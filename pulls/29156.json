{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29156",
    "id": 1660166793,
    "node_id": "PR_kwDOABII585i9CKJ",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/29156",
    "diff_url": "https://github.com/bitcoin/bitcoin/pull/29156.diff",
    "patch_url": "https://github.com/bitcoin/bitcoin/pull/29156.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/29156",
    "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29156/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29156/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/29156/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/aae032015367be812154a0e87955e6fd5ea5c192",
    "number": 29156,
    "state": "open",
    "locked": false,
    "maintainer_can_modify": true,
    "title": "tests: add functional test for miniscript decaying multisig",
    "user": {
      "login": "mjdietzx",
      "id": 7217256,
      "node_id": "MDQ6VXNlcjcyMTcyNTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7217256?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mjdietzx",
      "html_url": "https://github.com/mjdietzx",
      "followers_url": "https://api.github.com/users/mjdietzx/followers",
      "following_url": "https://api.github.com/users/mjdietzx/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/mjdietzx/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/mjdietzx/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/mjdietzx/subscriptions",
      "organizations_url": "https://api.github.com/users/mjdietzx/orgs",
      "repos_url": "https://api.github.com/users/mjdietzx/repos",
      "events_url": "https://api.github.com/users/mjdietzx/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/mjdietzx/received_events",
      "type": "User",
      "site_admin": false,
      "patch_url": null
    },
    "body": "This is very closely based on [test/functional/wallet_multisig_descriptor_psbt.py](https://github.com/bitcoin/bitcoin/blob/master/test/functional/wallet_multisig_descriptor_psbt.py) both in code and concept. It should serve as some integration testing for Miniscript descriptors, and also documents a simple multisig that starts as 4-of-4 and decays to 3-of-4, 2-of-4, and finally 1-of-4 at block heights (I think in the real world aligning this to halvenings would be nice).\r\n\r\n<!--\r\n*** Please remove the following help text before submitting: ***\r\n\r\nPull requests without a rationale and clear improvement may be closed\r\nimmediately.\r\n\r\nGUI-related pull requests should be opened against\r\nhttps://github.com/bitcoin-core/gui\r\nfirst. See CONTRIBUTING.md\r\n-->\r\n\r\n<!--\r\nPlease provide clear motivation for your patch and explain how it improves\r\nBitcoin Core user experience or Bitcoin Core developer experience\r\nsignificantly:\r\n\r\n* Any test improvements or new tests that improve coverage are always welcome.\r\n* All other changes should have accompanying unit tests (see `src/test/`) or\r\n  functional tests (see `test/`). Contributors should note which tests cover\r\n  modified code. If no tests exist for a region of modified code, new tests\r\n  should accompany the change.\r\n* Bug fixes are most welcome when they come with steps to reproduce or an\r\n  explanation of the potential issue as well as reasoning for the way the bug\r\n  was fixed.\r\n* Features are welcome, but might be rejected due to design or scope issues.\r\n  If a feature is based on a lot of dependencies, contributors should first\r\n  consider building the system outside of Bitcoin Core, if possible.\r\n* Refactoring changes are only accepted if they are required for a feature or\r\n  bug fix or otherwise improve developer experience significantly. For example,\r\n  most \"code style\" refactoring changes require a thorough explanation why they\r\n  are useful, what downsides they have and why they *significantly* improve\r\n  developer experience or avoid serious programming bugs. Note that code style\r\n  is often a subjective matter. Unless they are explicitly mentioned to be\r\n  preferred in the [developer notes](/doc/developer-notes.md), stylistic code\r\n  changes are usually rejected.\r\n-->\r\n\r\n<!--\r\nBitcoin Core has a thorough review process and even the most trivial change\r\nneeds to pass a lot of eyes and requires non-zero or even substantial time\r\neffort to review. There is a huge lack of active reviewers on the project, so\r\npatches often sit for a long time.\r\n-->\r\n",
    "labels": [
      {
        "id": 62963516,
        "node_id": "MDU6TGFiZWw2Mjk2MzUxNg==",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Tests",
        "name": "Tests",
        "color": "d4c5f9",
        "default": false
      },
      {
        "id": 5334691551,
        "node_id": "LA_kwDOABII588AAAABPfju3w",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/CI%20failed",
        "name": "CI failed",
        "description": "",
        "color": "cccccc",
        "default": false
      }
    ],
    "created_at": "2023-12-29T21:27:28Z",
    "updated_at": "2025-01-22T05:31:18Z",
    "mergeable": true,
    "mergeable_state": "blocked",
    "merge_commit_sha": "eebe405ec6a3828c06879c77a13b83d8f67676e8",
    "assignees": [],
    "requested_reviewers": [
      {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    ],
    "requested_teams": [],
    "rebaseable": true,
    "head": {
      "label": "mjdietzx:test_miniscript_decaying_multiscript_descriptor",
      "ref": "test_miniscript_decaying_multiscript_descriptor",
      "sha": "aae032015367be812154a0e87955e6fd5ea5c192",
      "user": {
        "login": "mjdietzx",
        "id": 7217256,
        "node_id": "MDQ6VXNlcjcyMTcyNTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7217256?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mjdietzx",
        "html_url": "https://github.com/mjdietzx",
        "followers_url": "https://api.github.com/users/mjdietzx/followers",
        "following_url": "https://api.github.com/users/mjdietzx/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mjdietzx/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mjdietzx/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mjdietzx/subscriptions",
        "organizations_url": "https://api.github.com/users/mjdietzx/orgs",
        "repos_url": "https://api.github.com/users/mjdietzx/repos",
        "events_url": "https://api.github.com/users/mjdietzx/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mjdietzx/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "repo": {
        "id": 308407734,
        "node_id": "MDEwOlJlcG9zaXRvcnkzMDg0MDc3MzQ=",
        "name": "bitcoin",
        "full_name": "mjdietzx/bitcoin",
        "owner": {
          "login": "mjdietzx",
          "id": 7217256,
          "node_id": "MDQ6VXNlcjcyMTcyNTY=",
          "avatar_url": "https://avatars.githubusercontent.com/u/7217256?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/mjdietzx",
          "html_url": "https://github.com/mjdietzx",
          "followers_url": "https://api.github.com/users/mjdietzx/followers",
          "following_url": "https://api.github.com/users/mjdietzx/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/mjdietzx/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/mjdietzx/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/mjdietzx/subscriptions",
          "organizations_url": "https://api.github.com/users/mjdietzx/orgs",
          "repos_url": "https://api.github.com/users/mjdietzx/repos",
          "events_url": "https://api.github.com/users/mjdietzx/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/mjdietzx/received_events",
          "type": "User",
          "site_admin": false,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/mjdietzx/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": true,
        "url": "https://api.github.com/repos/mjdietzx/bitcoin",
        "archive_url": "https://api.github.com/repos/mjdietzx/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/mjdietzx/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/mjdietzx/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/mjdietzx/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/mjdietzx/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/mjdietzx/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/mjdietzx/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/mjdietzx/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/mjdietzx/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/mjdietzx/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/mjdietzx/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/mjdietzx/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/mjdietzx/bitcoin/events",
        "forks_url": "https://api.github.com/repos/mjdietzx/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/mjdietzx/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/mjdietzx/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/mjdietzx/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/mjdietzx/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/mjdietzx/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/mjdietzx/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/mjdietzx/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/mjdietzx/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/mjdietzx/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/mjdietzx/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/mjdietzx/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/mjdietzx/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/mjdietzx/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/mjdietzx/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/mjdietzx/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:mjdietzx/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/mjdietzx/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/mjdietzx/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/mjdietzx/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/mjdietzx/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/mjdietzx/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/mjdietzx/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/mjdietzx/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/mjdietzx/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/mjdietzx/bitcoin/hooks",
        "svn_url": "https://github.com/mjdietzx/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 0,
        "stargazers_count": 0,
        "watchers_count": 0,
        "size": 256912,
        "default_branch": "master",
        "open_issues_count": 0,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2024-12-03T20:12:54Z",
        "created_at": "2020-10-29T17:53:38Z",
        "updated_at": "2023-12-29T20:48:36Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "8e02b480591008c457cc841050f6f755ff54fcba",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false,
        "patch_url": null
      },
      "repo": {
        "id": 1181927,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTgxOTI3",
        "name": "bitcoin",
        "full_name": "bitcoin/bitcoin",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bitcoin",
        "archive_url": "https://api.github.com/repos/bitcoin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bitcoin/hooks",
        "svn_url": "https://github.com/bitcoin/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 36585,
        "stargazers_count": 81554,
        "watchers_count": 81554,
        "size": 274398,
        "default_branch": "master",
        "open_issues_count": 698,
        "is_template": false,
        "topics": [
          "bitcoin",
          "c-plus-plus",
          "cryptocurrency",
          "cryptography",
          "p2p"
        ],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2025-01-21T17:04:41Z",
        "created_at": "2010-12-19T15:16:43Z",
        "updated_at": "2025-01-22T05:09:02Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29156"
      }
    },
    "author_association": "CONTRIBUTOR",
    "draft": false,
    "additions": 150,
    "deletions": 0,
    "changed_files": 3,
    "commits": 1,
    "review_comments": 37,
    "comments": 20
  },
  "events": [
    {
      "event": "commented",
      "id": 1872345837,
      "node_id": "IC_kwDOABII585vmbrt",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1872345837",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-12-29T21:27:31Z",
      "updated_at": "2025-01-22T05:31:18Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage & Benchmarks\nFor details see: https://corecheck.dev/bitcoin/bitcoin/pulls/29156.\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| ACK | [rkrux](https://github.com/bitcoin/bitcoin/pull/29156#pullrequestreview-2488750053) |\n| Concept ACK | [michaelfolkson](https://github.com/bitcoin/bitcoin/pull/29156#issuecomment-1882786231), [epiccurious](https://github.com/bitcoin/bitcoin/pull/29156#issuecomment-1937402710), [RandyMcMillan](https://github.com/bitcoin/bitcoin/pull/29156#issuecomment-2081684905) |\n| Stale ACK | [kevkevinpal](https://github.com/bitcoin/bitcoin/pull/29156#issuecomment-1882243654), [Eunovo](https://github.com/bitcoin/bitcoin/pull/29156#issuecomment-1888973157) |\n\nIf your review is incorrectly listed, please react with 👎 to this comment and the bot will ignore it on the next update.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#31250](https://github.com/bitcoin/bitcoin/pull/31250) (wallet: Disable creating and loading legacy wallets by achow101)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29156#issuecomment-1872345837",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/29156"
    },
    {
      "event": "labeled",
      "id": 11358717338,
      "node_id": "LE_lADOABII5856z2OlzwAAAAKlCEWa",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11358717338",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-12-29T21:27:33Z",
      "label": {
        "name": "Tests",
        "color": "d4c5f9"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 11358727144,
      "node_id": "HRFPE_lADOABII5856z2OlzwAAAAKlCGvo",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11358727144",
      "actor": {
        "login": "mjdietzx",
        "id": 7217256,
        "node_id": "MDQ6VXNlcjcyMTcyNTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7217256?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mjdietzx",
        "html_url": "https://github.com/mjdietzx",
        "followers_url": "https://api.github.com/users/mjdietzx/followers",
        "following_url": "https://api.github.com/users/mjdietzx/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mjdietzx/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mjdietzx/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mjdietzx/subscriptions",
        "organizations_url": "https://api.github.com/users/mjdietzx/orgs",
        "repos_url": "https://api.github.com/users/mjdietzx/repos",
        "events_url": "https://api.github.com/users/mjdietzx/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mjdietzx/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "4838e2e58f4926cd5f784209e87e3de3e317d028",
      "commit_url": "https://api.github.com/repos/mjdietzx/bitcoin/commits/4838e2e58f4926cd5f784209e87e3de3e317d028",
      "created_at": "2023-12-29T21:31:49Z"
    },
    {
      "event": "labeled",
      "id": 11358729058,
      "node_id": "LE_lADOABII5856z2OlzwAAAAKlCHNi",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11358729058",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-12-29T21:32:36Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "unlabeled",
      "id": 11358925144,
      "node_id": "UNLE_lADOABII5856z2OlzwAAAAKlC3FY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11358925144",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-12-29T22:47:54Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 11360408452,
      "node_id": "HRFPE_lADOABII5856z2OlzwAAAAKlIhOE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11360408452",
      "actor": {
        "login": "mjdietzx",
        "id": 7217256,
        "node_id": "MDQ6VXNlcjcyMTcyNTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7217256?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mjdietzx",
        "html_url": "https://github.com/mjdietzx",
        "followers_url": "https://api.github.com/users/mjdietzx/followers",
        "following_url": "https://api.github.com/users/mjdietzx/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mjdietzx/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mjdietzx/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mjdietzx/subscriptions",
        "organizations_url": "https://api.github.com/users/mjdietzx/orgs",
        "repos_url": "https://api.github.com/users/mjdietzx/repos",
        "events_url": "https://api.github.com/users/mjdietzx/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mjdietzx/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "2422b90978f4ea13ee49954598dc8aef841e36df",
      "commit_url": "https://api.github.com/repos/mjdietzx/bitcoin/commits/2422b90978f4ea13ee49954598dc8aef841e36df",
      "created_at": "2023-12-30T19:34:34Z"
    },
    {
      "event": "commented",
      "id": 1879749727,
      "node_id": "IC_kwDOABII585wCrRf",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1879749727",
      "actor": {
        "login": "kevkevinpal",
        "id": 15950706,
        "node_id": "MDQ6VXNlcjE1OTUwNzA2",
        "avatar_url": "https://avatars.githubusercontent.com/u/15950706?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kevkevinpal",
        "html_url": "https://github.com/kevkevinpal",
        "followers_url": "https://api.github.com/users/kevkevinpal/followers",
        "following_url": "https://api.github.com/users/kevkevinpal/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kevkevinpal/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kevkevinpal/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kevkevinpal/subscriptions",
        "organizations_url": "https://api.github.com/users/kevkevinpal/orgs",
        "repos_url": "https://api.github.com/users/kevkevinpal/repos",
        "events_url": "https://api.github.com/users/kevkevinpal/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kevkevinpal/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-06T16:36:27Z",
      "updated_at": "2024-01-06T16:36:27Z",
      "author_association": "CONTRIBUTOR",
      "body": "PR description link is routes to 404 can you update to use this https://github.com/bitcoin/bitcoin/blob/master/test/functional/wallet_multisig_descriptor_psbt.py instead?",
      "user": {
        "login": "kevkevinpal",
        "id": 15950706,
        "node_id": "MDQ6VXNlcjE1OTUwNzA2",
        "avatar_url": "https://avatars.githubusercontent.com/u/15950706?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kevkevinpal",
        "html_url": "https://github.com/kevkevinpal",
        "followers_url": "https://api.github.com/users/kevkevinpal/followers",
        "following_url": "https://api.github.com/users/kevkevinpal/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kevkevinpal/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kevkevinpal/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kevkevinpal/subscriptions",
        "organizations_url": "https://api.github.com/users/kevkevinpal/orgs",
        "repos_url": "https://api.github.com/users/kevkevinpal/repos",
        "events_url": "https://api.github.com/users/kevkevinpal/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kevkevinpal/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29156#issuecomment-1879749727",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/29156"
    },
    {
      "event": "commented",
      "id": 1880357066,
      "node_id": "IC_kwDOABII585wE_jK",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1880357066",
      "actor": {
        "login": "kevkevinpal",
        "id": 15950706,
        "node_id": "MDQ6VXNlcjE1OTUwNzA2",
        "avatar_url": "https://avatars.githubusercontent.com/u/15950706?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kevkevinpal",
        "html_url": "https://github.com/kevkevinpal",
        "followers_url": "https://api.github.com/users/kevkevinpal/followers",
        "following_url": "https://api.github.com/users/kevkevinpal/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kevkevinpal/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kevkevinpal/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kevkevinpal/subscriptions",
        "organizations_url": "https://api.github.com/users/kevkevinpal/orgs",
        "repos_url": "https://api.github.com/users/kevkevinpal/repos",
        "events_url": "https://api.github.com/users/kevkevinpal/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kevkevinpal/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-08T04:05:07Z",
      "updated_at": "2024-01-08T04:05:07Z",
      "author_association": "CONTRIBUTOR",
      "body": "Concept ACK [2422b90](https://github.com/bitcoin/bitcoin/pull/29156/commits/2422b90978f4ea13ee49954598dc8aef841e36df)\r\n\r\nI've done a little code review and so far it is looking good, I think it would be cool if instead of always using the pubkeys in the same order when decaying we could randomly use different signers, I just quickly tested it worked the other way around with this diff (not sure how you feel about adding this randomness)\r\n\r\n```\r\n             for m in range(self.M):\r\n-                signers_multisig = participants[\"multisigs\"][m]\r\n+                self.log.info(self.N - 1 - m)\r\n+                signers_multisig = participants[\"multisigs\"][self.N - 1 - m]\r\n                 self._check_psbt(psbt[\"psbt\"], to, value, signers_multisig)\r\n-                signing_wallet = participants[\"signers\"][m]\r\n+                signing_wallet = participants[\"signers\"][self.N - 1 - m]\r\n                 psbt = signing_wallet.walletprocesspsbt(psbt[\"psbt\"])\r\n```\r\n\r\nThat way we can assert that any of the keys can create the 4/4 3/4 2/4 and 1/4\r\n\r\nAlso, one thing I am unsure of is if we should include this test in `test/functional/wallet_multisig_descriptor_psbt.py` since they are very similar and maybe we can use common functions but I am not sure what will be the cleanest",
      "user": {
        "login": "kevkevinpal",
        "id": 15950706,
        "node_id": "MDQ6VXNlcjE1OTUwNzA2",
        "avatar_url": "https://avatars.githubusercontent.com/u/15950706?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kevkevinpal",
        "html_url": "https://github.com/kevkevinpal",
        "followers_url": "https://api.github.com/users/kevkevinpal/followers",
        "following_url": "https://api.github.com/users/kevkevinpal/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kevkevinpal/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kevkevinpal/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kevkevinpal/subscriptions",
        "organizations_url": "https://api.github.com/users/kevkevinpal/orgs",
        "repos_url": "https://api.github.com/users/kevkevinpal/repos",
        "events_url": "https://api.github.com/users/kevkevinpal/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kevkevinpal/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29156#issuecomment-1880357066",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/29156"
    },
    {
      "event": "commented",
      "id": 1881518666,
      "node_id": "IC_kwDOABII585wJbJK",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1881518666",
      "actor": {
        "login": "mjdietzx",
        "id": 7217256,
        "node_id": "MDQ6VXNlcjcyMTcyNTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7217256?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mjdietzx",
        "html_url": "https://github.com/mjdietzx",
        "followers_url": "https://api.github.com/users/mjdietzx/followers",
        "following_url": "https://api.github.com/users/mjdietzx/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mjdietzx/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mjdietzx/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mjdietzx/subscriptions",
        "organizations_url": "https://api.github.com/users/mjdietzx/orgs",
        "repos_url": "https://api.github.com/users/mjdietzx/repos",
        "events_url": "https://api.github.com/users/mjdietzx/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mjdietzx/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-08T17:24:15Z",
      "updated_at": "2024-01-08T17:24:15Z",
      "author_association": "CONTRIBUTOR",
      "body": "Thank you for the review, and good idea @kevkevinpal!\r\n\r\n>  I think it would be cool if instead of always using the pubkeys in the same order when decaying we could randomly use different signers\r\n\r\nI added a 2nd commit to this PR with your suggestion. In a similar spirit I improved #29154 (also adding a 2nd commit with your suggestion, and in that case we can also assert that order of xpubs in the multisig descriptors don't matter since it is `sorted`).\r\n\r\n> Also, one thing I am unsure of is if we should include this test in test/functional/wallet_multisig_descriptor_psbt.py since they are very similar and maybe we can use common functions but I am not sure what will be the cleanest\r\n\r\nI don't think it would be too much trouble to combine them, but I didn't go that route because my opinion is that some code duplication is preferable to trying to generalize/combine these tests. So I went the route of keeping these as two simple independent integration tests. I don't have a strong opinion on this, but usually for test code like this I lean towards approach I took where I duplicate some code to favor simple and easy to explain/delete tests. If more people feel strongly one way or the other I'm happy to change though",
      "user": {
        "login": "mjdietzx",
        "id": 7217256,
        "node_id": "MDQ6VXNlcjcyMTcyNTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7217256?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mjdietzx",
        "html_url": "https://github.com/mjdietzx",
        "followers_url": "https://api.github.com/users/mjdietzx/followers",
        "following_url": "https://api.github.com/users/mjdietzx/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mjdietzx/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mjdietzx/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mjdietzx/subscriptions",
        "organizations_url": "https://api.github.com/users/mjdietzx/orgs",
        "repos_url": "https://api.github.com/users/mjdietzx/repos",
        "events_url": "https://api.github.com/users/mjdietzx/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mjdietzx/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29156#issuecomment-1881518666",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/29156"
    },
    {
      "event": "mentioned",
      "id": 11420536061,
      "node_id": "MEE_lADOABII5856z2OlzwAAAAKot4z9",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11420536061",
      "actor": {
        "login": "kevkevinpal",
        "id": 15950706,
        "node_id": "MDQ6VXNlcjE1OTUwNzA2",
        "avatar_url": "https://avatars.githubusercontent.com/u/15950706?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kevkevinpal",
        "html_url": "https://github.com/kevkevinpal",
        "followers_url": "https://api.github.com/users/kevkevinpal/followers",
        "following_url": "https://api.github.com/users/kevkevinpal/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kevkevinpal/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kevkevinpal/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kevkevinpal/subscriptions",
        "organizations_url": "https://api.github.com/users/kevkevinpal/orgs",
        "repos_url": "https://api.github.com/users/kevkevinpal/repos",
        "events_url": "https://api.github.com/users/kevkevinpal/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kevkevinpal/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-08T17:24:15Z"
    },
    {
      "event": "subscribed",
      "id": 11420536082,
      "node_id": "SE_lADOABII5856z2OlzwAAAAKot40S",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11420536082",
      "actor": {
        "login": "kevkevinpal",
        "id": 15950706,
        "node_id": "MDQ6VXNlcjE1OTUwNzA2",
        "avatar_url": "https://avatars.githubusercontent.com/u/15950706?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kevkevinpal",
        "html_url": "https://github.com/kevkevinpal",
        "followers_url": "https://api.github.com/users/kevkevinpal/followers",
        "following_url": "https://api.github.com/users/kevkevinpal/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kevkevinpal/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kevkevinpal/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kevkevinpal/subscriptions",
        "organizations_url": "https://api.github.com/users/kevkevinpal/orgs",
        "repos_url": "https://api.github.com/users/kevkevinpal/repos",
        "events_url": "https://api.github.com/users/kevkevinpal/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kevkevinpal/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-08T17:24:15Z"
    },
    {
      "event": "commented",
      "id": 1882243654,
      "node_id": "IC_kwDOABII585wMMJG",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1882243654",
      "actor": {
        "login": "kevkevinpal",
        "id": 15950706,
        "node_id": "MDQ6VXNlcjE1OTUwNzA2",
        "avatar_url": "https://avatars.githubusercontent.com/u/15950706?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kevkevinpal",
        "html_url": "https://github.com/kevkevinpal",
        "followers_url": "https://api.github.com/users/kevkevinpal/followers",
        "following_url": "https://api.github.com/users/kevkevinpal/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kevkevinpal/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kevkevinpal/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kevkevinpal/subscriptions",
        "organizations_url": "https://api.github.com/users/kevkevinpal/orgs",
        "repos_url": "https://api.github.com/users/kevkevinpal/repos",
        "events_url": "https://api.github.com/users/kevkevinpal/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kevkevinpal/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-09T02:42:04Z",
      "updated_at": "2024-01-09T02:42:04Z",
      "author_association": "CONTRIBUTOR",
      "body": "ACK [7f0be89](https://github.com/bitcoin/bitcoin/pull/29156/commits/7f0be8969e721de69fc352f76db5787836803b76)",
      "user": {
        "login": "kevkevinpal",
        "id": 15950706,
        "node_id": "MDQ6VXNlcjE1OTUwNzA2",
        "avatar_url": "https://avatars.githubusercontent.com/u/15950706?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kevkevinpal",
        "html_url": "https://github.com/kevkevinpal",
        "followers_url": "https://api.github.com/users/kevkevinpal/followers",
        "following_url": "https://api.github.com/users/kevkevinpal/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kevkevinpal/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kevkevinpal/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kevkevinpal/subscriptions",
        "organizations_url": "https://api.github.com/users/kevkevinpal/orgs",
        "repos_url": "https://api.github.com/users/kevkevinpal/repos",
        "events_url": "https://api.github.com/users/kevkevinpal/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kevkevinpal/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29156#issuecomment-1882243654",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/29156"
    },
    {
      "event": "commented",
      "id": 1882786231,
      "node_id": "IC_kwDOABII585wOQm3",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1882786231",
      "actor": {
        "login": "michaelfolkson",
        "id": 16323900,
        "node_id": "MDQ6VXNlcjE2MzIzOTAw",
        "avatar_url": "https://avatars.githubusercontent.com/u/16323900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/michaelfolkson",
        "html_url": "https://github.com/michaelfolkson",
        "followers_url": "https://api.github.com/users/michaelfolkson/followers",
        "following_url": "https://api.github.com/users/michaelfolkson/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/michaelfolkson/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/michaelfolkson/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/michaelfolkson/subscriptions",
        "organizations_url": "https://api.github.com/users/michaelfolkson/orgs",
        "repos_url": "https://api.github.com/users/michaelfolkson/repos",
        "events_url": "https://api.github.com/users/michaelfolkson/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/michaelfolkson/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-09T10:16:32Z",
      "updated_at": "2024-01-09T10:16:32Z",
      "author_association": "CONTRIBUTOR",
      "body": "Concept ACK\r\n\r\nA couple of things on first skim read.\r\n\r\n1) I think it is probably overkill to create a new functional test file for this. I'm not sure why it can't go in `wallet_miniscript.py`?\r\n\r\n2) Miniscript has always been described by its authors/contributors as an extension of descriptors. I personally wouldn't be against adding some Miniscript explanation, examples in `descriptors.md` but I'd want a short explanation of what Miniscript is making it clear that this decaying multisig example is enabled by Miniscript and not just added to the list of descriptor examples. Maybe longer term there should be a `miniscript.md` but for now that seems fine to me.",
      "user": {
        "login": "michaelfolkson",
        "id": 16323900,
        "node_id": "MDQ6VXNlcjE2MzIzOTAw",
        "avatar_url": "https://avatars.githubusercontent.com/u/16323900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/michaelfolkson",
        "html_url": "https://github.com/michaelfolkson",
        "followers_url": "https://api.github.com/users/michaelfolkson/followers",
        "following_url": "https://api.github.com/users/michaelfolkson/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/michaelfolkson/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/michaelfolkson/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/michaelfolkson/subscriptions",
        "organizations_url": "https://api.github.com/users/michaelfolkson/orgs",
        "repos_url": "https://api.github.com/users/michaelfolkson/repos",
        "events_url": "https://api.github.com/users/michaelfolkson/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/michaelfolkson/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29156#issuecomment-1882786231",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/29156"
    },
    {
      "event": "commented",
      "id": 1888973157,
      "node_id": "IC_kwDOABII585wl3Fl",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1888973157",
      "actor": {
        "login": "Eunovo",
        "id": 37949128,
        "node_id": "MDQ6VXNlcjM3OTQ5MTI4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37949128?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Eunovo",
        "html_url": "https://github.com/Eunovo",
        "followers_url": "https://api.github.com/users/Eunovo/followers",
        "following_url": "https://api.github.com/users/Eunovo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Eunovo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Eunovo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Eunovo/subscriptions",
        "organizations_url": "https://api.github.com/users/Eunovo/orgs",
        "repos_url": "https://api.github.com/users/Eunovo/repos",
        "events_url": "https://api.github.com/users/Eunovo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Eunovo/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-12T11:53:58Z",
      "updated_at": "2024-01-12T11:53:58Z",
      "author_association": "NONE",
      "body": "ACK [7f0be89](https://github.com/bitcoin/bitcoin/pull/29156/commits/7f0be8969e721de69fc352f76db5787836803b76)\r\n\r\nAdding an example for this to descriptors.md is really helpful but I think users who are unfamiliar with miniscript and descriptors might benefit from the addition of the fragments, `thresh` and `after` to the `Reference` section. Seeing these fragments used in the examples but not included the reference can introduce confusion.",
      "user": {
        "login": "Eunovo",
        "id": 37949128,
        "node_id": "MDQ6VXNlcjM3OTQ5MTI4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37949128?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Eunovo",
        "html_url": "https://github.com/Eunovo",
        "followers_url": "https://api.github.com/users/Eunovo/followers",
        "following_url": "https://api.github.com/users/Eunovo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Eunovo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Eunovo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Eunovo/subscriptions",
        "organizations_url": "https://api.github.com/users/Eunovo/orgs",
        "repos_url": "https://api.github.com/users/Eunovo/repos",
        "events_url": "https://api.github.com/users/Eunovo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Eunovo/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29156#issuecomment-1888973157",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/29156"
    },
    {
      "event": "commented",
      "id": 1889653618,
      "node_id": "IC_kwDOABII585wodNy",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1889653618",
      "actor": {
        "login": "Eunovo",
        "id": 37949128,
        "node_id": "MDQ6VXNlcjM3OTQ5MTI4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37949128?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Eunovo",
        "html_url": "https://github.com/Eunovo",
        "followers_url": "https://api.github.com/users/Eunovo/followers",
        "following_url": "https://api.github.com/users/Eunovo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Eunovo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Eunovo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Eunovo/subscriptions",
        "organizations_url": "https://api.github.com/users/Eunovo/orgs",
        "repos_url": "https://api.github.com/users/Eunovo/repos",
        "events_url": "https://api.github.com/users/Eunovo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Eunovo/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-12T17:02:19Z",
      "updated_at": "2024-01-12T17:02:19Z",
      "author_association": "NONE",
      "body": "I tested this locally and I've observed that the test doesn't fail if you modify the external wallet's timelocks, see below:\r\n`external = multisig.getdescriptorinfo(f\"wsh(thresh({self.N},pk({f'),s:pk('.join(external_xpubs)}),sln:after(128)))\")`\r\nThe reason is that the test only sends from the external wallet once using all keys and the transactions that use the `locktimes` send from the internal wallet because that's where the funds are. Hence, changing the timelocks for the external descriptor doesn't break the test.\r\n\r\nI'm not sure if we care about this or not but fixing this is pretty simple, we just need to create a transaction that uses 3-of-4 keys and the first timelock and sends from the external wallet. The easiest way to do this is to modify the first transaction in the test. See sample code below:\r\n```\r\nself.generate(self.nodes[0], self.locktimes[0])\r\nself.sync_blocks()\r\nself.log.info(\"First, make a sending transaction, created using `walletcreatefundedpsbt` (anyone can initiate this)...\")\r\npsbt = participants[\"multisigs\"][0].walletcreatefundedpsbt(inputs=[], outputs={to: value}, feeRate=0.00010, locktime=self.locktimes[0])\r\n\r\npsbts = []\r\nself.log.info(\"Now at least M users check the psbt with decodepsbt and (if OK) signs it with walletprocesspsbt...\")\r\nfor m in random.sample(range(self.M), self.M - 1):\r\n    signers_multisig = participants[\"multisigs\"][m]\r\n    self._check_psbt(psbt[\"psbt\"], to, value, signers_multisig)\r\n    signing_wallet = participants[\"signers\"][m]\r\n    partially_signed_psbt = signing_wallet.walletprocesspsbt(psbt[\"psbt\"])\r\n    psbts.append(partially_signed_psbt[\"psbt\"])\r\n\r\nself.log.info(\"Finally, collect the signed PSBTs with combinepsbt, finalizepsbt, then broadcast the resulting transaction...\")\r\ncombined = coordinator_wallet.combinepsbt(psbts)\r\nfinalized = coordinator_wallet.finalizepsbt(combined)\r\ncoordinator_wallet.sendrawtransaction(finalized[\"hex\"])\r\n```",
      "user": {
        "login": "Eunovo",
        "id": 37949128,
        "node_id": "MDQ6VXNlcjM3OTQ5MTI4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37949128?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Eunovo",
        "html_url": "https://github.com/Eunovo",
        "followers_url": "https://api.github.com/users/Eunovo/followers",
        "following_url": "https://api.github.com/users/Eunovo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Eunovo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Eunovo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Eunovo/subscriptions",
        "organizations_url": "https://api.github.com/users/Eunovo/orgs",
        "repos_url": "https://api.github.com/users/Eunovo/repos",
        "events_url": "https://api.github.com/users/Eunovo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Eunovo/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29156#issuecomment-1889653618",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/29156"
    },
    {
      "event": "commented",
      "id": 1889791034,
      "node_id": "IC_kwDOABII585wo-w6",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1889791034",
      "actor": {
        "login": "mjdietzx",
        "id": 7217256,
        "node_id": "MDQ6VXNlcjcyMTcyNTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7217256?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mjdietzx",
        "html_url": "https://github.com/mjdietzx",
        "followers_url": "https://api.github.com/users/mjdietzx/followers",
        "following_url": "https://api.github.com/users/mjdietzx/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mjdietzx/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mjdietzx/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mjdietzx/subscriptions",
        "organizations_url": "https://api.github.com/users/mjdietzx/orgs",
        "repos_url": "https://api.github.com/users/mjdietzx/repos",
        "events_url": "https://api.github.com/users/mjdietzx/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mjdietzx/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-12T18:49:24Z",
      "updated_at": "2024-01-12T18:51:04Z",
      "author_association": "CONTRIBUTOR",
      "body": "Thank you @michaelfolkson and @Eunovo for the reviews! I agree with both of your feedback re improving `descriptors.md` docs to accompany this test. I will have a commit addressing your feedback in the coming days.\r\n\r\n> I think it is probably overkill to create a new functional test file for this. I'm not sure why it can't go in wallet_miniscript.py\r\n\r\nMy intention with this test is to provide a \"reference example\" with the same motivations and flow/architecture as #22067 (and the original issue #21278 it resolved). But taking this one step further with a \"decaying\" multisig that highlights \"Miniscript as an extension of descriptors\" and showing the same multisig architecture and signing flows \"just work\" when we utilize Miniscript.\r\n\r\nTo your point - the additional raw test coverage this provides is limited, and if anything could be accomplished in `wallet_miniscript.py`. So if a \"reference example\" that tests end-to-end functionality of a wallet like this at a high-level (and more from a user perspective) isn't valuable then this is overkill and is not needed.\r\n\r\nI think once I follow up with docs this intention will be clear. Then we can see if this additional test is useful or overkill.\r\n\r\n> modify(ing) the external wallet's timelocks\r\n\r\n@Eunovo interesting observation! We could also break up the initial deposit into multiple utxos so that we aren't only spending change after the first transaction. I played around with it locally after thinking through your writeup, but I'm leaning towards not modifying the test to try to assert this failure. Partly because modifying the external descriptor to differ from internal would be a _different wallet_ conceptually than what I have here. Ideally #22838 would be merged and I'd be using those semantics in this test and then it's even more clear that external and internal wallets should only differ in derivation path\r\n\r\nRegardless, it's cool you thought of this. For a similar wallet that uses relative time locks instead of absolute, this would be even weirder. Because the same concept could lead to the change of a spendable utxo being unspendable for a time.",
      "user": {
        "login": "mjdietzx",
        "id": 7217256,
        "node_id": "MDQ6VXNlcjcyMTcyNTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7217256?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mjdietzx",
        "html_url": "https://github.com/mjdietzx",
        "followers_url": "https://api.github.com/users/mjdietzx/followers",
        "following_url": "https://api.github.com/users/mjdietzx/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mjdietzx/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mjdietzx/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mjdietzx/subscriptions",
        "organizations_url": "https://api.github.com/users/mjdietzx/orgs",
        "repos_url": "https://api.github.com/users/mjdietzx/repos",
        "events_url": "https://api.github.com/users/mjdietzx/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mjdietzx/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29156#issuecomment-1889791034",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/29156"
    },
    {
      "event": "mentioned",
      "id": 11472685484,
      "node_id": "MEE_lADOABII5856z2OlzwAAAAKr00ms",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11472685484",
      "actor": {
        "login": "michaelfolkson",
        "id": 16323900,
        "node_id": "MDQ6VXNlcjE2MzIzOTAw",
        "avatar_url": "https://avatars.githubusercontent.com/u/16323900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/michaelfolkson",
        "html_url": "https://github.com/michaelfolkson",
        "followers_url": "https://api.github.com/users/michaelfolkson/followers",
        "following_url": "https://api.github.com/users/michaelfolkson/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/michaelfolkson/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/michaelfolkson/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/michaelfolkson/subscriptions",
        "organizations_url": "https://api.github.com/users/michaelfolkson/orgs",
        "repos_url": "https://api.github.com/users/michaelfolkson/repos",
        "events_url": "https://api.github.com/users/michaelfolkson/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/michaelfolkson/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-12T18:49:24Z"
    },
    {
      "event": "subscribed",
      "id": 11472685494,
      "node_id": "SE_lADOABII5856z2OlzwAAAAKr00m2",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11472685494",
      "actor": {
        "login": "michaelfolkson",
        "id": 16323900,
        "node_id": "MDQ6VXNlcjE2MzIzOTAw",
        "avatar_url": "https://avatars.githubusercontent.com/u/16323900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/michaelfolkson",
        "html_url": "https://github.com/michaelfolkson",
        "followers_url": "https://api.github.com/users/michaelfolkson/followers",
        "following_url": "https://api.github.com/users/michaelfolkson/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/michaelfolkson/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/michaelfolkson/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/michaelfolkson/subscriptions",
        "organizations_url": "https://api.github.com/users/michaelfolkson/orgs",
        "repos_url": "https://api.github.com/users/michaelfolkson/repos",
        "events_url": "https://api.github.com/users/michaelfolkson/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/michaelfolkson/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-12T18:49:24Z"
    },
    {
      "event": "mentioned",
      "id": 11472685506,
      "node_id": "MEE_lADOABII5856z2OlzwAAAAKr00nC",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11472685506",
      "actor": {
        "login": "Eunovo",
        "id": 37949128,
        "node_id": "MDQ6VXNlcjM3OTQ5MTI4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37949128?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Eunovo",
        "html_url": "https://github.com/Eunovo",
        "followers_url": "https://api.github.com/users/Eunovo/followers",
        "following_url": "https://api.github.com/users/Eunovo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Eunovo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Eunovo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Eunovo/subscriptions",
        "organizations_url": "https://api.github.com/users/Eunovo/orgs",
        "repos_url": "https://api.github.com/users/Eunovo/repos",
        "events_url": "https://api.github.com/users/Eunovo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Eunovo/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-12T18:49:24Z"
    },
    {
      "event": "subscribed",
      "id": 11472685515,
      "node_id": "SE_lADOABII5856z2OlzwAAAAKr00nL",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11472685515",
      "actor": {
        "login": "Eunovo",
        "id": 37949128,
        "node_id": "MDQ6VXNlcjM3OTQ5MTI4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37949128?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Eunovo",
        "html_url": "https://github.com/Eunovo",
        "followers_url": "https://api.github.com/users/Eunovo/followers",
        "following_url": "https://api.github.com/users/Eunovo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Eunovo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Eunovo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Eunovo/subscriptions",
        "organizations_url": "https://api.github.com/users/Eunovo/orgs",
        "repos_url": "https://api.github.com/users/Eunovo/repos",
        "events_url": "https://api.github.com/users/Eunovo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Eunovo/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-12T18:49:24Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 11478449643,
      "node_id": "HRFPE_lADOABII5856z2OlzwAAAAKsKz3r",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11478449643",
      "actor": {
        "login": "mjdietzx",
        "id": 7217256,
        "node_id": "MDQ6VXNlcjcyMTcyNTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7217256?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mjdietzx",
        "html_url": "https://github.com/mjdietzx",
        "followers_url": "https://api.github.com/users/mjdietzx/followers",
        "following_url": "https://api.github.com/users/mjdietzx/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mjdietzx/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mjdietzx/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mjdietzx/subscriptions",
        "organizations_url": "https://api.github.com/users/mjdietzx/orgs",
        "repos_url": "https://api.github.com/users/mjdietzx/repos",
        "events_url": "https://api.github.com/users/mjdietzx/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mjdietzx/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "7fa41e6112b50a45d047c8e559c3e522cc9ff2cc",
      "commit_url": "https://api.github.com/repos/mjdietzx/bitcoin/commits/7fa41e6112b50a45d047c8e559c3e522cc9ff2cc",
      "created_at": "2024-01-13T16:53:19Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 11479295254,
      "node_id": "HRFPE_lADOABII5856z2OlzwAAAAKsOCUW",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11479295254",
      "actor": {
        "login": "mjdietzx",
        "id": 7217256,
        "node_id": "MDQ6VXNlcjcyMTcyNTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7217256?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mjdietzx",
        "html_url": "https://github.com/mjdietzx",
        "followers_url": "https://api.github.com/users/mjdietzx/followers",
        "following_url": "https://api.github.com/users/mjdietzx/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mjdietzx/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mjdietzx/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mjdietzx/subscriptions",
        "organizations_url": "https://api.github.com/users/mjdietzx/orgs",
        "repos_url": "https://api.github.com/users/mjdietzx/repos",
        "events_url": "https://api.github.com/users/mjdietzx/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mjdietzx/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "5023b47e85161a0b35839ce03c7b5d55ff1cd4c1",
      "commit_url": "https://api.github.com/repos/mjdietzx/bitcoin/commits/5023b47e85161a0b35839ce03c7b5d55ff1cd4c1",
      "created_at": "2024-01-13T23:41:04Z"
    },
    {
      "event": "commented",
      "id": 1937402710,
      "node_id": "IC_kwDOABII585zemtW",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1937402710",
      "actor": {
        "login": "epiccurious",
        "id": 109078515,
        "node_id": "U_kgDOBoBn8w",
        "avatar_url": "https://avatars.githubusercontent.com/u/109078515?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/epiccurious",
        "html_url": "https://github.com/epiccurious",
        "followers_url": "https://api.github.com/users/epiccurious/followers",
        "following_url": "https://api.github.com/users/epiccurious/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/epiccurious/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/epiccurious/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/epiccurious/subscriptions",
        "organizations_url": "https://api.github.com/users/epiccurious/orgs",
        "repos_url": "https://api.github.com/users/epiccurious/repos",
        "events_url": "https://api.github.com/users/epiccurious/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/epiccurious/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-02-11T02:49:17Z",
      "updated_at": "2024-02-11T02:49:17Z",
      "author_association": "CONTRIBUTOR",
      "body": "Concept ACK 5023b47e85161a0b35839ce03c7b5d55ff1cd4c1.",
      "user": {
        "login": "epiccurious",
        "id": 109078515,
        "node_id": "U_kgDOBoBn8w",
        "avatar_url": "https://avatars.githubusercontent.com/u/109078515?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/epiccurious",
        "html_url": "https://github.com/epiccurious",
        "followers_url": "https://api.github.com/users/epiccurious/followers",
        "following_url": "https://api.github.com/users/epiccurious/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/epiccurious/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/epiccurious/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/epiccurious/subscriptions",
        "organizations_url": "https://api.github.com/users/epiccurious/orgs",
        "repos_url": "https://api.github.com/users/epiccurious/repos",
        "events_url": "https://api.github.com/users/epiccurious/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/epiccurious/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29156#issuecomment-1937402710",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/29156"
    },
    {
      "event": "commented",
      "id": 2045528359,
      "node_id": "IC_kwDOABII58557Ekn",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2045528359",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-09T15:48:10Z",
      "updated_at": "2024-04-09T15:48:10Z",
      "author_association": "MEMBER",
      "body": "> This is very closely based on [test/functional/wallet_multisig_descriptor_psbt.py](https://github.com/bitcoin/bitcoin/blob/master/test/functional/wallet_multisig_descriptor_psbt.py) both in code and concept.\r\n\r\nCan you articulate what meaningful difference there is?",
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29156#issuecomment-2045528359",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/29156"
    },
    {
      "event": "commented",
      "id": 2045667575,
      "node_id": "IC_kwDOABII58557mj3",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2045667575",
      "actor": {
        "login": "mjdietzx",
        "id": 7217256,
        "node_id": "MDQ6VXNlcjcyMTcyNTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7217256?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mjdietzx",
        "html_url": "https://github.com/mjdietzx",
        "followers_url": "https://api.github.com/users/mjdietzx/followers",
        "following_url": "https://api.github.com/users/mjdietzx/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mjdietzx/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mjdietzx/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mjdietzx/subscriptions",
        "organizations_url": "https://api.github.com/users/mjdietzx/orgs",
        "repos_url": "https://api.github.com/users/mjdietzx/repos",
        "events_url": "https://api.github.com/users/mjdietzx/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mjdietzx/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-09T16:58:25Z",
      "updated_at": "2024-04-09T16:58:25Z",
      "author_association": "CONTRIBUTOR",
      "body": "> Can you articulate what meaningful difference there is?\r\n\r\nTests a Miniscript descriptor and asserts that it behaves as expected at different block heights as the multisig's thresh of required signers decreases.\r\n\r\nI can't judge how meaningful that is or if it deserves a standalone test. As someone who checks in occasionally I needed to convince myself I can really throw Miniscript into a descriptor and the wallet will work/behave like I'm used to",
      "user": {
        "login": "mjdietzx",
        "id": 7217256,
        "node_id": "MDQ6VXNlcjcyMTcyNTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7217256?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mjdietzx",
        "html_url": "https://github.com/mjdietzx",
        "followers_url": "https://api.github.com/users/mjdietzx/followers",
        "following_url": "https://api.github.com/users/mjdietzx/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mjdietzx/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mjdietzx/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mjdietzx/subscriptions",
        "organizations_url": "https://api.github.com/users/mjdietzx/orgs",
        "repos_url": "https://api.github.com/users/mjdietzx/repos",
        "events_url": "https://api.github.com/users/mjdietzx/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mjdietzx/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29156#issuecomment-2045667575",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/29156"
    },
    {
      "event": "reviewed",
      "id": 1989661119,
      "node_id": "PRR_kwDOABII5852l9G_",
      "url": null,
      "actor": null,
      "commit_id": "5023b47e85161a0b35839ce03c7b5d55ff1cd4c1",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "mjdietzx",
        "id": 7217256,
        "node_id": "MDQ6VXNlcjcyMTcyNTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7217256?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mjdietzx",
        "html_url": "https://github.com/mjdietzx",
        "followers_url": "https://api.github.com/users/mjdietzx/followers",
        "following_url": "https://api.github.com/users/mjdietzx/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mjdietzx/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mjdietzx/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mjdietzx/subscriptions",
        "organizations_url": "https://api.github.com/users/mjdietzx/orgs",
        "repos_url": "https://api.github.com/users/mjdietzx/repos",
        "events_url": "https://api.github.com/users/mjdietzx/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mjdietzx/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29156#pullrequestreview-1989661119",
      "submitted_at": "2024-04-09T17:08:32Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29156"
    },
    {
      "event": "reviewed",
      "id": 1999196598,
      "node_id": "PRR_kwDOABII5853KVG2",
      "url": null,
      "actor": null,
      "commit_id": "5023b47e85161a0b35839ce03c7b5d55ff1cd4c1",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "body": "tACK [5023b47](https://github.com/bitcoin/bitcoin/pull/29156/commits/5023b47e85161a0b35839ce03c7b5d55ff1cd4c1)\r\n\r\nBuild and all functional tests successful. I like the clarity and the expressiveness with which this test has been written, and believe this is a good addition. Thanks for coming up with this @mjdietzx!\r\n\r\nSuggested adding a log message in the last portion of the test.",
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29156#pullrequestreview-1999196598",
      "submitted_at": "2024-04-13T09:07:58Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29156"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12459043615,
      "node_id": "HRFPE_lADOABII5856z2OlzwAAAALmnesf",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12459043615",
      "actor": {
        "login": "mjdietzx",
        "id": 7217256,
        "node_id": "MDQ6VXNlcjcyMTcyNTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7217256?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mjdietzx",
        "html_url": "https://github.com/mjdietzx",
        "followers_url": "https://api.github.com/users/mjdietzx/followers",
        "following_url": "https://api.github.com/users/mjdietzx/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mjdietzx/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mjdietzx/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mjdietzx/subscriptions",
        "organizations_url": "https://api.github.com/users/mjdietzx/orgs",
        "repos_url": "https://api.github.com/users/mjdietzx/repos",
        "events_url": "https://api.github.com/users/mjdietzx/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mjdietzx/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "296bbf8ef2044306e5749302a26e9aa7f7eca060",
      "commit_url": "https://api.github.com/repos/mjdietzx/bitcoin/commits/296bbf8ef2044306e5749302a26e9aa7f7eca060",
      "created_at": "2024-04-13T23:06:37Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12459186055,
      "node_id": "HRFPE_lADOABII5856z2OlzwAAAALmoBeH",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12459186055",
      "actor": {
        "login": "mjdietzx",
        "id": 7217256,
        "node_id": "MDQ6VXNlcjcyMTcyNTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7217256?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mjdietzx",
        "html_url": "https://github.com/mjdietzx",
        "followers_url": "https://api.github.com/users/mjdietzx/followers",
        "following_url": "https://api.github.com/users/mjdietzx/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mjdietzx/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mjdietzx/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mjdietzx/subscriptions",
        "organizations_url": "https://api.github.com/users/mjdietzx/orgs",
        "repos_url": "https://api.github.com/users/mjdietzx/repos",
        "events_url": "https://api.github.com/users/mjdietzx/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mjdietzx/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "66dd11a2da18dc9e7ebd5cd5faf0088f64bc0350",
      "commit_url": "https://api.github.com/repos/mjdietzx/bitcoin/commits/66dd11a2da18dc9e7ebd5cd5faf0088f64bc0350",
      "created_at": "2024-04-14T00:58:30Z"
    },
    {
      "event": "commented",
      "id": 2053833598,
      "node_id": "IC_kwDOABII5856awN-",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2053833598",
      "actor": {
        "login": "mjdietzx",
        "id": 7217256,
        "node_id": "MDQ6VXNlcjcyMTcyNTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7217256?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mjdietzx",
        "html_url": "https://github.com/mjdietzx",
        "followers_url": "https://api.github.com/users/mjdietzx/followers",
        "following_url": "https://api.github.com/users/mjdietzx/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mjdietzx/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mjdietzx/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mjdietzx/subscriptions",
        "organizations_url": "https://api.github.com/users/mjdietzx/orgs",
        "repos_url": "https://api.github.com/users/mjdietzx/repos",
        "events_url": "https://api.github.com/users/mjdietzx/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mjdietzx/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-14T01:13:08Z",
      "updated_at": "2024-04-14T01:13:08Z",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks for the review @rkrux ! \r\n\r\n> Suggested adding a log message in the last portion of the test.\r\n\r\nNice suggestion, I did this just now when I rebased on latest `master`",
      "user": {
        "login": "mjdietzx",
        "id": 7217256,
        "node_id": "MDQ6VXNlcjcyMTcyNTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7217256?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mjdietzx",
        "html_url": "https://github.com/mjdietzx",
        "followers_url": "https://api.github.com/users/mjdietzx/followers",
        "following_url": "https://api.github.com/users/mjdietzx/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mjdietzx/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mjdietzx/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mjdietzx/subscriptions",
        "organizations_url": "https://api.github.com/users/mjdietzx/orgs",
        "repos_url": "https://api.github.com/users/mjdietzx/repos",
        "events_url": "https://api.github.com/users/mjdietzx/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mjdietzx/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29156#issuecomment-2053833598",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/29156"
    },
    {
      "event": "mentioned",
      "id": 12459202218,
      "node_id": "MEE_lADOABII5856z2OlzwAAAALmoFaq",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12459202218",
      "actor": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-14T01:13:10Z"
    },
    {
      "event": "subscribed",
      "id": 12459202219,
      "node_id": "SE_lADOABII5856z2OlzwAAAALmoFar",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12459202219",
      "actor": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-14T01:13:10Z"
    },
    {
      "event": "reviewed",
      "id": 2004420996,
      "node_id": "PRR_kwDOABII5853eQmE",
      "url": null,
      "actor": null,
      "commit_id": "66dd11a2da18dc9e7ebd5cd5faf0088f64bc0350",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "e0b0a385350d8f7a9d00542cc3d14bb47224d889 \"tests: miniscript decaying multisig signing order does not matter\" could be squashed into de93b863583921929bc16feb7a0bf5decfbc7ac5 \"tests: add functional test for miniscript decaying multisig\".",
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29156#pullrequestreview-2004420996",
      "submitted_at": "2024-04-16T19:28:33Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29156"
    },
    {
      "event": "commented",
      "id": 2070481115,
      "node_id": "IC_kwDOABII5857aQjb",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2070481115",
      "actor": {
        "login": "mjdietzx",
        "id": 7217256,
        "node_id": "MDQ6VXNlcjcyMTcyNTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7217256?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mjdietzx",
        "html_url": "https://github.com/mjdietzx",
        "followers_url": "https://api.github.com/users/mjdietzx/followers",
        "following_url": "https://api.github.com/users/mjdietzx/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mjdietzx/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mjdietzx/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mjdietzx/subscriptions",
        "organizations_url": "https://api.github.com/users/mjdietzx/orgs",
        "repos_url": "https://api.github.com/users/mjdietzx/repos",
        "events_url": "https://api.github.com/users/mjdietzx/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mjdietzx/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-22T18:07:09Z",
      "updated_at": "2024-04-22T18:07:09Z",
      "author_association": "CONTRIBUTOR",
      "body": "Thank you for the thorough review @achow101! I'll update this PR addressing all of your comments and ping you when I've pushed (I'll need to find a chunk of time to do this so it may be a week or two)",
      "user": {
        "login": "mjdietzx",
        "id": 7217256,
        "node_id": "MDQ6VXNlcjcyMTcyNTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7217256?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mjdietzx",
        "html_url": "https://github.com/mjdietzx",
        "followers_url": "https://api.github.com/users/mjdietzx/followers",
        "following_url": "https://api.github.com/users/mjdietzx/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mjdietzx/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mjdietzx/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mjdietzx/subscriptions",
        "organizations_url": "https://api.github.com/users/mjdietzx/orgs",
        "repos_url": "https://api.github.com/users/mjdietzx/repos",
        "events_url": "https://api.github.com/users/mjdietzx/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mjdietzx/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29156#issuecomment-2070481115",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/29156"
    },
    {
      "event": "mentioned",
      "id": 12563881486,
      "node_id": "MEE_lADOABII5856z2OlzwAAAALs3Z4O",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12563881486",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-22T18:07:11Z"
    },
    {
      "event": "subscribed",
      "id": 12563881505,
      "node_id": "SE_lADOABII5856z2OlzwAAAALs3Z4h",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12563881505",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-22T18:07:11Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12635383794,
      "node_id": "HRFPE_lADOABII5856z2OlzwAAAALxIKfy",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12635383794",
      "actor": {
        "login": "mjdietzx",
        "id": 7217256,
        "node_id": "MDQ6VXNlcjcyMTcyNTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7217256?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mjdietzx",
        "html_url": "https://github.com/mjdietzx",
        "followers_url": "https://api.github.com/users/mjdietzx/followers",
        "following_url": "https://api.github.com/users/mjdietzx/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mjdietzx/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mjdietzx/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mjdietzx/subscriptions",
        "organizations_url": "https://api.github.com/users/mjdietzx/orgs",
        "repos_url": "https://api.github.com/users/mjdietzx/repos",
        "events_url": "https://api.github.com/users/mjdietzx/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mjdietzx/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "283006a45b679579753fef0a80529effec2602d6",
      "commit_url": "https://api.github.com/repos/mjdietzx/bitcoin/commits/283006a45b679579753fef0a80529effec2602d6",
      "created_at": "2024-04-28T17:30:02Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12635387232,
      "node_id": "HRFPE_lADOABII5856z2OlzwAAAALxILVg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12635387232",
      "actor": {
        "login": "mjdietzx",
        "id": 7217256,
        "node_id": "MDQ6VXNlcjcyMTcyNTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7217256?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mjdietzx",
        "html_url": "https://github.com/mjdietzx",
        "followers_url": "https://api.github.com/users/mjdietzx/followers",
        "following_url": "https://api.github.com/users/mjdietzx/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mjdietzx/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mjdietzx/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mjdietzx/subscriptions",
        "organizations_url": "https://api.github.com/users/mjdietzx/orgs",
        "repos_url": "https://api.github.com/users/mjdietzx/repos",
        "events_url": "https://api.github.com/users/mjdietzx/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mjdietzx/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "7ddfc6d53cedbbf539dcd4bb6289b65b581c01c9",
      "commit_url": "https://api.github.com/repos/mjdietzx/bitcoin/commits/7ddfc6d53cedbbf539dcd4bb6289b65b581c01c9",
      "created_at": "2024-04-28T17:31:26Z"
    },
    {
      "event": "commented",
      "id": 2081582395,
      "node_id": "IC_kwDOABII5858Em07",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2081582395",
      "actor": {
        "login": "mjdietzx",
        "id": 7217256,
        "node_id": "MDQ6VXNlcjcyMTcyNTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7217256?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mjdietzx",
        "html_url": "https://github.com/mjdietzx",
        "followers_url": "https://api.github.com/users/mjdietzx/followers",
        "following_url": "https://api.github.com/users/mjdietzx/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mjdietzx/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mjdietzx/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mjdietzx/subscriptions",
        "organizations_url": "https://api.github.com/users/mjdietzx/orgs",
        "repos_url": "https://api.github.com/users/mjdietzx/repos",
        "events_url": "https://api.github.com/users/mjdietzx/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mjdietzx/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-28T18:10:17Z",
      "updated_at": "2024-04-28T18:10:17Z",
      "author_association": "CONTRIBUTOR",
      "body": "I've addressed all your comments and rebased/squashed @achow101\r\n\r\n> Using multiple wallets is preferred over using multiple nodes.\r\n\r\nThis point led me to simplify and remove some unnecessary code/checks. When I had first implemented [test/functional/wallet_multisig_descriptor_psbt.py](https://github.com/bitcoin/bitcoin/blob/master/test/functional/wallet_multisig_descriptor_psbt.py) there was feedback/interest in different nodes/participants coordinating together. That led to some additional checks, code, and showing two different signing flows.\r\n\r\nIn this test I don't think coordination across nodes is necessary or in the scope of what it's trying to show (focused on the number of required signers decaying at the defined block heights). So I made this improvement as you suggested which led to simplifications and removing chunks of now unnecessary code.",
      "user": {
        "login": "mjdietzx",
        "id": 7217256,
        "node_id": "MDQ6VXNlcjcyMTcyNTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7217256?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mjdietzx",
        "html_url": "https://github.com/mjdietzx",
        "followers_url": "https://api.github.com/users/mjdietzx/followers",
        "following_url": "https://api.github.com/users/mjdietzx/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mjdietzx/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mjdietzx/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mjdietzx/subscriptions",
        "organizations_url": "https://api.github.com/users/mjdietzx/orgs",
        "repos_url": "https://api.github.com/users/mjdietzx/repos",
        "events_url": "https://api.github.com/users/mjdietzx/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mjdietzx/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29156#issuecomment-2081582395",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/29156"
    },
    {
      "event": "mentioned",
      "id": 12635470645,
      "node_id": "MEE_lADOABII5856z2OlzwAAAALxIfs1",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12635470645",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-28T18:10:18Z"
    },
    {
      "event": "subscribed",
      "id": 12635470650,
      "node_id": "SE_lADOABII5856z2OlzwAAAALxIfs6",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12635470650",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-28T18:10:18Z"
    },
    {
      "event": "commented",
      "id": 2081684905,
      "node_id": "IC_kwDOABII5858E_2p",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2081684905",
      "actor": {
        "login": "RandyMcMillan",
        "id": 152159,
        "node_id": "MDQ6VXNlcjE1MjE1OQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/152159?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/RandyMcMillan",
        "html_url": "https://github.com/RandyMcMillan",
        "followers_url": "https://api.github.com/users/RandyMcMillan/followers",
        "following_url": "https://api.github.com/users/RandyMcMillan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/RandyMcMillan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/RandyMcMillan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/RandyMcMillan/subscriptions",
        "organizations_url": "https://api.github.com/users/RandyMcMillan/orgs",
        "repos_url": "https://api.github.com/users/RandyMcMillan/repos",
        "events_url": "https://api.github.com/users/RandyMcMillan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/RandyMcMillan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-28T22:45:30Z",
      "updated_at": "2024-04-28T22:45:30Z",
      "author_association": "CONTRIBUTOR",
      "body": "Concept ACK 7ddfc6d",
      "user": {
        "login": "RandyMcMillan",
        "id": 152159,
        "node_id": "MDQ6VXNlcjE1MjE1OQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/152159?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/RandyMcMillan",
        "html_url": "https://github.com/RandyMcMillan",
        "followers_url": "https://api.github.com/users/RandyMcMillan/followers",
        "following_url": "https://api.github.com/users/RandyMcMillan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/RandyMcMillan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/RandyMcMillan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/RandyMcMillan/subscriptions",
        "organizations_url": "https://api.github.com/users/RandyMcMillan/orgs",
        "repos_url": "https://api.github.com/users/RandyMcMillan/repos",
        "events_url": "https://api.github.com/users/RandyMcMillan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/RandyMcMillan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29156#issuecomment-2081684905",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/29156"
    },
    {
      "event": "subscribed",
      "id": 12961724849,
      "node_id": "SE_lADOABII5856z2OlzwAAAAMElDmx",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12961724849",
      "actor": {
        "login": "Blackmoses32",
        "id": 76093520,
        "node_id": "MDQ6VXNlcjc2MDkzNTIw",
        "avatar_url": "https://avatars.githubusercontent.com/u/76093520?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Blackmoses32",
        "html_url": "https://github.com/Blackmoses32",
        "followers_url": "https://api.github.com/users/Blackmoses32/followers",
        "following_url": "https://api.github.com/users/Blackmoses32/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Blackmoses32/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Blackmoses32/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Blackmoses32/subscriptions",
        "organizations_url": "https://api.github.com/users/Blackmoses32/orgs",
        "repos_url": "https://api.github.com/users/Blackmoses32/repos",
        "events_url": "https://api.github.com/users/Blackmoses32/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Blackmoses32/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-28T18:30:23Z"
    },
    {
      "event": "unsubscribed",
      "id": 12961725002,
      "node_id": "UE_lADOABII5856z2OlzwAAAAMElDpK",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12961725002",
      "actor": {
        "login": "Blackmoses32",
        "id": 76093520,
        "node_id": "MDQ6VXNlcjc2MDkzNTIw",
        "avatar_url": "https://avatars.githubusercontent.com/u/76093520?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Blackmoses32",
        "html_url": "https://github.com/Blackmoses32",
        "followers_url": "https://api.github.com/users/Blackmoses32/followers",
        "following_url": "https://api.github.com/users/Blackmoses32/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Blackmoses32/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Blackmoses32/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Blackmoses32/subscriptions",
        "organizations_url": "https://api.github.com/users/Blackmoses32/orgs",
        "repos_url": "https://api.github.com/users/Blackmoses32/repos",
        "events_url": "https://api.github.com/users/Blackmoses32/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Blackmoses32/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-28T18:30:24Z"
    },
    {
      "event": "labeled",
      "id": 13449035969,
      "node_id": "LE_lADOABII5856z2OlzwAAAAMhoADB",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13449035969",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-10T02:41:33Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13452955530,
      "node_id": "HRFPE_lADOABII5856z2OlzwAAAAMh28-K",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13452955530",
      "actor": {
        "login": "mjdietzx",
        "id": 7217256,
        "node_id": "MDQ6VXNlcjcyMTcyNTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7217256?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mjdietzx",
        "html_url": "https://github.com/mjdietzx",
        "followers_url": "https://api.github.com/users/mjdietzx/followers",
        "following_url": "https://api.github.com/users/mjdietzx/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mjdietzx/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mjdietzx/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mjdietzx/subscriptions",
        "organizations_url": "https://api.github.com/users/mjdietzx/orgs",
        "repos_url": "https://api.github.com/users/mjdietzx/repos",
        "events_url": "https://api.github.com/users/mjdietzx/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mjdietzx/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "d58698b776d6b3e797d3da8bfe9ebabf66949434",
      "commit_url": "https://api.github.com/repos/mjdietzx/bitcoin/commits/d58698b776d6b3e797d3da8bfe9ebabf66949434",
      "created_at": "2024-07-10T09:36:35Z"
    },
    {
      "event": "unlabeled",
      "id": 13454145104,
      "node_id": "UNLE_lADOABII5856z2OlzwAAAAMh7fZQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13454145104",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-10T10:57:42Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "labeled",
      "id": 13630712957,
      "node_id": "LE_lADOABII5856z2OlzwAAAAMsdCx9",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13630712957",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-24T13:34:06Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2247952377,
      "node_id": "IC_kwDOABII586F_Qf5",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2247952377",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-24T13:34:07Z",
      "updated_at": "2024-07-24T13:34:07Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\n🚧 At least one of the CI tasks failed.\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/27260554001</sub>\n\n<details><summary>Hints</summary>\n\nMake sure to run all tests locally, according to the documentation.\n\nThe failure may happen due to a number of reasons, for example:\n\n* Possibly due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\n* A sanitizer issue, which can only be found by compiling with the sanitizer and running the\n  affected test.\n\n* An intermittent issue.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n</details>\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29156#issuecomment-2247952377",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/29156"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13669678771,
      "node_id": "HRFPE_lADOABII5856z2OlzwAAAAMuxr6z",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13669678771",
      "actor": {
        "login": "mjdietzx",
        "id": 7217256,
        "node_id": "MDQ6VXNlcjcyMTcyNTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7217256?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mjdietzx",
        "html_url": "https://github.com/mjdietzx",
        "followers_url": "https://api.github.com/users/mjdietzx/followers",
        "following_url": "https://api.github.com/users/mjdietzx/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mjdietzx/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mjdietzx/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mjdietzx/subscriptions",
        "organizations_url": "https://api.github.com/users/mjdietzx/orgs",
        "repos_url": "https://api.github.com/users/mjdietzx/repos",
        "events_url": "https://api.github.com/users/mjdietzx/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mjdietzx/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "882eff399e9d948db66228fb575ce97b4a74f0fe",
      "commit_url": "https://api.github.com/repos/mjdietzx/bitcoin/commits/882eff399e9d948db66228fb575ce97b4a74f0fe",
      "created_at": "2024-07-27T23:09:05Z"
    },
    {
      "event": "unlabeled",
      "id": 13669776046,
      "node_id": "UNLE_lADOABII5856z2OlzwAAAAMuyDqu",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13669776046",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-28T00:33:48Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "review_requested",
      "id": 13889022744,
      "node_id": "RRE_lADOABII5856z2OlzwAAAAM72asY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13889022744",
      "actor": {
        "login": "mjdietzx",
        "id": 7217256,
        "node_id": "MDQ6VXNlcjcyMTcyNTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7217256?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mjdietzx",
        "html_url": "https://github.com/mjdietzx",
        "followers_url": "https://api.github.com/users/mjdietzx/followers",
        "following_url": "https://api.github.com/users/mjdietzx/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mjdietzx/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mjdietzx/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mjdietzx/subscriptions",
        "organizations_url": "https://api.github.com/users/mjdietzx/orgs",
        "repos_url": "https://api.github.com/users/mjdietzx/repos",
        "events_url": "https://api.github.com/users/mjdietzx/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mjdietzx/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-15T00:53:29Z",
      "requested_reviewer": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "mjdietzx",
        "id": 7217256,
        "node_id": "MDQ6VXNlcjcyMTcyNTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7217256?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mjdietzx",
        "html_url": "https://github.com/mjdietzx",
        "followers_url": "https://api.github.com/users/mjdietzx/followers",
        "following_url": "https://api.github.com/users/mjdietzx/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mjdietzx/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mjdietzx/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mjdietzx/subscriptions",
        "organizations_url": "https://api.github.com/users/mjdietzx/orgs",
        "repos_url": "https://api.github.com/users/mjdietzx/repos",
        "events_url": "https://api.github.com/users/mjdietzx/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mjdietzx/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "labeled",
      "id": 14431987043,
      "node_id": "LE_lADOABII5856z2OlzwAAAANcNqVj",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14431987043",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-27T14:19:16Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "unlabeled",
      "id": 14471479820,
      "node_id": "UNLE_lADOABII5856z2OlzwAAAANekUIM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14471479820",
      "actor": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-10-01T12:17:22Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "labeled",
      "id": 15102039921,
      "node_id": "LE_lADOABII5856z2OlzwAAAAOEJtdx",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15102039921",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-11-04T11:09:46Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "unlabeled",
      "id": 15103466742,
      "node_id": "UNLE_lADOABII5856z2OlzwAAAAOEPJz2",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15103466742",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-11-04T12:55:49Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 2427112510,
      "node_id": "PRR_kwDOABII586Qqsw-",
      "url": null,
      "actor": null,
      "commit_id": "882eff399e9d948db66228fb575ce97b4a74f0fe",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "body": "@mjdietzx I will review this PR again soon as I want to see a decaying multi-sig using miniscript example checked in. Would you be willing to rebase this over master to get the CMake build changes? The other option is for me (and other reviewers) to use the older build commands to test this PR locally, which is fine as well but at the cost of a much longer build time and having two building tools in my local. \r\nAlso, it would be nice to ensure this works with the latest build system though there are only python changes.",
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29156#pullrequestreview-2427112510",
      "submitted_at": "2024-11-11T12:00:45Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29156"
    },
    {
      "event": "commented",
      "id": 2477872950,
      "node_id": "IC_kwDOABII586TsVc2",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2477872950",
      "actor": {
        "login": "mjdietzx",
        "id": 7217256,
        "node_id": "MDQ6VXNlcjcyMTcyNTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7217256?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mjdietzx",
        "html_url": "https://github.com/mjdietzx",
        "followers_url": "https://api.github.com/users/mjdietzx/followers",
        "following_url": "https://api.github.com/users/mjdietzx/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mjdietzx/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mjdietzx/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mjdietzx/subscriptions",
        "organizations_url": "https://api.github.com/users/mjdietzx/orgs",
        "repos_url": "https://api.github.com/users/mjdietzx/repos",
        "events_url": "https://api.github.com/users/mjdietzx/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mjdietzx/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-11-15T03:18:51Z",
      "updated_at": "2024-11-15T03:18:51Z",
      "author_association": "CONTRIBUTOR",
      "body": "@rkrux thanks for the heads up. I didn't expect changes to build system would affect this. I'll rebase asap, also want to bring in achow's [#22838](https://github.com/bitcoin/bitcoin/pull/22838)",
      "user": {
        "login": "mjdietzx",
        "id": 7217256,
        "node_id": "MDQ6VXNlcjcyMTcyNTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7217256?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mjdietzx",
        "html_url": "https://github.com/mjdietzx",
        "followers_url": "https://api.github.com/users/mjdietzx/followers",
        "following_url": "https://api.github.com/users/mjdietzx/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mjdietzx/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mjdietzx/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mjdietzx/subscriptions",
        "organizations_url": "https://api.github.com/users/mjdietzx/orgs",
        "repos_url": "https://api.github.com/users/mjdietzx/repos",
        "events_url": "https://api.github.com/users/mjdietzx/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mjdietzx/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29156#issuecomment-2477872950",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/29156"
    },
    {
      "event": "mentioned",
      "id": 15306720891,
      "node_id": "MEE_lADOABII5856z2OlzwAAAAOQWgZ7",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15306720891",
      "actor": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-11-15T03:18:51Z"
    },
    {
      "event": "subscribed",
      "id": 15306720907,
      "node_id": "SE_lADOABII5856z2OlzwAAAAOQWgaL",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15306720907",
      "actor": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-11-15T03:18:52Z"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGFhZTAzMjAxNTM2N2JlODEyMTU0YTBlODc5NTVlNmZkNWVhNWMxOTI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/aae032015367be812154a0e87955e6fd5ea5c192",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/aae032015367be812154a0e87955e6fd5ea5c192",
      "tree": {
        "sha": "f808c0551b984346bceb47705047b175d456ad96",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f808c0551b984346bceb47705047b175d456ad96"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8e02b480591008c457cc841050f6f755ff54fcba",
          "sha": "8e02b480591008c457cc841050f6f755ff54fcba",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/8e02b480591008c457cc841050f6f755ff54fcba"
        }
      ],
      "message": "tests: add functional test for miniscript decaying multisig\n\nThis is similar in structure to test/functional/wallet_multisig_descriptor_psbt.py\nboth in code and concept. It should serve as some integration testing for\nMiniscript descriptors, and also documents a simple multisig that starts as 4-of-4\nand decays to 3-of-4, 2-of-4, and finally 1-of-4 at block heights (I think in the\nreal world aligning this to halvenings would be nice).",
      "committer": {
        "name": "Michael Dietz",
        "email": "michael.dietz@waya.ai",
        "date": "2024-12-03T20:05:26Z"
      },
      "author": {
        "name": "Michael Dietz",
        "email": "michael.dietz@waya.ai",
        "date": "2023-12-29T21:20:45Z"
      },
      "sha": "aae032015367be812154a0e87955e6fd5ea5c192"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15515457738,
      "node_id": "HRFPE_lADOABII5856z2OlzwAAAAOcyxjK",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15515457738",
      "actor": {
        "login": "mjdietzx",
        "id": 7217256,
        "node_id": "MDQ6VXNlcjcyMTcyNTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7217256?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mjdietzx",
        "html_url": "https://github.com/mjdietzx",
        "followers_url": "https://api.github.com/users/mjdietzx/followers",
        "following_url": "https://api.github.com/users/mjdietzx/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mjdietzx/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mjdietzx/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mjdietzx/subscriptions",
        "organizations_url": "https://api.github.com/users/mjdietzx/orgs",
        "repos_url": "https://api.github.com/users/mjdietzx/repos",
        "events_url": "https://api.github.com/users/mjdietzx/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mjdietzx/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "aae032015367be812154a0e87955e6fd5ea5c192",
      "commit_url": "https://api.github.com/repos/mjdietzx/bitcoin/commits/aae032015367be812154a0e87955e6fd5ea5c192",
      "created_at": "2024-12-03T20:12:56Z"
    },
    {
      "event": "commented",
      "id": 2515462391,
      "node_id": "IC_kwDOABII586V7uj3",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2515462391",
      "actor": {
        "login": "mjdietzx",
        "id": 7217256,
        "node_id": "MDQ6VXNlcjcyMTcyNTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7217256?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mjdietzx",
        "html_url": "https://github.com/mjdietzx",
        "followers_url": "https://api.github.com/users/mjdietzx/followers",
        "following_url": "https://api.github.com/users/mjdietzx/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mjdietzx/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mjdietzx/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mjdietzx/subscriptions",
        "organizations_url": "https://api.github.com/users/mjdietzx/orgs",
        "repos_url": "https://api.github.com/users/mjdietzx/repos",
        "events_url": "https://api.github.com/users/mjdietzx/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mjdietzx/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-12-03T20:14:51Z",
      "updated_at": "2024-12-03T20:14:51Z",
      "author_association": "CONTRIBUTOR",
      "body": "@rkrux I updated to master and rebased. There were no conflicts and this test continues to pass without needing any modifications. This should be ready to merge\r\n\r\nNote: I will update to multi-path descriptors now that it's merged in a tiny followup PR. but I don't want to mess with all the prior reviews on this PR so not introducing any new changes",
      "user": {
        "login": "mjdietzx",
        "id": 7217256,
        "node_id": "MDQ6VXNlcjcyMTcyNTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7217256?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mjdietzx",
        "html_url": "https://github.com/mjdietzx",
        "followers_url": "https://api.github.com/users/mjdietzx/followers",
        "following_url": "https://api.github.com/users/mjdietzx/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mjdietzx/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mjdietzx/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mjdietzx/subscriptions",
        "organizations_url": "https://api.github.com/users/mjdietzx/orgs",
        "repos_url": "https://api.github.com/users/mjdietzx/repos",
        "events_url": "https://api.github.com/users/mjdietzx/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mjdietzx/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29156#issuecomment-2515462391",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/29156"
    },
    {
      "event": "mentioned",
      "id": 15515480290,
      "node_id": "MEE_lADOABII5856z2OlzwAAAAOcy3Di",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15515480290",
      "actor": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-12-03T20:14:54Z"
    },
    {
      "event": "subscribed",
      "id": 15515480313,
      "node_id": "SE_lADOABII5856z2OlzwAAAAOcy3D5",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15515480313",
      "actor": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-12-03T20:14:54Z"
    },
    {
      "event": "reviewed",
      "id": 2488750053,
      "node_id": "PRR_kwDOABII586UV0_l",
      "url": null,
      "actor": null,
      "commit_id": "aae032015367be812154a0e87955e6fd5ea5c192",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "body": "tACK aae032015367be812154a0e87955e6fd5ea5c192\r\n\r\nMy comments are mostly nits and few questions.",
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29156#pullrequestreview-2488750053",
      "submitted_at": "2024-12-09T13:55:00Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29156"
    },
    {
      "event": "mentioned",
      "id": 15583764236,
      "node_id": "MEE_lADOABII5856z2OlzwAAAAOg3V8M",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15583764236",
      "actor": {
        "login": "staticmethod",
        "id": 3434126,
        "node_id": "MDQ6VXNlcjM0MzQxMjY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3434126?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/staticmethod",
        "html_url": "https://github.com/staticmethod",
        "followers_url": "https://api.github.com/users/staticmethod/followers",
        "following_url": "https://api.github.com/users/staticmethod/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/staticmethod/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/staticmethod/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/staticmethod/subscriptions",
        "organizations_url": "https://api.github.com/users/staticmethod/orgs",
        "repos_url": "https://api.github.com/users/staticmethod/repos",
        "events_url": "https://api.github.com/users/staticmethod/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/staticmethod/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-12-09T14:02:13Z"
    },
    {
      "event": "subscribed",
      "id": 15583764277,
      "node_id": "SE_lADOABII5856z2OlzwAAAAOg3V81",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15583764277",
      "actor": {
        "login": "staticmethod",
        "id": 3434126,
        "node_id": "MDQ6VXNlcjM0MzQxMjY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3434126?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/staticmethod",
        "html_url": "https://github.com/staticmethod",
        "followers_url": "https://api.github.com/users/staticmethod/followers",
        "following_url": "https://api.github.com/users/staticmethod/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/staticmethod/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/staticmethod/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/staticmethod/subscriptions",
        "organizations_url": "https://api.github.com/users/staticmethod/orgs",
        "repos_url": "https://api.github.com/users/staticmethod/repos",
        "events_url": "https://api.github.com/users/staticmethod/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/staticmethod/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-12-09T14:02:13Z"
    },
    {
      "event": "comment_deleted",
      "id": 15583786784,
      "node_id": "CDE_lADOABII5856z2OlzwAAAAOg3bcg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15583786784",
      "actor": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-12-09T14:03:44Z"
    },
    {
      "event": "labeled",
      "id": 15629458806,
      "node_id": "LE_lADOABII5856z2OlzwAAAAOjlp12",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15629458806",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-12-12T06:45:21Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2537947878,
      "node_id": "IC_kwDOABII586XRgLm",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2537947878",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-12-12T06:45:22Z",
      "updated_at": "2024-12-12T06:45:22Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\n🚧 At least one of the CI tasks failed.\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/33873388110</sub>\n\n<details><summary>Hints</summary>\n\nTry to run the tests locally, according to the documentation. However, a CI failure may still\nhappen due to a number of reasons, for example:\n\n* Possibly due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\n* A sanitizer issue, which can only be found by compiling with the sanitizer and running the\n  affected test.\n\n* An intermittent issue.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n</details>\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29156#issuecomment-2537947878",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/29156"
    },
    {
      "event": "reviewed",
      "id": 2501140714,
      "node_id": "PRR_kwDOABII586VFGDq",
      "url": null,
      "actor": null,
      "commit_id": "aae032015367be812154a0e87955e6fd5ea5c192",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Thank you for the thorough review @rkrux! I've responded to all your comments. I will @ you when I've rebased and addressed the ones that need it",
      "user": {
        "login": "mjdietzx",
        "id": 7217256,
        "node_id": "MDQ6VXNlcjcyMTcyNTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7217256?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mjdietzx",
        "html_url": "https://github.com/mjdietzx",
        "followers_url": "https://api.github.com/users/mjdietzx/followers",
        "following_url": "https://api.github.com/users/mjdietzx/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mjdietzx/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mjdietzx/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mjdietzx/subscriptions",
        "organizations_url": "https://api.github.com/users/mjdietzx/orgs",
        "repos_url": "https://api.github.com/users/mjdietzx/repos",
        "events_url": "https://api.github.com/users/mjdietzx/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mjdietzx/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29156#pullrequestreview-2501140714",
      "submitted_at": "2024-12-13T03:09:35Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29156"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1558033127",
      "pull_request_review_id": 1989661119,
      "id": 1558033127,
      "node_id": "PRRC_kwDOABII585c3bLn",
      "diff_hunk": "@@ -0,0 +1,177 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test a miniscript multisig that starts as 4-of-4 and \"decays\" to 3-of-4, 2-of-4, and finally 1-of-4 at each future halvening block height.\n+\n+Spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+This is based off of `test/functional/wallet_multisig_descriptor_psbt.py` and most code is the same.\n+\"\"\"\n+\n+import random\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_approx,\n+    assert_equal,\n+    assert_raises_rpc_error,\n+)\n+\n+\n+class WalletMiniscriptDecayingMultisigDescriptorPSBTTest(BitcoinTestFramework):\n+    def add_options(self, parser):\n+        self.add_wallet_options(parser, legacy=False)\n+\n+    def set_test_params(self):\n+        self.num_nodes = 4\n+        self.setup_clean_chain = True\n+        self.wallet_names = []\n+        self.extra_args = [[\"-keypool=100\"]] * self.num_nodes\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+        self.skip_if_no_sqlite()\n+\n+    @staticmethod\n+    def _get_xpub(wallet, internal):\n+        \"\"\"Extract the wallet's xpubs using `listdescriptors` and pick the one from the `pkh` descriptor since it's least likely to be accidentally reused (legacy addresses).\"\"\"\n+        pkh_descriptor = next(filter(lambda d: d[\"desc\"].startswith(\"pkh(\") and d[\"internal\"] == internal, wallet.listdescriptors()[\"descriptors\"]))\n+        # Keep all key origin information (master key fingerprint and all derivation steps) for proper support of hardware devices\n+        # See section 'Key origin identification' in 'doc/descriptors.md' for more details...\n+        return pkh_descriptor[\"desc\"].split(\"pkh(\")[1].split(\")\")[0]\n+\n+    @staticmethod\n+    def _check_psbt(psbt, to, value, multisig):\n+        \"\"\"Helper function for any of the N participants to check the psbt with decodepsbt and verify it is OK before signing.\"\"\"\n+        tx = multisig.decodepsbt(psbt)[\"tx\"]\n+        amount = 0\n+        for vout in tx[\"vout\"]:\n+            address = vout[\"scriptPubKey\"][\"address\"]\n+            assert_equal(multisig.getaddressinfo(address)[\"ischange\"], address != to)\n+            if address == to:\n+                amount += vout[\"value\"]\n+        assert_approx(amount, float(value), vspan=0.001)\n+\n+    def participants_create_multisigs(self, external_xpubs, internal_xpubs):\n+        \"\"\"The multisig is created by importing the following descriptors. The resulting wallet is watch-only and every participant can do this.\"\"\"\n+        for i, node in enumerate(self.nodes):\n+            node.createwallet(wallet_name=f\"{self.name}_{i}\", blank=True, descriptors=True, disable_private_keys=True)\n+            multisig = node.get_wallet_rpc(f\"{self.name}_{i}\")\n+            # Spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+            external = multisig.getdescriptorinfo(f\"wsh(thresh({self.N},pk({f'),s:pk('.join(external_xpubs)}),sln:after({f'),sln:after('.join(map(str, self.locktimes))})))\")\n+            internal = multisig.getdescriptorinfo(f\"wsh(thresh({self.N},pk({f'),s:pk('.join(internal_xpubs)}),sln:after({f'),sln:after('.join(map(str, self.locktimes))})))\")\n+            result = multisig.importdescriptors([\n+                {  # receiving addresses (internal: False)\n+                    \"desc\": external[\"descriptor\"],\n+                    \"active\": True,\n+                    \"internal\": False,\n+                    \"timestamp\": \"now\",\n+                },\n+                {  # change addresses (internal: True)\n+                    \"desc\": internal[\"descriptor\"],\n+                    \"active\": True,\n+                    \"internal\": True,\n+                    \"timestamp\": \"now\",\n+                },\n+            ])\n+            assert all(r[\"success\"] for r in result)\n+            yield multisig\n+\n+    def run_test(self):\n+        self.M = self.num_nodes\n+        self.N = self.num_nodes\n+        self.locktimes = [128, 256, 512]  # in real-world align with future halvenings: [840000, 1050000, 1260000]\n+        assert_equal(len(self.locktimes), self.N - 1)\n+\n+        self.name = f\"{self.M}_of_{self.N}_decaying_multisig\"\n+        self.log.info(f\"Testing {self.name}...\")\n+\n+        participants = {\n+            # Every participant generates an xpub. The most straightforward way is to create a new descriptor wallet.\n+            # This wallet will be the participant's `signer` for the resulting multisig. Avoid reusing this wallet for any other purpose (for privacy reasons).\n+            \"signers\": [node.get_wallet_rpc(node.createwallet(wallet_name=f\"participant_{self.nodes.index(node)}\", descriptors=True)[\"name\"]) for node in self.nodes],\n+            # After participants generate and exchange their xpubs they will each create their own watch-only multisig.\n+            # Note: these multisigs are all the same, this just highlights that each participant can independently verify everything on their own node.\n+            \"multisigs\": []\n+        }\n+\n+        self.log.info(\"Generate and exchange xpubs...\")\n+        external_xpubs, internal_xpubs = [[self._get_xpub(signer, internal) for signer in participants[\"signers\"]] for internal in [False, True]]\n+\n+        self.log.info(\"Every participant imports the following descriptors to create the watch-only multisig...\")\n+        participants[\"multisigs\"] = list(self.participants_create_multisigs(external_xpubs, internal_xpubs))\n+\n+        self.log.info(\"Check that every participant's multisig generates the same addresses...\")\n+        for _ in range(10):  # we check that the first 10 generated addresses are the same for all participant's multisigs\n+            receive_addresses = [multisig.getnewaddress() for multisig in participants[\"multisigs\"]]\n+            all(address == receive_addresses[0] for address in receive_addresses)\n+            change_addresses = [multisig.getrawchangeaddress() for multisig in participants[\"multisigs\"]]\n+            all(address == change_addresses[0] for address in change_addresses)\n+\n+        self.log.info(\"Get a mature utxo to send to the multisig...\")\n+        coordinator_wallet = participants[\"signers\"][0]\n+        self.generatetoaddress(self.nodes[0], 101, coordinator_wallet.getnewaddress())\n+\n+        deposit_amount = 6.15\n+        multisig_receiving_address = participants[\"multisigs\"][0].getnewaddress()\n+        self.log.info(\"Send funds to the resulting multisig receiving address...\")\n+        coordinator_wallet.sendtoaddress(multisig_receiving_address, deposit_amount)\n+        self.generate(self.nodes[0], 1)\n+        for participant in participants[\"multisigs\"]:\n+            assert_approx(participant.getbalance(), deposit_amount, vspan=0.001)\n+\n+        self.log.info(\"Send a transaction from the multisig! We can always spend with all signers!\")\n+        to = participants[\"signers\"][self.N - 1].getnewaddress()\n+        value = 1.5\n+        self.log.info(\"First, make a sending transaction, created using `walletcreatefundedpsbt` (anyone can initiate this)...\")\n+        psbt = participants[\"multisigs\"][0].walletcreatefundedpsbt(inputs=[], outputs={to: value}, feeRate=0.00010)\n+\n+        psbts = []\n+        self.log.info(\"Now at least M users check the psbt with decodepsbt and (if OK) signs it with walletprocesspsbt...\")\n+        for m in random.sample(range(self.M), self.M):\n+            signers_multisig = participants[\"multisigs\"][m]\n+            self._check_psbt(psbt[\"psbt\"], to, value, signers_multisig)\n+            signing_wallet = participants[\"signers\"][m]\n+            partially_signed_psbt = signing_wallet.walletprocesspsbt(psbt[\"psbt\"])\n+            psbts.append(partially_signed_psbt[\"psbt\"])\n+\n+        self.log.info(\"Finally, collect the signed PSBTs with combinepsbt, finalizepsbt, then broadcast the resulting transaction...\")\n+        combined = coordinator_wallet.combinepsbt(psbts)\n+        finalized = coordinator_wallet.finalizepsbt(combined)\n+        coordinator_wallet.sendrawtransaction(finalized[\"hex\"])\n+\n+        self.log.info(\"Check that balances are correct after the transaction has been included in a block.\")\n+        self.generate(self.nodes[0], 1)\n+        assert_approx(participants[\"multisigs\"][0].getbalance(), deposit_amount - value, vspan=0.001)\n+        assert_equal(participants[\"signers\"][self.N - 1].getbalance(), value)\n+\n+        self.log.info(\"Send more transactions from the multisig as required signers decay, this time with a daisy chained signing flow (one after another in series)!\")\n+        sent = value\n+        for locktime in self.locktimes:\n+            self.M -= 1\n+            self.log.info(f\"At block height >= {locktime} this multisig is {self.M}-of-{self.N}\")\n+            current_height = self.nodes[0].getblock(self.nodes[0].getbestblockhash())['height']\n+\n+            psbt = participants[\"multisigs\"][0].walletcreatefundedpsbt(inputs=[], outputs={to: value}, feeRate=0.00010, locktime=locktime)",
      "path": "test/functional/wallet_miniscript_decaying_multisig_descriptor_psbt.py",
      "position": null,
      "original_position": 154,
      "commit_id": "aae032015367be812154a0e87955e6fd5ea5c192",
      "original_commit_id": "5023b47e85161a0b35839ce03c7b5d55ff1cd4c1",
      "in_reply_to_id": null,
      "user": {
        "login": "mjdietzx",
        "id": 7217256,
        "node_id": "MDQ6VXNlcjcyMTcyNTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7217256?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mjdietzx",
        "html_url": "https://github.com/mjdietzx",
        "followers_url": "https://api.github.com/users/mjdietzx/followers",
        "following_url": "https://api.github.com/users/mjdietzx/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mjdietzx/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mjdietzx/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mjdietzx/subscriptions",
        "organizations_url": "https://api.github.com/users/mjdietzx/orgs",
        "repos_url": "https://api.github.com/users/mjdietzx/repos",
        "events_url": "https://api.github.com/users/mjdietzx/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mjdietzx/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "An interesting thing I learned with this test was psbt behavior related to `locktime`. If I created a psbt at a blockheight of 800,000 when multisig was 4-of-4 (maybe I want to pre-sign it with a cold wallet and save it for later), and then I wanted to spend it when the multisig decayed to 3-of-4 at blockheight 840,000, then wallet would not process that psbt as `complete` with 3 valid signatures like I expected (bc I guess it's using locktime of when psbt was created to know how to interpret the Miniscript and not current blockheight)\r\n\r\nI didn't investigate further or learn why that is.. or if there is a fundamental reason for this behavior or if `walletprocesspsbt` can/should be improved",
      "created_at": "2024-04-09T17:08:32Z",
      "updated_at": "2024-04-09T17:08:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29156#discussion_r1558033127",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1558033127"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29156"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 154,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1563885340",
      "pull_request_review_id": 1999196598,
      "id": 1563885340,
      "node_id": "PRRC_kwDOABII585dNv8c",
      "diff_hunk": "@@ -0,0 +1,176 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test a miniscript multisig that starts as 4-of-4 and \"decays\" to 3-of-4, 2-of-4, and finally 1-of-4 at each future halvening block height.\n+\n+Spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+This is based off of `test/functional/wallet_multisig_descriptor_psbt.py` and most code is the same.\n+\"\"\"\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_approx,\n+    assert_equal,\n+    assert_raises_rpc_error,\n+)\n+\n+\n+class WalletMiniscriptDecayingMultisigDescriptorPSBTTest(BitcoinTestFramework):\n+    def add_options(self, parser):\n+        self.add_wallet_options(parser, legacy=False)\n+\n+    def set_test_params(self):\n+        self.num_nodes = 4\n+        self.setup_clean_chain = True\n+        self.wallet_names = []\n+        self.extra_args = [[\"-keypool=100\"]] * self.num_nodes\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+        self.skip_if_no_sqlite()\n+\n+    @staticmethod\n+    def _get_xpub(wallet, internal):\n+        \"\"\"Extract the wallet's xpubs using `listdescriptors` and pick the one from the `pkh` descriptor since it's least likely to be accidentally reused (legacy addresses).\"\"\"\n+        pkh_descriptor = next(filter(lambda d: d[\"desc\"].startswith(\"pkh(\") and d[\"internal\"] == internal, wallet.listdescriptors()[\"descriptors\"]))\n+        # Keep all key origin information (master key fingerprint and all derivation steps) for proper support of hardware devices\n+        # See section 'Key origin identification' in 'doc/descriptors.md' for more details...\n+        return pkh_descriptor[\"desc\"].split(\"pkh(\")[1].split(\")\")[0]\n+\n+    @staticmethod\n+    def _check_psbt(psbt, to, value, multisig):\n+        \"\"\"Helper function for any of the N participants to check the psbt with decodepsbt and verify it is OK before signing.\"\"\"\n+        tx = multisig.decodepsbt(psbt)[\"tx\"]\n+        amount = 0\n+        for vout in tx[\"vout\"]:\n+            address = vout[\"scriptPubKey\"][\"address\"]\n+            assert_equal(multisig.getaddressinfo(address)[\"ischange\"], address != to)\n+            if address == to:\n+                amount += vout[\"value\"]\n+        assert_approx(amount, float(value), vspan=0.001)\n+\n+    def participants_create_multisigs(self, external_xpubs, internal_xpubs):\n+        \"\"\"The multisig is created by importing the following descriptors. The resulting wallet is watch-only and every participant can do this.\"\"\"\n+        for i, node in enumerate(self.nodes):\n+            node.createwallet(wallet_name=f\"{self.name}_{i}\", blank=True, descriptors=True, disable_private_keys=True)\n+            multisig = node.get_wallet_rpc(f\"{self.name}_{i}\")\n+            # Spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+            external = multisig.getdescriptorinfo(f\"wsh(thresh({self.N},pk({f'),s:pk('.join(external_xpubs)}),sln:after({f'),sln:after('.join(map(str, self.locktimes))})))\")\n+            internal = multisig.getdescriptorinfo(f\"wsh(thresh({self.N},pk({f'),s:pk('.join(internal_xpubs)}),sln:after({f'),sln:after('.join(map(str, self.locktimes))})))\")\n+            result = multisig.importdescriptors([\n+                {  # receiving addresses (internal: False)\n+                    \"desc\": external[\"descriptor\"],\n+                    \"active\": True,\n+                    \"internal\": False,\n+                    \"timestamp\": \"now\",\n+                },\n+                {  # change addresses (internal: True)\n+                    \"desc\": internal[\"descriptor\"],\n+                    \"active\": True,\n+                    \"internal\": True,\n+                    \"timestamp\": \"now\",\n+                },\n+            ])\n+            assert all(r[\"success\"] for r in result)\n+            yield multisig\n+\n+    def run_test(self):\n+        self.M = self.num_nodes\n+        self.N = self.num_nodes\n+        self.locktimes = [128, 256, 512]  # in real-world align with future halvenings: [840000, 1050000, 1260000]\n+        assert_equal(len(self.locktimes), self.N - 1)\n+\n+        self.name = f\"{self.M}_of_{self.N}_decaying_multisig\"\n+        self.log.info(f\"Testing {self.name}...\")\n+\n+        participants = {\n+            # Every participant generates an xpub. The most straightforward way is to create a new descriptor wallet.\n+            # This wallet will be the participant's `signer` for the resulting multisig. Avoid reusing this wallet for any other purpose (for privacy reasons).\n+            \"signers\": [node.get_wallet_rpc(node.createwallet(wallet_name=f\"participant_{self.nodes.index(node)}\", descriptors=True)[\"name\"]) for node in self.nodes],\n+            # After participants generate and exchange their xpubs they will each create their own watch-only multisig.\n+            # Note: these multisigs are all the same, this just highlights that each participant can independently verify everything on their own node.\n+            \"multisigs\": []\n+        }\n+\n+        self.log.info(\"Generate and exchange xpubs...\")\n+        external_xpubs, internal_xpubs = [[self._get_xpub(signer, internal) for signer in participants[\"signers\"]] for internal in [False, True]]\n+\n+        self.log.info(\"Every participant imports the following descriptors to create the watch-only multisig...\")\n+        participants[\"multisigs\"] = list(self.participants_create_multisigs(external_xpubs, internal_xpubs))\n+\n+        self.log.info(\"Check that every participant's multisig generates the same addresses...\")\n+        for _ in range(10):  # we check that the first 10 generated addresses are the same for all participant's multisigs\n+            receive_addresses = [multisig.getnewaddress() for multisig in participants[\"multisigs\"]]\n+            all(address == receive_addresses[0] for address in receive_addresses)\n+            change_addresses = [multisig.getrawchangeaddress() for multisig in participants[\"multisigs\"]]\n+            all(address == change_addresses[0] for address in change_addresses)\n+\n+        self.log.info(\"Get a mature utxo to send to the multisig...\")\n+        coordinator_wallet = participants[\"signers\"][0]\n+        self.generatetoaddress(self.nodes[0], 101, coordinator_wallet.getnewaddress())\n+\n+        deposit_amount = 6.15\n+        multisig_receiving_address = participants[\"multisigs\"][0].getnewaddress()\n+        self.log.info(\"Send funds to the resulting multisig receiving address...\")\n+        coordinator_wallet.sendtoaddress(multisig_receiving_address, deposit_amount)\n+        self.generate(self.nodes[0], 1)\n+        for participant in participants[\"multisigs\"]:\n+            assert_approx(participant.getbalance(), deposit_amount, vspan=0.001)\n+\n+        self.log.info(\"Send a transaction from the multisig! We can always spend with all signers!\")\n+        to = participants[\"signers\"][self.N - 1].getnewaddress()\n+        value = 1.5\n+        self.log.info(\"First, make a sending transaction, created using `walletcreatefundedpsbt` (anyone can initiate this)...\")\n+        psbt = participants[\"multisigs\"][0].walletcreatefundedpsbt(inputs=[], outputs={to: value}, feeRate=0.00010)\n+\n+        psbts = []\n+        self.log.info(\"Now at least M users check the psbt with decodepsbt and (if OK) signs it with walletprocesspsbt...\")\n+        for m in range(self.M):\n+            signers_multisig = participants[\"multisigs\"][m]\n+            self._check_psbt(psbt[\"psbt\"], to, value, signers_multisig)\n+            signing_wallet = participants[\"signers\"][m]\n+            partially_signed_psbt = signing_wallet.walletprocesspsbt(psbt[\"psbt\"])\n+            psbts.append(partially_signed_psbt[\"psbt\"])\n+\n+        self.log.info(\"Finally, collect the signed PSBTs with combinepsbt, finalizepsbt, then broadcast the resulting transaction...\")\n+        combined = coordinator_wallet.combinepsbt(psbts)\n+        finalized = coordinator_wallet.finalizepsbt(combined)\n+        coordinator_wallet.sendrawtransaction(finalized[\"hex\"])\n+\n+        self.log.info(\"Check that balances are correct after the transaction has been included in a block.\")\n+        self.generate(self.nodes[0], 1)\n+        assert_approx(participants[\"multisigs\"][0].getbalance(), deposit_amount - value, vspan=0.001)\n+        assert_equal(participants[\"signers\"][self.N - 1].getbalance(), value)\n+\n+        self.log.info(\"Send more transactions from the multisig as required signers decay, this time with a daisy chained signing flow (one after another in series)!\")\n+        sent = value\n+        for locktime in self.locktimes:\n+            self.M -= 1\n+            self.log.info(f\"At block height >= {locktime} this multisig is {self.M}-of-{self.N}\")\n+            current_height = self.nodes[0].getblock(self.nodes[0].getbestblockhash())['height']\n+\n+            psbt = participants[\"multisigs\"][0].walletcreatefundedpsbt(inputs=[], outputs={to: value}, feeRate=0.00010, locktime=locktime)\n+            for m in range(self.M):\n+                signers_multisig = participants[\"multisigs\"][m]\n+                self._check_psbt(psbt[\"psbt\"], to, value, signers_multisig)\n+                signing_wallet = participants[\"signers\"][m]\n+                psbt = signing_wallet.walletprocesspsbt(psbt[\"psbt\"])\n+                assert_equal(psbt[\"complete\"], m == self.M - 1)\n+            self.log.info(\"Check that the time-locked transaction is too immature to spend...\")\n+            assert_equal(current_height >= locktime, False)\n+            assert_raises_rpc_error(-26, \"non-final\", coordinator_wallet.sendrawtransaction, psbt[\"hex\"])\n+\n+            self.generate(self.nodes[0], locktime)\n+            self.sync_blocks()\n+            coordinator_wallet.sendrawtransaction(psbt[\"hex\"])\n+\n+            self.log.info(\"Check that balances are correct after the transaction has been included in a block.\")",
      "path": "test/functional/wallet_miniscript_decaying_multisig_descriptor_psbt.py",
      "position": null,
      "original_position": 168,
      "commit_id": "aae032015367be812154a0e87955e6fd5ea5c192",
      "original_commit_id": "2422b90978f4ea13ee49954598dc8aef841e36df",
      "in_reply_to_id": null,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```\r\n2024-04-13T08:31:05.463000Z TestFramework (INFO): At block height >= 128 this multisig is 3-of-4\r\n2024-04-13T08:31:05.473000Z TestFramework (INFO): Check that the time-locked transaction is too immature to spend...\r\n2024-04-13T08:31:05.614000Z TestFramework (INFO): Check that balances are correct after the transaction has been included in a block.\r\n```\r\n\r\nThe first time I ran this test, I felt there should be another log message in between that displays something like \"Generating ABC blocks to cover for the timelock\". Reading the 3rd message immediately after the 2nd one made me think this new message might make what the test is doing more explicit.",
      "created_at": "2024-04-13T09:02:49Z",
      "updated_at": "2024-04-13T09:07:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29156#discussion_r1563885340",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1563885340"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29156"
        }
      },
      "start_line": null,
      "original_start_line": 160,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 170,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1563886096",
      "pull_request_review_id": 1999196598,
      "id": 1563886096,
      "node_id": "PRRC_kwDOABII585dNwIQ",
      "diff_hunk": "@@ -0,0 +1,177 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test a miniscript multisig that starts as 4-of-4 and \"decays\" to 3-of-4, 2-of-4, and finally 1-of-4 at each future halvening block height.\n+\n+Spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+This is based off of `test/functional/wallet_multisig_descriptor_psbt.py` and most code is the same.\n+\"\"\"\n+\n+import random\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_approx,\n+    assert_equal,\n+    assert_raises_rpc_error,\n+)\n+\n+\n+class WalletMiniscriptDecayingMultisigDescriptorPSBTTest(BitcoinTestFramework):\n+    def add_options(self, parser):\n+        self.add_wallet_options(parser, legacy=False)\n+\n+    def set_test_params(self):\n+        self.num_nodes = 4\n+        self.setup_clean_chain = True\n+        self.wallet_names = []\n+        self.extra_args = [[\"-keypool=100\"]] * self.num_nodes\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+        self.skip_if_no_sqlite()\n+\n+    @staticmethod\n+    def _get_xpub(wallet, internal):\n+        \"\"\"Extract the wallet's xpubs using `listdescriptors` and pick the one from the `pkh` descriptor since it's least likely to be accidentally reused (legacy addresses).\"\"\"\n+        pkh_descriptor = next(filter(lambda d: d[\"desc\"].startswith(\"pkh(\") and d[\"internal\"] == internal, wallet.listdescriptors()[\"descriptors\"]))\n+        # Keep all key origin information (master key fingerprint and all derivation steps) for proper support of hardware devices\n+        # See section 'Key origin identification' in 'doc/descriptors.md' for more details...\n+        return pkh_descriptor[\"desc\"].split(\"pkh(\")[1].split(\")\")[0]\n+\n+    @staticmethod\n+    def _check_psbt(psbt, to, value, multisig):\n+        \"\"\"Helper function for any of the N participants to check the psbt with decodepsbt and verify it is OK before signing.\"\"\"\n+        tx = multisig.decodepsbt(psbt)[\"tx\"]\n+        amount = 0\n+        for vout in tx[\"vout\"]:\n+            address = vout[\"scriptPubKey\"][\"address\"]\n+            assert_equal(multisig.getaddressinfo(address)[\"ischange\"], address != to)\n+            if address == to:\n+                amount += vout[\"value\"]\n+        assert_approx(amount, float(value), vspan=0.001)\n+\n+    def participants_create_multisigs(self, external_xpubs, internal_xpubs):\n+        \"\"\"The multisig is created by importing the following descriptors. The resulting wallet is watch-only and every participant can do this.\"\"\"\n+        for i, node in enumerate(self.nodes):\n+            node.createwallet(wallet_name=f\"{self.name}_{i}\", blank=True, descriptors=True, disable_private_keys=True)\n+            multisig = node.get_wallet_rpc(f\"{self.name}_{i}\")\n+            # Spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+            external = multisig.getdescriptorinfo(f\"wsh(thresh({self.N},pk({f'),s:pk('.join(external_xpubs)}),sln:after({f'),sln:after('.join(map(str, self.locktimes))})))\")\n+            internal = multisig.getdescriptorinfo(f\"wsh(thresh({self.N},pk({f'),s:pk('.join(internal_xpubs)}),sln:after({f'),sln:after('.join(map(str, self.locktimes))})))\")\n+            result = multisig.importdescriptors([\n+                {  # receiving addresses (internal: False)\n+                    \"desc\": external[\"descriptor\"],\n+                    \"active\": True,\n+                    \"internal\": False,\n+                    \"timestamp\": \"now\",\n+                },\n+                {  # change addresses (internal: True)\n+                    \"desc\": internal[\"descriptor\"],\n+                    \"active\": True,\n+                    \"internal\": True,\n+                    \"timestamp\": \"now\",\n+                },\n+            ])\n+            assert all(r[\"success\"] for r in result)\n+            yield multisig\n+\n+    def run_test(self):\n+        self.M = self.num_nodes\n+        self.N = self.num_nodes\n+        self.locktimes = [128, 256, 512]  # in real-world align with future halvenings: [840000, 1050000, 1260000]\n+        assert_equal(len(self.locktimes), self.N - 1)\n+\n+        self.name = f\"{self.M}_of_{self.N}_decaying_multisig\"\n+        self.log.info(f\"Testing {self.name}...\")\n+\n+        participants = {\n+            # Every participant generates an xpub. The most straightforward way is to create a new descriptor wallet.\n+            # This wallet will be the participant's `signer` for the resulting multisig. Avoid reusing this wallet for any other purpose (for privacy reasons).\n+            \"signers\": [node.get_wallet_rpc(node.createwallet(wallet_name=f\"participant_{self.nodes.index(node)}\", descriptors=True)[\"name\"]) for node in self.nodes],\n+            # After participants generate and exchange their xpubs they will each create their own watch-only multisig.\n+            # Note: these multisigs are all the same, this just highlights that each participant can independently verify everything on their own node.\n+            \"multisigs\": []\n+        }\n+\n+        self.log.info(\"Generate and exchange xpubs...\")\n+        external_xpubs, internal_xpubs = [[self._get_xpub(signer, internal) for signer in participants[\"signers\"]] for internal in [False, True]]\n+\n+        self.log.info(\"Every participant imports the following descriptors to create the watch-only multisig...\")\n+        participants[\"multisigs\"] = list(self.participants_create_multisigs(external_xpubs, internal_xpubs))\n+\n+        self.log.info(\"Check that every participant's multisig generates the same addresses...\")\n+        for _ in range(10):  # we check that the first 10 generated addresses are the same for all participant's multisigs\n+            receive_addresses = [multisig.getnewaddress() for multisig in participants[\"multisigs\"]]\n+            all(address == receive_addresses[0] for address in receive_addresses)\n+            change_addresses = [multisig.getrawchangeaddress() for multisig in participants[\"multisigs\"]]\n+            all(address == change_addresses[0] for address in change_addresses)\n+\n+        self.log.info(\"Get a mature utxo to send to the multisig...\")\n+        coordinator_wallet = participants[\"signers\"][0]\n+        self.generatetoaddress(self.nodes[0], 101, coordinator_wallet.getnewaddress())\n+\n+        deposit_amount = 6.15\n+        multisig_receiving_address = participants[\"multisigs\"][0].getnewaddress()\n+        self.log.info(\"Send funds to the resulting multisig receiving address...\")\n+        coordinator_wallet.sendtoaddress(multisig_receiving_address, deposit_amount)\n+        self.generate(self.nodes[0], 1)\n+        for participant in participants[\"multisigs\"]:\n+            assert_approx(participant.getbalance(), deposit_amount, vspan=0.001)\n+\n+        self.log.info(\"Send a transaction from the multisig! We can always spend with all signers!\")\n+        to = participants[\"signers\"][self.N - 1].getnewaddress()\n+        value = 1.5\n+        self.log.info(\"First, make a sending transaction, created using `walletcreatefundedpsbt` (anyone can initiate this)...\")\n+        psbt = participants[\"multisigs\"][0].walletcreatefundedpsbt(inputs=[], outputs={to: value}, feeRate=0.00010)\n+\n+        psbts = []\n+        self.log.info(\"Now at least M users check the psbt with decodepsbt and (if OK) signs it with walletprocesspsbt...\")\n+        for m in random.sample(range(self.M), self.M):\n+            signers_multisig = participants[\"multisigs\"][m]\n+            self._check_psbt(psbt[\"psbt\"], to, value, signers_multisig)\n+            signing_wallet = participants[\"signers\"][m]\n+            partially_signed_psbt = signing_wallet.walletprocesspsbt(psbt[\"psbt\"])\n+            psbts.append(partially_signed_psbt[\"psbt\"])\n+\n+        self.log.info(\"Finally, collect the signed PSBTs with combinepsbt, finalizepsbt, then broadcast the resulting transaction...\")\n+        combined = coordinator_wallet.combinepsbt(psbts)\n+        finalized = coordinator_wallet.finalizepsbt(combined)\n+        coordinator_wallet.sendrawtransaction(finalized[\"hex\"])\n+\n+        self.log.info(\"Check that balances are correct after the transaction has been included in a block.\")\n+        self.generate(self.nodes[0], 1)\n+        assert_approx(participants[\"multisigs\"][0].getbalance(), deposit_amount - value, vspan=0.001)\n+        assert_equal(participants[\"signers\"][self.N - 1].getbalance(), value)\n+\n+        self.log.info(\"Send more transactions from the multisig as required signers decay, this time with a daisy chained signing flow (one after another in series)!\")\n+        sent = value\n+        for locktime in self.locktimes:\n+            self.M -= 1\n+            self.log.info(f\"At block height >= {locktime} this multisig is {self.M}-of-{self.N}\")\n+            current_height = self.nodes[0].getblock(self.nodes[0].getbestblockhash())['height']\n+\n+            psbt = participants[\"multisigs\"][0].walletcreatefundedpsbt(inputs=[], outputs={to: value}, feeRate=0.00010, locktime=locktime)",
      "path": "test/functional/wallet_miniscript_decaying_multisig_descriptor_psbt.py",
      "position": null,
      "original_position": 154,
      "commit_id": "aae032015367be812154a0e87955e6fd5ea5c192",
      "original_commit_id": "5023b47e85161a0b35839ce03c7b5d55ff1cd4c1",
      "in_reply_to_id": 1558033127,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> then wallet would not process that psbt as complete with 3 valid signatures like I expected\r\n\r\nDo you mean the 4-signature transaction was rejected? ",
      "created_at": "2024-04-13T09:04:18Z",
      "updated_at": "2024-04-13T09:07:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29156#discussion_r1563886096",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1563886096"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29156"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 154,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1563887374",
      "pull_request_review_id": 1999196598,
      "id": 1563887374,
      "node_id": "PRRC_kwDOABII585dNwcO",
      "diff_hunk": "@@ -0,0 +1,176 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test a miniscript multisig that starts as 4-of-4 and \"decays\" to 3-of-4, 2-of-4, and finally 1-of-4 at each future halvening block height.\n+\n+Spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+This is based off of `test/functional/wallet_multisig_descriptor_psbt.py` and most code is the same.\n+\"\"\"\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_approx,\n+    assert_equal,\n+    assert_raises_rpc_error,\n+)\n+\n+\n+class WalletMiniscriptDecayingMultisigDescriptorPSBTTest(BitcoinTestFramework):\n+    def add_options(self, parser):\n+        self.add_wallet_options(parser, legacy=False)\n+\n+    def set_test_params(self):\n+        self.num_nodes = 4\n+        self.setup_clean_chain = True\n+        self.wallet_names = []\n+        self.extra_args = [[\"-keypool=100\"]] * self.num_nodes\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+        self.skip_if_no_sqlite()\n+\n+    @staticmethod\n+    def _get_xpub(wallet, internal):\n+        \"\"\"Extract the wallet's xpubs using `listdescriptors` and pick the one from the `pkh` descriptor since it's least likely to be accidentally reused (legacy addresses).\"\"\"\n+        pkh_descriptor = next(filter(lambda d: d[\"desc\"].startswith(\"pkh(\") and d[\"internal\"] == internal, wallet.listdescriptors()[\"descriptors\"]))\n+        # Keep all key origin information (master key fingerprint and all derivation steps) for proper support of hardware devices\n+        # See section 'Key origin identification' in 'doc/descriptors.md' for more details...\n+        return pkh_descriptor[\"desc\"].split(\"pkh(\")[1].split(\")\")[0]\n+\n+    @staticmethod\n+    def _check_psbt(psbt, to, value, multisig):\n+        \"\"\"Helper function for any of the N participants to check the psbt with decodepsbt and verify it is OK before signing.\"\"\"\n+        tx = multisig.decodepsbt(psbt)[\"tx\"]\n+        amount = 0\n+        for vout in tx[\"vout\"]:\n+            address = vout[\"scriptPubKey\"][\"address\"]\n+            assert_equal(multisig.getaddressinfo(address)[\"ischange\"], address != to)\n+            if address == to:\n+                amount += vout[\"value\"]\n+        assert_approx(amount, float(value), vspan=0.001)\n+\n+    def participants_create_multisigs(self, external_xpubs, internal_xpubs):\n+        \"\"\"The multisig is created by importing the following descriptors. The resulting wallet is watch-only and every participant can do this.\"\"\"\n+        for i, node in enumerate(self.nodes):\n+            node.createwallet(wallet_name=f\"{self.name}_{i}\", blank=True, descriptors=True, disable_private_keys=True)\n+            multisig = node.get_wallet_rpc(f\"{self.name}_{i}\")\n+            # Spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+            external = multisig.getdescriptorinfo(f\"wsh(thresh({self.N},pk({f'),s:pk('.join(external_xpubs)}),sln:after({f'),sln:after('.join(map(str, self.locktimes))})))\")\n+            internal = multisig.getdescriptorinfo(f\"wsh(thresh({self.N},pk({f'),s:pk('.join(internal_xpubs)}),sln:after({f'),sln:after('.join(map(str, self.locktimes))})))\")\n+            result = multisig.importdescriptors([\n+                {  # receiving addresses (internal: False)\n+                    \"desc\": external[\"descriptor\"],\n+                    \"active\": True,\n+                    \"internal\": False,\n+                    \"timestamp\": \"now\",\n+                },\n+                {  # change addresses (internal: True)\n+                    \"desc\": internal[\"descriptor\"],\n+                    \"active\": True,\n+                    \"internal\": True,\n+                    \"timestamp\": \"now\",\n+                },\n+            ])\n+            assert all(r[\"success\"] for r in result)\n+            yield multisig\n+\n+    def run_test(self):\n+        self.M = self.num_nodes\n+        self.N = self.num_nodes\n+        self.locktimes = [128, 256, 512]  # in real-world align with future halvenings: [840000, 1050000, 1260000]\n+        assert_equal(len(self.locktimes), self.N - 1)\n+\n+        self.name = f\"{self.M}_of_{self.N}_decaying_multisig\"\n+        self.log.info(f\"Testing {self.name}...\")\n+\n+        participants = {\n+            # Every participant generates an xpub. The most straightforward way is to create a new descriptor wallet.\n+            # This wallet will be the participant's `signer` for the resulting multisig. Avoid reusing this wallet for any other purpose (for privacy reasons).\n+            \"signers\": [node.get_wallet_rpc(node.createwallet(wallet_name=f\"participant_{self.nodes.index(node)}\", descriptors=True)[\"name\"]) for node in self.nodes],\n+            # After participants generate and exchange their xpubs they will each create their own watch-only multisig.\n+            # Note: these multisigs are all the same, this just highlights that each participant can independently verify everything on their own node.\n+            \"multisigs\": []\n+        }\n+\n+        self.log.info(\"Generate and exchange xpubs...\")\n+        external_xpubs, internal_xpubs = [[self._get_xpub(signer, internal) for signer in participants[\"signers\"]] for internal in [False, True]]\n+\n+        self.log.info(\"Every participant imports the following descriptors to create the watch-only multisig...\")\n+        participants[\"multisigs\"] = list(self.participants_create_multisigs(external_xpubs, internal_xpubs))\n+\n+        self.log.info(\"Check that every participant's multisig generates the same addresses...\")\n+        for _ in range(10):  # we check that the first 10 generated addresses are the same for all participant's multisigs\n+            receive_addresses = [multisig.getnewaddress() for multisig in participants[\"multisigs\"]]\n+            all(address == receive_addresses[0] for address in receive_addresses)\n+            change_addresses = [multisig.getrawchangeaddress() for multisig in participants[\"multisigs\"]]\n+            all(address == change_addresses[0] for address in change_addresses)\n+\n+        self.log.info(\"Get a mature utxo to send to the multisig...\")\n+        coordinator_wallet = participants[\"signers\"][0]\n+        self.generatetoaddress(self.nodes[0], 101, coordinator_wallet.getnewaddress())\n+\n+        deposit_amount = 6.15\n+        multisig_receiving_address = participants[\"multisigs\"][0].getnewaddress()\n+        self.log.info(\"Send funds to the resulting multisig receiving address...\")\n+        coordinator_wallet.sendtoaddress(multisig_receiving_address, deposit_amount)\n+        self.generate(self.nodes[0], 1)\n+        for participant in participants[\"multisigs\"]:\n+            assert_approx(participant.getbalance(), deposit_amount, vspan=0.001)\n+\n+        self.log.info(\"Send a transaction from the multisig! We can always spend with all signers!\")\n+        to = participants[\"signers\"][self.N - 1].getnewaddress()\n+        value = 1.5\n+        self.log.info(\"First, make a sending transaction, created using `walletcreatefundedpsbt` (anyone can initiate this)...\")\n+        psbt = participants[\"multisigs\"][0].walletcreatefundedpsbt(inputs=[], outputs={to: value}, feeRate=0.00010)\n+\n+        psbts = []\n+        self.log.info(\"Now at least M users check the psbt with decodepsbt and (if OK) signs it with walletprocesspsbt...\")\n+        for m in range(self.M):\n+            signers_multisig = participants[\"multisigs\"][m]\n+            self._check_psbt(psbt[\"psbt\"], to, value, signers_multisig)\n+            signing_wallet = participants[\"signers\"][m]\n+            partially_signed_psbt = signing_wallet.walletprocesspsbt(psbt[\"psbt\"])\n+            psbts.append(partially_signed_psbt[\"psbt\"])\n+\n+        self.log.info(\"Finally, collect the signed PSBTs with combinepsbt, finalizepsbt, then broadcast the resulting transaction...\")\n+        combined = coordinator_wallet.combinepsbt(psbts)\n+        finalized = coordinator_wallet.finalizepsbt(combined)\n+        coordinator_wallet.sendrawtransaction(finalized[\"hex\"])\n+\n+        self.log.info(\"Check that balances are correct after the transaction has been included in a block.\")\n+        self.generate(self.nodes[0], 1)\n+        assert_approx(participants[\"multisigs\"][0].getbalance(), deposit_amount - value, vspan=0.001)\n+        assert_equal(participants[\"signers\"][self.N - 1].getbalance(), value)\n+\n+        self.log.info(\"Send more transactions from the multisig as required signers decay, this time with a daisy chained signing flow (one after another in series)!\")",
      "path": "test/functional/wallet_miniscript_decaying_multisig_descriptor_psbt.py",
      "position": null,
      "original_position": 146,
      "commit_id": "aae032015367be812154a0e87955e6fd5ea5c192",
      "original_commit_id": "2422b90978f4ea13ee49954598dc8aef841e36df",
      "in_reply_to_id": null,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Most of the code before this one is very similar to `wallet_multisig_descriptor_psbt.py` test - `participants_create_multisigs` is different though.\r\nAs pointed out in other reviews as well, I feel this test can go in the same file and some commonalities can be extracted, but I don't think this is blocking though.  ",
      "created_at": "2024-04-13T09:07:18Z",
      "updated_at": "2024-04-13T09:07:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29156#discussion_r1563887374",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1563887374"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29156"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 147,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1564307022",
      "pull_request_review_id": 1999371847,
      "id": 1564307022,
      "node_id": "PRRC_kwDOABII585dPW5O",
      "diff_hunk": "@@ -0,0 +1,176 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test a miniscript multisig that starts as 4-of-4 and \"decays\" to 3-of-4, 2-of-4, and finally 1-of-4 at each future halvening block height.\n+\n+Spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+This is based off of `test/functional/wallet_multisig_descriptor_psbt.py` and most code is the same.\n+\"\"\"\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_approx,\n+    assert_equal,\n+    assert_raises_rpc_error,\n+)\n+\n+\n+class WalletMiniscriptDecayingMultisigDescriptorPSBTTest(BitcoinTestFramework):\n+    def add_options(self, parser):\n+        self.add_wallet_options(parser, legacy=False)\n+\n+    def set_test_params(self):\n+        self.num_nodes = 4\n+        self.setup_clean_chain = True\n+        self.wallet_names = []\n+        self.extra_args = [[\"-keypool=100\"]] * self.num_nodes\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+        self.skip_if_no_sqlite()\n+\n+    @staticmethod\n+    def _get_xpub(wallet, internal):\n+        \"\"\"Extract the wallet's xpubs using `listdescriptors` and pick the one from the `pkh` descriptor since it's least likely to be accidentally reused (legacy addresses).\"\"\"\n+        pkh_descriptor = next(filter(lambda d: d[\"desc\"].startswith(\"pkh(\") and d[\"internal\"] == internal, wallet.listdescriptors()[\"descriptors\"]))\n+        # Keep all key origin information (master key fingerprint and all derivation steps) for proper support of hardware devices\n+        # See section 'Key origin identification' in 'doc/descriptors.md' for more details...\n+        return pkh_descriptor[\"desc\"].split(\"pkh(\")[1].split(\")\")[0]\n+\n+    @staticmethod\n+    def _check_psbt(psbt, to, value, multisig):\n+        \"\"\"Helper function for any of the N participants to check the psbt with decodepsbt and verify it is OK before signing.\"\"\"\n+        tx = multisig.decodepsbt(psbt)[\"tx\"]\n+        amount = 0\n+        for vout in tx[\"vout\"]:\n+            address = vout[\"scriptPubKey\"][\"address\"]\n+            assert_equal(multisig.getaddressinfo(address)[\"ischange\"], address != to)\n+            if address == to:\n+                amount += vout[\"value\"]\n+        assert_approx(amount, float(value), vspan=0.001)\n+\n+    def participants_create_multisigs(self, external_xpubs, internal_xpubs):\n+        \"\"\"The multisig is created by importing the following descriptors. The resulting wallet is watch-only and every participant can do this.\"\"\"\n+        for i, node in enumerate(self.nodes):\n+            node.createwallet(wallet_name=f\"{self.name}_{i}\", blank=True, descriptors=True, disable_private_keys=True)\n+            multisig = node.get_wallet_rpc(f\"{self.name}_{i}\")\n+            # Spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+            external = multisig.getdescriptorinfo(f\"wsh(thresh({self.N},pk({f'),s:pk('.join(external_xpubs)}),sln:after({f'),sln:after('.join(map(str, self.locktimes))})))\")\n+            internal = multisig.getdescriptorinfo(f\"wsh(thresh({self.N},pk({f'),s:pk('.join(internal_xpubs)}),sln:after({f'),sln:after('.join(map(str, self.locktimes))})))\")\n+            result = multisig.importdescriptors([\n+                {  # receiving addresses (internal: False)\n+                    \"desc\": external[\"descriptor\"],\n+                    \"active\": True,\n+                    \"internal\": False,\n+                    \"timestamp\": \"now\",\n+                },\n+                {  # change addresses (internal: True)\n+                    \"desc\": internal[\"descriptor\"],\n+                    \"active\": True,\n+                    \"internal\": True,\n+                    \"timestamp\": \"now\",\n+                },\n+            ])\n+            assert all(r[\"success\"] for r in result)\n+            yield multisig\n+\n+    def run_test(self):\n+        self.M = self.num_nodes\n+        self.N = self.num_nodes\n+        self.locktimes = [128, 256, 512]  # in real-world align with future halvenings: [840000, 1050000, 1260000]\n+        assert_equal(len(self.locktimes), self.N - 1)\n+\n+        self.name = f\"{self.M}_of_{self.N}_decaying_multisig\"\n+        self.log.info(f\"Testing {self.name}...\")\n+\n+        participants = {\n+            # Every participant generates an xpub. The most straightforward way is to create a new descriptor wallet.\n+            # This wallet will be the participant's `signer` for the resulting multisig. Avoid reusing this wallet for any other purpose (for privacy reasons).\n+            \"signers\": [node.get_wallet_rpc(node.createwallet(wallet_name=f\"participant_{self.nodes.index(node)}\", descriptors=True)[\"name\"]) for node in self.nodes],\n+            # After participants generate and exchange their xpubs they will each create their own watch-only multisig.\n+            # Note: these multisigs are all the same, this just highlights that each participant can independently verify everything on their own node.\n+            \"multisigs\": []\n+        }\n+\n+        self.log.info(\"Generate and exchange xpubs...\")\n+        external_xpubs, internal_xpubs = [[self._get_xpub(signer, internal) for signer in participants[\"signers\"]] for internal in [False, True]]\n+\n+        self.log.info(\"Every participant imports the following descriptors to create the watch-only multisig...\")\n+        participants[\"multisigs\"] = list(self.participants_create_multisigs(external_xpubs, internal_xpubs))\n+\n+        self.log.info(\"Check that every participant's multisig generates the same addresses...\")\n+        for _ in range(10):  # we check that the first 10 generated addresses are the same for all participant's multisigs\n+            receive_addresses = [multisig.getnewaddress() for multisig in participants[\"multisigs\"]]\n+            all(address == receive_addresses[0] for address in receive_addresses)\n+            change_addresses = [multisig.getrawchangeaddress() for multisig in participants[\"multisigs\"]]\n+            all(address == change_addresses[0] for address in change_addresses)\n+\n+        self.log.info(\"Get a mature utxo to send to the multisig...\")\n+        coordinator_wallet = participants[\"signers\"][0]\n+        self.generatetoaddress(self.nodes[0], 101, coordinator_wallet.getnewaddress())\n+\n+        deposit_amount = 6.15\n+        multisig_receiving_address = participants[\"multisigs\"][0].getnewaddress()\n+        self.log.info(\"Send funds to the resulting multisig receiving address...\")\n+        coordinator_wallet.sendtoaddress(multisig_receiving_address, deposit_amount)\n+        self.generate(self.nodes[0], 1)\n+        for participant in participants[\"multisigs\"]:\n+            assert_approx(participant.getbalance(), deposit_amount, vspan=0.001)\n+\n+        self.log.info(\"Send a transaction from the multisig! We can always spend with all signers!\")\n+        to = participants[\"signers\"][self.N - 1].getnewaddress()\n+        value = 1.5\n+        self.log.info(\"First, make a sending transaction, created using `walletcreatefundedpsbt` (anyone can initiate this)...\")\n+        psbt = participants[\"multisigs\"][0].walletcreatefundedpsbt(inputs=[], outputs={to: value}, feeRate=0.00010)\n+\n+        psbts = []\n+        self.log.info(\"Now at least M users check the psbt with decodepsbt and (if OK) signs it with walletprocesspsbt...\")\n+        for m in range(self.M):\n+            signers_multisig = participants[\"multisigs\"][m]\n+            self._check_psbt(psbt[\"psbt\"], to, value, signers_multisig)\n+            signing_wallet = participants[\"signers\"][m]\n+            partially_signed_psbt = signing_wallet.walletprocesspsbt(psbt[\"psbt\"])\n+            psbts.append(partially_signed_psbt[\"psbt\"])\n+\n+        self.log.info(\"Finally, collect the signed PSBTs with combinepsbt, finalizepsbt, then broadcast the resulting transaction...\")\n+        combined = coordinator_wallet.combinepsbt(psbts)\n+        finalized = coordinator_wallet.finalizepsbt(combined)\n+        coordinator_wallet.sendrawtransaction(finalized[\"hex\"])\n+\n+        self.log.info(\"Check that balances are correct after the transaction has been included in a block.\")\n+        self.generate(self.nodes[0], 1)\n+        assert_approx(participants[\"multisigs\"][0].getbalance(), deposit_amount - value, vspan=0.001)\n+        assert_equal(participants[\"signers\"][self.N - 1].getbalance(), value)\n+\n+        self.log.info(\"Send more transactions from the multisig as required signers decay, this time with a daisy chained signing flow (one after another in series)!\")\n+        sent = value\n+        for locktime in self.locktimes:\n+            self.M -= 1\n+            self.log.info(f\"At block height >= {locktime} this multisig is {self.M}-of-{self.N}\")\n+            current_height = self.nodes[0].getblock(self.nodes[0].getbestblockhash())['height']\n+\n+            psbt = participants[\"multisigs\"][0].walletcreatefundedpsbt(inputs=[], outputs={to: value}, feeRate=0.00010, locktime=locktime)\n+            for m in range(self.M):\n+                signers_multisig = participants[\"multisigs\"][m]\n+                self._check_psbt(psbt[\"psbt\"], to, value, signers_multisig)\n+                signing_wallet = participants[\"signers\"][m]\n+                psbt = signing_wallet.walletprocesspsbt(psbt[\"psbt\"])\n+                assert_equal(psbt[\"complete\"], m == self.M - 1)\n+            self.log.info(\"Check that the time-locked transaction is too immature to spend...\")\n+            assert_equal(current_height >= locktime, False)\n+            assert_raises_rpc_error(-26, \"non-final\", coordinator_wallet.sendrawtransaction, psbt[\"hex\"])\n+\n+            self.generate(self.nodes[0], locktime)\n+            self.sync_blocks()\n+            coordinator_wallet.sendrawtransaction(psbt[\"hex\"])\n+\n+            self.log.info(\"Check that balances are correct after the transaction has been included in a block.\")",
      "path": "test/functional/wallet_miniscript_decaying_multisig_descriptor_psbt.py",
      "position": null,
      "original_position": 168,
      "commit_id": "aae032015367be812154a0e87955e6fd5ea5c192",
      "original_commit_id": "2422b90978f4ea13ee49954598dc8aef841e36df",
      "in_reply_to_id": 1563885340,
      "user": {
        "login": "mjdietzx",
        "id": 7217256,
        "node_id": "MDQ6VXNlcjcyMTcyNTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7217256?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mjdietzx",
        "html_url": "https://github.com/mjdietzx",
        "followers_url": "https://api.github.com/users/mjdietzx/followers",
        "following_url": "https://api.github.com/users/mjdietzx/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mjdietzx/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mjdietzx/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mjdietzx/subscriptions",
        "organizations_url": "https://api.github.com/users/mjdietzx/orgs",
        "repos_url": "https://api.github.com/users/mjdietzx/repos",
        "events_url": "https://api.github.com/users/mjdietzx/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mjdietzx/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Good point! I added the message like you suggest. Logs now read:\r\n```\r\n2024-04-13T23:05:41.654000Z TestFramework (INFO): At block height >= 128 this multisig is 3-of-4\r\n2024-04-13T23:05:41.674000Z TestFramework (INFO): Check that the time-locked transaction is too immature to spend with 3-of-4 at block height 103...\r\n2024-04-13T23:05:41.675000Z TestFramework (INFO): Generate blocks to reach the time-lock block height 128 and broadcast the transaction...\r\n2024-04-13T23:05:42.888000Z TestFramework (INFO): Check that balances are correct after the transaction has been included in a block.\r\n```",
      "created_at": "2024-04-13T23:07:36Z",
      "updated_at": "2024-04-13T23:07:36Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29156#discussion_r1564307022",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1564307022"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29156"
        }
      },
      "start_line": null,
      "original_start_line": 160,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 170,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1564361740",
      "pull_request_review_id": 1999395283,
      "id": 1564361740,
      "node_id": "PRRC_kwDOABII585dPkQM",
      "diff_hunk": "@@ -0,0 +1,177 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test a miniscript multisig that starts as 4-of-4 and \"decays\" to 3-of-4, 2-of-4, and finally 1-of-4 at each future halvening block height.\n+\n+Spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+This is based off of `test/functional/wallet_multisig_descriptor_psbt.py` and most code is the same.\n+\"\"\"\n+\n+import random\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_approx,\n+    assert_equal,\n+    assert_raises_rpc_error,\n+)\n+\n+\n+class WalletMiniscriptDecayingMultisigDescriptorPSBTTest(BitcoinTestFramework):\n+    def add_options(self, parser):\n+        self.add_wallet_options(parser, legacy=False)\n+\n+    def set_test_params(self):\n+        self.num_nodes = 4\n+        self.setup_clean_chain = True\n+        self.wallet_names = []\n+        self.extra_args = [[\"-keypool=100\"]] * self.num_nodes\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+        self.skip_if_no_sqlite()\n+\n+    @staticmethod\n+    def _get_xpub(wallet, internal):\n+        \"\"\"Extract the wallet's xpubs using `listdescriptors` and pick the one from the `pkh` descriptor since it's least likely to be accidentally reused (legacy addresses).\"\"\"\n+        pkh_descriptor = next(filter(lambda d: d[\"desc\"].startswith(\"pkh(\") and d[\"internal\"] == internal, wallet.listdescriptors()[\"descriptors\"]))\n+        # Keep all key origin information (master key fingerprint and all derivation steps) for proper support of hardware devices\n+        # See section 'Key origin identification' in 'doc/descriptors.md' for more details...\n+        return pkh_descriptor[\"desc\"].split(\"pkh(\")[1].split(\")\")[0]\n+\n+    @staticmethod\n+    def _check_psbt(psbt, to, value, multisig):\n+        \"\"\"Helper function for any of the N participants to check the psbt with decodepsbt and verify it is OK before signing.\"\"\"\n+        tx = multisig.decodepsbt(psbt)[\"tx\"]\n+        amount = 0\n+        for vout in tx[\"vout\"]:\n+            address = vout[\"scriptPubKey\"][\"address\"]\n+            assert_equal(multisig.getaddressinfo(address)[\"ischange\"], address != to)\n+            if address == to:\n+                amount += vout[\"value\"]\n+        assert_approx(amount, float(value), vspan=0.001)\n+\n+    def participants_create_multisigs(self, external_xpubs, internal_xpubs):\n+        \"\"\"The multisig is created by importing the following descriptors. The resulting wallet is watch-only and every participant can do this.\"\"\"\n+        for i, node in enumerate(self.nodes):\n+            node.createwallet(wallet_name=f\"{self.name}_{i}\", blank=True, descriptors=True, disable_private_keys=True)\n+            multisig = node.get_wallet_rpc(f\"{self.name}_{i}\")\n+            # Spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+            external = multisig.getdescriptorinfo(f\"wsh(thresh({self.N},pk({f'),s:pk('.join(external_xpubs)}),sln:after({f'),sln:after('.join(map(str, self.locktimes))})))\")\n+            internal = multisig.getdescriptorinfo(f\"wsh(thresh({self.N},pk({f'),s:pk('.join(internal_xpubs)}),sln:after({f'),sln:after('.join(map(str, self.locktimes))})))\")\n+            result = multisig.importdescriptors([\n+                {  # receiving addresses (internal: False)\n+                    \"desc\": external[\"descriptor\"],\n+                    \"active\": True,\n+                    \"internal\": False,\n+                    \"timestamp\": \"now\",\n+                },\n+                {  # change addresses (internal: True)\n+                    \"desc\": internal[\"descriptor\"],\n+                    \"active\": True,\n+                    \"internal\": True,\n+                    \"timestamp\": \"now\",\n+                },\n+            ])\n+            assert all(r[\"success\"] for r in result)\n+            yield multisig\n+\n+    def run_test(self):\n+        self.M = self.num_nodes\n+        self.N = self.num_nodes\n+        self.locktimes = [128, 256, 512]  # in real-world align with future halvenings: [840000, 1050000, 1260000]\n+        assert_equal(len(self.locktimes), self.N - 1)\n+\n+        self.name = f\"{self.M}_of_{self.N}_decaying_multisig\"\n+        self.log.info(f\"Testing {self.name}...\")\n+\n+        participants = {\n+            # Every participant generates an xpub. The most straightforward way is to create a new descriptor wallet.\n+            # This wallet will be the participant's `signer` for the resulting multisig. Avoid reusing this wallet for any other purpose (for privacy reasons).\n+            \"signers\": [node.get_wallet_rpc(node.createwallet(wallet_name=f\"participant_{self.nodes.index(node)}\", descriptors=True)[\"name\"]) for node in self.nodes],\n+            # After participants generate and exchange their xpubs they will each create their own watch-only multisig.\n+            # Note: these multisigs are all the same, this just highlights that each participant can independently verify everything on their own node.\n+            \"multisigs\": []\n+        }\n+\n+        self.log.info(\"Generate and exchange xpubs...\")\n+        external_xpubs, internal_xpubs = [[self._get_xpub(signer, internal) for signer in participants[\"signers\"]] for internal in [False, True]]\n+\n+        self.log.info(\"Every participant imports the following descriptors to create the watch-only multisig...\")\n+        participants[\"multisigs\"] = list(self.participants_create_multisigs(external_xpubs, internal_xpubs))\n+\n+        self.log.info(\"Check that every participant's multisig generates the same addresses...\")\n+        for _ in range(10):  # we check that the first 10 generated addresses are the same for all participant's multisigs\n+            receive_addresses = [multisig.getnewaddress() for multisig in participants[\"multisigs\"]]\n+            all(address == receive_addresses[0] for address in receive_addresses)\n+            change_addresses = [multisig.getrawchangeaddress() for multisig in participants[\"multisigs\"]]\n+            all(address == change_addresses[0] for address in change_addresses)\n+\n+        self.log.info(\"Get a mature utxo to send to the multisig...\")\n+        coordinator_wallet = participants[\"signers\"][0]\n+        self.generatetoaddress(self.nodes[0], 101, coordinator_wallet.getnewaddress())\n+\n+        deposit_amount = 6.15\n+        multisig_receiving_address = participants[\"multisigs\"][0].getnewaddress()\n+        self.log.info(\"Send funds to the resulting multisig receiving address...\")\n+        coordinator_wallet.sendtoaddress(multisig_receiving_address, deposit_amount)\n+        self.generate(self.nodes[0], 1)\n+        for participant in participants[\"multisigs\"]:\n+            assert_approx(participant.getbalance(), deposit_amount, vspan=0.001)\n+\n+        self.log.info(\"Send a transaction from the multisig! We can always spend with all signers!\")\n+        to = participants[\"signers\"][self.N - 1].getnewaddress()\n+        value = 1.5\n+        self.log.info(\"First, make a sending transaction, created using `walletcreatefundedpsbt` (anyone can initiate this)...\")\n+        psbt = participants[\"multisigs\"][0].walletcreatefundedpsbt(inputs=[], outputs={to: value}, feeRate=0.00010)\n+\n+        psbts = []\n+        self.log.info(\"Now at least M users check the psbt with decodepsbt and (if OK) signs it with walletprocesspsbt...\")\n+        for m in random.sample(range(self.M), self.M):\n+            signers_multisig = participants[\"multisigs\"][m]\n+            self._check_psbt(psbt[\"psbt\"], to, value, signers_multisig)\n+            signing_wallet = participants[\"signers\"][m]\n+            partially_signed_psbt = signing_wallet.walletprocesspsbt(psbt[\"psbt\"])\n+            psbts.append(partially_signed_psbt[\"psbt\"])\n+\n+        self.log.info(\"Finally, collect the signed PSBTs with combinepsbt, finalizepsbt, then broadcast the resulting transaction...\")\n+        combined = coordinator_wallet.combinepsbt(psbts)\n+        finalized = coordinator_wallet.finalizepsbt(combined)\n+        coordinator_wallet.sendrawtransaction(finalized[\"hex\"])\n+\n+        self.log.info(\"Check that balances are correct after the transaction has been included in a block.\")\n+        self.generate(self.nodes[0], 1)\n+        assert_approx(participants[\"multisigs\"][0].getbalance(), deposit_amount - value, vspan=0.001)\n+        assert_equal(participants[\"signers\"][self.N - 1].getbalance(), value)\n+\n+        self.log.info(\"Send more transactions from the multisig as required signers decay, this time with a daisy chained signing flow (one after another in series)!\")\n+        sent = value\n+        for locktime in self.locktimes:\n+            self.M -= 1\n+            self.log.info(f\"At block height >= {locktime} this multisig is {self.M}-of-{self.N}\")\n+            current_height = self.nodes[0].getblock(self.nodes[0].getbestblockhash())['height']\n+\n+            psbt = participants[\"multisigs\"][0].walletcreatefundedpsbt(inputs=[], outputs={to: value}, feeRate=0.00010, locktime=locktime)",
      "path": "test/functional/wallet_miniscript_decaying_multisig_descriptor_psbt.py",
      "position": null,
      "original_position": 154,
      "commit_id": "aae032015367be812154a0e87955e6fd5ea5c192",
      "original_commit_id": "5023b47e85161a0b35839ce03c7b5d55ff1cd4c1",
      "in_reply_to_id": 1558033127,
      "user": {
        "login": "mjdietzx",
        "id": 7217256,
        "node_id": "MDQ6VXNlcjcyMTcyNTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7217256?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mjdietzx",
        "html_url": "https://github.com/mjdietzx",
        "followers_url": "https://api.github.com/users/mjdietzx/followers",
        "following_url": "https://api.github.com/users/mjdietzx/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mjdietzx/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mjdietzx/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mjdietzx/subscriptions",
        "organizations_url": "https://api.github.com/users/mjdietzx/orgs",
        "repos_url": "https://api.github.com/users/mjdietzx/repos",
        "events_url": "https://api.github.com/users/mjdietzx/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mjdietzx/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I just got confused here. CLTV opcode checks against spending transaction `nLockTime`. So behavior is exactly as expected\r\n\r\n> Do you mean the 4-signature transaction was rejected?\r\n\r\nNo I didn't mean this. 4-signature transaction would never be rejected. But I explained this confusingly so you can ignore my comment above",
      "created_at": "2024-04-14T01:12:06Z",
      "updated_at": "2024-04-14T01:12:06Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29156#discussion_r1564361740",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1564361740"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29156"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 154,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1564364788",
      "pull_request_review_id": 1999396323,
      "id": 1564364788,
      "node_id": "PRRC_kwDOABII585dPk_0",
      "diff_hunk": "@@ -0,0 +1,176 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test a miniscript multisig that starts as 4-of-4 and \"decays\" to 3-of-4, 2-of-4, and finally 1-of-4 at each future halvening block height.\n+\n+Spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+This is based off of `test/functional/wallet_multisig_descriptor_psbt.py` and most code is the same.\n+\"\"\"\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_approx,\n+    assert_equal,\n+    assert_raises_rpc_error,\n+)\n+\n+\n+class WalletMiniscriptDecayingMultisigDescriptorPSBTTest(BitcoinTestFramework):\n+    def add_options(self, parser):\n+        self.add_wallet_options(parser, legacy=False)\n+\n+    def set_test_params(self):\n+        self.num_nodes = 4\n+        self.setup_clean_chain = True\n+        self.wallet_names = []\n+        self.extra_args = [[\"-keypool=100\"]] * self.num_nodes\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+        self.skip_if_no_sqlite()\n+\n+    @staticmethod\n+    def _get_xpub(wallet, internal):\n+        \"\"\"Extract the wallet's xpubs using `listdescriptors` and pick the one from the `pkh` descriptor since it's least likely to be accidentally reused (legacy addresses).\"\"\"\n+        pkh_descriptor = next(filter(lambda d: d[\"desc\"].startswith(\"pkh(\") and d[\"internal\"] == internal, wallet.listdescriptors()[\"descriptors\"]))\n+        # Keep all key origin information (master key fingerprint and all derivation steps) for proper support of hardware devices\n+        # See section 'Key origin identification' in 'doc/descriptors.md' for more details...\n+        return pkh_descriptor[\"desc\"].split(\"pkh(\")[1].split(\")\")[0]\n+\n+    @staticmethod\n+    def _check_psbt(psbt, to, value, multisig):\n+        \"\"\"Helper function for any of the N participants to check the psbt with decodepsbt and verify it is OK before signing.\"\"\"\n+        tx = multisig.decodepsbt(psbt)[\"tx\"]\n+        amount = 0\n+        for vout in tx[\"vout\"]:\n+            address = vout[\"scriptPubKey\"][\"address\"]\n+            assert_equal(multisig.getaddressinfo(address)[\"ischange\"], address != to)\n+            if address == to:\n+                amount += vout[\"value\"]\n+        assert_approx(amount, float(value), vspan=0.001)\n+\n+    def participants_create_multisigs(self, external_xpubs, internal_xpubs):\n+        \"\"\"The multisig is created by importing the following descriptors. The resulting wallet is watch-only and every participant can do this.\"\"\"\n+        for i, node in enumerate(self.nodes):\n+            node.createwallet(wallet_name=f\"{self.name}_{i}\", blank=True, descriptors=True, disable_private_keys=True)\n+            multisig = node.get_wallet_rpc(f\"{self.name}_{i}\")\n+            # Spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+            external = multisig.getdescriptorinfo(f\"wsh(thresh({self.N},pk({f'),s:pk('.join(external_xpubs)}),sln:after({f'),sln:after('.join(map(str, self.locktimes))})))\")\n+            internal = multisig.getdescriptorinfo(f\"wsh(thresh({self.N},pk({f'),s:pk('.join(internal_xpubs)}),sln:after({f'),sln:after('.join(map(str, self.locktimes))})))\")\n+            result = multisig.importdescriptors([\n+                {  # receiving addresses (internal: False)\n+                    \"desc\": external[\"descriptor\"],\n+                    \"active\": True,\n+                    \"internal\": False,\n+                    \"timestamp\": \"now\",\n+                },\n+                {  # change addresses (internal: True)\n+                    \"desc\": internal[\"descriptor\"],\n+                    \"active\": True,\n+                    \"internal\": True,\n+                    \"timestamp\": \"now\",\n+                },\n+            ])\n+            assert all(r[\"success\"] for r in result)\n+            yield multisig\n+\n+    def run_test(self):\n+        self.M = self.num_nodes\n+        self.N = self.num_nodes\n+        self.locktimes = [128, 256, 512]  # in real-world align with future halvenings: [840000, 1050000, 1260000]\n+        assert_equal(len(self.locktimes), self.N - 1)\n+\n+        self.name = f\"{self.M}_of_{self.N}_decaying_multisig\"\n+        self.log.info(f\"Testing {self.name}...\")\n+\n+        participants = {\n+            # Every participant generates an xpub. The most straightforward way is to create a new descriptor wallet.\n+            # This wallet will be the participant's `signer` for the resulting multisig. Avoid reusing this wallet for any other purpose (for privacy reasons).\n+            \"signers\": [node.get_wallet_rpc(node.createwallet(wallet_name=f\"participant_{self.nodes.index(node)}\", descriptors=True)[\"name\"]) for node in self.nodes],\n+            # After participants generate and exchange their xpubs they will each create their own watch-only multisig.\n+            # Note: these multisigs are all the same, this just highlights that each participant can independently verify everything on their own node.\n+            \"multisigs\": []\n+        }\n+\n+        self.log.info(\"Generate and exchange xpubs...\")\n+        external_xpubs, internal_xpubs = [[self._get_xpub(signer, internal) for signer in participants[\"signers\"]] for internal in [False, True]]\n+\n+        self.log.info(\"Every participant imports the following descriptors to create the watch-only multisig...\")\n+        participants[\"multisigs\"] = list(self.participants_create_multisigs(external_xpubs, internal_xpubs))\n+\n+        self.log.info(\"Check that every participant's multisig generates the same addresses...\")\n+        for _ in range(10):  # we check that the first 10 generated addresses are the same for all participant's multisigs\n+            receive_addresses = [multisig.getnewaddress() for multisig in participants[\"multisigs\"]]\n+            all(address == receive_addresses[0] for address in receive_addresses)\n+            change_addresses = [multisig.getrawchangeaddress() for multisig in participants[\"multisigs\"]]\n+            all(address == change_addresses[0] for address in change_addresses)\n+\n+        self.log.info(\"Get a mature utxo to send to the multisig...\")\n+        coordinator_wallet = participants[\"signers\"][0]\n+        self.generatetoaddress(self.nodes[0], 101, coordinator_wallet.getnewaddress())\n+\n+        deposit_amount = 6.15\n+        multisig_receiving_address = participants[\"multisigs\"][0].getnewaddress()\n+        self.log.info(\"Send funds to the resulting multisig receiving address...\")\n+        coordinator_wallet.sendtoaddress(multisig_receiving_address, deposit_amount)\n+        self.generate(self.nodes[0], 1)\n+        for participant in participants[\"multisigs\"]:\n+            assert_approx(participant.getbalance(), deposit_amount, vspan=0.001)\n+\n+        self.log.info(\"Send a transaction from the multisig! We can always spend with all signers!\")\n+        to = participants[\"signers\"][self.N - 1].getnewaddress()\n+        value = 1.5\n+        self.log.info(\"First, make a sending transaction, created using `walletcreatefundedpsbt` (anyone can initiate this)...\")\n+        psbt = participants[\"multisigs\"][0].walletcreatefundedpsbt(inputs=[], outputs={to: value}, feeRate=0.00010)\n+\n+        psbts = []\n+        self.log.info(\"Now at least M users check the psbt with decodepsbt and (if OK) signs it with walletprocesspsbt...\")\n+        for m in range(self.M):\n+            signers_multisig = participants[\"multisigs\"][m]\n+            self._check_psbt(psbt[\"psbt\"], to, value, signers_multisig)\n+            signing_wallet = participants[\"signers\"][m]\n+            partially_signed_psbt = signing_wallet.walletprocesspsbt(psbt[\"psbt\"])\n+            psbts.append(partially_signed_psbt[\"psbt\"])\n+\n+        self.log.info(\"Finally, collect the signed PSBTs with combinepsbt, finalizepsbt, then broadcast the resulting transaction...\")\n+        combined = coordinator_wallet.combinepsbt(psbts)\n+        finalized = coordinator_wallet.finalizepsbt(combined)\n+        coordinator_wallet.sendrawtransaction(finalized[\"hex\"])\n+\n+        self.log.info(\"Check that balances are correct after the transaction has been included in a block.\")\n+        self.generate(self.nodes[0], 1)\n+        assert_approx(participants[\"multisigs\"][0].getbalance(), deposit_amount - value, vspan=0.001)\n+        assert_equal(participants[\"signers\"][self.N - 1].getbalance(), value)\n+\n+        self.log.info(\"Send more transactions from the multisig as required signers decay, this time with a daisy chained signing flow (one after another in series)!\")",
      "path": "test/functional/wallet_miniscript_decaying_multisig_descriptor_psbt.py",
      "position": null,
      "original_position": 146,
      "commit_id": "aae032015367be812154a0e87955e6fd5ea5c192",
      "original_commit_id": "2422b90978f4ea13ee49954598dc8aef841e36df",
      "in_reply_to_id": 1563887374,
      "user": {
        "login": "mjdietzx",
        "id": 7217256,
        "node_id": "MDQ6VXNlcjcyMTcyNTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7217256?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mjdietzx",
        "html_url": "https://github.com/mjdietzx",
        "followers_url": "https://api.github.com/users/mjdietzx/followers",
        "following_url": "https://api.github.com/users/mjdietzx/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mjdietzx/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mjdietzx/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mjdietzx/subscriptions",
        "organizations_url": "https://api.github.com/users/mjdietzx/orgs",
        "repos_url": "https://api.github.com/users/mjdietzx/repos",
        "events_url": "https://api.github.com/users/mjdietzx/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mjdietzx/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Yeah there is def some duplicated code between the two tests. But I want to focus on making this simple and easy to understand. It's trying to demonstrate/document an example wallet and could be used as a reference. Kind of like a quick start / tutorial\r\n\r\nIf I were to combine these tests it would become harder for someone to quickly and easily follow, and would lose the purpose of being a quick example. I think it's quite common to have code duplication in these types of tests/examples for that reason and hope this is fine",
      "created_at": "2024-04-14T01:19:11Z",
      "updated_at": "2024-04-14T01:19:11Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29156#discussion_r1564364788",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1564364788"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29156"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 147,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1567831190",
      "pull_request_review_id": 2004420996,
      "id": 1567831190,
      "node_id": "PRRC_kwDOABII585dczSW",
      "diff_hunk": "@@ -63,6 +63,7 @@ Output descriptors currently support:\n - `wsh(sortedmulti(1,xpub661MyMwAqRbcFW31YEwpkMuc5THy2PSt5bDMsktWQcFF8syAmRUapSCGu8ED9W6oDMSgv6Zz8idoc4a6mr8BDzTJY47LJhkJ8UB7WEGuduB/1/0/*,xpub69H7F5d8KSRgmmdJg2KhpAK8SR3DjMwAdkxj3ZuxV27CprR9LgpeyGmXUbC6wb7ERfvrnKZjXoUmmDznezpbZb7ap6r1D3tgFxHmwMkQTPH/0/0/*))` describes a set of *1-of-2* P2WSH multisig outputs where one multisig key is the *1/0/`i`* child of the first specified xpub and the other multisig key is the *0/0/`i`* child of the second specified xpub, and `i` is any number in a configurable range (`0-1000` by default). The order of public keys in the resulting witnessScripts is determined by the lexicographic order of the public keys at that index.\n - `tr(c6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee5,{pk(fff97bd5755eeea420453a14355235d382f6472f8568a18b2f057a1460297556),pk(e493dbf1c10d80f3581e4904930b1404cc6c13900ee0758474fa94abe8c4cd13)})` describes a P2TR output with the `c6...` x-only pubkey as internal key, and two script paths.\n - `tr(c6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee5,sortedmulti_a(2,2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4,5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc))` describes a P2TR output with the `c6...` x-only pubkey as internal key, and a single `multi_a` script that needs 2 signatures with 2 specified x-only keys, which will be sorted lexicographically.\n+- `wsh(thresh(4,pk([7258e4f9/44h/1h/0h]tpubDCZrkQoEU3845aFKUu9VQBYWZtrTwxMzcxnBwKFCYXHD6gEXvtFcxddCCLFsEwmxQaG15izcHxj48SXg1QS5FQGMBx5Ak6deXKPAL7wauBU/0/*),s:pk([c80b1469/44h/1h/0h]tpubDD3UwwHoNUF4F3Vi5PiUVTc3ji1uThuRfFyBexTSHoAcHuWW2z8qEE2YujegcLtgthr3wMp3ZauvNG9eT9xfJyxXCfNty8h6rDBYU8UU1qq/0/*),s:pk([4e5024fe/44h/1h/0h]tpubDDLrpPymPLSCJyCMLQdmcWxrAWwsqqssm5NdxT2WSdEBPSXNXxwbeKtsHAyXPpLkhUyKovtZgCi47QxVpw9iVkg95UUgeevyAqtJ9dqBqa1/0/*),s:pk([3b1d1ee9/44h/1h/0h]tpubDCmDTANBWPzf6d8Ap1J5Ku7J1Ay92MpHMrEV7M5muWxCrTBN1g5f1NPcjMEL6dJHxbvEKNZtYCdowaSTN81DAyLsmv6w6xjJHCQNkxrsrfu/0/*),sln:after(840000),sln:after(1050000),sln:after(1260000)))#k28080kv` describes a Miniscript multisig with spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))` that starts as 4-of-4 and \"decays\" to 3-of-4, 2-of-4, and finally 1-of-4 at each future halvening block height. This descriptor was generated by a test run of [test/functional/wallet_miniscript_decaying_multisig_descriptor_psbt.py](/test/functional/wallet_miniscript_decaying_multisig_descriptor_psbt.py). For brevity, the internal \"change\" descriptor accompanying the above external \"receiving\" descriptor is not included here, but it typically differs only in the xpub derivation steps, ending in `/1/*` for change addresses.",
      "path": "doc/descriptors.md",
      "position": null,
      "original_position": 4,
      "commit_id": "aae032015367be812154a0e87955e6fd5ea5c192",
      "original_commit_id": "de93b863583921929bc16feb7a0bf5decfbc7ac5",
      "in_reply_to_id": null,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In de93b863583921929bc16feb7a0bf5decfbc7ac5 \"tests: add functional test for miniscript decaying multisig\"\r\n\r\nIt's not necessary to state where the descriptor comes from.",
      "created_at": "2024-04-16T19:11:17Z",
      "updated_at": "2024-04-16T19:28:33Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29156#discussion_r1567831190",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1567831190"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29156"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 66,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1567833329",
      "pull_request_review_id": 2004420996,
      "id": 1567833329,
      "node_id": "PRRC_kwDOABII585dczzx",
      "diff_hunk": "@@ -0,0 +1,176 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test a miniscript multisig that starts as 4-of-4 and \"decays\" to 3-of-4, 2-of-4, and finally 1-of-4 at each future halvening block height.\n+\n+Spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+This is based off of `test/functional/wallet_multisig_descriptor_psbt.py` and most code is the same.\n+\"\"\"\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_approx,\n+    assert_equal,\n+    assert_raises_rpc_error,\n+)\n+\n+\n+class WalletMiniscriptDecayingMultisigDescriptorPSBTTest(BitcoinTestFramework):\n+    def add_options(self, parser):\n+        self.add_wallet_options(parser, legacy=False)\n+\n+    def set_test_params(self):\n+        self.num_nodes = 4",
      "path": "test/functional/wallet_miniscript_decaying_multisig_descriptor_psbt.py",
      "position": null,
      "original_position": 24,
      "commit_id": "aae032015367be812154a0e87955e6fd5ea5c192",
      "original_commit_id": "de93b863583921929bc16feb7a0bf5decfbc7ac5",
      "in_reply_to_id": null,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In de93b863583921929bc16feb7a0bf5decfbc7ac5 \"tests: add functional test for miniscript decaying multisig\"\r\n\r\nUsing multiple wallets is preferred over using multiple nodes.",
      "created_at": "2024-04-16T19:12:44Z",
      "updated_at": "2024-04-16T19:28:33Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29156#discussion_r1567833329",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1567833329"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29156"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 24,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1567838489",
      "pull_request_review_id": 2004420996,
      "id": 1567838489,
      "node_id": "PRRC_kwDOABII585dc1EZ",
      "diff_hunk": "@@ -0,0 +1,176 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test a miniscript multisig that starts as 4-of-4 and \"decays\" to 3-of-4, 2-of-4, and finally 1-of-4 at each future halvening block height.\n+\n+Spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+This is based off of `test/functional/wallet_multisig_descriptor_psbt.py` and most code is the same.\n+\"\"\"\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_approx,\n+    assert_equal,\n+    assert_raises_rpc_error,\n+)\n+\n+\n+class WalletMiniscriptDecayingMultisigDescriptorPSBTTest(BitcoinTestFramework):\n+    def add_options(self, parser):\n+        self.add_wallet_options(parser, legacy=False)\n+\n+    def set_test_params(self):\n+        self.num_nodes = 4\n+        self.setup_clean_chain = True\n+        self.wallet_names = []\n+        self.extra_args = [[\"-keypool=100\"]] * self.num_nodes\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+        self.skip_if_no_sqlite()\n+\n+    @staticmethod\n+    def _get_xpub(wallet, internal):\n+        \"\"\"Extract the wallet's xpubs using `listdescriptors` and pick the one from the `pkh` descriptor since it's least likely to be accidentally reused (legacy addresses).\"\"\"\n+        pkh_descriptor = next(filter(lambda d: d[\"desc\"].startswith(\"pkh(\") and d[\"internal\"] == internal, wallet.listdescriptors()[\"descriptors\"]))\n+        # Keep all key origin information (master key fingerprint and all derivation steps) for proper support of hardware devices\n+        # See section 'Key origin identification' in 'doc/descriptors.md' for more details...\n+        return pkh_descriptor[\"desc\"].split(\"pkh(\")[1].split(\")\")[0]\n+\n+    @staticmethod\n+    def _check_psbt(psbt, to, value, multisig):\n+        \"\"\"Helper function for any of the N participants to check the psbt with decodepsbt and verify it is OK before signing.\"\"\"\n+        tx = multisig.decodepsbt(psbt)[\"tx\"]\n+        amount = 0\n+        for vout in tx[\"vout\"]:\n+            address = vout[\"scriptPubKey\"][\"address\"]\n+            assert_equal(multisig.getaddressinfo(address)[\"ischange\"], address != to)\n+            if address == to:\n+                amount += vout[\"value\"]\n+        assert_approx(amount, float(value), vspan=0.001)\n+\n+    def participants_create_multisigs(self, external_xpubs, internal_xpubs):\n+        \"\"\"The multisig is created by importing the following descriptors. The resulting wallet is watch-only and every participant can do this.\"\"\"\n+        for i, node in enumerate(self.nodes):\n+            node.createwallet(wallet_name=f\"{self.name}_{i}\", blank=True, descriptors=True, disable_private_keys=True)\n+            multisig = node.get_wallet_rpc(f\"{self.name}_{i}\")\n+            # Spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+            external = multisig.getdescriptorinfo(f\"wsh(thresh({self.N},pk({f'),s:pk('.join(external_xpubs)}),sln:after({f'),sln:after('.join(map(str, self.locktimes))})))\")\n+            internal = multisig.getdescriptorinfo(f\"wsh(thresh({self.N},pk({f'),s:pk('.join(internal_xpubs)}),sln:after({f'),sln:after('.join(map(str, self.locktimes))})))\")\n+            result = multisig.importdescriptors([\n+                {  # receiving addresses (internal: False)\n+                    \"desc\": external[\"descriptor\"],\n+                    \"active\": True,\n+                    \"internal\": False,\n+                    \"timestamp\": \"now\",\n+                },\n+                {  # change addresses (internal: True)\n+                    \"desc\": internal[\"descriptor\"],\n+                    \"active\": True,\n+                    \"internal\": True,\n+                    \"timestamp\": \"now\",\n+                },\n+            ])\n+            assert all(r[\"success\"] for r in result)\n+            yield multisig",
      "path": "test/functional/wallet_miniscript_decaying_multisig_descriptor_psbt.py",
      "position": null,
      "original_position": 76,
      "commit_id": "aae032015367be812154a0e87955e6fd5ea5c192",
      "original_commit_id": "de93b863583921929bc16feb7a0bf5decfbc7ac5",
      "in_reply_to_id": null,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In de93b863583921929bc16feb7a0bf5decfbc7ac5 \"tests: add functional test for miniscript decaying multisig\"\r\n\r\nA lot of this is very similar to/the same as `wallet_multisig_descriptor_psbt.py`. I would prefer if they were combined into one test file. Note that you can (and should) make separate functions for the different test cases so that there is a distinct separation between them, while still using the same utility functions.",
      "created_at": "2024-04-16T19:17:22Z",
      "updated_at": "2024-04-16T19:28:33Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29156#discussion_r1567838489",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1567838489"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29156"
        }
      },
      "start_line": null,
      "original_start_line": 33,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 76,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1567842740",
      "pull_request_review_id": 2004420996,
      "id": 1567842740,
      "node_id": "PRRC_kwDOABII585dc2G0",
      "diff_hunk": "@@ -0,0 +1,176 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test a miniscript multisig that starts as 4-of-4 and \"decays\" to 3-of-4, 2-of-4, and finally 1-of-4 at each future halvening block height.\n+\n+Spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+This is based off of `test/functional/wallet_multisig_descriptor_psbt.py` and most code is the same.\n+\"\"\"\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_approx,\n+    assert_equal,\n+    assert_raises_rpc_error,\n+)\n+\n+\n+class WalletMiniscriptDecayingMultisigDescriptorPSBTTest(BitcoinTestFramework):\n+    def add_options(self, parser):\n+        self.add_wallet_options(parser, legacy=False)\n+\n+    def set_test_params(self):\n+        self.num_nodes = 4\n+        self.setup_clean_chain = True\n+        self.wallet_names = []\n+        self.extra_args = [[\"-keypool=100\"]] * self.num_nodes\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+        self.skip_if_no_sqlite()\n+\n+    @staticmethod\n+    def _get_xpub(wallet, internal):\n+        \"\"\"Extract the wallet's xpubs using `listdescriptors` and pick the one from the `pkh` descriptor since it's least likely to be accidentally reused (legacy addresses).\"\"\"\n+        pkh_descriptor = next(filter(lambda d: d[\"desc\"].startswith(\"pkh(\") and d[\"internal\"] == internal, wallet.listdescriptors()[\"descriptors\"]))\n+        # Keep all key origin information (master key fingerprint and all derivation steps) for proper support of hardware devices\n+        # See section 'Key origin identification' in 'doc/descriptors.md' for more details...\n+        return pkh_descriptor[\"desc\"].split(\"pkh(\")[1].split(\")\")[0]\n+\n+    @staticmethod\n+    def _check_psbt(psbt, to, value, multisig):\n+        \"\"\"Helper function for any of the N participants to check the psbt with decodepsbt and verify it is OK before signing.\"\"\"\n+        tx = multisig.decodepsbt(psbt)[\"tx\"]\n+        amount = 0\n+        for vout in tx[\"vout\"]:\n+            address = vout[\"scriptPubKey\"][\"address\"]\n+            assert_equal(multisig.getaddressinfo(address)[\"ischange\"], address != to)\n+            if address == to:\n+                amount += vout[\"value\"]\n+        assert_approx(amount, float(value), vspan=0.001)\n+\n+    def participants_create_multisigs(self, external_xpubs, internal_xpubs):\n+        \"\"\"The multisig is created by importing the following descriptors. The resulting wallet is watch-only and every participant can do this.\"\"\"\n+        for i, node in enumerate(self.nodes):\n+            node.createwallet(wallet_name=f\"{self.name}_{i}\", blank=True, descriptors=True, disable_private_keys=True)\n+            multisig = node.get_wallet_rpc(f\"{self.name}_{i}\")\n+            # Spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+            external = multisig.getdescriptorinfo(f\"wsh(thresh({self.N},pk({f'),s:pk('.join(external_xpubs)}),sln:after({f'),sln:after('.join(map(str, self.locktimes))})))\")\n+            internal = multisig.getdescriptorinfo(f\"wsh(thresh({self.N},pk({f'),s:pk('.join(internal_xpubs)}),sln:after({f'),sln:after('.join(map(str, self.locktimes))})))\")\n+            result = multisig.importdescriptors([\n+                {  # receiving addresses (internal: False)\n+                    \"desc\": external[\"descriptor\"],\n+                    \"active\": True,\n+                    \"internal\": False,\n+                    \"timestamp\": \"now\",\n+                },\n+                {  # change addresses (internal: True)\n+                    \"desc\": internal[\"descriptor\"],\n+                    \"active\": True,\n+                    \"internal\": True,\n+                    \"timestamp\": \"now\",\n+                },\n+            ])\n+            assert all(r[\"success\"] for r in result)\n+            yield multisig\n+\n+    def run_test(self):\n+        self.M = self.num_nodes\n+        self.N = self.num_nodes\n+        self.locktimes = [128, 256, 512]  # in real-world align with future halvenings: [840000, 1050000, 1260000]\n+        assert_equal(len(self.locktimes), self.N - 1)\n+\n+        self.name = f\"{self.M}_of_{self.N}_decaying_multisig\"\n+        self.log.info(f\"Testing {self.name}...\")\n+\n+        participants = {\n+            # Every participant generates an xpub. The most straightforward way is to create a new descriptor wallet.\n+            # This wallet will be the participant's `signer` for the resulting multisig. Avoid reusing this wallet for any other purpose (for privacy reasons).\n+            \"signers\": [node.get_wallet_rpc(node.createwallet(wallet_name=f\"participant_{self.nodes.index(node)}\", descriptors=True)[\"name\"]) for node in self.nodes],\n+            # After participants generate and exchange their xpubs they will each create their own watch-only multisig.\n+            # Note: these multisigs are all the same, this just highlights that each participant can independently verify everything on their own node.\n+            \"multisigs\": []\n+        }\n+\n+        self.log.info(\"Generate and exchange xpubs...\")\n+        external_xpubs, internal_xpubs = [[self._get_xpub(signer, internal) for signer in participants[\"signers\"]] for internal in [False, True]]\n+\n+        self.log.info(\"Every participant imports the following descriptors to create the watch-only multisig...\")\n+        participants[\"multisigs\"] = list(self.participants_create_multisigs(external_xpubs, internal_xpubs))\n+\n+        self.log.info(\"Check that every participant's multisig generates the same addresses...\")\n+        for _ in range(10):  # we check that the first 10 generated addresses are the same for all participant's multisigs\n+            receive_addresses = [multisig.getnewaddress() for multisig in participants[\"multisigs\"]]\n+            all(address == receive_addresses[0] for address in receive_addresses)\n+            change_addresses = [multisig.getrawchangeaddress() for multisig in participants[\"multisigs\"]]\n+            all(address == change_addresses[0] for address in change_addresses)\n+\n+        self.log.info(\"Get a mature utxo to send to the multisig...\")\n+        coordinator_wallet = participants[\"signers\"][0]\n+        self.generatetoaddress(self.nodes[0], 101, coordinator_wallet.getnewaddress())\n+\n+        deposit_amount = 6.15\n+        multisig_receiving_address = participants[\"multisigs\"][0].getnewaddress()\n+        self.log.info(\"Send funds to the resulting multisig receiving address...\")\n+        coordinator_wallet.sendtoaddress(multisig_receiving_address, deposit_amount)\n+        self.generate(self.nodes[0], 1)\n+        for participant in participants[\"multisigs\"]:\n+            assert_approx(participant.getbalance(), deposit_amount, vspan=0.001)\n+\n+        self.log.info(\"Send a transaction from the multisig! We can always spend with all signers!\")\n+        to = participants[\"signers\"][self.N - 1].getnewaddress()\n+        value = 1.5\n+        self.log.info(\"First, make a sending transaction, created using `walletcreatefundedpsbt` (anyone can initiate this)...\")\n+        psbt = participants[\"multisigs\"][0].walletcreatefundedpsbt(inputs=[], outputs={to: value}, feeRate=0.00010)\n+\n+        psbts = []\n+        self.log.info(\"Now at least M users check the psbt with decodepsbt and (if OK) signs it with walletprocesspsbt...\")\n+        for m in range(self.M):\n+            signers_multisig = participants[\"multisigs\"][m]\n+            self._check_psbt(psbt[\"psbt\"], to, value, signers_multisig)\n+            signing_wallet = participants[\"signers\"][m]\n+            partially_signed_psbt = signing_wallet.walletprocesspsbt(psbt[\"psbt\"])\n+            psbts.append(partially_signed_psbt[\"psbt\"])\n+\n+        self.log.info(\"Finally, collect the signed PSBTs with combinepsbt, finalizepsbt, then broadcast the resulting transaction...\")\n+        combined = coordinator_wallet.combinepsbt(psbts)\n+        finalized = coordinator_wallet.finalizepsbt(combined)\n+        coordinator_wallet.sendrawtransaction(finalized[\"hex\"])\n+\n+        self.log.info(\"Check that balances are correct after the transaction has been included in a block.\")\n+        self.generate(self.nodes[0], 1)\n+        assert_approx(participants[\"multisigs\"][0].getbalance(), deposit_amount - value, vspan=0.001)\n+        assert_equal(participants[\"signers\"][self.N - 1].getbalance(), value)",
      "path": "test/functional/wallet_miniscript_decaying_multisig_descriptor_psbt.py",
      "position": null,
      "original_position": 144,
      "commit_id": "aae032015367be812154a0e87955e6fd5ea5c192",
      "original_commit_id": "de93b863583921929bc16feb7a0bf5decfbc7ac5",
      "in_reply_to_id": null,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In de93b863583921929bc16feb7a0bf5decfbc7ac5 \"tests: add functional test for miniscript decaying multisig\"\r\n\r\nThis workflow is very similar to what will happen in the loop below. Can they be consolidated?",
      "created_at": "2024-04-16T19:22:00Z",
      "updated_at": "2024-04-16T19:28:33Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29156#discussion_r1567842740",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1567842740"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29156"
        }
      },
      "start_line": null,
      "original_start_line": 129,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 144,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1567843544",
      "pull_request_review_id": 2004420996,
      "id": 1567843544,
      "node_id": "PRRC_kwDOABII585dc2TY",
      "diff_hunk": "@@ -0,0 +1,176 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test a miniscript multisig that starts as 4-of-4 and \"decays\" to 3-of-4, 2-of-4, and finally 1-of-4 at each future halvening block height.\n+\n+Spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+This is based off of `test/functional/wallet_multisig_descriptor_psbt.py` and most code is the same.\n+\"\"\"\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_approx,\n+    assert_equal,\n+    assert_raises_rpc_error,\n+)\n+\n+\n+class WalletMiniscriptDecayingMultisigDescriptorPSBTTest(BitcoinTestFramework):\n+    def add_options(self, parser):\n+        self.add_wallet_options(parser, legacy=False)\n+\n+    def set_test_params(self):\n+        self.num_nodes = 4\n+        self.setup_clean_chain = True\n+        self.wallet_names = []\n+        self.extra_args = [[\"-keypool=100\"]] * self.num_nodes\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+        self.skip_if_no_sqlite()\n+\n+    @staticmethod\n+    def _get_xpub(wallet, internal):\n+        \"\"\"Extract the wallet's xpubs using `listdescriptors` and pick the one from the `pkh` descriptor since it's least likely to be accidentally reused (legacy addresses).\"\"\"\n+        pkh_descriptor = next(filter(lambda d: d[\"desc\"].startswith(\"pkh(\") and d[\"internal\"] == internal, wallet.listdescriptors()[\"descriptors\"]))\n+        # Keep all key origin information (master key fingerprint and all derivation steps) for proper support of hardware devices\n+        # See section 'Key origin identification' in 'doc/descriptors.md' for more details...\n+        return pkh_descriptor[\"desc\"].split(\"pkh(\")[1].split(\")\")[0]\n+\n+    @staticmethod\n+    def _check_psbt(psbt, to, value, multisig):\n+        \"\"\"Helper function for any of the N participants to check the psbt with decodepsbt and verify it is OK before signing.\"\"\"\n+        tx = multisig.decodepsbt(psbt)[\"tx\"]\n+        amount = 0\n+        for vout in tx[\"vout\"]:\n+            address = vout[\"scriptPubKey\"][\"address\"]\n+            assert_equal(multisig.getaddressinfo(address)[\"ischange\"], address != to)\n+            if address == to:\n+                amount += vout[\"value\"]\n+        assert_approx(amount, float(value), vspan=0.001)\n+\n+    def participants_create_multisigs(self, external_xpubs, internal_xpubs):\n+        \"\"\"The multisig is created by importing the following descriptors. The resulting wallet is watch-only and every participant can do this.\"\"\"\n+        for i, node in enumerate(self.nodes):\n+            node.createwallet(wallet_name=f\"{self.name}_{i}\", blank=True, descriptors=True, disable_private_keys=True)\n+            multisig = node.get_wallet_rpc(f\"{self.name}_{i}\")\n+            # Spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+            external = multisig.getdescriptorinfo(f\"wsh(thresh({self.N},pk({f'),s:pk('.join(external_xpubs)}),sln:after({f'),sln:after('.join(map(str, self.locktimes))})))\")\n+            internal = multisig.getdescriptorinfo(f\"wsh(thresh({self.N},pk({f'),s:pk('.join(internal_xpubs)}),sln:after({f'),sln:after('.join(map(str, self.locktimes))})))\")\n+            result = multisig.importdescriptors([\n+                {  # receiving addresses (internal: False)\n+                    \"desc\": external[\"descriptor\"],\n+                    \"active\": True,\n+                    \"internal\": False,\n+                    \"timestamp\": \"now\",\n+                },\n+                {  # change addresses (internal: True)\n+                    \"desc\": internal[\"descriptor\"],\n+                    \"active\": True,\n+                    \"internal\": True,\n+                    \"timestamp\": \"now\",\n+                },\n+            ])\n+            assert all(r[\"success\"] for r in result)\n+            yield multisig\n+\n+    def run_test(self):\n+        self.M = self.num_nodes\n+        self.N = self.num_nodes\n+        self.locktimes = [128, 256, 512]  # in real-world align with future halvenings: [840000, 1050000, 1260000]",
      "path": "test/functional/wallet_miniscript_decaying_multisig_descriptor_psbt.py",
      "position": null,
      "original_position": 81,
      "commit_id": "aae032015367be812154a0e87955e6fd5ea5c192",
      "original_commit_id": "de93b863583921929bc16feb7a0bf5decfbc7ac5",
      "in_reply_to_id": null,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In de93b863583921929bc16feb7a0bf5decfbc7ac5 \"tests: add functional test for miniscript decaying multisig\"\r\n\r\nMining hundreds of blocks can take a while and is unnecessary for this test. This could run quite a bit faster with locktimes that are closer to each other.",
      "created_at": "2024-04-16T19:22:51Z",
      "updated_at": "2024-04-16T19:28:33Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29156#discussion_r1567843544",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1567843544"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29156"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 81,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1567846617",
      "pull_request_review_id": 2004420996,
      "id": 1567846617,
      "node_id": "PRRC_kwDOABII585dc3DZ",
      "diff_hunk": "@@ -0,0 +1,176 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test a miniscript multisig that starts as 4-of-4 and \"decays\" to 3-of-4, 2-of-4, and finally 1-of-4 at each future halvening block height.\n+\n+Spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+This is based off of `test/functional/wallet_multisig_descriptor_psbt.py` and most code is the same.\n+\"\"\"\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_approx,\n+    assert_equal,\n+    assert_raises_rpc_error,\n+)\n+\n+\n+class WalletMiniscriptDecayingMultisigDescriptorPSBTTest(BitcoinTestFramework):\n+    def add_options(self, parser):\n+        self.add_wallet_options(parser, legacy=False)\n+\n+    def set_test_params(self):\n+        self.num_nodes = 4\n+        self.setup_clean_chain = True\n+        self.wallet_names = []\n+        self.extra_args = [[\"-keypool=100\"]] * self.num_nodes\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+        self.skip_if_no_sqlite()\n+\n+    @staticmethod\n+    def _get_xpub(wallet, internal):\n+        \"\"\"Extract the wallet's xpubs using `listdescriptors` and pick the one from the `pkh` descriptor since it's least likely to be accidentally reused (legacy addresses).\"\"\"\n+        pkh_descriptor = next(filter(lambda d: d[\"desc\"].startswith(\"pkh(\") and d[\"internal\"] == internal, wallet.listdescriptors()[\"descriptors\"]))\n+        # Keep all key origin information (master key fingerprint and all derivation steps) for proper support of hardware devices\n+        # See section 'Key origin identification' in 'doc/descriptors.md' for more details...\n+        return pkh_descriptor[\"desc\"].split(\"pkh(\")[1].split(\")\")[0]\n+\n+    @staticmethod\n+    def _check_psbt(psbt, to, value, multisig):\n+        \"\"\"Helper function for any of the N participants to check the psbt with decodepsbt and verify it is OK before signing.\"\"\"\n+        tx = multisig.decodepsbt(psbt)[\"tx\"]\n+        amount = 0\n+        for vout in tx[\"vout\"]:\n+            address = vout[\"scriptPubKey\"][\"address\"]\n+            assert_equal(multisig.getaddressinfo(address)[\"ischange\"], address != to)\n+            if address == to:\n+                amount += vout[\"value\"]\n+        assert_approx(amount, float(value), vspan=0.001)\n+\n+    def participants_create_multisigs(self, external_xpubs, internal_xpubs):\n+        \"\"\"The multisig is created by importing the following descriptors. The resulting wallet is watch-only and every participant can do this.\"\"\"\n+        for i, node in enumerate(self.nodes):\n+            node.createwallet(wallet_name=f\"{self.name}_{i}\", blank=True, descriptors=True, disable_private_keys=True)\n+            multisig = node.get_wallet_rpc(f\"{self.name}_{i}\")\n+            # Spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+            external = multisig.getdescriptorinfo(f\"wsh(thresh({self.N},pk({f'),s:pk('.join(external_xpubs)}),sln:after({f'),sln:after('.join(map(str, self.locktimes))})))\")\n+            internal = multisig.getdescriptorinfo(f\"wsh(thresh({self.N},pk({f'),s:pk('.join(internal_xpubs)}),sln:after({f'),sln:after('.join(map(str, self.locktimes))})))\")\n+            result = multisig.importdescriptors([\n+                {  # receiving addresses (internal: False)\n+                    \"desc\": external[\"descriptor\"],\n+                    \"active\": True,\n+                    \"internal\": False,\n+                    \"timestamp\": \"now\",\n+                },\n+                {  # change addresses (internal: True)\n+                    \"desc\": internal[\"descriptor\"],\n+                    \"active\": True,\n+                    \"internal\": True,\n+                    \"timestamp\": \"now\",\n+                },\n+            ])\n+            assert all(r[\"success\"] for r in result)\n+            yield multisig\n+\n+    def run_test(self):\n+        self.M = self.num_nodes\n+        self.N = self.num_nodes\n+        self.locktimes = [128, 256, 512]  # in real-world align with future halvenings: [840000, 1050000, 1260000]\n+        assert_equal(len(self.locktimes), self.N - 1)\n+\n+        self.name = f\"{self.M}_of_{self.N}_decaying_multisig\"\n+        self.log.info(f\"Testing {self.name}...\")\n+\n+        participants = {\n+            # Every participant generates an xpub. The most straightforward way is to create a new descriptor wallet.\n+            # This wallet will be the participant's `signer` for the resulting multisig. Avoid reusing this wallet for any other purpose (for privacy reasons).\n+            \"signers\": [node.get_wallet_rpc(node.createwallet(wallet_name=f\"participant_{self.nodes.index(node)}\", descriptors=True)[\"name\"]) for node in self.nodes],\n+            # After participants generate and exchange their xpubs they will each create their own watch-only multisig.\n+            # Note: these multisigs are all the same, this just highlights that each participant can independently verify everything on their own node.\n+            \"multisigs\": []\n+        }\n+\n+        self.log.info(\"Generate and exchange xpubs...\")\n+        external_xpubs, internal_xpubs = [[self._get_xpub(signer, internal) for signer in participants[\"signers\"]] for internal in [False, True]]\n+\n+        self.log.info(\"Every participant imports the following descriptors to create the watch-only multisig...\")\n+        participants[\"multisigs\"] = list(self.participants_create_multisigs(external_xpubs, internal_xpubs))\n+\n+        self.log.info(\"Check that every participant's multisig generates the same addresses...\")\n+        for _ in range(10):  # we check that the first 10 generated addresses are the same for all participant's multisigs\n+            receive_addresses = [multisig.getnewaddress() for multisig in participants[\"multisigs\"]]\n+            all(address == receive_addresses[0] for address in receive_addresses)\n+            change_addresses = [multisig.getrawchangeaddress() for multisig in participants[\"multisigs\"]]\n+            all(address == change_addresses[0] for address in change_addresses)\n+\n+        self.log.info(\"Get a mature utxo to send to the multisig...\")\n+        coordinator_wallet = participants[\"signers\"][0]\n+        self.generatetoaddress(self.nodes[0], 101, coordinator_wallet.getnewaddress())\n+\n+        deposit_amount = 6.15\n+        multisig_receiving_address = participants[\"multisigs\"][0].getnewaddress()\n+        self.log.info(\"Send funds to the resulting multisig receiving address...\")\n+        coordinator_wallet.sendtoaddress(multisig_receiving_address, deposit_amount)\n+        self.generate(self.nodes[0], 1)\n+        for participant in participants[\"multisigs\"]:\n+            assert_approx(participant.getbalance(), deposit_amount, vspan=0.001)\n+\n+        self.log.info(\"Send a transaction from the multisig! We can always spend with all signers!\")\n+        to = participants[\"signers\"][self.N - 1].getnewaddress()\n+        value = 1.5\n+        self.log.info(\"First, make a sending transaction, created using `walletcreatefundedpsbt` (anyone can initiate this)...\")\n+        psbt = participants[\"multisigs\"][0].walletcreatefundedpsbt(inputs=[], outputs={to: value}, feeRate=0.00010)\n+\n+        psbts = []\n+        self.log.info(\"Now at least M users check the psbt with decodepsbt and (if OK) signs it with walletprocesspsbt...\")\n+        for m in range(self.M):\n+            signers_multisig = participants[\"multisigs\"][m]\n+            self._check_psbt(psbt[\"psbt\"], to, value, signers_multisig)\n+            signing_wallet = participants[\"signers\"][m]\n+            partially_signed_psbt = signing_wallet.walletprocesspsbt(psbt[\"psbt\"])\n+            psbts.append(partially_signed_psbt[\"psbt\"])\n+\n+        self.log.info(\"Finally, collect the signed PSBTs with combinepsbt, finalizepsbt, then broadcast the resulting transaction...\")\n+        combined = coordinator_wallet.combinepsbt(psbts)\n+        finalized = coordinator_wallet.finalizepsbt(combined)\n+        coordinator_wallet.sendrawtransaction(finalized[\"hex\"])\n+\n+        self.log.info(\"Check that balances are correct after the transaction has been included in a block.\")\n+        self.generate(self.nodes[0], 1)\n+        assert_approx(participants[\"multisigs\"][0].getbalance(), deposit_amount - value, vspan=0.001)\n+        assert_equal(participants[\"signers\"][self.N - 1].getbalance(), value)\n+\n+        self.log.info(\"Send more transactions from the multisig as required signers decay, this time with a daisy chained signing flow (one after another in series)!\")\n+        sent = value\n+        for locktime in self.locktimes:\n+            self.M -= 1\n+            self.log.info(f\"At block height >= {locktime} this multisig is {self.M}-of-{self.N}\")\n+            current_height = self.nodes[0].getblock(self.nodes[0].getbestblockhash())['height']\n+\n+            psbt = participants[\"multisigs\"][0].walletcreatefundedpsbt(inputs=[], outputs={to: value}, feeRate=0.00010, locktime=locktime)\n+            for m in range(self.M):\n+                signers_multisig = participants[\"multisigs\"][m]\n+                self._check_psbt(psbt[\"psbt\"], to, value, signers_multisig)\n+                signing_wallet = participants[\"signers\"][m]\n+                psbt = signing_wallet.walletprocesspsbt(psbt[\"psbt\"])\n+                assert_equal(psbt[\"complete\"], m == self.M - 1)\n+            self.log.info(\"Check that the time-locked transaction is too immature to spend...\")\n+            assert_equal(current_height >= locktime, False)\n+            assert_raises_rpc_error(-26, \"non-final\", coordinator_wallet.sendrawtransaction, psbt[\"hex\"])\n+\n+            self.generate(self.nodes[0], locktime)",
      "path": "test/functional/wallet_miniscript_decaying_multisig_descriptor_psbt.py",
      "position": null,
      "original_position": 164,
      "commit_id": "aae032015367be812154a0e87955e6fd5ea5c192",
      "original_commit_id": "de93b863583921929bc16feb7a0bf5decfbc7ac5",
      "in_reply_to_id": null,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In de93b863583921929bc16feb7a0bf5decfbc7ac5 \"tests: add functional test for miniscript decaying multisig\"\r\n\r\nThis massively overshoots the locktime block each time. I think it would be better to mine just enough blocks to reach the locktime height.",
      "created_at": "2024-04-16T19:25:59Z",
      "updated_at": "2024-04-16T19:28:33Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29156#discussion_r1567846617",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1567846617"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29156"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 164,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1582257401",
      "pull_request_review_id": 2027204045,
      "id": 1582257401,
      "node_id": "PRRC_kwDOABII585eT1T5",
      "diff_hunk": "@@ -0,0 +1,176 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test a miniscript multisig that starts as 4-of-4 and \"decays\" to 3-of-4, 2-of-4, and finally 1-of-4 at each future halvening block height.\n+\n+Spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+This is based off of `test/functional/wallet_multisig_descriptor_psbt.py` and most code is the same.\n+\"\"\"\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_approx,\n+    assert_equal,\n+    assert_raises_rpc_error,\n+)\n+\n+\n+class WalletMiniscriptDecayingMultisigDescriptorPSBTTest(BitcoinTestFramework):\n+    def add_options(self, parser):\n+        self.add_wallet_options(parser, legacy=False)\n+\n+    def set_test_params(self):\n+        self.num_nodes = 4\n+        self.setup_clean_chain = True\n+        self.wallet_names = []\n+        self.extra_args = [[\"-keypool=100\"]] * self.num_nodes\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+        self.skip_if_no_sqlite()\n+\n+    @staticmethod\n+    def _get_xpub(wallet, internal):\n+        \"\"\"Extract the wallet's xpubs using `listdescriptors` and pick the one from the `pkh` descriptor since it's least likely to be accidentally reused (legacy addresses).\"\"\"\n+        pkh_descriptor = next(filter(lambda d: d[\"desc\"].startswith(\"pkh(\") and d[\"internal\"] == internal, wallet.listdescriptors()[\"descriptors\"]))\n+        # Keep all key origin information (master key fingerprint and all derivation steps) for proper support of hardware devices\n+        # See section 'Key origin identification' in 'doc/descriptors.md' for more details...\n+        return pkh_descriptor[\"desc\"].split(\"pkh(\")[1].split(\")\")[0]\n+\n+    @staticmethod\n+    def _check_psbt(psbt, to, value, multisig):\n+        \"\"\"Helper function for any of the N participants to check the psbt with decodepsbt and verify it is OK before signing.\"\"\"\n+        tx = multisig.decodepsbt(psbt)[\"tx\"]\n+        amount = 0\n+        for vout in tx[\"vout\"]:\n+            address = vout[\"scriptPubKey\"][\"address\"]\n+            assert_equal(multisig.getaddressinfo(address)[\"ischange\"], address != to)\n+            if address == to:\n+                amount += vout[\"value\"]\n+        assert_approx(amount, float(value), vspan=0.001)\n+\n+    def participants_create_multisigs(self, external_xpubs, internal_xpubs):\n+        \"\"\"The multisig is created by importing the following descriptors. The resulting wallet is watch-only and every participant can do this.\"\"\"\n+        for i, node in enumerate(self.nodes):\n+            node.createwallet(wallet_name=f\"{self.name}_{i}\", blank=True, descriptors=True, disable_private_keys=True)\n+            multisig = node.get_wallet_rpc(f\"{self.name}_{i}\")\n+            # Spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+            external = multisig.getdescriptorinfo(f\"wsh(thresh({self.N},pk({f'),s:pk('.join(external_xpubs)}),sln:after({f'),sln:after('.join(map(str, self.locktimes))})))\")\n+            internal = multisig.getdescriptorinfo(f\"wsh(thresh({self.N},pk({f'),s:pk('.join(internal_xpubs)}),sln:after({f'),sln:after('.join(map(str, self.locktimes))})))\")\n+            result = multisig.importdescriptors([\n+                {  # receiving addresses (internal: False)\n+                    \"desc\": external[\"descriptor\"],\n+                    \"active\": True,\n+                    \"internal\": False,\n+                    \"timestamp\": \"now\",\n+                },\n+                {  # change addresses (internal: True)\n+                    \"desc\": internal[\"descriptor\"],\n+                    \"active\": True,\n+                    \"internal\": True,\n+                    \"timestamp\": \"now\",\n+                },\n+            ])\n+            assert all(r[\"success\"] for r in result)\n+            yield multisig\n+\n+    def run_test(self):\n+        self.M = self.num_nodes\n+        self.N = self.num_nodes\n+        self.locktimes = [128, 256, 512]  # in real-world align with future halvenings: [840000, 1050000, 1260000]\n+        assert_equal(len(self.locktimes), self.N - 1)\n+\n+        self.name = f\"{self.M}_of_{self.N}_decaying_multisig\"\n+        self.log.info(f\"Testing {self.name}...\")\n+\n+        participants = {\n+            # Every participant generates an xpub. The most straightforward way is to create a new descriptor wallet.\n+            # This wallet will be the participant's `signer` for the resulting multisig. Avoid reusing this wallet for any other purpose (for privacy reasons).\n+            \"signers\": [node.get_wallet_rpc(node.createwallet(wallet_name=f\"participant_{self.nodes.index(node)}\", descriptors=True)[\"name\"]) for node in self.nodes],\n+            # After participants generate and exchange their xpubs they will each create their own watch-only multisig.\n+            # Note: these multisigs are all the same, this just highlights that each participant can independently verify everything on their own node.\n+            \"multisigs\": []\n+        }\n+\n+        self.log.info(\"Generate and exchange xpubs...\")\n+        external_xpubs, internal_xpubs = [[self._get_xpub(signer, internal) for signer in participants[\"signers\"]] for internal in [False, True]]\n+\n+        self.log.info(\"Every participant imports the following descriptors to create the watch-only multisig...\")\n+        participants[\"multisigs\"] = list(self.participants_create_multisigs(external_xpubs, internal_xpubs))\n+\n+        self.log.info(\"Check that every participant's multisig generates the same addresses...\")\n+        for _ in range(10):  # we check that the first 10 generated addresses are the same for all participant's multisigs\n+            receive_addresses = [multisig.getnewaddress() for multisig in participants[\"multisigs\"]]\n+            all(address == receive_addresses[0] for address in receive_addresses)\n+            change_addresses = [multisig.getrawchangeaddress() for multisig in participants[\"multisigs\"]]\n+            all(address == change_addresses[0] for address in change_addresses)\n+\n+        self.log.info(\"Get a mature utxo to send to the multisig...\")\n+        coordinator_wallet = participants[\"signers\"][0]\n+        self.generatetoaddress(self.nodes[0], 101, coordinator_wallet.getnewaddress())\n+\n+        deposit_amount = 6.15\n+        multisig_receiving_address = participants[\"multisigs\"][0].getnewaddress()\n+        self.log.info(\"Send funds to the resulting multisig receiving address...\")\n+        coordinator_wallet.sendtoaddress(multisig_receiving_address, deposit_amount)\n+        self.generate(self.nodes[0], 1)\n+        for participant in participants[\"multisigs\"]:\n+            assert_approx(participant.getbalance(), deposit_amount, vspan=0.001)\n+\n+        self.log.info(\"Send a transaction from the multisig! We can always spend with all signers!\")\n+        to = participants[\"signers\"][self.N - 1].getnewaddress()\n+        value = 1.5\n+        self.log.info(\"First, make a sending transaction, created using `walletcreatefundedpsbt` (anyone can initiate this)...\")\n+        psbt = participants[\"multisigs\"][0].walletcreatefundedpsbt(inputs=[], outputs={to: value}, feeRate=0.00010)\n+\n+        psbts = []\n+        self.log.info(\"Now at least M users check the psbt with decodepsbt and (if OK) signs it with walletprocesspsbt...\")\n+        for m in range(self.M):\n+            signers_multisig = participants[\"multisigs\"][m]\n+            self._check_psbt(psbt[\"psbt\"], to, value, signers_multisig)\n+            signing_wallet = participants[\"signers\"][m]\n+            partially_signed_psbt = signing_wallet.walletprocesspsbt(psbt[\"psbt\"])\n+            psbts.append(partially_signed_psbt[\"psbt\"])\n+\n+        self.log.info(\"Finally, collect the signed PSBTs with combinepsbt, finalizepsbt, then broadcast the resulting transaction...\")\n+        combined = coordinator_wallet.combinepsbt(psbts)\n+        finalized = coordinator_wallet.finalizepsbt(combined)\n+        coordinator_wallet.sendrawtransaction(finalized[\"hex\"])\n+\n+        self.log.info(\"Check that balances are correct after the transaction has been included in a block.\")\n+        self.generate(self.nodes[0], 1)\n+        assert_approx(participants[\"multisigs\"][0].getbalance(), deposit_amount - value, vspan=0.001)\n+        assert_equal(participants[\"signers\"][self.N - 1].getbalance(), value)",
      "path": "test/functional/wallet_miniscript_decaying_multisig_descriptor_psbt.py",
      "position": null,
      "original_position": 144,
      "commit_id": "aae032015367be812154a0e87955e6fd5ea5c192",
      "original_commit_id": "de93b863583921929bc16feb7a0bf5decfbc7ac5",
      "in_reply_to_id": 1567842740,
      "user": {
        "login": "mjdietzx",
        "id": 7217256,
        "node_id": "MDQ6VXNlcjcyMTcyNTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7217256?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mjdietzx",
        "html_url": "https://github.com/mjdietzx",
        "followers_url": "https://api.github.com/users/mjdietzx/followers",
        "following_url": "https://api.github.com/users/mjdietzx/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mjdietzx/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mjdietzx/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mjdietzx/subscriptions",
        "organizations_url": "https://api.github.com/users/mjdietzx/orgs",
        "repos_url": "https://api.github.com/users/mjdietzx/repos",
        "events_url": "https://api.github.com/users/mjdietzx/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mjdietzx/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I don't think it was ever necessary for me to demonstrate this alternative signing flow as part of this test. So I simplified and removed this code. Now all sends are tested in the single loop",
      "created_at": "2024-04-28T17:50:26Z",
      "updated_at": "2024-04-28T17:50:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29156#discussion_r1582257401",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1582257401"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29156"
        }
      },
      "start_line": null,
      "original_start_line": 129,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 144,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1582265867",
      "pull_request_review_id": 2027209534,
      "id": 1582265867,
      "node_id": "PRRC_kwDOABII585eT3YL",
      "diff_hunk": "@@ -0,0 +1,176 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test a miniscript multisig that starts as 4-of-4 and \"decays\" to 3-of-4, 2-of-4, and finally 1-of-4 at each future halvening block height.\n+\n+Spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+This is based off of `test/functional/wallet_multisig_descriptor_psbt.py` and most code is the same.\n+\"\"\"\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_approx,\n+    assert_equal,\n+    assert_raises_rpc_error,\n+)\n+\n+\n+class WalletMiniscriptDecayingMultisigDescriptorPSBTTest(BitcoinTestFramework):\n+    def add_options(self, parser):\n+        self.add_wallet_options(parser, legacy=False)\n+\n+    def set_test_params(self):\n+        self.num_nodes = 4\n+        self.setup_clean_chain = True\n+        self.wallet_names = []\n+        self.extra_args = [[\"-keypool=100\"]] * self.num_nodes\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+        self.skip_if_no_sqlite()\n+\n+    @staticmethod\n+    def _get_xpub(wallet, internal):\n+        \"\"\"Extract the wallet's xpubs using `listdescriptors` and pick the one from the `pkh` descriptor since it's least likely to be accidentally reused (legacy addresses).\"\"\"\n+        pkh_descriptor = next(filter(lambda d: d[\"desc\"].startswith(\"pkh(\") and d[\"internal\"] == internal, wallet.listdescriptors()[\"descriptors\"]))\n+        # Keep all key origin information (master key fingerprint and all derivation steps) for proper support of hardware devices\n+        # See section 'Key origin identification' in 'doc/descriptors.md' for more details...\n+        return pkh_descriptor[\"desc\"].split(\"pkh(\")[1].split(\")\")[0]\n+\n+    @staticmethod\n+    def _check_psbt(psbt, to, value, multisig):\n+        \"\"\"Helper function for any of the N participants to check the psbt with decodepsbt and verify it is OK before signing.\"\"\"\n+        tx = multisig.decodepsbt(psbt)[\"tx\"]\n+        amount = 0\n+        for vout in tx[\"vout\"]:\n+            address = vout[\"scriptPubKey\"][\"address\"]\n+            assert_equal(multisig.getaddressinfo(address)[\"ischange\"], address != to)\n+            if address == to:\n+                amount += vout[\"value\"]\n+        assert_approx(amount, float(value), vspan=0.001)\n+\n+    def participants_create_multisigs(self, external_xpubs, internal_xpubs):\n+        \"\"\"The multisig is created by importing the following descriptors. The resulting wallet is watch-only and every participant can do this.\"\"\"\n+        for i, node in enumerate(self.nodes):\n+            node.createwallet(wallet_name=f\"{self.name}_{i}\", blank=True, descriptors=True, disable_private_keys=True)\n+            multisig = node.get_wallet_rpc(f\"{self.name}_{i}\")\n+            # Spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+            external = multisig.getdescriptorinfo(f\"wsh(thresh({self.N},pk({f'),s:pk('.join(external_xpubs)}),sln:after({f'),sln:after('.join(map(str, self.locktimes))})))\")\n+            internal = multisig.getdescriptorinfo(f\"wsh(thresh({self.N},pk({f'),s:pk('.join(internal_xpubs)}),sln:after({f'),sln:after('.join(map(str, self.locktimes))})))\")\n+            result = multisig.importdescriptors([\n+                {  # receiving addresses (internal: False)\n+                    \"desc\": external[\"descriptor\"],\n+                    \"active\": True,\n+                    \"internal\": False,\n+                    \"timestamp\": \"now\",\n+                },\n+                {  # change addresses (internal: True)\n+                    \"desc\": internal[\"descriptor\"],\n+                    \"active\": True,\n+                    \"internal\": True,\n+                    \"timestamp\": \"now\",\n+                },\n+            ])\n+            assert all(r[\"success\"] for r in result)\n+            yield multisig",
      "path": "test/functional/wallet_miniscript_decaying_multisig_descriptor_psbt.py",
      "position": null,
      "original_position": 76,
      "commit_id": "aae032015367be812154a0e87955e6fd5ea5c192",
      "original_commit_id": "de93b863583921929bc16feb7a0bf5decfbc7ac5",
      "in_reply_to_id": 1567838489,
      "user": {
        "login": "mjdietzx",
        "id": 7217256,
        "node_id": "MDQ6VXNlcjcyMTcyNTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7217256?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mjdietzx",
        "html_url": "https://github.com/mjdietzx",
        "followers_url": "https://api.github.com/users/mjdietzx/followers",
        "following_url": "https://api.github.com/users/mjdietzx/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mjdietzx/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mjdietzx/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mjdietzx/subscriptions",
        "organizations_url": "https://api.github.com/users/mjdietzx/orgs",
        "repos_url": "https://api.github.com/users/mjdietzx/repos",
        "events_url": "https://api.github.com/users/mjdietzx/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mjdietzx/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "After addressing comments from your review, I made some simplifications and the two tests are now different enough I think this is no longer the case. The tests are still similar in their high-level structure, but otherwise not much code is duplicated (and definitely no complex/deep logic)",
      "created_at": "2024-04-28T18:13:02Z",
      "updated_at": "2024-04-28T18:13:02Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29156#discussion_r1582265867",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1582265867"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29156"
        }
      },
      "start_line": null,
      "original_start_line": 33,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 76,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1875950237",
      "pull_request_review_id": 2488750053,
      "id": 1875950237,
      "node_id": "PRRC_kwDOABII585v0Lqd",
      "diff_hunk": "@@ -0,0 +1,137 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test a miniscript multisig that starts as 4-of-4 and \"decays\" to 3-of-4, 2-of-4, and finally 1-of-4 at each future halvening block height.\n+\n+Spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+This is similar to `test/functional/wallet_multisig_descriptor_psbt.py`.\n+\"\"\"\n+\n+import random\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_approx,\n+    assert_equal,\n+    assert_raises_rpc_error,\n+)\n+\n+\n+class WalletMiniscriptDecayingMultisigDescriptorPSBTTest(BitcoinTestFramework):\n+    def add_options(self, parser):\n+        self.add_wallet_options(parser, legacy=False)\n+\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+        self.wallet_names = []\n+        self.extra_args = [[\"-keypool=100\"]]\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+        self.skip_if_no_sqlite()\n+\n+    @staticmethod\n+    def _get_xpub(wallet, internal):\n+        \"\"\"Extract the wallet's xpubs using `listdescriptors` and pick the one from the `pkh` descriptor since it's least likely to be accidentally reused (legacy addresses).\"\"\"\n+        pkh_descriptor = next(filter(lambda d: d[\"desc\"].startswith(\"pkh(\") and d[\"internal\"] == internal, wallet.listdescriptors()[\"descriptors\"]))\n+        # keep all key origin information (master key fingerprint and all derivation steps) for proper support of hardware devices\n+        # see section 'Key origin identification' in 'doc/descriptors.md' for more details...\n+        return pkh_descriptor[\"desc\"].split(\"pkh(\")[1].split(\")\")[0]\n+\n+    def create_multisig(self, external_xpubs, internal_xpubs):\n+        \"\"\"The multisig is created by importing the following descriptors. The resulting wallet is watch-only and every signer can do this.\"\"\"\n+        self.node.createwallet(wallet_name=f\"{self.name}\", blank=True, descriptors=True, disable_private_keys=True)\n+        multisig = self.node.get_wallet_rpc(f\"{self.name}\")\n+        # spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+        # IMPORTANT: when backing up your descriptor, the order of key_1...key_4 must be correct!\n+        external = multisig.getdescriptorinfo(f\"wsh(thresh({self.N},pk({f'),s:pk('.join(external_xpubs)}),sln:after({f'),sln:after('.join(map(str, self.locktimes))})))\")\n+        internal = multisig.getdescriptorinfo(f\"wsh(thresh({self.N},pk({f'),s:pk('.join(internal_xpubs)}),sln:after({f'),sln:after('.join(map(str, self.locktimes))})))\")\n+        result = multisig.importdescriptors([\n+            {  # receiving addresses (internal: False)\n+                \"desc\": external[\"descriptor\"],\n+                \"active\": True,\n+                \"internal\": False,\n+                \"timestamp\": \"now\",\n+            },\n+            {  # change addresses (internal: True)\n+                \"desc\": internal[\"descriptor\"],\n+                \"active\": True,\n+                \"internal\": True,\n+                \"timestamp\": \"now\",\n+            },\n+        ])\n+        assert all(r[\"success\"] for r in result)\n+        return multisig\n+\n+    def run_test(self):\n+        self.node = self.nodes[0]\n+        self.M = 4  # starts as 4-of-4\n+        self.N = 4\n+\n+        self.locktimes = [104, 106, 108]  # in real-world align with future halvenings, eg: [840000, 1050000, 1260000]",
      "path": "test/functional/wallet_miniscript_decaying_multisig_descriptor_psbt.py",
      "position": 72,
      "original_position": 72,
      "commit_id": "aae032015367be812154a0e87955e6fd5ea5c192",
      "original_commit_id": "aae032015367be812154a0e87955e6fd5ea5c192",
      "in_reply_to_id": null,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Nit: While the message in the comment is a neat idea for the timelocks, I don't think it is necessary to add in the test. ",
      "created_at": "2024-12-09T13:03:58Z",
      "updated_at": "2024-12-09T13:55:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29156#discussion_r1875950237",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1875950237"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29156"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 72,
      "original_line": 72,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1875977296",
      "pull_request_review_id": 2488750053,
      "id": 1875977296,
      "node_id": "PRRC_kwDOABII585v0SRQ",
      "diff_hunk": "@@ -0,0 +1,137 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test a miniscript multisig that starts as 4-of-4 and \"decays\" to 3-of-4, 2-of-4, and finally 1-of-4 at each future halvening block height.\n+\n+Spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+This is similar to `test/functional/wallet_multisig_descriptor_psbt.py`.\n+\"\"\"\n+\n+import random\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_approx,\n+    assert_equal,\n+    assert_raises_rpc_error,\n+)\n+\n+\n+class WalletMiniscriptDecayingMultisigDescriptorPSBTTest(BitcoinTestFramework):\n+    def add_options(self, parser):\n+        self.add_wallet_options(parser, legacy=False)\n+\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+        self.wallet_names = []\n+        self.extra_args = [[\"-keypool=100\"]]\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+        self.skip_if_no_sqlite()\n+\n+    @staticmethod",
      "path": "test/functional/wallet_miniscript_decaying_multisig_descriptor_psbt.py",
      "position": 34,
      "original_position": 34,
      "commit_id": "aae032015367be812154a0e87955e6fd5ea5c192",
      "original_commit_id": "aae032015367be812154a0e87955e6fd5ea5c192",
      "in_reply_to_id": null,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Why is this static method?",
      "created_at": "2024-12-09T13:24:34Z",
      "updated_at": "2024-12-09T13:55:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29156#discussion_r1875977296",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1875977296"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29156"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 34,
      "original_line": 34,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1875981014",
      "pull_request_review_id": 2488750053,
      "id": 1875981014,
      "node_id": "PRRC_kwDOABII585v0TLW",
      "diff_hunk": "@@ -0,0 +1,137 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test a miniscript multisig that starts as 4-of-4 and \"decays\" to 3-of-4, 2-of-4, and finally 1-of-4 at each future halvening block height.\n+\n+Spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+This is similar to `test/functional/wallet_multisig_descriptor_psbt.py`.\n+\"\"\"\n+\n+import random\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_approx,\n+    assert_equal,\n+    assert_raises_rpc_error,\n+)\n+\n+\n+class WalletMiniscriptDecayingMultisigDescriptorPSBTTest(BitcoinTestFramework):\n+    def add_options(self, parser):\n+        self.add_wallet_options(parser, legacy=False)\n+\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+        self.wallet_names = []\n+        self.extra_args = [[\"-keypool=100\"]]\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+        self.skip_if_no_sqlite()\n+\n+    @staticmethod\n+    def _get_xpub(wallet, internal):\n+        \"\"\"Extract the wallet's xpubs using `listdescriptors` and pick the one from the `pkh` descriptor since it's least likely to be accidentally reused (legacy addresses).\"\"\"\n+        pkh_descriptor = next(filter(lambda d: d[\"desc\"].startswith(\"pkh(\") and d[\"internal\"] == internal, wallet.listdescriptors()[\"descriptors\"]))\n+        # keep all key origin information (master key fingerprint and all derivation steps) for proper support of hardware devices\n+        # see section 'Key origin identification' in 'doc/descriptors.md' for more details...\n+        return pkh_descriptor[\"desc\"].split(\"pkh(\")[1].split(\")\")[0]\n+\n+    def create_multisig(self, external_xpubs, internal_xpubs):\n+        \"\"\"The multisig is created by importing the following descriptors. The resulting wallet is watch-only and every signer can do this.\"\"\"\n+        self.node.createwallet(wallet_name=f\"{self.name}\", blank=True, descriptors=True, disable_private_keys=True)\n+        multisig = self.node.get_wallet_rpc(f\"{self.name}\")\n+        # spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+        # IMPORTANT: when backing up your descriptor, the order of key_1...key_4 must be correct!\n+        external = multisig.getdescriptorinfo(f\"wsh(thresh({self.N},pk({f'),s:pk('.join(external_xpubs)}),sln:after({f'),sln:after('.join(map(str, self.locktimes))})))\")\n+        internal = multisig.getdescriptorinfo(f\"wsh(thresh({self.N},pk({f'),s:pk('.join(internal_xpubs)}),sln:after({f'),sln:after('.join(map(str, self.locktimes))})))\")\n+        result = multisig.importdescriptors([\n+            {  # receiving addresses (internal: False)\n+                \"desc\": external[\"descriptor\"],\n+                \"active\": True,\n+                \"internal\": False,\n+                \"timestamp\": \"now\",\n+            },\n+            {  # change addresses (internal: True)\n+                \"desc\": internal[\"descriptor\"],\n+                \"active\": True,\n+                \"internal\": True,\n+                \"timestamp\": \"now\",\n+            },\n+        ])\n+        assert all(r[\"success\"] for r in result)\n+        return multisig\n+\n+    def run_test(self):\n+        self.node = self.nodes[0]\n+        self.M = 4  # starts as 4-of-4\n+        self.N = 4\n+\n+        self.locktimes = [104, 106, 108]  # in real-world align with future halvenings, eg: [840000, 1050000, 1260000]\n+        assert_equal(len(self.locktimes), self.N - 1)\n+\n+        self.name = f\"{self.M}_of_{self.N}_decaying_multisig\"\n+        self.log.info(f\"Testing a miniscript multisig which starts as 4-of-4 and 'decays' to 3-of-4 at block height {self.locktimes[0]}, 2-of-4 at {self.locktimes[1]}, and finally 1-of-4 at {self.locktimes[2]}...\")",
      "path": "test/functional/wallet_miniscript_decaying_multisig_descriptor_psbt.py",
      "position": 76,
      "original_position": 76,
      "commit_id": "aae032015367be812154a0e87955e6fd5ea5c192",
      "original_commit_id": "aae032015367be812154a0e87955e6fd5ea5c192",
      "in_reply_to_id": null,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Nit:\r\n\r\n```suggestion\r\n        self.log.info(f\"Testing a miniscript multisig which starts as {self.N}-of-{self.N} and 'decays' to {self.N-1}-of-{self.N} at block height {self.locktimes[0]}, {self.N-2}-of-{self.N} at {self.locktimes[1]}, and finally {self.N-3}-of-{self.N} at {self.locktimes[2]}...\")\r\n```",
      "created_at": "2024-12-09T13:27:14Z",
      "updated_at": "2024-12-09T13:55:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29156#discussion_r1875981014",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1875981014"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29156"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 76,
      "original_line": 76,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1875988659",
      "pull_request_review_id": 2488750053,
      "id": 1875988659,
      "node_id": "PRRC_kwDOABII585v0VCz",
      "diff_hunk": "@@ -0,0 +1,137 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test a miniscript multisig that starts as 4-of-4 and \"decays\" to 3-of-4, 2-of-4, and finally 1-of-4 at each future halvening block height.\n+\n+Spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+This is similar to `test/functional/wallet_multisig_descriptor_psbt.py`.\n+\"\"\"\n+\n+import random\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_approx,\n+    assert_equal,\n+    assert_raises_rpc_error,\n+)\n+\n+\n+class WalletMiniscriptDecayingMultisigDescriptorPSBTTest(BitcoinTestFramework):\n+    def add_options(self, parser):\n+        self.add_wallet_options(parser, legacy=False)\n+\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+        self.wallet_names = []\n+        self.extra_args = [[\"-keypool=100\"]]\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+        self.skip_if_no_sqlite()\n+\n+    @staticmethod\n+    def _get_xpub(wallet, internal):\n+        \"\"\"Extract the wallet's xpubs using `listdescriptors` and pick the one from the `pkh` descriptor since it's least likely to be accidentally reused (legacy addresses).\"\"\"\n+        pkh_descriptor = next(filter(lambda d: d[\"desc\"].startswith(\"pkh(\") and d[\"internal\"] == internal, wallet.listdescriptors()[\"descriptors\"]))\n+        # keep all key origin information (master key fingerprint and all derivation steps) for proper support of hardware devices\n+        # see section 'Key origin identification' in 'doc/descriptors.md' for more details...\n+        return pkh_descriptor[\"desc\"].split(\"pkh(\")[1].split(\")\")[0]\n+\n+    def create_multisig(self, external_xpubs, internal_xpubs):\n+        \"\"\"The multisig is created by importing the following descriptors. The resulting wallet is watch-only and every signer can do this.\"\"\"\n+        self.node.createwallet(wallet_name=f\"{self.name}\", blank=True, descriptors=True, disable_private_keys=True)\n+        multisig = self.node.get_wallet_rpc(f\"{self.name}\")\n+        # spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+        # IMPORTANT: when backing up your descriptor, the order of key_1...key_4 must be correct!\n+        external = multisig.getdescriptorinfo(f\"wsh(thresh({self.N},pk({f'),s:pk('.join(external_xpubs)}),sln:after({f'),sln:after('.join(map(str, self.locktimes))})))\")\n+        internal = multisig.getdescriptorinfo(f\"wsh(thresh({self.N},pk({f'),s:pk('.join(internal_xpubs)}),sln:after({f'),sln:after('.join(map(str, self.locktimes))})))\")\n+        result = multisig.importdescriptors([\n+            {  # receiving addresses (internal: False)\n+                \"desc\": external[\"descriptor\"],\n+                \"active\": True,\n+                \"internal\": False,\n+                \"timestamp\": \"now\",\n+            },\n+            {  # change addresses (internal: True)\n+                \"desc\": internal[\"descriptor\"],\n+                \"active\": True,\n+                \"internal\": True,\n+                \"timestamp\": \"now\",\n+            },\n+        ])\n+        assert all(r[\"success\"] for r in result)\n+        return multisig\n+\n+    def run_test(self):\n+        self.node = self.nodes[0]\n+        self.M = 4  # starts as 4-of-4\n+        self.N = 4\n+\n+        self.locktimes = [104, 106, 108]  # in real-world align with future halvenings, eg: [840000, 1050000, 1260000]\n+        assert_equal(len(self.locktimes), self.N - 1)\n+\n+        self.name = f\"{self.M}_of_{self.N}_decaying_multisig\"\n+        self.log.info(f\"Testing a miniscript multisig which starts as 4-of-4 and 'decays' to 3-of-4 at block height {self.locktimes[0]}, 2-of-4 at {self.locktimes[1]}, and finally 1-of-4 at {self.locktimes[2]}...\")\n+\n+        self.log.info(\"Create the signer wallets and get their xpubs...\")\n+        signers = [self.node.get_wallet_rpc(self.node.createwallet(wallet_name=f\"signer_{i}\", descriptors=True)[\"name\"]) for i in range(self.N)]\n+        external_xpubs, internal_xpubs = [[self._get_xpub(signer, internal) for signer in signers] for internal in [False, True]]\n+\n+        self.log.info(\"Create the watch-only decaying multisig using signers' xpubs...\")\n+        multisig = self.create_multisig(external_xpubs, internal_xpubs)\n+\n+        self.log.info(\"Get a mature utxo to send to the multisig...\")\n+        coordinator_wallet = self.node.get_wallet_rpc(self.node.createwallet(wallet_name=f\"coordinator\", descriptors=True)[\"name\"])\n+        self.generatetoaddress(self.node, 101, coordinator_wallet.getnewaddress())\n+\n+        self.log.info(\"Send funds to the multisig's receiving address...\")\n+        deposit_amount = 6.15\n+        coordinator_wallet.sendtoaddress(multisig.getnewaddress(), deposit_amount)\n+        self.generate(self.node, 1)\n+        assert_approx(multisig.getbalance(), deposit_amount, vspan=0.001)\n+\n+        self.log.info(\"Send transactions from the multisig as required signers decay...\")\n+        sent = 0\n+        for locktime in [0] + self.locktimes:\n+            self.log.info(f\"At block height >= {locktime} this multisig is {self.M}-of-{self.N}\")\n+            current_height = self.node.getblock(self.node.getbestblockhash())['height']\n+\n+            amount = 1.5\n+            receiver = signers[0]\n+\n+            # in this test each signer signs the same psbt \"in series\" one after the other.\n+            # Another option is for each signer to sign the original psbt, and then combine\n+            # and finalize these. In some cases this may be more optimal for coordination.\n+            psbt = multisig.walletcreatefundedpsbt(inputs=[], outputs={receiver.getnewaddress(): amount}, feeRate=0.00010, locktime=locktime)\n+            # the random sample asserts that any of the signing keys can sign for the 3-of-4,\n+            # 2-of-4, and 1-of-4. While this is basic behavior of the miniscript thresh primitive,\n+            # it is a critical property of this wallet.\n+            for i, m in enumerate(random.sample(range(self.M), self.M)):\n+                psbt = signers[m].walletprocesspsbt(psbt[\"psbt\"])\n+                assert_equal(psbt[\"complete\"], i == self.M - 1)",
      "path": "test/functional/wallet_miniscript_decaying_multisig_descriptor_psbt.py",
      "position": 113,
      "original_position": 113,
      "commit_id": "aae032015367be812154a0e87955e6fd5ea5c192",
      "original_commit_id": "aae032015367be812154a0e87955e6fd5ea5c192",
      "in_reply_to_id": null,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "This is a neat check! Do you think there is value in calling the `testmempoolaccept` RPC as well in the case psbt is complete?",
      "created_at": "2024-12-09T13:32:49Z",
      "updated_at": "2024-12-09T13:55:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29156#discussion_r1875988659",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1875988659"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29156"
        }
      },
      "start_line": 111,
      "original_start_line": 111,
      "start_side": "RIGHT",
      "line": 113,
      "original_line": 113,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1875989430",
      "pull_request_review_id": 2488750053,
      "id": 1875989430,
      "node_id": "PRRC_kwDOABII585v0VO2",
      "diff_hunk": "@@ -0,0 +1,137 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test a miniscript multisig that starts as 4-of-4 and \"decays\" to 3-of-4, 2-of-4, and finally 1-of-4 at each future halvening block height.\n+\n+Spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+This is similar to `test/functional/wallet_multisig_descriptor_psbt.py`.\n+\"\"\"\n+\n+import random\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_approx,\n+    assert_equal,\n+    assert_raises_rpc_error,\n+)\n+\n+\n+class WalletMiniscriptDecayingMultisigDescriptorPSBTTest(BitcoinTestFramework):\n+    def add_options(self, parser):\n+        self.add_wallet_options(parser, legacy=False)\n+\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+        self.wallet_names = []\n+        self.extra_args = [[\"-keypool=100\"]]\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+        self.skip_if_no_sqlite()\n+\n+    @staticmethod\n+    def _get_xpub(wallet, internal):\n+        \"\"\"Extract the wallet's xpubs using `listdescriptors` and pick the one from the `pkh` descriptor since it's least likely to be accidentally reused (legacy addresses).\"\"\"\n+        pkh_descriptor = next(filter(lambda d: d[\"desc\"].startswith(\"pkh(\") and d[\"internal\"] == internal, wallet.listdescriptors()[\"descriptors\"]))\n+        # keep all key origin information (master key fingerprint and all derivation steps) for proper support of hardware devices\n+        # see section 'Key origin identification' in 'doc/descriptors.md' for more details...\n+        return pkh_descriptor[\"desc\"].split(\"pkh(\")[1].split(\")\")[0]\n+\n+    def create_multisig(self, external_xpubs, internal_xpubs):\n+        \"\"\"The multisig is created by importing the following descriptors. The resulting wallet is watch-only and every signer can do this.\"\"\"\n+        self.node.createwallet(wallet_name=f\"{self.name}\", blank=True, descriptors=True, disable_private_keys=True)\n+        multisig = self.node.get_wallet_rpc(f\"{self.name}\")\n+        # spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+        # IMPORTANT: when backing up your descriptor, the order of key_1...key_4 must be correct!\n+        external = multisig.getdescriptorinfo(f\"wsh(thresh({self.N},pk({f'),s:pk('.join(external_xpubs)}),sln:after({f'),sln:after('.join(map(str, self.locktimes))})))\")\n+        internal = multisig.getdescriptorinfo(f\"wsh(thresh({self.N},pk({f'),s:pk('.join(internal_xpubs)}),sln:after({f'),sln:after('.join(map(str, self.locktimes))})))\")\n+        result = multisig.importdescriptors([\n+            {  # receiving addresses (internal: False)\n+                \"desc\": external[\"descriptor\"],\n+                \"active\": True,\n+                \"internal\": False,\n+                \"timestamp\": \"now\",\n+            },\n+            {  # change addresses (internal: True)\n+                \"desc\": internal[\"descriptor\"],\n+                \"active\": True,\n+                \"internal\": True,\n+                \"timestamp\": \"now\",\n+            },\n+        ])\n+        assert all(r[\"success\"] for r in result)\n+        return multisig\n+\n+    def run_test(self):\n+        self.node = self.nodes[0]\n+        self.M = 4  # starts as 4-of-4\n+        self.N = 4\n+\n+        self.locktimes = [104, 106, 108]  # in real-world align with future halvenings, eg: [840000, 1050000, 1260000]\n+        assert_equal(len(self.locktimes), self.N - 1)\n+\n+        self.name = f\"{self.M}_of_{self.N}_decaying_multisig\"\n+        self.log.info(f\"Testing a miniscript multisig which starts as 4-of-4 and 'decays' to 3-of-4 at block height {self.locktimes[0]}, 2-of-4 at {self.locktimes[1]}, and finally 1-of-4 at {self.locktimes[2]}...\")\n+\n+        self.log.info(\"Create the signer wallets and get their xpubs...\")\n+        signers = [self.node.get_wallet_rpc(self.node.createwallet(wallet_name=f\"signer_{i}\", descriptors=True)[\"name\"]) for i in range(self.N)]\n+        external_xpubs, internal_xpubs = [[self._get_xpub(signer, internal) for signer in signers] for internal in [False, True]]\n+\n+        self.log.info(\"Create the watch-only decaying multisig using signers' xpubs...\")\n+        multisig = self.create_multisig(external_xpubs, internal_xpubs)\n+\n+        self.log.info(\"Get a mature utxo to send to the multisig...\")\n+        coordinator_wallet = self.node.get_wallet_rpc(self.node.createwallet(wallet_name=f\"coordinator\", descriptors=True)[\"name\"])\n+        self.generatetoaddress(self.node, 101, coordinator_wallet.getnewaddress())\n+\n+        self.log.info(\"Send funds to the multisig's receiving address...\")\n+        deposit_amount = 6.15\n+        coordinator_wallet.sendtoaddress(multisig.getnewaddress(), deposit_amount)\n+        self.generate(self.node, 1)\n+        assert_approx(multisig.getbalance(), deposit_amount, vspan=0.001)\n+\n+        self.log.info(\"Send transactions from the multisig as required signers decay...\")\n+        sent = 0\n+        for locktime in [0] + self.locktimes:\n+            self.log.info(f\"At block height >= {locktime} this multisig is {self.M}-of-{self.N}\")\n+            current_height = self.node.getblock(self.node.getbestblockhash())['height']\n+\n+            amount = 1.5\n+            receiver = signers[0]\n+\n+            # in this test each signer signs the same psbt \"in series\" one after the other.\n+            # Another option is for each signer to sign the original psbt, and then combine\n+            # and finalize these. In some cases this may be more optimal for coordination.\n+            psbt = multisig.walletcreatefundedpsbt(inputs=[], outputs={receiver.getnewaddress(): amount}, feeRate=0.00010, locktime=locktime)\n+            # the random sample asserts that any of the signing keys can sign for the 3-of-4,\n+            # 2-of-4, and 1-of-4. While this is basic behavior of the miniscript thresh primitive,\n+            # it is a critical property of this wallet.\n+            for i, m in enumerate(random.sample(range(self.M), self.M)):\n+                psbt = signers[m].walletprocesspsbt(psbt[\"psbt\"])\n+                assert_equal(psbt[\"complete\"], i == self.M - 1)\n+\n+            if self.M < self.N:\n+                self.log.info(f\"Check that the time-locked transaction is too immature to spend with {self.M}-of-{self.N} at block height {current_height}...\")\n+                assert_equal(current_height >= locktime, False)\n+                assert_raises_rpc_error(-26, \"non-final\", multisig.sendrawtransaction, psbt[\"hex\"])\n+\n+                self.log.info(f\"Generate blocks to reach the time-lock block height {locktime} and broadcast the transaction...\")\n+                self.generate(self.node, locktime - current_height)\n+            else:\n+                self.log.info(\"We can always spend with all signers!\")\n+\n+            multisig.sendrawtransaction(psbt[\"hex\"])\n+            sent += amount\n+\n+            self.log.info(\"Check that balances are correct after the transaction has been included in a block...\")\n+            self.generate(self.node, 1)\n+            assert_approx(multisig.getbalance(), deposit_amount - sent, vspan=0.001)\n+            assert_equal(receiver.getbalance(), sent)",
      "path": "test/functional/wallet_miniscript_decaying_multisig_descriptor_psbt.py",
      "position": 131,
      "original_position": 131,
      "commit_id": "aae032015367be812154a0e87955e6fd5ea5c192",
      "original_commit_id": "aae032015367be812154a0e87955e6fd5ea5c192",
      "in_reply_to_id": null,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Why is `assert_approx` not needed here?",
      "created_at": "2024-12-09T13:33:20Z",
      "updated_at": "2024-12-09T13:55:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29156#discussion_r1875989430",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1875989430"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29156"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 131,
      "original_line": 131,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1875998205",
      "pull_request_review_id": 2488750053,
      "id": 1875998205,
      "node_id": "PRRC_kwDOABII585v0XX9",
      "diff_hunk": "@@ -0,0 +1,137 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test a miniscript multisig that starts as 4-of-4 and \"decays\" to 3-of-4, 2-of-4, and finally 1-of-4 at each future halvening block height.\n+\n+Spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+This is similar to `test/functional/wallet_multisig_descriptor_psbt.py`.\n+\"\"\"\n+\n+import random\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_approx,\n+    assert_equal,\n+    assert_raises_rpc_error,\n+)\n+\n+\n+class WalletMiniscriptDecayingMultisigDescriptorPSBTTest(BitcoinTestFramework):\n+    def add_options(self, parser):\n+        self.add_wallet_options(parser, legacy=False)\n+\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+        self.wallet_names = []\n+        self.extra_args = [[\"-keypool=100\"]]\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+        self.skip_if_no_sqlite()\n+\n+    @staticmethod\n+    def _get_xpub(wallet, internal):\n+        \"\"\"Extract the wallet's xpubs using `listdescriptors` and pick the one from the `pkh` descriptor since it's least likely to be accidentally reused (legacy addresses).\"\"\"\n+        pkh_descriptor = next(filter(lambda d: d[\"desc\"].startswith(\"pkh(\") and d[\"internal\"] == internal, wallet.listdescriptors()[\"descriptors\"]))\n+        # keep all key origin information (master key fingerprint and all derivation steps) for proper support of hardware devices\n+        # see section 'Key origin identification' in 'doc/descriptors.md' for more details...\n+        return pkh_descriptor[\"desc\"].split(\"pkh(\")[1].split(\")\")[0]\n+\n+    def create_multisig(self, external_xpubs, internal_xpubs):\n+        \"\"\"The multisig is created by importing the following descriptors. The resulting wallet is watch-only and every signer can do this.\"\"\"\n+        self.node.createwallet(wallet_name=f\"{self.name}\", blank=True, descriptors=True, disable_private_keys=True)\n+        multisig = self.node.get_wallet_rpc(f\"{self.name}\")\n+        # spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+        # IMPORTANT: when backing up your descriptor, the order of key_1...key_4 must be correct!\n+        external = multisig.getdescriptorinfo(f\"wsh(thresh({self.N},pk({f'),s:pk('.join(external_xpubs)}),sln:after({f'),sln:after('.join(map(str, self.locktimes))})))\")\n+        internal = multisig.getdescriptorinfo(f\"wsh(thresh({self.N},pk({f'),s:pk('.join(internal_xpubs)}),sln:after({f'),sln:after('.join(map(str, self.locktimes))})))\")\n+        result = multisig.importdescriptors([\n+            {  # receiving addresses (internal: False)\n+                \"desc\": external[\"descriptor\"],\n+                \"active\": True,\n+                \"internal\": False,\n+                \"timestamp\": \"now\",\n+            },\n+            {  # change addresses (internal: True)\n+                \"desc\": internal[\"descriptor\"],\n+                \"active\": True,\n+                \"internal\": True,\n+                \"timestamp\": \"now\",\n+            },\n+        ])\n+        assert all(r[\"success\"] for r in result)\n+        return multisig\n+\n+    def run_test(self):\n+        self.node = self.nodes[0]\n+        self.M = 4  # starts as 4-of-4\n+        self.N = 4\n+\n+        self.locktimes = [104, 106, 108]  # in real-world align with future halvenings, eg: [840000, 1050000, 1260000]\n+        assert_equal(len(self.locktimes), self.N - 1)\n+\n+        self.name = f\"{self.M}_of_{self.N}_decaying_multisig\"\n+        self.log.info(f\"Testing a miniscript multisig which starts as 4-of-4 and 'decays' to 3-of-4 at block height {self.locktimes[0]}, 2-of-4 at {self.locktimes[1]}, and finally 1-of-4 at {self.locktimes[2]}...\")\n+\n+        self.log.info(\"Create the signer wallets and get their xpubs...\")\n+        signers = [self.node.get_wallet_rpc(self.node.createwallet(wallet_name=f\"signer_{i}\", descriptors=True)[\"name\"]) for i in range(self.N)]\n+        external_xpubs, internal_xpubs = [[self._get_xpub(signer, internal) for signer in signers] for internal in [False, True]]\n+\n+        self.log.info(\"Create the watch-only decaying multisig using signers' xpubs...\")\n+        multisig = self.create_multisig(external_xpubs, internal_xpubs)\n+\n+        self.log.info(\"Get a mature utxo to send to the multisig...\")\n+        coordinator_wallet = self.node.get_wallet_rpc(self.node.createwallet(wallet_name=f\"coordinator\", descriptors=True)[\"name\"])\n+        self.generatetoaddress(self.node, 101, coordinator_wallet.getnewaddress())\n+\n+        self.log.info(\"Send funds to the multisig's receiving address...\")\n+        deposit_amount = 6.15\n+        coordinator_wallet.sendtoaddress(multisig.getnewaddress(), deposit_amount)\n+        self.generate(self.node, 1)\n+        assert_approx(multisig.getbalance(), deposit_amount, vspan=0.001)\n+\n+        self.log.info(\"Send transactions from the multisig as required signers decay...\")\n+        sent = 0\n+        for locktime in [0] + self.locktimes:\n+            self.log.info(f\"At block height >= {locktime} this multisig is {self.M}-of-{self.N}\")\n+            current_height = self.node.getblock(self.node.getbestblockhash())['height']\n+\n+            amount = 1.5\n+            receiver = signers[0]",
      "path": "test/functional/wallet_miniscript_decaying_multisig_descriptor_psbt.py",
      "position": 102,
      "original_position": 102,
      "commit_id": "aae032015367be812154a0e87955e6fd5ea5c192",
      "original_commit_id": "aae032015367be812154a0e87955e6fd5ea5c192",
      "in_reply_to_id": null,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "`sent` is updated cumulatively here: https://github.com/bitcoin/bitcoin/pull/29156/files#diff-6d077a4bc1ef7303d3259ceb996ba18ac82741c9bf65afd403fb938ffbef2ba7R126\r\nbut the `receiver` is update every time in the for loop!\r\nNot a bug because the same receiver is picked every time but `receiver` should be defined once outside the loop just like the `sent` var.",
      "created_at": "2024-12-09T13:39:48Z",
      "updated_at": "2024-12-09T13:55:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29156#discussion_r1875998205",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1875998205"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29156"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 102,
      "original_line": 102,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1876006175",
      "pull_request_review_id": 2488750053,
      "id": 1876006175,
      "node_id": "PRRC_kwDOABII585v0ZUf",
      "diff_hunk": "@@ -0,0 +1,137 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test a miniscript multisig that starts as 4-of-4 and \"decays\" to 3-of-4, 2-of-4, and finally 1-of-4 at each future halvening block height.\n+\n+Spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+This is similar to `test/functional/wallet_multisig_descriptor_psbt.py`.\n+\"\"\"\n+\n+import random\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_approx,\n+    assert_equal,\n+    assert_raises_rpc_error,\n+)\n+\n+\n+class WalletMiniscriptDecayingMultisigDescriptorPSBTTest(BitcoinTestFramework):\n+    def add_options(self, parser):\n+        self.add_wallet_options(parser, legacy=False)\n+\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+        self.wallet_names = []\n+        self.extra_args = [[\"-keypool=100\"]]\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+        self.skip_if_no_sqlite()\n+\n+    @staticmethod\n+    def _get_xpub(wallet, internal):\n+        \"\"\"Extract the wallet's xpubs using `listdescriptors` and pick the one from the `pkh` descriptor since it's least likely to be accidentally reused (legacy addresses).\"\"\"\n+        pkh_descriptor = next(filter(lambda d: d[\"desc\"].startswith(\"pkh(\") and d[\"internal\"] == internal, wallet.listdescriptors()[\"descriptors\"]))\n+        # keep all key origin information (master key fingerprint and all derivation steps) for proper support of hardware devices\n+        # see section 'Key origin identification' in 'doc/descriptors.md' for more details...\n+        return pkh_descriptor[\"desc\"].split(\"pkh(\")[1].split(\")\")[0]\n+\n+    def create_multisig(self, external_xpubs, internal_xpubs):\n+        \"\"\"The multisig is created by importing the following descriptors. The resulting wallet is watch-only and every signer can do this.\"\"\"\n+        self.node.createwallet(wallet_name=f\"{self.name}\", blank=True, descriptors=True, disable_private_keys=True)\n+        multisig = self.node.get_wallet_rpc(f\"{self.name}\")\n+        # spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+        # IMPORTANT: when backing up your descriptor, the order of key_1...key_4 must be correct!\n+        external = multisig.getdescriptorinfo(f\"wsh(thresh({self.N},pk({f'),s:pk('.join(external_xpubs)}),sln:after({f'),sln:after('.join(map(str, self.locktimes))})))\")\n+        internal = multisig.getdescriptorinfo(f\"wsh(thresh({self.N},pk({f'),s:pk('.join(internal_xpubs)}),sln:after({f'),sln:after('.join(map(str, self.locktimes))})))\")\n+        result = multisig.importdescriptors([\n+            {  # receiving addresses (internal: False)\n+                \"desc\": external[\"descriptor\"],\n+                \"active\": True,\n+                \"internal\": False,\n+                \"timestamp\": \"now\",\n+            },\n+            {  # change addresses (internal: True)\n+                \"desc\": internal[\"descriptor\"],\n+                \"active\": True,\n+                \"internal\": True,\n+                \"timestamp\": \"now\",\n+            },\n+        ])\n+        assert all(r[\"success\"] for r in result)\n+        return multisig\n+\n+    def run_test(self):\n+        self.node = self.nodes[0]\n+        self.M = 4  # starts as 4-of-4\n+        self.N = 4\n+\n+        self.locktimes = [104, 106, 108]  # in real-world align with future halvenings, eg: [840000, 1050000, 1260000]\n+        assert_equal(len(self.locktimes), self.N - 1)\n+\n+        self.name = f\"{self.M}_of_{self.N}_decaying_multisig\"\n+        self.log.info(f\"Testing a miniscript multisig which starts as 4-of-4 and 'decays' to 3-of-4 at block height {self.locktimes[0]}, 2-of-4 at {self.locktimes[1]}, and finally 1-of-4 at {self.locktimes[2]}...\")\n+\n+        self.log.info(\"Create the signer wallets and get their xpubs...\")\n+        signers = [self.node.get_wallet_rpc(self.node.createwallet(wallet_name=f\"signer_{i}\", descriptors=True)[\"name\"]) for i in range(self.N)]\n+        external_xpubs, internal_xpubs = [[self._get_xpub(signer, internal) for signer in signers] for internal in [False, True]]\n+\n+        self.log.info(\"Create the watch-only decaying multisig using signers' xpubs...\")\n+        multisig = self.create_multisig(external_xpubs, internal_xpubs)\n+\n+        self.log.info(\"Get a mature utxo to send to the multisig...\")\n+        coordinator_wallet = self.node.get_wallet_rpc(self.node.createwallet(wallet_name=f\"coordinator\", descriptors=True)[\"name\"])\n+        self.generatetoaddress(self.node, 101, coordinator_wallet.getnewaddress())\n+\n+        self.log.info(\"Send funds to the multisig's receiving address...\")\n+        deposit_amount = 6.15\n+        coordinator_wallet.sendtoaddress(multisig.getnewaddress(), deposit_amount)",
      "path": "test/functional/wallet_miniscript_decaying_multisig_descriptor_psbt.py",
      "position": 91,
      "original_position": 91,
      "commit_id": "aae032015367be812154a0e87955e6fd5ea5c192",
      "original_commit_id": "aae032015367be812154a0e87955e6fd5ea5c192",
      "in_reply_to_id": null,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "If I'm not missing something, why is coordinator wallet needed here? Is there any issue in sending funds directly to the multi-sig address?",
      "created_at": "2024-12-09T13:45:25Z",
      "updated_at": "2024-12-09T13:55:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29156#discussion_r1876006175",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1876006175"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29156"
        }
      },
      "start_line": 86,
      "original_start_line": 86,
      "start_side": "RIGHT",
      "line": 91,
      "original_line": 91,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1876014461",
      "pull_request_review_id": 2488750053,
      "id": 1876014461,
      "node_id": "PRRC_kwDOABII585v0bV9",
      "diff_hunk": "@@ -0,0 +1,137 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test a miniscript multisig that starts as 4-of-4 and \"decays\" to 3-of-4, 2-of-4, and finally 1-of-4 at each future halvening block height.\n+\n+Spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+This is similar to `test/functional/wallet_multisig_descriptor_psbt.py`.\n+\"\"\"\n+\n+import random\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_approx,\n+    assert_equal,\n+    assert_raises_rpc_error,\n+)\n+\n+\n+class WalletMiniscriptDecayingMultisigDescriptorPSBTTest(BitcoinTestFramework):\n+    def add_options(self, parser):\n+        self.add_wallet_options(parser, legacy=False)\n+\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+        self.wallet_names = []\n+        self.extra_args = [[\"-keypool=100\"]]\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+        self.skip_if_no_sqlite()\n+\n+    @staticmethod\n+    def _get_xpub(wallet, internal):\n+        \"\"\"Extract the wallet's xpubs using `listdescriptors` and pick the one from the `pkh` descriptor since it's least likely to be accidentally reused (legacy addresses).\"\"\"\n+        pkh_descriptor = next(filter(lambda d: d[\"desc\"].startswith(\"pkh(\") and d[\"internal\"] == internal, wallet.listdescriptors()[\"descriptors\"]))\n+        # keep all key origin information (master key fingerprint and all derivation steps) for proper support of hardware devices\n+        # see section 'Key origin identification' in 'doc/descriptors.md' for more details...\n+        return pkh_descriptor[\"desc\"].split(\"pkh(\")[1].split(\")\")[0]\n+\n+    def create_multisig(self, external_xpubs, internal_xpubs):\n+        \"\"\"The multisig is created by importing the following descriptors. The resulting wallet is watch-only and every signer can do this.\"\"\"\n+        self.node.createwallet(wallet_name=f\"{self.name}\", blank=True, descriptors=True, disable_private_keys=True)\n+        multisig = self.node.get_wallet_rpc(f\"{self.name}\")\n+        # spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+        # IMPORTANT: when backing up your descriptor, the order of key_1...key_4 must be correct!\n+        external = multisig.getdescriptorinfo(f\"wsh(thresh({self.N},pk({f'),s:pk('.join(external_xpubs)}),sln:after({f'),sln:after('.join(map(str, self.locktimes))})))\")\n+        internal = multisig.getdescriptorinfo(f\"wsh(thresh({self.N},pk({f'),s:pk('.join(internal_xpubs)}),sln:after({f'),sln:after('.join(map(str, self.locktimes))})))\")\n+        result = multisig.importdescriptors([\n+            {  # receiving addresses (internal: False)\n+                \"desc\": external[\"descriptor\"],\n+                \"active\": True,\n+                \"internal\": False,\n+                \"timestamp\": \"now\",\n+            },\n+            {  # change addresses (internal: True)\n+                \"desc\": internal[\"descriptor\"],\n+                \"active\": True,\n+                \"internal\": True,\n+                \"timestamp\": \"now\",\n+            },\n+        ])\n+        assert all(r[\"success\"] for r in result)\n+        return multisig\n+\n+    def run_test(self):\n+        self.node = self.nodes[0]\n+        self.M = 4  # starts as 4-of-4\n+        self.N = 4\n+\n+        self.locktimes = [104, 106, 108]  # in real-world align with future halvenings, eg: [840000, 1050000, 1260000]\n+        assert_equal(len(self.locktimes), self.N - 1)\n+\n+        self.name = f\"{self.M}_of_{self.N}_decaying_multisig\"\n+        self.log.info(f\"Testing a miniscript multisig which starts as 4-of-4 and 'decays' to 3-of-4 at block height {self.locktimes[0]}, 2-of-4 at {self.locktimes[1]}, and finally 1-of-4 at {self.locktimes[2]}...\")\n+\n+        self.log.info(\"Create the signer wallets and get their xpubs...\")\n+        signers = [self.node.get_wallet_rpc(self.node.createwallet(wallet_name=f\"signer_{i}\", descriptors=True)[\"name\"]) for i in range(self.N)]\n+        external_xpubs, internal_xpubs = [[self._get_xpub(signer, internal) for signer in signers] for internal in [False, True]]\n+\n+        self.log.info(\"Create the watch-only decaying multisig using signers' xpubs...\")\n+        multisig = self.create_multisig(external_xpubs, internal_xpubs)\n+\n+        self.log.info(\"Get a mature utxo to send to the multisig...\")\n+        coordinator_wallet = self.node.get_wallet_rpc(self.node.createwallet(wallet_name=f\"coordinator\", descriptors=True)[\"name\"])\n+        self.generatetoaddress(self.node, 101, coordinator_wallet.getnewaddress())\n+\n+        self.log.info(\"Send funds to the multisig's receiving address...\")\n+        deposit_amount = 6.15\n+        coordinator_wallet.sendtoaddress(multisig.getnewaddress(), deposit_amount)\n+        self.generate(self.node, 1)\n+        assert_approx(multisig.getbalance(), deposit_amount, vspan=0.001)\n+\n+        self.log.info(\"Send transactions from the multisig as required signers decay...\")\n+        sent = 0\n+        for locktime in [0] + self.locktimes:",
      "path": "test/functional/wallet_miniscript_decaying_multisig_descriptor_psbt.py",
      "position": 97,
      "original_position": 97,
      "commit_id": "aae032015367be812154a0e87955e6fd5ea5c192",
      "original_commit_id": "aae032015367be812154a0e87955e6fd5ea5c192",
      "in_reply_to_id": null,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Why is 0 appended? Isn't the block height 102 at the start of the loop?",
      "created_at": "2024-12-09T13:51:10Z",
      "updated_at": "2024-12-09T13:55:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29156#discussion_r1876014461",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1876014461"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29156"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 97,
      "original_line": 97,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1876017269",
      "pull_request_review_id": 2488750053,
      "id": 1876017269,
      "node_id": "PRRC_kwDOABII585v0cB1",
      "diff_hunk": "@@ -0,0 +1,137 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test a miniscript multisig that starts as 4-of-4 and \"decays\" to 3-of-4, 2-of-4, and finally 1-of-4 at each future halvening block height.\n+\n+Spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+This is similar to `test/functional/wallet_multisig_descriptor_psbt.py`.\n+\"\"\"\n+\n+import random\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_approx,\n+    assert_equal,\n+    assert_raises_rpc_error,\n+)\n+\n+\n+class WalletMiniscriptDecayingMultisigDescriptorPSBTTest(BitcoinTestFramework):\n+    def add_options(self, parser):\n+        self.add_wallet_options(parser, legacy=False)\n+\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+        self.wallet_names = []\n+        self.extra_args = [[\"-keypool=100\"]]\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+        self.skip_if_no_sqlite()\n+\n+    @staticmethod\n+    def _get_xpub(wallet, internal):\n+        \"\"\"Extract the wallet's xpubs using `listdescriptors` and pick the one from the `pkh` descriptor since it's least likely to be accidentally reused (legacy addresses).\"\"\"\n+        pkh_descriptor = next(filter(lambda d: d[\"desc\"].startswith(\"pkh(\") and d[\"internal\"] == internal, wallet.listdescriptors()[\"descriptors\"]))\n+        # keep all key origin information (master key fingerprint and all derivation steps) for proper support of hardware devices\n+        # see section 'Key origin identification' in 'doc/descriptors.md' for more details...\n+        return pkh_descriptor[\"desc\"].split(\"pkh(\")[1].split(\")\")[0]\n+\n+    def create_multisig(self, external_xpubs, internal_xpubs):\n+        \"\"\"The multisig is created by importing the following descriptors. The resulting wallet is watch-only and every signer can do this.\"\"\"\n+        self.node.createwallet(wallet_name=f\"{self.name}\", blank=True, descriptors=True, disable_private_keys=True)\n+        multisig = self.node.get_wallet_rpc(f\"{self.name}\")\n+        # spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+        # IMPORTANT: when backing up your descriptor, the order of key_1...key_4 must be correct!\n+        external = multisig.getdescriptorinfo(f\"wsh(thresh({self.N},pk({f'),s:pk('.join(external_xpubs)}),sln:after({f'),sln:after('.join(map(str, self.locktimes))})))\")\n+        internal = multisig.getdescriptorinfo(f\"wsh(thresh({self.N},pk({f'),s:pk('.join(internal_xpubs)}),sln:after({f'),sln:after('.join(map(str, self.locktimes))})))\")\n+        result = multisig.importdescriptors([\n+            {  # receiving addresses (internal: False)\n+                \"desc\": external[\"descriptor\"],\n+                \"active\": True,\n+                \"internal\": False,\n+                \"timestamp\": \"now\",\n+            },\n+            {  # change addresses (internal: True)\n+                \"desc\": internal[\"descriptor\"],\n+                \"active\": True,\n+                \"internal\": True,\n+                \"timestamp\": \"now\",\n+            },\n+        ])\n+        assert all(r[\"success\"] for r in result)\n+        return multisig\n+\n+    def run_test(self):\n+        self.node = self.nodes[0]\n+        self.M = 4  # starts as 4-of-4\n+        self.N = 4\n+\n+        self.locktimes = [104, 106, 108]  # in real-world align with future halvenings, eg: [840000, 1050000, 1260000]\n+        assert_equal(len(self.locktimes), self.N - 1)\n+\n+        self.name = f\"{self.M}_of_{self.N}_decaying_multisig\"\n+        self.log.info(f\"Testing a miniscript multisig which starts as 4-of-4 and 'decays' to 3-of-4 at block height {self.locktimes[0]}, 2-of-4 at {self.locktimes[1]}, and finally 1-of-4 at {self.locktimes[2]}...\")\n+\n+        self.log.info(\"Create the signer wallets and get their xpubs...\")\n+        signers = [self.node.get_wallet_rpc(self.node.createwallet(wallet_name=f\"signer_{i}\", descriptors=True)[\"name\"]) for i in range(self.N)]\n+        external_xpubs, internal_xpubs = [[self._get_xpub(signer, internal) for signer in signers] for internal in [False, True]]\n+\n+        self.log.info(\"Create the watch-only decaying multisig using signers' xpubs...\")\n+        multisig = self.create_multisig(external_xpubs, internal_xpubs)\n+\n+        self.log.info(\"Get a mature utxo to send to the multisig...\")\n+        coordinator_wallet = self.node.get_wallet_rpc(self.node.createwallet(wallet_name=f\"coordinator\", descriptors=True)[\"name\"])\n+        self.generatetoaddress(self.node, 101, coordinator_wallet.getnewaddress())\n+\n+        self.log.info(\"Send funds to the multisig's receiving address...\")\n+        deposit_amount = 6.15\n+        coordinator_wallet.sendtoaddress(multisig.getnewaddress(), deposit_amount)\n+        self.generate(self.node, 1)\n+        assert_approx(multisig.getbalance(), deposit_amount, vspan=0.001)\n+\n+        self.log.info(\"Send transactions from the multisig as required signers decay...\")\n+        sent = 0\n+        for locktime in [0] + self.locktimes:\n+            self.log.info(f\"At block height >= {locktime} this multisig is {self.M}-of-{self.N}\")\n+            current_height = self.node.getblock(self.node.getbestblockhash())['height']\n+\n+            amount = 1.5\n+            receiver = signers[0]\n+\n+            # in this test each signer signs the same psbt \"in series\" one after the other.\n+            # Another option is for each signer to sign the original psbt, and then combine\n+            # and finalize these. In some cases this may be more optimal for coordination.\n+            psbt = multisig.walletcreatefundedpsbt(inputs=[], outputs={receiver.getnewaddress(): amount}, feeRate=0.00010, locktime=locktime)\n+            # the random sample asserts that any of the signing keys can sign for the 3-of-4,\n+            # 2-of-4, and 1-of-4. While this is basic behavior of the miniscript thresh primitive,\n+            # it is a critical property of this wallet.\n+            for i, m in enumerate(random.sample(range(self.M), self.M)):\n+                psbt = signers[m].walletprocesspsbt(psbt[\"psbt\"])\n+                assert_equal(psbt[\"complete\"], i == self.M - 1)\n+\n+            if self.M < self.N:\n+                self.log.info(f\"Check that the time-locked transaction is too immature to spend with {self.M}-of-{self.N} at block height {current_height}...\")\n+                assert_equal(current_height >= locktime, False)\n+                assert_raises_rpc_error(-26, \"non-final\", multisig.sendrawtransaction, psbt[\"hex\"])\n+\n+                self.log.info(f\"Generate blocks to reach the time-lock block height {locktime} and broadcast the transaction...\")\n+                self.generate(self.node, locktime - current_height)\n+            else:",
      "path": "test/functional/wallet_miniscript_decaying_multisig_descriptor_psbt.py",
      "position": 122,
      "original_position": 122,
      "commit_id": "aae032015367be812154a0e87955e6fd5ea5c192",
      "original_commit_id": "aae032015367be812154a0e87955e6fd5ea5c192",
      "in_reply_to_id": null,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```\r\n2024-12-09T13:49:54.971000Z TestFramework (INFO): At block height >= 0 this multisig is 4-of-4\r\n2024-12-09T13:49:54.980000Z TestFramework (INFO): We can always spend with all signers!\r\n```\r\n\r\nI found this log slightly confusing. Before the block height 104, 4 sigs are indeed required. Maybe the phrase \"We can always spend with all signers\" is more suited while spending after the height 108?",
      "created_at": "2024-12-09T13:53:07Z",
      "updated_at": "2024-12-09T13:55:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29156#discussion_r1876017269",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1876017269"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29156"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 122,
      "original_line": 122,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1883173215",
      "pull_request_review_id": 2501140714,
      "id": 1883173215,
      "node_id": "PRRC_kwDOABII585wPvFf",
      "diff_hunk": "@@ -0,0 +1,137 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test a miniscript multisig that starts as 4-of-4 and \"decays\" to 3-of-4, 2-of-4, and finally 1-of-4 at each future halvening block height.\n+\n+Spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+This is similar to `test/functional/wallet_multisig_descriptor_psbt.py`.\n+\"\"\"\n+\n+import random\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_approx,\n+    assert_equal,\n+    assert_raises_rpc_error,\n+)\n+\n+\n+class WalletMiniscriptDecayingMultisigDescriptorPSBTTest(BitcoinTestFramework):\n+    def add_options(self, parser):\n+        self.add_wallet_options(parser, legacy=False)\n+\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+        self.wallet_names = []\n+        self.extra_args = [[\"-keypool=100\"]]\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+        self.skip_if_no_sqlite()\n+\n+    @staticmethod",
      "path": "test/functional/wallet_miniscript_decaying_multisig_descriptor_psbt.py",
      "position": 34,
      "original_position": 34,
      "commit_id": "aae032015367be812154a0e87955e6fd5ea5c192",
      "original_commit_id": "aae032015367be812154a0e87955e6fd5ea5c192",
      "in_reply_to_id": 1875977296,
      "user": {
        "login": "mjdietzx",
        "id": 7217256,
        "node_id": "MDQ6VXNlcjcyMTcyNTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7217256?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mjdietzx",
        "html_url": "https://github.com/mjdietzx",
        "followers_url": "https://api.github.com/users/mjdietzx/followers",
        "following_url": "https://api.github.com/users/mjdietzx/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mjdietzx/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mjdietzx/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mjdietzx/subscriptions",
        "organizations_url": "https://api.github.com/users/mjdietzx/orgs",
        "repos_url": "https://api.github.com/users/mjdietzx/repos",
        "events_url": "https://api.github.com/users/mjdietzx/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mjdietzx/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "bc it doesn't use `self` so it indicates that it's a utility function that doesn't access class-data. just a convention, doesn't really matter",
      "created_at": "2024-12-13T02:47:38Z",
      "updated_at": "2024-12-13T03:09:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29156#discussion_r1883173215",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1883173215"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29156"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 34,
      "original_line": 34,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1883174900",
      "pull_request_review_id": 2501140714,
      "id": 1883174900,
      "node_id": "PRRC_kwDOABII585wPvf0",
      "diff_hunk": "@@ -0,0 +1,137 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test a miniscript multisig that starts as 4-of-4 and \"decays\" to 3-of-4, 2-of-4, and finally 1-of-4 at each future halvening block height.\n+\n+Spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+This is similar to `test/functional/wallet_multisig_descriptor_psbt.py`.\n+\"\"\"\n+\n+import random\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_approx,\n+    assert_equal,\n+    assert_raises_rpc_error,\n+)\n+\n+\n+class WalletMiniscriptDecayingMultisigDescriptorPSBTTest(BitcoinTestFramework):\n+    def add_options(self, parser):\n+        self.add_wallet_options(parser, legacy=False)\n+\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+        self.wallet_names = []\n+        self.extra_args = [[\"-keypool=100\"]]\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+        self.skip_if_no_sqlite()\n+\n+    @staticmethod\n+    def _get_xpub(wallet, internal):\n+        \"\"\"Extract the wallet's xpubs using `listdescriptors` and pick the one from the `pkh` descriptor since it's least likely to be accidentally reused (legacy addresses).\"\"\"\n+        pkh_descriptor = next(filter(lambda d: d[\"desc\"].startswith(\"pkh(\") and d[\"internal\"] == internal, wallet.listdescriptors()[\"descriptors\"]))\n+        # keep all key origin information (master key fingerprint and all derivation steps) for proper support of hardware devices\n+        # see section 'Key origin identification' in 'doc/descriptors.md' for more details...\n+        return pkh_descriptor[\"desc\"].split(\"pkh(\")[1].split(\")\")[0]\n+\n+    def create_multisig(self, external_xpubs, internal_xpubs):\n+        \"\"\"The multisig is created by importing the following descriptors. The resulting wallet is watch-only and every signer can do this.\"\"\"\n+        self.node.createwallet(wallet_name=f\"{self.name}\", blank=True, descriptors=True, disable_private_keys=True)\n+        multisig = self.node.get_wallet_rpc(f\"{self.name}\")\n+        # spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+        # IMPORTANT: when backing up your descriptor, the order of key_1...key_4 must be correct!\n+        external = multisig.getdescriptorinfo(f\"wsh(thresh({self.N},pk({f'),s:pk('.join(external_xpubs)}),sln:after({f'),sln:after('.join(map(str, self.locktimes))})))\")\n+        internal = multisig.getdescriptorinfo(f\"wsh(thresh({self.N},pk({f'),s:pk('.join(internal_xpubs)}),sln:after({f'),sln:after('.join(map(str, self.locktimes))})))\")\n+        result = multisig.importdescriptors([\n+            {  # receiving addresses (internal: False)\n+                \"desc\": external[\"descriptor\"],\n+                \"active\": True,\n+                \"internal\": False,\n+                \"timestamp\": \"now\",\n+            },\n+            {  # change addresses (internal: True)\n+                \"desc\": internal[\"descriptor\"],\n+                \"active\": True,\n+                \"internal\": True,\n+                \"timestamp\": \"now\",\n+            },\n+        ])\n+        assert all(r[\"success\"] for r in result)\n+        return multisig\n+\n+    def run_test(self):\n+        self.node = self.nodes[0]\n+        self.M = 4  # starts as 4-of-4\n+        self.N = 4\n+\n+        self.locktimes = [104, 106, 108]  # in real-world align with future halvenings, eg: [840000, 1050000, 1260000]\n+        assert_equal(len(self.locktimes), self.N - 1)\n+\n+        self.name = f\"{self.M}_of_{self.N}_decaying_multisig\"\n+        self.log.info(f\"Testing a miniscript multisig which starts as 4-of-4 and 'decays' to 3-of-4 at block height {self.locktimes[0]}, 2-of-4 at {self.locktimes[1]}, and finally 1-of-4 at {self.locktimes[2]}...\")\n+\n+        self.log.info(\"Create the signer wallets and get their xpubs...\")\n+        signers = [self.node.get_wallet_rpc(self.node.createwallet(wallet_name=f\"signer_{i}\", descriptors=True)[\"name\"]) for i in range(self.N)]\n+        external_xpubs, internal_xpubs = [[self._get_xpub(signer, internal) for signer in signers] for internal in [False, True]]\n+\n+        self.log.info(\"Create the watch-only decaying multisig using signers' xpubs...\")\n+        multisig = self.create_multisig(external_xpubs, internal_xpubs)\n+\n+        self.log.info(\"Get a mature utxo to send to the multisig...\")\n+        coordinator_wallet = self.node.get_wallet_rpc(self.node.createwallet(wallet_name=f\"coordinator\", descriptors=True)[\"name\"])\n+        self.generatetoaddress(self.node, 101, coordinator_wallet.getnewaddress())\n+\n+        self.log.info(\"Send funds to the multisig's receiving address...\")\n+        deposit_amount = 6.15\n+        coordinator_wallet.sendtoaddress(multisig.getnewaddress(), deposit_amount)",
      "path": "test/functional/wallet_miniscript_decaying_multisig_descriptor_psbt.py",
      "position": 91,
      "original_position": 91,
      "commit_id": "aae032015367be812154a0e87955e6fd5ea5c192",
      "original_commit_id": "aae032015367be812154a0e87955e6fd5ea5c192",
      "in_reply_to_id": 1876006175,
      "user": {
        "login": "mjdietzx",
        "id": 7217256,
        "node_id": "MDQ6VXNlcjcyMTcyNTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7217256?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mjdietzx",
        "html_url": "https://github.com/mjdietzx",
        "followers_url": "https://api.github.com/users/mjdietzx/followers",
        "following_url": "https://api.github.com/users/mjdietzx/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mjdietzx/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mjdietzx/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mjdietzx/subscriptions",
        "organizations_url": "https://api.github.com/users/mjdietzx/orgs",
        "repos_url": "https://api.github.com/users/mjdietzx/repos",
        "events_url": "https://api.github.com/users/mjdietzx/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mjdietzx/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "`coordinator` has a balance (the block rewards) so this is where the funds originate. it then sends to multisig and we assert expected values. I guess we could send directly to multisig but then it'd be doing self sends and we wouldn't be able to do simple checks on balances since it wouldn't change",
      "created_at": "2024-12-13T02:50:06Z",
      "updated_at": "2024-12-13T03:09:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29156#discussion_r1883174900",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1883174900"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29156"
        }
      },
      "start_line": 86,
      "original_start_line": 86,
      "start_side": "RIGHT",
      "line": 91,
      "original_line": 91,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1883175471",
      "pull_request_review_id": 2501140714,
      "id": 1883175471,
      "node_id": "PRRC_kwDOABII585wPvov",
      "diff_hunk": "@@ -0,0 +1,137 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test a miniscript multisig that starts as 4-of-4 and \"decays\" to 3-of-4, 2-of-4, and finally 1-of-4 at each future halvening block height.\n+\n+Spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+This is similar to `test/functional/wallet_multisig_descriptor_psbt.py`.\n+\"\"\"\n+\n+import random\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_approx,\n+    assert_equal,\n+    assert_raises_rpc_error,\n+)\n+\n+\n+class WalletMiniscriptDecayingMultisigDescriptorPSBTTest(BitcoinTestFramework):\n+    def add_options(self, parser):\n+        self.add_wallet_options(parser, legacy=False)\n+\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+        self.wallet_names = []\n+        self.extra_args = [[\"-keypool=100\"]]\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+        self.skip_if_no_sqlite()\n+\n+    @staticmethod\n+    def _get_xpub(wallet, internal):\n+        \"\"\"Extract the wallet's xpubs using `listdescriptors` and pick the one from the `pkh` descriptor since it's least likely to be accidentally reused (legacy addresses).\"\"\"\n+        pkh_descriptor = next(filter(lambda d: d[\"desc\"].startswith(\"pkh(\") and d[\"internal\"] == internal, wallet.listdescriptors()[\"descriptors\"]))\n+        # keep all key origin information (master key fingerprint and all derivation steps) for proper support of hardware devices\n+        # see section 'Key origin identification' in 'doc/descriptors.md' for more details...\n+        return pkh_descriptor[\"desc\"].split(\"pkh(\")[1].split(\")\")[0]\n+\n+    def create_multisig(self, external_xpubs, internal_xpubs):\n+        \"\"\"The multisig is created by importing the following descriptors. The resulting wallet is watch-only and every signer can do this.\"\"\"\n+        self.node.createwallet(wallet_name=f\"{self.name}\", blank=True, descriptors=True, disable_private_keys=True)\n+        multisig = self.node.get_wallet_rpc(f\"{self.name}\")\n+        # spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+        # IMPORTANT: when backing up your descriptor, the order of key_1...key_4 must be correct!\n+        external = multisig.getdescriptorinfo(f\"wsh(thresh({self.N},pk({f'),s:pk('.join(external_xpubs)}),sln:after({f'),sln:after('.join(map(str, self.locktimes))})))\")\n+        internal = multisig.getdescriptorinfo(f\"wsh(thresh({self.N},pk({f'),s:pk('.join(internal_xpubs)}),sln:after({f'),sln:after('.join(map(str, self.locktimes))})))\")\n+        result = multisig.importdescriptors([\n+            {  # receiving addresses (internal: False)\n+                \"desc\": external[\"descriptor\"],\n+                \"active\": True,\n+                \"internal\": False,\n+                \"timestamp\": \"now\",\n+            },\n+            {  # change addresses (internal: True)\n+                \"desc\": internal[\"descriptor\"],\n+                \"active\": True,\n+                \"internal\": True,\n+                \"timestamp\": \"now\",\n+            },\n+        ])\n+        assert all(r[\"success\"] for r in result)\n+        return multisig\n+\n+    def run_test(self):\n+        self.node = self.nodes[0]\n+        self.M = 4  # starts as 4-of-4\n+        self.N = 4\n+\n+        self.locktimes = [104, 106, 108]  # in real-world align with future halvenings, eg: [840000, 1050000, 1260000]\n+        assert_equal(len(self.locktimes), self.N - 1)\n+\n+        self.name = f\"{self.M}_of_{self.N}_decaying_multisig\"\n+        self.log.info(f\"Testing a miniscript multisig which starts as 4-of-4 and 'decays' to 3-of-4 at block height {self.locktimes[0]}, 2-of-4 at {self.locktimes[1]}, and finally 1-of-4 at {self.locktimes[2]}...\")\n+\n+        self.log.info(\"Create the signer wallets and get their xpubs...\")\n+        signers = [self.node.get_wallet_rpc(self.node.createwallet(wallet_name=f\"signer_{i}\", descriptors=True)[\"name\"]) for i in range(self.N)]\n+        external_xpubs, internal_xpubs = [[self._get_xpub(signer, internal) for signer in signers] for internal in [False, True]]\n+\n+        self.log.info(\"Create the watch-only decaying multisig using signers' xpubs...\")\n+        multisig = self.create_multisig(external_xpubs, internal_xpubs)\n+\n+        self.log.info(\"Get a mature utxo to send to the multisig...\")\n+        coordinator_wallet = self.node.get_wallet_rpc(self.node.createwallet(wallet_name=f\"coordinator\", descriptors=True)[\"name\"])\n+        self.generatetoaddress(self.node, 101, coordinator_wallet.getnewaddress())\n+\n+        self.log.info(\"Send funds to the multisig's receiving address...\")\n+        deposit_amount = 6.15\n+        coordinator_wallet.sendtoaddress(multisig.getnewaddress(), deposit_amount)\n+        self.generate(self.node, 1)\n+        assert_approx(multisig.getbalance(), deposit_amount, vspan=0.001)\n+\n+        self.log.info(\"Send transactions from the multisig as required signers decay...\")\n+        sent = 0\n+        for locktime in [0] + self.locktimes:",
      "path": "test/functional/wallet_miniscript_decaying_multisig_descriptor_psbt.py",
      "position": 97,
      "original_position": 97,
      "commit_id": "aae032015367be812154a0e87955e6fd5ea5c192",
      "original_commit_id": "aae032015367be812154a0e87955e6fd5ea5c192",
      "in_reply_to_id": 1876014461,
      "user": {
        "login": "mjdietzx",
        "id": 7217256,
        "node_id": "MDQ6VXNlcjcyMTcyNTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7217256?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mjdietzx",
        "html_url": "https://github.com/mjdietzx",
        "followers_url": "https://api.github.com/users/mjdietzx/followers",
        "following_url": "https://api.github.com/users/mjdietzx/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mjdietzx/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mjdietzx/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mjdietzx/subscriptions",
        "organizations_url": "https://api.github.com/users/mjdietzx/orgs",
        "repos_url": "https://api.github.com/users/mjdietzx/repos",
        "events_url": "https://api.github.com/users/mjdietzx/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mjdietzx/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "because at block 0 it is a 4 of 4 multisig. we test that case, then go through the lock times which correspond to 3 of 4, 2 of 4, 1 of 4 as it decays at those block heights",
      "created_at": "2024-12-13T02:50:58Z",
      "updated_at": "2024-12-13T03:09:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29156#discussion_r1883175471",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1883175471"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29156"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 97,
      "original_line": 97,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1883181187",
      "pull_request_review_id": 2501140714,
      "id": 1883181187,
      "node_id": "PRRC_kwDOABII585wPxCD",
      "diff_hunk": "@@ -0,0 +1,137 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test a miniscript multisig that starts as 4-of-4 and \"decays\" to 3-of-4, 2-of-4, and finally 1-of-4 at each future halvening block height.\n+\n+Spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+This is similar to `test/functional/wallet_multisig_descriptor_psbt.py`.\n+\"\"\"\n+\n+import random\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_approx,\n+    assert_equal,\n+    assert_raises_rpc_error,\n+)\n+\n+\n+class WalletMiniscriptDecayingMultisigDescriptorPSBTTest(BitcoinTestFramework):\n+    def add_options(self, parser):\n+        self.add_wallet_options(parser, legacy=False)\n+\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+        self.wallet_names = []\n+        self.extra_args = [[\"-keypool=100\"]]\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+        self.skip_if_no_sqlite()\n+\n+    @staticmethod\n+    def _get_xpub(wallet, internal):\n+        \"\"\"Extract the wallet's xpubs using `listdescriptors` and pick the one from the `pkh` descriptor since it's least likely to be accidentally reused (legacy addresses).\"\"\"\n+        pkh_descriptor = next(filter(lambda d: d[\"desc\"].startswith(\"pkh(\") and d[\"internal\"] == internal, wallet.listdescriptors()[\"descriptors\"]))\n+        # keep all key origin information (master key fingerprint and all derivation steps) for proper support of hardware devices\n+        # see section 'Key origin identification' in 'doc/descriptors.md' for more details...\n+        return pkh_descriptor[\"desc\"].split(\"pkh(\")[1].split(\")\")[0]\n+\n+    def create_multisig(self, external_xpubs, internal_xpubs):\n+        \"\"\"The multisig is created by importing the following descriptors. The resulting wallet is watch-only and every signer can do this.\"\"\"\n+        self.node.createwallet(wallet_name=f\"{self.name}\", blank=True, descriptors=True, disable_private_keys=True)\n+        multisig = self.node.get_wallet_rpc(f\"{self.name}\")\n+        # spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+        # IMPORTANT: when backing up your descriptor, the order of key_1...key_4 must be correct!\n+        external = multisig.getdescriptorinfo(f\"wsh(thresh({self.N},pk({f'),s:pk('.join(external_xpubs)}),sln:after({f'),sln:after('.join(map(str, self.locktimes))})))\")\n+        internal = multisig.getdescriptorinfo(f\"wsh(thresh({self.N},pk({f'),s:pk('.join(internal_xpubs)}),sln:after({f'),sln:after('.join(map(str, self.locktimes))})))\")\n+        result = multisig.importdescriptors([\n+            {  # receiving addresses (internal: False)\n+                \"desc\": external[\"descriptor\"],\n+                \"active\": True,\n+                \"internal\": False,\n+                \"timestamp\": \"now\",\n+            },\n+            {  # change addresses (internal: True)\n+                \"desc\": internal[\"descriptor\"],\n+                \"active\": True,\n+                \"internal\": True,\n+                \"timestamp\": \"now\",\n+            },\n+        ])\n+        assert all(r[\"success\"] for r in result)\n+        return multisig\n+\n+    def run_test(self):\n+        self.node = self.nodes[0]\n+        self.M = 4  # starts as 4-of-4\n+        self.N = 4\n+\n+        self.locktimes = [104, 106, 108]  # in real-world align with future halvenings, eg: [840000, 1050000, 1260000]\n+        assert_equal(len(self.locktimes), self.N - 1)\n+\n+        self.name = f\"{self.M}_of_{self.N}_decaying_multisig\"\n+        self.log.info(f\"Testing a miniscript multisig which starts as 4-of-4 and 'decays' to 3-of-4 at block height {self.locktimes[0]}, 2-of-4 at {self.locktimes[1]}, and finally 1-of-4 at {self.locktimes[2]}...\")\n+\n+        self.log.info(\"Create the signer wallets and get their xpubs...\")\n+        signers = [self.node.get_wallet_rpc(self.node.createwallet(wallet_name=f\"signer_{i}\", descriptors=True)[\"name\"]) for i in range(self.N)]\n+        external_xpubs, internal_xpubs = [[self._get_xpub(signer, internal) for signer in signers] for internal in [False, True]]\n+\n+        self.log.info(\"Create the watch-only decaying multisig using signers' xpubs...\")\n+        multisig = self.create_multisig(external_xpubs, internal_xpubs)\n+\n+        self.log.info(\"Get a mature utxo to send to the multisig...\")\n+        coordinator_wallet = self.node.get_wallet_rpc(self.node.createwallet(wallet_name=f\"coordinator\", descriptors=True)[\"name\"])\n+        self.generatetoaddress(self.node, 101, coordinator_wallet.getnewaddress())\n+\n+        self.log.info(\"Send funds to the multisig's receiving address...\")\n+        deposit_amount = 6.15\n+        coordinator_wallet.sendtoaddress(multisig.getnewaddress(), deposit_amount)\n+        self.generate(self.node, 1)\n+        assert_approx(multisig.getbalance(), deposit_amount, vspan=0.001)\n+\n+        self.log.info(\"Send transactions from the multisig as required signers decay...\")\n+        sent = 0\n+        for locktime in [0] + self.locktimes:\n+            self.log.info(f\"At block height >= {locktime} this multisig is {self.M}-of-{self.N}\")\n+            current_height = self.node.getblock(self.node.getbestblockhash())['height']\n+\n+            amount = 1.5\n+            receiver = signers[0]",
      "path": "test/functional/wallet_miniscript_decaying_multisig_descriptor_psbt.py",
      "position": 102,
      "original_position": 102,
      "commit_id": "aae032015367be812154a0e87955e6fd5ea5c192",
      "original_commit_id": "aae032015367be812154a0e87955e6fd5ea5c192",
      "in_reply_to_id": 1875998205,
      "user": {
        "login": "mjdietzx",
        "id": 7217256,
        "node_id": "MDQ6VXNlcjcyMTcyNTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7217256?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mjdietzx",
        "html_url": "https://github.com/mjdietzx",
        "followers_url": "https://api.github.com/users/mjdietzx/followers",
        "following_url": "https://api.github.com/users/mjdietzx/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mjdietzx/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mjdietzx/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mjdietzx/subscriptions",
        "organizations_url": "https://api.github.com/users/mjdietzx/orgs",
        "repos_url": "https://api.github.com/users/mjdietzx/repos",
        "events_url": "https://api.github.com/users/mjdietzx/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mjdietzx/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "good point, seems like amount is also hardcoded and would make more sense to be defined outside loop. will update when I rebase",
      "created_at": "2024-12-13T02:59:30Z",
      "updated_at": "2024-12-13T03:09:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29156#discussion_r1883181187",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1883181187"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29156"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 102,
      "original_line": 102,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1883182504",
      "pull_request_review_id": 2501140714,
      "id": 1883182504,
      "node_id": "PRRC_kwDOABII585wPxWo",
      "diff_hunk": "@@ -0,0 +1,137 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test a miniscript multisig that starts as 4-of-4 and \"decays\" to 3-of-4, 2-of-4, and finally 1-of-4 at each future halvening block height.\n+\n+Spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+This is similar to `test/functional/wallet_multisig_descriptor_psbt.py`.\n+\"\"\"\n+\n+import random\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_approx,\n+    assert_equal,\n+    assert_raises_rpc_error,\n+)\n+\n+\n+class WalletMiniscriptDecayingMultisigDescriptorPSBTTest(BitcoinTestFramework):\n+    def add_options(self, parser):\n+        self.add_wallet_options(parser, legacy=False)\n+\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+        self.wallet_names = []\n+        self.extra_args = [[\"-keypool=100\"]]\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+        self.skip_if_no_sqlite()\n+\n+    @staticmethod\n+    def _get_xpub(wallet, internal):\n+        \"\"\"Extract the wallet's xpubs using `listdescriptors` and pick the one from the `pkh` descriptor since it's least likely to be accidentally reused (legacy addresses).\"\"\"\n+        pkh_descriptor = next(filter(lambda d: d[\"desc\"].startswith(\"pkh(\") and d[\"internal\"] == internal, wallet.listdescriptors()[\"descriptors\"]))\n+        # keep all key origin information (master key fingerprint and all derivation steps) for proper support of hardware devices\n+        # see section 'Key origin identification' in 'doc/descriptors.md' for more details...\n+        return pkh_descriptor[\"desc\"].split(\"pkh(\")[1].split(\")\")[0]\n+\n+    def create_multisig(self, external_xpubs, internal_xpubs):\n+        \"\"\"The multisig is created by importing the following descriptors. The resulting wallet is watch-only and every signer can do this.\"\"\"\n+        self.node.createwallet(wallet_name=f\"{self.name}\", blank=True, descriptors=True, disable_private_keys=True)\n+        multisig = self.node.get_wallet_rpc(f\"{self.name}\")\n+        # spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+        # IMPORTANT: when backing up your descriptor, the order of key_1...key_4 must be correct!\n+        external = multisig.getdescriptorinfo(f\"wsh(thresh({self.N},pk({f'),s:pk('.join(external_xpubs)}),sln:after({f'),sln:after('.join(map(str, self.locktimes))})))\")\n+        internal = multisig.getdescriptorinfo(f\"wsh(thresh({self.N},pk({f'),s:pk('.join(internal_xpubs)}),sln:after({f'),sln:after('.join(map(str, self.locktimes))})))\")\n+        result = multisig.importdescriptors([\n+            {  # receiving addresses (internal: False)\n+                \"desc\": external[\"descriptor\"],\n+                \"active\": True,\n+                \"internal\": False,\n+                \"timestamp\": \"now\",\n+            },\n+            {  # change addresses (internal: True)\n+                \"desc\": internal[\"descriptor\"],\n+                \"active\": True,\n+                \"internal\": True,\n+                \"timestamp\": \"now\",\n+            },\n+        ])\n+        assert all(r[\"success\"] for r in result)\n+        return multisig\n+\n+    def run_test(self):\n+        self.node = self.nodes[0]\n+        self.M = 4  # starts as 4-of-4\n+        self.N = 4\n+\n+        self.locktimes = [104, 106, 108]  # in real-world align with future halvenings, eg: [840000, 1050000, 1260000]\n+        assert_equal(len(self.locktimes), self.N - 1)\n+\n+        self.name = f\"{self.M}_of_{self.N}_decaying_multisig\"\n+        self.log.info(f\"Testing a miniscript multisig which starts as 4-of-4 and 'decays' to 3-of-4 at block height {self.locktimes[0]}, 2-of-4 at {self.locktimes[1]}, and finally 1-of-4 at {self.locktimes[2]}...\")\n+\n+        self.log.info(\"Create the signer wallets and get their xpubs...\")\n+        signers = [self.node.get_wallet_rpc(self.node.createwallet(wallet_name=f\"signer_{i}\", descriptors=True)[\"name\"]) for i in range(self.N)]\n+        external_xpubs, internal_xpubs = [[self._get_xpub(signer, internal) for signer in signers] for internal in [False, True]]\n+\n+        self.log.info(\"Create the watch-only decaying multisig using signers' xpubs...\")\n+        multisig = self.create_multisig(external_xpubs, internal_xpubs)\n+\n+        self.log.info(\"Get a mature utxo to send to the multisig...\")\n+        coordinator_wallet = self.node.get_wallet_rpc(self.node.createwallet(wallet_name=f\"coordinator\", descriptors=True)[\"name\"])\n+        self.generatetoaddress(self.node, 101, coordinator_wallet.getnewaddress())\n+\n+        self.log.info(\"Send funds to the multisig's receiving address...\")\n+        deposit_amount = 6.15\n+        coordinator_wallet.sendtoaddress(multisig.getnewaddress(), deposit_amount)\n+        self.generate(self.node, 1)\n+        assert_approx(multisig.getbalance(), deposit_amount, vspan=0.001)\n+\n+        self.log.info(\"Send transactions from the multisig as required signers decay...\")\n+        sent = 0\n+        for locktime in [0] + self.locktimes:\n+            self.log.info(f\"At block height >= {locktime} this multisig is {self.M}-of-{self.N}\")\n+            current_height = self.node.getblock(self.node.getbestblockhash())['height']\n+\n+            amount = 1.5\n+            receiver = signers[0]\n+\n+            # in this test each signer signs the same psbt \"in series\" one after the other.\n+            # Another option is for each signer to sign the original psbt, and then combine\n+            # and finalize these. In some cases this may be more optimal for coordination.\n+            psbt = multisig.walletcreatefundedpsbt(inputs=[], outputs={receiver.getnewaddress(): amount}, feeRate=0.00010, locktime=locktime)\n+            # the random sample asserts that any of the signing keys can sign for the 3-of-4,\n+            # 2-of-4, and 1-of-4. While this is basic behavior of the miniscript thresh primitive,\n+            # it is a critical property of this wallet.\n+            for i, m in enumerate(random.sample(range(self.M), self.M)):\n+                psbt = signers[m].walletprocesspsbt(psbt[\"psbt\"])\n+                assert_equal(psbt[\"complete\"], i == self.M - 1)",
      "path": "test/functional/wallet_miniscript_decaying_multisig_descriptor_psbt.py",
      "position": 113,
      "original_position": 113,
      "commit_id": "aae032015367be812154a0e87955e6fd5ea5c192",
      "original_commit_id": "aae032015367be812154a0e87955e6fd5ea5c192",
      "in_reply_to_id": 1875988659,
      "user": {
        "login": "mjdietzx",
        "id": 7217256,
        "node_id": "MDQ6VXNlcjcyMTcyNTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7217256?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mjdietzx",
        "html_url": "https://github.com/mjdietzx",
        "followers_url": "https://api.github.com/users/mjdietzx/followers",
        "following_url": "https://api.github.com/users/mjdietzx/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mjdietzx/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mjdietzx/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mjdietzx/subscriptions",
        "organizations_url": "https://api.github.com/users/mjdietzx/orgs",
        "repos_url": "https://api.github.com/users/mjdietzx/repos",
        "events_url": "https://api.github.com/users/mjdietzx/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mjdietzx/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I don't think it'd hurt to add, but also not necessary because we will be broadcasting this to mempool next and that would revert. if it is simple to add testmempoolaccept though I'll add this as an improvement when I rebase",
      "created_at": "2024-12-13T03:01:37Z",
      "updated_at": "2024-12-13T03:09:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29156#discussion_r1883182504",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1883182504"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29156"
        }
      },
      "start_line": 111,
      "original_start_line": 111,
      "start_side": "RIGHT",
      "line": 113,
      "original_line": 113,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1883185654",
      "pull_request_review_id": 2501140714,
      "id": 1883185654,
      "node_id": "PRRC_kwDOABII585wPyH2",
      "diff_hunk": "@@ -0,0 +1,137 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test a miniscript multisig that starts as 4-of-4 and \"decays\" to 3-of-4, 2-of-4, and finally 1-of-4 at each future halvening block height.\n+\n+Spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+This is similar to `test/functional/wallet_multisig_descriptor_psbt.py`.\n+\"\"\"\n+\n+import random\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_approx,\n+    assert_equal,\n+    assert_raises_rpc_error,\n+)\n+\n+\n+class WalletMiniscriptDecayingMultisigDescriptorPSBTTest(BitcoinTestFramework):\n+    def add_options(self, parser):\n+        self.add_wallet_options(parser, legacy=False)\n+\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+        self.wallet_names = []\n+        self.extra_args = [[\"-keypool=100\"]]\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+        self.skip_if_no_sqlite()\n+\n+    @staticmethod\n+    def _get_xpub(wallet, internal):\n+        \"\"\"Extract the wallet's xpubs using `listdescriptors` and pick the one from the `pkh` descriptor since it's least likely to be accidentally reused (legacy addresses).\"\"\"\n+        pkh_descriptor = next(filter(lambda d: d[\"desc\"].startswith(\"pkh(\") and d[\"internal\"] == internal, wallet.listdescriptors()[\"descriptors\"]))\n+        # keep all key origin information (master key fingerprint and all derivation steps) for proper support of hardware devices\n+        # see section 'Key origin identification' in 'doc/descriptors.md' for more details...\n+        return pkh_descriptor[\"desc\"].split(\"pkh(\")[1].split(\")\")[0]\n+\n+    def create_multisig(self, external_xpubs, internal_xpubs):\n+        \"\"\"The multisig is created by importing the following descriptors. The resulting wallet is watch-only and every signer can do this.\"\"\"\n+        self.node.createwallet(wallet_name=f\"{self.name}\", blank=True, descriptors=True, disable_private_keys=True)\n+        multisig = self.node.get_wallet_rpc(f\"{self.name}\")\n+        # spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+        # IMPORTANT: when backing up your descriptor, the order of key_1...key_4 must be correct!\n+        external = multisig.getdescriptorinfo(f\"wsh(thresh({self.N},pk({f'),s:pk('.join(external_xpubs)}),sln:after({f'),sln:after('.join(map(str, self.locktimes))})))\")\n+        internal = multisig.getdescriptorinfo(f\"wsh(thresh({self.N},pk({f'),s:pk('.join(internal_xpubs)}),sln:after({f'),sln:after('.join(map(str, self.locktimes))})))\")\n+        result = multisig.importdescriptors([\n+            {  # receiving addresses (internal: False)\n+                \"desc\": external[\"descriptor\"],\n+                \"active\": True,\n+                \"internal\": False,\n+                \"timestamp\": \"now\",\n+            },\n+            {  # change addresses (internal: True)\n+                \"desc\": internal[\"descriptor\"],\n+                \"active\": True,\n+                \"internal\": True,\n+                \"timestamp\": \"now\",\n+            },\n+        ])\n+        assert all(r[\"success\"] for r in result)\n+        return multisig\n+\n+    def run_test(self):\n+        self.node = self.nodes[0]\n+        self.M = 4  # starts as 4-of-4\n+        self.N = 4\n+\n+        self.locktimes = [104, 106, 108]  # in real-world align with future halvenings, eg: [840000, 1050000, 1260000]\n+        assert_equal(len(self.locktimes), self.N - 1)\n+\n+        self.name = f\"{self.M}_of_{self.N}_decaying_multisig\"\n+        self.log.info(f\"Testing a miniscript multisig which starts as 4-of-4 and 'decays' to 3-of-4 at block height {self.locktimes[0]}, 2-of-4 at {self.locktimes[1]}, and finally 1-of-4 at {self.locktimes[2]}...\")\n+\n+        self.log.info(\"Create the signer wallets and get their xpubs...\")\n+        signers = [self.node.get_wallet_rpc(self.node.createwallet(wallet_name=f\"signer_{i}\", descriptors=True)[\"name\"]) for i in range(self.N)]\n+        external_xpubs, internal_xpubs = [[self._get_xpub(signer, internal) for signer in signers] for internal in [False, True]]\n+\n+        self.log.info(\"Create the watch-only decaying multisig using signers' xpubs...\")\n+        multisig = self.create_multisig(external_xpubs, internal_xpubs)\n+\n+        self.log.info(\"Get a mature utxo to send to the multisig...\")\n+        coordinator_wallet = self.node.get_wallet_rpc(self.node.createwallet(wallet_name=f\"coordinator\", descriptors=True)[\"name\"])\n+        self.generatetoaddress(self.node, 101, coordinator_wallet.getnewaddress())\n+\n+        self.log.info(\"Send funds to the multisig's receiving address...\")\n+        deposit_amount = 6.15\n+        coordinator_wallet.sendtoaddress(multisig.getnewaddress(), deposit_amount)\n+        self.generate(self.node, 1)\n+        assert_approx(multisig.getbalance(), deposit_amount, vspan=0.001)\n+\n+        self.log.info(\"Send transactions from the multisig as required signers decay...\")\n+        sent = 0\n+        for locktime in [0] + self.locktimes:\n+            self.log.info(f\"At block height >= {locktime} this multisig is {self.M}-of-{self.N}\")\n+            current_height = self.node.getblock(self.node.getbestblockhash())['height']\n+\n+            amount = 1.5\n+            receiver = signers[0]\n+\n+            # in this test each signer signs the same psbt \"in series\" one after the other.\n+            # Another option is for each signer to sign the original psbt, and then combine\n+            # and finalize these. In some cases this may be more optimal for coordination.\n+            psbt = multisig.walletcreatefundedpsbt(inputs=[], outputs={receiver.getnewaddress(): amount}, feeRate=0.00010, locktime=locktime)\n+            # the random sample asserts that any of the signing keys can sign for the 3-of-4,\n+            # 2-of-4, and 1-of-4. While this is basic behavior of the miniscript thresh primitive,\n+            # it is a critical property of this wallet.\n+            for i, m in enumerate(random.sample(range(self.M), self.M)):\n+                psbt = signers[m].walletprocesspsbt(psbt[\"psbt\"])\n+                assert_equal(psbt[\"complete\"], i == self.M - 1)\n+\n+            if self.M < self.N:\n+                self.log.info(f\"Check that the time-locked transaction is too immature to spend with {self.M}-of-{self.N} at block height {current_height}...\")\n+                assert_equal(current_height >= locktime, False)\n+                assert_raises_rpc_error(-26, \"non-final\", multisig.sendrawtransaction, psbt[\"hex\"])\n+\n+                self.log.info(f\"Generate blocks to reach the time-lock block height {locktime} and broadcast the transaction...\")\n+                self.generate(self.node, locktime - current_height)\n+            else:",
      "path": "test/functional/wallet_miniscript_decaying_multisig_descriptor_psbt.py",
      "position": 122,
      "original_position": 122,
      "commit_id": "aae032015367be812154a0e87955e6fd5ea5c192",
      "original_commit_id": "aae032015367be812154a0e87955e6fd5ea5c192",
      "in_reply_to_id": 1876017269,
      "user": {
        "login": "mjdietzx",
        "id": 7217256,
        "node_id": "MDQ6VXNlcjcyMTcyNTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7217256?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mjdietzx",
        "html_url": "https://github.com/mjdietzx",
        "followers_url": "https://api.github.com/users/mjdietzx/followers",
        "following_url": "https://api.github.com/users/mjdietzx/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mjdietzx/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mjdietzx/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mjdietzx/subscriptions",
        "organizations_url": "https://api.github.com/users/mjdietzx/orgs",
        "repos_url": "https://api.github.com/users/mjdietzx/repos",
        "events_url": "https://api.github.com/users/mjdietzx/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mjdietzx/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "It's just ensuring that no matter what 4 of 4 signers can always spend. So this is independent of block height. So this is asserted by checking that 4 of 4 can spend before the first lock time. Maybe it's confusing bc it's obvious but I thought it was important to check",
      "created_at": "2024-12-13T03:06:29Z",
      "updated_at": "2024-12-13T03:09:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29156#discussion_r1883185654",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1883185654"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29156"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 122,
      "original_line": 122,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1883186208",
      "pull_request_review_id": 2501140714,
      "id": 1883186208,
      "node_id": "PRRC_kwDOABII585wPyQg",
      "diff_hunk": "@@ -0,0 +1,137 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test a miniscript multisig that starts as 4-of-4 and \"decays\" to 3-of-4, 2-of-4, and finally 1-of-4 at each future halvening block height.\n+\n+Spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+This is similar to `test/functional/wallet_multisig_descriptor_psbt.py`.\n+\"\"\"\n+\n+import random\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_approx,\n+    assert_equal,\n+    assert_raises_rpc_error,\n+)\n+\n+\n+class WalletMiniscriptDecayingMultisigDescriptorPSBTTest(BitcoinTestFramework):\n+    def add_options(self, parser):\n+        self.add_wallet_options(parser, legacy=False)\n+\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+        self.wallet_names = []\n+        self.extra_args = [[\"-keypool=100\"]]\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+        self.skip_if_no_sqlite()\n+\n+    @staticmethod\n+    def _get_xpub(wallet, internal):\n+        \"\"\"Extract the wallet's xpubs using `listdescriptors` and pick the one from the `pkh` descriptor since it's least likely to be accidentally reused (legacy addresses).\"\"\"\n+        pkh_descriptor = next(filter(lambda d: d[\"desc\"].startswith(\"pkh(\") and d[\"internal\"] == internal, wallet.listdescriptors()[\"descriptors\"]))\n+        # keep all key origin information (master key fingerprint and all derivation steps) for proper support of hardware devices\n+        # see section 'Key origin identification' in 'doc/descriptors.md' for more details...\n+        return pkh_descriptor[\"desc\"].split(\"pkh(\")[1].split(\")\")[0]\n+\n+    def create_multisig(self, external_xpubs, internal_xpubs):\n+        \"\"\"The multisig is created by importing the following descriptors. The resulting wallet is watch-only and every signer can do this.\"\"\"\n+        self.node.createwallet(wallet_name=f\"{self.name}\", blank=True, descriptors=True, disable_private_keys=True)\n+        multisig = self.node.get_wallet_rpc(f\"{self.name}\")\n+        # spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+        # IMPORTANT: when backing up your descriptor, the order of key_1...key_4 must be correct!\n+        external = multisig.getdescriptorinfo(f\"wsh(thresh({self.N},pk({f'),s:pk('.join(external_xpubs)}),sln:after({f'),sln:after('.join(map(str, self.locktimes))})))\")\n+        internal = multisig.getdescriptorinfo(f\"wsh(thresh({self.N},pk({f'),s:pk('.join(internal_xpubs)}),sln:after({f'),sln:after('.join(map(str, self.locktimes))})))\")\n+        result = multisig.importdescriptors([\n+            {  # receiving addresses (internal: False)\n+                \"desc\": external[\"descriptor\"],\n+                \"active\": True,\n+                \"internal\": False,\n+                \"timestamp\": \"now\",\n+            },\n+            {  # change addresses (internal: True)\n+                \"desc\": internal[\"descriptor\"],\n+                \"active\": True,\n+                \"internal\": True,\n+                \"timestamp\": \"now\",\n+            },\n+        ])\n+        assert all(r[\"success\"] for r in result)\n+        return multisig\n+\n+    def run_test(self):\n+        self.node = self.nodes[0]\n+        self.M = 4  # starts as 4-of-4\n+        self.N = 4\n+\n+        self.locktimes = [104, 106, 108]  # in real-world align with future halvenings, eg: [840000, 1050000, 1260000]\n+        assert_equal(len(self.locktimes), self.N - 1)\n+\n+        self.name = f\"{self.M}_of_{self.N}_decaying_multisig\"\n+        self.log.info(f\"Testing a miniscript multisig which starts as 4-of-4 and 'decays' to 3-of-4 at block height {self.locktimes[0]}, 2-of-4 at {self.locktimes[1]}, and finally 1-of-4 at {self.locktimes[2]}...\")\n+\n+        self.log.info(\"Create the signer wallets and get their xpubs...\")\n+        signers = [self.node.get_wallet_rpc(self.node.createwallet(wallet_name=f\"signer_{i}\", descriptors=True)[\"name\"]) for i in range(self.N)]\n+        external_xpubs, internal_xpubs = [[self._get_xpub(signer, internal) for signer in signers] for internal in [False, True]]\n+\n+        self.log.info(\"Create the watch-only decaying multisig using signers' xpubs...\")\n+        multisig = self.create_multisig(external_xpubs, internal_xpubs)\n+\n+        self.log.info(\"Get a mature utxo to send to the multisig...\")\n+        coordinator_wallet = self.node.get_wallet_rpc(self.node.createwallet(wallet_name=f\"coordinator\", descriptors=True)[\"name\"])\n+        self.generatetoaddress(self.node, 101, coordinator_wallet.getnewaddress())\n+\n+        self.log.info(\"Send funds to the multisig's receiving address...\")\n+        deposit_amount = 6.15\n+        coordinator_wallet.sendtoaddress(multisig.getnewaddress(), deposit_amount)\n+        self.generate(self.node, 1)\n+        assert_approx(multisig.getbalance(), deposit_amount, vspan=0.001)\n+\n+        self.log.info(\"Send transactions from the multisig as required signers decay...\")\n+        sent = 0\n+        for locktime in [0] + self.locktimes:\n+            self.log.info(f\"At block height >= {locktime} this multisig is {self.M}-of-{self.N}\")\n+            current_height = self.node.getblock(self.node.getbestblockhash())['height']\n+\n+            amount = 1.5\n+            receiver = signers[0]\n+\n+            # in this test each signer signs the same psbt \"in series\" one after the other.\n+            # Another option is for each signer to sign the original psbt, and then combine\n+            # and finalize these. In some cases this may be more optimal for coordination.\n+            psbt = multisig.walletcreatefundedpsbt(inputs=[], outputs={receiver.getnewaddress(): amount}, feeRate=0.00010, locktime=locktime)\n+            # the random sample asserts that any of the signing keys can sign for the 3-of-4,\n+            # 2-of-4, and 1-of-4. While this is basic behavior of the miniscript thresh primitive,\n+            # it is a critical property of this wallet.\n+            for i, m in enumerate(random.sample(range(self.M), self.M)):\n+                psbt = signers[m].walletprocesspsbt(psbt[\"psbt\"])\n+                assert_equal(psbt[\"complete\"], i == self.M - 1)\n+\n+            if self.M < self.N:\n+                self.log.info(f\"Check that the time-locked transaction is too immature to spend with {self.M}-of-{self.N} at block height {current_height}...\")\n+                assert_equal(current_height >= locktime, False)\n+                assert_raises_rpc_error(-26, \"non-final\", multisig.sendrawtransaction, psbt[\"hex\"])\n+\n+                self.log.info(f\"Generate blocks to reach the time-lock block height {locktime} and broadcast the transaction...\")\n+                self.generate(self.node, locktime - current_height)\n+            else:\n+                self.log.info(\"We can always spend with all signers!\")\n+\n+            multisig.sendrawtransaction(psbt[\"hex\"])\n+            sent += amount\n+\n+            self.log.info(\"Check that balances are correct after the transaction has been included in a block...\")\n+            self.generate(self.node, 1)\n+            assert_approx(multisig.getbalance(), deposit_amount - sent, vspan=0.001)\n+            assert_equal(receiver.getbalance(), sent)",
      "path": "test/functional/wallet_miniscript_decaying_multisig_descriptor_psbt.py",
      "position": 131,
      "original_position": 131,
      "commit_id": "aae032015367be812154a0e87955e6fd5ea5c192",
      "original_commit_id": "aae032015367be812154a0e87955e6fd5ea5c192",
      "in_reply_to_id": 1875989430,
      "user": {
        "login": "mjdietzx",
        "id": 7217256,
        "node_id": "MDQ6VXNlcjcyMTcyNTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7217256?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mjdietzx",
        "html_url": "https://github.com/mjdietzx",
        "followers_url": "https://api.github.com/users/mjdietzx/followers",
        "following_url": "https://api.github.com/users/mjdietzx/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mjdietzx/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mjdietzx/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mjdietzx/subscriptions",
        "organizations_url": "https://api.github.com/users/mjdietzx/orgs",
        "repos_url": "https://api.github.com/users/mjdietzx/repos",
        "events_url": "https://api.github.com/users/mjdietzx/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mjdietzx/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "because the receiver gets the full amount sent, while the sender sent the full amount plus a small txn fee (which is why sender needs to use assert approx to keep it simple)",
      "created_at": "2024-12-13T03:07:27Z",
      "updated_at": "2024-12-13T03:09:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29156#discussion_r1883186208",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1883186208"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29156"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 131,
      "original_line": 131,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1883186512",
      "pull_request_review_id": 2501140714,
      "id": 1883186512,
      "node_id": "PRRC_kwDOABII585wPyVQ",
      "diff_hunk": "@@ -0,0 +1,137 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test a miniscript multisig that starts as 4-of-4 and \"decays\" to 3-of-4, 2-of-4, and finally 1-of-4 at each future halvening block height.\n+\n+Spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+This is similar to `test/functional/wallet_multisig_descriptor_psbt.py`.\n+\"\"\"\n+\n+import random\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_approx,\n+    assert_equal,\n+    assert_raises_rpc_error,\n+)\n+\n+\n+class WalletMiniscriptDecayingMultisigDescriptorPSBTTest(BitcoinTestFramework):\n+    def add_options(self, parser):\n+        self.add_wallet_options(parser, legacy=False)\n+\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+        self.wallet_names = []\n+        self.extra_args = [[\"-keypool=100\"]]\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+        self.skip_if_no_sqlite()\n+\n+    @staticmethod\n+    def _get_xpub(wallet, internal):\n+        \"\"\"Extract the wallet's xpubs using `listdescriptors` and pick the one from the `pkh` descriptor since it's least likely to be accidentally reused (legacy addresses).\"\"\"\n+        pkh_descriptor = next(filter(lambda d: d[\"desc\"].startswith(\"pkh(\") and d[\"internal\"] == internal, wallet.listdescriptors()[\"descriptors\"]))\n+        # keep all key origin information (master key fingerprint and all derivation steps) for proper support of hardware devices\n+        # see section 'Key origin identification' in 'doc/descriptors.md' for more details...\n+        return pkh_descriptor[\"desc\"].split(\"pkh(\")[1].split(\")\")[0]\n+\n+    def create_multisig(self, external_xpubs, internal_xpubs):\n+        \"\"\"The multisig is created by importing the following descriptors. The resulting wallet is watch-only and every signer can do this.\"\"\"\n+        self.node.createwallet(wallet_name=f\"{self.name}\", blank=True, descriptors=True, disable_private_keys=True)\n+        multisig = self.node.get_wallet_rpc(f\"{self.name}\")\n+        # spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+        # IMPORTANT: when backing up your descriptor, the order of key_1...key_4 must be correct!\n+        external = multisig.getdescriptorinfo(f\"wsh(thresh({self.N},pk({f'),s:pk('.join(external_xpubs)}),sln:after({f'),sln:after('.join(map(str, self.locktimes))})))\")\n+        internal = multisig.getdescriptorinfo(f\"wsh(thresh({self.N},pk({f'),s:pk('.join(internal_xpubs)}),sln:after({f'),sln:after('.join(map(str, self.locktimes))})))\")\n+        result = multisig.importdescriptors([\n+            {  # receiving addresses (internal: False)\n+                \"desc\": external[\"descriptor\"],\n+                \"active\": True,\n+                \"internal\": False,\n+                \"timestamp\": \"now\",\n+            },\n+            {  # change addresses (internal: True)\n+                \"desc\": internal[\"descriptor\"],\n+                \"active\": True,\n+                \"internal\": True,\n+                \"timestamp\": \"now\",\n+            },\n+        ])\n+        assert all(r[\"success\"] for r in result)\n+        return multisig\n+\n+    def run_test(self):\n+        self.node = self.nodes[0]\n+        self.M = 4  # starts as 4-of-4\n+        self.N = 4\n+\n+        self.locktimes = [104, 106, 108]  # in real-world align with future halvenings, eg: [840000, 1050000, 1260000]\n+        assert_equal(len(self.locktimes), self.N - 1)\n+\n+        self.name = f\"{self.M}_of_{self.N}_decaying_multisig\"\n+        self.log.info(f\"Testing a miniscript multisig which starts as 4-of-4 and 'decays' to 3-of-4 at block height {self.locktimes[0]}, 2-of-4 at {self.locktimes[1]}, and finally 1-of-4 at {self.locktimes[2]}...\")",
      "path": "test/functional/wallet_miniscript_decaying_multisig_descriptor_psbt.py",
      "position": 76,
      "original_position": 76,
      "commit_id": "aae032015367be812154a0e87955e6fd5ea5c192",
      "original_commit_id": "aae032015367be812154a0e87955e6fd5ea5c192",
      "in_reply_to_id": 1875981014,
      "user": {
        "login": "mjdietzx",
        "id": 7217256,
        "node_id": "MDQ6VXNlcjcyMTcyNTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7217256?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mjdietzx",
        "html_url": "https://github.com/mjdietzx",
        "followers_url": "https://api.github.com/users/mjdietzx/followers",
        "following_url": "https://api.github.com/users/mjdietzx/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mjdietzx/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mjdietzx/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mjdietzx/subscriptions",
        "organizations_url": "https://api.github.com/users/mjdietzx/orgs",
        "repos_url": "https://api.github.com/users/mjdietzx/repos",
        "events_url": "https://api.github.com/users/mjdietzx/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mjdietzx/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "seems more complicated to me tbh",
      "created_at": "2024-12-13T03:07:58Z",
      "updated_at": "2024-12-13T03:09:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29156#discussion_r1883186512",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1883186512"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29156"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 76,
      "original_line": 76,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1883186875",
      "pull_request_review_id": 2501140714,
      "id": 1883186875,
      "node_id": "PRRC_kwDOABII585wPya7",
      "diff_hunk": "@@ -0,0 +1,137 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test a miniscript multisig that starts as 4-of-4 and \"decays\" to 3-of-4, 2-of-4, and finally 1-of-4 at each future halvening block height.\n+\n+Spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+This is similar to `test/functional/wallet_multisig_descriptor_psbt.py`.\n+\"\"\"\n+\n+import random\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_approx,\n+    assert_equal,\n+    assert_raises_rpc_error,\n+)\n+\n+\n+class WalletMiniscriptDecayingMultisigDescriptorPSBTTest(BitcoinTestFramework):\n+    def add_options(self, parser):\n+        self.add_wallet_options(parser, legacy=False)\n+\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+        self.wallet_names = []\n+        self.extra_args = [[\"-keypool=100\"]]\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+        self.skip_if_no_sqlite()\n+\n+    @staticmethod\n+    def _get_xpub(wallet, internal):\n+        \"\"\"Extract the wallet's xpubs using `listdescriptors` and pick the one from the `pkh` descriptor since it's least likely to be accidentally reused (legacy addresses).\"\"\"\n+        pkh_descriptor = next(filter(lambda d: d[\"desc\"].startswith(\"pkh(\") and d[\"internal\"] == internal, wallet.listdescriptors()[\"descriptors\"]))\n+        # keep all key origin information (master key fingerprint and all derivation steps) for proper support of hardware devices\n+        # see section 'Key origin identification' in 'doc/descriptors.md' for more details...\n+        return pkh_descriptor[\"desc\"].split(\"pkh(\")[1].split(\")\")[0]\n+\n+    def create_multisig(self, external_xpubs, internal_xpubs):\n+        \"\"\"The multisig is created by importing the following descriptors. The resulting wallet is watch-only and every signer can do this.\"\"\"\n+        self.node.createwallet(wallet_name=f\"{self.name}\", blank=True, descriptors=True, disable_private_keys=True)\n+        multisig = self.node.get_wallet_rpc(f\"{self.name}\")\n+        # spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+        # IMPORTANT: when backing up your descriptor, the order of key_1...key_4 must be correct!\n+        external = multisig.getdescriptorinfo(f\"wsh(thresh({self.N},pk({f'),s:pk('.join(external_xpubs)}),sln:after({f'),sln:after('.join(map(str, self.locktimes))})))\")\n+        internal = multisig.getdescriptorinfo(f\"wsh(thresh({self.N},pk({f'),s:pk('.join(internal_xpubs)}),sln:after({f'),sln:after('.join(map(str, self.locktimes))})))\")\n+        result = multisig.importdescriptors([\n+            {  # receiving addresses (internal: False)\n+                \"desc\": external[\"descriptor\"],\n+                \"active\": True,\n+                \"internal\": False,\n+                \"timestamp\": \"now\",\n+            },\n+            {  # change addresses (internal: True)\n+                \"desc\": internal[\"descriptor\"],\n+                \"active\": True,\n+                \"internal\": True,\n+                \"timestamp\": \"now\",\n+            },\n+        ])\n+        assert all(r[\"success\"] for r in result)\n+        return multisig\n+\n+    def run_test(self):\n+        self.node = self.nodes[0]\n+        self.M = 4  # starts as 4-of-4\n+        self.N = 4\n+\n+        self.locktimes = [104, 106, 108]  # in real-world align with future halvenings, eg: [840000, 1050000, 1260000]",
      "path": "test/functional/wallet_miniscript_decaying_multisig_descriptor_psbt.py",
      "position": 72,
      "original_position": 72,
      "commit_id": "aae032015367be812154a0e87955e6fd5ea5c192",
      "original_commit_id": "aae032015367be812154a0e87955e6fd5ea5c192",
      "in_reply_to_id": 1875950237,
      "user": {
        "login": "mjdietzx",
        "id": 7217256,
        "node_id": "MDQ6VXNlcjcyMTcyNTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7217256?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mjdietzx",
        "html_url": "https://github.com/mjdietzx",
        "followers_url": "https://api.github.com/users/mjdietzx/followers",
        "following_url": "https://api.github.com/users/mjdietzx/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mjdietzx/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mjdietzx/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mjdietzx/subscriptions",
        "organizations_url": "https://api.github.com/users/mjdietzx/orgs",
        "repos_url": "https://api.github.com/users/mjdietzx/repos",
        "events_url": "https://api.github.com/users/mjdietzx/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mjdietzx/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "yeah maybe it's over specific. I'll either remove or improve it",
      "created_at": "2024-12-13T03:08:34Z",
      "updated_at": "2024-12-13T03:09:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29156#discussion_r1883186875",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1883186875"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29156"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 72,
      "original_line": 72,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1883304623",
      "pull_request_review_id": 2501317018,
      "id": 1883304623,
      "node_id": "PRRC_kwDOABII585wQPKv",
      "diff_hunk": "@@ -0,0 +1,137 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test a miniscript multisig that starts as 4-of-4 and \"decays\" to 3-of-4, 2-of-4, and finally 1-of-4 at each future halvening block height.\n+\n+Spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+This is similar to `test/functional/wallet_multisig_descriptor_psbt.py`.\n+\"\"\"\n+\n+import random\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_approx,\n+    assert_equal,\n+    assert_raises_rpc_error,\n+)\n+\n+\n+class WalletMiniscriptDecayingMultisigDescriptorPSBTTest(BitcoinTestFramework):\n+    def add_options(self, parser):\n+        self.add_wallet_options(parser, legacy=False)\n+\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+        self.wallet_names = []\n+        self.extra_args = [[\"-keypool=100\"]]\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+        self.skip_if_no_sqlite()\n+\n+    @staticmethod\n+    def _get_xpub(wallet, internal):\n+        \"\"\"Extract the wallet's xpubs using `listdescriptors` and pick the one from the `pkh` descriptor since it's least likely to be accidentally reused (legacy addresses).\"\"\"\n+        pkh_descriptor = next(filter(lambda d: d[\"desc\"].startswith(\"pkh(\") and d[\"internal\"] == internal, wallet.listdescriptors()[\"descriptors\"]))\n+        # keep all key origin information (master key fingerprint and all derivation steps) for proper support of hardware devices\n+        # see section 'Key origin identification' in 'doc/descriptors.md' for more details...\n+        return pkh_descriptor[\"desc\"].split(\"pkh(\")[1].split(\")\")[0]\n+\n+    def create_multisig(self, external_xpubs, internal_xpubs):\n+        \"\"\"The multisig is created by importing the following descriptors. The resulting wallet is watch-only and every signer can do this.\"\"\"\n+        self.node.createwallet(wallet_name=f\"{self.name}\", blank=True, descriptors=True, disable_private_keys=True)\n+        multisig = self.node.get_wallet_rpc(f\"{self.name}\")\n+        # spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+        # IMPORTANT: when backing up your descriptor, the order of key_1...key_4 must be correct!\n+        external = multisig.getdescriptorinfo(f\"wsh(thresh({self.N},pk({f'),s:pk('.join(external_xpubs)}),sln:after({f'),sln:after('.join(map(str, self.locktimes))})))\")\n+        internal = multisig.getdescriptorinfo(f\"wsh(thresh({self.N},pk({f'),s:pk('.join(internal_xpubs)}),sln:after({f'),sln:after('.join(map(str, self.locktimes))})))\")\n+        result = multisig.importdescriptors([\n+            {  # receiving addresses (internal: False)\n+                \"desc\": external[\"descriptor\"],\n+                \"active\": True,\n+                \"internal\": False,\n+                \"timestamp\": \"now\",\n+            },\n+            {  # change addresses (internal: True)\n+                \"desc\": internal[\"descriptor\"],\n+                \"active\": True,\n+                \"internal\": True,\n+                \"timestamp\": \"now\",\n+            },\n+        ])\n+        assert all(r[\"success\"] for r in result)\n+        return multisig\n+\n+    def run_test(self):\n+        self.node = self.nodes[0]\n+        self.M = 4  # starts as 4-of-4\n+        self.N = 4\n+\n+        self.locktimes = [104, 106, 108]  # in real-world align with future halvenings, eg: [840000, 1050000, 1260000]\n+        assert_equal(len(self.locktimes), self.N - 1)\n+\n+        self.name = f\"{self.M}_of_{self.N}_decaying_multisig\"\n+        self.log.info(f\"Testing a miniscript multisig which starts as 4-of-4 and 'decays' to 3-of-4 at block height {self.locktimes[0]}, 2-of-4 at {self.locktimes[1]}, and finally 1-of-4 at {self.locktimes[2]}...\")\n+\n+        self.log.info(\"Create the signer wallets and get their xpubs...\")\n+        signers = [self.node.get_wallet_rpc(self.node.createwallet(wallet_name=f\"signer_{i}\", descriptors=True)[\"name\"]) for i in range(self.N)]\n+        external_xpubs, internal_xpubs = [[self._get_xpub(signer, internal) for signer in signers] for internal in [False, True]]\n+\n+        self.log.info(\"Create the watch-only decaying multisig using signers' xpubs...\")\n+        multisig = self.create_multisig(external_xpubs, internal_xpubs)\n+\n+        self.log.info(\"Get a mature utxo to send to the multisig...\")\n+        coordinator_wallet = self.node.get_wallet_rpc(self.node.createwallet(wallet_name=f\"coordinator\", descriptors=True)[\"name\"])\n+        self.generatetoaddress(self.node, 101, coordinator_wallet.getnewaddress())\n+\n+        self.log.info(\"Send funds to the multisig's receiving address...\")\n+        deposit_amount = 6.15\n+        coordinator_wallet.sendtoaddress(multisig.getnewaddress(), deposit_amount)",
      "path": "test/functional/wallet_miniscript_decaying_multisig_descriptor_psbt.py",
      "position": 91,
      "original_position": 91,
      "commit_id": "aae032015367be812154a0e87955e6fd5ea5c192",
      "original_commit_id": "aae032015367be812154a0e87955e6fd5ea5c192",
      "in_reply_to_id": 1876006175,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I don't think there would be self sends from wallets point of view because in the loop the funds are transferred from the `multisig` wallet to the `signer` wallet, both of which are two different wallets with different balances as I checked.",
      "created_at": "2024-12-13T05:14:28Z",
      "updated_at": "2024-12-13T05:14:28Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29156#discussion_r1883304623",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1883304623"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29156"
        }
      },
      "start_line": 86,
      "original_start_line": 86,
      "start_side": "RIGHT",
      "line": 91,
      "original_line": 91,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1883304648",
      "pull_request_review_id": 2501317056,
      "id": 1883304648,
      "node_id": "PRRC_kwDOABII585wQPLI",
      "diff_hunk": "@@ -0,0 +1,137 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test a miniscript multisig that starts as 4-of-4 and \"decays\" to 3-of-4, 2-of-4, and finally 1-of-4 at each future halvening block height.\n+\n+Spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+This is similar to `test/functional/wallet_multisig_descriptor_psbt.py`.\n+\"\"\"\n+\n+import random\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_approx,\n+    assert_equal,\n+    assert_raises_rpc_error,\n+)\n+\n+\n+class WalletMiniscriptDecayingMultisigDescriptorPSBTTest(BitcoinTestFramework):\n+    def add_options(self, parser):\n+        self.add_wallet_options(parser, legacy=False)\n+\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+        self.wallet_names = []\n+        self.extra_args = [[\"-keypool=100\"]]\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+        self.skip_if_no_sqlite()\n+\n+    @staticmethod\n+    def _get_xpub(wallet, internal):\n+        \"\"\"Extract the wallet's xpubs using `listdescriptors` and pick the one from the `pkh` descriptor since it's least likely to be accidentally reused (legacy addresses).\"\"\"\n+        pkh_descriptor = next(filter(lambda d: d[\"desc\"].startswith(\"pkh(\") and d[\"internal\"] == internal, wallet.listdescriptors()[\"descriptors\"]))\n+        # keep all key origin information (master key fingerprint and all derivation steps) for proper support of hardware devices\n+        # see section 'Key origin identification' in 'doc/descriptors.md' for more details...\n+        return pkh_descriptor[\"desc\"].split(\"pkh(\")[1].split(\")\")[0]\n+\n+    def create_multisig(self, external_xpubs, internal_xpubs):\n+        \"\"\"The multisig is created by importing the following descriptors. The resulting wallet is watch-only and every signer can do this.\"\"\"\n+        self.node.createwallet(wallet_name=f\"{self.name}\", blank=True, descriptors=True, disable_private_keys=True)\n+        multisig = self.node.get_wallet_rpc(f\"{self.name}\")\n+        # spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+        # IMPORTANT: when backing up your descriptor, the order of key_1...key_4 must be correct!\n+        external = multisig.getdescriptorinfo(f\"wsh(thresh({self.N},pk({f'),s:pk('.join(external_xpubs)}),sln:after({f'),sln:after('.join(map(str, self.locktimes))})))\")\n+        internal = multisig.getdescriptorinfo(f\"wsh(thresh({self.N},pk({f'),s:pk('.join(internal_xpubs)}),sln:after({f'),sln:after('.join(map(str, self.locktimes))})))\")\n+        result = multisig.importdescriptors([\n+            {  # receiving addresses (internal: False)\n+                \"desc\": external[\"descriptor\"],\n+                \"active\": True,\n+                \"internal\": False,\n+                \"timestamp\": \"now\",\n+            },\n+            {  # change addresses (internal: True)\n+                \"desc\": internal[\"descriptor\"],\n+                \"active\": True,\n+                \"internal\": True,\n+                \"timestamp\": \"now\",\n+            },\n+        ])\n+        assert all(r[\"success\"] for r in result)\n+        return multisig\n+\n+    def run_test(self):\n+        self.node = self.nodes[0]\n+        self.M = 4  # starts as 4-of-4\n+        self.N = 4\n+\n+        self.locktimes = [104, 106, 108]  # in real-world align with future halvenings, eg: [840000, 1050000, 1260000]\n+        assert_equal(len(self.locktimes), self.N - 1)\n+\n+        self.name = f\"{self.M}_of_{self.N}_decaying_multisig\"\n+        self.log.info(f\"Testing a miniscript multisig which starts as 4-of-4 and 'decays' to 3-of-4 at block height {self.locktimes[0]}, 2-of-4 at {self.locktimes[1]}, and finally 1-of-4 at {self.locktimes[2]}...\")\n+\n+        self.log.info(\"Create the signer wallets and get their xpubs...\")\n+        signers = [self.node.get_wallet_rpc(self.node.createwallet(wallet_name=f\"signer_{i}\", descriptors=True)[\"name\"]) for i in range(self.N)]\n+        external_xpubs, internal_xpubs = [[self._get_xpub(signer, internal) for signer in signers] for internal in [False, True]]\n+\n+        self.log.info(\"Create the watch-only decaying multisig using signers' xpubs...\")\n+        multisig = self.create_multisig(external_xpubs, internal_xpubs)\n+\n+        self.log.info(\"Get a mature utxo to send to the multisig...\")\n+        coordinator_wallet = self.node.get_wallet_rpc(self.node.createwallet(wallet_name=f\"coordinator\", descriptors=True)[\"name\"])\n+        self.generatetoaddress(self.node, 101, coordinator_wallet.getnewaddress())\n+\n+        self.log.info(\"Send funds to the multisig's receiving address...\")\n+        deposit_amount = 6.15\n+        coordinator_wallet.sendtoaddress(multisig.getnewaddress(), deposit_amount)\n+        self.generate(self.node, 1)\n+        assert_approx(multisig.getbalance(), deposit_amount, vspan=0.001)\n+\n+        self.log.info(\"Send transactions from the multisig as required signers decay...\")\n+        sent = 0\n+        for locktime in [0] + self.locktimes:",
      "path": "test/functional/wallet_miniscript_decaying_multisig_descriptor_psbt.py",
      "position": 97,
      "original_position": 97,
      "commit_id": "aae032015367be812154a0e87955e6fd5ea5c192",
      "original_commit_id": "aae032015367be812154a0e87955e6fd5ea5c192",
      "in_reply_to_id": 1876014461,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I get it now, 0 acts a \"default/initial\" locktime.",
      "created_at": "2024-12-13T05:14:31Z",
      "updated_at": "2024-12-13T05:14:31Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29156#discussion_r1883304648",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1883304648"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29156"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 97,
      "original_line": 97,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1883304841",
      "pull_request_review_id": 2501317305,
      "id": 1883304841,
      "node_id": "PRRC_kwDOABII585wQPOJ",
      "diff_hunk": "@@ -0,0 +1,137 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test a miniscript multisig that starts as 4-of-4 and \"decays\" to 3-of-4, 2-of-4, and finally 1-of-4 at each future halvening block height.\n+\n+Spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+This is similar to `test/functional/wallet_multisig_descriptor_psbt.py`.\n+\"\"\"\n+\n+import random\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_approx,\n+    assert_equal,\n+    assert_raises_rpc_error,\n+)\n+\n+\n+class WalletMiniscriptDecayingMultisigDescriptorPSBTTest(BitcoinTestFramework):\n+    def add_options(self, parser):\n+        self.add_wallet_options(parser, legacy=False)\n+\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+        self.wallet_names = []\n+        self.extra_args = [[\"-keypool=100\"]]\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+        self.skip_if_no_sqlite()\n+\n+    @staticmethod\n+    def _get_xpub(wallet, internal):\n+        \"\"\"Extract the wallet's xpubs using `listdescriptors` and pick the one from the `pkh` descriptor since it's least likely to be accidentally reused (legacy addresses).\"\"\"\n+        pkh_descriptor = next(filter(lambda d: d[\"desc\"].startswith(\"pkh(\") and d[\"internal\"] == internal, wallet.listdescriptors()[\"descriptors\"]))\n+        # keep all key origin information (master key fingerprint and all derivation steps) for proper support of hardware devices\n+        # see section 'Key origin identification' in 'doc/descriptors.md' for more details...\n+        return pkh_descriptor[\"desc\"].split(\"pkh(\")[1].split(\")\")[0]\n+\n+    def create_multisig(self, external_xpubs, internal_xpubs):\n+        \"\"\"The multisig is created by importing the following descriptors. The resulting wallet is watch-only and every signer can do this.\"\"\"\n+        self.node.createwallet(wallet_name=f\"{self.name}\", blank=True, descriptors=True, disable_private_keys=True)\n+        multisig = self.node.get_wallet_rpc(f\"{self.name}\")\n+        # spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+        # IMPORTANT: when backing up your descriptor, the order of key_1...key_4 must be correct!\n+        external = multisig.getdescriptorinfo(f\"wsh(thresh({self.N},pk({f'),s:pk('.join(external_xpubs)}),sln:after({f'),sln:after('.join(map(str, self.locktimes))})))\")\n+        internal = multisig.getdescriptorinfo(f\"wsh(thresh({self.N},pk({f'),s:pk('.join(internal_xpubs)}),sln:after({f'),sln:after('.join(map(str, self.locktimes))})))\")\n+        result = multisig.importdescriptors([\n+            {  # receiving addresses (internal: False)\n+                \"desc\": external[\"descriptor\"],\n+                \"active\": True,\n+                \"internal\": False,\n+                \"timestamp\": \"now\",\n+            },\n+            {  # change addresses (internal: True)\n+                \"desc\": internal[\"descriptor\"],\n+                \"active\": True,\n+                \"internal\": True,\n+                \"timestamp\": \"now\",\n+            },\n+        ])\n+        assert all(r[\"success\"] for r in result)\n+        return multisig\n+\n+    def run_test(self):\n+        self.node = self.nodes[0]\n+        self.M = 4  # starts as 4-of-4\n+        self.N = 4\n+\n+        self.locktimes = [104, 106, 108]  # in real-world align with future halvenings, eg: [840000, 1050000, 1260000]\n+        assert_equal(len(self.locktimes), self.N - 1)\n+\n+        self.name = f\"{self.M}_of_{self.N}_decaying_multisig\"\n+        self.log.info(f\"Testing a miniscript multisig which starts as 4-of-4 and 'decays' to 3-of-4 at block height {self.locktimes[0]}, 2-of-4 at {self.locktimes[1]}, and finally 1-of-4 at {self.locktimes[2]}...\")\n+\n+        self.log.info(\"Create the signer wallets and get their xpubs...\")\n+        signers = [self.node.get_wallet_rpc(self.node.createwallet(wallet_name=f\"signer_{i}\", descriptors=True)[\"name\"]) for i in range(self.N)]\n+        external_xpubs, internal_xpubs = [[self._get_xpub(signer, internal) for signer in signers] for internal in [False, True]]\n+\n+        self.log.info(\"Create the watch-only decaying multisig using signers' xpubs...\")\n+        multisig = self.create_multisig(external_xpubs, internal_xpubs)\n+\n+        self.log.info(\"Get a mature utxo to send to the multisig...\")\n+        coordinator_wallet = self.node.get_wallet_rpc(self.node.createwallet(wallet_name=f\"coordinator\", descriptors=True)[\"name\"])\n+        self.generatetoaddress(self.node, 101, coordinator_wallet.getnewaddress())\n+\n+        self.log.info(\"Send funds to the multisig's receiving address...\")\n+        deposit_amount = 6.15\n+        coordinator_wallet.sendtoaddress(multisig.getnewaddress(), deposit_amount)\n+        self.generate(self.node, 1)\n+        assert_approx(multisig.getbalance(), deposit_amount, vspan=0.001)\n+\n+        self.log.info(\"Send transactions from the multisig as required signers decay...\")\n+        sent = 0\n+        for locktime in [0] + self.locktimes:\n+            self.log.info(f\"At block height >= {locktime} this multisig is {self.M}-of-{self.N}\")\n+            current_height = self.node.getblock(self.node.getbestblockhash())['height']\n+\n+            amount = 1.5\n+            receiver = signers[0]\n+\n+            # in this test each signer signs the same psbt \"in series\" one after the other.\n+            # Another option is for each signer to sign the original psbt, and then combine\n+            # and finalize these. In some cases this may be more optimal for coordination.\n+            psbt = multisig.walletcreatefundedpsbt(inputs=[], outputs={receiver.getnewaddress(): amount}, feeRate=0.00010, locktime=locktime)\n+            # the random sample asserts that any of the signing keys can sign for the 3-of-4,\n+            # 2-of-4, and 1-of-4. While this is basic behavior of the miniscript thresh primitive,\n+            # it is a critical property of this wallet.\n+            for i, m in enumerate(random.sample(range(self.M), self.M)):\n+                psbt = signers[m].walletprocesspsbt(psbt[\"psbt\"])\n+                assert_equal(psbt[\"complete\"], i == self.M - 1)\n+\n+            if self.M < self.N:\n+                self.log.info(f\"Check that the time-locked transaction is too immature to spend with {self.M}-of-{self.N} at block height {current_height}...\")\n+                assert_equal(current_height >= locktime, False)\n+                assert_raises_rpc_error(-26, \"non-final\", multisig.sendrawtransaction, psbt[\"hex\"])\n+\n+                self.log.info(f\"Generate blocks to reach the time-lock block height {locktime} and broadcast the transaction...\")\n+                self.generate(self.node, locktime - current_height)\n+            else:",
      "path": "test/functional/wallet_miniscript_decaying_multisig_descriptor_psbt.py",
      "position": 122,
      "original_position": 122,
      "commit_id": "aae032015367be812154a0e87955e6fd5ea5c192",
      "original_commit_id": "aae032015367be812154a0e87955e6fd5ea5c192",
      "in_reply_to_id": 1876017269,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I do believe it's important to check and if being done at any height less than the first locktime, then indeed all the signers are needed. I got a little thrown off by the word \"always\" in the middle because I expected a phrase like \"All the signers are required to spend before the first locktime\". ",
      "created_at": "2024-12-13T05:14:49Z",
      "updated_at": "2024-12-13T05:14:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29156#discussion_r1883304841",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1883304841"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29156"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 122,
      "original_line": 122,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1883304953",
      "pull_request_review_id": 2501317477,
      "id": 1883304953,
      "node_id": "PRRC_kwDOABII585wQPP5",
      "diff_hunk": "@@ -0,0 +1,137 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test a miniscript multisig that starts as 4-of-4 and \"decays\" to 3-of-4, 2-of-4, and finally 1-of-4 at each future halvening block height.\n+\n+Spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+This is similar to `test/functional/wallet_multisig_descriptor_psbt.py`.\n+\"\"\"\n+\n+import random\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_approx,\n+    assert_equal,\n+    assert_raises_rpc_error,\n+)\n+\n+\n+class WalletMiniscriptDecayingMultisigDescriptorPSBTTest(BitcoinTestFramework):\n+    def add_options(self, parser):\n+        self.add_wallet_options(parser, legacy=False)\n+\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+        self.wallet_names = []\n+        self.extra_args = [[\"-keypool=100\"]]\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+        self.skip_if_no_sqlite()\n+\n+    @staticmethod\n+    def _get_xpub(wallet, internal):\n+        \"\"\"Extract the wallet's xpubs using `listdescriptors` and pick the one from the `pkh` descriptor since it's least likely to be accidentally reused (legacy addresses).\"\"\"\n+        pkh_descriptor = next(filter(lambda d: d[\"desc\"].startswith(\"pkh(\") and d[\"internal\"] == internal, wallet.listdescriptors()[\"descriptors\"]))\n+        # keep all key origin information (master key fingerprint and all derivation steps) for proper support of hardware devices\n+        # see section 'Key origin identification' in 'doc/descriptors.md' for more details...\n+        return pkh_descriptor[\"desc\"].split(\"pkh(\")[1].split(\")\")[0]\n+\n+    def create_multisig(self, external_xpubs, internal_xpubs):\n+        \"\"\"The multisig is created by importing the following descriptors. The resulting wallet is watch-only and every signer can do this.\"\"\"\n+        self.node.createwallet(wallet_name=f\"{self.name}\", blank=True, descriptors=True, disable_private_keys=True)\n+        multisig = self.node.get_wallet_rpc(f\"{self.name}\")\n+        # spending policy: `thresh(4,pk(key_1),pk(key_2),pk(key_3),pk(key_4),after(t1),after(t2),after(t3))`\n+        # IMPORTANT: when backing up your descriptor, the order of key_1...key_4 must be correct!\n+        external = multisig.getdescriptorinfo(f\"wsh(thresh({self.N},pk({f'),s:pk('.join(external_xpubs)}),sln:after({f'),sln:after('.join(map(str, self.locktimes))})))\")\n+        internal = multisig.getdescriptorinfo(f\"wsh(thresh({self.N},pk({f'),s:pk('.join(internal_xpubs)}),sln:after({f'),sln:after('.join(map(str, self.locktimes))})))\")\n+        result = multisig.importdescriptors([\n+            {  # receiving addresses (internal: False)\n+                \"desc\": external[\"descriptor\"],\n+                \"active\": True,\n+                \"internal\": False,\n+                \"timestamp\": \"now\",\n+            },\n+            {  # change addresses (internal: True)\n+                \"desc\": internal[\"descriptor\"],\n+                \"active\": True,\n+                \"internal\": True,\n+                \"timestamp\": \"now\",\n+            },\n+        ])\n+        assert all(r[\"success\"] for r in result)\n+        return multisig\n+\n+    def run_test(self):\n+        self.node = self.nodes[0]\n+        self.M = 4  # starts as 4-of-4\n+        self.N = 4\n+\n+        self.locktimes = [104, 106, 108]  # in real-world align with future halvenings, eg: [840000, 1050000, 1260000]\n+        assert_equal(len(self.locktimes), self.N - 1)\n+\n+        self.name = f\"{self.M}_of_{self.N}_decaying_multisig\"\n+        self.log.info(f\"Testing a miniscript multisig which starts as 4-of-4 and 'decays' to 3-of-4 at block height {self.locktimes[0]}, 2-of-4 at {self.locktimes[1]}, and finally 1-of-4 at {self.locktimes[2]}...\")",
      "path": "test/functional/wallet_miniscript_decaying_multisig_descriptor_psbt.py",
      "position": 76,
      "original_position": 76,
      "commit_id": "aae032015367be812154a0e87955e6fd5ea5c192",
      "original_commit_id": "aae032015367be812154a0e87955e6fd5ea5c192",
      "in_reply_to_id": 1875981014,
      "user": {
        "login": "rkrux",
        "id": 5960750,
        "node_id": "MDQ6VXNlcjU5NjA3NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5960750?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rkrux",
        "html_url": "https://github.com/rkrux",
        "followers_url": "https://api.github.com/users/rkrux/followers",
        "following_url": "https://api.github.com/users/rkrux/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rkrux/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rkrux/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rkrux/subscriptions",
        "organizations_url": "https://api.github.com/users/rkrux/orgs",
        "repos_url": "https://api.github.com/users/rkrux/repos",
        "events_url": "https://api.github.com/users/rkrux/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rkrux/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Wanted to avoid hardcoding, feel free to ignore.",
      "created_at": "2024-12-13T05:15:01Z",
      "updated_at": "2024-12-13T05:15:01Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/29156#discussion_r1883304953",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1883304953"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/29156"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 76,
      "original_line": 76,
      "side": "RIGHT"
    }
  ]
}