{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160",
    "id": 1884900870,
    "node_id": "PR_kwDOABII585wWU4G",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/30160",
    "diff_url": "https://github.com/bitcoin/bitcoin/pull/30160.diff",
    "patch_url": "https://github.com/bitcoin/bitcoin/pull/30160.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30160",
    "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30160/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/47f705b33fc1381d96c99038e2110e6fe2b2f883",
    "number": 30160,
    "state": "closed",
    "locked": true,
    "maintainer_can_modify": false,
    "title": "util: add BitSet",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false,
      "patch_url": null
    },
    "body": "Extracted from #30126.\r\n\r\nThis introduces the `BitSet` data structure, inspired by `std::bitset`, but with a few features that cannot be implemented on top without efficiency loss:\r\n* Finding the first set bit (`First`)\r\n* Finding the last set bit (`Last`)\r\n* Iterating over all set bits (`begin` and `end`).\r\n\r\nAnd a few other operators/member functions that help readability for #30126:\r\n* `operator-` for set subtraction\r\n* `Overlaps()` for testing whether intersection is non-empty\r\n* `IsSupersetOf()` for testing (non-strict) supersetness\r\n* `IsSubsetOf()` for testing (non-strict) subsetness\r\n* `Fill()` to construct a set with all numbers from 0 to n-1, inclusive\r\n* `Singleton()` to construct a set with one specific element.\r\n\r\nEverything is tested through a simulation-based fuzz test that compares the behavior with normal `std::bitset` equivalent operations.\r\n",
    "labels": [
      {
        "id": 241832923,
        "node_id": "MDU6TGFiZWwyNDE4MzI5MjM=",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Utils/log/libs",
        "name": "Utils/log/libs",
        "description": "",
        "color": "5319e7",
        "default": false
      }
    ],
    "created_at": "2024-05-23T15:42:28Z",
    "updated_at": "2025-07-14T11:39:29Z",
    "closed_at": "2024-06-11T21:29:00Z",
    "mergeable_state": "unknown",
    "merged": true,
    "merged_at": "2024-06-11T21:29:00Z",
    "merged_by": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false,
      "patch_url": null
    },
    "merge_commit_sha": "91e0beede2859dea987ba6db746e95dca0ceb024",
    "assignees": [],
    "requested_reviewers": [
      {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    ],
    "requested_teams": [],
    "head": {
      "label": "sipa:202405_bitset",
      "ref": "202405_bitset",
      "sha": "47f705b33fc1381d96c99038e2110e6fe2b2f883",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "repo": {
        "id": 1458655,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNDU4NjU1",
        "name": "bitcoin",
        "full_name": "sipa/bitcoin",
        "owner": {
          "login": "sipa",
          "id": 548488,
          "node_id": "MDQ6VXNlcjU0ODQ4OA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/sipa",
          "html_url": "https://github.com/sipa",
          "followers_url": "https://api.github.com/users/sipa/followers",
          "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
          "organizations_url": "https://api.github.com/users/sipa/orgs",
          "repos_url": "https://api.github.com/users/sipa/repos",
          "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/sipa/received_events",
          "type": "User",
          "site_admin": false,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/sipa/bitcoin",
        "description": "Bitcoin integration/staging tree",
        "fork": true,
        "url": "https://api.github.com/repos/sipa/bitcoin",
        "archive_url": "https://api.github.com/repos/sipa/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/sipa/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/sipa/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/sipa/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/sipa/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/sipa/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/sipa/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/sipa/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/sipa/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/sipa/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/sipa/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/sipa/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/sipa/bitcoin/events",
        "forks_url": "https://api.github.com/repos/sipa/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/sipa/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/sipa/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/sipa/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/sipa/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/sipa/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/sipa/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/sipa/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/sipa/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/sipa/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/sipa/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/sipa/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/sipa/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/sipa/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/sipa/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/sipa/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:sipa/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/sipa/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/sipa/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/sipa/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/sipa/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/sipa/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/sipa/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/sipa/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/sipa/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/sipa/bitcoin/hooks",
        "svn_url": "https://github.com/sipa/bitcoin",
        "homepage": "http://www.bitcoin.org",
        "language": "TypeScript",
        "forks_count": 20,
        "stargazers_count": 90,
        "watchers_count": 90,
        "size": 269314,
        "default_branch": "lows",
        "open_issues_count": 16,
        "is_template": false,
        "topics": [],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2025-07-13T19:11:02Z",
        "created_at": "2011-03-09T10:46:59Z",
        "updated_at": "2025-02-27T11:11:39Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "cad127235e307d7de0e9cc04708dbd31aa6c24b0",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false,
        "patch_url": null
      },
      "repo": {
        "id": 1181927,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTgxOTI3",
        "name": "bitcoin",
        "full_name": "bitcoin/bitcoin",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bitcoin",
        "archive_url": "https://api.github.com/repos/bitcoin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bitcoin/hooks",
        "svn_url": "https://github.com/bitcoin/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 37514,
        "stargazers_count": 84551,
        "watchers_count": 84551,
        "size": 289117,
        "default_branch": "master",
        "open_issues_count": 750,
        "is_template": false,
        "topics": [
          "bitcoin",
          "c-plus-plus",
          "cryptocurrency",
          "cryptography",
          "p2p"
        ],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2025-07-14T10:47:00Z",
        "created_at": "2010-12-19T15:16:43Z",
        "updated_at": "2025-07-14T11:40:47Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
      }
    },
    "author_association": "MEMBER",
    "draft": false,
    "additions": 846,
    "deletions": 0,
    "changed_files": 5,
    "commits": 2,
    "review_comments": 50,
    "comments": 8
  },
  "events": [
    {
      "event": "commented",
      "id": 2127454745,
      "node_id": "IC_kwDOABII585-zmIZ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2127454745",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-23T15:42:31Z",
      "updated_at": "2024-06-11T21:18:23Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage\nFor detailed information about the code coverage, see the [test coverage report](https://corecheck.dev/bitcoin/bitcoin/pulls/30160).\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| ACK | [instagibbs](https://github.com/bitcoin/bitcoin/pull/30160#issuecomment-2158379951), [cbergqvist](https://github.com/bitcoin/bitcoin/pull/30160#pullrequestreview-2107852785), [theStack](https://github.com/bitcoin/bitcoin/pull/30160#pullrequestreview-2108226640), [achow101](https://github.com/bitcoin/bitcoin/pull/30160#issuecomment-2161613165) |\n| Concept ACK | [hebasto](https://github.com/bitcoin/bitcoin/pull/30160#issuecomment-2147744433) |\n\nIf your review is incorrectly listed, please react with 👎 to this comment and the bot will ignore it on the next update.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#30126](https://github.com/bitcoin/bitcoin/pull/30126) (Low-level cluster linearization code by sipa)\n* [#29625](https://github.com/bitcoin/bitcoin/pull/29625) (Several randomness improvements by sipa)\n* [#28676](https://github.com/bitcoin/bitcoin/pull/28676) ([WIP] Cluster mempool implementation by sdaftuar)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#issuecomment-2127454745",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30160"
    },
    {
      "event": "labeled",
      "id": 12911543348,
      "node_id": "LE_lADOABII586J4VcvzwAAAAMBloQ0",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12911543348",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-23T15:42:33Z",
      "label": {
        "name": "Utils/log/libs",
        "color": "5319e7"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12913402292,
      "node_id": "HRFPE_lADOABII586J4VcvzwAAAAMBsuG0",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12913402292",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "0505f4f495dfcb3afa856edb428c70e87bb6804c",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/0505f4f495dfcb3afa856edb428c70e87bb6804c",
      "created_at": "2024-05-23T17:55:56Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12913691028,
      "node_id": "HRFPE_lADOABII586J4VcvzwAAAAMBt0mU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12913691028",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "aeef8a4dcf982cb76bca9571871196c4b25a1bdd",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/aeef8a4dcf982cb76bca9571871196c4b25a1bdd",
      "created_at": "2024-05-23T18:23:57Z"
    },
    {
      "event": "reviewed",
      "id": 2074881667,
      "node_id": "PRR_kwDOABII5857rC6D",
      "url": null,
      "actor": null,
      "commit_id": "a12b4052dad2158cf21de07fded63fb224dba915",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#pullrequestreview-2074881667",
      "submitted_at": "2024-05-23T19:55:17Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
    },
    {
      "event": "reviewed",
      "id": 2074894349,
      "node_id": "PRR_kwDOABII5857rGAN",
      "url": null,
      "actor": null,
      "commit_id": "a12b4052dad2158cf21de07fded63fb224dba915",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#pullrequestreview-2074894349",
      "submitted_at": "2024-05-23T20:03:01Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12925383411,
      "node_id": "HRFPE_lADOABII586J4VcvzwAAAAMCabLz",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12925383411",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "d598c71c54e2398ec36a1a629e9e4350a5856113",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/d598c71c54e2398ec36a1a629e9e4350a5856113",
      "created_at": "2024-05-24T13:48:25Z"
    },
    {
      "event": "reviewed",
      "id": 2077061355,
      "node_id": "PRR_kwDOABII5857zXDr",
      "url": null,
      "actor": null,
      "commit_id": "797ea9aca05a6dafb70e224e6a7d89bb18294150",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#pullrequestreview-2077061355",
      "submitted_at": "2024-05-24T14:17:56Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12926722640,
      "node_id": "HRFPE_lADOABII586J4VcvzwAAAAMCfiJQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12926722640",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "692e533f0b698960c0fd87b47706f7542d467f5f",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/692e533f0b698960c0fd87b47706f7542d467f5f",
      "created_at": "2024-05-24T15:35:39Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12934056317,
      "node_id": "HRFPE_lADOABII586J4VcvzwAAAAMC7gl9",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12934056317",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "3bc131a85ce826aa171f0328c014ea51b8740fed",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/3bc131a85ce826aa171f0328c014ea51b8740fed",
      "created_at": "2024-05-25T22:07:52Z"
    },
    {
      "event": "labeled",
      "id": 12945169502,
      "node_id": "LE_lADOABII586J4VcvzwAAAAMDl5xe",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12945169502",
      "actor": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-27T12:09:59Z",
      "label": {
        "name": "Needs CMake port",
        "color": "0e8a16"
      }
    },
    {
      "event": "reviewed",
      "id": 2076257466,
      "node_id": "PRR_kwDOABII5857wSy6",
      "url": null,
      "actor": null,
      "commit_id": "3bc131a85ce826aa171f0328c014ea51b8740fed",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Looked at 3bc131a85ce826aa171f0328c014ea51b8740fed\r\n\r\nConcept: Bummer that `std::countr_zero` and `std::countl_zero` aren't implemented for `std::bitset`. And for iterating it seems like one would be using `std::vector<bool>` and hoping for the best in terms of implementation. So makes sense to introduce `BitSet`.\r\n\r\nSummary still mentions `operator/` instead of `operator-`.\r\n\r\n(Fuzz-code is too new to me to comment).",
      "user": {
        "login": "cbergqvist",
        "id": 581308,
        "node_id": "MDQ6VXNlcjU4MTMwOA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/581308?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/cbergqvist",
        "html_url": "https://github.com/cbergqvist",
        "followers_url": "https://api.github.com/users/cbergqvist/followers",
        "following_url": "https://api.github.com/users/cbergqvist/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/cbergqvist/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/cbergqvist/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/cbergqvist/subscriptions",
        "organizations_url": "https://api.github.com/users/cbergqvist/orgs",
        "repos_url": "https://api.github.com/users/cbergqvist/repos",
        "events_url": "https://api.github.com/users/cbergqvist/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/cbergqvist/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#pullrequestreview-2076257466",
      "submitted_at": "2024-05-28T11:52:13Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
    },
    {
      "event": "reviewed",
      "id": 2082445138,
      "node_id": "PRR_kwDOABII5858H5dS",
      "url": null,
      "actor": null,
      "commit_id": "3bc131a85ce826aa171f0328c014ea51b8740fed",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Concept ACK",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#pullrequestreview-2082445138",
      "submitted_at": "2024-05-28T12:20:47Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12957008979,
      "node_id": "HRFPE_lADOABII586J4VcvzwAAAAMETERT",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12957008979",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "f03f3fe27dfcaf5e3fe4744a5c85e68a1480c893",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/f03f3fe27dfcaf5e3fe4744a5c85e68a1480c893",
      "created_at": "2024-05-28T12:39:15Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12973968539,
      "node_id": "HRFPE_lADOABII586J4VcvzwAAAAMFTwyb",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12973968539",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "18ec3fc0bde855d777ba702f0a0a5d5a4d323cba",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/18ec3fc0bde855d777ba702f0a0a5d5a4d323cba",
      "created_at": "2024-05-29T15:44:58Z"
    },
    {
      "event": "commented",
      "id": 2137732304,
      "node_id": "IC_kwDOABII585_azTQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2137732304",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-29T15:46:03Z",
      "updated_at": "2024-05-29T15:46:03Z",
      "author_association": "MEMBER",
      "body": "Added additional `Assume()`s to prevent `operator++` on iterators past the end:\r\n\r\n```diff\r\n--- a/src/util/bitset.h\r\n+++ b/src/util/bitset.h\r\n@@ -101,6 +101,7 @@ class IntBitSet\r\n         /** Progress to the next 1 bit (only if != IteratorEnd). */\r\n         constexpr Iterator& operator++() noexcept\r\n         {\r\n+            Assume(m_val != 0);\r\n             m_val &= m_val - I{1U};\r\n             if (m_val != 0) m_pos = std::countr_zero(m_val);\r\n             return *this;\r\n@@ -272,6 +273,7 @@ class MultiIntBitSet\r\n         /** Progress to the next 1 bit (only if != IteratorEnd). */\r\n         constexpr Iterator& operator++() noexcept\r\n         {\r\n+            Assume(m_idx < N);\r\n             m_val &= m_val - I{1U};\r\n             if (m_val == 0) {\r\n                 while (true) {\r\n```",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#issuecomment-2137732304",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30160"
    },
    {
      "event": "reviewed",
      "id": 2088636268,
      "node_id": "PRR_kwDOABII5858fg9s",
      "url": null,
      "actor": null,
      "commit_id": "18ec3fc0bde855d777ba702f0a0a5d5a4d323cba",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#pullrequestreview-2088636268",
      "submitted_at": "2024-06-03T20:41:37Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
    },
    {
      "event": "reviewed",
      "id": 2096649215,
      "node_id": "PRR_kwDOABII5858-FP_",
      "url": null,
      "actor": null,
      "commit_id": "18ec3fc0bde855d777ba702f0a0a5d5a4d323cba",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#pullrequestreview-2096649215",
      "submitted_at": "2024-06-04T14:49:18Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
    },
    {
      "event": "commented",
      "id": 2147744433,
      "node_id": "IC_kwDOABII586AA_qx",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2147744433",
      "actor": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-04T14:54:00Z",
      "updated_at": "2024-06-04T14:54:00Z",
      "author_association": "MEMBER",
      "body": "Concept ACK.",
      "user": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#issuecomment-2147744433",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30160"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13038752534,
      "node_id": "HRFPE_lADOABII586J4VcvzwAAAAMJK5MW",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13038752534",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "c99063e902c810dde1742696b3140610120d391c",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/c99063e902c810dde1742696b3140610120d391c",
      "created_at": "2024-06-04T15:56:48Z"
    },
    {
      "event": "commented",
      "id": 2148037183,
      "node_id": "IC_kwDOABII586ACHI_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2148037183",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-04T17:19:38Z",
      "updated_at": "2024-06-04T17:19:38Z",
      "author_association": "MEMBER",
      "body": "concept ACK\r\n\r\nrequested changes were included, will continue review\r\n\r\n`git range-diff master 18ec3fc c99063e`",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#issuecomment-2148037183",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30160"
    },
    {
      "event": "reviewed",
      "id": 2103029469,
      "node_id": "PRR_kwDOABII5859Wa7d",
      "url": null,
      "actor": null,
      "commit_id": "c99063e902c810dde1742696b3140610120d391c",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "ACK c99063e902c810dde1742696b3140610120d391c\r\n\r\n(Ran `git range-diff 3bc131a~2..3bc131a c99063e~2..c99063e`).",
      "user": {
        "login": "cbergqvist",
        "id": 581308,
        "node_id": "MDQ6VXNlcjU4MTMwOA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/581308?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/cbergqvist",
        "html_url": "https://github.com/cbergqvist",
        "followers_url": "https://api.github.com/users/cbergqvist/followers",
        "following_url": "https://api.github.com/users/cbergqvist/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/cbergqvist/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/cbergqvist/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/cbergqvist/subscriptions",
        "organizations_url": "https://api.github.com/users/cbergqvist/orgs",
        "repos_url": "https://api.github.com/users/cbergqvist/repos",
        "events_url": "https://api.github.com/users/cbergqvist/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/cbergqvist/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#pullrequestreview-2103029469",
      "submitted_at": "2024-06-06T19:29:26Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
    },
    {
      "event": "review_requested",
      "id": 13071383541,
      "node_id": "RRE_lADOABII586J4VcvzwAAAAMLHXv1",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13071383541",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-06T19:29:29Z",
      "requested_reviewer": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "review_requested",
      "id": 13071383668,
      "node_id": "RRE_lADOABII586J4VcvzwAAAAMLHXx0",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13071383668",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-06T19:29:30Z",
      "requested_reviewer": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "review_requested",
      "id": 13071383798,
      "node_id": "RRE_lADOABII586J4VcvzwAAAAMLHXz2",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13071383798",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-06T19:29:30Z",
      "requested_reviewer": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "reviewed",
      "id": 2104783238,
      "node_id": "PRR_kwDOABII5859dHGG",
      "url": null,
      "actor": null,
      "commit_id": "c99063e902c810dde1742696b3140610120d391c",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "c99063e902c810dde1742696b3140610120d391c seems to need `swap` fuzz coverage\r\n\r\nrest of comments are nits\r\n\r\n",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#pullrequestreview-2104783238",
      "submitted_at": "2024-06-07T16:07:37Z",
      "state": "CHANGES_REQUESTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
    },
    {
      "event": "review_requested",
      "id": 13083012605,
      "node_id": "RRE_lADOABII586J4VcvzwAAAAMLzu39",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13083012605",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-07T16:07:40Z",
      "requested_reviewer": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13083603593,
      "node_id": "HRFPE_lADOABII586J4VcvzwAAAAML1_KJ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13083603593",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "a135ab970e8d9e0c86fd9fca682a04b19dd9c3c9",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/a135ab970e8d9e0c86fd9fca682a04b19dd9c3c9",
      "created_at": "2024-06-07T17:13:15Z"
    },
    {
      "event": "reviewed",
      "id": 2106417903,
      "node_id": "PRR_kwDOABII5859jWLv",
      "url": null,
      "actor": null,
      "commit_id": "a135ab970e8d9e0c86fd9fca682a04b19dd9c3c9",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Reviewed 1e08ba37e7b5d9b083c938d90526f8fabbe1c799 so far, the code looks correct to me. Planning to review and run the fuzz test tomorrow.",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#pullrequestreview-2106417903",
      "submitted_at": "2024-06-10T00:15:07Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDU5YTZkZjZiZDU4NDcwMWY4MjBhZDYwYTEwZDlkNDc3YmYwMjM2YjU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/59a6df6bd584701f820ad60a10d9d477bf0236b5",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/59a6df6bd584701f820ad60a10d9d477bf0236b5",
      "tree": {
        "sha": "17699b43e3a5c5874bea7c291f2a6dc7b9f272ba",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/17699b43e3a5c5874bea7c291f2a6dc7b9f272ba"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/cad127235e307d7de0e9cc04708dbd31aa6c24b0",
          "sha": "cad127235e307d7de0e9cc04708dbd31aa6c24b0",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/cad127235e307d7de0e9cc04708dbd31aa6c24b0"
        }
      ],
      "message": "util: add BitSet\n\nThis adds a bitset module that implements a BitSet<N> class, a variant\nof std::bitset with a few additional features that cannot be implemented\nin a wrapper without performance loss (specifically, finding first and\nlast bit set, or iterating over all set bits).",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-06-10T11:54:48Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-01-22T00:20:06Z"
      },
      "sha": "59a6df6bd584701f820ad60a10d9d477bf0236b5"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDQ3ZjcwNWIzM2ZjMTM4MWQ5NmM5OTAzOGUyMTEwZTZmZTJiMmY4ODM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/47f705b33fc1381d96c99038e2110e6fe2b2f883",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/47f705b33fc1381d96c99038e2110e6fe2b2f883",
      "tree": {
        "sha": "762f1c1d060c039efdfb6b3928c668f1a3e945a1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/762f1c1d060c039efdfb6b3928c668f1a3e945a1"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/59a6df6bd584701f820ad60a10d9d477bf0236b5",
          "sha": "59a6df6bd584701f820ad60a10d9d477bf0236b5",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/59a6df6bd584701f820ad60a10d9d477bf0236b5"
        }
      ],
      "message": "tests: add fuzz tests for BitSet",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-06-10T11:54:48Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-05-23T15:32:05Z"
      },
      "sha": "47f705b33fc1381d96c99038e2110e6fe2b2f883"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13100227702,
      "node_id": "HRFPE_lADOABII586J4VcvzwAAAAMM1Zx2",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13100227702",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "47f705b33fc1381d96c99038e2110e6fe2b2f883",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/47f705b33fc1381d96c99038e2110e6fe2b2f883",
      "created_at": "2024-06-10T11:55:01Z"
    },
    {
      "event": "commented",
      "id": 2158146838,
      "node_id": "IC_kwDOABII586AorUW",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2158146838",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-10T11:56:02Z",
      "updated_at": "2024-06-10T11:56:02Z",
      "author_association": "MEMBER",
      "body": "Made a few small changes still:\r\n\r\n```diff\r\n@@ -107,7 +107,11 @@ class IntBitSet\r\n             return *this;\r\n         }\r\n         /** Get the current bit position (only if != IteratorEnd). */\r\n-        constexpr const unsigned& operator*() const noexcept { return m_pos; }\r\n+        constexpr unsigned operator*() const noexcept\r\n+        {\r\n+            Assume(m_val != 0);\r\n+            return m_pos;\r\n+        }\r\n     };\r\n \r\n public:\r\n@@ -231,6 +235,8 @@ class MultiIntBitSet\r\n     static constexpr unsigned LIMB_BITS = std::numeric_limits<I>::digits;\r\n     /** Number of elements this set type supports. */\r\n     static constexpr unsigned MAX_SIZE = LIMB_BITS * N;\r\n+    // No overflow allowed here.\r\n+    static_assert(MAX_SIZE / LIMB_BITS == N);\r\n     /** Array whose member integers store the bits of the set. */\r\n     std::array<I, N> m_val;\r\n     /** Dummy type to return using end(). Only used for comparing with Iterator. */\r\n@@ -293,7 +299,11 @@ class MultiIntBitSet\r\n             return *this;\r\n         }\r\n         /** Get the current bit position (only if != IteratorEnd). */\r\n-        constexpr const unsigned& operator*() const noexcept { return m_pos; }\r\n+        constexpr unsigned operator*() const noexcept\r\n+        {\r\n+            Assume(m_idx < N);\r\n+            return m_pos;\r\n+        }\r\n     };\r\n \r\n public:\r\n```",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#issuecomment-2158146838",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30160"
    },
    {
      "event": "commented",
      "id": 2158379951,
      "node_id": "IC_kwDOABII586ApkOv",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2158379951",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-10T13:26:22Z",
      "updated_at": "2024-06-10T13:26:22Z",
      "author_association": "MEMBER",
      "body": "ACK https://github.com/bitcoin/bitcoin/pull/30160/commits/47f705b33fc1381d96c99038e2110e6fe2b2f883\r\n\r\nswap coverage added, some of the nits taken, and a couple `Assume()`s added\r\n\r\nreviewed via `git range-diff master c99063e 47f705b`",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#issuecomment-2158379951",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30160"
    },
    {
      "event": "review_requested",
      "id": 13101568025,
      "node_id": "RRE_lADOABII586J4VcvzwAAAAMM6hAZ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13101568025",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-10T13:26:27Z",
      "requested_reviewer": {
        "login": "cbergqvist",
        "id": 581308,
        "node_id": "MDQ6VXNlcjU4MTMwOA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/581308?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/cbergqvist",
        "html_url": "https://github.com/cbergqvist",
        "followers_url": "https://api.github.com/users/cbergqvist/followers",
        "following_url": "https://api.github.com/users/cbergqvist/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/cbergqvist/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/cbergqvist/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/cbergqvist/subscriptions",
        "organizations_url": "https://api.github.com/users/cbergqvist/orgs",
        "repos_url": "https://api.github.com/users/cbergqvist/repos",
        "events_url": "https://api.github.com/users/cbergqvist/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/cbergqvist/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "review_requested",
      "id": 13101568314,
      "node_id": "RRE_lADOABII586J4VcvzwAAAAMM6hE6",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13101568314",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-10T13:26:28Z",
      "requested_reviewer": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "reviewed",
      "id": 2107852785,
      "node_id": "PRR_kwDOABII5859o0fx",
      "url": null,
      "actor": null,
      "commit_id": "47f705b33fc1381d96c99038e2110e6fe2b2f883",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "re-ACK 47f705b33fc1381d96c99038e2110e6fe2b2f883\r\n\r\nUsed same range-diff as instagibbs.",
      "user": {
        "login": "cbergqvist",
        "id": 581308,
        "node_id": "MDQ6VXNlcjU4MTMwOA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/581308?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/cbergqvist",
        "html_url": "https://github.com/cbergqvist",
        "followers_url": "https://api.github.com/users/cbergqvist/followers",
        "following_url": "https://api.github.com/users/cbergqvist/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/cbergqvist/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/cbergqvist/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/cbergqvist/subscriptions",
        "organizations_url": "https://api.github.com/users/cbergqvist/orgs",
        "repos_url": "https://api.github.com/users/cbergqvist/repos",
        "events_url": "https://api.github.com/users/cbergqvist/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/cbergqvist/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#pullrequestreview-2107852785",
      "submitted_at": "2024-06-10T13:44:34Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
    },
    {
      "event": "reviewed",
      "id": 2108226640,
      "node_id": "PRR_kwDOABII5859qPxQ",
      "url": null,
      "actor": null,
      "commit_id": "47f705b33fc1381d96c99038e2110e6fe2b2f883",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Code-review ACK 47f705b33fc1381d96c99038e2110e6fe2b2f883",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#pullrequestreview-2108226640",
      "submitted_at": "2024-06-10T16:12:26Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
    },
    {
      "event": "commented",
      "id": 2161613165,
      "node_id": "IC_kwDOABII586A15lt",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2161613165",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-11T21:18:20Z",
      "updated_at": "2024-06-11T21:18:20Z",
      "author_association": "MEMBER",
      "body": "ACK 47f705b33fc1381d96c99038e2110e6fe2b2f883",
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#issuecomment-2161613165",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30160"
    },
    {
      "event": "merged",
      "id": 13122953935,
      "node_id": "ME_lADOABII586J4VcvzwAAAAMOMGLP",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13122953935",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "91e0beede2859dea987ba6db746e95dca0ceb024",
      "commit_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/91e0beede2859dea987ba6db746e95dca0ceb024",
      "created_at": "2024-06-11T21:29:00Z"
    },
    {
      "event": "closed",
      "id": 13122953958,
      "node_id": "CE_lADOABII586J4VcvzwAAAAMOMGLm",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13122953958",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-11T21:29:00Z"
    },
    {
      "event": "commented",
      "id": 2227217787,
      "node_id": "IC_kwDOABII586EwKV7",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2227217787",
      "actor": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-14T06:55:02Z",
      "updated_at": "2024-07-14T06:55:02Z",
      "author_association": "MEMBER",
      "body": "Ported to the CMake-based build system in https://github.com/hebasto/bitcoin/pull/264.",
      "user": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#issuecomment-2227217787",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30160"
    },
    {
      "event": "unlabeled",
      "id": 13497153383,
      "node_id": "UNLE_lADOABII586J4VcvzwAAAAMkfjdn",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13497153383",
      "actor": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-14T06:55:09Z",
      "label": {
        "name": "Needs CMake port",
        "color": "0e8a16"
      }
    },
    {
      "event": "locked",
      "id": 18616262161,
      "node_id": "LOE_lADOABII586J4VcvzwAAAARVnZ4R",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18616262161",
      "actor": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-14T11:39:29Z"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1612232560",
      "pull_request_review_id": 2074881667,
      "id": 1612232560,
      "node_id": "PRRC_kwDOABII585gGLdw",
      "diff_hunk": "@@ -0,0 +1,463 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a / b) implements \"a and not b\".\n+ * - Efficient subset/superset testing: (a <= b) and (a >= b).\n+ * - Efficient set overlap testing: a && b\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept {\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept {\n+        IntBitSet ret;\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept { m_val |= I{1U} << pos; }",
      "path": "src/util/bitset.h",
      "position": null,
      "original_position": 144,
      "commit_id": "47f705b33fc1381d96c99038e2110e6fe2b2f883",
      "original_commit_id": "a12b4052dad2158cf21de07fded63fb224dba915",
      "in_reply_to_id": null,
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "`std::bitset` throws for these if pos is out of range.\r\n\r\nMaybe add `Assume()`s? Or were you trying to keep the header self-contained?",
      "created_at": "2024-05-23T19:55:17Z",
      "updated_at": "2024-05-23T19:55:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1612232560",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1612232560"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 144,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1612240218",
      "pull_request_review_id": 2074894349,
      "id": 1612240218,
      "node_id": "PRRC_kwDOABII585gGNVa",
      "diff_hunk": "@@ -0,0 +1,463 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a / b) implements \"a and not b\".\n+ * - Efficient subset/superset testing: (a <= b) and (a >= b).\n+ * - Efficient set overlap testing: a && b\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept {\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept {\n+        IntBitSet ret;\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept { m_val |= I{1U} << pos; }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept { m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos); }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept { m_val &= ~I(I{1U} << pos); }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept { return (m_val >> pos) & 1U; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept { return std::countr_zero(m_val); }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept { return std::bit_width(m_val) - 1; }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator/=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    friend constexpr bool operator&&(const IntBitSet& a, const IntBitSet& b) noexcept { return a.m_val & b.m_val; }",
      "path": "src/util/bitset.h",
      "position": null,
      "original_position": 172,
      "commit_id": "47f705b33fc1381d96c99038e2110e6fe2b2f883",
      "original_commit_id": "a12b4052dad2158cf21de07fded63fb224dba915",
      "in_reply_to_id": null,
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I know you like dense code, but...\r\n\r\nI suspect function names would make reviewing uses of this easier than operators. Especially for the non-obvious ones like `&&` that `std::bitset` doesn't support.\r\n\r\nI know that personally I'd have an easier time reviewing `a.intersects(b)`.",
      "created_at": "2024-05-23T20:03:01Z",
      "updated_at": "2024-05-23T20:03:01Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1612240218",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1612240218"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 172,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613105680",
      "pull_request_review_id": 2076257466,
      "id": 1613105680,
      "node_id": "PRRC_kwDOABII585gJgoQ",
      "diff_hunk": "@@ -0,0 +1,463 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a / b) implements \"a and not b\".\n+ * - Efficient subset/superset testing: (a <= b) and (a >= b).\n+ * - Efficient set overlap testing: a && b\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept {\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept {\n+        IntBitSet ret;\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept { m_val |= I{1U} << pos; }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept { m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos); }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept { m_val &= ~I(I{1U} << pos); }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept { return (m_val >> pos) & 1U; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept { return std::countr_zero(m_val); }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept { return std::bit_width(m_val) - 1; }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator/=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    friend constexpr bool operator&&(const IntBitSet& a, const IntBitSet& b) noexcept { return a.m_val & b.m_val; }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr IntBitSet operator&(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & b.m_val); }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator|(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val | b.m_val); }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr IntBitSet operator/(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & ~b.m_val); }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator^(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val ^ b.m_val); }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const IntBitSet& a, const IntBitSet& b) noexcept = default;\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    friend constexpr bool operator>=(const IntBitSet& a, const IntBitSet& b) noexcept { return (b.m_val & ~a.m_val) == 0; }\n+    /** Check if bitset a is a subset of bitset b (= every 1 bit in a is also in b). */\n+    friend constexpr bool operator<=(const IntBitSet& a, const IntBitSet& b) noexcept { return (a.m_val & ~b.m_val) == 0; }\n+    /** Swap two bitsets. */\n+    friend constexpr void swap(IntBitSet& a, IntBitSet& b) noexcept { std::swap(a.m_val, b.m_val); }\n+};\n+\n+/** A bitset implementation backed by N integers of type I. */\n+template<typename I, unsigned N>\n+class MultiIntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The number of bits per integer. */\n+    static constexpr unsigned LIMB_BITS = std::numeric_limits<I>::digits;\n+    /** Number of elements this set type supports. */\n+    static constexpr unsigned MAX_SIZE = LIMB_BITS * N;\n+    /** Array whose member integers store the bits of the set. */\n+    std::array<I, N> m_val;\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class MultiIntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class MultiIntBitSet;\n+        const std::array<I, N>* m_ptr; /**< Pointer to array to fetch bits from. */\n+        I m_val; /**< The remaining bits of (*m_ptr)[m_idx]. */\n+        unsigned m_pos; /**< The last reported position. */\n+        unsigned m_idx; /**< The index in *m_ptr currently being iterated over. */\n+        constexpr Iterator(const std::array<I, N>* ptr) noexcept : m_ptr(ptr), m_idx(0)\n+        {\n+            do {\n+                m_val = (*m_ptr)[m_idx];\n+                if (m_val) {\n+                    m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                    break;\n+                }\n+                ++m_idx;\n+            } while(m_idx < N);\n+        }\n+\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        friend constexpr bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_idx == N;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val == 0) {\n+                while (true) {\n+                    ++m_idx;\n+                    if (m_idx == N) break;\n+                    m_val = (*m_ptr)[m_idx];\n+                    if (m_val) {\n+                        m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                        break;\n+                    }\n+                }\n+            } else {\n+                m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+            }\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr MultiIntBitSet() noexcept : m_val{} {}\n+    /** Copy construct a bitset. */\n+    constexpr MultiIntBitSet(const MultiIntBitSet&) noexcept = default;\n+    /** Copy assign a bitset. */\n+    constexpr MultiIntBitSet& operator=(const MultiIntBitSet&) noexcept = default;\n+    /** Set a bit to 1. */\n+    void constexpr Set(unsigned pos) noexcept { m_val[pos / LIMB_BITS] |= I{1U} << (pos % LIMB_BITS); }\n+    /** Set a bit to the specified value. */\n+    void constexpr Set(unsigned pos, bool val) noexcept { m_val[pos / LIMB_BITS] = (m_val[pos / LIMB_BITS] & ~I(I{1U} << (pos % LIMB_BITS))) | (I{val} << (pos % LIMB_BITS)); }\n+    /** Construct a bitset from a list of values. */\n+    constexpr MultiIntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val{}\n+    {\n+        for (auto i : ilist) Set(i);\n+    }\n+    /** Set a bitset to a list of values. */\n+    constexpr MultiIntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val.fill(0);\n+        for (auto i : ilist) Set(i);\n+        return *this;\n+    }\n+    /** Set a bit to 0. */\n+    void constexpr Reset(unsigned pos) noexcept { m_val[pos / LIMB_BITS] &= ~I(I{1U} << (pos % LIMB_BITS)); }\n+    /** Retrieve a bit at the given position. */\n+    bool constexpr operator[](unsigned pos) const noexcept { return (m_val[pos / LIMB_BITS] >> (pos % LIMB_BITS)) & 1U; }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr MultiIntBitSet Singleton(unsigned i) noexcept\n+    {\n+        MultiIntBitSet ret;\n+        ret.m_val[i / LIMB_BITS] = I{1U} << (i % LIMB_BITS);\n+        return ret;\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr MultiIntBitSet Fill(unsigned count) noexcept\n+    {\n+        MultiIntBitSet ret;\n+        if (count) {\n+            unsigned i = 0;\n+            while (count > LIMB_BITS) {\n+                ret.m_val[i++] = ~I{0};\n+                count -= LIMB_BITS;\n+            }\n+            ret.m_val[i] = I(~I{0}) >> (LIMB_BITS - count);\n+        }\n+        return ret;\n+    }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Compute the number of 1 bits in the bitset. */\n+    unsigned constexpr Count() const noexcept\n+    {\n+        unsigned ret{0};\n+        for (I v : m_val) ret += PopCount(v);\n+        return ret;\n+    }\n+    /** Check if all bits are 0. */\n+    bool constexpr None() const noexcept\n+    {\n+        for (auto v : m_val) {\n+            if (v != 0) return false;\n+        }\n+        return true;\n+    }\n+    /** Check if any bits are 1. */\n+    bool constexpr Any() const noexcept\n+    {\n+        for (auto v : m_val) {\n+            if (v != 0) return true;\n+        }\n+        return false;\n+    }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    Iterator constexpr begin() const noexcept { return Iterator(&m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    IteratorEnd constexpr end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    unsigned constexpr First() const noexcept\n+    {\n+        unsigned p = 0;\n+        while (m_val[p] == 0) ++p;\n+        return std::countr_zero(m_val[p]) + p * LIMB_BITS;\n+    }\n+    /** Find the last element (requires Any()). */\n+    unsigned constexpr Last() const noexcept\n+    {\n+        unsigned p = N - 1;\n+        while (m_val[p] == 0) --p;\n+        return std::bit_width(m_val[p]) - 1 + p * LIMB_BITS;\n+    }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr MultiIntBitSet& operator|=(const MultiIntBitSet& a) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            m_val[i] |= a.m_val[i];\n+        }\n+        return *this;\n+    }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr MultiIntBitSet& operator&=(const MultiIntBitSet& a) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            m_val[i] &= a.m_val[i];\n+        }\n+        return *this;\n+    }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr MultiIntBitSet& operator/=(const MultiIntBitSet& a) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            m_val[i] &= ~a.m_val[i];\n+        }\n+        return *this;\n+    }\n+    /** Set this object's bits to be the binary XOR between respective bits from this and a. */\n+    constexpr MultiIntBitSet& operator^=(const MultiIntBitSet& a) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            m_val[i] ^= a.m_val[i];\n+        }\n+        return *this;\n+    }\n+    /** Check whether the intersection between two sets is non-empty. */\n+    friend constexpr bool operator&&(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            if (a.m_val[i] & b.m_val[i]) return true;\n+        }\n+        return false;\n+    }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr MultiIntBitSet operator&(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        MultiIntBitSet r;\n+        for (unsigned i = 0; i < N; ++i) {\n+            r.m_val[i] = a.m_val[i] & b.m_val[i];\n+        }\n+        return r;\n+    }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr MultiIntBitSet operator|(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        MultiIntBitSet r;\n+        for (unsigned i = 0; i < N; ++i) {\n+            r.m_val[i] = a.m_val[i] | b.m_val[i];\n+        }\n+        return r;\n+    }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr MultiIntBitSet operator/(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        MultiIntBitSet r;\n+        for (unsigned i = 0; i < N; ++i) {\n+            r.m_val[i] = a.m_val[i] & ~b.m_val[i];\n+        }\n+        return r;\n+    }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr MultiIntBitSet operator^(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        MultiIntBitSet r;\n+        for (unsigned i = 0; i < N; ++i) {\n+            r.m_val[i] = a.m_val[i] ^ b.m_val[i];\n+        }\n+        return r;\n+    }\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    friend constexpr bool operator>=(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            if (b.m_val[i] & ~a.m_val[i]) return false;\n+        }\n+        return true;\n+    }\n+    /** Check if bitset a is a subset of bitset b (= every 1 bit in a is also in b). */\n+    friend constexpr bool operator<=(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            if (a.m_val[i] & ~b.m_val[i]) return false;\n+        }\n+        return true;\n+    }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept = default;\n+    /** Swap two bitsets. */\n+    friend constexpr void swap(MultiIntBitSet& a, MultiIntBitSet& b) noexcept { std::swap(a.m_val, b.m_val); }\n+};\n+\n+} // namespace bitset_detail\n+\n+// BitSet dispatches to IntBitSet or MultiIntBitSet as appropriate for the requested minimum number\n+// of bits.\n+template<unsigned BITS>\n+using BitSet = std::conditional_t<(BITS <= 32), bitset_detail::IntBitSet<uint32_t>,\n+               std::conditional_t<(BITS <= std::numeric_limits<size_t>::digits), bitset_detail::IntBitSet<size_t>,\n+               bitset_detail::MultiIntBitSet<size_t, (BITS + std::numeric_limits<size_t>::digits - 1) / std::numeric_limits<size_t>::digits>>>;",
      "path": "src/util/bitset.h",
      "position": 525,
      "original_position": 461,
      "commit_id": "47f705b33fc1381d96c99038e2110e6fe2b2f883",
      "original_commit_id": "aeef8a4dcf982cb76bca9571871196c4b25a1bdd",
      "in_reply_to_id": null,
      "user": {
        "login": "cbergqvist",
        "id": 581308,
        "node_id": "MDQ6VXNlcjU4MTMwOA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/581308?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/cbergqvist",
        "html_url": "https://github.com/cbergqvist",
        "followers_url": "https://api.github.com/users/cbergqvist/followers",
        "following_url": "https://api.github.com/users/cbergqvist/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/cbergqvist/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/cbergqvist/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/cbergqvist/subscriptions",
        "organizations_url": "https://api.github.com/users/cbergqvist/orgs",
        "repos_url": "https://api.github.com/users/cbergqvist/repos",
        "events_url": "https://api.github.com/users/cbergqvist/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/cbergqvist/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Have you considered using `__int128`, `__int256` etc when available, before falling back to `MultiIntBitSet`? Maybe something for a follow-up PR.",
      "created_at": "2024-05-24T08:44:43Z",
      "updated_at": "2024-05-28T11:52:13Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1613105680",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613105680"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": 524,
      "original_start_line": 460,
      "start_side": "RIGHT",
      "line": 525,
      "original_line": 525,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613223825",
      "pull_request_review_id": 2076257466,
      "id": 1613223825,
      "node_id": "PRRC_kwDOABII585gJ9eR",
      "diff_hunk": "@@ -0,0 +1,463 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a / b) implements \"a and not b\".\n+ * - Efficient subset/superset testing: (a <= b) and (a >= b).\n+ * - Efficient set overlap testing: a && b\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept {\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept {\n+        IntBitSet ret;\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept { m_val |= I{1U} << pos; }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept { m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos); }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept { m_val &= ~I(I{1U} << pos); }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept { return (m_val >> pos) & 1U; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept { return std::countr_zero(m_val); }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept { return std::bit_width(m_val) - 1; }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator/=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    friend constexpr bool operator&&(const IntBitSet& a, const IntBitSet& b) noexcept { return a.m_val & b.m_val; }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr IntBitSet operator&(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & b.m_val); }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator|(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val | b.m_val); }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr IntBitSet operator/(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & ~b.m_val); }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator^(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val ^ b.m_val); }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const IntBitSet& a, const IntBitSet& b) noexcept = default;\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    friend constexpr bool operator>=(const IntBitSet& a, const IntBitSet& b) noexcept { return (b.m_val & ~a.m_val) == 0; }\n+    /** Check if bitset a is a subset of bitset b (= every 1 bit in a is also in b). */\n+    friend constexpr bool operator<=(const IntBitSet& a, const IntBitSet& b) noexcept { return (a.m_val & ~b.m_val) == 0; }\n+    /** Swap two bitsets. */\n+    friend constexpr void swap(IntBitSet& a, IntBitSet& b) noexcept { std::swap(a.m_val, b.m_val); }\n+};\n+\n+/** A bitset implementation backed by N integers of type I. */\n+template<typename I, unsigned N>\n+class MultiIntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The number of bits per integer. */\n+    static constexpr unsigned LIMB_BITS = std::numeric_limits<I>::digits;\n+    /** Number of elements this set type supports. */\n+    static constexpr unsigned MAX_SIZE = LIMB_BITS * N;\n+    /** Array whose member integers store the bits of the set. */\n+    std::array<I, N> m_val;\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class MultiIntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class MultiIntBitSet;\n+        const std::array<I, N>* m_ptr; /**< Pointer to array to fetch bits from. */\n+        I m_val; /**< The remaining bits of (*m_ptr)[m_idx]. */\n+        unsigned m_pos; /**< The last reported position. */\n+        unsigned m_idx; /**< The index in *m_ptr currently being iterated over. */\n+        constexpr Iterator(const std::array<I, N>* ptr) noexcept : m_ptr(ptr), m_idx(0)\n+        {\n+            do {\n+                m_val = (*m_ptr)[m_idx];\n+                if (m_val) {\n+                    m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                    break;\n+                }\n+                ++m_idx;\n+            } while(m_idx < N);\n+        }\n+\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        friend constexpr bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_idx == N;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val == 0) {\n+                while (true) {\n+                    ++m_idx;\n+                    if (m_idx == N) break;\n+                    m_val = (*m_ptr)[m_idx];\n+                    if (m_val) {\n+                        m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                        break;\n+                    }\n+                }\n+            } else {\n+                m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+            }\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr MultiIntBitSet() noexcept : m_val{} {}\n+    /** Copy construct a bitset. */\n+    constexpr MultiIntBitSet(const MultiIntBitSet&) noexcept = default;\n+    /** Copy assign a bitset. */\n+    constexpr MultiIntBitSet& operator=(const MultiIntBitSet&) noexcept = default;\n+    /** Set a bit to 1. */\n+    void constexpr Set(unsigned pos) noexcept { m_val[pos / LIMB_BITS] |= I{1U} << (pos % LIMB_BITS); }\n+    /** Set a bit to the specified value. */\n+    void constexpr Set(unsigned pos, bool val) noexcept { m_val[pos / LIMB_BITS] = (m_val[pos / LIMB_BITS] & ~I(I{1U} << (pos % LIMB_BITS))) | (I{val} << (pos % LIMB_BITS)); }\n+    /** Construct a bitset from a list of values. */\n+    constexpr MultiIntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val{}\n+    {\n+        for (auto i : ilist) Set(i);\n+    }\n+    /** Set a bitset to a list of values. */\n+    constexpr MultiIntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val.fill(0);\n+        for (auto i : ilist) Set(i);\n+        return *this;\n+    }\n+    /** Set a bit to 0. */\n+    void constexpr Reset(unsigned pos) noexcept { m_val[pos / LIMB_BITS] &= ~I(I{1U} << (pos % LIMB_BITS)); }\n+    /** Retrieve a bit at the given position. */\n+    bool constexpr operator[](unsigned pos) const noexcept { return (m_val[pos / LIMB_BITS] >> (pos % LIMB_BITS)) & 1U; }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr MultiIntBitSet Singleton(unsigned i) noexcept\n+    {\n+        MultiIntBitSet ret;\n+        ret.m_val[i / LIMB_BITS] = I{1U} << (i % LIMB_BITS);\n+        return ret;\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr MultiIntBitSet Fill(unsigned count) noexcept\n+    {\n+        MultiIntBitSet ret;\n+        if (count) {\n+            unsigned i = 0;\n+            while (count > LIMB_BITS) {\n+                ret.m_val[i++] = ~I{0};\n+                count -= LIMB_BITS;\n+            }\n+            ret.m_val[i] = I(~I{0}) >> (LIMB_BITS - count);",
      "path": "src/util/bitset.h",
      "position": 372,
      "original_position": 309,
      "commit_id": "47f705b33fc1381d96c99038e2110e6fe2b2f883",
      "original_commit_id": "aeef8a4dcf982cb76bca9571871196c4b25a1bdd",
      "in_reply_to_id": null,
      "user": {
        "login": "cbergqvist",
        "id": 581308,
        "node_id": "MDQ6VXNlcjU4MTMwOA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/581308?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/cbergqvist",
        "html_url": "https://github.com/cbergqvist",
        "followers_url": "https://api.github.com/users/cbergqvist/followers",
        "following_url": "https://api.github.com/users/cbergqvist/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/cbergqvist/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/cbergqvist/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/cbergqvist/subscriptions",
        "organizations_url": "https://api.github.com/users/cbergqvist/orgs",
        "repos_url": "https://api.github.com/users/cbergqvist/repos",
        "events_url": "https://api.github.com/users/cbergqvist/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/cbergqvist/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: Superfluous `I()`",
      "created_at": "2024-05-24T10:05:10Z",
      "updated_at": "2024-05-28T11:52:13Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1613223825",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613223825"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 372,
      "original_line": 372,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613558242",
      "pull_request_review_id": 2077061355,
      "id": 1613558242,
      "node_id": "PRRC_kwDOABII585gLPHi",
      "diff_hunk": "@@ -0,0 +1,510 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <util/check.h>\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a / b) implements \"a and not b\".\n+ * - Efficient non-strict subset/superset testing: (a <= b) and (a >= b).\n+ * - Efficient set overlap testing: a.Overlaps(b)\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept\n+    {\n+        Assume(i < MAX_SIZE);\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept\n+    {\n+        IntBitSet ret;\n+        Assume(count <= MAX_SIZE);\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val |= I{1U} << pos;\n+    }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos);\n+    }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val &= ~I(I{1U} << pos);\n+    }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        return (m_val >> pos) & 1U;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept { return std::countr_zero(m_val); }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept { return std::bit_width(m_val) - 1; }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator/=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    constexpr bool Overlaps(const IntBitSet& a) noexcept { return m_val & a.m_val; }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr IntBitSet operator&(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & b.m_val); }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator|(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val | b.m_val); }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr IntBitSet operator/(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & ~b.m_val); }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator^(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val ^ b.m_val); }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const IntBitSet& a, const IntBitSet& b) noexcept = default;\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    friend constexpr bool operator>=(const IntBitSet& a, const IntBitSet& b) noexcept { return (b.m_val & ~a.m_val) == 0; }",
      "path": "src/util/bitset.h",
      "position": null,
      "original_position": 212,
      "commit_id": "47f705b33fc1381d96c99038e2110e6fe2b2f883",
      "original_commit_id": "797ea9aca05a6dafb70e224e6a7d89bb18294150",
      "in_reply_to_id": null,
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "`.Subset()` and `.Superset()`?\r\n\r\nWithout these comments, I would have to guess at the meanings (and I would have guessed wrong).",
      "created_at": "2024-05-24T14:17:56Z",
      "updated_at": "2024-05-24T14:17:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1613558242",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613558242"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 212,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613674776",
      "pull_request_review_id": 2077267486,
      "id": 1613674776,
      "node_id": "PRRC_kwDOABII585gLrkY",
      "diff_hunk": "@@ -0,0 +1,463 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a / b) implements \"a and not b\".\n+ * - Efficient subset/superset testing: (a <= b) and (a >= b).\n+ * - Efficient set overlap testing: a && b\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept {\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept {\n+        IntBitSet ret;\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept { m_val |= I{1U} << pos; }",
      "path": "src/util/bitset.h",
      "position": null,
      "original_position": 144,
      "commit_id": "47f705b33fc1381d96c99038e2110e6fe2b2f883",
      "original_commit_id": "a12b4052dad2158cf21de07fded63fb224dba915",
      "in_reply_to_id": 1612232560,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2024-05-24T15:37:28Z",
      "updated_at": "2024-05-24T15:37:28Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1613674776",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613674776"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 144,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613675392",
      "pull_request_review_id": 2077268563,
      "id": 1613675392,
      "node_id": "PRRC_kwDOABII585gLruA",
      "diff_hunk": "@@ -0,0 +1,463 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a / b) implements \"a and not b\".\n+ * - Efficient subset/superset testing: (a <= b) and (a >= b).\n+ * - Efficient set overlap testing: a && b\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept {\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept {\n+        IntBitSet ret;\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept { m_val |= I{1U} << pos; }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept { m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos); }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept { m_val &= ~I(I{1U} << pos); }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept { return (m_val >> pos) & 1U; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept { return std::countr_zero(m_val); }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept { return std::bit_width(m_val) - 1; }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator/=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    friend constexpr bool operator&&(const IntBitSet& a, const IntBitSet& b) noexcept { return a.m_val & b.m_val; }",
      "path": "src/util/bitset.h",
      "position": null,
      "original_position": 172,
      "commit_id": "47f705b33fc1381d96c99038e2110e6fe2b2f883",
      "original_commit_id": "a12b4052dad2158cf21de07fded63fb224dba915",
      "in_reply_to_id": 1612240218,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Replaced with `Overlaps()`.",
      "created_at": "2024-05-24T15:37:50Z",
      "updated_at": "2024-05-24T15:37:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1613675392",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613675392"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 172,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613675918",
      "pull_request_review_id": 2077269480,
      "id": 1613675918,
      "node_id": "PRRC_kwDOABII585gLr2O",
      "diff_hunk": "@@ -0,0 +1,510 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <util/check.h>\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a / b) implements \"a and not b\".\n+ * - Efficient non-strict subset/superset testing: (a <= b) and (a >= b).\n+ * - Efficient set overlap testing: a.Overlaps(b)\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept\n+    {\n+        Assume(i < MAX_SIZE);\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept\n+    {\n+        IntBitSet ret;\n+        Assume(count <= MAX_SIZE);\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val |= I{1U} << pos;\n+    }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos);\n+    }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val &= ~I(I{1U} << pos);\n+    }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        return (m_val >> pos) & 1U;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept { return std::countr_zero(m_val); }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept { return std::bit_width(m_val) - 1; }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator/=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    constexpr bool Overlaps(const IntBitSet& a) noexcept { return m_val & a.m_val; }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr IntBitSet operator&(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & b.m_val); }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator|(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val | b.m_val); }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr IntBitSet operator/(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & ~b.m_val); }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator^(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val ^ b.m_val); }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const IntBitSet& a, const IntBitSet& b) noexcept = default;\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    friend constexpr bool operator>=(const IntBitSet& a, const IntBitSet& b) noexcept { return (b.m_val & ~a.m_val) == 0; }",
      "path": "src/util/bitset.h",
      "position": null,
      "original_position": 212,
      "commit_id": "47f705b33fc1381d96c99038e2110e6fe2b2f883",
      "original_commit_id": "797ea9aca05a6dafb70e224e6a7d89bb18294150",
      "in_reply_to_id": 1613558242,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Replaced with `IsSubsetOf()` and `IsSupersetOf()`.",
      "created_at": "2024-05-24T15:38:09Z",
      "updated_at": "2024-05-24T15:38:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1613675918",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613675918"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 212,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617026499",
      "pull_request_review_id": 2082445138,
      "id": 1617026499,
      "node_id": "PRRC_kwDOABII585gYd3D",
      "diff_hunk": "@@ -0,0 +1,510 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <util/check.h>\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a - b) implements \"a and not b\".\n+ * - Efficient non-strict subset/superset testing: IsSubsetOf() and IsSupersetOf().\n+ * - Efficient set overlap testing: a.Overlaps(b)\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept\n+    {\n+        Assume(i < MAX_SIZE);\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept\n+    {\n+        IntBitSet ret;\n+        Assume(count <= MAX_SIZE);\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val |= I{1U} << pos;\n+    }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos);\n+    }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val &= ~I(I{1U} << pos);\n+    }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        return (m_val >> pos) & 1U;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept { return std::countr_zero(m_val); }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept { return std::bit_width(m_val) - 1; }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator-=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    constexpr bool Overlaps(const IntBitSet& a) const noexcept { return m_val & a.m_val; }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr IntBitSet operator&(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & b.m_val); }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator|(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val | b.m_val); }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr IntBitSet operator-(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & ~b.m_val); }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator^(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val ^ b.m_val); }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const IntBitSet& a, const IntBitSet& b) noexcept = default;\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    constexpr bool IsSupersetOf(const IntBitSet& a) const noexcept { return (a.m_val & ~m_val) == 0; }\n+    /** Check if bitset a is a subset of bitset b (= every 1 bit in a is also in b). */\n+    constexpr bool IsSubsetOf(const IntBitSet& a) const noexcept { return (m_val & ~a.m_val) == 0; }\n+    /** Swap two bitsets. */\n+    friend constexpr void swap(IntBitSet& a, IntBitSet& b) noexcept { std::swap(a.m_val, b.m_val); }\n+};\n+\n+/** A bitset implementation backed by N integers of type I. */\n+template<typename I, unsigned N>\n+class MultiIntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The number of bits per integer. */\n+    static constexpr unsigned LIMB_BITS = std::numeric_limits<I>::digits;\n+    /** Number of elements this set type supports. */\n+    static constexpr unsigned MAX_SIZE = LIMB_BITS * N;\n+    /** Array whose member integers store the bits of the set. */\n+    std::array<I, N> m_val;\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class MultiIntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class MultiIntBitSet;\n+        const std::array<I, N>* m_ptr; /**< Pointer to array to fetch bits from. */\n+        I m_val; /**< The remaining bits of (*m_ptr)[m_idx]. */\n+        unsigned m_pos; /**< The last reported position. */\n+        unsigned m_idx; /**< The index in *m_ptr currently being iterated over. */\n+        constexpr Iterator(const std::array<I, N>* ptr) noexcept : m_ptr(ptr), m_idx(0)\n+        {\n+            do {\n+                m_val = (*m_ptr)[m_idx];\n+                if (m_val) {\n+                    m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                    break;\n+                }\n+                ++m_idx;\n+            } while(m_idx < N);\n+        }\n+\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        friend constexpr bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_idx == N;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val == 0) {\n+                while (true) {\n+                    ++m_idx;\n+                    if (m_idx == N) break;\n+                    m_val = (*m_ptr)[m_idx];\n+                    if (m_val) {\n+                        m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                        break;\n+                    }\n+                }\n+            } else {\n+                m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+            }\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr MultiIntBitSet() noexcept : m_val{} {}\n+    /** Copy construct a bitset. */\n+    constexpr MultiIntBitSet(const MultiIntBitSet&) noexcept = default;\n+    /** Copy assign a bitset. */\n+    constexpr MultiIntBitSet& operator=(const MultiIntBitSet&) noexcept = default;\n+    /** Set a bit to 1. */\n+    void constexpr Set(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val[pos / LIMB_BITS] |= I{1U} << (pos % LIMB_BITS);\n+    }\n+    /** Set a bit to the specified value. */\n+    void constexpr Set(unsigned pos, bool val) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val[pos / LIMB_BITS] = (m_val[pos / LIMB_BITS] & ~I(I{1U} << (pos % LIMB_BITS))) |\n+                                 (I{val} << (pos % LIMB_BITS));\n+    }\n+    /** Construct a bitset from a list of values. */\n+    constexpr MultiIntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val{}\n+    {\n+        for (auto i : ilist) Set(i);\n+    }\n+    /** Set a bitset to a list of values. */\n+    constexpr MultiIntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val.fill(0);\n+        for (auto i : ilist) Set(i);\n+        return *this;\n+    }\n+    /** Set a bit to 0. */\n+    void constexpr Reset(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val[pos / LIMB_BITS] &= ~I(I{1U} << (pos % LIMB_BITS));\n+    }\n+    /** Retrieve a bit at the given position. */\n+    bool constexpr operator[](unsigned pos) const noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        return (m_val[pos / LIMB_BITS] >> (pos % LIMB_BITS)) & 1U;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr MultiIntBitSet Singleton(unsigned i) noexcept\n+    {\n+        Assume(i < MAX_SIZE);\n+        MultiIntBitSet ret;\n+        ret.m_val[i / LIMB_BITS] = I{1U} << (i % LIMB_BITS);\n+        return ret;\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr MultiIntBitSet Fill(unsigned count) noexcept\n+    {\n+        Assume(count <= MAX_SIZE);\n+        MultiIntBitSet ret;\n+        if (count) {\n+            unsigned i = 0;\n+            while (count > LIMB_BITS) {\n+                ret.m_val[i++] = ~I{0};\n+                count -= LIMB_BITS;\n+            }\n+            ret.m_val[i] = I(~I{0}) >> (LIMB_BITS - count);\n+        }\n+        return ret;\n+    }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Compute the number of 1 bits in the bitset. */\n+    unsigned constexpr Count() const noexcept\n+    {\n+        unsigned ret{0};\n+        for (I v : m_val) ret += PopCount(v);\n+        return ret;\n+    }\n+    /** Check if all bits are 0. */\n+    bool constexpr None() const noexcept\n+    {\n+        for (auto v : m_val) {\n+            if (v != 0) return false;\n+        }\n+        return true;\n+    }\n+    /** Check if any bits are 1. */\n+    bool constexpr Any() const noexcept\n+    {\n+        for (auto v : m_val) {\n+            if (v != 0) return true;\n+        }\n+        return false;\n+    }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    Iterator constexpr begin() const noexcept { return Iterator(&m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    IteratorEnd constexpr end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    unsigned constexpr First() const noexcept\n+    {\n+        unsigned p = 0;\n+        while (m_val[p] == 0) ++p;",
      "path": "src/util/bitset.h",
      "position": null,
      "original_position": 393,
      "commit_id": "47f705b33fc1381d96c99038e2110e6fe2b2f883",
      "original_commit_id": "beb535680b85b511709240a8e1f7de59864b3524",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "It's a bit scary that `MultiIntBitSet::{First,Last}` lead to buffer over/under-reads if no bit is set. I understand that we wouldn't want to do assert for `Any` in production for performance reasons, but it's maybe worth it do it for debug builds, e.g. with somethink like the `ASSERT_IF_DEBUG` construct used in src/span.h.",
      "created_at": "2024-05-28T11:01:55Z",
      "updated_at": "2024-05-28T12:20:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1617026499",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617026499"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 393,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617040989",
      "pull_request_review_id": 2076257466,
      "id": 1617040989,
      "node_id": "PRRC_kwDOABII585gYhZd",
      "diff_hunk": "@@ -0,0 +1,510 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <util/check.h>\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a - b) implements \"a and not b\".\n+ * - Efficient non-strict subset/superset testing: IsSubsetOf() and IsSupersetOf().\n+ * - Efficient set overlap testing: a.Overlaps(b)\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept\n+    {\n+        Assume(i < MAX_SIZE);\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept\n+    {\n+        IntBitSet ret;\n+        Assume(count <= MAX_SIZE);\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val |= I{1U} << pos;\n+    }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos);\n+    }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val &= ~I(I{1U} << pos);\n+    }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        return (m_val >> pos) & 1U;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept { return std::countr_zero(m_val); }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept { return std::bit_width(m_val) - 1; }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator-=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    constexpr bool Overlaps(const IntBitSet& a) const noexcept { return m_val & a.m_val; }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr IntBitSet operator&(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & b.m_val); }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator|(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val | b.m_val); }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr IntBitSet operator-(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & ~b.m_val); }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator^(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val ^ b.m_val); }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const IntBitSet& a, const IntBitSet& b) noexcept = default;\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    constexpr bool IsSupersetOf(const IntBitSet& a) const noexcept { return (a.m_val & ~m_val) == 0; }\n+    /** Check if bitset a is a subset of bitset b (= every 1 bit in a is also in b). */\n+    constexpr bool IsSubsetOf(const IntBitSet& a) const noexcept { return (m_val & ~a.m_val) == 0; }\n+    /** Swap two bitsets. */\n+    friend constexpr void swap(IntBitSet& a, IntBitSet& b) noexcept { std::swap(a.m_val, b.m_val); }\n+};\n+\n+/** A bitset implementation backed by N integers of type I. */\n+template<typename I, unsigned N>\n+class MultiIntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The number of bits per integer. */\n+    static constexpr unsigned LIMB_BITS = std::numeric_limits<I>::digits;\n+    /** Number of elements this set type supports. */\n+    static constexpr unsigned MAX_SIZE = LIMB_BITS * N;\n+    /** Array whose member integers store the bits of the set. */\n+    std::array<I, N> m_val;\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class MultiIntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class MultiIntBitSet;\n+        const std::array<I, N>* m_ptr; /**< Pointer to array to fetch bits from. */\n+        I m_val; /**< The remaining bits of (*m_ptr)[m_idx]. */\n+        unsigned m_pos; /**< The last reported position. */\n+        unsigned m_idx; /**< The index in *m_ptr currently being iterated over. */\n+        constexpr Iterator(const std::array<I, N>* ptr) noexcept : m_ptr(ptr), m_idx(0)",
      "path": "src/util/bitset.h",
      "position": null,
      "original_position": 247,
      "commit_id": "47f705b33fc1381d96c99038e2110e6fe2b2f883",
      "original_commit_id": "3bc131a85ce826aa171f0328c014ea51b8740fed",
      "in_reply_to_id": null,
      "user": {
        "login": "cbergqvist",
        "id": 581308,
        "node_id": "MDQ6VXNlcjU4MTMwOA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/581308?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/cbergqvist",
        "html_url": "https://github.com/cbergqvist",
        "followers_url": "https://api.github.com/users/cbergqvist/followers",
        "following_url": "https://api.github.com/users/cbergqvist/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/cbergqvist/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/cbergqvist/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/cbergqvist/subscriptions",
        "organizations_url": "https://api.github.com/users/cbergqvist/orgs",
        "repos_url": "https://api.github.com/users/cbergqvist/repos",
        "events_url": "https://api.github.com/users/cbergqvist/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/cbergqvist/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: `ptr` could be passed as a reference to signify non-nullness. (But the member still needs to be a pointer). Not at all significant as it is a private function.",
      "created_at": "2024-05-28T11:13:46Z",
      "updated_at": "2024-05-28T11:52:13Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1617040989",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617040989"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 247,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617148751",
      "pull_request_review_id": 2082633346,
      "id": 1617148751,
      "node_id": "PRRC_kwDOABII585gY7tP",
      "diff_hunk": "@@ -0,0 +1,463 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a / b) implements \"a and not b\".\n+ * - Efficient subset/superset testing: (a <= b) and (a >= b).\n+ * - Efficient set overlap testing: a && b\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept {\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept {\n+        IntBitSet ret;\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept { m_val |= I{1U} << pos; }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept { m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos); }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept { m_val &= ~I(I{1U} << pos); }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept { return (m_val >> pos) & 1U; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept { return std::countr_zero(m_val); }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept { return std::bit_width(m_val) - 1; }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator/=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    friend constexpr bool operator&&(const IntBitSet& a, const IntBitSet& b) noexcept { return a.m_val & b.m_val; }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr IntBitSet operator&(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & b.m_val); }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator|(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val | b.m_val); }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr IntBitSet operator/(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & ~b.m_val); }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator^(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val ^ b.m_val); }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const IntBitSet& a, const IntBitSet& b) noexcept = default;\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    friend constexpr bool operator>=(const IntBitSet& a, const IntBitSet& b) noexcept { return (b.m_val & ~a.m_val) == 0; }\n+    /** Check if bitset a is a subset of bitset b (= every 1 bit in a is also in b). */\n+    friend constexpr bool operator<=(const IntBitSet& a, const IntBitSet& b) noexcept { return (a.m_val & ~b.m_val) == 0; }\n+    /** Swap two bitsets. */\n+    friend constexpr void swap(IntBitSet& a, IntBitSet& b) noexcept { std::swap(a.m_val, b.m_val); }\n+};\n+\n+/** A bitset implementation backed by N integers of type I. */\n+template<typename I, unsigned N>\n+class MultiIntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The number of bits per integer. */\n+    static constexpr unsigned LIMB_BITS = std::numeric_limits<I>::digits;\n+    /** Number of elements this set type supports. */\n+    static constexpr unsigned MAX_SIZE = LIMB_BITS * N;\n+    /** Array whose member integers store the bits of the set. */\n+    std::array<I, N> m_val;\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class MultiIntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class MultiIntBitSet;\n+        const std::array<I, N>* m_ptr; /**< Pointer to array to fetch bits from. */\n+        I m_val; /**< The remaining bits of (*m_ptr)[m_idx]. */\n+        unsigned m_pos; /**< The last reported position. */\n+        unsigned m_idx; /**< The index in *m_ptr currently being iterated over. */\n+        constexpr Iterator(const std::array<I, N>* ptr) noexcept : m_ptr(ptr), m_idx(0)\n+        {\n+            do {\n+                m_val = (*m_ptr)[m_idx];\n+                if (m_val) {\n+                    m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                    break;\n+                }\n+                ++m_idx;\n+            } while(m_idx < N);\n+        }\n+\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        friend constexpr bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_idx == N;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val == 0) {\n+                while (true) {\n+                    ++m_idx;\n+                    if (m_idx == N) break;\n+                    m_val = (*m_ptr)[m_idx];\n+                    if (m_val) {\n+                        m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                        break;\n+                    }\n+                }\n+            } else {\n+                m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+            }\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr MultiIntBitSet() noexcept : m_val{} {}\n+    /** Copy construct a bitset. */\n+    constexpr MultiIntBitSet(const MultiIntBitSet&) noexcept = default;\n+    /** Copy assign a bitset. */\n+    constexpr MultiIntBitSet& operator=(const MultiIntBitSet&) noexcept = default;\n+    /** Set a bit to 1. */\n+    void constexpr Set(unsigned pos) noexcept { m_val[pos / LIMB_BITS] |= I{1U} << (pos % LIMB_BITS); }\n+    /** Set a bit to the specified value. */\n+    void constexpr Set(unsigned pos, bool val) noexcept { m_val[pos / LIMB_BITS] = (m_val[pos / LIMB_BITS] & ~I(I{1U} << (pos % LIMB_BITS))) | (I{val} << (pos % LIMB_BITS)); }\n+    /** Construct a bitset from a list of values. */\n+    constexpr MultiIntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val{}\n+    {\n+        for (auto i : ilist) Set(i);\n+    }\n+    /** Set a bitset to a list of values. */\n+    constexpr MultiIntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val.fill(0);\n+        for (auto i : ilist) Set(i);\n+        return *this;\n+    }\n+    /** Set a bit to 0. */\n+    void constexpr Reset(unsigned pos) noexcept { m_val[pos / LIMB_BITS] &= ~I(I{1U} << (pos % LIMB_BITS)); }\n+    /** Retrieve a bit at the given position. */\n+    bool constexpr operator[](unsigned pos) const noexcept { return (m_val[pos / LIMB_BITS] >> (pos % LIMB_BITS)) & 1U; }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr MultiIntBitSet Singleton(unsigned i) noexcept\n+    {\n+        MultiIntBitSet ret;\n+        ret.m_val[i / LIMB_BITS] = I{1U} << (i % LIMB_BITS);\n+        return ret;\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr MultiIntBitSet Fill(unsigned count) noexcept\n+    {\n+        MultiIntBitSet ret;\n+        if (count) {\n+            unsigned i = 0;\n+            while (count > LIMB_BITS) {\n+                ret.m_val[i++] = ~I{0};\n+                count -= LIMB_BITS;\n+            }\n+            ret.m_val[i] = I(~I{0}) >> (LIMB_BITS - count);\n+        }\n+        return ret;\n+    }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Compute the number of 1 bits in the bitset. */\n+    unsigned constexpr Count() const noexcept\n+    {\n+        unsigned ret{0};\n+        for (I v : m_val) ret += PopCount(v);\n+        return ret;\n+    }\n+    /** Check if all bits are 0. */\n+    bool constexpr None() const noexcept\n+    {\n+        for (auto v : m_val) {\n+            if (v != 0) return false;\n+        }\n+        return true;\n+    }\n+    /** Check if any bits are 1. */\n+    bool constexpr Any() const noexcept\n+    {\n+        for (auto v : m_val) {\n+            if (v != 0) return true;\n+        }\n+        return false;\n+    }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    Iterator constexpr begin() const noexcept { return Iterator(&m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    IteratorEnd constexpr end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    unsigned constexpr First() const noexcept\n+    {\n+        unsigned p = 0;\n+        while (m_val[p] == 0) ++p;\n+        return std::countr_zero(m_val[p]) + p * LIMB_BITS;\n+    }\n+    /** Find the last element (requires Any()). */\n+    unsigned constexpr Last() const noexcept\n+    {\n+        unsigned p = N - 1;\n+        while (m_val[p] == 0) --p;\n+        return std::bit_width(m_val[p]) - 1 + p * LIMB_BITS;\n+    }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr MultiIntBitSet& operator|=(const MultiIntBitSet& a) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            m_val[i] |= a.m_val[i];\n+        }\n+        return *this;\n+    }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr MultiIntBitSet& operator&=(const MultiIntBitSet& a) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            m_val[i] &= a.m_val[i];\n+        }\n+        return *this;\n+    }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr MultiIntBitSet& operator/=(const MultiIntBitSet& a) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            m_val[i] &= ~a.m_val[i];\n+        }\n+        return *this;\n+    }\n+    /** Set this object's bits to be the binary XOR between respective bits from this and a. */\n+    constexpr MultiIntBitSet& operator^=(const MultiIntBitSet& a) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            m_val[i] ^= a.m_val[i];\n+        }\n+        return *this;\n+    }\n+    /** Check whether the intersection between two sets is non-empty. */\n+    friend constexpr bool operator&&(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            if (a.m_val[i] & b.m_val[i]) return true;\n+        }\n+        return false;\n+    }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr MultiIntBitSet operator&(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        MultiIntBitSet r;\n+        for (unsigned i = 0; i < N; ++i) {\n+            r.m_val[i] = a.m_val[i] & b.m_val[i];\n+        }\n+        return r;\n+    }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr MultiIntBitSet operator|(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        MultiIntBitSet r;\n+        for (unsigned i = 0; i < N; ++i) {\n+            r.m_val[i] = a.m_val[i] | b.m_val[i];\n+        }\n+        return r;\n+    }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr MultiIntBitSet operator/(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        MultiIntBitSet r;\n+        for (unsigned i = 0; i < N; ++i) {\n+            r.m_val[i] = a.m_val[i] & ~b.m_val[i];\n+        }\n+        return r;\n+    }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr MultiIntBitSet operator^(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        MultiIntBitSet r;\n+        for (unsigned i = 0; i < N; ++i) {\n+            r.m_val[i] = a.m_val[i] ^ b.m_val[i];\n+        }\n+        return r;\n+    }\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    friend constexpr bool operator>=(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            if (b.m_val[i] & ~a.m_val[i]) return false;\n+        }\n+        return true;\n+    }\n+    /** Check if bitset a is a subset of bitset b (= every 1 bit in a is also in b). */\n+    friend constexpr bool operator<=(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            if (a.m_val[i] & ~b.m_val[i]) return false;\n+        }\n+        return true;\n+    }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept = default;\n+    /** Swap two bitsets. */\n+    friend constexpr void swap(MultiIntBitSet& a, MultiIntBitSet& b) noexcept { std::swap(a.m_val, b.m_val); }\n+};\n+\n+} // namespace bitset_detail\n+\n+// BitSet dispatches to IntBitSet or MultiIntBitSet as appropriate for the requested minimum number\n+// of bits.\n+template<unsigned BITS>\n+using BitSet = std::conditional_t<(BITS <= 32), bitset_detail::IntBitSet<uint32_t>,\n+               std::conditional_t<(BITS <= std::numeric_limits<size_t>::digits), bitset_detail::IntBitSet<size_t>,\n+               bitset_detail::MultiIntBitSet<size_t, (BITS + std::numeric_limits<size_t>::digits - 1) / std::numeric_limits<size_t>::digits>>>;",
      "path": "src/util/bitset.h",
      "position": 525,
      "original_position": 461,
      "commit_id": "47f705b33fc1381d96c99038e2110e6fe2b2f883",
      "original_commit_id": "aeef8a4dcf982cb76bca9571871196c4b25a1bdd",
      "in_reply_to_id": 1613105680,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I have not benchmarked this, but I have a hard time imagining how that can be faster, as common hardware doesn't have general-purpose registers bigger than `size_t`, so `__int128` operations get simulated using multiple variables anyway. Some architectures do have vector extensions (SSE, AVX, ...) which introduce native 128-, 256-, or 512-bit registers, but those generally only support operations of units up to 32 to 64 bits in them (including leading-zero counting, or popcount, which we need here).",
      "created_at": "2024-05-28T12:21:47Z",
      "updated_at": "2024-05-28T12:21:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1617148751",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617148751"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": 524,
      "original_start_line": 460,
      "start_side": "RIGHT",
      "line": 525,
      "original_line": 525,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617153576",
      "pull_request_review_id": 2082640599,
      "id": 1617153576,
      "node_id": "PRRC_kwDOABII585gY84o",
      "diff_hunk": "@@ -0,0 +1,463 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a / b) implements \"a and not b\".\n+ * - Efficient subset/superset testing: (a <= b) and (a >= b).\n+ * - Efficient set overlap testing: a && b\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept {\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept {\n+        IntBitSet ret;\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept { m_val |= I{1U} << pos; }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept { m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos); }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept { m_val &= ~I(I{1U} << pos); }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept { return (m_val >> pos) & 1U; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept { return std::countr_zero(m_val); }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept { return std::bit_width(m_val) - 1; }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator/=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    friend constexpr bool operator&&(const IntBitSet& a, const IntBitSet& b) noexcept { return a.m_val & b.m_val; }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr IntBitSet operator&(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & b.m_val); }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator|(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val | b.m_val); }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr IntBitSet operator/(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & ~b.m_val); }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator^(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val ^ b.m_val); }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const IntBitSet& a, const IntBitSet& b) noexcept = default;\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    friend constexpr bool operator>=(const IntBitSet& a, const IntBitSet& b) noexcept { return (b.m_val & ~a.m_val) == 0; }\n+    /** Check if bitset a is a subset of bitset b (= every 1 bit in a is also in b). */\n+    friend constexpr bool operator<=(const IntBitSet& a, const IntBitSet& b) noexcept { return (a.m_val & ~b.m_val) == 0; }\n+    /** Swap two bitsets. */\n+    friend constexpr void swap(IntBitSet& a, IntBitSet& b) noexcept { std::swap(a.m_val, b.m_val); }\n+};\n+\n+/** A bitset implementation backed by N integers of type I. */\n+template<typename I, unsigned N>\n+class MultiIntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The number of bits per integer. */\n+    static constexpr unsigned LIMB_BITS = std::numeric_limits<I>::digits;\n+    /** Number of elements this set type supports. */\n+    static constexpr unsigned MAX_SIZE = LIMB_BITS * N;\n+    /** Array whose member integers store the bits of the set. */\n+    std::array<I, N> m_val;\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class MultiIntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class MultiIntBitSet;\n+        const std::array<I, N>* m_ptr; /**< Pointer to array to fetch bits from. */\n+        I m_val; /**< The remaining bits of (*m_ptr)[m_idx]. */\n+        unsigned m_pos; /**< The last reported position. */\n+        unsigned m_idx; /**< The index in *m_ptr currently being iterated over. */\n+        constexpr Iterator(const std::array<I, N>* ptr) noexcept : m_ptr(ptr), m_idx(0)\n+        {\n+            do {\n+                m_val = (*m_ptr)[m_idx];\n+                if (m_val) {\n+                    m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                    break;\n+                }\n+                ++m_idx;\n+            } while(m_idx < N);\n+        }\n+\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        friend constexpr bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_idx == N;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val == 0) {\n+                while (true) {\n+                    ++m_idx;\n+                    if (m_idx == N) break;\n+                    m_val = (*m_ptr)[m_idx];\n+                    if (m_val) {\n+                        m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                        break;\n+                    }\n+                }\n+            } else {\n+                m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+            }\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr MultiIntBitSet() noexcept : m_val{} {}\n+    /** Copy construct a bitset. */\n+    constexpr MultiIntBitSet(const MultiIntBitSet&) noexcept = default;\n+    /** Copy assign a bitset. */\n+    constexpr MultiIntBitSet& operator=(const MultiIntBitSet&) noexcept = default;\n+    /** Set a bit to 1. */\n+    void constexpr Set(unsigned pos) noexcept { m_val[pos / LIMB_BITS] |= I{1U} << (pos % LIMB_BITS); }\n+    /** Set a bit to the specified value. */\n+    void constexpr Set(unsigned pos, bool val) noexcept { m_val[pos / LIMB_BITS] = (m_val[pos / LIMB_BITS] & ~I(I{1U} << (pos % LIMB_BITS))) | (I{val} << (pos % LIMB_BITS)); }\n+    /** Construct a bitset from a list of values. */\n+    constexpr MultiIntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val{}\n+    {\n+        for (auto i : ilist) Set(i);\n+    }\n+    /** Set a bitset to a list of values. */\n+    constexpr MultiIntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val.fill(0);\n+        for (auto i : ilist) Set(i);\n+        return *this;\n+    }\n+    /** Set a bit to 0. */\n+    void constexpr Reset(unsigned pos) noexcept { m_val[pos / LIMB_BITS] &= ~I(I{1U} << (pos % LIMB_BITS)); }\n+    /** Retrieve a bit at the given position. */\n+    bool constexpr operator[](unsigned pos) const noexcept { return (m_val[pos / LIMB_BITS] >> (pos % LIMB_BITS)) & 1U; }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr MultiIntBitSet Singleton(unsigned i) noexcept\n+    {\n+        MultiIntBitSet ret;\n+        ret.m_val[i / LIMB_BITS] = I{1U} << (i % LIMB_BITS);\n+        return ret;\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr MultiIntBitSet Fill(unsigned count) noexcept\n+    {\n+        MultiIntBitSet ret;\n+        if (count) {\n+            unsigned i = 0;\n+            while (count > LIMB_BITS) {\n+                ret.m_val[i++] = ~I{0};\n+                count -= LIMB_BITS;\n+            }\n+            ret.m_val[i] = I(~I{0}) >> (LIMB_BITS - count);",
      "path": "src/util/bitset.h",
      "position": 372,
      "original_position": 309,
      "commit_id": "47f705b33fc1381d96c99038e2110e6fe2b2f883",
      "original_commit_id": "aeef8a4dcf982cb76bca9571871196c4b25a1bdd",
      "in_reply_to_id": 1613223825,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I don't believe this is superfluous. If `I` is smaller than an `int` (e.g. `I = uint16_t`) then `~I{0}` undergoes [integer promotion](https://en.cppreference.com/w/c/language/conversion) to `int`, and right-shifting that would sign-extend, which would incorrect here. The `I(...)` around it forces it to be unsigned before the right-shift.",
      "created_at": "2024-05-28T12:25:11Z",
      "updated_at": "2024-05-28T12:25:11Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1617153576",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617153576"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 372,
      "original_line": 372,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617175155",
      "pull_request_review_id": 2082674196,
      "id": 1617175155,
      "node_id": "PRRC_kwDOABII585gZCJz",
      "diff_hunk": "@@ -0,0 +1,510 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <util/check.h>\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a - b) implements \"a and not b\".\n+ * - Efficient non-strict subset/superset testing: IsSubsetOf() and IsSupersetOf().\n+ * - Efficient set overlap testing: a.Overlaps(b)\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept\n+    {\n+        Assume(i < MAX_SIZE);\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept\n+    {\n+        IntBitSet ret;\n+        Assume(count <= MAX_SIZE);\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val |= I{1U} << pos;\n+    }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos);\n+    }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val &= ~I(I{1U} << pos);\n+    }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        return (m_val >> pos) & 1U;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept { return std::countr_zero(m_val); }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept { return std::bit_width(m_val) - 1; }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator-=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    constexpr bool Overlaps(const IntBitSet& a) const noexcept { return m_val & a.m_val; }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr IntBitSet operator&(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & b.m_val); }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator|(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val | b.m_val); }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr IntBitSet operator-(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & ~b.m_val); }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator^(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val ^ b.m_val); }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const IntBitSet& a, const IntBitSet& b) noexcept = default;\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    constexpr bool IsSupersetOf(const IntBitSet& a) const noexcept { return (a.m_val & ~m_val) == 0; }\n+    /** Check if bitset a is a subset of bitset b (= every 1 bit in a is also in b). */\n+    constexpr bool IsSubsetOf(const IntBitSet& a) const noexcept { return (m_val & ~a.m_val) == 0; }\n+    /** Swap two bitsets. */\n+    friend constexpr void swap(IntBitSet& a, IntBitSet& b) noexcept { std::swap(a.m_val, b.m_val); }\n+};\n+\n+/** A bitset implementation backed by N integers of type I. */\n+template<typename I, unsigned N>\n+class MultiIntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The number of bits per integer. */\n+    static constexpr unsigned LIMB_BITS = std::numeric_limits<I>::digits;\n+    /** Number of elements this set type supports. */\n+    static constexpr unsigned MAX_SIZE = LIMB_BITS * N;\n+    /** Array whose member integers store the bits of the set. */\n+    std::array<I, N> m_val;\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class MultiIntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class MultiIntBitSet;\n+        const std::array<I, N>* m_ptr; /**< Pointer to array to fetch bits from. */\n+        I m_val; /**< The remaining bits of (*m_ptr)[m_idx]. */\n+        unsigned m_pos; /**< The last reported position. */\n+        unsigned m_idx; /**< The index in *m_ptr currently being iterated over. */\n+        constexpr Iterator(const std::array<I, N>* ptr) noexcept : m_ptr(ptr), m_idx(0)\n+        {\n+            do {\n+                m_val = (*m_ptr)[m_idx];\n+                if (m_val) {\n+                    m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                    break;\n+                }\n+                ++m_idx;\n+            } while(m_idx < N);\n+        }\n+\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        friend constexpr bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_idx == N;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val == 0) {\n+                while (true) {\n+                    ++m_idx;\n+                    if (m_idx == N) break;\n+                    m_val = (*m_ptr)[m_idx];\n+                    if (m_val) {\n+                        m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                        break;\n+                    }\n+                }\n+            } else {\n+                m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+            }\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr MultiIntBitSet() noexcept : m_val{} {}\n+    /** Copy construct a bitset. */\n+    constexpr MultiIntBitSet(const MultiIntBitSet&) noexcept = default;\n+    /** Copy assign a bitset. */\n+    constexpr MultiIntBitSet& operator=(const MultiIntBitSet&) noexcept = default;\n+    /** Set a bit to 1. */\n+    void constexpr Set(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val[pos / LIMB_BITS] |= I{1U} << (pos % LIMB_BITS);\n+    }\n+    /** Set a bit to the specified value. */\n+    void constexpr Set(unsigned pos, bool val) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val[pos / LIMB_BITS] = (m_val[pos / LIMB_BITS] & ~I(I{1U} << (pos % LIMB_BITS))) |\n+                                 (I{val} << (pos % LIMB_BITS));\n+    }\n+    /** Construct a bitset from a list of values. */\n+    constexpr MultiIntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val{}\n+    {\n+        for (auto i : ilist) Set(i);\n+    }\n+    /** Set a bitset to a list of values. */\n+    constexpr MultiIntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val.fill(0);\n+        for (auto i : ilist) Set(i);\n+        return *this;\n+    }\n+    /** Set a bit to 0. */\n+    void constexpr Reset(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val[pos / LIMB_BITS] &= ~I(I{1U} << (pos % LIMB_BITS));\n+    }\n+    /** Retrieve a bit at the given position. */\n+    bool constexpr operator[](unsigned pos) const noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        return (m_val[pos / LIMB_BITS] >> (pos % LIMB_BITS)) & 1U;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr MultiIntBitSet Singleton(unsigned i) noexcept\n+    {\n+        Assume(i < MAX_SIZE);\n+        MultiIntBitSet ret;\n+        ret.m_val[i / LIMB_BITS] = I{1U} << (i % LIMB_BITS);\n+        return ret;\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr MultiIntBitSet Fill(unsigned count) noexcept\n+    {\n+        Assume(count <= MAX_SIZE);\n+        MultiIntBitSet ret;\n+        if (count) {\n+            unsigned i = 0;\n+            while (count > LIMB_BITS) {\n+                ret.m_val[i++] = ~I{0};\n+                count -= LIMB_BITS;\n+            }\n+            ret.m_val[i] = I(~I{0}) >> (LIMB_BITS - count);\n+        }\n+        return ret;\n+    }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Compute the number of 1 bits in the bitset. */\n+    unsigned constexpr Count() const noexcept\n+    {\n+        unsigned ret{0};\n+        for (I v : m_val) ret += PopCount(v);\n+        return ret;\n+    }\n+    /** Check if all bits are 0. */\n+    bool constexpr None() const noexcept\n+    {\n+        for (auto v : m_val) {\n+            if (v != 0) return false;\n+        }\n+        return true;\n+    }\n+    /** Check if any bits are 1. */\n+    bool constexpr Any() const noexcept\n+    {\n+        for (auto v : m_val) {\n+            if (v != 0) return true;\n+        }\n+        return false;\n+    }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    Iterator constexpr begin() const noexcept { return Iterator(&m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    IteratorEnd constexpr end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    unsigned constexpr First() const noexcept\n+    {\n+        unsigned p = 0;\n+        while (m_val[p] == 0) ++p;",
      "path": "src/util/bitset.h",
      "position": null,
      "original_position": 393,
      "commit_id": "47f705b33fc1381d96c99038e2110e6fe2b2f883",
      "original_commit_id": "beb535680b85b511709240a8e1f7de59864b3524",
      "in_reply_to_id": 1617026499,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I've added `Assume()`s in `First()` and `Last()` to avoid this.",
      "created_at": "2024-05-28T12:39:37Z",
      "updated_at": "2024-05-28T12:39:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1617175155",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617175155"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 393,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617175296",
      "pull_request_review_id": 2082674439,
      "id": 1617175296,
      "node_id": "PRRC_kwDOABII585gZCMA",
      "diff_hunk": "@@ -0,0 +1,510 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <util/check.h>\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a - b) implements \"a and not b\".\n+ * - Efficient non-strict subset/superset testing: IsSubsetOf() and IsSupersetOf().\n+ * - Efficient set overlap testing: a.Overlaps(b)\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept\n+    {\n+        Assume(i < MAX_SIZE);\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept\n+    {\n+        IntBitSet ret;\n+        Assume(count <= MAX_SIZE);\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val |= I{1U} << pos;\n+    }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos);\n+    }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val &= ~I(I{1U} << pos);\n+    }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        return (m_val >> pos) & 1U;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept { return std::countr_zero(m_val); }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept { return std::bit_width(m_val) - 1; }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator-=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    constexpr bool Overlaps(const IntBitSet& a) const noexcept { return m_val & a.m_val; }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr IntBitSet operator&(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & b.m_val); }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator|(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val | b.m_val); }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr IntBitSet operator-(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & ~b.m_val); }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator^(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val ^ b.m_val); }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const IntBitSet& a, const IntBitSet& b) noexcept = default;\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    constexpr bool IsSupersetOf(const IntBitSet& a) const noexcept { return (a.m_val & ~m_val) == 0; }\n+    /** Check if bitset a is a subset of bitset b (= every 1 bit in a is also in b). */\n+    constexpr bool IsSubsetOf(const IntBitSet& a) const noexcept { return (m_val & ~a.m_val) == 0; }\n+    /** Swap two bitsets. */\n+    friend constexpr void swap(IntBitSet& a, IntBitSet& b) noexcept { std::swap(a.m_val, b.m_val); }\n+};\n+\n+/** A bitset implementation backed by N integers of type I. */\n+template<typename I, unsigned N>\n+class MultiIntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The number of bits per integer. */\n+    static constexpr unsigned LIMB_BITS = std::numeric_limits<I>::digits;\n+    /** Number of elements this set type supports. */\n+    static constexpr unsigned MAX_SIZE = LIMB_BITS * N;\n+    /** Array whose member integers store the bits of the set. */\n+    std::array<I, N> m_val;\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class MultiIntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class MultiIntBitSet;\n+        const std::array<I, N>* m_ptr; /**< Pointer to array to fetch bits from. */\n+        I m_val; /**< The remaining bits of (*m_ptr)[m_idx]. */\n+        unsigned m_pos; /**< The last reported position. */\n+        unsigned m_idx; /**< The index in *m_ptr currently being iterated over. */\n+        constexpr Iterator(const std::array<I, N>* ptr) noexcept : m_ptr(ptr), m_idx(0)",
      "path": "src/util/bitset.h",
      "position": null,
      "original_position": 247,
      "commit_id": "47f705b33fc1381d96c99038e2110e6fe2b2f883",
      "original_commit_id": "3bc131a85ce826aa171f0328c014ea51b8740fed",
      "in_reply_to_id": 1617040989,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2024-05-28T12:39:44Z",
      "updated_at": "2024-05-28T12:39:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1617175296",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617175296"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 247,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617190868",
      "pull_request_review_id": 2082699927,
      "id": 1617190868,
      "node_id": "PRRC_kwDOABII585gZF_U",
      "diff_hunk": "@@ -0,0 +1,463 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a / b) implements \"a and not b\".\n+ * - Efficient subset/superset testing: (a <= b) and (a >= b).\n+ * - Efficient set overlap testing: a && b\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept {\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept {\n+        IntBitSet ret;\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept { m_val |= I{1U} << pos; }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept { m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos); }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept { m_val &= ~I(I{1U} << pos); }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept { return (m_val >> pos) & 1U; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept { return std::countr_zero(m_val); }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept { return std::bit_width(m_val) - 1; }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator/=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    friend constexpr bool operator&&(const IntBitSet& a, const IntBitSet& b) noexcept { return a.m_val & b.m_val; }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr IntBitSet operator&(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & b.m_val); }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator|(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val | b.m_val); }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr IntBitSet operator/(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & ~b.m_val); }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator^(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val ^ b.m_val); }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const IntBitSet& a, const IntBitSet& b) noexcept = default;\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    friend constexpr bool operator>=(const IntBitSet& a, const IntBitSet& b) noexcept { return (b.m_val & ~a.m_val) == 0; }\n+    /** Check if bitset a is a subset of bitset b (= every 1 bit in a is also in b). */\n+    friend constexpr bool operator<=(const IntBitSet& a, const IntBitSet& b) noexcept { return (a.m_val & ~b.m_val) == 0; }\n+    /** Swap two bitsets. */\n+    friend constexpr void swap(IntBitSet& a, IntBitSet& b) noexcept { std::swap(a.m_val, b.m_val); }\n+};\n+\n+/** A bitset implementation backed by N integers of type I. */\n+template<typename I, unsigned N>\n+class MultiIntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The number of bits per integer. */\n+    static constexpr unsigned LIMB_BITS = std::numeric_limits<I>::digits;\n+    /** Number of elements this set type supports. */\n+    static constexpr unsigned MAX_SIZE = LIMB_BITS * N;\n+    /** Array whose member integers store the bits of the set. */\n+    std::array<I, N> m_val;\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class MultiIntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class MultiIntBitSet;\n+        const std::array<I, N>* m_ptr; /**< Pointer to array to fetch bits from. */\n+        I m_val; /**< The remaining bits of (*m_ptr)[m_idx]. */\n+        unsigned m_pos; /**< The last reported position. */\n+        unsigned m_idx; /**< The index in *m_ptr currently being iterated over. */\n+        constexpr Iterator(const std::array<I, N>* ptr) noexcept : m_ptr(ptr), m_idx(0)\n+        {\n+            do {\n+                m_val = (*m_ptr)[m_idx];\n+                if (m_val) {\n+                    m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                    break;\n+                }\n+                ++m_idx;\n+            } while(m_idx < N);\n+        }\n+\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        friend constexpr bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_idx == N;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val == 0) {\n+                while (true) {\n+                    ++m_idx;\n+                    if (m_idx == N) break;\n+                    m_val = (*m_ptr)[m_idx];\n+                    if (m_val) {\n+                        m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                        break;\n+                    }\n+                }\n+            } else {\n+                m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+            }\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr MultiIntBitSet() noexcept : m_val{} {}\n+    /** Copy construct a bitset. */\n+    constexpr MultiIntBitSet(const MultiIntBitSet&) noexcept = default;\n+    /** Copy assign a bitset. */\n+    constexpr MultiIntBitSet& operator=(const MultiIntBitSet&) noexcept = default;\n+    /** Set a bit to 1. */\n+    void constexpr Set(unsigned pos) noexcept { m_val[pos / LIMB_BITS] |= I{1U} << (pos % LIMB_BITS); }\n+    /** Set a bit to the specified value. */\n+    void constexpr Set(unsigned pos, bool val) noexcept { m_val[pos / LIMB_BITS] = (m_val[pos / LIMB_BITS] & ~I(I{1U} << (pos % LIMB_BITS))) | (I{val} << (pos % LIMB_BITS)); }\n+    /** Construct a bitset from a list of values. */\n+    constexpr MultiIntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val{}\n+    {\n+        for (auto i : ilist) Set(i);\n+    }\n+    /** Set a bitset to a list of values. */\n+    constexpr MultiIntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val.fill(0);\n+        for (auto i : ilist) Set(i);\n+        return *this;\n+    }\n+    /** Set a bit to 0. */\n+    void constexpr Reset(unsigned pos) noexcept { m_val[pos / LIMB_BITS] &= ~I(I{1U} << (pos % LIMB_BITS)); }\n+    /** Retrieve a bit at the given position. */\n+    bool constexpr operator[](unsigned pos) const noexcept { return (m_val[pos / LIMB_BITS] >> (pos % LIMB_BITS)) & 1U; }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr MultiIntBitSet Singleton(unsigned i) noexcept\n+    {\n+        MultiIntBitSet ret;\n+        ret.m_val[i / LIMB_BITS] = I{1U} << (i % LIMB_BITS);\n+        return ret;\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr MultiIntBitSet Fill(unsigned count) noexcept\n+    {\n+        MultiIntBitSet ret;\n+        if (count) {\n+            unsigned i = 0;\n+            while (count > LIMB_BITS) {\n+                ret.m_val[i++] = ~I{0};\n+                count -= LIMB_BITS;\n+            }\n+            ret.m_val[i] = I(~I{0}) >> (LIMB_BITS - count);\n+        }\n+        return ret;\n+    }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Compute the number of 1 bits in the bitset. */\n+    unsigned constexpr Count() const noexcept\n+    {\n+        unsigned ret{0};\n+        for (I v : m_val) ret += PopCount(v);\n+        return ret;\n+    }\n+    /** Check if all bits are 0. */\n+    bool constexpr None() const noexcept\n+    {\n+        for (auto v : m_val) {\n+            if (v != 0) return false;\n+        }\n+        return true;\n+    }\n+    /** Check if any bits are 1. */\n+    bool constexpr Any() const noexcept\n+    {\n+        for (auto v : m_val) {\n+            if (v != 0) return true;\n+        }\n+        return false;\n+    }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    Iterator constexpr begin() const noexcept { return Iterator(&m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    IteratorEnd constexpr end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    unsigned constexpr First() const noexcept\n+    {\n+        unsigned p = 0;\n+        while (m_val[p] == 0) ++p;\n+        return std::countr_zero(m_val[p]) + p * LIMB_BITS;\n+    }\n+    /** Find the last element (requires Any()). */\n+    unsigned constexpr Last() const noexcept\n+    {\n+        unsigned p = N - 1;\n+        while (m_val[p] == 0) --p;\n+        return std::bit_width(m_val[p]) - 1 + p * LIMB_BITS;\n+    }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr MultiIntBitSet& operator|=(const MultiIntBitSet& a) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            m_val[i] |= a.m_val[i];\n+        }\n+        return *this;\n+    }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr MultiIntBitSet& operator&=(const MultiIntBitSet& a) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            m_val[i] &= a.m_val[i];\n+        }\n+        return *this;\n+    }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr MultiIntBitSet& operator/=(const MultiIntBitSet& a) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            m_val[i] &= ~a.m_val[i];\n+        }\n+        return *this;\n+    }\n+    /** Set this object's bits to be the binary XOR between respective bits from this and a. */\n+    constexpr MultiIntBitSet& operator^=(const MultiIntBitSet& a) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            m_val[i] ^= a.m_val[i];\n+        }\n+        return *this;\n+    }\n+    /** Check whether the intersection between two sets is non-empty. */\n+    friend constexpr bool operator&&(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            if (a.m_val[i] & b.m_val[i]) return true;\n+        }\n+        return false;\n+    }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr MultiIntBitSet operator&(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        MultiIntBitSet r;\n+        for (unsigned i = 0; i < N; ++i) {\n+            r.m_val[i] = a.m_val[i] & b.m_val[i];\n+        }\n+        return r;\n+    }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr MultiIntBitSet operator|(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        MultiIntBitSet r;\n+        for (unsigned i = 0; i < N; ++i) {\n+            r.m_val[i] = a.m_val[i] | b.m_val[i];\n+        }\n+        return r;\n+    }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr MultiIntBitSet operator/(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        MultiIntBitSet r;\n+        for (unsigned i = 0; i < N; ++i) {\n+            r.m_val[i] = a.m_val[i] & ~b.m_val[i];\n+        }\n+        return r;\n+    }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr MultiIntBitSet operator^(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        MultiIntBitSet r;\n+        for (unsigned i = 0; i < N; ++i) {\n+            r.m_val[i] = a.m_val[i] ^ b.m_val[i];\n+        }\n+        return r;\n+    }\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    friend constexpr bool operator>=(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            if (b.m_val[i] & ~a.m_val[i]) return false;\n+        }\n+        return true;\n+    }\n+    /** Check if bitset a is a subset of bitset b (= every 1 bit in a is also in b). */\n+    friend constexpr bool operator<=(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept\n+    {\n+        for (unsigned i = 0; i < N; ++i) {\n+            if (a.m_val[i] & ~b.m_val[i]) return false;\n+        }\n+        return true;\n+    }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const MultiIntBitSet& a, const MultiIntBitSet& b) noexcept = default;\n+    /** Swap two bitsets. */\n+    friend constexpr void swap(MultiIntBitSet& a, MultiIntBitSet& b) noexcept { std::swap(a.m_val, b.m_val); }\n+};\n+\n+} // namespace bitset_detail\n+\n+// BitSet dispatches to IntBitSet or MultiIntBitSet as appropriate for the requested minimum number\n+// of bits.\n+template<unsigned BITS>\n+using BitSet = std::conditional_t<(BITS <= 32), bitset_detail::IntBitSet<uint32_t>,\n+               std::conditional_t<(BITS <= std::numeric_limits<size_t>::digits), bitset_detail::IntBitSet<size_t>,\n+               bitset_detail::MultiIntBitSet<size_t, (BITS + std::numeric_limits<size_t>::digits - 1) / std::numeric_limits<size_t>::digits>>>;",
      "path": "src/util/bitset.h",
      "position": 525,
      "original_position": 461,
      "commit_id": "47f705b33fc1381d96c99038e2110e6fe2b2f883",
      "original_commit_id": "aeef8a4dcf982cb76bca9571871196c4b25a1bdd",
      "in_reply_to_id": 1613105680,
      "user": {
        "login": "cbergqvist",
        "id": 581308,
        "node_id": "MDQ6VXNlcjU4MTMwOA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/581308?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/cbergqvist",
        "html_url": "https://github.com/cbergqvist",
        "followers_url": "https://api.github.com/users/cbergqvist/followers",
        "following_url": "https://api.github.com/users/cbergqvist/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/cbergqvist/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/cbergqvist/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/cbergqvist/subscriptions",
        "organizations_url": "https://api.github.com/users/cbergqvist/orgs",
        "repos_url": "https://api.github.com/users/cbergqvist/repos",
        "events_url": "https://api.github.com/users/cbergqvist/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/cbergqvist/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I'd consider SSE supporting CPUs quite common. Seems like using such instructions can offer efficiency gains but are sufficiently complex to write papers about - https://stackoverflow.com/a/42675620, something for the future maybe.",
      "created_at": "2024-05-28T12:50:32Z",
      "updated_at": "2024-05-28T12:50:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1617190868",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617190868"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": 524,
      "original_start_line": 460,
      "start_side": "RIGHT",
      "line": 525,
      "original_line": 525,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1618814697",
      "pull_request_review_id": 2085289550,
      "id": 1618814697,
      "node_id": "PRRC_kwDOABII585gfSbp",
      "diff_hunk": "@@ -0,0 +1,463 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a / b) implements \"a and not b\".\n+ * - Efficient subset/superset testing: (a <= b) and (a >= b).\n+ * - Efficient set overlap testing: a && b\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) m_val |= I{1U} << i;\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept {\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept {\n+        IntBitSet ret;\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept { m_val |= I{1U} << pos; }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept { m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos); }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept { m_val &= ~I(I{1U} << pos); }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept { return (m_val >> pos) & 1U; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept { return std::countr_zero(m_val); }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept { return std::bit_width(m_val) - 1; }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator/=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    friend constexpr bool operator&&(const IntBitSet& a, const IntBitSet& b) noexcept { return a.m_val & b.m_val; }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr IntBitSet operator&(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & b.m_val); }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator|(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val | b.m_val); }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr IntBitSet operator/(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & ~b.m_val); }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator^(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val ^ b.m_val); }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const IntBitSet& a, const IntBitSet& b) noexcept = default;\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    friend constexpr bool operator>=(const IntBitSet& a, const IntBitSet& b) noexcept { return (b.m_val & ~a.m_val) == 0; }\n+    /** Check if bitset a is a subset of bitset b (= every 1 bit in a is also in b). */\n+    friend constexpr bool operator<=(const IntBitSet& a, const IntBitSet& b) noexcept { return (a.m_val & ~b.m_val) == 0; }\n+    /** Swap two bitsets. */\n+    friend constexpr void swap(IntBitSet& a, IntBitSet& b) noexcept { std::swap(a.m_val, b.m_val); }\n+};\n+\n+/** A bitset implementation backed by N integers of type I. */\n+template<typename I, unsigned N>\n+class MultiIntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The number of bits per integer. */\n+    static constexpr unsigned LIMB_BITS = std::numeric_limits<I>::digits;\n+    /** Number of elements this set type supports. */\n+    static constexpr unsigned MAX_SIZE = LIMB_BITS * N;\n+    /** Array whose member integers store the bits of the set. */\n+    std::array<I, N> m_val;\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class MultiIntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class MultiIntBitSet;\n+        const std::array<I, N>* m_ptr; /**< Pointer to array to fetch bits from. */\n+        I m_val; /**< The remaining bits of (*m_ptr)[m_idx]. */\n+        unsigned m_pos; /**< The last reported position. */\n+        unsigned m_idx; /**< The index in *m_ptr currently being iterated over. */\n+        constexpr Iterator(const std::array<I, N>* ptr) noexcept : m_ptr(ptr), m_idx(0)\n+        {\n+            do {\n+                m_val = (*m_ptr)[m_idx];\n+                if (m_val) {\n+                    m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                    break;\n+                }\n+                ++m_idx;\n+            } while(m_idx < N);\n+        }\n+\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        friend constexpr bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_idx == N;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            m_val &= m_val - I{1U};\n+            if (m_val == 0) {\n+                while (true) {\n+                    ++m_idx;\n+                    if (m_idx == N) break;\n+                    m_val = (*m_ptr)[m_idx];\n+                    if (m_val) {\n+                        m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                        break;\n+                    }\n+                }\n+            } else {\n+                m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+            }\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr MultiIntBitSet() noexcept : m_val{} {}\n+    /** Copy construct a bitset. */\n+    constexpr MultiIntBitSet(const MultiIntBitSet&) noexcept = default;\n+    /** Copy assign a bitset. */\n+    constexpr MultiIntBitSet& operator=(const MultiIntBitSet&) noexcept = default;\n+    /** Set a bit to 1. */\n+    void constexpr Set(unsigned pos) noexcept { m_val[pos / LIMB_BITS] |= I{1U} << (pos % LIMB_BITS); }\n+    /** Set a bit to the specified value. */\n+    void constexpr Set(unsigned pos, bool val) noexcept { m_val[pos / LIMB_BITS] = (m_val[pos / LIMB_BITS] & ~I(I{1U} << (pos % LIMB_BITS))) | (I{val} << (pos % LIMB_BITS)); }\n+    /** Construct a bitset from a list of values. */\n+    constexpr MultiIntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val{}\n+    {\n+        for (auto i : ilist) Set(i);\n+    }\n+    /** Set a bitset to a list of values. */\n+    constexpr MultiIntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val.fill(0);\n+        for (auto i : ilist) Set(i);\n+        return *this;\n+    }\n+    /** Set a bit to 0. */\n+    void constexpr Reset(unsigned pos) noexcept { m_val[pos / LIMB_BITS] &= ~I(I{1U} << (pos % LIMB_BITS)); }\n+    /** Retrieve a bit at the given position. */\n+    bool constexpr operator[](unsigned pos) const noexcept { return (m_val[pos / LIMB_BITS] >> (pos % LIMB_BITS)) & 1U; }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr MultiIntBitSet Singleton(unsigned i) noexcept\n+    {\n+        MultiIntBitSet ret;\n+        ret.m_val[i / LIMB_BITS] = I{1U} << (i % LIMB_BITS);\n+        return ret;\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr MultiIntBitSet Fill(unsigned count) noexcept\n+    {\n+        MultiIntBitSet ret;\n+        if (count) {\n+            unsigned i = 0;\n+            while (count > LIMB_BITS) {\n+                ret.m_val[i++] = ~I{0};\n+                count -= LIMB_BITS;\n+            }\n+            ret.m_val[i] = I(~I{0}) >> (LIMB_BITS - count);",
      "path": "src/util/bitset.h",
      "position": 372,
      "original_position": 309,
      "commit_id": "47f705b33fc1381d96c99038e2110e6fe2b2f883",
      "original_commit_id": "aeef8a4dcf982cb76bca9571871196c4b25a1bdd",
      "in_reply_to_id": 1613223825,
      "user": {
        "login": "cbergqvist",
        "id": 581308,
        "node_id": "MDQ6VXNlcjU4MTMwOA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/581308?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/cbergqvist",
        "html_url": "https://github.com/cbergqvist",
        "followers_url": "https://api.github.com/users/cbergqvist/followers",
        "following_url": "https://api.github.com/users/cbergqvist/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/cbergqvist/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/cbergqvist/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/cbergqvist/subscriptions",
        "organizations_url": "https://api.github.com/users/cbergqvist/orgs",
        "repos_url": "https://api.github.com/users/cbergqvist/repos",
        "events_url": "https://api.github.com/users/cbergqvist/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/cbergqvist/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Added `std::conditional_t<(BITS <= 16), bitset_detail::IntBitSet<uint16_t>, ... ` and removed the `I()`, wrote unit test in bc36241f5a0a23d16645155eb819e94b0db2813e, and it indeed proves you are correct. Right now it cannot occur since `IntBitSet<uint32_t>` is the smallest we go, but better not to leave loaded footguns lying around.\r\n\r\n<details>\r\n<summary>Test Log</summary>\r\n\r\n```\r\n$ src/test/test_bitcoin -t bitset_tests\r\n...\r\nRunning 1 test case...\r\ntest/bitset_tests.cpp(18): error: in \"bitset_tests/bitset_test_15\": check std::popcount(sim) == set.Count() has failed [1 != 16]\r\ntest/bitset_tests.cpp(18): error: in \"bitset_tests/bitset_test_15\": check std::popcount(sim) == set.Count() has failed [2 != 16]\r\ntest/bitset_tests.cpp(18): error: in \"bitset_tests/bitset_test_15\": check std::popcount(sim) == set.Count() has failed [3 != 16]\r\ntest/bitset_tests.cpp(18): error: in \"bitset_tests/bitset_test_15\": check std::popcount(sim) == set.Count() has failed [4 != 16]\r\ntest/bitset_tests.cpp(18): error: in \"bitset_tests/bitset_test_15\": check std::popcount(sim) == set.Count() has failed [5 != 16]\r\ntest/bitset_tests.cpp(18): error: in \"bitset_tests/bitset_test_15\": check std::popcount(sim) == set.Count() has failed [6 != 16]\r\ntest/bitset_tests.cpp(18): error: in \"bitset_tests/bitset_test_15\": check std::popcount(sim) == set.Count() has failed [7 != 16]\r\ntest/bitset_tests.cpp(18): error: in \"bitset_tests/bitset_test_15\": check std::popcount(sim) == set.Count() has failed [8 != 16]\r\ntest/bitset_tests.cpp(18): error: in \"bitset_tests/bitset_test_15\": check std::popcount(sim) == set.Count() has failed [9 != 16]\r\ntest/bitset_tests.cpp(18): error: in \"bitset_tests/bitset_test_15\": check std::popcount(sim) == set.Count() has failed [10 != 16]\r\ntest/bitset_tests.cpp(18): error: in \"bitset_tests/bitset_test_15\": check std::popcount(sim) == set.Count() has failed [11 != 16]\r\ntest/bitset_tests.cpp(18): error: in \"bitset_tests/bitset_test_15\": check std::popcount(sim) == set.Count() has failed [12 != 16]\r\ntest/bitset_tests.cpp(18): error: in \"bitset_tests/bitset_test_15\": check std::popcount(sim) == set.Count() has failed [13 != 16]\r\ntest/bitset_tests.cpp(18): error: in \"bitset_tests/bitset_test_15\": check std::popcount(sim) == set.Count() has failed [14 != 16]\r\ntest/bitset_tests.cpp(18): error: in \"bitset_tests/bitset_test_15\": check std::popcount(sim) == set.Count() has failed [15 != 16]\r\n```\r\n</details>",
      "created_at": "2024-05-29T12:41:44Z",
      "updated_at": "2024-05-29T12:41:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1618814697",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1618814697"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 372,
      "original_line": 372,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1620960269",
      "pull_request_review_id": 2088636268,
      "id": 1620960269,
      "node_id": "PRRC_kwDOABII585gneQN",
      "diff_hunk": "@@ -0,0 +1,300 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/bitset.h>\n+\n+#include <bitset>\n+#include <vector>\n+\n+namespace {\n+\n+/** Pop the first byte from a Span<const uint8_t>, and return it. */\n+uint8_t ReadByte(Span<const uint8_t>& buffer)\n+{\n+    if (buffer.empty()) return 0;\n+    uint8_t ret = buffer.front();\n+    buffer = buffer.subspan(1);\n+    return ret;\n+}\n+\n+/** Perform a simulation fuzz test on BitSet type S. */\n+template<typename S>\n+void TestType(Span<const uint8_t> buffer)\n+{\n+    XoRoShiRo128PlusPlus rng(buffer.size() + 0x10000 * S::Size());",
      "path": "src/test/fuzz/bitset.cpp",
      "position": 32,
      "original_position": 28,
      "commit_id": "47f705b33fc1381d96c99038e2110e6fe2b2f883",
      "original_commit_id": "18ec3fc0bde855d777ba702f0a0a5d5a4d323cba",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "can you motivate this seed in a comment?",
      "created_at": "2024-05-30T15:30:30Z",
      "updated_at": "2024-06-03T20:41:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1620960269",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1620960269"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 32,
      "original_line": 32,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1621072544",
      "pull_request_review_id": 2088636268,
      "id": 1621072544,
      "node_id": "PRRC_kwDOABII585gn5qg",
      "diff_hunk": "@@ -0,0 +1,300 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/bitset.h>\n+\n+#include <bitset>\n+#include <vector>\n+\n+namespace {\n+\n+/** Pop the first byte from a Span<const uint8_t>, and return it. */\n+uint8_t ReadByte(Span<const uint8_t>& buffer)\n+{\n+    if (buffer.empty()) return 0;\n+    uint8_t ret = buffer.front();\n+    buffer = buffer.subspan(1);\n+    return ret;\n+}\n+\n+/** Perform a simulation fuzz test on BitSet type S. */\n+template<typename S>\n+void TestType(Span<const uint8_t> buffer)\n+{\n+    XoRoShiRo128PlusPlus rng(buffer.size() + 0x10000 * S::Size());\n+\n+    using Sim = std::bitset<S::Size()>;\n+    // Up to 4 real BitSets (initially 2).\n+    std::vector<S> real(2);\n+    // Up to 4 std::bitsets with the same corresponding contents.\n+    std::vector<Sim> sim(2);\n+\n+    /* Compare sim[idx] with real[idx], using all inspector operations. */\n+    auto compare_fn = [&](unsigned idx) {\n+        /* iterators and operator[] */\n+        auto it = real[idx].begin();\n+        unsigned first = S::Size();\n+        unsigned last = S::Size();\n+        for (unsigned i = 0; i < S::Size(); ++i) {\n+            bool match = (it != real[idx].end()) && *it == i;\n+            assert(sim[idx][i] == real[idx][i]);\n+            assert(match == real[idx][i]);\n+            assert((it == real[idx].end()) != (it != real[idx].end()));\n+            if (match) {\n+                ++it;\n+                if (first == S::Size()) first = i;\n+                last = i;\n+            }\n+        }\n+        assert(it == real[idx].end());\n+        assert(!(it != real[idx].end()));\n+        /* Any / None */\n+        assert(sim[idx].any() == real[idx].Any());\n+        assert(sim[idx].none() == real[idx].None());\n+        /* First */\n+        if (sim[idx].any()) {\n+            assert(first == real[idx].First());\n+            assert(last == real[idx].Last());\n+        }\n+        /* Count */\n+        assert(sim[idx].count() == real[idx].Count());\n+    };\n+\n+    LIMITED_WHILE(buffer.size() > 0, 1000) {\n+        int command = ReadByte(buffer) % 64;\n+        unsigned args = ReadByte(buffer);\n+        unsigned dest = ((args & 7) * sim.size()) >> 3;\n+        unsigned src = (((args >> 3) & 7) * sim.size()) >> 3;\n+        unsigned aux = (((args >> 6) & 3) * sim.size()) >> 2;",
      "path": "src/test/fuzz/bitset.cpp",
      "position": 78,
      "original_position": 72,
      "commit_id": "47f705b33fc1381d96c99038e2110e6fe2b2f883",
      "original_commit_id": "18ec3fc0bde855d777ba702f0a0a5d5a4d323cba",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "If this is true, this helps my understanding of the code to follow, knowing that each loop below will eventually terminate.\r\n```Suggestion\r\n        unsigned aux = (((args >> 6) & 3) * sim.size()) >> 2;\r\n        // Args are in range for non-empty sim, or sim is completely empty and will be grown\r\n        assert((sim.empty() && dest == 0 && src == 0 && aux == 0) ||\r\n            (!sim.empty() &&  dest < sim.size() && src < sim.size() && aux < sim.size()));\r\n\r\n```",
      "created_at": "2024-05-30T16:41:44Z",
      "updated_at": "2024-06-03T20:41:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1621072544",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1621072544"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 78,
      "original_line": 78,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1621275746",
      "pull_request_review_id": 2088636268,
      "id": 1621275746,
      "node_id": "PRRC_kwDOABII585gorRi",
      "diff_hunk": "@@ -0,0 +1,521 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <util/check.h>\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a - b) implements \"a and not b\".\n+ * - Efficient non-strict subset/superset testing: IsSubsetOf() and IsSupersetOf().\n+ * - Efficient set overlap testing: a.Overlaps(b)\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            Assume(m_val != 0);\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept\n+    {\n+        Assume(i < MAX_SIZE);\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept\n+    {\n+        IntBitSet ret;\n+        Assume(count <= MAX_SIZE);\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val |= I{1U} << pos;\n+    }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos);\n+    }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val &= ~I(I{1U} << pos);\n+    }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        return (m_val >> pos) & 1U;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept { return std::countr_zero(m_val); }\n+    /** Find the last element (requires Any()). */",
      "path": "src/util/bitset.h",
      "position": 192,
      "original_position": 190,
      "commit_id": "47f705b33fc1381d96c99038e2110e6fe2b2f883",
      "original_commit_id": "a1a0c4c2bc4e6add52f8dfb03788ed2bb2dabbf1",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Could we add `Assume()`/`Assert()`s rather than comments here and above?",
      "created_at": "2024-05-30T18:40:27Z",
      "updated_at": "2024-06-03T20:41:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1621275746",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1621275746"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 192,
      "original_line": 192,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1624946699",
      "pull_request_review_id": 2088636268,
      "id": 1624946699,
      "node_id": "PRRC_kwDOABII585g2rgL",
      "diff_hunk": "@@ -0,0 +1,521 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <util/check.h>\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a - b) implements \"a and not b\".\n+ * - Efficient non-strict subset/superset testing: IsSubsetOf() and IsSupersetOf().\n+ * - Efficient set overlap testing: a.Overlaps(b)\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)",
      "path": "src/util/bitset.h",
      "position": 38,
      "original_position": 38,
      "commit_id": "47f705b33fc1381d96c99038e2110e6fe2b2f883",
      "original_commit_id": "a1a0c4c2bc4e6add52f8dfb03788ed2bb2dabbf1",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "did you consider using `std::popcount` instead?",
      "created_at": "2024-06-03T19:30:57Z",
      "updated_at": "2024-06-03T20:41:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1624946699",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1624946699"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 38,
      "original_line": 38,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626157391",
      "pull_request_review_id": 2096649215,
      "id": 1626157391,
      "node_id": "PRRC_kwDOABII585g7TFP",
      "diff_hunk": "@@ -0,0 +1,300 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/bitset.h>\n+\n+#include <bitset>\n+#include <vector>\n+\n+namespace {\n+\n+/** Pop the first byte from a Span<const uint8_t>, and return it. */\n+uint8_t ReadByte(Span<const uint8_t>& buffer)\n+{\n+    if (buffer.empty()) return 0;\n+    uint8_t ret = buffer.front();\n+    buffer = buffer.subspan(1);\n+    return ret;\n+}\n+\n+/** Perform a simulation fuzz test on BitSet type S. */\n+template<typename S>\n+void TestType(Span<const uint8_t> buffer)\n+{\n+    XoRoShiRo128PlusPlus rng(buffer.size() + 0x10000 * S::Size());\n+\n+    using Sim = std::bitset<S::Size()>;\n+    // Up to 4 real BitSets (initially 2).\n+    std::vector<S> real(2);\n+    // Up to 4 std::bitsets with the same corresponding contents.\n+    std::vector<Sim> sim(2);\n+\n+    /* Compare sim[idx] with real[idx], using all inspector operations. */\n+    auto compare_fn = [&](unsigned idx) {\n+        /* iterators and operator[] */\n+        auto it = real[idx].begin();\n+        unsigned first = S::Size();\n+        unsigned last = S::Size();\n+        for (unsigned i = 0; i < S::Size(); ++i) {\n+            bool match = (it != real[idx].end()) && *it == i;\n+            assert(sim[idx][i] == real[idx][i]);\n+            assert(match == real[idx][i]);\n+            assert((it == real[idx].end()) != (it != real[idx].end()));\n+            if (match) {\n+                ++it;\n+                if (first == S::Size()) first = i;\n+                last = i;\n+            }\n+        }\n+        assert(it == real[idx].end());\n+        assert(!(it != real[idx].end()));\n+        /* Any / None */\n+        assert(sim[idx].any() == real[idx].Any());\n+        assert(sim[idx].none() == real[idx].None());\n+        /* First */\n+        if (sim[idx].any()) {\n+            assert(first == real[idx].First());\n+            assert(last == real[idx].Last());\n+        }\n+        /* Count */\n+        assert(sim[idx].count() == real[idx].Count());\n+    };\n+\n+    LIMITED_WHILE(buffer.size() > 0, 1000) {\n+        int command = ReadByte(buffer) % 64;\n+        unsigned args = ReadByte(buffer);\n+        unsigned dest = ((args & 7) * sim.size()) >> 3;\n+        unsigned src = (((args >> 3) & 7) * sim.size()) >> 3;\n+        unsigned aux = (((args >> 6) & 3) * sim.size()) >> 2;\n+        // Loop until command reaches 0. This way, every iteration will cause one operation",
      "path": "src/test/fuzz/bitset.cpp",
      "position": null,
      "original_position": 73,
      "commit_id": "47f705b33fc1381d96c99038e2110e6fe2b2f883",
      "original_commit_id": "18ec3fc0bde855d777ba702f0a0a5d5a4d323cba",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I like the comment in the VecDeque PR better if you'd care to just copy it here: https://github.com/bitcoin/bitcoin/pull/30161/commits/ecb278bb19c53b007380e262fa86d809255eeb49#diff-1f28310f089eac74210ecbc0db2083279282ade962dc464bd31448480dc5563dR59",
      "created_at": "2024-06-04T14:49:18Z",
      "updated_at": "2024-06-04T14:49:19Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1626157391",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626157391"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 73,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626264025",
      "pull_request_review_id": 2096825133,
      "id": 1626264025,
      "node_id": "PRRC_kwDOABII585g7tHZ",
      "diff_hunk": "@@ -0,0 +1,300 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/bitset.h>\n+\n+#include <bitset>\n+#include <vector>\n+\n+namespace {\n+\n+/** Pop the first byte from a Span<const uint8_t>, and return it. */\n+uint8_t ReadByte(Span<const uint8_t>& buffer)\n+{\n+    if (buffer.empty()) return 0;\n+    uint8_t ret = buffer.front();\n+    buffer = buffer.subspan(1);\n+    return ret;\n+}\n+\n+/** Perform a simulation fuzz test on BitSet type S. */\n+template<typename S>\n+void TestType(Span<const uint8_t> buffer)\n+{\n+    XoRoShiRo128PlusPlus rng(buffer.size() + 0x10000 * S::Size());",
      "path": "src/test/fuzz/bitset.cpp",
      "position": 32,
      "original_position": 28,
      "commit_id": "47f705b33fc1381d96c99038e2110e6fe2b2f883",
      "original_commit_id": "18ec3fc0bde855d777ba702f0a0a5d5a4d323cba",
      "in_reply_to_id": 1620960269,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done, let me know if this is better.",
      "created_at": "2024-06-04T15:57:06Z",
      "updated_at": "2024-06-04T15:57:07Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1626264025",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626264025"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 32,
      "original_line": 32,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626264244",
      "pull_request_review_id": 2096825466,
      "id": 1626264244,
      "node_id": "PRRC_kwDOABII585g7tK0",
      "diff_hunk": "@@ -0,0 +1,300 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/bitset.h>\n+\n+#include <bitset>\n+#include <vector>\n+\n+namespace {\n+\n+/** Pop the first byte from a Span<const uint8_t>, and return it. */\n+uint8_t ReadByte(Span<const uint8_t>& buffer)\n+{\n+    if (buffer.empty()) return 0;\n+    uint8_t ret = buffer.front();\n+    buffer = buffer.subspan(1);\n+    return ret;\n+}\n+\n+/** Perform a simulation fuzz test on BitSet type S. */\n+template<typename S>\n+void TestType(Span<const uint8_t> buffer)\n+{\n+    XoRoShiRo128PlusPlus rng(buffer.size() + 0x10000 * S::Size());\n+\n+    using Sim = std::bitset<S::Size()>;\n+    // Up to 4 real BitSets (initially 2).\n+    std::vector<S> real(2);\n+    // Up to 4 std::bitsets with the same corresponding contents.\n+    std::vector<Sim> sim(2);\n+\n+    /* Compare sim[idx] with real[idx], using all inspector operations. */\n+    auto compare_fn = [&](unsigned idx) {\n+        /* iterators and operator[] */\n+        auto it = real[idx].begin();\n+        unsigned first = S::Size();\n+        unsigned last = S::Size();\n+        for (unsigned i = 0; i < S::Size(); ++i) {\n+            bool match = (it != real[idx].end()) && *it == i;\n+            assert(sim[idx][i] == real[idx][i]);\n+            assert(match == real[idx][i]);\n+            assert((it == real[idx].end()) != (it != real[idx].end()));\n+            if (match) {\n+                ++it;\n+                if (first == S::Size()) first = i;\n+                last = i;\n+            }\n+        }\n+        assert(it == real[idx].end());\n+        assert(!(it != real[idx].end()));\n+        /* Any / None */\n+        assert(sim[idx].any() == real[idx].Any());\n+        assert(sim[idx].none() == real[idx].None());\n+        /* First */\n+        if (sim[idx].any()) {\n+            assert(first == real[idx].First());\n+            assert(last == real[idx].Last());\n+        }\n+        /* Count */\n+        assert(sim[idx].count() == real[idx].Count());\n+    };\n+\n+    LIMITED_WHILE(buffer.size() > 0, 1000) {\n+        int command = ReadByte(buffer) % 64;\n+        unsigned args = ReadByte(buffer);\n+        unsigned dest = ((args & 7) * sim.size()) >> 3;\n+        unsigned src = (((args >> 3) & 7) * sim.size()) >> 3;\n+        unsigned aux = (((args >> 6) & 3) * sim.size()) >> 2;",
      "path": "src/test/fuzz/bitset.cpp",
      "position": 78,
      "original_position": 72,
      "commit_id": "47f705b33fc1381d96c99038e2110e6fe2b2f883",
      "original_commit_id": "18ec3fc0bde855d777ba702f0a0a5d5a4d323cba",
      "in_reply_to_id": 1621072544,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Added.",
      "created_at": "2024-06-04T15:57:16Z",
      "updated_at": "2024-06-04T15:57:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1626264244",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626264244"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 78,
      "original_line": 78,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626264403",
      "pull_request_review_id": 2096825758,
      "id": 1626264403,
      "node_id": "PRRC_kwDOABII585g7tNT",
      "diff_hunk": "@@ -0,0 +1,521 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <util/check.h>\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a - b) implements \"a and not b\".\n+ * - Efficient non-strict subset/superset testing: IsSubsetOf() and IsSupersetOf().\n+ * - Efficient set overlap testing: a.Overlaps(b)\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than __builtin_popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            Assume(m_val != 0);\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept\n+    {\n+        Assume(i < MAX_SIZE);\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept\n+    {\n+        IntBitSet ret;\n+        Assume(count <= MAX_SIZE);\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val |= I{1U} << pos;\n+    }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos);\n+    }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val &= ~I(I{1U} << pos);\n+    }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        return (m_val >> pos) & 1U;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept { return std::countr_zero(m_val); }\n+    /** Find the last element (requires Any()). */",
      "path": "src/util/bitset.h",
      "position": 192,
      "original_position": 190,
      "commit_id": "47f705b33fc1381d96c99038e2110e6fe2b2f883",
      "original_commit_id": "a1a0c4c2bc4e6add52f8dfb03788ed2bb2dabbf1",
      "in_reply_to_id": 1621275746,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2024-06-04T15:57:22Z",
      "updated_at": "2024-06-04T15:57:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1626264403",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626264403"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 192,
      "original_line": 192,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626265719",
      "pull_request_review_id": 2096828139,
      "id": 1626265719,
      "node_id": "PRRC_kwDOABII585g7th3",
      "diff_hunk": "@@ -0,0 +1,521 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <util/check.h>\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a - b) implements \"a and not b\".\n+ * - Efficient non-strict subset/superset testing: IsSubsetOf() and IsSupersetOf().\n+ * - Efficient set overlap testing: a.Overlaps(b)\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)",
      "path": "src/util/bitset.h",
      "position": 38,
      "original_position": 38,
      "commit_id": "47f705b33fc1381d96c99038e2110e6fe2b2f883",
      "original_commit_id": "a1a0c4c2bc4e6add52f8dfb03788ed2bb2dabbf1",
      "in_reply_to_id": 1624946699,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Yes; but on GCC/stdlibc++, `std::popcount` just uses `__builtin_popcount`, which in benchmarks seems to perform worse than the code here. The I've updated the comment to reflect that (it was written before the C++20 switch which introduced `std::popcount`).",
      "created_at": "2024-06-04T15:58:17Z",
      "updated_at": "2024-06-04T15:58:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1626265719",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626265719"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 38,
      "original_line": 38,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626266141",
      "pull_request_review_id": 2096828845,
      "id": 1626266141,
      "node_id": "PRRC_kwDOABII585g7tod",
      "diff_hunk": "@@ -0,0 +1,300 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/bitset.h>\n+\n+#include <bitset>\n+#include <vector>\n+\n+namespace {\n+\n+/** Pop the first byte from a Span<const uint8_t>, and return it. */\n+uint8_t ReadByte(Span<const uint8_t>& buffer)\n+{\n+    if (buffer.empty()) return 0;\n+    uint8_t ret = buffer.front();\n+    buffer = buffer.subspan(1);\n+    return ret;\n+}\n+\n+/** Perform a simulation fuzz test on BitSet type S. */\n+template<typename S>\n+void TestType(Span<const uint8_t> buffer)\n+{\n+    XoRoShiRo128PlusPlus rng(buffer.size() + 0x10000 * S::Size());\n+\n+    using Sim = std::bitset<S::Size()>;\n+    // Up to 4 real BitSets (initially 2).\n+    std::vector<S> real(2);\n+    // Up to 4 std::bitsets with the same corresponding contents.\n+    std::vector<Sim> sim(2);\n+\n+    /* Compare sim[idx] with real[idx], using all inspector operations. */\n+    auto compare_fn = [&](unsigned idx) {\n+        /* iterators and operator[] */\n+        auto it = real[idx].begin();\n+        unsigned first = S::Size();\n+        unsigned last = S::Size();\n+        for (unsigned i = 0; i < S::Size(); ++i) {\n+            bool match = (it != real[idx].end()) && *it == i;\n+            assert(sim[idx][i] == real[idx][i]);\n+            assert(match == real[idx][i]);\n+            assert((it == real[idx].end()) != (it != real[idx].end()));\n+            if (match) {\n+                ++it;\n+                if (first == S::Size()) first = i;\n+                last = i;\n+            }\n+        }\n+        assert(it == real[idx].end());\n+        assert(!(it != real[idx].end()));\n+        /* Any / None */\n+        assert(sim[idx].any() == real[idx].Any());\n+        assert(sim[idx].none() == real[idx].None());\n+        /* First */\n+        if (sim[idx].any()) {\n+            assert(first == real[idx].First());\n+            assert(last == real[idx].Last());\n+        }\n+        /* Count */\n+        assert(sim[idx].count() == real[idx].Count());\n+    };\n+\n+    LIMITED_WHILE(buffer.size() > 0, 1000) {\n+        int command = ReadByte(buffer) % 64;\n+        unsigned args = ReadByte(buffer);\n+        unsigned dest = ((args & 7) * sim.size()) >> 3;\n+        unsigned src = (((args >> 3) & 7) * sim.size()) >> 3;\n+        unsigned aux = (((args >> 6) & 3) * sim.size()) >> 2;\n+        // Loop until command reaches 0. This way, every iteration will cause one operation",
      "path": "src/test/fuzz/bitset.cpp",
      "position": null,
      "original_position": 73,
      "commit_id": "47f705b33fc1381d96c99038e2110e6fe2b2f883",
      "original_commit_id": "18ec3fc0bde855d777ba702f0a0a5d5a4d323cba",
      "in_reply_to_id": 1626157391,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done. Credit to @glozow.",
      "created_at": "2024-06-04T15:58:37Z",
      "updated_at": "2024-06-04T15:58:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1626266141",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626266141"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 73,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626267484",
      "pull_request_review_id": 2096831131,
      "id": 1626267484,
      "node_id": "PRRC_kwDOABII585g7t9c",
      "diff_hunk": "@@ -0,0 +1,521 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <util/check.h>\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a - b) implements \"a and not b\".\n+ * - Efficient non-strict subset/superset testing: IsSubsetOf() and IsSupersetOf().\n+ * - Efficient set overlap testing: a.Overlaps(b)\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)",
      "path": "src/util/bitset.h",
      "position": 38,
      "original_position": 38,
      "commit_id": "47f705b33fc1381d96c99038e2110e6fe2b2f883",
      "original_commit_id": "a1a0c4c2bc4e6add52f8dfb03788ed2bb2dabbf1",
      "in_reply_to_id": 1624946699,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "figured as much based on my investigation thanks",
      "created_at": "2024-06-04T15:59:36Z",
      "updated_at": "2024-06-04T15:59:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1626267484",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1626267484"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 38,
      "original_line": 38,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1627806235",
      "pull_request_review_id": 2099239010,
      "id": 1627806235,
      "node_id": "PRRC_kwDOABII585hBlob",
      "diff_hunk": "@@ -0,0 +1,300 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/bitset.h>\n+\n+#include <bitset>\n+#include <vector>\n+\n+namespace {\n+\n+/** Pop the first byte from a Span<const uint8_t>, and return it. */\n+uint8_t ReadByte(Span<const uint8_t>& buffer)\n+{\n+    if (buffer.empty()) return 0;\n+    uint8_t ret = buffer.front();\n+    buffer = buffer.subspan(1);\n+    return ret;\n+}\n+\n+/** Perform a simulation fuzz test on BitSet type S. */\n+template<typename S>\n+void TestType(Span<const uint8_t> buffer)\n+{\n+    XoRoShiRo128PlusPlus rng(buffer.size() + 0x10000 * S::Size());",
      "path": "src/test/fuzz/bitset.cpp",
      "position": 32,
      "original_position": 28,
      "commit_id": "47f705b33fc1381d96c99038e2110e6fe2b2f883",
      "original_commit_id": "18ec3fc0bde855d777ba702f0a0a5d5a4d323cba",
      "in_reply_to_id": 1620960269,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "perfect thanks",
      "created_at": "2024-06-05T13:38:39Z",
      "updated_at": "2024-06-05T13:38:39Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1627806235",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1627806235"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 32,
      "original_line": 32,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1630102455",
      "pull_request_review_id": 2103029469,
      "id": 1630102455,
      "node_id": "PRRC_kwDOABII585hKWO3",
      "diff_hunk": "@@ -0,0 +1,529 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <util/check.h>\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a - b) implements \"a and not b\".\n+ * - Efficient non-strict subset/superset testing: IsSubsetOf() and IsSupersetOf().\n+ * - Efficient set overlap testing: a.Overlaps(b)\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than std::popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);",
      "path": "src/util/bitset.h",
      "position": 65,
      "original_position": 65,
      "commit_id": "47f705b33fc1381d96c99038e2110e6fe2b2f883",
      "original_commit_id": "c99063e902c810dde1742696b3140610120d391c",
      "in_reply_to_id": null,
      "user": {
        "login": "cbergqvist",
        "id": 581308,
        "node_id": "MDQ6VXNlcjU4MTMwOA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/581308?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/cbergqvist",
        "html_url": "https://github.com/cbergqvist",
        "followers_url": "https://api.github.com/users/cbergqvist/followers",
        "following_url": "https://api.github.com/users/cbergqvist/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/cbergqvist/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/cbergqvist/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/cbergqvist/subscriptions",
        "organizations_url": "https://api.github.com/users/cbergqvist/orgs",
        "repos_url": "https://api.github.com/users/cbergqvist/repos",
        "events_url": "https://api.github.com/users/cbergqvist/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/cbergqvist/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Why not use the ability to put the descriptions inside the `static_assert()`s here and elsewhere?\r\n```suggestion\r\n    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2,\r\n        \"Only binary, unsigned, integer, types allowed.\");\r\n```",
      "created_at": "2024-06-06T19:21:05Z",
      "updated_at": "2024-06-06T19:29:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1630102455",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1630102455"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": 64,
      "original_start_line": 64,
      "start_side": "RIGHT",
      "line": 65,
      "original_line": 65,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1630120206",
      "pull_request_review_id": 2103053367,
      "id": 1630120206,
      "node_id": "PRRC_kwDOABII585hKakO",
      "diff_hunk": "@@ -0,0 +1,529 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <util/check.h>\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a - b) implements \"a and not b\".\n+ * - Efficient non-strict subset/superset testing: IsSubsetOf() and IsSupersetOf().\n+ * - Efficient set overlap testing: a.Overlaps(b)\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than std::popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);",
      "path": "src/util/bitset.h",
      "position": 65,
      "original_position": 65,
      "commit_id": "47f705b33fc1381d96c99038e2110e6fe2b2f883",
      "original_commit_id": "c99063e902c810dde1742696b3140610120d391c",
      "in_reply_to_id": 1630102455,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I think the condition is sufficiently self-descriptive that this isn't really needed (the compiler error emitted will report the line causing it anyway). And I still like to have a comment on all top-level statements/definitions inside a class, even if it's trivial, just for organization purposes.",
      "created_at": "2024-06-06T19:34:46Z",
      "updated_at": "2024-06-06T19:34:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1630120206",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1630120206"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": 64,
      "original_start_line": 64,
      "start_side": "RIGHT",
      "line": 65,
      "original_line": 65,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1631335816",
      "pull_request_review_id": 2104783238,
      "id": 1631335816,
      "node_id": "PRRC_kwDOABII585hPDWI",
      "diff_hunk": "@@ -0,0 +1,529 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <util/check.h>\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a - b) implements \"a and not b\".\n+ * - Efficient non-strict subset/superset testing: IsSubsetOf() and IsSupersetOf().\n+ * - Efficient set overlap testing: a.Overlaps(b)\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than std::popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            Assume(m_val != 0);\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */",
      "path": "src/util/bitset.h",
      "position": null,
      "original_position": 128,
      "commit_id": "47f705b33fc1381d96c99038e2110e6fe2b2f883",
      "original_commit_id": "9aff4cb9446fedf99e8e212ce1db823c9dd0d03c",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```Suggestion\r\n    /** Assign from a list of positional values. */\r\n```",
      "created_at": "2024-06-07T14:49:46Z",
      "updated_at": "2024-06-07T16:07:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1631335816",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1631335816"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 128,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1631369553",
      "pull_request_review_id": 2104783238,
      "id": 1631369553,
      "node_id": "PRRC_kwDOABII585hPLlR",
      "diff_hunk": "@@ -0,0 +1,311 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/bitset.h>\n+\n+#include <bitset>\n+#include <vector>\n+\n+namespace {\n+\n+/** Pop the first byte from a Span<const uint8_t>, and return it. */\n+uint8_t ReadByte(Span<const uint8_t>& buffer)\n+{\n+    if (buffer.empty()) return 0;\n+    uint8_t ret = buffer.front();\n+    buffer = buffer.subspan(1);\n+    return ret;\n+}\n+\n+/** Perform a simulation fuzz test on BitSet type S. */\n+template<typename S>\n+void TestType(Span<const uint8_t> buffer)\n+{\n+    /** This fuzz test's design is based on the assumption that the actual bits stored in the\n+     *  bitsets and their simulations do not matter for the purpose of detecting edge cases, thus\n+     *  these are taken from a deterministically-seeded RNG instead. To provide some level of\n+     *  variation however, pick the seed based on the buffer size and size of the chosen bitset. */\n+    XoRoShiRo128PlusPlus rng(buffer.size() + 0x10000 * S::Size());\n+\n+    using Sim = std::bitset<S::Size()>;\n+    // Up to 4 real BitSets (initially 2).\n+    std::vector<S> real(2);\n+    // Up to 4 std::bitsets with the same corresponding contents.\n+    std::vector<Sim> sim(2);\n+\n+    /* Compare sim[idx] with real[idx], using all inspector operations. */\n+    auto compare_fn = [&](unsigned idx) {\n+        /* iterators and operator[] */\n+        auto it = real[idx].begin();\n+        unsigned first = S::Size();\n+        unsigned last = S::Size();\n+        for (unsigned i = 0; i < S::Size(); ++i) {\n+            bool match = (it != real[idx].end()) && *it == i;\n+            assert(sim[idx][i] == real[idx][i]);\n+            assert(match == real[idx][i]);\n+            assert((it == real[idx].end()) != (it != real[idx].end()));\n+            if (match) {\n+                ++it;\n+                if (first == S::Size()) first = i;\n+                last = i;\n+            }\n+        }\n+        assert(it == real[idx].end());\n+        assert(!(it != real[idx].end()));\n+        /* Any / None */\n+        assert(sim[idx].any() == real[idx].Any());\n+        assert(sim[idx].none() == real[idx].None());\n+        /* First */",
      "path": "src/test/fuzz/bitset.cpp",
      "position": null,
      "original_position": 62,
      "commit_id": "47f705b33fc1381d96c99038e2110e6fe2b2f883",
      "original_commit_id": "c99063e902c810dde1742696b3140610120d391c",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```Suggestion\r\n        /* First / Last */\r\n```",
      "created_at": "2024-06-07T15:17:16Z",
      "updated_at": "2024-06-07T16:07:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1631369553",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1631369553"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 62,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1631393064",
      "pull_request_review_id": 2104783238,
      "id": 1631393064,
      "node_id": "PRRC_kwDOABII585hPRUo",
      "diff_hunk": "@@ -0,0 +1,529 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <util/check.h>\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a - b) implements \"a and not b\".\n+ * - Efficient non-strict subset/superset testing: IsSubsetOf() and IsSupersetOf().\n+ * - Efficient set overlap testing: a.Overlaps(b)\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than std::popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            Assume(m_val != 0);\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept\n+    {\n+        Assume(i < MAX_SIZE);\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept\n+    {\n+        IntBitSet ret;\n+        Assume(count <= MAX_SIZE);\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val |= I{1U} << pos;\n+    }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos);\n+    }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val &= ~I(I{1U} << pos);\n+    }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        return (m_val >> pos) & 1U;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept\n+    {\n+        Assume(m_val != 0);\n+        return std::countr_zero(m_val);\n+    }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept\n+    {\n+        Assume(m_val != 0);\n+        return std::bit_width(m_val) - 1;\n+    }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator-=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    constexpr bool Overlaps(const IntBitSet& a) const noexcept { return m_val & a.m_val; }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr IntBitSet operator&(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & b.m_val); }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator|(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val | b.m_val); }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr IntBitSet operator-(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & ~b.m_val); }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator^(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val ^ b.m_val); }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const IntBitSet& a, const IntBitSet& b) noexcept = default;\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    constexpr bool IsSupersetOf(const IntBitSet& a) const noexcept { return (a.m_val & ~m_val) == 0; }\n+    /** Check if bitset a is a subset of bitset b (= every 1 bit in a is also in b). */\n+    constexpr bool IsSubsetOf(const IntBitSet& a) const noexcept { return (m_val & ~a.m_val) == 0; }\n+    /** Swap two bitsets. */\n+    friend constexpr void swap(IntBitSet& a, IntBitSet& b) noexcept { std::swap(a.m_val, b.m_val); }",
      "path": "src/util/bitset.h",
      "position": 223,
      "original_position": 225,
      "commit_id": "47f705b33fc1381d96c99038e2110e6fe2b2f883",
      "original_commit_id": "9aff4cb9446fedf99e8e212ce1db823c9dd0d03c",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "lacks coverage? \r\n\r\nmy local coverage generation is kinda screwed up, but fuzz coverage should be computed :pray: ",
      "created_at": "2024-06-07T15:37:19Z",
      "updated_at": "2024-06-07T16:07:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1631393064",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1631393064"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 223,
      "original_line": 223,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1631403413",
      "pull_request_review_id": 2104783238,
      "id": 1631403413,
      "node_id": "PRRC_kwDOABII585hPT2V",
      "diff_hunk": "@@ -0,0 +1,529 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <util/check.h>\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a - b) implements \"a and not b\".\n+ * - Efficient non-strict subset/superset testing: IsSubsetOf() and IsSupersetOf().\n+ * - Efficient set overlap testing: a.Overlaps(b)\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than std::popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            Assume(m_val != 0);\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;",
      "path": "src/util/bitset.h",
      "position": null,
      "original_position": 134,
      "commit_id": "47f705b33fc1381d96c99038e2110e6fe2b2f883",
      "original_commit_id": "9aff4cb9446fedf99e8e212ce1db823c9dd0d03c",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Set(i)?",
      "created_at": "2024-06-07T15:46:37Z",
      "updated_at": "2024-06-07T16:07:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1631403413",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1631403413"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 134,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1631403529",
      "pull_request_review_id": 2104783238,
      "id": 1631403529,
      "node_id": "PRRC_kwDOABII585hPT4J",
      "diff_hunk": "@@ -0,0 +1,529 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <util/check.h>\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a - b) implements \"a and not b\".\n+ * - Efficient non-strict subset/superset testing: IsSubsetOf() and IsSupersetOf().\n+ * - Efficient set overlap testing: a.Overlaps(b)\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than std::popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            Assume(m_val != 0);\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;",
      "path": "src/util/bitset.h",
      "position": null,
      "original_position": 123,
      "commit_id": "47f705b33fc1381d96c99038e2110e6fe2b2f883",
      "original_commit_id": "9aff4cb9446fedf99e8e212ce1db823c9dd0d03c",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Set(i)",
      "created_at": "2024-06-07T15:46:43Z",
      "updated_at": "2024-06-07T16:07:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1631403529",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1631403529"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 123,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1631406724",
      "pull_request_review_id": 2104783238,
      "id": 1631406724,
      "node_id": "PRRC_kwDOABII585hPUqE",
      "diff_hunk": "@@ -0,0 +1,529 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <util/check.h>\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a - b) implements \"a and not b\".\n+ * - Efficient non-strict subset/superset testing: IsSubsetOf() and IsSupersetOf().\n+ * - Efficient set overlap testing: a.Overlaps(b)\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than std::popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            Assume(m_val != 0);\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept\n+    {\n+        Assume(i < MAX_SIZE);\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept\n+    {\n+        IntBitSet ret;\n+        Assume(count <= MAX_SIZE);\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val |= I{1U} << pos;\n+    }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos);\n+    }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val &= ~I(I{1U} << pos);",
      "path": "src/util/bitset.h",
      "position": 166,
      "original_position": 168,
      "commit_id": "47f705b33fc1381d96c99038e2110e6fe2b2f883",
      "original_commit_id": "9aff4cb9446fedf99e8e212ce1db823c9dd0d03c",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "maybe just use conditional `Set`?",
      "created_at": "2024-06-07T15:49:30Z",
      "updated_at": "2024-06-07T16:07:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1631406724",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1631406724"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 166,
      "original_line": 166,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1631406944",
      "pull_request_review_id": 2104783238,
      "id": 1631406944,
      "node_id": "PRRC_kwDOABII585hPUtg",
      "diff_hunk": "@@ -0,0 +1,529 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <util/check.h>\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a - b) implements \"a and not b\".\n+ * - Efficient non-strict subset/superset testing: IsSubsetOf() and IsSupersetOf().\n+ * - Efficient set overlap testing: a.Overlaps(b)\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than std::popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            Assume(m_val != 0);\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept\n+    {\n+        Assume(i < MAX_SIZE);\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept\n+    {\n+        IntBitSet ret;\n+        Assume(count <= MAX_SIZE);\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val |= I{1U} << pos;\n+    }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos);\n+    }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val &= ~I(I{1U} << pos);\n+    }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        return (m_val >> pos) & 1U;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept\n+    {\n+        Assume(m_val != 0);\n+        return std::countr_zero(m_val);\n+    }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept\n+    {\n+        Assume(m_val != 0);\n+        return std::bit_width(m_val) - 1;\n+    }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator-=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    constexpr bool Overlaps(const IntBitSet& a) const noexcept { return m_val & a.m_val; }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr IntBitSet operator&(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & b.m_val); }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator|(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val | b.m_val); }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr IntBitSet operator-(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & ~b.m_val); }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator^(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val ^ b.m_val); }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const IntBitSet& a, const IntBitSet& b) noexcept = default;\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    constexpr bool IsSupersetOf(const IntBitSet& a) const noexcept { return (a.m_val & ~m_val) == 0; }\n+    /** Check if bitset a is a subset of bitset b (= every 1 bit in a is also in b). */\n+    constexpr bool IsSubsetOf(const IntBitSet& a) const noexcept { return (m_val & ~a.m_val) == 0; }\n+    /** Swap two bitsets. */\n+    friend constexpr void swap(IntBitSet& a, IntBitSet& b) noexcept { std::swap(a.m_val, b.m_val); }\n+};\n+\n+/** A bitset implementation backed by N integers of type I. */\n+template<typename I, unsigned N>\n+class MultiIntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    // Cannot be empty.\n+    static_assert(N > 0);\n+    /** The number of bits per integer. */\n+    static constexpr unsigned LIMB_BITS = std::numeric_limits<I>::digits;\n+    /** Number of elements this set type supports. */\n+    static constexpr unsigned MAX_SIZE = LIMB_BITS * N;\n+    /** Array whose member integers store the bits of the set. */\n+    std::array<I, N> m_val;\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class MultiIntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class MultiIntBitSet;\n+        const std::array<I, N>* m_ptr; /**< Pointer to array to fetch bits from. */\n+        I m_val; /**< The remaining bits of (*m_ptr)[m_idx]. */\n+        unsigned m_pos; /**< The last reported position. */\n+        unsigned m_idx; /**< The index in *m_ptr currently being iterated over. */\n+        constexpr Iterator(const std::array<I, N>& ref) noexcept : m_ptr(&ref), m_idx(0)\n+        {\n+            do {\n+                m_val = (*m_ptr)[m_idx];\n+                if (m_val) {\n+                    m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                    break;\n+                }\n+                ++m_idx;\n+            } while(m_idx < N);\n+        }\n+\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        friend constexpr bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_idx == N;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            Assume(m_idx < N);\n+            m_val &= m_val - I{1U};\n+            if (m_val == 0) {\n+                while (true) {\n+                    ++m_idx;\n+                    if (m_idx == N) break;\n+                    m_val = (*m_ptr)[m_idx];\n+                    if (m_val) {\n+                        m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                        break;\n+                    }\n+                }\n+            } else {\n+                m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+            }\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr MultiIntBitSet() noexcept : m_val{} {}\n+    /** Copy construct a bitset. */\n+    constexpr MultiIntBitSet(const MultiIntBitSet&) noexcept = default;\n+    /** Copy assign a bitset. */\n+    constexpr MultiIntBitSet& operator=(const MultiIntBitSet&) noexcept = default;\n+    /** Set a bit to 1. */\n+    void constexpr Set(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val[pos / LIMB_BITS] |= I{1U} << (pos % LIMB_BITS);\n+    }\n+    /** Set a bit to the specified value. */\n+    void constexpr Set(unsigned pos, bool val) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val[pos / LIMB_BITS] = (m_val[pos / LIMB_BITS] & ~I(I{1U} << (pos % LIMB_BITS))) |\n+                                 (I{val} << (pos % LIMB_BITS));\n+    }\n+    /** Construct a bitset from a list of values. */\n+    constexpr MultiIntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val{}\n+    {\n+        for (auto i : ilist) Set(i);\n+    }\n+    /** Set a bitset to a list of values. */\n+    constexpr MultiIntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val.fill(0);\n+        for (auto i : ilist) Set(i);\n+        return *this;\n+    }\n+    /** Set a bit to 0. */\n+    void constexpr Reset(unsigned pos) noexcept",
      "path": "src/util/bitset.h",
      "position": 342,
      "original_position": 338,
      "commit_id": "47f705b33fc1381d96c99038e2110e6fe2b2f883",
      "original_commit_id": "9aff4cb9446fedf99e8e212ce1db823c9dd0d03c",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "maybe just use conditional `Set`?",
      "created_at": "2024-06-07T15:49:43Z",
      "updated_at": "2024-06-07T16:07:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1631406944",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1631406944"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 342,
      "original_line": 342,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1631408015",
      "pull_request_review_id": 2104783238,
      "id": 1631408015,
      "node_id": "PRRC_kwDOABII585hPU-P",
      "diff_hunk": "@@ -0,0 +1,529 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <util/check.h>\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a - b) implements \"a and not b\".\n+ * - Efficient non-strict subset/superset testing: IsSubsetOf() and IsSupersetOf().\n+ * - Efficient set overlap testing: a.Overlaps(b)\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than std::popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            Assume(m_val != 0);\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept\n+    {\n+        Assume(i < MAX_SIZE);\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept\n+    {\n+        IntBitSet ret;\n+        Assume(count <= MAX_SIZE);\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val |= I{1U} << pos;\n+    }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos);\n+    }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val &= ~I(I{1U} << pos);\n+    }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        return (m_val >> pos) & 1U;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept\n+    {\n+        Assume(m_val != 0);\n+        return std::countr_zero(m_val);\n+    }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept\n+    {\n+        Assume(m_val != 0);\n+        return std::bit_width(m_val) - 1;\n+    }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator-=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    constexpr bool Overlaps(const IntBitSet& a) const noexcept { return m_val & a.m_val; }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr IntBitSet operator&(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & b.m_val); }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator|(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val | b.m_val); }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr IntBitSet operator-(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & ~b.m_val); }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator^(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val ^ b.m_val); }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const IntBitSet& a, const IntBitSet& b) noexcept = default;\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    constexpr bool IsSupersetOf(const IntBitSet& a) const noexcept { return (a.m_val & ~m_val) == 0; }\n+    /** Check if bitset a is a subset of bitset b (= every 1 bit in a is also in b). */\n+    constexpr bool IsSubsetOf(const IntBitSet& a) const noexcept { return (m_val & ~a.m_val) == 0; }\n+    /** Swap two bitsets. */\n+    friend constexpr void swap(IntBitSet& a, IntBitSet& b) noexcept { std::swap(a.m_val, b.m_val); }\n+};\n+\n+/** A bitset implementation backed by N integers of type I. */\n+template<typename I, unsigned N>\n+class MultiIntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    // Cannot be empty.\n+    static_assert(N > 0);\n+    /** The number of bits per integer. */\n+    static constexpr unsigned LIMB_BITS = std::numeric_limits<I>::digits;\n+    /** Number of elements this set type supports. */\n+    static constexpr unsigned MAX_SIZE = LIMB_BITS * N;\n+    /** Array whose member integers store the bits of the set. */\n+    std::array<I, N> m_val;\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class MultiIntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class MultiIntBitSet;\n+        const std::array<I, N>* m_ptr; /**< Pointer to array to fetch bits from. */\n+        I m_val; /**< The remaining bits of (*m_ptr)[m_idx]. */\n+        unsigned m_pos; /**< The last reported position. */\n+        unsigned m_idx; /**< The index in *m_ptr currently being iterated over. */\n+        constexpr Iterator(const std::array<I, N>& ref) noexcept : m_ptr(&ref), m_idx(0)\n+        {\n+            do {\n+                m_val = (*m_ptr)[m_idx];\n+                if (m_val) {\n+                    m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                    break;\n+                }\n+                ++m_idx;\n+            } while(m_idx < N);\n+        }\n+\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        friend constexpr bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_idx == N;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            Assume(m_idx < N);\n+            m_val &= m_val - I{1U};\n+            if (m_val == 0) {\n+                while (true) {\n+                    ++m_idx;\n+                    if (m_idx == N) break;\n+                    m_val = (*m_ptr)[m_idx];\n+                    if (m_val) {\n+                        m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                        break;\n+                    }\n+                }\n+            } else {\n+                m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+            }\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr MultiIntBitSet() noexcept : m_val{} {}\n+    /** Copy construct a bitset. */\n+    constexpr MultiIntBitSet(const MultiIntBitSet&) noexcept = default;\n+    /** Copy assign a bitset. */\n+    constexpr MultiIntBitSet& operator=(const MultiIntBitSet&) noexcept = default;\n+    /** Set a bit to 1. */\n+    void constexpr Set(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val[pos / LIMB_BITS] |= I{1U} << (pos % LIMB_BITS);\n+    }\n+    /** Set a bit to the specified value. */\n+    void constexpr Set(unsigned pos, bool val) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val[pos / LIMB_BITS] = (m_val[pos / LIMB_BITS] & ~I(I{1U} << (pos % LIMB_BITS))) |\n+                                 (I{val} << (pos % LIMB_BITS));\n+    }\n+    /** Construct a bitset from a list of values. */\n+    constexpr MultiIntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val{}\n+    {\n+        for (auto i : ilist) Set(i);\n+    }\n+    /** Set a bitset to a list of values. */\n+    constexpr MultiIntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val.fill(0);\n+        for (auto i : ilist) Set(i);\n+        return *this;\n+    }\n+    /** Set a bit to 0. */\n+    void constexpr Reset(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val[pos / LIMB_BITS] &= ~I(I{1U} << (pos % LIMB_BITS));\n+    }\n+    /** Retrieve a bit at the given position. */\n+    bool constexpr operator[](unsigned pos) const noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        return (m_val[pos / LIMB_BITS] >> (pos % LIMB_BITS)) & 1U;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr MultiIntBitSet Singleton(unsigned i) noexcept",
      "path": "src/util/bitset.h",
      "position": null,
      "original_position": 350,
      "commit_id": "47f705b33fc1381d96c99038e2110e6fe2b2f883",
      "original_commit_id": "9aff4cb9446fedf99e8e212ce1db823c9dd0d03c",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "stick with `pos` for arg names?",
      "created_at": "2024-06-07T15:50:34Z",
      "updated_at": "2024-06-07T16:07:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1631408015",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1631408015"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 350,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1631411035",
      "pull_request_review_id": 2104783238,
      "id": 1631411035,
      "node_id": "PRRC_kwDOABII585hPVtb",
      "diff_hunk": "@@ -0,0 +1,529 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <util/check.h>\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a - b) implements \"a and not b\".\n+ * - Efficient non-strict subset/superset testing: IsSubsetOf() and IsSupersetOf().\n+ * - Efficient set overlap testing: a.Overlaps(b)\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than std::popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            Assume(m_val != 0);\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept\n+    {\n+        Assume(i < MAX_SIZE);\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept\n+    {\n+        IntBitSet ret;\n+        Assume(count <= MAX_SIZE);\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val |= I{1U} << pos;\n+    }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos);\n+    }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val &= ~I(I{1U} << pos);\n+    }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        return (m_val >> pos) & 1U;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept\n+    {\n+        Assume(m_val != 0);\n+        return std::countr_zero(m_val);\n+    }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept\n+    {\n+        Assume(m_val != 0);\n+        return std::bit_width(m_val) - 1;\n+    }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator-=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    constexpr bool Overlaps(const IntBitSet& a) const noexcept { return m_val & a.m_val; }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr IntBitSet operator&(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & b.m_val); }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator|(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val | b.m_val); }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr IntBitSet operator-(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & ~b.m_val); }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator^(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val ^ b.m_val); }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const IntBitSet& a, const IntBitSet& b) noexcept = default;\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    constexpr bool IsSupersetOf(const IntBitSet& a) const noexcept { return (a.m_val & ~m_val) == 0; }\n+    /** Check if bitset a is a subset of bitset b (= every 1 bit in a is also in b). */\n+    constexpr bool IsSubsetOf(const IntBitSet& a) const noexcept { return (m_val & ~a.m_val) == 0; }\n+    /** Swap two bitsets. */\n+    friend constexpr void swap(IntBitSet& a, IntBitSet& b) noexcept { std::swap(a.m_val, b.m_val); }\n+};\n+\n+/** A bitset implementation backed by N integers of type I. */\n+template<typename I, unsigned N>\n+class MultiIntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    // Cannot be empty.\n+    static_assert(N > 0);\n+    /** The number of bits per integer. */\n+    static constexpr unsigned LIMB_BITS = std::numeric_limits<I>::digits;\n+    /** Number of elements this set type supports. */\n+    static constexpr unsigned MAX_SIZE = LIMB_BITS * N;\n+    /** Array whose member integers store the bits of the set. */\n+    std::array<I, N> m_val;\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class MultiIntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class MultiIntBitSet;\n+        const std::array<I, N>* m_ptr; /**< Pointer to array to fetch bits from. */\n+        I m_val; /**< The remaining bits of (*m_ptr)[m_idx]. */\n+        unsigned m_pos; /**< The last reported position. */\n+        unsigned m_idx; /**< The index in *m_ptr currently being iterated over. */\n+        constexpr Iterator(const std::array<I, N>& ref) noexcept : m_ptr(&ref), m_idx(0)\n+        {\n+            do {\n+                m_val = (*m_ptr)[m_idx];\n+                if (m_val) {\n+                    m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                    break;\n+                }\n+                ++m_idx;\n+            } while(m_idx < N);\n+        }\n+\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        friend constexpr bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_idx == N;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            Assume(m_idx < N);\n+            m_val &= m_val - I{1U};\n+            if (m_val == 0) {\n+                while (true) {\n+                    ++m_idx;\n+                    if (m_idx == N) break;\n+                    m_val = (*m_ptr)[m_idx];\n+                    if (m_val) {\n+                        m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                        break;\n+                    }\n+                }\n+            } else {\n+                m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+            }\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr MultiIntBitSet() noexcept : m_val{} {}\n+    /** Copy construct a bitset. */\n+    constexpr MultiIntBitSet(const MultiIntBitSet&) noexcept = default;\n+    /** Copy assign a bitset. */\n+    constexpr MultiIntBitSet& operator=(const MultiIntBitSet&) noexcept = default;\n+    /** Set a bit to 1. */\n+    void constexpr Set(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val[pos / LIMB_BITS] |= I{1U} << (pos % LIMB_BITS);\n+    }\n+    /** Set a bit to the specified value. */\n+    void constexpr Set(unsigned pos, bool val) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val[pos / LIMB_BITS] = (m_val[pos / LIMB_BITS] & ~I(I{1U} << (pos % LIMB_BITS))) |\n+                                 (I{val} << (pos % LIMB_BITS));\n+    }\n+    /** Construct a bitset from a list of values. */\n+    constexpr MultiIntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val{}\n+    {\n+        for (auto i : ilist) Set(i);\n+    }\n+    /** Set a bitset to a list of values. */\n+    constexpr MultiIntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val.fill(0);\n+        for (auto i : ilist) Set(i);\n+        return *this;\n+    }\n+    /** Set a bit to 0. */\n+    void constexpr Reset(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val[pos / LIMB_BITS] &= ~I(I{1U} << (pos % LIMB_BITS));\n+    }\n+    /** Retrieve a bit at the given position. */\n+    bool constexpr operator[](unsigned pos) const noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        return (m_val[pos / LIMB_BITS] >> (pos % LIMB_BITS)) & 1U;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr MultiIntBitSet Singleton(unsigned i) noexcept\n+    {\n+        Assume(i < MAX_SIZE);\n+        MultiIntBitSet ret;\n+        ret.m_val[i / LIMB_BITS] = I{1U} << (i % LIMB_BITS);\n+        return ret;\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr MultiIntBitSet Fill(unsigned count) noexcept\n+    {\n+        Assume(count <= MAX_SIZE);\n+        MultiIntBitSet ret;\n+        if (count) {\n+            unsigned i = 0;\n+            while (count > LIMB_BITS) {\n+                ret.m_val[i++] = ~I{0};\n+                count -= LIMB_BITS;\n+            }\n+            ret.m_val[i] = I(~I{0}) >> (LIMB_BITS - count);\n+        }\n+        return ret;\n+    }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Compute the number of 1 bits in the bitset. */\n+    unsigned constexpr Count() const noexcept\n+    {\n+        unsigned ret{0};\n+        for (I v : m_val) ret += PopCount(v);\n+        return ret;\n+    }\n+    /** Check if all bits are 0. */\n+    bool constexpr None() const noexcept\n+    {\n+        for (auto v : m_val) {\n+            if (v != 0) return false;\n+        }\n+        return true;\n+    }\n+    /** Check if any bits are 1. */\n+    bool constexpr Any() const noexcept",
      "path": "src/util/bitset.h",
      "position": null,
      "original_position": 390,
      "commit_id": "47f705b33fc1381d96c99038e2110e6fe2b2f883",
      "original_commit_id": "9aff4cb9446fedf99e8e212ce1db823c9dd0d03c",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "just check `!None()`?",
      "created_at": "2024-06-07T15:53:18Z",
      "updated_at": "2024-06-07T16:07:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1631411035",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1631411035"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 390,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1631480159",
      "pull_request_review_id": 2105019196,
      "id": 1631480159,
      "node_id": "PRRC_kwDOABII585hPmlf",
      "diff_hunk": "@@ -0,0 +1,529 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <util/check.h>\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a - b) implements \"a and not b\".\n+ * - Efficient non-strict subset/superset testing: IsSubsetOf() and IsSupersetOf().\n+ * - Efficient set overlap testing: a.Overlaps(b)\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than std::popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            Assume(m_val != 0);\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept\n+    {\n+        Assume(i < MAX_SIZE);\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept\n+    {\n+        IntBitSet ret;\n+        Assume(count <= MAX_SIZE);\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val |= I{1U} << pos;\n+    }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos);\n+    }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val &= ~I(I{1U} << pos);",
      "path": "src/util/bitset.h",
      "position": 166,
      "original_position": 168,
      "commit_id": "47f705b33fc1381d96c99038e2110e6fe2b2f883",
      "original_commit_id": "9aff4cb9446fedf99e8e212ce1db823c9dd0d03c",
      "in_reply_to_id": 1631406724,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I haven't benchmarked or investigated compiled code, but I want to give the compiler every opportunity to use the simpler operation here (the conditional `Set` is more complex, and inlining will hopefully strength-reduce it, but I prefer not counting on that).",
      "created_at": "2024-06-07T17:02:33Z",
      "updated_at": "2024-06-07T17:02:33Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1631480159",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1631480159"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 166,
      "original_line": 166,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1631489780",
      "pull_request_review_id": 2105034800,
      "id": 1631489780,
      "node_id": "PRRC_kwDOABII585hPo70",
      "diff_hunk": "@@ -0,0 +1,529 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <util/check.h>\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a - b) implements \"a and not b\".\n+ * - Efficient non-strict subset/superset testing: IsSubsetOf() and IsSupersetOf().\n+ * - Efficient set overlap testing: a.Overlaps(b)\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than std::popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            Assume(m_val != 0);\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */",
      "path": "src/util/bitset.h",
      "position": null,
      "original_position": 128,
      "commit_id": "47f705b33fc1381d96c99038e2110e6fe2b2f883",
      "original_commit_id": "9aff4cb9446fedf99e8e212ce1db823c9dd0d03c",
      "in_reply_to_id": 1631335816,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2024-06-07T17:13:22Z",
      "updated_at": "2024-06-07T17:13:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1631489780",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1631489780"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 128,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1631489851",
      "pull_request_review_id": 2105034907,
      "id": 1631489851,
      "node_id": "PRRC_kwDOABII585hPo87",
      "diff_hunk": "@@ -0,0 +1,311 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/fuzz/util.h>\n+#include <test/util/xoroshiro128plusplus.h>\n+#include <util/bitset.h>\n+\n+#include <bitset>\n+#include <vector>\n+\n+namespace {\n+\n+/** Pop the first byte from a Span<const uint8_t>, and return it. */\n+uint8_t ReadByte(Span<const uint8_t>& buffer)\n+{\n+    if (buffer.empty()) return 0;\n+    uint8_t ret = buffer.front();\n+    buffer = buffer.subspan(1);\n+    return ret;\n+}\n+\n+/** Perform a simulation fuzz test on BitSet type S. */\n+template<typename S>\n+void TestType(Span<const uint8_t> buffer)\n+{\n+    /** This fuzz test's design is based on the assumption that the actual bits stored in the\n+     *  bitsets and their simulations do not matter for the purpose of detecting edge cases, thus\n+     *  these are taken from a deterministically-seeded RNG instead. To provide some level of\n+     *  variation however, pick the seed based on the buffer size and size of the chosen bitset. */\n+    XoRoShiRo128PlusPlus rng(buffer.size() + 0x10000 * S::Size());\n+\n+    using Sim = std::bitset<S::Size()>;\n+    // Up to 4 real BitSets (initially 2).\n+    std::vector<S> real(2);\n+    // Up to 4 std::bitsets with the same corresponding contents.\n+    std::vector<Sim> sim(2);\n+\n+    /* Compare sim[idx] with real[idx], using all inspector operations. */\n+    auto compare_fn = [&](unsigned idx) {\n+        /* iterators and operator[] */\n+        auto it = real[idx].begin();\n+        unsigned first = S::Size();\n+        unsigned last = S::Size();\n+        for (unsigned i = 0; i < S::Size(); ++i) {\n+            bool match = (it != real[idx].end()) && *it == i;\n+            assert(sim[idx][i] == real[idx][i]);\n+            assert(match == real[idx][i]);\n+            assert((it == real[idx].end()) != (it != real[idx].end()));\n+            if (match) {\n+                ++it;\n+                if (first == S::Size()) first = i;\n+                last = i;\n+            }\n+        }\n+        assert(it == real[idx].end());\n+        assert(!(it != real[idx].end()));\n+        /* Any / None */\n+        assert(sim[idx].any() == real[idx].Any());\n+        assert(sim[idx].none() == real[idx].None());\n+        /* First */",
      "path": "src/test/fuzz/bitset.cpp",
      "position": null,
      "original_position": 62,
      "commit_id": "47f705b33fc1381d96c99038e2110e6fe2b2f883",
      "original_commit_id": "c99063e902c810dde1742696b3140610120d391c",
      "in_reply_to_id": 1631369553,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2024-06-07T17:13:27Z",
      "updated_at": "2024-06-07T17:13:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1631489851",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1631489851"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 62,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1631490140",
      "pull_request_review_id": 2105035441,
      "id": 1631490140,
      "node_id": "PRRC_kwDOABII585hPpBc",
      "diff_hunk": "@@ -0,0 +1,529 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <util/check.h>\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a - b) implements \"a and not b\".\n+ * - Efficient non-strict subset/superset testing: IsSubsetOf() and IsSupersetOf().\n+ * - Efficient set overlap testing: a.Overlaps(b)\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than std::popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            Assume(m_val != 0);\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept\n+    {\n+        Assume(i < MAX_SIZE);\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept\n+    {\n+        IntBitSet ret;\n+        Assume(count <= MAX_SIZE);\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val |= I{1U} << pos;\n+    }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos);\n+    }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val &= ~I(I{1U} << pos);\n+    }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        return (m_val >> pos) & 1U;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept\n+    {\n+        Assume(m_val != 0);\n+        return std::countr_zero(m_val);\n+    }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept\n+    {\n+        Assume(m_val != 0);\n+        return std::bit_width(m_val) - 1;\n+    }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator-=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    constexpr bool Overlaps(const IntBitSet& a) const noexcept { return m_val & a.m_val; }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr IntBitSet operator&(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & b.m_val); }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator|(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val | b.m_val); }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr IntBitSet operator-(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & ~b.m_val); }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator^(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val ^ b.m_val); }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const IntBitSet& a, const IntBitSet& b) noexcept = default;\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    constexpr bool IsSupersetOf(const IntBitSet& a) const noexcept { return (a.m_val & ~m_val) == 0; }\n+    /** Check if bitset a is a subset of bitset b (= every 1 bit in a is also in b). */\n+    constexpr bool IsSubsetOf(const IntBitSet& a) const noexcept { return (m_val & ~a.m_val) == 0; }\n+    /** Swap two bitsets. */\n+    friend constexpr void swap(IntBitSet& a, IntBitSet& b) noexcept { std::swap(a.m_val, b.m_val); }",
      "path": "src/util/bitset.h",
      "position": 223,
      "original_position": 225,
      "commit_id": "47f705b33fc1381d96c99038e2110e6fe2b2f883",
      "original_commit_id": "9aff4cb9446fedf99e8e212ce1db823c9dd0d03c",
      "in_reply_to_id": 1631393064,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Added coverage for the `swap` function in the fuzz test.",
      "created_at": "2024-06-07T17:13:45Z",
      "updated_at": "2024-06-07T17:13:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1631490140",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1631490140"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 223,
      "original_line": 223,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1631490229",
      "pull_request_review_id": 2105035568,
      "id": 1631490229,
      "node_id": "PRRC_kwDOABII585hPpC1",
      "diff_hunk": "@@ -0,0 +1,529 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <util/check.h>\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a - b) implements \"a and not b\".\n+ * - Efficient non-strict subset/superset testing: IsSubsetOf() and IsSupersetOf().\n+ * - Efficient set overlap testing: a.Overlaps(b)\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than std::popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            Assume(m_val != 0);\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;",
      "path": "src/util/bitset.h",
      "position": null,
      "original_position": 134,
      "commit_id": "47f705b33fc1381d96c99038e2110e6fe2b2f883",
      "original_commit_id": "9aff4cb9446fedf99e8e212ce1db823c9dd0d03c",
      "in_reply_to_id": 1631403413,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2024-06-07T17:13:51Z",
      "updated_at": "2024-06-07T17:13:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1631490229",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1631490229"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 134,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1631490300",
      "pull_request_review_id": 2105035694,
      "id": 1631490300,
      "node_id": "PRRC_kwDOABII585hPpD8",
      "diff_hunk": "@@ -0,0 +1,529 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <util/check.h>\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a - b) implements \"a and not b\".\n+ * - Efficient non-strict subset/superset testing: IsSubsetOf() and IsSupersetOf().\n+ * - Efficient set overlap testing: a.Overlaps(b)\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than std::popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            Assume(m_val != 0);\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;",
      "path": "src/util/bitset.h",
      "position": null,
      "original_position": 123,
      "commit_id": "47f705b33fc1381d96c99038e2110e6fe2b2f883",
      "original_commit_id": "9aff4cb9446fedf99e8e212ce1db823c9dd0d03c",
      "in_reply_to_id": 1631403529,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2024-06-07T17:13:56Z",
      "updated_at": "2024-06-07T17:13:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1631490300",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1631490300"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 123,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1631490491",
      "pull_request_review_id": 2105036045,
      "id": 1631490491,
      "node_id": "PRRC_kwDOABII585hPpG7",
      "diff_hunk": "@@ -0,0 +1,529 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <util/check.h>\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a - b) implements \"a and not b\".\n+ * - Efficient non-strict subset/superset testing: IsSubsetOf() and IsSupersetOf().\n+ * - Efficient set overlap testing: a.Overlaps(b)\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than std::popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            Assume(m_val != 0);\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept\n+    {\n+        Assume(i < MAX_SIZE);\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept\n+    {\n+        IntBitSet ret;\n+        Assume(count <= MAX_SIZE);\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val |= I{1U} << pos;\n+    }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos);\n+    }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val &= ~I(I{1U} << pos);\n+    }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        return (m_val >> pos) & 1U;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept\n+    {\n+        Assume(m_val != 0);\n+        return std::countr_zero(m_val);\n+    }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept\n+    {\n+        Assume(m_val != 0);\n+        return std::bit_width(m_val) - 1;\n+    }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator-=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    constexpr bool Overlaps(const IntBitSet& a) const noexcept { return m_val & a.m_val; }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr IntBitSet operator&(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & b.m_val); }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator|(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val | b.m_val); }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr IntBitSet operator-(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & ~b.m_val); }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator^(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val ^ b.m_val); }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const IntBitSet& a, const IntBitSet& b) noexcept = default;\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    constexpr bool IsSupersetOf(const IntBitSet& a) const noexcept { return (a.m_val & ~m_val) == 0; }\n+    /** Check if bitset a is a subset of bitset b (= every 1 bit in a is also in b). */\n+    constexpr bool IsSubsetOf(const IntBitSet& a) const noexcept { return (m_val & ~a.m_val) == 0; }\n+    /** Swap two bitsets. */\n+    friend constexpr void swap(IntBitSet& a, IntBitSet& b) noexcept { std::swap(a.m_val, b.m_val); }\n+};\n+\n+/** A bitset implementation backed by N integers of type I. */\n+template<typename I, unsigned N>\n+class MultiIntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    // Cannot be empty.\n+    static_assert(N > 0);\n+    /** The number of bits per integer. */\n+    static constexpr unsigned LIMB_BITS = std::numeric_limits<I>::digits;\n+    /** Number of elements this set type supports. */\n+    static constexpr unsigned MAX_SIZE = LIMB_BITS * N;\n+    /** Array whose member integers store the bits of the set. */\n+    std::array<I, N> m_val;\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class MultiIntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class MultiIntBitSet;\n+        const std::array<I, N>* m_ptr; /**< Pointer to array to fetch bits from. */\n+        I m_val; /**< The remaining bits of (*m_ptr)[m_idx]. */\n+        unsigned m_pos; /**< The last reported position. */\n+        unsigned m_idx; /**< The index in *m_ptr currently being iterated over. */\n+        constexpr Iterator(const std::array<I, N>& ref) noexcept : m_ptr(&ref), m_idx(0)\n+        {\n+            do {\n+                m_val = (*m_ptr)[m_idx];\n+                if (m_val) {\n+                    m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                    break;\n+                }\n+                ++m_idx;\n+            } while(m_idx < N);\n+        }\n+\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        friend constexpr bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_idx == N;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            Assume(m_idx < N);\n+            m_val &= m_val - I{1U};\n+            if (m_val == 0) {\n+                while (true) {\n+                    ++m_idx;\n+                    if (m_idx == N) break;\n+                    m_val = (*m_ptr)[m_idx];\n+                    if (m_val) {\n+                        m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                        break;\n+                    }\n+                }\n+            } else {\n+                m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+            }\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr MultiIntBitSet() noexcept : m_val{} {}\n+    /** Copy construct a bitset. */\n+    constexpr MultiIntBitSet(const MultiIntBitSet&) noexcept = default;\n+    /** Copy assign a bitset. */\n+    constexpr MultiIntBitSet& operator=(const MultiIntBitSet&) noexcept = default;\n+    /** Set a bit to 1. */\n+    void constexpr Set(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val[pos / LIMB_BITS] |= I{1U} << (pos % LIMB_BITS);\n+    }\n+    /** Set a bit to the specified value. */\n+    void constexpr Set(unsigned pos, bool val) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val[pos / LIMB_BITS] = (m_val[pos / LIMB_BITS] & ~I(I{1U} << (pos % LIMB_BITS))) |\n+                                 (I{val} << (pos % LIMB_BITS));\n+    }\n+    /** Construct a bitset from a list of values. */\n+    constexpr MultiIntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val{}\n+    {\n+        for (auto i : ilist) Set(i);\n+    }\n+    /** Set a bitset to a list of values. */\n+    constexpr MultiIntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val.fill(0);\n+        for (auto i : ilist) Set(i);\n+        return *this;\n+    }\n+    /** Set a bit to 0. */\n+    void constexpr Reset(unsigned pos) noexcept",
      "path": "src/util/bitset.h",
      "position": 342,
      "original_position": 338,
      "commit_id": "47f705b33fc1381d96c99038e2110e6fe2b2f883",
      "original_commit_id": "9aff4cb9446fedf99e8e212ce1db823c9dd0d03c",
      "in_reply_to_id": 1631406944,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Same reasoning as [here](https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1631480159)",
      "created_at": "2024-06-07T17:14:12Z",
      "updated_at": "2024-06-07T17:14:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1631490491",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1631490491"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 342,
      "original_line": 342,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1631490602",
      "pull_request_review_id": 2105036214,
      "id": 1631490602,
      "node_id": "PRRC_kwDOABII585hPpIq",
      "diff_hunk": "@@ -0,0 +1,529 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <util/check.h>\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a - b) implements \"a and not b\".\n+ * - Efficient non-strict subset/superset testing: IsSubsetOf() and IsSupersetOf().\n+ * - Efficient set overlap testing: a.Overlaps(b)\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than std::popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            Assume(m_val != 0);\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept\n+    {\n+        Assume(i < MAX_SIZE);\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept\n+    {\n+        IntBitSet ret;\n+        Assume(count <= MAX_SIZE);\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val |= I{1U} << pos;\n+    }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos);\n+    }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val &= ~I(I{1U} << pos);\n+    }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        return (m_val >> pos) & 1U;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept\n+    {\n+        Assume(m_val != 0);\n+        return std::countr_zero(m_val);\n+    }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept\n+    {\n+        Assume(m_val != 0);\n+        return std::bit_width(m_val) - 1;\n+    }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator-=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    constexpr bool Overlaps(const IntBitSet& a) const noexcept { return m_val & a.m_val; }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr IntBitSet operator&(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & b.m_val); }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator|(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val | b.m_val); }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr IntBitSet operator-(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & ~b.m_val); }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator^(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val ^ b.m_val); }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const IntBitSet& a, const IntBitSet& b) noexcept = default;\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    constexpr bool IsSupersetOf(const IntBitSet& a) const noexcept { return (a.m_val & ~m_val) == 0; }\n+    /** Check if bitset a is a subset of bitset b (= every 1 bit in a is also in b). */\n+    constexpr bool IsSubsetOf(const IntBitSet& a) const noexcept { return (m_val & ~a.m_val) == 0; }\n+    /** Swap two bitsets. */\n+    friend constexpr void swap(IntBitSet& a, IntBitSet& b) noexcept { std::swap(a.m_val, b.m_val); }\n+};\n+\n+/** A bitset implementation backed by N integers of type I. */\n+template<typename I, unsigned N>\n+class MultiIntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    // Cannot be empty.\n+    static_assert(N > 0);\n+    /** The number of bits per integer. */\n+    static constexpr unsigned LIMB_BITS = std::numeric_limits<I>::digits;\n+    /** Number of elements this set type supports. */\n+    static constexpr unsigned MAX_SIZE = LIMB_BITS * N;\n+    /** Array whose member integers store the bits of the set. */\n+    std::array<I, N> m_val;\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class MultiIntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class MultiIntBitSet;\n+        const std::array<I, N>* m_ptr; /**< Pointer to array to fetch bits from. */\n+        I m_val; /**< The remaining bits of (*m_ptr)[m_idx]. */\n+        unsigned m_pos; /**< The last reported position. */\n+        unsigned m_idx; /**< The index in *m_ptr currently being iterated over. */\n+        constexpr Iterator(const std::array<I, N>& ref) noexcept : m_ptr(&ref), m_idx(0)\n+        {\n+            do {\n+                m_val = (*m_ptr)[m_idx];\n+                if (m_val) {\n+                    m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                    break;\n+                }\n+                ++m_idx;\n+            } while(m_idx < N);\n+        }\n+\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        friend constexpr bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_idx == N;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            Assume(m_idx < N);\n+            m_val &= m_val - I{1U};\n+            if (m_val == 0) {\n+                while (true) {\n+                    ++m_idx;\n+                    if (m_idx == N) break;\n+                    m_val = (*m_ptr)[m_idx];\n+                    if (m_val) {\n+                        m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                        break;\n+                    }\n+                }\n+            } else {\n+                m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+            }\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr MultiIntBitSet() noexcept : m_val{} {}\n+    /** Copy construct a bitset. */\n+    constexpr MultiIntBitSet(const MultiIntBitSet&) noexcept = default;\n+    /** Copy assign a bitset. */\n+    constexpr MultiIntBitSet& operator=(const MultiIntBitSet&) noexcept = default;\n+    /** Set a bit to 1. */\n+    void constexpr Set(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val[pos / LIMB_BITS] |= I{1U} << (pos % LIMB_BITS);\n+    }\n+    /** Set a bit to the specified value. */\n+    void constexpr Set(unsigned pos, bool val) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val[pos / LIMB_BITS] = (m_val[pos / LIMB_BITS] & ~I(I{1U} << (pos % LIMB_BITS))) |\n+                                 (I{val} << (pos % LIMB_BITS));\n+    }\n+    /** Construct a bitset from a list of values. */\n+    constexpr MultiIntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val{}\n+    {\n+        for (auto i : ilist) Set(i);\n+    }\n+    /** Set a bitset to a list of values. */\n+    constexpr MultiIntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val.fill(0);\n+        for (auto i : ilist) Set(i);\n+        return *this;\n+    }\n+    /** Set a bit to 0. */\n+    void constexpr Reset(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val[pos / LIMB_BITS] &= ~I(I{1U} << (pos % LIMB_BITS));\n+    }\n+    /** Retrieve a bit at the given position. */\n+    bool constexpr operator[](unsigned pos) const noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        return (m_val[pos / LIMB_BITS] >> (pos % LIMB_BITS)) & 1U;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr MultiIntBitSet Singleton(unsigned i) noexcept",
      "path": "src/util/bitset.h",
      "position": null,
      "original_position": 350,
      "commit_id": "47f705b33fc1381d96c99038e2110e6fe2b2f883",
      "original_commit_id": "9aff4cb9446fedf99e8e212ce1db823c9dd0d03c",
      "in_reply_to_id": 1631408015,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2024-06-07T17:14:19Z",
      "updated_at": "2024-06-07T17:14:19Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1631490602",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1631490602"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 350,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1631490667",
      "pull_request_review_id": 2105036341,
      "id": 1631490667,
      "node_id": "PRRC_kwDOABII585hPpJr",
      "diff_hunk": "@@ -0,0 +1,529 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <util/check.h>\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a - b) implements \"a and not b\".\n+ * - Efficient non-strict subset/superset testing: IsSubsetOf() and IsSupersetOf().\n+ * - Efficient set overlap testing: a.Overlaps(b)\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than std::popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            Assume(m_val != 0);\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr IntBitSet() noexcept : m_val{0} {}\n+    /** Copy construct a bitset. */\n+    constexpr IntBitSet(const IntBitSet&) noexcept = default;\n+    /** Construct from a list of values. */\n+    constexpr IntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val(0)\n+    {\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+    }\n+    /** Copy assign a bitset. */\n+    constexpr IntBitSet& operator=(const IntBitSet&) noexcept = default;\n+    /** Assign a list of values. */\n+    constexpr IntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val = 0;\n+        for (auto i : ilist) {\n+            Assume(i < MAX_SIZE);\n+            m_val |= I{1U} << i;\n+        }\n+        return *this;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr IntBitSet Singleton(unsigned i) noexcept\n+    {\n+        Assume(i < MAX_SIZE);\n+        return IntBitSet(I(1U) << i);\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr IntBitSet Fill(unsigned count) noexcept\n+    {\n+        IntBitSet ret;\n+        Assume(count <= MAX_SIZE);\n+        if (count) ret.m_val = I(~I{0}) >> (MAX_SIZE - count);\n+        return ret;\n+    }\n+    /** Set a bit to 1. */\n+    constexpr void Set(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val |= I{1U} << pos;\n+    }\n+    /** Set a bit to the specified value. */\n+    constexpr void Set(unsigned pos, bool val) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val = (m_val & ~I(I{1U} << pos)) | (I(val) << pos);\n+    }\n+    /** Set a bit to 0. */\n+    constexpr void Reset(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val &= ~I(I{1U} << pos);\n+    }\n+    /** Retrieve a bit at the given position. */\n+    constexpr bool operator[](unsigned pos) const noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        return (m_val >> pos) & 1U;\n+    }\n+    /** Compute the number of 1 bits in the bitset. */\n+    constexpr unsigned Count() const noexcept { return PopCount(m_val); }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Check if all bits are 0. */\n+    constexpr bool None() const noexcept { return m_val == 0; }\n+    /** Check if any bits are 1. */\n+    constexpr bool Any() const noexcept { return m_val != 0; }\n+    /** Return an object that iterates over all 1 bits (++ and * only allowed when != end()). */\n+    constexpr Iterator begin() const noexcept { return Iterator(m_val); }\n+    /** Return a dummy object to compare Iterators with. */\n+    constexpr IteratorEnd end() const noexcept { return IteratorEnd(); }\n+    /** Find the first element (requires Any()). */\n+    constexpr unsigned First() const noexcept\n+    {\n+        Assume(m_val != 0);\n+        return std::countr_zero(m_val);\n+    }\n+    /** Find the last element (requires Any()). */\n+    constexpr unsigned Last() const noexcept\n+    {\n+        Assume(m_val != 0);\n+        return std::bit_width(m_val) - 1;\n+    }\n+    /** Set this object's bits to be the binary AND between respective bits from this and a. */\n+    constexpr IntBitSet& operator|=(const IntBitSet& a) noexcept { m_val |= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary OR between respective bits from this and a. */\n+    constexpr IntBitSet& operator&=(const IntBitSet& a) noexcept { m_val &= a.m_val; return *this; }\n+    /** Set this object's bits to be the binary AND NOT between respective bits from this and a. */\n+    constexpr IntBitSet& operator-=(const IntBitSet& a) noexcept { m_val &= ~a.m_val; return *this; }\n+    /** Set this object's bits to be the binary XOR between respective bits from this as a. */\n+    constexpr IntBitSet& operator^=(const IntBitSet& a) noexcept { m_val ^= a.m_val; return *this; }\n+    /** Check if the intersection between two sets is non-empty. */\n+    constexpr bool Overlaps(const IntBitSet& a) const noexcept { return m_val & a.m_val; }\n+    /** Return an object with the binary AND between respective bits from a and b. */\n+    friend constexpr IntBitSet operator&(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & b.m_val); }\n+    /** Return an object with the binary OR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator|(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val | b.m_val); }\n+    /** Return an object with the binary AND NOT between respective bits from a and b. */\n+    friend constexpr IntBitSet operator-(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val & ~b.m_val); }\n+    /** Return an object with the binary XOR between respective bits from a and b. */\n+    friend constexpr IntBitSet operator^(const IntBitSet& a, const IntBitSet& b) noexcept { return I(a.m_val ^ b.m_val); }\n+    /** Check if bitset a and bitset b are identical. */\n+    friend constexpr bool operator==(const IntBitSet& a, const IntBitSet& b) noexcept = default;\n+    /** Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). */\n+    constexpr bool IsSupersetOf(const IntBitSet& a) const noexcept { return (a.m_val & ~m_val) == 0; }\n+    /** Check if bitset a is a subset of bitset b (= every 1 bit in a is also in b). */\n+    constexpr bool IsSubsetOf(const IntBitSet& a) const noexcept { return (m_val & ~a.m_val) == 0; }\n+    /** Swap two bitsets. */\n+    friend constexpr void swap(IntBitSet& a, IntBitSet& b) noexcept { std::swap(a.m_val, b.m_val); }\n+};\n+\n+/** A bitset implementation backed by N integers of type I. */\n+template<typename I, unsigned N>\n+class MultiIntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    // Cannot be empty.\n+    static_assert(N > 0);\n+    /** The number of bits per integer. */\n+    static constexpr unsigned LIMB_BITS = std::numeric_limits<I>::digits;\n+    /** Number of elements this set type supports. */\n+    static constexpr unsigned MAX_SIZE = LIMB_BITS * N;\n+    /** Array whose member integers store the bits of the set. */\n+    std::array<I, N> m_val;\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class MultiIntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class MultiIntBitSet;\n+        const std::array<I, N>* m_ptr; /**< Pointer to array to fetch bits from. */\n+        I m_val; /**< The remaining bits of (*m_ptr)[m_idx]. */\n+        unsigned m_pos; /**< The last reported position. */\n+        unsigned m_idx; /**< The index in *m_ptr currently being iterated over. */\n+        constexpr Iterator(const std::array<I, N>& ref) noexcept : m_ptr(&ref), m_idx(0)\n+        {\n+            do {\n+                m_val = (*m_ptr)[m_idx];\n+                if (m_val) {\n+                    m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                    break;\n+                }\n+                ++m_idx;\n+            } while(m_idx < N);\n+        }\n+\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        friend constexpr bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_idx == N;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            Assume(m_idx < N);\n+            m_val &= m_val - I{1U};\n+            if (m_val == 0) {\n+                while (true) {\n+                    ++m_idx;\n+                    if (m_idx == N) break;\n+                    m_val = (*m_ptr)[m_idx];\n+                    if (m_val) {\n+                        m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+                        break;\n+                    }\n+                }\n+            } else {\n+                m_pos = std::countr_zero(m_val) + m_idx * LIMB_BITS;\n+            }\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }\n+    };\n+\n+public:\n+    /** Construct an all-zero bitset. */\n+    constexpr MultiIntBitSet() noexcept : m_val{} {}\n+    /** Copy construct a bitset. */\n+    constexpr MultiIntBitSet(const MultiIntBitSet&) noexcept = default;\n+    /** Copy assign a bitset. */\n+    constexpr MultiIntBitSet& operator=(const MultiIntBitSet&) noexcept = default;\n+    /** Set a bit to 1. */\n+    void constexpr Set(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val[pos / LIMB_BITS] |= I{1U} << (pos % LIMB_BITS);\n+    }\n+    /** Set a bit to the specified value. */\n+    void constexpr Set(unsigned pos, bool val) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val[pos / LIMB_BITS] = (m_val[pos / LIMB_BITS] & ~I(I{1U} << (pos % LIMB_BITS))) |\n+                                 (I{val} << (pos % LIMB_BITS));\n+    }\n+    /** Construct a bitset from a list of values. */\n+    constexpr MultiIntBitSet(std::initializer_list<unsigned> ilist) noexcept : m_val{}\n+    {\n+        for (auto i : ilist) Set(i);\n+    }\n+    /** Set a bitset to a list of values. */\n+    constexpr MultiIntBitSet& operator=(std::initializer_list<unsigned> ilist) noexcept\n+    {\n+        m_val.fill(0);\n+        for (auto i : ilist) Set(i);\n+        return *this;\n+    }\n+    /** Set a bit to 0. */\n+    void constexpr Reset(unsigned pos) noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        m_val[pos / LIMB_BITS] &= ~I(I{1U} << (pos % LIMB_BITS));\n+    }\n+    /** Retrieve a bit at the given position. */\n+    bool constexpr operator[](unsigned pos) const noexcept\n+    {\n+        Assume(pos < MAX_SIZE);\n+        return (m_val[pos / LIMB_BITS] >> (pos % LIMB_BITS)) & 1U;\n+    }\n+    /** Construct a bitset with the singleton i. */\n+    static constexpr MultiIntBitSet Singleton(unsigned i) noexcept\n+    {\n+        Assume(i < MAX_SIZE);\n+        MultiIntBitSet ret;\n+        ret.m_val[i / LIMB_BITS] = I{1U} << (i % LIMB_BITS);\n+        return ret;\n+    }\n+    /** Construct a bitset with bits 0..count-1 (inclusive) set to 1. */\n+    static constexpr MultiIntBitSet Fill(unsigned count) noexcept\n+    {\n+        Assume(count <= MAX_SIZE);\n+        MultiIntBitSet ret;\n+        if (count) {\n+            unsigned i = 0;\n+            while (count > LIMB_BITS) {\n+                ret.m_val[i++] = ~I{0};\n+                count -= LIMB_BITS;\n+            }\n+            ret.m_val[i] = I(~I{0}) >> (LIMB_BITS - count);\n+        }\n+        return ret;\n+    }\n+    /** Return the number of bits that this object holds. */\n+    static constexpr unsigned Size() noexcept { return MAX_SIZE; }\n+    /** Compute the number of 1 bits in the bitset. */\n+    unsigned constexpr Count() const noexcept\n+    {\n+        unsigned ret{0};\n+        for (I v : m_val) ret += PopCount(v);\n+        return ret;\n+    }\n+    /** Check if all bits are 0. */\n+    bool constexpr None() const noexcept\n+    {\n+        for (auto v : m_val) {\n+            if (v != 0) return false;\n+        }\n+        return true;\n+    }\n+    /** Check if any bits are 1. */\n+    bool constexpr Any() const noexcept",
      "path": "src/util/bitset.h",
      "position": null,
      "original_position": 390,
      "commit_id": "47f705b33fc1381d96c99038e2110e6fe2b2f883",
      "original_commit_id": "9aff4cb9446fedf99e8e212ce1db823c9dd0d03c",
      "in_reply_to_id": 1631411035,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2024-06-07T17:14:24Z",
      "updated_at": "2024-06-07T17:14:24Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1631490667",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1631490667"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 390,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1632438115",
      "pull_request_review_id": 2106417903,
      "id": 1632438115,
      "node_id": "PRRC_kwDOABII585hTQdj",
      "diff_hunk": "@@ -0,0 +1,517 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <util/check.h>\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a - b) implements \"a and not b\".\n+ * - Efficient non-strict subset/superset testing: IsSubsetOf() and IsSupersetOf().\n+ * - Efficient set overlap testing: a.Overlaps(b)\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than std::popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            Assume(m_val != 0);\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }",
      "path": "src/util/bitset.h",
      "position": null,
      "original_position": 110,
      "commit_id": "47f705b33fc1381d96c99038e2110e6fe2b2f883",
      "original_commit_id": "1e08ba37e7b5d9b083c938d90526f8fabbe1c799",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: same as done in `operator++`, could add `Assume(m_val != 0)` here as well (both for `IntBitSet` and `MultiIntBitSet` iterators)",
      "created_at": "2024-06-10T00:06:26Z",
      "updated_at": "2024-06-10T00:15:07Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1632438115",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1632438115"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 110,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1633124579",
      "pull_request_review_id": 2107581749,
      "id": 1633124579,
      "node_id": "PRRC_kwDOABII585hV4Dj",
      "diff_hunk": "@@ -0,0 +1,517 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_BITSET_H\n+#define BITCOIN_UTIL_BITSET_H\n+\n+#include <util/check.h>\n+\n+#include <array>\n+#include <bit>\n+#include <cstdint>\n+#include <limits>\n+#include <type_traits>\n+\n+/* This file provides data types similar to std::bitset, but adds the following functionality:\n+ *\n+ * - Efficient iteration over all set bits (compatible with range-based for loops).\n+ * - Efficient search for the first and last set bit (First() and Last()).\n+ * - Efficient set subtraction: (a - b) implements \"a and not b\".\n+ * - Efficient non-strict subset/superset testing: IsSubsetOf() and IsSupersetOf().\n+ * - Efficient set overlap testing: a.Overlaps(b)\n+ * - Efficient construction of set containing 0..N-1 (S::Fill).\n+ * - Efficient construction of a single set (S::Singleton).\n+ * - Construction from initializer lists.\n+ *\n+ * Other differences:\n+ * - BitSet<N> is a bitset that supports at least N elements, but may support more (Size() reports\n+ *   the actual number). Because the actual number is unpredictable, there are no operations that\n+ *   affect all positions (like std::bitset's operator~, flip(), or all()).\n+ * - Various other unimplemented features.\n+ */\n+\n+namespace bitset_detail {\n+\n+/** Count the number of bits set in an unsigned integer type. */\n+template<typename I>\n+unsigned inline constexpr PopCount(I v)\n+{\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    constexpr auto BITS = std::numeric_limits<I>::digits;\n+    // Algorithms from https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation.\n+    // These seem to be faster than std::popcount when compiling for non-SSE4 on x86_64.\n+    if constexpr (BITS <= 32) {\n+        v -= (v >> 1) & 0x55555555;\n+        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f;\n+        if constexpr (BITS > 8) v += v >> 8;\n+        if constexpr (BITS > 16) v += v >> 16;\n+        return v & 0x3f;\n+    } else {\n+        static_assert(BITS <= 64);\n+        v -= (v >> 1) & 0x5555555555555555;\n+        v = (v & 0x3333333333333333) + ((v >> 2) & 0x3333333333333333);\n+        v = (v + (v >> 4)) & 0x0f0f0f0f0f0f0f0f;\n+        return (v * uint64_t{0x0101010101010101}) >> 56;\n+    }\n+}\n+\n+/** A bitset implementation backed by a single integer of type I. */\n+template<typename I>\n+class IntBitSet\n+{\n+    // Only binary, unsigned, integer, types allowed.\n+    static_assert(std::is_integral_v<I> && std::is_unsigned_v<I> && std::numeric_limits<I>::radix == 2);\n+    /** The maximum number of bits this bitset supports. */\n+    static constexpr unsigned MAX_SIZE = std::numeric_limits<I>::digits;\n+    /** Integer whose bits represent this bitset. */\n+    I m_val;\n+    /** Internal constructor with a given integer as contents. */\n+    IntBitSet(I val) noexcept : m_val{val} {}\n+    /** Dummy type to return using end(). Only used for comparing with Iterator. */\n+    class IteratorEnd\n+    {\n+        friend class IntBitSet;\n+        constexpr IteratorEnd() = default;\n+    public:\n+        constexpr IteratorEnd(const IteratorEnd&) = default;\n+    };\n+    /** Iterator type returned by begin(), which efficiently iterates all 1 positions. */\n+    class Iterator\n+    {\n+        friend class IntBitSet;\n+        I m_val; /**< The original integer's remaining bits. */\n+        unsigned m_pos; /** Last reported 1 position (if m_pos != 0). */\n+        constexpr Iterator(I val) noexcept : m_val(val), m_pos(0)\n+        {\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+        }\n+    public:\n+        /** Do not allow external code to construct an Iterator. */\n+        Iterator() = delete;\n+        // Copying is allowed.\n+        constexpr Iterator(const Iterator&) noexcept = default;\n+        constexpr Iterator& operator=(const Iterator&) noexcept = default;\n+        /** Test whether we are done (can only compare with IteratorEnd). */\n+        constexpr friend bool operator==(const Iterator& a, const IteratorEnd&) noexcept\n+        {\n+            return a.m_val == 0;\n+        }\n+        /** Progress to the next 1 bit (only if != IteratorEnd). */\n+        constexpr Iterator& operator++() noexcept\n+        {\n+            Assume(m_val != 0);\n+            m_val &= m_val - I{1U};\n+            if (m_val != 0) m_pos = std::countr_zero(m_val);\n+            return *this;\n+        }\n+        /** Get the current bit position (only if != IteratorEnd). */\n+        constexpr const unsigned& operator*() const noexcept { return m_pos; }",
      "path": "src/util/bitset.h",
      "position": null,
      "original_position": 110,
      "commit_id": "47f705b33fc1381d96c99038e2110e6fe2b2f883",
      "original_commit_id": "1e08ba37e7b5d9b083c938d90526f8fabbe1c799",
      "in_reply_to_id": 1632438115,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2024-06-10T11:55:09Z",
      "updated_at": "2024-06-10T11:55:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30160#discussion_r1633124579",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1633124579"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30160"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 110,
      "side": "RIGHT"
    }
  ]
}