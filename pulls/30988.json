{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988",
    "id": 2095252001,
    "node_id": "PR_kwDOABII58584wIh",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/30988",
    "diff_url": "https://github.com/bitcoin/bitcoin/pull/30988.diff",
    "patch_url": "https://github.com/bitcoin/bitcoin/pull/30988.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30988",
    "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30988/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/7ef9661fb09d2cd9356cca7476256fea2077bec9",
    "number": 30988,
    "state": "open",
    "locked": false,
    "maintainer_can_modify": true,
    "title": "Split CConnman",
    "user": {
      "login": "vasild",
      "id": 266751,
      "node_id": "MDQ6VXNlcjI2Njc1MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vasild",
      "html_url": "https://github.com/vasild",
      "followers_url": "https://api.github.com/users/vasild/followers",
      "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
      "organizations_url": "https://api.github.com/users/vasild/orgs",
      "repos_url": "https://api.github.com/users/vasild/repos",
      "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/vasild/received_events",
      "type": "User",
      "site_admin": false,
      "patch_url": null
    },
    "body": "Currently `CConnman` is a mixture of:\r\n* low level socket handling, e.g. send, recv, poll, bind, listen, connect, and\r\n* higher level logic that is specific to the Bitcoin P2P protocol, e.g. V1/V2 transport, choosing which address to connect to, if we manage to connect mark the address good in `AddrMan`, maintaining the number of inbound and outbound connections, banning of peers, interacting with `PeerManager`.\r\n\r\n---\r\n\r\nThis PR splits the socket handling into a new class which makes the code more modular and reusable. Having more modular and reusable code is a good thing on its own, even if the code is not reused. Stratum V2 and libevent-less RPC/HTTP server could benefit from this, but it makes sense on its own, even without those projects.\r\n\r\n---\r\n\r\nThe socket operations are driven by the new class `SockMan` which informs the higher level via provided methods when e.g. new data arrives on the socket or a new connection is accepted. For this, `SockMan` provides some non-virtual methods to start it rolling and then it calls pure virtual methods which are implemented by the higher level (e.g. `CConnman`) on certain events, for example \"got this new data on this node's socket\".\r\n\r\nThe interface of `SockMan` is:\r\n\r\n```cpp\r\n/**\r\n * A socket manager class which handles socket operations.\r\n * To use this class, inherit from it and implement the pure virtual methods.\r\n * Handled operations:\r\n * - binding and listening on sockets\r\n * - starting of necessary threads to process socket operations\r\n * - accepting incoming connections\r\n * - making outbound connections\r\n * - closing connections\r\n * - waiting for IO readiness on sockets and doing send/recv accordingly\r\n */\r\nclass SockMan\r\n{\r\npublic:\r\n\r\n    //\r\n    // Non-virtual functions, to be reused by children classes.\r\n    //\r\n\r\n    /**\r\n     * Bind to a new address:port, start listening and add the listen socket to `m_listen`.\r\n     * Should be called before `StartSocketsThreads()`.\r\n     * @param[in] to Where to bind.\r\n     * @param[out] err_msg Error string if an error occurs.\r\n     * @retval true Success.\r\n     * @retval false Failure, `err_msg` will be set.\r\n     */\r\n    bool BindAndStartListening(const CService& to, bilingual_str& err_msg);\r\n\r\n    /**\r\n     * Start the necessary threads for sockets IO.\r\n     */\r\n    void StartSocketsThreads(const Options& options);\r\n\r\n    /**\r\n     * Join (wait for) the threads started by `StartSocketsThreads()` to exit.\r\n     */\r\n    void JoinSocketsThreads();\r\n\r\n    /**\r\n     * Make an outbound connection, save the socket internally and return a newly generated connection id.\r\n     * @param[in] to The address to connect to, either as CService or a host as string and port as\r\n     * an integer, if the later is used, then `proxy` must be valid.\r\n     * @param[in] is_important If true, then log failures with higher severity.\r\n     * @param[in] proxy Proxy to connect through, if set.\r\n     * @param[out] proxy_failed If `proxy` is valid and the connection failed because of the\r\n     * proxy, then it will be set to true.\r\n     * @param[out] me If the connection was successful then this is set to the address on the\r\n     * local side of the socket.\r\n     * @return Newly generated id, or std::nullopt if the operation fails.\r\n     */\r\n    std::optional<SockMan::Id> ConnectAndMakeId(const std::variant<CService, StringHostIntPort>& to,\r\n                                                bool is_important,\r\n                                                std::optional<Proxy> proxy,\r\n                                                bool& proxy_failed,\r\n                                                CService& me)\r\n        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex, !m_unused_i2p_sessions_mutex);\r\n\r\n    /**\r\n     * Destroy a given connection by closing its socket and release resources occupied by it.\r\n     * @param[in] id Connection to destroy.\r\n     * @return Whether the connection existed and its socket was closed by this call.\r\n     */\r\n    bool CloseConnection(Id id)\r\n        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\r\n\r\n    /**\r\n     * Try to send some data over the given connection.\r\n     * @param[in] id Identifier of the connection.\r\n     * @param[in] data The data to send, it might happen that only a prefix of this is sent.\r\n     * @param[in] will_send_more Used as an optimization if the caller knows that they will\r\n     * be sending more data soon after this call.\r\n     * @param[out] errmsg If <0 is returned then this will contain a human readable message\r\n     * explaining the error.\r\n     * @retval >=0 The number of bytes actually sent.\r\n     * @retval <0 A permanent error has occurred.\r\n     */\r\n    ssize_t SendBytes(Id id,\r\n                      std::span<const unsigned char> data,\r\n                      bool will_send_more,\r\n                      std::string& errmsg) const\r\n        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\r\n\r\n    /**\r\n     * Stop listening by closing all listening sockets.\r\n     */\r\n    void StopListening();\r\n\r\n    //\r\n    // Pure virtual functions must be implemented by children classes.\r\n    //\r\n\r\n    /**\r\n     * Be notified when a new connection has been accepted.\r\n     * @param[in] id Id of the newly accepted connection.\r\n     * @param[in] me The address and port at our side of the connection.\r\n     * @param[in] them The address and port at the peer's side of the connection.\r\n     * @retval true The new connection was accepted at the higher level.\r\n     * @retval false The connection was refused at the higher level, so the\r\n     * associated socket and id should be discarded by `SockMan`.\r\n     */\r\n    virtual bool EventNewConnectionAccepted(Id id,\r\n                                            const CService& me,\r\n                                            const CService& them) = 0;\r\n\r\n    /**\r\n     * Called when the socket is ready to send data and `ShouldTryToSend()` has\r\n     * returned true. This is where the higher level code serializes its messages\r\n     * and calls `SockMan::SendBytes()`.\r\n     * @param[in] id Id of the connection whose socket is ready to send.\r\n     * @param[out] cancel_recv Should always be set upon return and if it is true,\r\n     * then the next attempt to receive data from that connection will be omitted.\r\n     */\r\n    virtual void EventReadyToSend(Id id, bool& cancel_recv) = 0;\r\n\r\n    /**\r\n     * Called when new data has been received.\r\n     * @param[in] id Connection for which the data arrived.\r\n     * @param[in] data Received data.\r\n     */\r\n    virtual void EventGotData(Id id, std::span<const uint8_t> data) = 0;\r\n\r\n    /**\r\n     * Called when the remote peer has sent an EOF on the socket. This is a graceful\r\n     * close of their writing side, we can still send and they will receive, if it\r\n     * makes sense at the application level.\r\n     * @param[in] id Connection whose socket got EOF.\r\n     */\r\n    virtual void EventGotEOF(Id id) = 0;\r\n\r\n    /**\r\n     * Called when we get an irrecoverable error trying to read from a socket.\r\n     * @param[in] id Connection whose socket got an error.\r\n     * @param[in] errmsg Message describing the error.\r\n     */\r\n    virtual void EventGotPermanentReadError(Id id, const std::string& errmsg) = 0;\r\n};\r\n```\r\n\r\nResolves: https://github.com/bitcoin/bitcoin/issues/30694\r\n\r\n---\r\n\r\nReview hint: this PR moves some code around, so reviewers may find this helpful: `git show --color-moved --color-moved-ws=allow-indentation-change`.",
    "labels": [],
    "created_at": "2024-09-27T07:57:10Z",
    "updated_at": "2025-04-30T18:32:30Z",
    "mergeable": true,
    "mergeable_state": "blocked",
    "merged": false,
    "merge_commit_sha": "732975b0f5f4840c9738c37aaebbffce132e2088",
    "assignees": [],
    "requested_reviewers": [
      {
        "login": "tdb3",
        "id": 106488469,
        "node_id": "U_kgDOBljilQ",
        "avatar_url": "https://avatars.githubusercontent.com/u/106488469?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/tdb3",
        "html_url": "https://github.com/tdb3",
        "followers_url": "https://api.github.com/users/tdb3/followers",
        "following_url": "https://api.github.com/users/tdb3/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/tdb3/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/tdb3/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/tdb3/subscriptions",
        "organizations_url": "https://api.github.com/users/tdb3/orgs",
        "repos_url": "https://api.github.com/users/tdb3/repos",
        "events_url": "https://api.github.com/users/tdb3/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/tdb3/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    ],
    "requested_teams": [],
    "rebaseable": true,
    "head": {
      "label": "vasild:sockman",
      "ref": "sockman",
      "sha": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "repo": {
        "id": 120608826,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMjA2MDg4MjY=",
        "name": "bitcoin",
        "full_name": "vasild/bitcoin",
        "owner": {
          "login": "vasild",
          "id": 266751,
          "node_id": "MDQ6VXNlcjI2Njc1MQ==",
          "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/vasild",
          "html_url": "https://github.com/vasild",
          "followers_url": "https://api.github.com/users/vasild/followers",
          "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
          "organizations_url": "https://api.github.com/users/vasild/orgs",
          "repos_url": "https://api.github.com/users/vasild/repos",
          "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/vasild/received_events",
          "type": "User",
          "site_admin": false,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/vasild/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": true,
        "url": "https://api.github.com/repos/vasild/bitcoin",
        "archive_url": "https://api.github.com/repos/vasild/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/vasild/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/vasild/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/vasild/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/vasild/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/vasild/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/vasild/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/vasild/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/vasild/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/vasild/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/vasild/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/vasild/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/vasild/bitcoin/events",
        "forks_url": "https://api.github.com/repos/vasild/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/vasild/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/vasild/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/vasild/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/vasild/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/vasild/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/vasild/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/vasild/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/vasild/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/vasild/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/vasild/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/vasild/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/vasild/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/vasild/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/vasild/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/vasild/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:vasild/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/vasild/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/vasild/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/vasild/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/vasild/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/vasild/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/vasild/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/vasild/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/vasild/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/vasild/bitcoin/hooks",
        "svn_url": "https://github.com/vasild/bitcoin",
        "homepage": "https://bitcoin.org/en/download",
        "language": "C++",
        "forks_count": 1,
        "stargazers_count": 6,
        "watchers_count": 6,
        "size": 256186,
        "default_branch": "master",
        "open_issues_count": 2,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2025-04-30T10:04:08Z",
        "created_at": "2018-02-07T11:52:47Z",
        "updated_at": "2025-04-30T10:04:27Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "bb92bb36f211b88e4c1aa031a4364795cbd24767",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false,
        "patch_url": null
      },
      "repo": {
        "id": 1181927,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTgxOTI3",
        "name": "bitcoin",
        "full_name": "bitcoin/bitcoin",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bitcoin",
        "archive_url": "https://api.github.com/repos/bitcoin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bitcoin/hooks",
        "svn_url": "https://github.com/bitcoin/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 37138,
        "stargazers_count": 83176,
        "watchers_count": 83176,
        "size": 280731,
        "default_branch": "master",
        "open_issues_count": 713,
        "is_template": false,
        "topics": [
          "bitcoin",
          "c-plus-plus",
          "cryptocurrency",
          "cryptography",
          "p2p"
        ],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2025-04-30T17:56:22Z",
        "created_at": "2010-12-19T15:16:43Z",
        "updated_at": "2025-04-30T18:55:22Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
      }
    },
    "author_association": "CONTRIBUTOR",
    "draft": false,
    "additions": 1416,
    "deletions": 729,
    "changed_files": 20,
    "commits": 17,
    "review_comments": 171,
    "comments": 42
  },
  "events": [
    {
      "event": "commented",
      "id": 2378648531,
      "node_id": "IC_kwDOABII586Nx0vT",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2378648531",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-27T07:57:13Z",
      "updated_at": "2025-04-30T18:32:29Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage & Benchmarks\nFor details see: https://corecheck.dev/bitcoin/bitcoin/pulls/30988.\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| Concept NACK | [theuni](https://github.com/bitcoin/bitcoin/pull/30988#issuecomment-2702063374) |\n| Concept ACK | [tdb3](https://github.com/bitcoin/bitcoin/pull/30988#pullrequestreview-2336026243), [Sjors](https://github.com/bitcoin/bitcoin/pull/30988#pullrequestreview-2552832660), [hodlinator](https://github.com/bitcoin/bitcoin/pull/30988#pullrequestreview-2582270517), [jonatack](https://github.com/bitcoin/bitcoin/pull/30988#pullrequestreview-2621788527) |\n| Stale ACK | [pinheadmz](https://github.com/bitcoin/bitcoin/pull/30988#pullrequestreview-2373476515) |\n\nIf your review is incorrectly listed, please react with 👎 to this comment and the bot will ignore it on the next update.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#32278](https://github.com/bitcoin/bitcoin/pull/32278) (doc: better document NetEventsInterface and the deletion of \"CNode\"s by vasild)\n* [#32065](https://github.com/bitcoin/bitcoin/pull/32065) (i2p: make a time gap between creating transient sessions and using them by vasild)\n* [#32015](https://github.com/bitcoin/bitcoin/pull/32015) (net: replace manual reference counting of CNode with shared_ptr by vasild)\n* [#30951](https://github.com/bitcoin/bitcoin/pull/30951) (net: option to disallow v1 connection on ipv4 and ipv6 peers by stratospher)\n* [#29641](https://github.com/bitcoin/bitcoin/pull/29641) (scripted-diff: Use LogInfo over LogPrintf [WIP, NOMERGE, DRAFT] by maflcko)\n* [#29418](https://github.com/bitcoin/bitcoin/pull/29418) (rpc: provide per message stats for global traffic via new RPC 'getnetmsgstats' by vasild)\n* [#28584](https://github.com/bitcoin/bitcoin/pull/28584) (Fuzz: extend CConnman tests by vasild)\n* [#28463](https://github.com/bitcoin/bitcoin/pull/28463) (p2p: Increase inbound capacity for block-relay only connections by mzumsande)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#issuecomment-2378648531",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30988"
    },
    {
      "event": "labeled",
      "id": 14428004914,
      "node_id": "LE_lADOABII586YIJemzwAAAANb-eIy",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14428004914",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-27T09:09:45Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2379079961,
      "node_id": "IC_kwDOABII586NzeEZ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2379079961",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-27T11:41:28Z",
      "updated_at": "2024-09-27T11:41:48Z",
      "author_association": "MEMBER",
      "body": "Nice! I'll try to use this for `Sv2Connman` in https://github.com/Sjors/bitcoin/pull/50 and will let you know if anything is missing.\r\n\r\nCan you put `sockman.h` in `libbitcoin_common` instead of `libbitcoin_node`? For the Template Provider I'm trying to prevent a circular dependency on the node. This should do the trick: https://github.com/bitcoin/bitcoin/commit/4dd51b2924860bf10466da080ea4ff7bed1a3e3f",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#issuecomment-2379079961",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30988"
    },
    {
      "event": "reviewed",
      "id": 2333138089,
      "node_id": "PRR_kwDOABII586LENyp",
      "url": null,
      "actor": null,
      "commit_id": "03f6cc2b4a76cafd278b9ab92bd915d3946212a9",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#pullrequestreview-2333138089",
      "submitted_at": "2024-09-27T11:51:51Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 14432633095,
      "node_id": "HRFPE_lADOABII586YIJemzwAAAANcQIEH",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14432633095",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "70c2f13f83a5cc740330d0b4af9cbd74515be6b2",
      "commit_url": "https://api.github.com/repos/vasild/bitcoin/commits/70c2f13f83a5cc740330d0b4af9cbd74515be6b2",
      "created_at": "2024-09-27T15:05:31Z"
    },
    {
      "event": "commented",
      "id": 2379495804,
      "node_id": "IC_kwDOABII586N1Dl8",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2379495804",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-27T15:07:28Z",
      "updated_at": "2024-09-27T15:07:28Z",
      "author_association": "CONTRIBUTOR",
      "body": "`03f6cc2b4a...70c2f13f83`: fix CI failure, and address suggestions\r\n\r\n> Can you put sockman.h in libbitcoin_common\r\n\r\nDone.",
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#issuecomment-2379495804",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30988"
    },
    {
      "event": "unlabeled",
      "id": 14433585567,
      "node_id": "UNLE_lADOABII586YIJemzwAAAANcTwmf",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14433585567",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-27T16:23:34Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2379691000,
      "node_id": "IC_kwDOABII586N1zP4",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2379691000",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-27T16:51:49Z",
      "updated_at": "2024-09-27T16:52:05Z",
      "author_association": "MEMBER",
      "body": "Here's an initial sketch of making `Sv2Connman` a subclass of `SockMan`. The test gets through the handshake but fails later on, so I'll need to study it a bit more closely.\r\n\r\nhttps://github.com/Sjors/bitcoin/pull/64",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#issuecomment-2379691000",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30988"
    },
    {
      "event": "labeled",
      "id": 14443182181,
      "node_id": "LE_lADOABII586YIJemzwAAAANc4Xhl",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14443182181",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-29T01:02:15Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "unlabeled",
      "id": 14445040755,
      "node_id": "UNLE_lADOABII586YIJemzwAAAANc_dRz",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14445040755",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-29T11:27:54Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 2336026243,
      "node_id": "PRR_kwDOABII586LPO6D",
      "url": null,
      "actor": null,
      "commit_id": "70c2f13f83a5cc740330d0b4af9cbd74515be6b2",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Concept ACK",
      "user": {
        "login": "tdb3",
        "id": 106488469,
        "node_id": "U_kgDOBljilQ",
        "avatar_url": "https://avatars.githubusercontent.com/u/106488469?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/tdb3",
        "html_url": "https://github.com/tdb3",
        "followers_url": "https://api.github.com/users/tdb3/followers",
        "following_url": "https://api.github.com/users/tdb3/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/tdb3/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/tdb3/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/tdb3/subscriptions",
        "organizations_url": "https://api.github.com/users/tdb3/orgs",
        "repos_url": "https://api.github.com/users/tdb3/repos",
        "events_url": "https://api.github.com/users/tdb3/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/tdb3/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#pullrequestreview-2336026243",
      "submitted_at": "2024-09-29T22:05:50Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
    },
    {
      "event": "commented",
      "id": 2383223911,
      "node_id": "IC_kwDOABII586ODRxn",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2383223911",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-30T13:38:34Z",
      "updated_at": "2024-09-30T13:38:34Z",
      "author_association": "MEMBER",
      "body": "Concept ACK\r\n\r\nThis looks great and the API in the header looks easy, thanks.\r\n\r\nI'm in the process of cleaning up my HTTP branch for a pull request and then I can start reviewing this and rebasing on top. \r\n\r\nOne element of libevent I'm not immediately seeing here is timed events. Really the only thing HTTP needs it for is `walletpassphrase` which calls `RPCRunLater()` which interacts with `HTTPRPCTimerInterface()`. I don't think Conman has a specific mechanism for this because timed things are attached directly to nodes like `m_last_getheaders_timestamp` etc. The current `HTTPRPCTimerInterface` uses libevent `event_new()`  and `evtimer_add()`, I accomplish this with a map of timestamps and callback functions in my event loop: https://github.com/pinheadmz/bitcoin/commit/42b7240378ffc4890ab4ba1453623e5986ea2a71",
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#issuecomment-2383223911",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30988"
    },
    {
      "event": "commented",
      "id": 2383313791,
      "node_id": "IC_kwDOABII586ODnt_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2383313791",
      "actor": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-30T14:07:19Z",
      "updated_at": "2024-09-30T14:07:19Z",
      "author_association": "MEMBER",
      "body": "> I accomplish this with a map of timestamps and callback functions in my event loop\r\n\r\nI wonder why the existing scheduler can't be used for re-locking the wallet? I know there is https://github.com/bitcoin/bitcoin/issues/18488 and https://github.com/bitcoin/bitcoin/issues/14289, but the thread is already filled with random stuff such as `BerkeleyDatabase::PeriodicFlush()`, and relocking the wallet seems(?) fast (I haven't benchmarked), so should be fine to put in there as well, at least from that perspective?",
      "user": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#issuecomment-2383313791",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30988"
    },
    {
      "event": "commented",
      "id": 2391022009,
      "node_id": "IC_kwDOABII586OhBm5",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2391022009",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-10-03T10:07:55Z",
      "updated_at": "2024-10-03T10:16:06Z",
      "author_association": "CONTRIBUTOR",
      "body": "@pinheadmz, I think that the functionality of \"execute this code after some time\", is not much related to the sockets handling and better be implemented at some higher level, not inside `SockMan`. Maybe the scheduler, like @maflcko suggested, or in the `EventIOLoopCompletedForAllPeers()` method which will be called periodically by `SockMan`:\r\n\r\n```cpp\r\n    /**\r\n     * SockMan has completed send+recv for all nodes.\r\n     * Can be used to execute periodic tasks for all nodes.\r\n     * The implementation in SockMan does nothing.\r\n     */\r\n    virtual void EventIOLoopCompletedForAllPeers();\r\n```\r\n\r\nEdit: I guess `TriggerEvents()` from https://github.com/pinheadmz/bitcoin/commit/42b7240378ffc4890ab4ba1453623e5986ea2a71 can be called from `EventIOLoopCompletedForAllPeers()` or from the scheduler.",
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#issuecomment-2391022009",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30988"
    },
    {
      "event": "mentioned",
      "id": 14501959506,
      "node_id": "MEE_lADOABII586YIJemzwAAAANgYldS",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14501959506",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-10-03T10:07:57Z"
    },
    {
      "event": "subscribed",
      "id": 14501959523,
      "node_id": "SE_lADOABII586YIJemzwAAAANgYldj",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14501959523",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-10-03T10:07:57Z"
    },
    {
      "event": "mentioned",
      "id": 14501959538,
      "node_id": "MEE_lADOABII586YIJemzwAAAANgYldy",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14501959538",
      "actor": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-10-03T10:07:57Z"
    },
    {
      "event": "subscribed",
      "id": 14501959552,
      "node_id": "SE_lADOABII586YIJemzwAAAANgYleA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14501959552",
      "actor": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-10-03T10:07:57Z"
    },
    {
      "event": "commented",
      "id": 2393768768,
      "node_id": "IC_kwDOABII586OrgNA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2393768768",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-10-04T13:54:41Z",
      "updated_at": "2024-10-04T13:56:44Z",
      "author_association": "MEMBER",
      "body": "@vasild if you rebase past #31011, tidy might point out that `sockman.cpp.o depends on i2p.cpp`. So you probably need to either move `i2p.cpp` to common as well, or remove the dependency.",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#issuecomment-2393768768",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30988"
    },
    {
      "event": "mentioned",
      "id": 14519676585,
      "node_id": "MEE_lADOABII586YIJemzwAAAANhcK6p",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14519676585",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-10-04T13:54:43Z"
    },
    {
      "event": "subscribed",
      "id": 14519676599,
      "node_id": "SE_lADOABII586YIJemzwAAAANhcK63",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14519676599",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-10-04T13:54:43Z"
    },
    {
      "event": "reviewed",
      "id": 2349481835,
      "node_id": "PRR_kwDOABII586MCj9r",
      "url": null,
      "actor": null,
      "commit_id": "70c2f13f83a5cc740330d0b4af9cbd74515be6b2",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "body": "",
      "user": {
        "login": "Jacksonearl2468",
        "id": 180059160,
        "node_id": "U_kgDOCrt8GA",
        "avatar_url": "https://avatars.githubusercontent.com/u/180059160?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Jacksonearl2468",
        "html_url": "https://github.com/Jacksonearl2468",
        "followers_url": "https://api.github.com/users/Jacksonearl2468/followers",
        "following_url": "https://api.github.com/users/Jacksonearl2468/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Jacksonearl2468/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Jacksonearl2468/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Jacksonearl2468/subscriptions",
        "organizations_url": "https://api.github.com/users/Jacksonearl2468/orgs",
        "repos_url": "https://api.github.com/users/Jacksonearl2468/repos",
        "events_url": "https://api.github.com/users/Jacksonearl2468/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Jacksonearl2468/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#pullrequestreview-2349481835",
      "submitted_at": "2024-10-05T04:02:01Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
    },
    {
      "event": "labeled",
      "id": 14537194486,
      "node_id": "LE_lADOABII586YIJemzwAAAANie_v2",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14537194486",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-10-07T09:27:40Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 2372105727,
      "node_id": "PRR_kwDOABII586NY3X_",
      "url": null,
      "actor": null,
      "commit_id": "70c2f13f83a5cc740330d0b4af9cbd74515be6b2",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#pullrequestreview-2372105727",
      "submitted_at": "2024-10-16T11:15:53Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
    },
    {
      "event": "reviewed",
      "id": 2373476515,
      "node_id": "PRR_kwDOABII586NeGCj",
      "url": null,
      "actor": null,
      "commit_id": "70c2f13f83a5cc740330d0b4af9cbd74515be6b2",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "ACK 70c2f13f83a5cc740330d0b4af9cbd74515be6b2\r\n\r\nBuilt and ran tests on macos/arm as well as debian/x86.\r\n\r\nSynced to signet with this build on a debian server, then synced from that node locally using the macos build.\r\n\r\nI left a lot of comments below but most are for myself to track during rebases, indicate to the maintainers the depth that I'm actually reviewing, and also some notes for myself -- I'll be rebaing my non-libevent http server on this banch and consuming the new SockMan.\r\n\r\nI have a working branch with my own sock handler for http, so I was able to compare that work to the code in this PR to follow along.\r\n\r\nThere are two areas I am not entirely clear on that I will review more closely in the coming weeks which is I2P stuff, and reviewing all the mutex stuff.\r\n\r\n\r\n<details><summary>Show Signature</summary>\r\n\r\n```\r\n-----BEGIN PGP SIGNED MESSAGE-----\r\nHash: SHA256\r\n\r\nACK 70c2f13f83a5cc740330d0b4af9cbd74515be6b2\r\n-----BEGIN PGP SIGNATURE-----\r\n\r\niQIzBAEBCAAdFiEE5hdzzW4BBA4vG9eM5+KYS2KJyToFAmcSeTIACgkQ5+KYS2KJ\r\nyTp/1A//ZzhksZzWlBbV6rcfIXnUVQS0SIgmY7sZCN8AN0RoiN4ECALWyrXz9Rdg\r\nfONCWiQSTyxE5u2TnFo7os+o0Z+3ybxApufAx/OzqHaJwR8d5wnZPHU/uFTPYm/z\r\nqArPT3SHQgKb1sftt8S5ve7j37RW7IbshiJ+6bq8+DNMY1Ep1DX4BBzZgwbzx2ek\r\nqMcRFQkOkTbJg3/yOT1Vz361qCPLmbKjvbRyjYgYYG7oxtdwb5r/ezeagSCWKDJo\r\nYx/DJ2cwZ3uMWDvfnhNJOeql4MhOLZcU5hKyGGTRT3B5ER7ELNye5+Sz+pv0cJuP\r\nR+zfoxAfYV3opqB/ewTD1sM+gtFZFUiLNHigPgKFmK5GerLguXUqY+vgQ/4VIEpg\r\nXD2tHOCwwDULsekVLZ+hXJPSTBDmZAlHmJvcCBQgzLkjCMvrlmxJR8KpKg3lDgKM\r\nGwFcYoIWubyFKgRCAQL6vc1qFnGc7PJ1TWJLoKxpjXeyE6igHquSK0KE3flhCJ97\r\nCpWhZflrHwcaomSf9bDYsSaNvMN2MiFUzC4lbmLRWTzeOCS9oMFRMcIayQ+psUqC\r\n0gmbZzi+Qcf32gCNYvhxYwKqTeAlKih9x+vurTuK8831AZoUYwusetGaTsklwvOn\r\nbDpgEGoqFPdPIB8yHAiFBwQPcGmn7tVmTbVhck59B3HvdS/wOr4=\r\n=rnjt\r\n-----END PGP SIGNATURE-----\r\n```\r\n\r\npinheadmz's public key is [on keybase](https://keybase.io/pinheadmz/pgp_keys.asc?fingerprint=e61773cd6e01040e2f1bd78ce7e2984b6289c93a)\r\n</details>\r\n",
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#pullrequestreview-2373476515",
      "submitted_at": "2024-10-18T15:14:27Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
    },
    {
      "event": "review_requested",
      "id": 14722788692,
      "node_id": "RRE_lADOABII586YIJemzwAAAANti-1U",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14722788692",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-10-18T15:14:31Z",
      "requested_reviewer": {
        "login": "tdb3",
        "id": 106488469,
        "node_id": "U_kgDOBljilQ",
        "avatar_url": "https://avatars.githubusercontent.com/u/106488469?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/tdb3",
        "html_url": "https://github.com/tdb3",
        "followers_url": "https://api.github.com/users/tdb3/followers",
        "following_url": "https://api.github.com/users/tdb3/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/tdb3/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/tdb3/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/tdb3/subscriptions",
        "organizations_url": "https://api.github.com/users/tdb3/orgs",
        "repos_url": "https://api.github.com/users/tdb3/repos",
        "events_url": "https://api.github.com/users/tdb3/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/tdb3/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "subscribed",
      "id": 14728527368,
      "node_id": "SE_lADOABII586YIJemzwAAAANt434I",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14728527368",
      "actor": {
        "login": "0xB10C",
        "id": 19157360,
        "node_id": "MDQ6VXNlcjE5MTU3MzYw",
        "avatar_url": "https://avatars.githubusercontent.com/u/19157360?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/0xB10C",
        "html_url": "https://github.com/0xB10C",
        "followers_url": "https://api.github.com/users/0xB10C/followers",
        "following_url": "https://api.github.com/users/0xB10C/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/0xB10C/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/0xB10C/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/0xB10C/subscriptions",
        "organizations_url": "https://api.github.com/users/0xB10C/orgs",
        "repos_url": "https://api.github.com/users/0xB10C/repos",
        "events_url": "https://api.github.com/users/0xB10C/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/0xB10C/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-10-19T00:27:08Z"
    },
    {
      "event": "commented",
      "id": 2426964142,
      "node_id": "IC_kwDOABII586QqIiu",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2426964142",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-10-21T15:09:15Z",
      "updated_at": "2024-10-21T15:09:15Z",
      "author_association": "MEMBER",
      "body": "cc @theuni any takes?",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#issuecomment-2426964142",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30988"
    },
    {
      "event": "mentioned",
      "id": 14766693192,
      "node_id": "MEE_lADOABII586YIJemzwAAAANwKdtI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14766693192",
      "actor": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-10-21T15:09:17Z"
    },
    {
      "event": "subscribed",
      "id": 14766693210,
      "node_id": "SE_lADOABII586YIJemzwAAAANwKdta",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14766693210",
      "actor": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-10-21T15:09:17Z"
    },
    {
      "event": "labeled",
      "id": 14967071246,
      "node_id": "LE_lADOABII586YIJemzwAAAAN8G2IO",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14967071246",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-10-28T17:52:52Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2476925664,
      "node_id": "IC_kwDOABII586TouLg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2476925664",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-11-14T16:47:02Z",
      "updated_at": "2024-11-14T16:50:12Z",
      "author_association": "MEMBER",
      "body": "This needs a rebase. Otherwise it's non-trivial for me to keep https://github.com/Sjors/bitcoin/pull/67 rebased.\r\n\r\nConflicts:\r\n* https://github.com/bitcoin/bitcoin/pull/30937",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#issuecomment-2476925664",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30988"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15301694425,
      "node_id": "HRFPE_lADOABII586YIJemzwAAAAOQDVPZ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15301694425",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "c4f51c7f61e6c4e291025e450f6dd97c2b939b56",
      "commit_url": "https://api.github.com/repos/vasild/bitcoin/commits/c4f51c7f61e6c4e291025e450f6dd97c2b939b56",
      "created_at": "2024-11-14T16:55:15Z"
    },
    {
      "event": "commented",
      "id": 2476951015,
      "node_id": "IC_kwDOABII586To0Xn",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2476951015",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-11-14T16:58:07Z",
      "updated_at": "2024-11-14T16:58:07Z",
      "author_association": "CONTRIBUTOR",
      "body": "`70c2f13f83...c4f51c7f61`: rebase due to conflicts, next I will look at @pinheadmz feedback above and implement changes from coredev discussions:\r\n\r\n* Store the node id -> CNode map in SockMan (then the SockMan class becomes templated)\r\n* SockMan <-> Connman calls based on CNode, not node id\r\n* Make the virtual methods in SockMan private, since they are called only from SockMan\r\n",
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#issuecomment-2476951015",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30988"
    },
    {
      "event": "mentioned",
      "id": 15301729382,
      "node_id": "MEE_lADOABII586YIJemzwAAAAOQDdxm",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15301729382",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-11-14T16:58:09Z"
    },
    {
      "event": "subscribed",
      "id": 15301729394,
      "node_id": "SE_lADOABII586YIJemzwAAAAOQDdxy",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15301729394",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-11-14T16:58:09Z"
    },
    {
      "event": "unlabeled",
      "id": 15302192423,
      "node_id": "UNLE_lADOABII586YIJemzwAAAAOQFO0n",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15302192423",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-11-14T17:33:38Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "unlabeled",
      "id": 15303158917,
      "node_id": "UNLE_lADOABII586YIJemzwAAAAOQI6yF",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15303158917",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-11-14T18:59:43Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15349386514,
      "node_id": "HRFPE_lADOABII586YIJemzwAAAAOS5Q0S",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15349386514",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "2b0103705fefddff6b880b9eb72fb590740a7300",
      "commit_url": "https://api.github.com/repos/vasild/bitcoin/commits/2b0103705fefddff6b880b9eb72fb590740a7300",
      "created_at": "2024-11-19T13:15:12Z"
    },
    {
      "event": "commented",
      "id": 2485715952,
      "node_id": "IC_kwDOABII586UKQPw",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2485715952",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-11-19T13:28:24Z",
      "updated_at": "2024-11-19T13:28:24Z",
      "author_association": "CONTRIBUTOR",
      "body": "`c4f51c7f61...2b0103705f`: rebase and make the virtual methods of `SockMan` private since they are only used by `SockMan`.\r\n\r\nAbout storing the `CNode` in `SockMan` (which would be templated like `SockMan<CNode>`) and making the communication between `SockMan` and the higher class (e.g. `CConnman`) based on `CNode` instead of node id: this is an excellent idea that will make the code more straight-forward and the higher classes simpler. However it would make this PR larger. I will leave it off for now. There is some specific `CNode` ref-counting in `CConnman` and the code around deleting a node is a bit complicated, so it would require further non-trivial changes to move that to `SockMan`.\r\n\r\nI think in general, in the long term, independently of this PR, it would be good to get rid of the manual `CNode` ref-counting and tap `std::shared_ptr` to do that for us. In other words, to revive https://github.com/bitcoin/bitcoin/pull/28222.",
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#issuecomment-2485715952",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30988"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15510275499,
      "node_id": "HRFPE_lADOABII586YIJemzwAAAAOcfAWr",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15510275499",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "645f625e29b36321bcba8db5758b0428b8ebd80f",
      "commit_url": "https://api.github.com/repos/vasild/bitcoin/commits/645f625e29b36321bcba8db5758b0428b8ebd80f",
      "created_at": "2024-12-03T13:59:28Z"
    },
    {
      "event": "commented",
      "id": 2514637932,
      "node_id": "IC_kwDOABII586V4lRs",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2514637932",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-12-03T13:59:38Z",
      "updated_at": "2024-12-03T13:59:38Z",
      "author_association": "CONTRIBUTOR",
      "body": "`2b0103705f...645f625e29`: rebase and address suggestions",
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#issuecomment-2514637932",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30988"
    },
    {
      "event": "labeled",
      "id": 15560141466,
      "node_id": "LE_lADOABII586YIJemzwAAAAOfdOqa",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15560141466",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-12-06T13:05:12Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 2493471520,
      "node_id": "PRR_kwDOABII586Un1sg",
      "url": null,
      "actor": null,
      "commit_id": "645f625e29b36321bcba8db5758b0428b8ebd80f",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#pullrequestreview-2493471520",
      "submitted_at": "2024-12-10T20:12:05Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
    },
    {
      "event": "commented",
      "id": 2552624259,
      "node_id": "IC_kwDOABII586YJfSD",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2552624259",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-12-19T02:07:54Z",
      "updated_at": "2024-12-19T02:57:51Z",
      "author_association": "MEMBER",
      "body": "Looks like the merge conflict is with #31072 as well as #31223.",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#issuecomment-2552624259",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30988"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15712190038,
      "node_id": "HRFPE_lADOABII586YIJemzwAAAAOohP5W",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15712190038",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "b8b042626ea65c2c2b355a6de69cb7c98bd04de3",
      "commit_url": "https://api.github.com/repos/vasild/bitcoin/commits/b8b042626ea65c2c2b355a6de69cb7c98bd04de3",
      "created_at": "2024-12-19T05:48:11Z"
    },
    {
      "event": "commented",
      "id": 2552841151,
      "node_id": "IC_kwDOABII586YKUO_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2552841151",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-12-19T05:48:57Z",
      "updated_at": "2024-12-19T05:48:57Z",
      "author_association": "CONTRIBUTOR",
      "body": "`645f625e29...b8b042626e`: rebase due to conflicts and use `std::span` instead of `Span` in new code: https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1878764170",
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#issuecomment-2552841151",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30988"
    },
    {
      "event": "unlabeled",
      "id": 15712672155,
      "node_id": "UNLE_lADOABII586YIJemzwAAAAOojFmb",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15712672155",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-12-19T06:54:27Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "labeled",
      "id": 15773413276,
      "node_id": "LE_lADOABII586YIJemzwAAAAOsKy-c",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15773413276",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-12-27T15:06:51Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15906018639,
      "node_id": "HRFPE_lADOABII586YIJemzwAAAAO0EpVP",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15906018639",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "f71f1a346c71909750e5e7d11305dd0a1c24373c",
      "commit_url": "https://api.github.com/repos/vasild/bitcoin/commits/f71f1a346c71909750e5e7d11305dd0a1c24373c",
      "created_at": "2025-01-13T14:31:15Z"
    },
    {
      "event": "commented",
      "id": 2587261731,
      "node_id": "IC_kwDOABII586aNnsj",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2587261731",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-13T14:31:34Z",
      "updated_at": "2025-01-13T14:31:34Z",
      "author_association": "CONTRIBUTOR",
      "body": "`b8b042626e...f71f1a346c`: rebase due to conflicts",
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#issuecomment-2587261731",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30988"
    },
    {
      "event": "unlabeled",
      "id": 15906562198,
      "node_id": "UNLE_lADOABII586YIJemzwAAAAO0GuCW",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15906562198",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-13T14:58:27Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2590020502,
      "node_id": "IC_kwDOABII586aYJOW",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2590020502",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-14T14:09:51Z",
      "updated_at": "2025-01-14T14:09:51Z",
      "author_association": "MEMBER",
      "body": "I found myself confused by e8b589ef45d5c94c47209fb952e8b05d631a9c47 dropping `AddSocketPermissionFlags`. Can you move that to a separate (earlier?) commit?",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#issuecomment-2590020502",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30988"
    },
    {
      "event": "reviewed",
      "id": 2550005361,
      "node_id": "PRR_kwDOABII586X_f5x",
      "url": null,
      "actor": null,
      "commit_id": "f71f1a346c71909750e5e7d11305dd0a1c24373c",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#pullrequestreview-2550005361",
      "submitted_at": "2025-01-14T15:31:47Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15926435616,
      "node_id": "HRFPE_lADOABII586YIJemzwAAAAO1Sh8g",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15926435616",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "d83ff66fd74654e67b56d11a7d8e92d38a4bd17a",
      "commit_url": "https://api.github.com/repos/vasild/bitcoin/commits/d83ff66fd74654e67b56d11a7d8e92d38a4bd17a",
      "created_at": "2025-01-14T16:39:29Z"
    },
    {
      "event": "commented",
      "id": 2590500946,
      "node_id": "IC_kwDOABII586aZ-hS",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2590500946",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-14T16:40:02Z",
      "updated_at": "2025-01-14T16:40:02Z",
      "author_association": "CONTRIBUTOR",
      "body": "`f71f1a346c...d83ff66fd7`:\r\n\r\n> ... dropping `AddSocketPermissionFlags`. Can you move that to a separate (earlier?) commit?\r\n\r\nDone.",
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#issuecomment-2590500946",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30988"
    },
    {
      "event": "labeled",
      "id": 15927367862,
      "node_id": "LE_lADOABII586YIJemzwAAAAO1WFi2",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15927367862",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-14T17:33:05Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15927448074,
      "node_id": "HRFPE_lADOABII586YIJemzwAAAAO1WZIK",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15927448074",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "bcf1254e91782a33b5a1db542f3758831e0bfe2e",
      "commit_url": "https://api.github.com/repos/vasild/bitcoin/commits/bcf1254e91782a33b5a1db542f3758831e0bfe2e",
      "created_at": "2025-01-14T17:37:26Z"
    },
    {
      "event": "commented",
      "id": 2590687348,
      "node_id": "IC_kwDOABII586aasB0",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2590687348",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-14T17:41:46Z",
      "updated_at": "2025-01-14T17:41:46Z",
      "author_association": "CONTRIBUTOR",
      "body": "`d83ff66fd7...bcf1254e91`: adjust test after change of the log message in the previous push",
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#issuecomment-2590687348",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30988"
    },
    {
      "event": "unlabeled",
      "id": 15928937968,
      "node_id": "UNLE_lADOABII586YIJemzwAAAAO1cE3w",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15928937968",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-14T19:02:37Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 2552280742,
      "node_id": "PRR_kwDOABII586YILam",
      "url": null,
      "actor": null,
      "commit_id": "bcf1254e91782a33b5a1db542f3758831e0bfe2e",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "> > ... dropping `AddSocketPermissionFlags`. Can you move that to a separate (earlier?) commit?\r\n> \r\n> Done.\r\n\r\nThanks. Don't forget to drop \"Also, separate the listening socket from the permissions\" from the commit description of e5d36eea015efc31aa38d540af4cf39c9e2e46b0.\r\n\r\nAlong similar lines, though less important, you could also have a separate commit that drops `ListenSocket` and introduces `m_listen` as a member of `CConnman`, before moving it to `Sockman`.\r\n\r\n(it makes `git show --color-moved=dimmed-zebra` more grey, less red and green when you introduce `SockMan`)",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#pullrequestreview-2552280742",
      "submitted_at": "2025-01-15T11:28:21Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
    },
    {
      "event": "reviewed",
      "id": 2552366143,
      "node_id": "PRR_kwDOABII586YIgQ_",
      "url": null,
      "actor": null,
      "commit_id": "bcf1254e91782a33b5a1db542f3758831e0bfe2e",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Reviewed up to 1b05e1d4ba55a42ba74026b68fa4e616b973e06d.",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#pullrequestreview-2552366143",
      "submitted_at": "2025-01-15T12:37:21Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
    },
    {
      "event": "reviewed",
      "id": 2552728389,
      "node_id": "PRR_kwDOABII586YJ4tF",
      "url": null,
      "actor": null,
      "commit_id": "bcf1254e91782a33b5a1db542f3758831e0bfe2e",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#pullrequestreview-2552728389",
      "submitted_at": "2025-01-15T13:32:28Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
    },
    {
      "event": "reviewed",
      "id": 2552832660,
      "node_id": "PRR_kwDOABII586YKSKU",
      "url": null,
      "actor": null,
      "commit_id": "bcf1254e91782a33b5a1db542f3758831e0bfe2e",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Concept ACK",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#pullrequestreview-2552832660",
      "submitted_at": "2025-01-15T14:25:01Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
    },
    {
      "event": "reviewed",
      "id": 2559620130,
      "node_id": "PRR_kwDOABII586YkLQi",
      "url": null,
      "actor": null,
      "commit_id": "bcf1254e91782a33b5a1db542f3758831e0bfe2e",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#pullrequestreview-2559620130",
      "submitted_at": "2025-01-17T17:48:05Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
    },
    {
      "event": "reviewed",
      "id": 2570362263,
      "node_id": "PRR_kwDOABII586ZNJ2X",
      "url": null,
      "actor": null,
      "commit_id": "bcf1254e91782a33b5a1db542f3758831e0bfe2e",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#pullrequestreview-2570362263",
      "submitted_at": "2025-01-23T16:18:36Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16096912166,
      "node_id": "HRFPE_lADOABII586YIJemzwAAAAO_c2Mm",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16096912166",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "266ac3267390270e6794d478aa1fbe40e88ffb0f",
      "commit_url": "https://api.github.com/repos/vasild/bitcoin/commits/266ac3267390270e6794d478aa1fbe40e88ffb0f",
      "created_at": "2025-01-28T17:18:56Z"
    },
    {
      "event": "commented",
      "id": 2619619537,
      "node_id": "IC_kwDOABII586cJDjR",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2619619537",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-28T17:20:15Z",
      "updated_at": "2025-01-28T17:20:15Z",
      "author_association": "CONTRIBUTOR",
      "body": "`bcf1254e91...266ac32673`: address suggestions\r\n\r\n> Don't forget to drop \"Also, separate ...\r\n\r\nDone.\r\n\r\n> Along similar lines, though less important, you could also have a separate commit that drops `ListenSocket` ...\r\n\r\nDone.\r\n\r\nThanks!",
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#issuecomment-2619619537",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30988"
    },
    {
      "event": "commented",
      "id": 2619994736,
      "node_id": "IC_kwDOABII586cKfJw",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2619994736",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-28T20:29:53Z",
      "updated_at": "2025-01-28T20:29:53Z",
      "author_association": "MEMBER",
      "body": "Something else I see using Sockman is in the `mempool_limit` functional test, we call `getrawtransaction` and expect around 540,000 bytes back. The call to `send()` returns the total amount of bytes immediately, but it requires 60-70 TCP packets to actually transmit the response. I think what I'm seeing in wireshark is that this transmission is incomplete when I close the HTTP connection with `CloseConnection()` which closes the underlying socket. The client waits 120 seconds for the rest of its data which never arrives before timing out. I'm not sure if there's a flag in one of the syscalls or another way to check the kernel's socket buffer before closing?\r\n",
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#issuecomment-2619994736",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30988"
    },
    {
      "event": "commented",
      "id": 2622122439,
      "node_id": "IC_kwDOABII586cSmnH",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2622122439",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-29T16:27:14Z",
      "updated_at": "2025-01-29T16:27:14Z",
      "author_association": "CONTRIBUTOR",
      "body": "> Something else I see using Sockman is in the `mempool_limit` functional test, we call `getrawtransaction` and expect around 540,000 bytes back. The call to `send()` returns the total amount of bytes immediately ...\r\n\r\nHmm, what I observed is that the send call sends less bytes than requested.\r\n\r\n_(Lets move the discussion away from the main thread of this PR into the below link)_\r\n\r\nSome a more elaborate explanation plus patch that fixes the problem in https://github.com/pinheadmz/bitcoin/commit/df1965a4e97ce7f3df067df9b3dcc2bbd8e6e15b#r151906181",
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#issuecomment-2622122439",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30988"
    },
    {
      "event": "labeled",
      "id": 16115116713,
      "node_id": "LE_lADOABII586YIJemzwAAAAPAiSqp",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16115116713",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-29T22:00:56Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16124841862,
      "node_id": "HRFPE_lADOABII586YIJemzwAAAAPBHY-G",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16124841862",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "7866c736c87a908cef75dc6901c9c0594c65b0eb",
      "commit_url": "https://api.github.com/repos/vasild/bitcoin/commits/7866c736c87a908cef75dc6901c9c0594c65b0eb",
      "created_at": "2025-01-30T14:01:58Z"
    },
    {
      "event": "commented",
      "id": 2624601401,
      "node_id": "IC_kwDOABII586ccD05",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2624601401",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-30T14:02:16Z",
      "updated_at": "2025-01-30T14:02:16Z",
      "author_association": "CONTRIBUTOR",
      "body": "`266ac32673...7866c736c8`: rebase due to conflicts",
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#issuecomment-2624601401",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30988"
    },
    {
      "event": "unlabeled",
      "id": 16125628183,
      "node_id": "UNLE_lADOABII586YIJemzwAAAAPBKY8X",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16125628183",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-30T15:03:32Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 2584231283,
      "node_id": "PRR_kwDOABII586aCD1z",
      "url": null,
      "actor": null,
      "commit_id": "248ec2d2687fae47b63688e00b9ef18d4c0c9676",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#pullrequestreview-2584231283",
      "submitted_at": "2025-01-30T15:25:18Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
    },
    {
      "event": "unsubscribed",
      "id": 16129570956,
      "node_id": "UE_lADOABII586YIJemzwAAAAPBZbiM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16129570956",
      "actor": {
        "login": "PRADACANDI18",
        "id": 91190628,
        "node_id": "MDQ6VXNlcjkxMTkwNjI4",
        "avatar_url": "https://avatars.githubusercontent.com/u/91190628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/PRADACANDI18",
        "html_url": "https://github.com/PRADACANDI18",
        "followers_url": "https://api.github.com/users/PRADACANDI18/followers",
        "following_url": "https://api.github.com/users/PRADACANDI18/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/PRADACANDI18/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/PRADACANDI18/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/PRADACANDI18/subscriptions",
        "organizations_url": "https://api.github.com/users/PRADACANDI18/orgs",
        "repos_url": "https://api.github.com/users/PRADACANDI18/repos",
        "events_url": "https://api.github.com/users/PRADACANDI18/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/PRADACANDI18/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-30T20:14:23Z"
    },
    {
      "event": "reviewed",
      "id": 2586038876,
      "node_id": "PRR_kwDOABII586aI9Jc",
      "url": null,
      "actor": null,
      "commit_id": "7866c736c87a908cef75dc6901c9c0594c65b0eb",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Reviewing in reverse order.\r\n\r\nf7dd4373b06daf34033fa84fa99408a3938e4ad4 is a beast, but looks correct. I'm not sure if it can be split further. There's some mixing of code modernisation with the move which make the diff a bit trickier to follow.",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#pullrequestreview-2586038876",
      "submitted_at": "2025-01-31T14:24:13Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
    },
    {
      "event": "reviewed",
      "id": 2582270517,
      "node_id": "PRR_kwDOABII586Z6lI1",
      "url": null,
      "actor": null,
      "commit_id": "7866c736c87a908cef75dc6901c9c0594c65b0eb",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Concept ACK 46131d44faeb797909e0fc3a2042492adef9aa0d\r\n\r\n(Still plan to check some in-depth aspects).\r\n\r\nNice to separate out some concerns!\r\n\r\nRelieved to see sockets actually moved down into `Sockman` in next-to-last commit. :)\r\n\r\n#### WinSock\r\n\r\nWould be nice to have socket/WinSock code in fewer files. Current status:\r\n```\r\n₿ git grep -c -E \"\\bWSA\"\r\nsrc/common/pcp.cpp:10\r\nsrc/common/sockman.cpp:13\r\nsrc/common/system.cpp:2\r\nsrc/compat/compat.h:12\r\nsrc/net.cpp:1\r\nsrc/netbase.cpp:11\r\nsrc/util/sock.cpp:5\r\n```\r\nCould at least remove the remaining call in *net.cpp* by moving `CNetCleanup` to *sockman.cpp*?\r\n\r\n#### Terminology\r\n\r\nnit: I prefer \"local\"/\"remote\" or \"self\"/\"other\" over \"me\"/\"them\". `i2p::Connection` uses \"me\"/\"peer\" though.\r\n\r\n#### 7866c736c87a908cef75dc6901c9c0594c65b0eb / net: move-only: improve encapsulation of SockMan\r\n\r\nCommit message typo: `m_listen private`\r\n\r\n#### 645f83354c0304fd339a45d9439084a44b7ca415 / net: reduce CAddress usage to CService or CNetAddr\r\n\r\nAre we going to change file/network serialization by switching `CAddress` -> `CService`? Might try to answer this in later review.",
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#pullrequestreview-2582270517",
      "submitted_at": "2025-02-01T20:37:50Z",
      "state": "CHANGES_REQUESTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
    },
    {
      "event": "reviewed",
      "id": 2589941779,
      "node_id": "PRR_kwDOABII586aX2AT",
      "url": null,
      "actor": null,
      "commit_id": "7866c736c87a908cef75dc6901c9c0594c65b0eb",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#pullrequestreview-2589941779",
      "submitted_at": "2025-02-03T13:56:45Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
    },
    {
      "event": "labeled",
      "id": 16197451210,
      "node_id": "LE_lADOABII586YIJemzwAAAAPFcX3K",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16197451210",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-02-05T16:23:35Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2637415972,
      "node_id": "IC_kwDOABII586dM8Yk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2637415972",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-02-05T16:26:06Z",
      "updated_at": "2025-02-05T16:26:06Z",
      "author_association": "MEMBER",
      "body": "Merge conflict is probably from #25832.",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#issuecomment-2637415972",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30988"
    },
    {
      "event": "reviewed",
      "id": 2598938658,
      "node_id": "PRR_kwDOABII586a6Kgi",
      "url": null,
      "actor": null,
      "commit_id": "7866c736c87a908cef75dc6901c9c0594c65b0eb",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#pullrequestreview-2598938658",
      "submitted_at": "2025-02-06T14:58:32Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
    },
    {
      "event": "reviewed",
      "id": 2599369355,
      "node_id": "PRR_kwDOABII586a7zqL",
      "url": null,
      "actor": null,
      "commit_id": "7866c736c87a908cef75dc6901c9c0594c65b0eb",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#pullrequestreview-2599369355",
      "submitted_at": "2025-02-06T17:07:14Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16229403992,
      "node_id": "HRFPE_lADOABII586YIJemzwAAAAPHWQ1Y",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16229403992",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "7d84f431f9fd89b647f385ea5224b5ad76236844",
      "commit_url": "https://api.github.com/repos/vasild/bitcoin/commits/7d84f431f9fd89b647f385ea5224b5ad76236844",
      "created_at": "2025-02-07T19:25:32Z"
    },
    {
      "event": "commented",
      "id": 2643842804,
      "node_id": "IC_kwDOABII586dldb0",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2643842804",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-02-07T19:26:45Z",
      "updated_at": "2025-02-07T19:26:45Z",
      "author_association": "CONTRIBUTOR",
      "body": "`7866c736c8...7d84f431f9`: rebase due to conflicts and address suggestions\r\n\r\nInterface changes:\r\n\r\n`SockMan::CloseSockets()` renamed to\r\n`SockMan::StopListening()`\r\n\r\n`SockMan::GetNewNodeId()` renamed to\r\n`SockMan::GetNewId()`\r\n\r\n`NodeId` renamed to\r\n`SockMan::Id`\r\n\r\n`SockMan::EventI2PListen()` renamed to\r\n`SockMan::EventI2PStatus()` and instead of `bool` it now takes an `enum I2PStatus` argument\r\n\r\n`SockMan::EventIOLoopCompletedForNode()` renamed to\r\n`SockMan::EventIOLoopCompletedForOne()`\r\n\r\n`SockMan::EventIOLoopCompletedForAllPeers()` renamed to\r\n`SockMan::EventIOLoopCompletedForAll()`\r\n\r\n`EventGotData()` now takes `std::span` instead of pointer+length\r\n\r\n`SockMan::ConnectAndMakeNodeId()` renamed to\r\n`SockMan::ConnectAndMakeId()` and takes `std::optional<Proxy>` instead of `Proxy` to more clearly denote the \"no proxy given\" case (empty optional, was an invalid proxy before).\r\n\r\nprivate:\r\n\r\n`SockMan::NodeSockets` renamed to\r\n`SockMan::ConnectionSockets`\r\n\r\n`SockMan::GetNodeSockets()` renamed to\r\n`SockMan::GetConnectionSockets()`\r\n",
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#issuecomment-2643842804",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30988"
    },
    {
      "event": "commented",
      "id": 2647374260,
      "node_id": "IC_kwDOABII586dy7m0",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2647374260",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-02-10T09:12:25Z",
      "updated_at": "2025-02-10T09:12:25Z",
      "author_association": "CONTRIBUTOR",
      "body": "It is better to post such suggestions not in the main thread of the PR but as a comment to some line of code, even if that is a random, unrelated line. That way replies will be grouped together with the questions instead of being scattered around in the main PR thread. In the main thread it is easier to forget to reply to some questions. As comments to some line of code, they can be tracked and eventually \"resolved\" to collapse them and reduce the main PR thread noise.\r\n\r\n> #### WinSock\r\n> \r\n> Would be nice to have socket/WinSock code in fewer files. Current status:\r\n> ...\r\n> Could at least remove the remaining call in _net.cpp_ by moving `CNetCleanup` to _sockman.cpp_?\r\n\r\nI agree, but that is out of the scope of this PR, even `CNetCleanup` is untouched by this PR, so I will leave it as it is.\r\n\r\n> #### Terminology\r\n> \r\n> nit: I prefer \"local\"/\"remote\" or \"self\"/\"other\" over \"me\"/\"them\". `i2p::Connection` uses \"me\"/\"peer\" though.\r\n\r\nNo strong opinion.\r\n\r\n> #### [7866c73](https://github.com/bitcoin/bitcoin/commit/7866c736c87a908cef75dc6901c9c0594c65b0eb) / net: move-only: improve encapsulation of SockMan\r\n> \r\n> Commit message typo: `m_listen private`\r\n\r\nFixed.\r\n\r\n> #### [645f833](https://github.com/bitcoin/bitcoin/commit/645f83354c0304fd339a45d9439084a44b7ca415) / net: reduce CAddress usage to CService or CNetAddr\r\n> \r\n> Are we going to change file/network serialization by switching `CAddress` -> `CService`? Might try to answer this in later review.\r\n\r\nNo.",
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#issuecomment-2647374260",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30988"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16246173212,
      "node_id": "HRFPE_lADOABII586YIJemzwAAAAPIWO4c",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16246173212",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "7b63b4ca1c4bc82bb1673313b326888cdb7eda9b",
      "commit_url": "https://api.github.com/repos/vasild/bitcoin/commits/7b63b4ca1c4bc82bb1673313b326888cdb7eda9b",
      "created_at": "2025-02-10T11:43:17Z"
    },
    {
      "event": "commented",
      "id": 2647781404,
      "node_id": "IC_kwDOABII586d0fAc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2647781404",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-02-10T11:59:50Z",
      "updated_at": "2025-02-10T11:59:50Z",
      "author_association": "CONTRIBUTOR",
      "body": "`7d84f431f9...7b63b4ca1c`: minor repush to elaborate a commit message as suggested.\r\n\r\nAre you in the mood of reviewing a change to this PR, https://github.com/bitcoin/bitcoin/pull/30988#issuecomment-2485715952, that stores the \"client\" objects in `SockMan` (as `shared_ptr`, not as raw pointers)? In the case of `CConnman` that is `CNode`. This will:\r\n* make the interaction between `SockMan` and `CConnman` simpler\r\n* probably faster (less lookups by id)\r\n* resolve the issue in https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1935423919\r\n* resolve the issue which https://github.com/bitcoin/bitcoin/pull/28222 tried to resolve\r\n* will get rid of the manual `CNode` reference counting (`CNode::AddRef()`).\r\n\r\nOr I could find a smaller workaround to https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1935423919.",
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#issuecomment-2647781404",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30988"
    },
    {
      "event": "commented",
      "id": 2647888735,
      "node_id": "IC_kwDOABII586d05Nf",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2647888735",
      "actor": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-02-10T12:47:21Z",
      "updated_at": "2025-02-10T12:48:33Z",
      "author_association": "CONTRIBUTOR",
      "body": "Would really like to get rid of the custom ref-counting of `CNode` and avoid id-lookups. But fear it will grow this PR a bit much.\r\n\r\nWhy not remove the custom ref-counting as a separate PR to begin with? Things like https://github.com/bitcoin/bitcoin/pull/28222#discussion_r1288400379 make me think it may not be trivial, but maybe you have a more elegant approach.\r\n\r\nI personally commit to review regardless of whether you split it out to it's own PR.",
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#issuecomment-2647888735",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30988"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16294421858,
      "node_id": "HRFPE_lADOABII586YIJemzwAAAAPLOSVi",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16294421858",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "c4ab7f82d6a4265fb96159b6c973ad849df4f8b9",
      "commit_url": "https://api.github.com/repos/vasild/bitcoin/commits/c4ab7f82d6a4265fb96159b6c973ad849df4f8b9",
      "created_at": "2025-02-13T10:41:41Z"
    },
    {
      "event": "commented",
      "id": 2656192834,
      "node_id": "IC_kwDOABII586eUklC",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2656192834",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-02-13T10:42:09Z",
      "updated_at": "2025-02-13T10:42:09Z",
      "author_association": "CONTRIBUTOR",
      "body": "`7b63b4ca1c...c4ab7f82d6`: rebase due to conflicts and address a suggestion",
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#issuecomment-2656192834",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30988"
    },
    {
      "event": "commented",
      "id": 2656216742,
      "node_id": "IC_kwDOABII586eUqam",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2656216742",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-02-13T10:52:02Z",
      "updated_at": "2025-02-13T10:52:02Z",
      "author_association": "CONTRIBUTOR",
      "body": "Extracted the first commit into https://github.com/bitcoin/bitcoin/pull/31854. It is not strictly related to this PR and makes sense on its own. If merged will reduce the size of this PR.",
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#issuecomment-2656216742",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30988"
    },
    {
      "event": "unlabeled",
      "id": 16296097831,
      "node_id": "UNLE_lADOABII586YIJemzwAAAAPLUrgn",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16296097831",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-02-13T12:51:58Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2657080863,
      "node_id": "IC_kwDOABII586eX9Yf",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2657080863",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-02-13T16:09:26Z",
      "updated_at": "2025-02-13T16:09:26Z",
      "author_association": "MEMBER",
      "body": "Can you update the PR description to say that this is based on #31854? The convention then is to mark this PR draft until that one is merged.\r\n\r\nAdditionally, it's 25% easier to review #31854 if you rebase this PR on the exact same commit. Since then I can just range-diff it with what I already reviewed here. ",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#issuecomment-2657080863",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30988"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16307825317,
      "node_id": "HRFPE_lADOABII586YIJemzwAAAAPMBaql",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16307825317",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "563afdd975771cd2b87c4a96e0059f1c6f8774ad",
      "commit_url": "https://api.github.com/repos/vasild/bitcoin/commits/563afdd975771cd2b87c4a96e0059f1c6f8774ad",
      "created_at": "2025-02-14T08:37:14Z"
    },
    {
      "event": "commented",
      "id": 2658649883,
      "node_id": "IC_kwDOABII586ed8cb",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2658649883",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-02-14T08:54:56Z",
      "updated_at": "2025-02-14T08:56:08Z",
      "author_association": "CONTRIBUTOR",
      "body": "`c4ab7f82d6...563afdd975`: pick change from https://github.com/bitcoin/bitcoin/pull/31854 into the first commit of this PR\r\n\r\n> Can you update the PR description to say that this is based on #31854? The convention then is to mark this PR draft until that one is merged.\r\n\r\nAdded a note at the bottom of the description of this PR. This PR was not a draft before #31854. The creation of #31854 did not change anything about this PR, so I think the existence of a chop off PR shouldn't render this one as a draft. There is no dependency between the two - either one can be merged first.\r\n\r\n> Additionally, it's 25% easier to review #31854 if you rebase this PR on the exact same commit. Since then I can just range-diff it with what I already reviewed here.\r\n\r\nDone.",
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#issuecomment-2658649883",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30988"
    },
    {
      "event": "reviewed",
      "id": 2617479050,
      "node_id": "PRR_kwDOABII586cA4-K",
      "url": null,
      "actor": null,
      "commit_id": "563afdd975771cd2b87c4a96e0059f1c6f8774ad",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#pullrequestreview-2617479050",
      "submitted_at": "2025-02-14T11:12:28Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16310821618,
      "node_id": "HRFPE_lADOABII586YIJemzwAAAAPMM2Ly",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16310821618",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "e1671ff42c385f611af778380a83e98920cee82e",
      "commit_url": "https://api.github.com/repos/vasild/bitcoin/commits/e1671ff42c385f611af778380a83e98920cee82e",
      "created_at": "2025-02-14T12:17:47Z"
    },
    {
      "event": "commented",
      "id": 2659191470,
      "node_id": "IC_kwDOABII586egAqu",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2659191470",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-02-14T12:18:07Z",
      "updated_at": "2025-02-14T12:18:07Z",
      "author_association": "CONTRIBUTOR",
      "body": "`563afdd975...e1671ff42c`: do https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1955976383",
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#issuecomment-2659191470",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30988"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16329827869,
      "node_id": "HRFPE_lADOABII586YIJemzwAAAAPNVWYd",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16329827869",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "741f17e51ddac002fadbc735e2ca650117594a3c",
      "commit_url": "https://api.github.com/repos/vasild/bitcoin/commits/741f17e51ddac002fadbc735e2ca650117594a3c",
      "created_at": "2025-02-17T08:52:04Z"
    },
    {
      "event": "commented",
      "id": 2662441920,
      "node_id": "IC_kwDOABII586esaPA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2662441920",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-02-17T08:52:43Z",
      "updated_at": "2025-02-17T08:52:43Z",
      "author_association": "CONTRIBUTOR",
      "body": "`e1671ff42c...741f17e51d`: rebase and remove the first commit which was merged via https://github.com/bitcoin/bitcoin/pull/31854, thanks!",
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#issuecomment-2662441920",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30988"
    },
    {
      "event": "reviewed",
      "id": 2621788527,
      "node_id": "PRR_kwDOABII586cRVFv",
      "url": null,
      "actor": null,
      "commit_id": "741f17e51ddac002fadbc735e2ca650117594a3c",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Concept ACK",
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#pullrequestreview-2621788527",
      "submitted_at": "2025-02-17T18:44:34Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
    },
    {
      "event": "reviewed",
      "id": 2654878363,
      "node_id": "PRR_kwDOABII586ePjqb",
      "url": null,
      "actor": null,
      "commit_id": "741f17e51ddac002fadbc735e2ca650117594a3c",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#pullrequestreview-2654878363",
      "submitted_at": "2025-03-03T18:10:41Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
    },
    {
      "event": "commented",
      "id": 2702063374,
      "node_id": "IC_kwDOABII586hDjcO",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2702063374",
      "actor": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-05T20:59:09Z",
      "updated_at": "2025-03-05T20:59:09Z",
      "author_association": "MEMBER",
      "body": "Sorry for waiting to late to chime in on this, but I'm afraid I'm a concept NACK. We discussed this at length at CoreDev, and I'll briefly try to sum up my thoughts:\r\n\r\n- I believe this is the wrong abstraction level. SockMan is essentially mimicking the behavior of a generic io multiplexing framework (libevent, libuv, etc.), but without the feature-set of those libs.\r\n- The internals and api are heavily biased on Core's p2p layer, and aren't well-suited for abstracting. In particular, its event-loop model, send/recv model, and thread model are all particular to Core, and far from state-of-the-art anyway.\r\n- It's not well-suited for the 2 use-cases (that I'm aware of) which use it: an http server and sv2 server. Both would benefit from different from custom socket handling and would actually be _more_ straightforward to implement that way as opposed to building on top of SockMan imo.\r\n- Both of the implementations mentioned above ended up with very non-optimal performance because of the optimistic send, another implementation detail here. This could of course be fixed or worked around, but is an example of the type of problems I would expect to see.\r\n\r\nI've discussed this with both @Sjors and @pinheadmz and have agreed to attempt custom implementations for their use-cases to replace their uses of SockMan. As such, I'd rather not see is abstraction go in.\r\n\r\nAgain, apologies for the delay in commenting :(",
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#issuecomment-2702063374",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30988"
    },
    {
      "event": "mentioned",
      "id": 16606514351,
      "node_id": "MEE_lADOABII586YIJemzwAAAAPd00yv",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16606514351",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-05T20:59:10Z"
    },
    {
      "event": "subscribed",
      "id": 16606514376,
      "node_id": "SE_lADOABII586YIJemzwAAAAPd00zI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16606514376",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-05T20:59:10Z"
    },
    {
      "event": "mentioned",
      "id": 16606514407,
      "node_id": "MEE_lADOABII586YIJemzwAAAAPd00zn",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16606514407",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-05T20:59:10Z"
    },
    {
      "event": "subscribed",
      "id": 16606514424,
      "node_id": "SE_lADOABII586YIJemzwAAAAPd00z4",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16606514424",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-05T20:59:10Z"
    },
    {
      "event": "commented",
      "id": 2703769420,
      "node_id": "IC_kwDOABII586hKD9M",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2703769420",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-06T12:54:00Z",
      "updated_at": "2025-03-06T12:54:00Z",
      "author_association": "CONTRIBUTOR",
      "body": "@theuni, thanks for looking into this! I find your feedback constructive.\r\n\r\nIf we would have different parts of the code listen for incoming connections, accept them, read and write data to them, then there is bound to be some code duplication in that around the low level sockets handling. `SockMan` aims to handle that code duplication. It is an in-house minimalistic version of a generic IO library, not a feature rich competitor to them. Something like [PCP](https://github.com/bitcoin/bitcoin/pull/30043). Only the minimal stuff that's needed.\r\n\r\nYes, it is biased on Core's P2P layer, because it is extracted from it. If it does not cover some of the needs of Sv2 or HTTP, I am open to tweaking it in any way possible. At the end it should be the intersection of what's needed for P2P, Sv2 and HTTP. If there is no such intersection, then `SockMan` should not exist, but I think that there is.\r\n\r\n> Both would benefit from different from custom socket handling and would actually be _more_ straightforward to implement that way as opposed to building on top of SockMan imo.\r\n\r\nAlright, I am open to that. I would be interested to review. If it would be better, then I do not insist that `SockMan` is used in Sv2 or HTTP. My idea is to make the life of Sv2 and HTTP easier. Could overhaul `SockMan` in anyway to do that - its current interface is not set in stone. Maybe also worth considering is to have a common library for Sv2 and HTTP and leave P2P (aka `CConnman`) alone, if Sv2 and HTTP have more in common and P2P is odd (i.e. if the intersection of Sv2 and HTTP is big and intersecting that with P2P is small or null).\r\n\r\n",
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#issuecomment-2703769420",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30988"
    },
    {
      "event": "mentioned",
      "id": 16616817875,
      "node_id": "MEE_lADOABII586YIJemzwAAAAPecITT",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16616817875",
      "actor": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-06T12:54:01Z"
    },
    {
      "event": "subscribed",
      "id": 16616817900,
      "node_id": "SE_lADOABII586YIJemzwAAAAPecITs",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16616817900",
      "actor": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-06T12:54:01Z"
    },
    {
      "event": "unsubscribed",
      "id": 16641578165,
      "node_id": "UE_lADOABII586YIJemzwAAAAPf6lS1",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16641578165",
      "actor": {
        "login": "0xB10C",
        "id": 19157360,
        "node_id": "MDQ6VXNlcjE5MTU3MzYw",
        "avatar_url": "https://avatars.githubusercontent.com/u/19157360?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/0xB10C",
        "html_url": "https://github.com/0xB10C",
        "followers_url": "https://api.github.com/users/0xB10C/followers",
        "following_url": "https://api.github.com/users/0xB10C/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/0xB10C/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/0xB10C/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/0xB10C/subscriptions",
        "organizations_url": "https://api.github.com/users/0xB10C/orgs",
        "repos_url": "https://api.github.com/users/0xB10C/repos",
        "events_url": "https://api.github.com/users/0xB10C/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/0xB10C/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-08T08:26:47Z"
    },
    {
      "event": "unsubscribed",
      "id": 16641578238,
      "node_id": "UE_lADOABII586YIJemzwAAAAPf6lT-",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16641578238",
      "actor": {
        "login": "0xB10C",
        "id": 19157360,
        "node_id": "MDQ6VXNlcjE5MTU3MzYw",
        "avatar_url": "https://avatars.githubusercontent.com/u/19157360?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/0xB10C",
        "html_url": "https://github.com/0xB10C",
        "followers_url": "https://api.github.com/users/0xB10C/followers",
        "following_url": "https://api.github.com/users/0xB10C/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/0xB10C/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/0xB10C/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/0xB10C/subscriptions",
        "organizations_url": "https://api.github.com/users/0xB10C/orgs",
        "repos_url": "https://api.github.com/users/0xB10C/repos",
        "events_url": "https://api.github.com/users/0xB10C/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/0xB10C/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-08T08:26:49Z"
    },
    {
      "event": "commented",
      "id": 2720395222,
      "node_id": "IC_kwDOABII586iJe_W",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2720395222",
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-13T08:39:15Z",
      "updated_at": "2025-03-13T08:39:15Z",
      "author_association": "MEMBER",
      "body": ">  it should be the intersection of what's needed for ... Sv2\r\n> Maybe also worth considering is to have a common library for Sv2\r\n\r\nAs far as I'm aware, nothing SV2 related is going into Core (aside from the mining interface), and we aren't planning on refactoring P2P code so it could be copy-pasted out/reused in some other SV2 utility, so, SV2 shouldn't be a motivating usecase here? It looks like #30694 could also be updated to remove any reference to SV2 as motivation (i.e \"Doing Stratum V2\").",
      "user": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#issuecomment-2720395222",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30988"
    },
    {
      "event": "commented",
      "id": 2720735149,
      "node_id": "IC_kwDOABII586iKx-t",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2720735149",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-13T10:23:43Z",
      "updated_at": "2025-03-13T10:24:31Z",
      "author_association": "MEMBER",
      "body": "The current approach of having the Template Provider communicate via IPC, as described in #31098, indeed does not require Bitcoin Core to change its net code.\r\n\r\nMaking easy to copy-paste code could still be a motivation for the author, but it would not be a good reason to include it.\r\n\r\nAdditionally, as @theuni pointed out in https://github.com/bitcoin/bitcoin/pull/30988#issuecomment-2702063374, it may not be the right design / abstraction for a Template Provider either.",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#issuecomment-2720735149",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30988"
    },
    {
      "event": "mentioned",
      "id": 16732003441,
      "node_id": "MEE_lADOABII586YIJemzwAAAAPlThxx",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16732003441",
      "actor": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-13T10:23:49Z"
    },
    {
      "event": "subscribed",
      "id": 16732003463,
      "node_id": "SE_lADOABII586YIJemzwAAAAPlThyH",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16732003463",
      "actor": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-13T10:23:49Z"
    },
    {
      "event": "commented",
      "id": 2722497291,
      "node_id": "IC_kwDOABII586iRgML",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2722497291",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-13T19:36:19Z",
      "updated_at": "2025-03-13T19:36:19Z",
      "author_association": "MEMBER",
      "body": "I just opened https://github.com/bitcoin/bitcoin/pull/32061 which consumes `Sockman` for HTTP. Thanks to @theuni help at coredev I'm now pretty happy with the performance. It obviously doesn't require a p2p refactor -- so we could just review sockman on its own, or in the context of HTTP",
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#issuecomment-2722497291",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30988"
    },
    {
      "event": "mentioned",
      "id": 16748534046,
      "node_id": "MEE_lADOABII586YIJemzwAAAAPmSlke",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16748534046",
      "actor": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-13T19:36:20Z"
    },
    {
      "event": "subscribed",
      "id": 16748534092,
      "node_id": "SE_lADOABII586YIJemzwAAAAPmSllM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16748534092",
      "actor": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-13T19:36:21Z"
    },
    {
      "event": "labeled",
      "id": 16899826371,
      "node_id": "LE_lADOABII586YIJemzwAAAAPvTuLD",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16899826371",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-20T10:18:07Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16911360838,
      "node_id": "HRFPE_lADOABII586YIJemzwAAAAPv_uNG",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16911360838",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "f2f9ff9823fa9ef84ab74af675dad36a390a6b34",
      "commit_url": "https://api.github.com/repos/vasild/bitcoin/commits/f2f9ff9823fa9ef84ab74af675dad36a390a6b34",
      "created_at": "2025-03-20T14:23:22Z"
    },
    {
      "event": "commented",
      "id": 2740633112,
      "node_id": "IC_kwDOABII586jWr4Y",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2740633112",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-20T14:23:56Z",
      "updated_at": "2025-03-20T14:23:56Z",
      "author_association": "CONTRIBUTOR",
      "body": "`741f17e51d...f2f9ff9823`: rebase due to conflicts",
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#issuecomment-2740633112",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30988"
    },
    {
      "event": "unlabeled",
      "id": 16912198828,
      "node_id": "UNLE_lADOABII586YIJemzwAAAAPwC6ys",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16912198828",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-20T14:38:45Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "labeled",
      "id": 16964133599,
      "node_id": "LE_lADOABII586YIJemzwAAAAPzJCLf",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16964133599",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-24T22:39:16Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDMxYTllYzIxOWUxNDU4MWNjMGQ2OWE3YjdlZTc0NmY0ZTAyOWJhNDM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/31a9ec219e14581cc0d69a7b7ee746f4e029ba43",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/31a9ec219e14581cc0d69a7b7ee746f4e029ba43",
      "tree": {
        "sha": "5d262095e0099e572ad67254644ad239ffb5edce",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5d262095e0099e572ad67254644ad239ffb5edce"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 5d262095e0099e572ad67254644ad239ffb5edce\nparent bb92bb36f211b88e4c1aa031a4364795cbd24767\nauthor Vasil Dimov <vd@FreeBSD.org> 1736871862 +0100\ncommitter Vasil Dimov <vd@FreeBSD.org> 1744184912 +0200\n\nnet: separate the listening socket from the permissions\n\nThey were coupled in `struct ListenSocket`, but the socket belongs to\nthe lower level transport protocol, whereas the permissions are specific\nto the higher Bitcoin P2P protocol.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQQzBAABCAAdFiEE5k2NRWFNsHVF2czBVN8G9ktVy78FAmf2JlAACgkQVN8G9ktV\ny78eAh/8D5VQahnjjEBySIxBxcme+5W3ScFPaqY0zPdBLt9sV35By+1Yt2hJvFtf\nhMaSZWRoy6JGA8/V+4kjg7VmPyjJqhzEsZJX24K9Hb6wNnSHBQyL3udEHHvSdx6i\nPVUzzs69TqK7Rp++4RTFt7n67/lVnzEwJk3JljuzJDIzNJ4QT/CnbN64kWWqBjZT\nQTf3T/b8Dn3M5zaTKITW58iEtfhuitf7STvj9eMynQN3ebqlvIxqadlyY6YmQ7mB\nwwRz/K3HUDOKfIQJzyN8DktAM2xDBWtjV9FWPD2XE+0Wft+yEUR4CVzXYYknn59k\nWAMtJvWApPbWHygPovXDT3Uq/yBgihRlTu2ygxUpXHGL+e6nVxIbhcGu7FgwAgw1\nbl0MvrYKJqhDYVgNVei6h+KIajCuBHNzm86gDSKsVbzSYV/NGZsdf/sh7fcuPfjS\nh2xGJocXEHhO+Vbqq7glg2hmUuQGmWfJX7zjv4iu8vY9bt7R/O3CPMcpe/r7wSAs\nMRKfJTVCQ8lD7h7sIj1cI/twBisx+50cb311NF30uIsW0pVFqujMW/tv0CCafCSr\n5+WK8WPaB8Rz3OY7RU3faat2xWzGGlvlv132UOoTDdyUDCncwMGvv8orRbUqqkKt\n8om9RaAhupiMPkPHiuZ9FATX9mdfsFPaH6DjoZaQYZtIUj/craU8TgPk7d9ORHox\nflo8yCe5rdtRojbzuT/juTFsC8FlFrL4mjSEtqAQx+XW3iOU2ut/KHptZrRWT40G\nZfV8fn5fbFLYW++0j0zq021OJJm3ebm9KApJ6cHwKokgCFaw7nKOl2BQKd5UTqr/\nA55X23Dcvzc0U127YOxO6/4KAUY6rPsBTZ1cHA07vp9LW2JKKIuEbjycj/YosJ3L\nd1qxqJhGYueODzUR6EuaaDaWt5y4G8W5NsSsUmB0fnOdlQ2AWw7UUInFC0jeLMYH\nu/IFiyPlpOadej3hF6lhapUGTfJsQlu8v57waJlEEOaneoLpuuUNazk0yaLwBp2X\njdHAwhDNIagKbBqX0Bc20WOulJskQ6b2r/9tsgMjg2qOqqJT6HUAXHHBS6ULJjQi\no9Tt0axkWgNC2vrUhzbVLW8kOcvfDcQ+bItALJO36Cc88DUO1lJtk5xX1BZ7dEH5\nRC1PrR8eJI7ooDAxPP0jLqLut+8KUZlfcsbW11d2z3f7jemmQRWWe0iqFrUwEWoV\ncJ3kmeQeRcakFD0XUF58d5umlhGH7zJ38Esje10O+pvopTv8O8ML2/Tsujtl8iuo\nRvdghuOZh7ScFcT03bz0eOhBm7S54MXFqmBSQPndL3Iy/edtfv/pEHqy8ZDO7Nc+\niT1/bepgd7gEJsNDwZsWkz2/AvGW6A==\n=FsFl\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/bb92bb36f211b88e4c1aa031a4364795cbd24767",
          "sha": "bb92bb36f211b88e4c1aa031a4364795cbd24767",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/bb92bb36f211b88e4c1aa031a4364795cbd24767"
        }
      ],
      "message": "net: separate the listening socket from the permissions\n\nThey were coupled in `struct ListenSocket`, but the socket belongs to\nthe lower level transport protocol, whereas the permissions are specific\nto the higher Bitcoin P2P protocol.",
      "committer": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2025-04-09T07:48:32Z"
      },
      "author": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2025-01-14T16:24:22Z"
      },
      "sha": "31a9ec219e14581cc0d69a7b7ee746f4e029ba43"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDg2ZjA1NjBkNTE2ODY4YjdlOGIyZjkyMjBhMDBkMWJmZjE1ZjZhNzc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/86f0560d516868b7e8b2f9220a00d1bff15f6a77",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/86f0560d516868b7e8b2f9220a00d1bff15f6a77",
      "tree": {
        "sha": "968c9c5fb048c1d9039bd276a208bd2dc7645b38",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/968c9c5fb048c1d9039bd276a208bd2dc7645b38"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 968c9c5fb048c1d9039bd276a208bd2dc7645b38\nparent 31a9ec219e14581cc0d69a7b7ee746f4e029ba43\nauthor Vasil Dimov <vd@FreeBSD.org> 1738071384 +0100\ncommitter Vasil Dimov <vd@FreeBSD.org> 1744184915 +0200\n\nnet: drop CConnman::ListenSocket\n\nNow that `CConnman::ListenSocket` is a `struct` that contains only one\nmember variable of type `std::shared_ptr<Sock>`, drop `ListenSocket` and\nuse `shared_ptr` directly.\n\nReplace the vector of `ListenSocket` with a vector of `shared_ptr`.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQQzBAABCAAdFiEE5k2NRWFNsHVF2czBVN8G9ktVy78FAmf2JlQACgkQVN8G9ktV\ny7955CAAjCus36CqoU2OgiaSN/FjYrXPO3UlzANMKR6/Oh9+1/2g/tdhtnvXeHtS\neDCi6A2XAOswSQUMEn9Ndq35m+EQaZP6WMet7CEXBmd480ATUYUpnj7CttF8lmlG\nyzZELk/eIJntvEL+/nrzWLrGbt/e4E8n73Ja37wbsDeyiMZjYUd67OiIhy8EgPFA\nD/WykN6x8iURRX+DJZjY9s4ttd9T2YiOowVpQ/2Z+PP2DQkBqSagwCuqV7cPi3Sw\nj8gS7tDoaGQvqcxa8gpQkQN9s0ntpDCn1Inw9suDBJ6vDR6Wwqg2qrIKRmjKmWnF\ncQXhYAFJiDJ1iBSjXMXzZ19sUB7jW2+qejVdoXGC1I8+OXxpR/qrXOr1FiyYHa6n\nqZ2giwSjTvZNsYESOaZu3b1K5Bj780YmsovEfYvLBwS2ISkofNzXPyfr5B1IeAZr\n9ahCA2B0YkJD38lop74AHMYYTqJgdADVoASODRTHYOrxWLhbYXMXorLInxWYrxG4\n8EYGls+bVTOarl0dO59siFrE4RovDlSTO4PBlVTqRbvCoThrbYvmh7OFjRjeYMsY\ny+wbXc946t/CKcCW9r4koYdPTAkj+fvOX0mpVPUk0H1CQG5+jBkUa078eNIh/oHw\nQu3ChsakuHe7tTra3ERPuYcZxJc/5HvXJqkVq96XZGC9d53hUVC1ENonT8h/EVem\nANOA7ThZpv+nljDhQ5Dy0B9G/dYKUh0jwvEWPS+hkztzQvVHnAUz72M0seQLdrJh\nC7GJN+T61uef0aBh7XIfmgWkn3bDX4exShZImAeOSbahEOKXI9sHfbQTLuEB9kWe\nGxfjPo1BI6uB1Xxk1h7MDAhoC82HCiPOUdAV8KJl5ir/fjJQcvvo1k6fHthy9KqR\ntVMl/QsdS4c//FkzEHw5OfBvqsEKp1g9rshAp2GxEyDGskaD8FTqoBjVgfxD+euI\nHdBarB5nzZvnnndnjaULRAST3AuVvWDxeyzCaoL5RrR6VW5sQfhFiEOLcq1NQFW5\nFSQmii7TVTAC4lRz92YB+GufhrcoDm3J7a1u7IumpHKl9AhUpNV5ZLFoDYcRpJp9\nKRuFP628tNuYCeylVAMl0uIaJDRTw2s8Ur53MVTr5HOxVwM7koRG/uaFwjB79JYz\nhPaBLfp8Ak4qU/HAUz1bvJGsSQ+q7JJzzCDTO/k/Tg94xq1mwYvHJ+red1cWgrd4\nehsLj7ojLh+/7esgYAmd3iIoCjF7Oj84bb98qol41JkMxc03tvMmENCKhHxIsAUC\nqEVU4to/eEpCp+z+SUdUZ+67M614c2yCWxI92vtlveNBXTKuYGvaemXOhKQKG/qN\ncs6/s3U55smOl2tWWOwjzPY1vdl+hw==\n=orHd\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/31a9ec219e14581cc0d69a7b7ee746f4e029ba43",
          "sha": "31a9ec219e14581cc0d69a7b7ee746f4e029ba43",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/31a9ec219e14581cc0d69a7b7ee746f4e029ba43"
        }
      ],
      "message": "net: drop CConnman::ListenSocket\n\nNow that `CConnman::ListenSocket` is a `struct` that contains only one\nmember variable of type `std::shared_ptr<Sock>`, drop `ListenSocket` and\nuse `shared_ptr` directly.\n\nReplace the vector of `ListenSocket` with a vector of `shared_ptr`.",
      "committer": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2025-04-09T07:48:35Z"
      },
      "author": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2025-01-28T13:36:24Z"
      },
      "sha": "86f0560d516868b7e8b2f9220a00d1bff15f6a77"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGI3YjI5NzNjZjFiZjY2ZTg2MDdlNjgzYzEzNTI3ZTQ4OWRhNjdhNjU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b7b2973cf1bf66e8607e683c13527e489da67a65",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/b7b2973cf1bf66e8607e683c13527e489da67a65",
      "tree": {
        "sha": "de2f4d67c8d465747c3a4e2f6fa3c6414a2bfe79",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/de2f4d67c8d465747c3a4e2f6fa3c6414a2bfe79"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree de2f4d67c8d465747c3a4e2f6fa3c6414a2bfe79\nparent 86f0560d516868b7e8b2f9220a00d1bff15f6a77\nauthor Vasil Dimov <vd@FreeBSD.org> 1724420200 +0200\ncommitter Vasil Dimov <vd@FreeBSD.org> 1744184916 +0200\n\nnet: split CConnman::BindListenPort() off CConnman\n\nIntroduce a new low-level socket managing class `SockMan`\nand move the `CConnman::BindListenPort()` method to it.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQQzBAABCAAdFiEE5k2NRWFNsHVF2czBVN8G9ktVy78FAmf2JlQACgkQVN8G9ktV\ny7+pkh//WahXynofMkGV/zdrxE39udW0tzoQIUDXp65Uh0fuo0MW5DFt0QgirntO\nz4CXbma/3UTFPWHfbCiBVd2x9fJH0LIl8RdyiSSAxHD0qhNJgqYalpTXxq4dmICC\nmK+aBFNsBDbvCknMLgPkCUkMlrBVBKJcyRyVKYfzOV2bjD72SRynezgCCWlKFjla\nlkCmN/+Auw7qT/uV+n2D/YWZpXXvak95vXY0OOhhAFF4dFwLctzTmw6FU7DHHF/3\n/9Wt/ERePd1+vGS4wPJJhR9bylaHekoTDENImaci6GwtAO2mCk6Pql2ZoQezKN4/\nxbcRp1GV2VINlk+IgV/Ogk57p1xBX2PXKZaRY+YTEs/ykOSuSedvECwZLA/FETAx\nF16QmEv1akphm+JemX98OJZgQPkIT5I3ri9ysgxWIVfGs7l3abJgNK7ygL0kjiFL\n6LBdnA7EyaD2JUIJ+luPHoTGDGmcU7Cmt25yRwovJ1WDpL2z3a9OsT590+5tYyON\nvcOPT+TsjytEx5DAW3SkfW0axrUpT4tjBTr6GacPNSVArRYqYJEBY8+Ryf+kUfES\nhyUpZbVoDLlcNQgqJtzsHPRdMBFoESENuDba5jN8iq2eLZXe0DqEIGdF5YcsutBQ\nOg6//hGsX9LCtCDU9WS487DvM6IQ/V9jxWAfZjxcQLL7iOs/jTM6rX7zF20sqNkE\nLgww+dZyRHAn55hm6pvSwyd7A2xmTqyz250hOtIDt5WMtHxfcS5q580MuOUnJ7S1\n5k/TjN8J8RwkIYhX1s3xnC2ukTd3bLM/GP2izeU3LGgTg9VhVCfZaDvE7pfqoBvs\nzf8A0m+RWzujUnENqotm41jopmSh3ah8rNGSt5MJRcNW/mfnEniPzt9DvTVkyGNN\nxWt22v7jj2V7TJ4bc6WbvYHmCTCT2BIAdEbGwHGfJPa65kQ1heModQLaC4gPf18H\nNkT0FqmtqKuy/iATlVd8tLnVCBebpDtwsiENBi7wToBob0CFBlWJCNUgLH88t9M3\nF8Cq1aMRyeeTv3joo7ILuA4q4Pw6h+myBoFf2IO87R2ewFRnOcDQWesKpHwYdSbD\nnE+1uJmXKgdmwJjPoXzaZcbN89aS1CkhjmlPBHEm8En6gKMhhJr6QpQkqYuxFFMs\nSm9gPKVDawaq/iRt3tg1ZaMYctnvzwGC9GCB8Rxf/22yCBh4PBJZ5zb5vYivSxX2\nePbcST5jhCRESAChWrUa/YY16umsIQ7nm9fziCZam9A7VNNOPpojNLz2AISAdT/X\nmRPfvU1UjtAK20rMoWJSUzLj46GmOmwfiFS8/WfoMu66sm06WKeztuHilHQru2AG\nhQmNWA23phRGmscCUitt8w32hipR7Q==\n=IfJC\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/86f0560d516868b7e8b2f9220a00d1bff15f6a77",
          "sha": "86f0560d516868b7e8b2f9220a00d1bff15f6a77",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/86f0560d516868b7e8b2f9220a00d1bff15f6a77"
        }
      ],
      "message": "net: split CConnman::BindListenPort() off CConnman\n\nIntroduce a new low-level socket managing class `SockMan`\nand move the `CConnman::BindListenPort()` method to it.",
      "committer": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2025-04-09T07:48:36Z"
      },
      "author": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2024-08-23T13:36:40Z"
      },
      "sha": "b7b2973cf1bf66e8607e683c13527e489da67a65"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDUwMDJhMGZkOWI0ZTRmMjNlNzE4OGEwNjRiMDE5ZjNmMTU5NDM4NDQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5002a0fd9b4e4f23e7188a064b019f3f15943844",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/5002a0fd9b4e4f23e7188a064b019f3f15943844",
      "tree": {
        "sha": "2d7f38aca140bbd2434c548b6a5c9acd6027857b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2d7f38aca140bbd2434c548b6a5c9acd6027857b"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 2d7f38aca140bbd2434c548b6a5c9acd6027857b\nparent b7b2973cf1bf66e8607e683c13527e489da67a65\nauthor Vasil Dimov <vd@FreeBSD.org> 1726578346 +0200\ncommitter Vasil Dimov <vd@FreeBSD.org> 1744184917 +0200\n\nstyle: modernize the style of SockMan::BindListenPort()\n\nIt was copied verbatim from `CConnman::BindListenPort()` in the previous\ncommit. Modernize its variables and style and log the error messages\nfrom the caller. Also categorize the informative messages to the \"net\"\ncategory because they are quite specific to the networking layer.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQQzBAABCAAdFiEE5k2NRWFNsHVF2czBVN8G9ktVy78FAmf2JlUACgkQVN8G9ktV\ny7+jxR//eP7dIJLHkBbC9iN4Fo+tCnuB+Yfd0N9gy2ioq29gr+IUghdjsYSDl7k6\nEIhQuciYydCN3lT9whi8u/Ffs0FBya+/on6lGUAtZ1wp/8VOLRcFEYkTM/d3IlWE\nx/cQDb4GeLmKjpd+RTu59v+BcXUQ9UFsWopmPAv0CJtDUF794q6V7LbJvrpKkq0U\nJnhfO9EnKpB5wpAUZSd2c1MCxbglAln07HDi4M0BD5g7YrtpJr5zY8ScNoawoR58\nbMJhH6bF+Q1yKWKKH3VtolVQeO6w5Z4rooO+zCh6MycNpumlTRDDv/cXh/L7p877\nuiY1fw5+kpUhE4jaz08oJ5wfkzsMEhz5BNeX4ZJxGEoHGwO+QOKo6qgBm6Dwj3Eh\nrEYtqsc3Gb5jJdjETGSarI8UGXETexTJXh/IQ0fKfJGkS25876wu2z91KikL6MlL\nYqLoYKBEV1DzYbbPVzUmR3Iv2HyGmr2JsxKE937MAUwD97rzga9dQK28Urm0arrU\nsJkANELQutGxTeGf4YGXvncuieSEcilZSf+3tr59I46cGd4vNWu6Qi4hln69ZoUg\naHH6l328JtcxrspZYdrIDPkeEiIoRutsEK13S7/+X7jDx5cLnz0Q51lOpsVaO2Qk\n2JVXAdKjJ5bY9MbdqLeGcrwNN0/8SkNYF/V2fPNiMKjVF2mPVMPvynUGuM8bMz/I\nHrzTJIAEovCVqg0abTrFSkbeb33ceG1xWb4Av0vwJkxZluBmmqfUS2hibq5qpvM/\n7PmT/E99T53JcHWUs1NNRdkeQd5kbCM2WKhpu8U7rqZAHaG4KgH6k/dgUH8bLPz9\nmKNtLLMTlVIcsZUZp6BshC/iX8fv+kYc3Jj3kkhAq8h4fJXh9TkBv6rFMshXUdVF\nbf+VUk55cpHhGzHmOrRiQtT9V4qnf03wOPkAw8d531VgGtHzbxFRmjBjrBHgf8Cl\np53bckqaAJ5iiIYWnooTFYbllGpdoWo6rkskLDDhl6l4uZQq8LOFtBDpyGXUjHLO\nO7BevlYrcNGR8OS70PpNgPyTiMpPbaLe5UVYf8gb1vtyUmugM0znFZJjubbuwIEm\n6zDb4D7I6BvoJ4JJ+3ODCuDbPOffn0k2/SbXst9KJ93VhEWDsaNMo6X2973uWpnS\n+XoE+GqEkLo8/FEIgci3FgJtnmRfac5AopftndeRE12yojp+DCavL71amCqi7Ero\nhTyLKCf73AcouftS55qjwQij4A3ZcYSffe4E0KdO0pZG79B3oozXID+A6Aih3k3q\nRuYGR5Rn0NLxPkMRWI+NfwRxQQzOul/W0UC+dpKgr9l+TI4XlDOoSW3QxTJCZVI8\npLaxCoopP3QdoTga8ldUlGEGQSpenQ==\n=JhG4\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b7b2973cf1bf66e8607e683c13527e489da67a65",
          "sha": "b7b2973cf1bf66e8607e683c13527e489da67a65",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/b7b2973cf1bf66e8607e683c13527e489da67a65"
        }
      ],
      "message": "style: modernize the style of SockMan::BindListenPort()\n\nIt was copied verbatim from `CConnman::BindListenPort()` in the previous\ncommit. Modernize its variables and style and log the error messages\nfrom the caller. Also categorize the informative messages to the \"net\"\ncategory because they are quite specific to the networking layer.",
      "committer": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2025-04-09T07:48:37Z"
      },
      "author": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2024-09-17T13:05:46Z"
      },
      "sha": "5002a0fd9b4e4f23e7188a064b019f3f15943844"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDlmOTI3OTkwNjEzYmM5OTJjMjMyODkxODAxZmE5Y2M3N2VlN2IzZjA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9f927990613bc992c232891801fa9cc77ee7b3f0",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/9f927990613bc992c232891801fa9cc77ee7b3f0",
      "tree": {
        "sha": "205da3dd742c88dd73296e1f20a11efeb6134fff",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/205da3dd742c88dd73296e1f20a11efeb6134fff"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 205da3dd742c88dd73296e1f20a11efeb6134fff\nparent 5002a0fd9b4e4f23e7188a064b019f3f15943844\nauthor Vasil Dimov <vd@FreeBSD.org> 1724670893 +0200\ncommitter Vasil Dimov <vd@FreeBSD.org> 1744184917 +0200\n\nnet: split CConnman::AcceptConnection() off CConnman\n\nMove the `CConnman::AcceptConnection()` method to `SockMan` and split\nparts of it:\n* the flip-to-CJDNS part: to just after the `AcceptConnection()` call\n* the permissions part: at the start of `CreateNodeFromAcceptedSocket()`\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQQzBAABCAAdFiEE5k2NRWFNsHVF2czBVN8G9ktVy78FAmf2JlYACgkQVN8G9ktV\ny78nHSAAn3HIcUzTHgZpAL8QANWwdQ/SxztF5L74Hdzyp2yJDTJHpr+N7EP6mrxe\nE/P+//b5choBkY4X8m7x3TWxamry9WIbDnoGZJSviUtTP5Te8/xO8gpB5xK0fmNu\n3M1uuAGoMnOqaKAEheQ8zPDzR4h2bNpigqejWs+DKxkMSX73lxxrga3nLpm5CxAo\nFsCxush8cpblu6sh4osoWyhuuPVLJXpc84BkvI3yYAwPd/5VPc+FJqE3+EtMH2jK\nAXhniXjqEyAv1qDrK1cflAxVDgJw7EjHJEF6rtpTfdnflqX1i2ziyeXnhHvBHyUv\nngMj8EKYGiAbgUWhXyKRQT/vhGuS3zNSFpL2fxjTHotzu72tY6fVUb3LiORZTEem\ntopCFSwIoAfnZM6fxeZnHR0wYo3zOuUrPW+5JZ0yLZjl5Tw5sGaANBSWWaIlrj8i\nuRv6rrAOQiIXLUDxVYvP6qV3XC+KLcIz7kD/n5Ne4wnHP/ghcnvbccu40A6lp/KU\nxGbFke38CsEhEkCphH0QJGe61bt9BaC7xPgacb+TwAR8gF1iIREF58nNv7idgNDP\nc7LjE9r5M5pDbgwiD1ff8aLM7ZfVBBO21vTfsuuKVPd6xu6yO1k3cCe96AW2RD59\n4RE3FRHKiN9fqosMunJRqweYVYupwOR0jEK1gxtPUEDHBfvqaqpLk08RczSNVK+w\ndsBloPwlCQn/EjJl3jVdus3sx/cYm8ihDW1mDsRoEFf2+8Gpv/6tgZmqX3LjxbRU\nrkOU0bhX7bNhXzDYwNM6NXUxf8esckL6bC0C9o+NnX0EJIGXhX1pWljjiSzrlPro\nok4RJNql8uownv2TerLoid8hFiFvilqQMgWZET4L0pUSJN2ddXM1uAFahIzO3Yra\nJ9Fi2cC6ISd0JMbcd/DHCjM4vKWCkdvkcJNBdi0Zvs3k2gNr1bcxkOvS9k38GDhu\n4l7PVZmuL3joxFsgjkZYHmAujfUIqCOhMOoXNU9w/jIUx67T0dJJqe4Y+gouENeW\nvMdi6j5VgKapRZBphewSpRo44c8c1U0cIIY5gKem+YS7dN4kBdGLfdHJOcmVA9q6\n+74JcyaFC0j9nG5p/Lsfs0MRLQGPz32ej+gVHw6qn6OjAM4zBaZT6LIDRvS7+YOt\nkd2ICUOPFPoRxoNfrHeVxJhdNZbOLPLGPuHTKkaL6TsDJ+lOGrx28LOjfDNwc+Rr\nRhXOF25XKBgt/lt9Uj4TQh2Nu6UWrCCrWmMOUeizAOqDj5tt1/N3KF8xymUudmwG\nyGQejuqHdAWweMQ91kqwUn9wN8EzwImNjl1r9chmVh7pfZhCDaMND9eGETa3enxO\nlGmiwZdhiU/NFla2egJcDh7Nmg/ZKQ==\n=HfdM\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5002a0fd9b4e4f23e7188a064b019f3f15943844",
          "sha": "5002a0fd9b4e4f23e7188a064b019f3f15943844",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/5002a0fd9b4e4f23e7188a064b019f3f15943844"
        }
      ],
      "message": "net: split CConnman::AcceptConnection() off CConnman\n\nMove the `CConnman::AcceptConnection()` method to `SockMan` and split\nparts of it:\n* the flip-to-CJDNS part: to just after the `AcceptConnection()` call\n* the permissions part: at the start of `CreateNodeFromAcceptedSocket()`",
      "committer": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2025-04-09T07:48:37Z"
      },
      "author": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2024-08-26T11:14:53Z"
      },
      "sha": "9f927990613bc992c232891801fa9cc77ee7b3f0"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGVlMjZjYzc4MjVhM2Y1ZDNhYWU4OGU3MGEzN2FiYjc5NGM2ZjUyYTE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ee26cc7825a3f5d3aae88e70a37abb794c6f52a1",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/ee26cc7825a3f5d3aae88e70a37abb794c6f52a1",
      "tree": {
        "sha": "ad48ffc214ce1025b1f828c6c0a5855ac5e1ea1f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ad48ffc214ce1025b1f828c6c0a5855ac5e1ea1f"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree ad48ffc214ce1025b1f828c6c0a5855ac5e1ea1f\nparent 9f927990613bc992c232891801fa9cc77ee7b3f0\nauthor Vasil Dimov <vd@FreeBSD.org> 1726586947 +0200\ncommitter Vasil Dimov <vd@FreeBSD.org> 1744184918 +0200\n\nstyle: modernize the style of SockMan::AcceptConnection()\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQQzBAABCAAdFiEE5k2NRWFNsHVF2czBVN8G9ktVy78FAmf2JlYACgkQVN8G9ktV\ny7/4TyAAphisQdm3TORWSMWGYr7nAxl/Q0FOrLRUceW5uuzgFh9M1snw/+OyMs2v\nFjMJCq4XmE7r/UkdpuOsIsCynKfvAFQb5astP4yCvvpT7oG0NwEMretTQgzFihcR\nlmhAEBsoXSe8CoLo1lYbzYvNoZeq2EQwPlNnXH932aCJERw+iHH5jW8Q0whecANA\n1498OkbLDKs/NrvWhYVeVQj2ZEQ3C7rrARtIt+IlT4tJOYBPidLJBaCVzVSBP8Ef\nv4ah/MyRq1a2PgLlIZXFuUhs8qi6sg4F4IV8qnbW9mo/EOqm+lx2kOzwcl22DFUl\nDVVVoaiy1nDeHRaH6AFOzqbbLUDVfRNBhl2cEllBz8Rj0yHLy4TiITizVf/D/iqJ\nKGiCnWVP6W/aw0mW71eyQWz9fbsr+SZeP8C5a/EJW2DhfNfAOPEq6fsZbSXuYDr2\noWsjmf3UOu7B/iNZw7xeHSGupBSuqPjQfzqMNZa/OKh/dNeASIm4TRJ46VZo5ebV\nReMAmc3T7D2Vk3iQvOBBUlGmbfm/n/4BdNhS80XJeeU0lVPvME/wEqs9n3Pi22ml\nK1JAflpm1jaZIdsKPHLwiWBvsA3MQWlKZNhIPDEmtMCZS6rYyAeT8aUud62x3hSd\nhZ7D3ljaDZZjwPnP2wARgan5OUxAxmP2FlMv0jAungdCQeK6vJEnflCI+p3B3Sli\nV/FNujkdab2XSfxb5XqfCvNPhYutyMogi1W/m3WomDaIrflqVsunL1AvO1W0Wr+a\nA6RMYr1vLi6qnskO/Nctdn7qcuqI2qDg72dBqzHDfWEuvcP/jafxuHZd9QYMi439\nJkYIEpmncyqR/tAuQPn+NWCcxZmRBl6j9sQUru3g/bCcE1/6pIr2boFqR9Dup250\n9OGk7Gtmqzz3NB99drk+ALFXVdSuN9pkaJCQ3XIiGwnNl+JsPsDNvtJ79Y8ILjcE\nd0JInFuGzSnBKan5qVu4aKbMEiL+XxQKYwh71q5+AnOyMQVWqMQtMcCbxMD4vi6J\nmELKnL+WckBP471iHZvULfoUXM1ruyKIlWWatEuCkSyBI681EFxe+uArJ5mJnUsL\nSGFBGjSkK2V6ItU+ZNPsEvIBAjauqb5bQ0MBvKIVGSOJHuC5o/N7qUcgUzlvDHFH\nv4i4he5gBSQU2p22t/Gy1PKr9rM8zZpktnMtPw3i00T565E2HGXIxe5WH/U52lCy\n+hkUzWpFY34eOHVb0V2Ss1rLg+IAtykwyxu5ByOoQYu9E7dTpAQHNH+2IeZ3ocvl\n8lagHC5W+dxpGXouwy1dBEFk5GDyB1VUjeHTd5ZLwnxWZgyJUBMe36BpIVPi+CWC\ns9Dk/E3Np3jaVYnsCu8hajQldcXv6A==\n=uVeC\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9f927990613bc992c232891801fa9cc77ee7b3f0",
          "sha": "9f927990613bc992c232891801fa9cc77ee7b3f0",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/9f927990613bc992c232891801fa9cc77ee7b3f0"
        }
      ],
      "message": "style: modernize the style of SockMan::AcceptConnection()",
      "committer": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2025-04-09T07:48:38Z"
      },
      "author": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2024-09-17T15:29:07Z"
      },
      "sha": "ee26cc7825a3f5d3aae88e70a37abb794c6f52a1"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDhlOGM1N2RjMmEzNjgyOGNiNDM4Yzk0ZGQwNmFmNThhMjhkMmEwOTU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8e8c57dc2a36828cb438c94dd06af58a28d2a095",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/8e8c57dc2a36828cb438c94dd06af58a28d2a095",
      "tree": {
        "sha": "a2a7c7d1b40452328d4d07ce716fa14a17ec8cf2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a2a7c7d1b40452328d4d07ce716fa14a17ec8cf2"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree a2a7c7d1b40452328d4d07ce716fa14a17ec8cf2\nparent ee26cc7825a3f5d3aae88e70a37abb794c6f52a1\nauthor Vasil Dimov <vd@FreeBSD.org> 1724750724 +0200\ncommitter Vasil Dimov <vd@FreeBSD.org> 1744184918 +0200\n\nnet: move the generation of ids for new nodes from CConnman to SockMan\n\nMove `CConnman::GetNewNodeId()` to `SockMan::GetNewId()`. Avoid using\nthe word \"node\" because that is too specific for `CConnman`.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQQzBAABCAAdFiEE5k2NRWFNsHVF2czBVN8G9ktVy78FAmf2JlcACgkQVN8G9ktV\ny79uQR//dM2/LvYGumbOT+KnawJPUUpeMMDwJX7uYRJt8Uc5XQFNTi50brdtnjS8\nYCOjw0Hz1jLKnzc+QDR2tXX3E/7B+R5cKzNrfUtQMgB5LWUU1TI4qWKaMf4vJddh\nTPbPuqD8tbl2i3U4K3g6hsIFvZI7q5O2r50uE22i1KGTx4sdsfPBIJs0JZSbyIpr\nWNqLAypMaeU2xBvRlEy9zFWk4nQU6WKuG6nXZeSYr+a9wYN0BnN3SHDyCWMzSNUI\n+dJRadtEp5Lmxvw5x8uPFznrQx4oSpO9v97GsuJJ1pP5PgxSA2Wx882L/ybNTVMn\nDeWH/mNdvZUD9nC+dhX3G17XdwiNLATu0Nv2ikO0B5duU57QEgl9Oxp6HcJrpUq8\nIbhbxRKZ3nhAGp7jVogcI0jImjzRaFK1s0GZllwvp/Rgh0pKYHGUtaN/Px3HTG4i\nQFr3Di9VDGhFELCrCAn25pVYfd7NN1nT1eDXHigwP3eakzmIkBs+76v2oke0GPf4\nJ7CYFFinerp2qAmTG4N+97xwJYf+NkH0dRAbUDNwaSg8EwUCkCJOdc+EOoV31i4e\n1J4o2goYUIh21u6Gk3dE/12nVkpLWqqkmVbjUwF7ix6n9nfiOeKUy67+roWPYf6e\n6msqEffjiVQyFG5MQgdwW2UAlZYwf5z11T4Ohhiv9D2KvXqu0025SiLHZ5jOHR8u\nujhpXRZcDI0GHrLbAW7kCGGgaHsl+Z3V3sIZ+jSnvdoVwTlYAdlSNz199ItG5k/O\ngEjq56arluWcCRrm94ym9Z3esGKJJIIDGtg6x2/f9P7a0blRAQ848zQZa2TWr9Ne\nmPh1gLuPN5qNNyYPK/tp0curXMtWj55tfUnk4rG0x+ViTsK7FRyLGl67F0wqW6VO\naoyxYiyflKgATA4OE3bgyw97bN7JdhX1fpdvvHUjCZTImtJLgsxt9KGYW1CpXKzu\nAk/fFbPmxaEch9fdePSz0TlQISqCeo2mdLwGsA6mOzpJfOXsTBtlHwkdILWO+ZIF\nvVEKEkfnepMPBBbAGPk1rHPszXGaVPcaHuW2HUKO/8JTr8oCDQ1L56ltYNVgC92+\n1kKsAw94nF8BkQOVlTIGLSlgqiuiaan/pIh3npx0KVppB+QIsIPha/0Qk+rTB66h\nlHdWwydwlKwcKvnbPzXlLXp7sL4+QHi5Wb4Br14isu3lPgSsCMqz59CyWpvdg9VO\n5a0XF/0BkeVBcxeasQVTYObMmG5a+q7PP3tEyOJKuTK60tMsXJ4LRuOkUki+EZMd\nhyoIbN/tdVlkXKTA08RxZLDjOfiYC5ryIzyqKp/2R0j+ps8nVNDaXY1vcJrMm/bn\nTzKY7PnxERS/y0zJJEbK1ntzt9giuQ==\n=/q9L\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ee26cc7825a3f5d3aae88e70a37abb794c6f52a1",
          "sha": "ee26cc7825a3f5d3aae88e70a37abb794c6f52a1",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/ee26cc7825a3f5d3aae88e70a37abb794c6f52a1"
        }
      ],
      "message": "net: move the generation of ids for new nodes from CConnman to SockMan\n\nMove `CConnman::GetNewNodeId()` to `SockMan::GetNewId()`. Avoid using\nthe word \"node\" because that is too specific for `CConnman`.",
      "committer": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2025-04-09T07:48:38Z"
      },
      "author": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2024-08-27T09:25:24Z"
      },
      "sha": "8e8c57dc2a36828cb438c94dd06af58a28d2a095"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDQzMDA1MzA5MTg2ZTBhNGJiYTdjYTE2OTUyM2Y0NjU5YmNjOGI4Zjk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/43005309186e0a4bba7ca169523f4659bcc8b8f9",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/43005309186e0a4bba7ca169523f4659bcc8b8f9",
      "tree": {
        "sha": "dc1c72aba0477c6e116188e1ec89fb13128929e7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/dc1c72aba0477c6e116188e1ec89fb13128929e7"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree dc1c72aba0477c6e116188e1ec89fb13128929e7\nparent 8e8c57dc2a36828cb438c94dd06af58a28d2a095\nauthor Vasil Dimov <vd@FreeBSD.org> 1724767895 +0200\ncommitter Vasil Dimov <vd@FreeBSD.org> 1744184919 +0200\n\nnet: move CConnman-specific parts away from ThreadI2PAcceptIncoming()\n\nCConnman-specific or in other words, Bitcoin P2P specific. Now\nthe `ThreadI2PAcceptIncoming()` method is protocol agnostic and\ncan be moved to `SockMan`.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQQzBAABCAAdFiEE5k2NRWFNsHVF2czBVN8G9ktVy78FAmf2JlcACgkQVN8G9ktV\ny79Agh/8Dy5/DWwyRN7wCKLsthpMcmi0VZZ0ZrVr7LfgA1eyW1d4h7Fo5kvU9t5D\nDySA6aSZ1wg/GKaEnKp+p7kgHJKoI7QK+TrpLgznWFeMe1/sGgoy7o70OaN7OECo\nWDC+dnVHBOwAMldiCJkBi3GK9J7tDP1+ASubu4CWUi3z8wy25LJelch1Er3ndNNp\nyX4FvRjMBa7Uu/4wq8PqYWuR3tOSo04bfwAkiWc44fSRfz+VPIAma0Rth8bxfYSD\nGX9t9VM3/I33PBBXLHU5XFnd9hwYqVHqTeQJuozbUwcNcEDYjwwyt607Dfiyi1+r\n57eDlZikqK+6YNvDS+JQsh2+9ClTk9L8T4KjGfNa5ocBl7T0J7Ct8J9gYHj7fnir\nvlSRofNEeoCIxzOtzVA2YC271BhoGdHR8XOdXvU2jMUfhghuzecR1LGTp5vNzUCS\nMo8DFjMXVa7Wnetr+4/Lkl1cv05Ja8Hoz1xv5w0jbaL3prm1Tcdk5KU3VQM5NSaJ\nbsKOuGugkVsDN5QhVAx7Fc++gPNyQ2VslRTt7v9oOzJutG7Lm4nZJMGTUxnObx7p\n9L8dIZv/GwcgD8Tm+iCwDOyDeqeI7TlvojM6xN/oF7nok6FTB7NLcycCvZ41Un1n\nmfqYbPAaWOEM5i++yjto9L7bA/Br7aj8OtiR3wErp0Zmrh1R7XEyu+EUJuYXm2rj\nhDh6pF5WU/9m3y041TtiHIaoPgLCr8R0kj48GHRk7G0xDrWfDPyrCyrEXkkf31yO\nsDbrOuca8AmRQQuSzma7IUeVyI86TBBz40eLC8XNqPdRt/uf2HBCtFkLPUNIilG/\nQTVoUdgSDX0/OWH4FsuSzpOzd16R2ZFo00Sif+cWMNWyOs90UEgkJKKofei0i3TX\nQmFHngN+4pLI8LCfNsjd8rnWZnCkrfbBbnGi3eVUVxF+Fh1utummaVuc1D7wA7SF\ngwILbYfZL2Fa+0FyoHwSiv2xtKX5h2TMBps80rN4Fk9KVaHkqzTmTAhhv+psgT6S\np+d+csaHciMeic1fviaVowvkRiYlPVrmY7MLX0tdkK/Q0P+ZcvHxZNnEoMWy2jVA\njnUq7Vma0PUPNwApmRjM0kDakTReiSUhb1EQ2JQiU8xHnDsEzlDYwgTdcjgTekQ9\nek0o+a1DOb+4IjSrKQj7wUr2oVdgw+NjiYh4XqI7yEf4NMVu1pMnPWUmucfUJmHc\nHVKMtpVMMifs27cHNeUyeEpFqfCSMptoBTaLvg25J7S0b6yxtIltL8krxw1FuBPi\nSAw+ip1q24zh1PX++399trfFOsa+W7wACMo11tvaVXmWdBM1MNpg2JOdSzksux29\nPxQz4b+HS+IvcjAcWtsUJS29bQ9lWw==\n=Q7cF\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8e8c57dc2a36828cb438c94dd06af58a28d2a095",
          "sha": "8e8c57dc2a36828cb438c94dd06af58a28d2a095",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/8e8c57dc2a36828cb438c94dd06af58a28d2a095"
        }
      ],
      "message": "net: move CConnman-specific parts away from ThreadI2PAcceptIncoming()\n\nCConnman-specific or in other words, Bitcoin P2P specific. Now\nthe `ThreadI2PAcceptIncoming()` method is protocol agnostic and\ncan be moved to `SockMan`.",
      "committer": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2025-04-09T07:48:39Z"
      },
      "author": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2024-08-27T14:11:35Z"
      },
      "sha": "43005309186e0a4bba7ca169523f4659bcc8b8f9"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDU3MDVlYTAxZDUxY2ZiZDJiOTM2NzVhNWJkMjE1ODEzNTZiNDUwY2Q",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5705ea01d51cfbd2b93675a5bd21581356b450cd",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/5705ea01d51cfbd2b93675a5bd21581356b450cd",
      "tree": {
        "sha": "ea0dfef3d90164f9337006a95d8e0bd3be2ea08c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ea0dfef3d90164f9337006a95d8e0bd3be2ea08c"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree ea0dfef3d90164f9337006a95d8e0bd3be2ea08c\nparent 43005309186e0a4bba7ca169523f4659bcc8b8f9\nauthor Vasil Dimov <vd@FreeBSD.org> 1724768611 +0200\ncommitter Vasil Dimov <vd@FreeBSD.org> 1744184920 +0200\n\nnet: move I2P-accept-incoming code from CConnman to SockMan\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQQzBAABCAAdFiEE5k2NRWFNsHVF2czBVN8G9ktVy78FAmf2JlgACgkQVN8G9ktV\ny7+DNx/9G5vB+Xx8Eir/ajVETWuWi3LOM74DiMPu7l8wtiIO8zlwO8+sNdmY2rTj\nkqTHOLHHUMI6sNoLGk+qVbFS/8K3n8xTN8TiN4Qhb75Zr/W3fKattj4Ojvah4x5j\n06kYehDQ2yYNMHTSOIwy15mMdqTCDRe9i6ClJISwHjP3rir3vKoF6E1OyaN1cMI0\n/BXr0rIS53/lI1fasRa4Hc5B+XPvnEZsCIXl/2nhNpTdL1PkZgCm4QU19oUvQPj+\nbHiyiE7AVSiRFHXqyDEkSl1toFSNZnp8WW+lj7rCddoPvWKesWJqZvWKAj3ujoEe\nF7xgZdvsOfkTW1XrJvHA7NwFg+kqDMM6N5gZe2uXw0+EfO0aho3Wlb5fXLtgpNNW\nv8uFz5floBCXjPUd2MqbJGV5Pcgnjr9rviopV3gfWkZqB9eaxiNGBewCy0VaOKGh\npCtbs30QZJ4gfDPsAXwqC5mMX3a51eaF6q96W2ZiNPIUGTttmPFQq6LPIrZspVx4\nrVPckp0fA1aaYUlmshuU2ny/b6DNi5InT0OqcUkbKOO/C30OVN4viLIyG2QraMj0\nSBj8+7YpOu5/vuauNHvwyk+BX6N0KwIMry7x/3q+aFUKhzt4KUsOwoFEclL2oaGM\n0CnJMQqyoJ2riMaUs7pnNleC6v9hkoXGocHlFYB3YXAz7wAsA/m/1Mwy6KKMv48c\n0gntfodM3quiZzAGPfKGtdb2u/rGQAr8udmp6D7LaBJfqQk9yzerpZKPxj2BDV9V\njnLZ+xOQNTIDW+l7kkiNNuOp0xsk1rYoI9pzDfONCrHa/cKdje5Feg6b8Dt/uSll\nmZKwgTlQUm92eS51Om9gxLcAjb6bG5DB/8Nk7rlNgu60zN7jM/SXCPzmxMTDlHA1\nfNMoGfV0bPko+EoK//eAoJkWuBCV+oIiECB1YtzmhU4dLYPU7R4Opp6Redf56Vj4\n6HJUfz5nx/T59hPTqZzXe7lkAktMkU2QZxUuFLlYw3ePb+w6aB8Xr0S8wTe0AZ3C\n/nf5vClgKgQefUvN0HgFa7/FeBoK2hFJV3Q782pATkDjAKKSQ7h0HwEr1ldj/gSb\nRGgfZMNiqOd8R1lirsMDBVifQIrhhDtiHyIHvLMT9Gq7fb3kHvSZcu7vas9O9PhG\nndMBR47b6ynmXh6kgtFl77W/7JUAIfWWPkux8GQjGy7YUH0B/gY/uVCyYYlvrUOl\nlP/SXk6fms9ooMhATuPMzCRgMPivs8idB/6N1C2byJpDHaOW1ZfdZidG8sYvAkvy\nTwZzRzTXOlTY0R8KeNmsSz1YkIljFyBN4C1tgaKiBNQjN441IQ/QCRd3KbiMa3s0\naIZQYsY4EUnfTFuySa6lbc8Uq9W3bQ==\n=GZxo\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/43005309186e0a4bba7ca169523f4659bcc8b8f9",
          "sha": "43005309186e0a4bba7ca169523f4659bcc8b8f9",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/43005309186e0a4bba7ca169523f4659bcc8b8f9"
        }
      ],
      "message": "net: move I2P-accept-incoming code from CConnman to SockMan",
      "committer": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2025-04-09T07:48:40Z"
      },
      "author": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2024-08-27T14:23:31Z"
      },
      "sha": "5705ea01d51cfbd2b93675a5bd21581356b450cd"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGIxOTg3YmRhMzQ3NWQ3Mjg3OWI2OGQ1MzY1OTYxMTg2NGMxOWEyYjQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b1987bda3475d72879b68d53659611864c19a2b4",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/b1987bda3475d72879b68d53659611864c19a2b4",
      "tree": {
        "sha": "1a82c3e465665eaef333f5da3ffee778c0cf2e36",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1a82c3e465665eaef333f5da3ffee778c0cf2e36"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 1a82c3e465665eaef333f5da3ffee778c0cf2e36\nparent 5705ea01d51cfbd2b93675a5bd21581356b450cd\nauthor Vasil Dimov <vd@FreeBSD.org> 1726831648 +0200\ncommitter Vasil Dimov <vd@FreeBSD.org> 1744185550 +0200\n\nnet: index nodes in CConnman by id\n\nChange `CConnman::m_nodes` from `std::vector<CNode*>` to\n`std::unordered_map<NodeId, CNode*>` because interaction\nbetween `CConnman` and `SockMan` is going to be based on\n`NodeId` and finding a node by its id would better be fast.\n\nChange `PeerManagerImpl::EvictExtraOutboundPeers()` to account for nodes\nno longer always being in order of id. The old code would have failed to\nupdate `next_youngest_peer` correctly if `CConnman::m_nodes` hadn't\nalways had nodes in ascending order of id.\n\nDuring fuzzing make sure that we don't generate duplicate `CNode` ids.\nThe easiest way to do that is to use sequential ids.\n\nAs a nice side effect the existent search-by-id operations in\n`CConnman::AttemptToEvictConnection()`,\n`CConnman::DisconnectNode()` and\n`CConnman::ForNode()` now become `O(1)` (were `O(number of nodes)`),\nas well as the erase in `CConnman::DisconnectNodes()`.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQQzBAABCAAdFiEE5k2NRWFNsHVF2czBVN8G9ktVy78FAmf2KNAACgkQVN8G9ktV\ny79l/SAAlAnU143cSL9iudFdwT56MqhmE5JxyOVCPLuqviBhKXgpL9mwYZ7nEsts\nBjaaEG8Halecp2tjxhEegPV041zHK5eOzZJkvBnUbVAw04GrBiEVsI2TOFdOl0Sc\nEwVDFoUF0I5zrbvYQYO5kOUDVgkMDiz0O1xTTOmP8UMZ37u9sLCP2maybURAwmwz\nJe8GalSYptnrpAYfxBJQr6q++E3Mu5VJWT3C6033fX80xKZJkWzkKclUo78BmTtW\nzm72UBH7wVoMrsGodjPKwcMwH8iAXTWrGiUYi4xJLlRD8kA38R9qNSue+nid9nL3\n6MkDg+/6yGtyZEOcDMwaAdwE4TfB2Zaw9pabJuoWjuDvcCwMk6om7VCm483qsId8\nKDbCaVTM8mEHnifnxouricFYAA1CyATh884xyqjk8uk8ZOMgOa7n1EdFce88Obra\n2UjT+2k9bOmzgbUE3cd+eJw9xgw6YyOMHzPv3rCt9FRwjOloYMM67SWkYnqEdq+B\na0fz+xabEAfnUMw+Jr+gwoENpZMDTmfD3NG5W+AQ/SQzV/dnFTeHLKkremaywFRy\nWVgR2TRbE+IEvHBUiUYOnDjWLNrWZEHebinF0JQ7ffSN/gFnPeA/QgNeu/F5aOJl\nR+SAWtUD6VzOSmoYC1GcWovR54RkDwqlXHy+L3Yp5AlpMWNnYQ231iRwRRxtRgmD\n1nHsAOBM6B3/qJw2gxaIqwWrsZUbWuP59Ts6t/WlF/+BwgzBxgmf6AJe2dBjzGMM\nytzN07vls8nB9zuHJc4vIEJPQVuIxOlmFYRXiiAsVkGPNEY+tU8yvnVIGlsVuVL2\nTAG7GM4rmvGosY4ISbdArv9NvyO8ym701z9vD9b5Xx37PROVWrYmWLlIrGANokt5\nDX3/GLdWxwQ/suSVjqEoHIKYqHVerM5bWvB7enKPG/Jle1/S/h34ZEsocqNznosF\naWlq/qWdGY0dT05NCV1WQ0pxKsg64qzDits/lABi6A6JJfbDz9rRMUYXUdTAFTC/\nvhfJ1MImAl9xnr39rNEb3A4HtdnjMtXuuWCx+TrxvpWDBCvYjRyPCpRhe1PtYwiS\nPHwPJ3sxM3VvppoXc8GBbjKuC0j1IhhdnhY2Gpcg+dftymrGXcdUdBhKlCsCmNbg\njAyYg/7FpT1jKMAdzakbrv/hSqVdIog632+3MiAxrd0JAg2dHHu5SZizUIMNKZJq\nhojD4LJ95ZQgrPn4TZ/5DtRNXpNSvoK5TwdMSjlMijBvDiLrVtfnQJ4TTi9TpLwi\nGnJKtG9YTVpdWjwN6bADy36C1Jj0kTaxKr3LT4Rrk7kz/moHBZW9vRe5HAjYOHsd\nh5lr3hFvNEGSmbr6wdyem+aK7vvT6g==\n=gTV/\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5705ea01d51cfbd2b93675a5bd21581356b450cd",
          "sha": "5705ea01d51cfbd2b93675a5bd21581356b450cd",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/5705ea01d51cfbd2b93675a5bd21581356b450cd"
        }
      ],
      "message": "net: index nodes in CConnman by id\n\nChange `CConnman::m_nodes` from `std::vector<CNode*>` to\n`std::unordered_map<NodeId, CNode*>` because interaction\nbetween `CConnman` and `SockMan` is going to be based on\n`NodeId` and finding a node by its id would better be fast.\n\nChange `PeerManagerImpl::EvictExtraOutboundPeers()` to account for nodes\nno longer always being in order of id. The old code would have failed to\nupdate `next_youngest_peer` correctly if `CConnman::m_nodes` hadn't\nalways had nodes in ascending order of id.\n\nDuring fuzzing make sure that we don't generate duplicate `CNode` ids.\nThe easiest way to do that is to use sequential ids.\n\nAs a nice side effect the existent search-by-id operations in\n`CConnman::AttemptToEvictConnection()`,\n`CConnman::DisconnectNode()` and\n`CConnman::ForNode()` now become `O(1)` (were `O(number of nodes)`),\nas well as the erase in `CConnman::DisconnectNodes()`.",
      "committer": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2025-04-09T07:59:10Z"
      },
      "author": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2024-09-20T11:27:28Z"
      },
      "sha": "b1987bda3475d72879b68d53659611864c19a2b4"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGYwMDdjZTRmZDUyZTBmMTQ5ODQ1MmM5YWQ1M2I5MDQxN2Q0NzA0ZTU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f007ce4fd52e0f1498452c9ad53b90417d4704e5",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/f007ce4fd52e0f1498452c9ad53b90417d4704e5",
      "tree": {
        "sha": "e9026ffc47a41dedf51f2cb4a55c070034340f81",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e9026ffc47a41dedf51f2cb4a55c070034340f81"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree e9026ffc47a41dedf51f2cb4a55c070034340f81\nparent b1987bda3475d72879b68d53659611864c19a2b4\nauthor Vasil Dimov <vd@FreeBSD.org> 1726905934 +0200\ncommitter Vasil Dimov <vd@FreeBSD.org> 1744185552 +0200\n\nnet: isolate P2P specifics from GenerateWaitSockets()\n\nMove the parts of `CConnman::GenerateWaitSockets()` that are specific to\nthe Bitcoin-P2P protocol to dedicated methods:\n`ShouldTryToSend()` and `ShouldTryToRecv()`.\n\nThis brings us one step closer to moving `GenerateWaitSockets()` to the\nprotocol agnostic `SockMan` (which would call `ShouldTry...()` from\n`CConnman`).\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQQzBAABCAAdFiEE5k2NRWFNsHVF2czBVN8G9ktVy78FAmf2KNAACgkQVN8G9ktV\ny784ox/9GvnWhSHOMbfbXJiLjZwMcCdkuoiBSsxESYvaYyT/nxTziiOsvwv4t10f\n5kKu9361jjLRq5B0t34JBhtBWts3OmO+HuOXR/7ey1OUArltfGgcDcui9NCQD/Fz\nKVSxAC4YRCAr/F8cxk6Ti7rm0uqfTvDWQcxk0K8dKbRG7dKk2ChjLVdZJDUoxVj9\niABlyHnbkE30+B2lSoZ7FrX+k26mB8eTRM09LOzsYDlM8BLclCqmrunRc6pNSQLS\nE34m0stOp0Wd/vpVzz1WMDAlTQYMfLkBdJkPbPX2MPzIuo4KDoDF84RFew9ifugm\n43WgXv37WENV4MCEfRgdFg4b+w6sCt7vsb9k7AUy/OB5Arnhpw3OdT/Mn7G+Hx2X\nNLhaxgvAKqjWHY++swLUSELwi+i2iFe767ijfVI/fEjpRHwtxmwRdImTMCKtAMPj\nhuXKZ3aGVya7WEqSd+HGVH10Zsvkv+7jvlg3sIOdCRH1qM4FptElRxUDHcUAyR+H\nv5Vt/34erLCNM/WSE4ynXrS1s8NU5yQPpYaAR0AmBAx3K6RhkPCKjf6YPUx1NRV8\nKkqqYzAQbsagGGQiVO9FH9jHpH67lwoWpSHqkcvG//tv+eDIe/YzNsbU4dClEasK\nBjpT4y+oqkmZfS9gQBSnrHK4uDCyj59A6PakBkZ7DnYQvaiwhZbznSB+PjGS4u1j\nkaWj8QeGJVk8arEYXtizx9wfgXQpdQCbuGVf2oD9/Flt3UWrDjKBrydfq6MoCHr1\nxZmKawXG7zDXZhrKuL5tHwjgvbZI9lBcpUJlsPGMlGEZLJPP1AWSWQdrd9TDt+vf\nFS49hBN9TgToz89ZypSLfqTfvbJGDy02k2EzakSuMZtPhO4UjUoBkrN1OQwtK2Fw\n80kHlIX75r03/CyhZJVCE2k4RAdRsmu1pa3HPnXxt6WnBuo169g5O0xgLCkff/3I\n/yFWWFVFvuLA1HmR4LR6cnba0tn03SYjj1ZkGc6ttSDkyB6QZ6qDmRS6WdblG9gw\nWOY1US+RFPF4vSRo65nW3SBruwlJsgRZeb7u7n9x1WgcWnalkcIXaU/rqEsjgi5B\nbJc6UeX7L3C2Xz/dZ41MuP3NzBaBqFewaG188a+sAPfasb0wIxOsTkwtXNx4pjfe\nhOiE7RGf/8jI5I2pBGZlp33jBfuV29mHuIgsjw+aawiUgU6tL1a/hZVeRCj/PC91\nS5iN1YGLgbDoyeQD5fA3deJ5zUvHs47UacpUyupFg616s6aZyDJWUjEwRcYMCuII\nh+BXVZI5mPzlNRBlk/sxK1Cav77YjPfxcckCSNrRgfWoOlleNOMySNU2REuo/7vr\n5oWsEfq7b6vUR765XUujU65jm+USAg==\n=5ug8\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b1987bda3475d72879b68d53659611864c19a2b4",
          "sha": "b1987bda3475d72879b68d53659611864c19a2b4",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/b1987bda3475d72879b68d53659611864c19a2b4"
        }
      ],
      "message": "net: isolate P2P specifics from GenerateWaitSockets()\n\nMove the parts of `CConnman::GenerateWaitSockets()` that are specific to\nthe Bitcoin-P2P protocol to dedicated methods:\n`ShouldTryToSend()` and `ShouldTryToRecv()`.\n\nThis brings us one step closer to moving `GenerateWaitSockets()` to the\nprotocol agnostic `SockMan` (which would call `ShouldTry...()` from\n`CConnman`).",
      "committer": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2025-04-09T07:59:12Z"
      },
      "author": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2024-09-21T08:05:34Z"
      },
      "sha": "f007ce4fd52e0f1498452c9ad53b90417d4704e5"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDdmODlkM2E1YmRjZjk5ODAxMGRiMmY5OGI1MTMxNjVmNTgzNGViMWQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7f89d3a5bdcf998010db2f98b513165f5834eb1d",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/7f89d3a5bdcf998010db2f98b513165f5834eb1d",
      "tree": {
        "sha": "c62ad25a37289c391a1667c570233dea39f67aba",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c62ad25a37289c391a1667c570233dea39f67aba"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree c62ad25a37289c391a1667c570233dea39f67aba\nparent f007ce4fd52e0f1498452c9ad53b90417d4704e5\nauthor Vasil Dimov <vd@FreeBSD.org> 1726907513 +0200\ncommitter Vasil Dimov <vd@FreeBSD.org> 1744185552 +0200\n\nnet: isolate P2P specifics from SocketHandlerConnected() and ThreadSocketHandler()\n\nMove some parts of `CConnman::SocketHandlerConnected()` and\n`CConnman::ThreadSocketHandler()` that are specific to the Bitcoin-P2P\nprotocol to dedicated methods:\n`EventIOLoopCompletedForOne(id)` and\n`EventIOLoopCompletedForAll()`.\n\nThis brings us one step closer to moving `SocketHandlerConnected()` and\n`ThreadSocketHandler()` to the protocol agnostic `SockMan` (which would\ncall `EventIOLoopCompleted...()` from `CConnman`).\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQQzBAABCAAdFiEE5k2NRWFNsHVF2czBVN8G9ktVy78FAmf2KNEACgkQVN8G9ktV\ny7+3dSAAnKLxd9p4DDHUEvdFe7/Mp56vKLl9Zc3XGW8nfDWp7fn+AjMX0YJiQqnT\nnyNK0hLS2cYEMec1nh70raJ5yRevNnrgXTtOF/v8kIRb1Ds0iWGCycoKIvKVZUL9\n3FTZLw6slsttftUk6p6LclFsHC5HZTDasCtKG3Ciwl/nM5NOCDl57MNvAK+qrhpC\nyJX8RVqncf2+WFSNN9UAgw62TKVqUW6QKCrARBJC677l3m1MgSQY/AtRWY/NQRjN\njzKWf9e6C/zWvbxVAvAiJcf41OUITwL9YKZ8hU/RO2YkMm3FKofUz1FY961hXAio\nVwps5RaI/8O47bGCp+Mfuoh9LJ1Xcf8M/VjzaKOvd6MRvuDygGUqK5SVQTsx6GCE\nMu10qV4HL2NeS4ZOBC4rm7ZyotgIc9HgMA4KCbfMzdGtZxCg6AUepHcXVyhY2O9n\nyqnIz3Ue/ByDUt1b9r8TpZ3aB5KZEjBlOZPmQvSdyJNqaWDwleaVXUZGW/Z3CsFj\nr7csZhe+ZZUk6V0HlJOQVR436HaKhEmkwOEHxr15AJt0ylo3AEPekXo+f8qkKOSw\n0Zz4IZ6tsbeWtYRnbWzlGkvwqm3LgksZM/kDTer6+ezRmtMYxekNBnVOm8DOT5QZ\n43ikIpS/xCQFzFa8JXweibLlTIAYebELNpeetVrHqWM8nTmsMDBAd7yHLcpX7clV\nipK7VRaBU1XSsippCeGniAORfvvl9RlCeE4OORsrfIRNV8RMaxi9tzcsW44tQkhd\nEAua0lTTRlrtS66R9lCf4JqSy81vAbhRFXHz1UyBlsLzakwScbi7AEM0KX9pK8zW\nLbmnfEW4cv1BcVh4UJdKcVm16aMFeJhjCI22R7HJiiK5q6as+endMc28pgQvyV7l\nR1yQVX0GQmF43xFASRRtN4vd6dNIg7K5JmWtF20YfCKRNA/QcJTVSH6Gv3SMs255\ni6KDTeBcoPdHUcGyc3Tq0eKhbQLW5w1nZCdErFo2pUmPrtqa6GtS9gReihTPRI9x\n0ot9YjbHAnUjPQyOV95qiUrqE+Ydunn03YCfnR6Wnyblve2MpBEBLHYXeplGYp2G\nCQ80PZgz9mXwO7sy4uBt7gDXpnyY7Z6oJiq5Wle3NkjegjHARw6H5L0YU9CVPrya\ndsMvlnQsS6qJ+Q7vkcdPZFsBAQybXeqaGNy50ulAHju6u2wvciS9O1hpc6+d4nXj\nTq5BMN03b4ND7vO3GniSk2BUCkwhLJeUwwfa/QAU1UB2wtFXwQ6WaFPYRlJmeDiA\nv1g3o1zqSL9g9U6NppE5yKBkcmIibiCTgtrwYJD8siJQVtf4TXpJgtEjvwK/+g2l\nC6SOzZawXq/cXt1ov0d7BuqrlCgw9g==\n=t9/E\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f007ce4fd52e0f1498452c9ad53b90417d4704e5",
          "sha": "f007ce4fd52e0f1498452c9ad53b90417d4704e5",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/f007ce4fd52e0f1498452c9ad53b90417d4704e5"
        }
      ],
      "message": "net: isolate P2P specifics from SocketHandlerConnected() and ThreadSocketHandler()\n\nMove some parts of `CConnman::SocketHandlerConnected()` and\n`CConnman::ThreadSocketHandler()` that are specific to the Bitcoin-P2P\nprotocol to dedicated methods:\n`EventIOLoopCompletedForOne(id)` and\n`EventIOLoopCompletedForAll()`.\n\nThis brings us one step closer to moving `SocketHandlerConnected()` and\n`ThreadSocketHandler()` to the protocol agnostic `SockMan` (which would\ncall `EventIOLoopCompleted...()` from `CConnman`).",
      "committer": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2025-04-09T07:59:12Z"
      },
      "author": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2024-09-21T08:31:53Z"
      },
      "sha": "7f89d3a5bdcf998010db2f98b513165f5834eb1d"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDc4YTE3ZTQzOTI1MjkzYTJjZGI3YWJmMmZhZGExMmE0YzM2ZTIyN2Q",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/78a17e43925293a2cdb7abf2fada12a4c36e227d",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/78a17e43925293a2cdb7abf2fada12a4c36e227d",
      "tree": {
        "sha": "180e968b7f3aa3d992fed8eb021385008f3e8ac5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/180e968b7f3aa3d992fed8eb021385008f3e8ac5"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 180e968b7f3aa3d992fed8eb021385008f3e8ac5\nparent 7f89d3a5bdcf998010db2f98b513165f5834eb1d\nauthor Vasil Dimov <vd@FreeBSD.org> 1726999902 +0200\ncommitter Vasil Dimov <vd@FreeBSD.org> 1744185553 +0200\n\nnet: isolate all remaining P2P specifics from SocketHandlerConnected()\n\nIntroduce 4 new methods for the interaction between `CConnman` and\n`SockMan`:\n\n* `EventReadyToSend()`:\n  called when there is readiness to send and do the actual sending of data.\n\n* `EventGotData()`, `EventGotEOF()`, `EventGotPermanentReadError()`:\n  called when the corresponing recv events occur.\n\nThese methods contain logic that is specific to the Bitcoin-P2P protocol\nand move it away from `CConnman::SocketHandlerConnected()` which will\nbecome a protocol agnostic method of `SockMan`.\n\nAlso, move the counting of sent bytes to `CConnman::SocketSendData()` -\nboth callers of that method called `RecordBytesSent()` just after the\ncall, so move it from the callers to inside\n`CConnman::SocketSendData()`.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQQzBAABCAAdFiEE5k2NRWFNsHVF2czBVN8G9ktVy78FAmf2KNEACgkQVN8G9ktV\ny78cGh/8CLOhcV/wmbGjtCUmNBN+yBVq9ejzegZHSGRb5O2KilL8oO7y4s107LPn\nio3tml0kNEVQNIHMiMbqdxMb7OmxKNe4hLaqh/LvJjIMm1l8b9Er+/MVEGdziSVU\n43Z95JGecIJR0FCC+FW9S9ziNFVvVes+daPYhtObLl+pCizuey61Y9CXXj5DWMcn\nCUI1yQI23UPBj7xb8pIhigOkeTL9asbBWXtLWccypqftUvJyYalVSMPD/0T6faMp\n88e2sKtCyh8hG5u73dx/P9Zkkm7TIjkHzUXbjGE1JwAmuOf7zfpDOJG4Uw4AMOzm\neNjvIvM08K2omyyuuYGarB1KW/K0oYlUjKh9Z65ed6Jv27RR8IWjJN56sS4Wmt73\n6dS8+IbS9GUZWx5UsSl6JQBgQlrpPEmPOy8FqwyJK3uefPe3aoiBQvOAbPdgRj6z\n//GCE1k7170kxMAd3C/e/AOJQmzkJIwT0ddYqR78IptyhSBl1esxovd/4aPo2nN3\nlboIhqdvlFp1lwKNl7OUFojv1K1GGEewoGWI0H58n64d5/pWsbfoN9WHIrwE3Op+\no9F5SYLcu79OHKAuG9WNcMm9/KrE84WcFmpCoCxG/FxXcryDZdzpt8OmHDJPJbDx\nqwd13TE4dTMFngm1Km4RGUHKhhJRWHJ6uPafH7rpknSBVAkjrqypRAPO8/91f00K\na+ql7zIP2isfb34dQqx9Z4SJkcaqz8JNW42Q76TPOWS2txZNwqtIn30yzG0Nh9fV\ngq517M9T3ZmRoDwbjt2GwZpyn3M/u47qXqj6E7UaMTapUHHrtWgBBf3LuhIGUzB4\n8QQg5VA9W1p4YiULrtvwvqD+TcOu6L8muKlrXX4gRUT5rHS7LgMGFzvv4NVyKCSc\nWa6huE5vTPd4mNtCvkYCSfXBzQ2OBFC91oWcl79u18kTqnE2Ju/Gqf9r1W1Jd5dR\n82oZXUu5Ewv08kXClWgQD/UYFsm/28OrBazf7DDJ0NHWw99smsIkkIdV48GZcIy0\nExSNum3geyffp87ANredElWlj5jQGTE24FwrmPKGJcYDzKEP/pjytOPhVWjZZbAF\nidDDLlzoB9clziTRyE7W8SwdTKRu7F0BhteAJ/aSjJVZ3KFP9lLFrFEeObdjMeWU\nDQ3YjVNL13gfaNVuClB0jYD316TmpGWAF1faD5RC95CU3sI1Kag9y53GRcqq02mU\nIcP3KEmST5ohyXMhyvNNESp3xPjZ9m5EP4/bqtSXJbM+DCU49Uc7dUlfYlIG7Hkg\nz9DDYJfxJWJW9xOIerOrGM14tAv36CoLr3jpF8oL0tgn7/OPOYGdPEURfFAl23g2\n1YcXlFI1mqpokiO+0YUfXNBQViuFRw==\n=v0Eh\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7f89d3a5bdcf998010db2f98b513165f5834eb1d",
          "sha": "7f89d3a5bdcf998010db2f98b513165f5834eb1d",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/7f89d3a5bdcf998010db2f98b513165f5834eb1d"
        }
      ],
      "message": "net: isolate all remaining P2P specifics from SocketHandlerConnected()\n\nIntroduce 4 new methods for the interaction between `CConnman` and\n`SockMan`:\n\n* `EventReadyToSend()`:\n  called when there is readiness to send and do the actual sending of data.\n\n* `EventGotData()`, `EventGotEOF()`, `EventGotPermanentReadError()`:\n  called when the corresponing recv events occur.\n\nThese methods contain logic that is specific to the Bitcoin-P2P protocol\nand move it away from `CConnman::SocketHandlerConnected()` which will\nbecome a protocol agnostic method of `SockMan`.\n\nAlso, move the counting of sent bytes to `CConnman::SocketSendData()` -\nboth callers of that method called `RecordBytesSent()` just after the\ncall, so move it from the callers to inside\n`CConnman::SocketSendData()`.",
      "committer": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2025-04-09T07:59:13Z"
      },
      "author": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2024-09-22T10:11:42Z"
      },
      "sha": "78a17e43925293a2cdb7abf2fada12a4c36e227d"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDBlMDc0ODFkODcyNGQ5Y2MyOTIzMDcxZDNhNDk4MjI5NWE1NGQ3ZDM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0e07481d8724d9cc2923071d3a4982295a54d7d3",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/0e07481d8724d9cc2923071d3a4982295a54d7d3",
      "tree": {
        "sha": "73c48dc05fce6edb87b849ae9c95194cf0bd5273",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/73c48dc05fce6edb87b849ae9c95194cf0bd5273"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 73c48dc05fce6edb87b849ae9c95194cf0bd5273\nparent 78a17e43925293a2cdb7abf2fada12a4c36e227d\nauthor Vasil Dimov <vd@FreeBSD.org> 1727088625 +0200\ncommitter Vasil Dimov <vd@FreeBSD.org> 1744185553 +0200\n\nnet: split CConnman::ConnectNode()\n\nMove the protocol agnostic parts of `CConnman::ConnectNode()` into\n`SockMan::ConnectAndMakeId()` and leave the Bitcoin-P2P specific\nstuff in `CConnman::ConnectNode()`.\n\nMove the protocol agnostic `CConnman::m_unused_i2p_sessions`, its mutex\nand `MAX_UNUSED_I2P_SESSIONS_SIZE` to `SockMan`.\n\nMove `GetBindAddress()` from `net.cpp` to `sockman.cpp`.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQQzBAABCAAdFiEE5k2NRWFNsHVF2czBVN8G9ktVy78FAmf2KNIACgkQVN8G9ktV\ny7+mEB//crbh5kd+xtCEKAMRmsanbmBt0dGKPGGcQflxIt7OP/v6/RIIxJTS+uR7\nVQV63cmOlY5VLO/09k4zbJue+B93bp6ugkXoF2ckHlZiVB5mF5Q8yrQqq6nWZ4Zr\nvrrsKZRkGQEy8+o9sQifZE3fthpnK9huJC2r26HL6W02xlJONMF5aHG2ChcH5dcA\nmVXyDQ8fZu5OaBNgBrI5MpLtGfqP0xYPZAS2nzHJUkP7tY6OU3WFFf4ODtZUQKyK\noE02htBus1lUtI4WWlxmgr4tgtroN5aQjsgRY1Ule+V5SXOUM5bbrpSr2CFRi2ol\nA1+gly/DR2uW2ugHqrqmazWprzDCXO2gI1xgOojdOl1uwtS+Gre5n2NvoRemIn1d\nYZ4623VioLwut/P5s1aNFe+ptIyU2QPblsDMUFx8opUm9YtXSbnPeiNWhFMcUoc2\nz7JUUxL7GNhhFXTBcinE0I9mPYRo7o+k+4GYIO6X+9h8S5/3iS80t93Sd/EZYYEo\nEdwfyovdTSO4JOkjWX3nUTuWsI72ZOnXVVC5PsOQ7ac5TNVCz2pkEx/S1n4vna47\nZG1pAELOYovzEd8njwngmJRsUdp6xHaSnszcGSIsMQTnzzQfeia5jJi7MnfeQ5SV\nY17iGrpIYMXBQLWSjZhKgxg/GGT6TtTdlsm9m9G1DruhTnayq2sshRT+CHThMINv\n2lpnvhPryByvCVGKVlsY/Tau4qxQjo7/1IKGajM7sFWRJFPsTGYXKOoVKz2KSJDX\npnwvSJmDN3MkfDxAoL7dAk8lCrG6Y+FgTNpxPgmXVTRkXr8T3lbZ9Mv6murjLtA0\n0jeOlS01i2Ba9JIT6mt9yn1QbsYOGTFbmP77NLX2SugIhlq3CgEZhIkR++nWiH5+\naiUS2eg8VO0EzQ6Tt3zu8CraFDvqtbddvyHhubN2VPY6NiTKT5GJd4DcPZde+9fp\nhkWddd48jV2QXNHoAow4ROCMMIKOAy6kKzV6AoZm4bL9blXZFaRHKZ8QU7kT/kQj\nEYsxvdJQq1MjMnhTf9/g1kWRtG7a3wNOe6qINs/L2wBBSpWZEbDYXBOAbw16nRHO\nfo/JEEknCZ8mbCbNF9IYO22I9JBGoN5thVIpOEyEcKbBqSgPHj9dHTwqtuhBQJAa\nbpbq4HzGFWdDbIDRrlpQfPrAKGmucCQJ30Dh9oVs1QGi1gCi3xnneD0QorN8MDwf\n76C0Fnv9rrd1pwaleTI0h0Gd5gFUkVVE9wP59C1SB3gwL5WMvvKIUQOCcDXP0eNf\ns9rYqyqCJGtZE1Y4cNEFlveO6/fvIlAHl9cE2bXb0ZEM7hRy9+rzWsgihDBBBEtn\nqsoRgT73MNsirXRVUOrw20rr/G1v8w==\n=UQv7\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/78a17e43925293a2cdb7abf2fada12a4c36e227d",
          "sha": "78a17e43925293a2cdb7abf2fada12a4c36e227d",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/78a17e43925293a2cdb7abf2fada12a4c36e227d"
        }
      ],
      "message": "net: split CConnman::ConnectNode()\n\nMove the protocol agnostic parts of `CConnman::ConnectNode()` into\n`SockMan::ConnectAndMakeId()` and leave the Bitcoin-P2P specific\nstuff in `CConnman::ConnectNode()`.\n\nMove the protocol agnostic `CConnman::m_unused_i2p_sessions`, its mutex\nand `MAX_UNUSED_I2P_SESSIONS_SIZE` to `SockMan`.\n\nMove `GetBindAddress()` from `net.cpp` to `sockman.cpp`.",
      "committer": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2025-04-09T07:59:13Z"
      },
      "author": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2024-09-23T10:50:25Z"
      },
      "sha": "0e07481d8724d9cc2923071d3a4982295a54d7d3"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGFmYzdmZTY5NGMzOTYzYzA1OGEwNzYwYzk0ZGFjMGY2ZjE4OTdlNGU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/afc7fe694c3963c058a0760c94dac0f6f1897e4e",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/afc7fe694c3963c058a0760c94dac0f6f1897e4e",
      "tree": {
        "sha": "1228ea4dc6fcf7f4f4d750aa3250dab233d2da76",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1228ea4dc6fcf7f4f4d750aa3250dab233d2da76"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 1228ea4dc6fcf7f4f4d750aa3250dab233d2da76\nparent 0e07481d8724d9cc2923071d3a4982295a54d7d3\nauthor Vasil Dimov <vd@FreeBSD.org> 1727163707 +0200\ncommitter Vasil Dimov <vd@FreeBSD.org> 1744185554 +0200\n\nnet: tweak EventNewConnectionAccepted()\n\nMove `MaybeFlipIPv6toCJDNS()`, which is Bitcoin P2P specific from the\ncallers of `CConnman::EventNewConnectionAccepted()` to inside that\nmethod.\n\nMove the IsSelectable check, the `TCP_NODELAY` option set and the\ngeneration of new connection id out of\n`CConnman::EventNewConnectionAccepted()` because those are protocol\nagnostic. Move those to a new method `SockMan::NewSockAccepted()` which\nis called instead of `CConnman::EventNewConnectionAccepted()`.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQQzBAABCAAdFiEE5k2NRWFNsHVF2czBVN8G9ktVy78FAmf2KNMACgkQVN8G9ktV\ny7/hhB//VBuLIgZG/tIMhaexDwT7Twe2Kb8cgUb1IcINIXmejDE2Lt3sjAxmFpUI\nx1dNJfAtUR1V8Qt0UKnuTgJErSzaLwzxrUvXfvWdub8i22lQWMpGFUJaDvAKzX0f\nCR++CctE0HiVgY9/FnHAiYM2SmjoUIsWXrUGzpqEVu56ATHQdISlGfts3L54L7vs\nVsm0r2CxyGEG9Vw8nMuXdvmLI6miWf05zYSDhmfgrVzQJVLIHws5T+7ypFTSak55\nHTXXjp0ISE+XM8nWRFaO2l86ThDWp9qGinC4apVhmLIZGtRB8/AAFRxjYPqKbgwA\nl8D3YhMcPfFn/y6gReyq+jdPNPX1nQzm57+eXC7yfxbl2NdVPUP6aieWBpkLL9js\nOGtQ/Nu5MU9LENQzQi0j4nZm4aaJZFZJEmPYyaS9LUbbb/Fs5JS9nd5B/BFEEORS\nRuYnrlkraMhiwADXol19giGdOgJ0HalcUoc8PupCKlhkQ6uCIKMRatCVw1EWGsDC\n6HSpEsS6XMqoPXF/GDBxXk1/LOChwzxuXYl6tfHz+mOp5YlYZA3rndEGiqYXKneq\nIT+MulG/n409pLFAHZf9/kXF7Ar+wn1HNPtoSwMs3a/NEsSFbEEIU4BJ8KYrDCMv\nkiDaiSwTTGouti1eX6VIF8PV0IlW7sI9Dbmgmlr9wLHxVeX6fTLzh3rHwFIuwl2x\nKTHfYbR2AYxtKgmM9k0Lm/H0uLsNIV5dHfEnrIb0EzbYfmoxcHg1neuQJhUadsCe\nLZ0OgNz0IWsIL9EgFUMk2o0/r/2g9gv4ZcCCIoGZ5OHUM55gWnZnTjh0ChB6kfvL\nQW6FVo5AAAIHQXbNZV5PDpzmouuUHlQ4jfFsaWgsYuMmJT08/H71u4hPh042jxL5\n6fpAgNnaosKsk7WTh6TmjOfDBpimr5Jdr+nIKwgdTys2BpManVNu2UAjdOq6vA5K\n9yNPN4Npz+/1to1ot86gFF1K/PPcjtabvU5ueVaH8V8CSyfEI4jmF1A6KR4sqQKj\nPsFyBMIoxEQJCsoNHWBWs1OX87/SQUWMf9BgMLINPjHNw5pdVO1iambw/69eDL7O\nUa9uiWAADSvUEkq0OZiSrEM8QHfvvWom6lxiDeCMtyl3xaSdvaUYgpQDjbi+5/Jo\nX8fZk0o9j3O7xFeWc6Gyr9LiF0dVB/7CnzQU9HJWFy1y0ICf7o7432koB9uuQAKJ\nLn/xmgTi9+KjdZXs9T5oboWxz8DuwLJJLQjHxTiKGBeJcnU3ZyepYL7bodQs4Fo/\nv4FxiqZ0gAOyn5zo4SSE9DyWOokkK6aYW916Z8SufdVievDPRRt8+Q/jy2Bpr4hC\niCN8wYXtl1vFugFYuuQkyx1XVn8V0w==\n=GNar\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0e07481d8724d9cc2923071d3a4982295a54d7d3",
          "sha": "0e07481d8724d9cc2923071d3a4982295a54d7d3",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/0e07481d8724d9cc2923071d3a4982295a54d7d3"
        }
      ],
      "message": "net: tweak EventNewConnectionAccepted()\n\nMove `MaybeFlipIPv6toCJDNS()`, which is Bitcoin P2P specific from the\ncallers of `CConnman::EventNewConnectionAccepted()` to inside that\nmethod.\n\nMove the IsSelectable check, the `TCP_NODELAY` option set and the\ngeneration of new connection id out of\n`CConnman::EventNewConnectionAccepted()` because those are protocol\nagnostic. Move those to a new method `SockMan::NewSockAccepted()` which\nis called instead of `CConnman::EventNewConnectionAccepted()`.",
      "committer": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2025-04-09T07:59:14Z"
      },
      "author": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2024-09-24T07:41:47Z"
      },
      "sha": "afc7fe694c3963c058a0760c94dac0f6f1897e4e"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDFlZjRmMmVlNDNhNjBkNzNhNTA5ZDViMmZjNTA3MjIwZjBjNGUxODU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1ef4f2ee43a60d73a509d5b2fc507220f0c4e185",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/1ef4f2ee43a60d73a509d5b2fc507220f0c4e185",
      "tree": {
        "sha": "7f8b4c3eb384ac6a154ff612ee17253feaacd1f0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7f8b4c3eb384ac6a154ff612ee17253feaacd1f0"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 7f8b4c3eb384ac6a154ff612ee17253feaacd1f0\nparent afc7fe694c3963c058a0760c94dac0f6f1897e4e\nauthor Vasil Dimov <vd@FreeBSD.org> 1727082212 +0200\ncommitter Vasil Dimov <vd@FreeBSD.org> 1744185555 +0200\n\nnet: move sockets from CNode to SockMan\n\nMove `CNode::m_sock` and `CNode::m_i2p_sam_session` to `SockMan::m_connected`.\nAlso move all the code that handles sockets to `SockMan`.\n\n`CNode::CloseSocketDisconnect()` becomes\n`CConnman::MarkAsDisconnectAndCloseConnection()`.\n\n`CConnman::SocketSendData()` is renamed to\n`CConnman::SendMessagesAsBytes()` and its sockets-touching bits are moved to\n`SockMan::SendBytes()`.\n\n`CConnman::GenerateWaitSockets()` goes to\n`SockMan::GenerateWaitSockets()`.\n\n`CConnman::ThreadSocketHandler()` and\n`CConnman::SocketHandler()` are combined into\n`SockMan::ThreadSocketHandler()`.\n\n`CConnman::SocketHandlerConnected()` goes to\n`SockMan::SocketHandlerConnected()`.\n\n`CConnman::SocketHandlerListening()` goes to\n`SockMan::SocketHandlerListening()`.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQQzBAABCAAdFiEE5k2NRWFNsHVF2czBVN8G9ktVy78FAmf2KNMACgkQVN8G9ktV\ny7+bNB/+P318qBk5ykk+4ZDOKxZjI8e4jQQFatPRtZSTuQK/x58189/w+823geSy\nBimejsIWiRVnNyU/lYuTKja6DaCA0vlOkaPwcOXvkik3BaNNsVNwDl9hqjgAcF8Z\nPLDnV4CWdO5FFssduWmrdGEneinJJlLu7NJIua85oJEae7kdB6/3udG+jlBfDXXq\nVlPbwBL1ckqfBSImbieQvvlP0K0UzUMh+if0WoydZ/HGrWSNvYieEXgquteOg6Td\nmPagVp571b1gCEUUnJbWVo99H9nPRimQaeFfqfYxgguSgYf/y+oke2GqfedHEeYk\nwosMJh8BatmdGXADqieZA2oDUEeRYoNG6LPVX+TgneDB2MmwiLdC6oY3xvyuWz8b\nYdMxop1Aedi7OQ0udipREXriVovNKKk7AogFfTVNj+Xpc4pZn017rXoZve0VcXwt\ny3XhwgzbXoxyR4qfhgRWr99Vznb6TQXygPwbqHqeHBNLwUTl9Ij41fcwqnedspnQ\nD4kv8IVzGstb4ObFNENaVxB0PQN2w8PV9tk1WNmVeJDWp5t03SzoycNgNj4m5Yk6\ncnA/VyMucKA2NA2GePNRkIJCGd27WbIxClBZYuVEw4iRA5Yx4um8oqQjNI66VN36\n+HIKe+dpzHjdrO3NZ/FTtXQMu8wGHODJxMsyDQ16PdGm4ffsLZ74bhO63L7HvxU3\nMVH7uowN+6puJJgXz2Q9zrShcx/Zonglnw0kkL7dqc15i8XHBVv2EYMq3dQhspHC\nBey+6mKaWF7ULyD6fZwglE1c7hlr55R3VxF8kX/ET4IKExEqW1m150N641cqHaBZ\nhxrV8wOC74rUrW5UGPrnBOfXNIu/EV+8HkQTeEIolX37uvBaofSdHQkXiPf6f6LJ\nTkpOLbPdVmYH1Iq1/zWB/2GfewWJ5Mo4vFL/DISAEzhjR8BajKQeBg0lyXuPDJcV\ntqESfWpTlCgXpWLRZuipHPcA7HndqBws03rTorV+39XOAnbf88kL97mZPPo+0ZvP\nu29WqxGvi3y+UdDqzsYGWxWikcRyVYeMxbe6ovhFhq2P2Lh1w5JXua38RjwiBnwa\n5U5P/Pei1jshXXUZ3M2bkMGVQMqrajvCbMPQhlAhePV3e/4X5Hz/ALFZfpsYUztz\n1qVkvsZMHDdgtNKdchCM5EAbS0YhF8tjvf3KgdHWkNMXk2FjfgBtTQ+FXZu13BxB\nRRCQEi5xrc6yyGk/j2MqB5ugNezSMf54TfhWbUFhcI/K9ShL+wu3E7mCFgj7BsWf\nLn6qraJDcnJI8ADkwDMZjicAY6aZdEo7DV9Uk6Q0HdcC6gOfjhWsTCKx1SDELlkd\nRElN3+68j/SljN08hIchhDLanYrkMg==\n=UH2w\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/afc7fe694c3963c058a0760c94dac0f6f1897e4e",
          "sha": "afc7fe694c3963c058a0760c94dac0f6f1897e4e",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/afc7fe694c3963c058a0760c94dac0f6f1897e4e"
        }
      ],
      "message": "net: move sockets from CNode to SockMan\n\nMove `CNode::m_sock` and `CNode::m_i2p_sam_session` to `SockMan::m_connected`.\nAlso move all the code that handles sockets to `SockMan`.\n\n`CNode::CloseSocketDisconnect()` becomes\n`CConnman::MarkAsDisconnectAndCloseConnection()`.\n\n`CConnman::SocketSendData()` is renamed to\n`CConnman::SendMessagesAsBytes()` and its sockets-touching bits are moved to\n`SockMan::SendBytes()`.\n\n`CConnman::GenerateWaitSockets()` goes to\n`SockMan::GenerateWaitSockets()`.\n\n`CConnman::ThreadSocketHandler()` and\n`CConnman::SocketHandler()` are combined into\n`SockMan::ThreadSocketHandler()`.\n\n`CConnman::SocketHandlerConnected()` goes to\n`SockMan::SocketHandlerConnected()`.\n\n`CConnman::SocketHandlerListening()` goes to\n`SockMan::SocketHandlerListening()`.",
      "committer": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2025-04-09T07:59:15Z"
      },
      "author": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2024-09-23T09:03:32Z"
      },
      "sha": "1ef4f2ee43a60d73a509d5b2fc507220f0c4e185"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDdlZjk2NjFmYjA5ZDJjZDkzNTZjY2E3NDc2MjU2ZmVhMjA3N2JlYzk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "tree": {
        "sha": "ba610741ba14793aac638c0944296d5d8f4fc579",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ba610741ba14793aac638c0944296d5d8f4fc579"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree ba610741ba14793aac638c0944296d5d8f4fc579\nparent 1ef4f2ee43a60d73a509d5b2fc507220f0c4e185\nauthor Vasil Dimov <vd@FreeBSD.org> 1727082359 +0200\ncommitter Vasil Dimov <vd@FreeBSD.org> 1744185555 +0200\n\nnet: move-only: improve encapsulation of SockMan\n\n`SockMan` members\n\n`AcceptConnection()`\n`NewSockAccepted()`\n`GetNewId()`\n`m_i2p_sam_session`\n`m_listen`\n\nare now used only by `SockMan`, thus make them private.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQQzBAABCAAdFiEE5k2NRWFNsHVF2czBVN8G9ktVy78FAmf2KNQACgkQVN8G9ktV\ny7+vUyAAkRxtsOcCVF8qQC2X7nAQDYtWVOlfZiOKydxomtb/t1iyQp6NQvv6CxW0\nQVLS2MJhX2si5KSJva39878fqmxY2Y7wQaLtXdHCt8eLS8pyWQc85glvVnjEdAr3\neNI4wcqKtTM/c9x0gCp9E9iNlJRRgE8+Itc5eFmeF1p1n57icln0J447onwZQ1a0\nYMfi5kY+TiWrO6r9+wtj6vJd5HBclsVbe+x3+i1eWI34Esu3gmiOSFDueXkj8OEX\nFSFJZSnmDnk/vR68WDrtPfvS382M0JxqRp/uVtNjKIkLiJQwEyA4j9p9hdV5NBP+\n14HXgSafMPb3d9mPxogRS9zBWChX9NYcdbqZtRWrKZa01yZ5O3V7ixmAgg4x1Sig\nhGYd0PiESaB9gifj2NzSiQQXSkDLO/kGrMjyXIHx+grHnXTYrhTBwuKwYA6nPPO+\nPvj7LuFzaNVVHk0Ep9f4tdp25vuhz7W4DWmcoW6eoNYkXcbsYhT9oUT4zp7ju6LI\nv7vahhbfTfUjZgU09sRHmEVmGKPZQs9fOYt+mAnzoeQ003lal3Z1RbRBHxer8PMt\nFtggI5PFcMp3D3s00cJvU8Qb2tQ3K0WIRm67+1oMkDmJJ7v4ulBbt7ARFKXJyzUD\nnUBeJrwdnR70bAk45OAdQs9oXOAsVCshTAIT90RGY+nban+5pZIfYNCnT6oF/l9C\nfpU4konQn5wHL0ygnNmvHvPCPUg/KHO42rjVzKds8H2opPyyawG6hn4t+Zw8bWdA\n1bwROMQr4KNUUxuPC2Q9VDKtN002VUivcWhUR9cYGPb6p1+jaa9DyVvxBbyc0+w5\nU8TI0ovpM7fQ4D/rhYm2h6oxhIPajY53wANsxmyLhj/xNHQ/BsOxe5BmYzMpxJM5\nlRMrQUqHg+Zh9NNmuy7RruyYcN+Nj8CB9acsceYEYGAjWMLSsrn2+nfD5nOkKY3R\ndcbdNgDa9w/B+pbb7EHkA9i6CDigYizLmOT9MkPwZRRobuBKWhKRlP6Yq6n4Ipfw\nArpS+qaST/U0u1fuGZRSXhuP2N1w+Ib3MJsje/TnA77su9K2GEE9vY91vc0vbl0y\nSS84kJerIoeFmx8n0DBy69JtRu50dGHNP9ziHr2q8m4sxMevtWZhzarOZNOJwgFO\nEr9D54UloLadnzb9vVK4uOWbPT1mptITjSBGkQNXdFCg1BjLwx068eWMbWu2x/se\nKKLKEmvT2b3yjwoaxA8re9HzMDqylJ0waHbwtkct9CmTT+9dZH4VlMYtcs3hJoak\nez/81+stxRR7TmV04X/ARIehrRdQ4Q0ddEOq0yEHeLQ+D4L+FltoLr6aBNqMqbkq\nXAH9Fv2NqcL/nzNpdimjV9MU/LkoMg==\n=Ljzb\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1ef4f2ee43a60d73a509d5b2fc507220f0c4e185",
          "sha": "1ef4f2ee43a60d73a509d5b2fc507220f0c4e185",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/1ef4f2ee43a60d73a509d5b2fc507220f0c4e185"
        }
      ],
      "message": "net: move-only: improve encapsulation of SockMan\n\n`SockMan` members\n\n`AcceptConnection()`\n`NewSockAccepted()`\n`GetNewId()`\n`m_i2p_sam_session`\n`m_listen`\n\nare now used only by `SockMan`, thus make them private.",
      "committer": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2025-04-09T07:59:15Z"
      },
      "author": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2024-09-23T09:05:59Z"
      },
      "sha": "7ef9661fb09d2cd9356cca7476256fea2077bec9"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17184207487,
      "node_id": "HRFPE_lADOABII586YIJemzwAAAAQAQjJ_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17184207487",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "commit_url": "https://api.github.com/repos/vasild/bitcoin/commits/7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "created_at": "2025-04-09T08:12:55Z"
    },
    {
      "event": "commented",
      "id": 2788734134,
      "node_id": "IC_kwDOABII586mOLS2",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2788734134",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-04-09T08:13:12Z",
      "updated_at": "2025-04-09T08:13:12Z",
      "author_association": "CONTRIBUTOR",
      "body": "`f2f9ff9823...7ef9661fb0`: rebase due to conflicts",
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#issuecomment-2788734134",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30988"
    },
    {
      "event": "unlabeled",
      "id": 17184377868,
      "node_id": "UNLE_lADOABII586YIJemzwAAAAQARMwM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17184377868",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-04-09T08:22:26Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2792622898,
      "node_id": "IC_kwDOABII586mdAsy",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2792622898",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-04-10T12:43:09Z",
      "updated_at": "2025-04-10T12:43:09Z",
      "author_association": "CONTRIBUTOR",
      "body": "I assume everybody understands the benefits of modular and reusable code. Reusability is actually a metric for code quality. The fact that `SockMan` can be reused from 3 places means this is on the right track. Even if Sv2 and HTTP are completely dropped, this wouldn't change the reusability of `SockMan`. Current `CConnman` is a mixture of low level socket handling and Bitcoin-P2P specifics. IMO this split makes sense even without Sv2 and HTTP because it makes the code more modular and reusable.\r\n\r\nCan the current `SockMan` interface be improved? I am sure it can and I am open to all kinds of suggestions, big or small.",
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#issuecomment-2792622898",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30988"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1778257807",
      "pull_request_review_id": 2333138089,
      "id": 1778257807,
      "node_id": "PRRC_kwDOABII585p_g-P",
      "diff_hunk": "@@ -203,6 +203,15 @@ static RPCHelpMan getpeerinfo()\n     std::vector<CNodeStats> vstats;\n     connman.GetNodeStats(vstats);\n \n+    // An undocumented side effect of how CConnman previously stored nodes was\n+    // that they were returned ordered by id. At least some functional tests\n+    // rely on that, so keep it that way. An alternative is to remove this sort\n+    // and fix the tests and take the risk of breaking other users of the\n+    // \"getpeerinfo\" RPC.",
      "path": "src/rpc/net.cpp",
      "position": null,
      "original_position": 8,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "03f6cc2b4a76cafd278b9ab92bd915d3946212a9",
      "in_reply_to_id": null,
      "user": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: Arrays are ordered data structures and I don't think it is user-friendly to shuffle them by ID. I think this comment can just be removed.",
      "created_at": "2024-09-27T08:41:33Z",
      "updated_at": "2024-09-27T11:52:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1778257807",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1778257807"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": 206,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 210,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1778767304",
      "pull_request_review_id": 2333986678,
      "id": 1778767304,
      "node_id": "PRRC_kwDOABII585qBdXI",
      "diff_hunk": "@@ -203,6 +203,15 @@ static RPCHelpMan getpeerinfo()\n     std::vector<CNodeStats> vstats;\n     connman.GetNodeStats(vstats);\n \n+    // An undocumented side effect of how CConnman previously stored nodes was\n+    // that they were returned ordered by id. At least some functional tests\n+    // rely on that, so keep it that way. An alternative is to remove this sort\n+    // and fix the tests and take the risk of breaking other users of the\n+    // \"getpeerinfo\" RPC.",
      "path": "src/rpc/net.cpp",
      "position": null,
      "original_position": 8,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "03f6cc2b4a76cafd278b9ab92bd915d3946212a9",
      "in_reply_to_id": 1778257807,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Removed, thanks!",
      "created_at": "2024-09-27T15:05:41Z",
      "updated_at": "2024-09-27T15:05:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1778767304",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1778767304"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": 206,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 210,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1802901394",
      "pull_request_review_id": 2372105727,
      "id": 1802901394,
      "node_id": "PRRC_kwDOABII585rdheS",
      "diff_hunk": "@@ -0,0 +1,528 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep",
      "path": "src/common/sockman.cpp",
      "position": null,
      "original_position": 5,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "70c2f13f83a5cc740330d0b4af9cbd74515be6b2",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Silent merge conflict with #30937",
      "created_at": "2024-10-16T11:15:53Z",
      "updated_at": "2024-10-16T11:15:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1802901394",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1802901394"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 5,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1803679987",
      "pull_request_review_id": 2373476515,
      "id": 1803679987,
      "node_id": "PRRC_kwDOABII585rgfjz",
      "diff_hunk": "@@ -1796,10 +1796,10 @@ void CConnman::CreateNodeFromAcceptedSocket(std::unique_ptr<Sock>&& sock,\n \n     CNode* pnode = new CNode(id,\n                              std::move(sock),\n-                             addr,\n+                             CAddress{addr, NODE_NONE},\n                              CalculateKeyedNetGroup(addr),\n                              nonce,\n-                             addr_bind,\n+                             CAddress{addr_bind, NODE_NONE},",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 45,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "1bfc1ca9b6b68c6356ffc23ecf01e417152ade95",
      "in_reply_to_id": null,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "1bfc1ca9b6b68c6356ffc23ecf01e417152ade95\r\n\r\nWhy do CNode .addr and .addrBind still need to be CAddress? maybe it makes some sense for .addr if that's where we also store the service flags for easier gossiping, but why would the local bind address need anything besides an IP and port?",
      "created_at": "2024-10-16T19:27:15Z",
      "updated_at": "2024-10-18T15:14:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1803679987",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1803679987"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": 1799,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1715,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1803692315",
      "pull_request_review_id": 2373476515,
      "id": 1803692315,
      "node_id": "PRRC_kwDOABII585rgikb",
      "diff_hunk": "@@ -0,0 +1,85 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+\n+bool SockMan::BindListenPort(const CService& addrBind, bilingual_str& strError)\n+{\n+    int nOne = 1;\n+\n+    // Create socket for listening for incoming connections\n+    struct sockaddr_storage sockaddr;\n+    socklen_t len = sizeof(sockaddr);\n+    if (!addrBind.GetSockAddr((struct sockaddr*)&sockaddr, &len))\n+    {\n+        strError = strprintf(Untranslated(\"Bind address family for %s not supported\"), addrBind.ToStringAddrPort());\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"%s\\n\", strError.original);\n+        return false;\n+    }\n+\n+    std::unique_ptr<Sock> sock = CreateSock(addrBind.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP);\n+    if (!sock) {\n+        strError = strprintf(Untranslated(\"Couldn't open socket for incoming connections (socket returned error %s)\"), NetworkErrorString(WSAGetLastError()));\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"%s\\n\", strError.original);\n+        return false;\n+    }\n+\n+    // Allow binding if the port is still in TIME_WAIT state after\n+    // the program was closed and restarted.\n+    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, (sockopt_arg_type)&nOne, sizeof(int)) == SOCKET_ERROR) {\n+        strError = strprintf(Untranslated(\"Error setting SO_REUSEADDR on socket: %s, continuing anyway\"), NetworkErrorString(WSAGetLastError()));\n+        LogPrintf(\"%s\\n\", strError.original);\n+    }\n+\n+    // some systems don't have IPV6_V6ONLY but are always v6only; others do have the option\n+    // and enable it by default or not. Try to enable it, if possible.\n+    if (addrBind.IsIPv6()) {\n+#ifdef IPV6_V6ONLY\n+        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, (sockopt_arg_type)&nOne, sizeof(int)) == SOCKET_ERROR) {\n+            strError = strprintf(Untranslated(\"Error setting IPV6_V6ONLY on socket: %s, continuing anyway\"), NetworkErrorString(WSAGetLastError()));\n+            LogPrintf(\"%s\\n\", strError.original);\n+        }\n+#endif\n+#ifdef WIN32\n+        int nProtLevel = PROTECTION_LEVEL_UNRESTRICTED;\n+        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_PROTECTION_LEVEL, (const char*)&nProtLevel, sizeof(int)) == SOCKET_ERROR) {\n+            strError = strprintf(Untranslated(\"Error setting IPV6_PROTECTION_LEVEL on socket: %s, continuing anyway\"), NetworkErrorString(WSAGetLastError()));\n+            LogPrintf(\"%s\\n\", strError.original);\n+        }\n+#endif\n+    }\n+",
      "path": "src/common/sockman.cpp",
      "position": 89,
      "original_position": 57,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "41c87ddb3d7a18d2c0fa7eccfbde57e9d6e898c2",
      "in_reply_to_id": null,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "41c87ddb3d7a18d2c0fa7eccfbde57e9d6e898c2\r\n\r\nMaybe these are expected to be set by callers in future commits, so I'm just leaving myself a note to look for `SO_KEEPALIVE` and `TCP_NODELAY`",
      "created_at": "2024-10-16T19:38:45Z",
      "updated_at": "2024-10-18T15:14:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1803692315",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1803692315"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 89,
      "original_line": 89,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1804940161",
      "pull_request_review_id": 2373476515,
      "id": 1804940161,
      "node_id": "PRRC_kwDOABII585rlTOB",
      "diff_hunk": "@@ -9,9 +9,12 @@\n #include <util/sock.h>\n #include <util/translation.h>\n \n+#include <atomic>\n #include <memory>\n #include <vector>\n \n+typedef int64_t NodeId;",
      "path": "src/common/sockman.h",
      "position": null,
      "original_position": 8,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "5d4920f630417ceeee1c79304faac6803795cd64",
      "in_reply_to_id": null,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "5d4920f630417ceeee1c79304faac6803795cd64\r\n\r\nI don't really have any better suggestion for this but the term \"node\" is now a higher-level ConnMan context, for HTTP and StratumV2 I'd probably refer to them as \"client\".",
      "created_at": "2024-10-17T14:53:34Z",
      "updated_at": "2024-10-18T15:14:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1804940161",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1804940161"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 23,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1804970448",
      "pull_request_review_id": 2373476515,
      "id": 1804970448,
      "node_id": "PRRC_kwDOABII585rlanQ",
      "diff_hunk": "@@ -124,3 +143,39 @@ void SockMan::CloseSockets()\n }\n \n void SockMan::EventI2PListen(const CService&, bool) {}\n+\n+void SockMan::ThreadI2PAccept()\n+{\n+    static constexpr auto err_wait_begin = 1s;\n+    static constexpr auto err_wait_cap = 5min;\n+    auto err_wait = err_wait_begin;\n+\n+    i2p::Connection conn;\n+\n+    auto SleepOnFailure = [&]() {\n+        interruptNet.sleep_for(err_wait);\n+        if (err_wait < err_wait_cap) {\n+            err_wait += 1s;\n+        }\n+    };\n+\n+    while (!interruptNet) {\n+\n+        if (!m_i2p_sam_session->Listen(conn)) {\n+            EventI2PListen(conn.me, /*success=*/false);",
      "path": "src/common/sockman.cpp",
      "position": null,
      "original_position": 56,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "b94f9d338fd0d3b47a4ea6165ce9cde48f3b19bc",
      "in_reply_to_id": null,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "b94f9d338fd0d3b47a4ea6165ce9cde48f3b19bc\r\n\r\nReminding myself to check for a test that covers a child class with i2p true but no Event listener",
      "created_at": "2024-10-17T15:11:34Z",
      "updated_at": "2024-10-18T15:14:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1804970448",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1804970448"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 309,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1804983489",
      "pull_request_review_id": 2373476515,
      "id": 1804983489,
      "node_id": "PRRC_kwDOABII585rldzB",
      "diff_hunk": "@@ -0,0 +1,85 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+\n+bool SockMan::BindListenPort(const CService& addrBind, bilingual_str& strError)\n+{\n+    int nOne = 1;\n+\n+    // Create socket for listening for incoming connections\n+    struct sockaddr_storage sockaddr;\n+    socklen_t len = sizeof(sockaddr);\n+    if (!addrBind.GetSockAddr((struct sockaddr*)&sockaddr, &len))\n+    {\n+        strError = strprintf(Untranslated(\"Bind address family for %s not supported\"), addrBind.ToStringAddrPort());\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"%s\\n\", strError.original);\n+        return false;\n+    }\n+\n+    std::unique_ptr<Sock> sock = CreateSock(addrBind.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP);\n+    if (!sock) {\n+        strError = strprintf(Untranslated(\"Couldn't open socket for incoming connections (socket returned error %s)\"), NetworkErrorString(WSAGetLastError()));\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"%s\\n\", strError.original);\n+        return false;\n+    }\n+\n+    // Allow binding if the port is still in TIME_WAIT state after\n+    // the program was closed and restarted.\n+    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, (sockopt_arg_type)&nOne, sizeof(int)) == SOCKET_ERROR) {\n+        strError = strprintf(Untranslated(\"Error setting SO_REUSEADDR on socket: %s, continuing anyway\"), NetworkErrorString(WSAGetLastError()));\n+        LogPrintf(\"%s\\n\", strError.original);\n+    }\n+\n+    // some systems don't have IPV6_V6ONLY but are always v6only; others do have the option\n+    // and enable it by default or not. Try to enable it, if possible.\n+    if (addrBind.IsIPv6()) {\n+#ifdef IPV6_V6ONLY\n+        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, (sockopt_arg_type)&nOne, sizeof(int)) == SOCKET_ERROR) {\n+            strError = strprintf(Untranslated(\"Error setting IPV6_V6ONLY on socket: %s, continuing anyway\"), NetworkErrorString(WSAGetLastError()));\n+            LogPrintf(\"%s\\n\", strError.original);\n+        }\n+#endif\n+#ifdef WIN32\n+        int nProtLevel = PROTECTION_LEVEL_UNRESTRICTED;\n+        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_PROTECTION_LEVEL, (const char*)&nProtLevel, sizeof(int)) == SOCKET_ERROR) {\n+            strError = strprintf(Untranslated(\"Error setting IPV6_PROTECTION_LEVEL on socket: %s, continuing anyway\"), NetworkErrorString(WSAGetLastError()));\n+            LogPrintf(\"%s\\n\", strError.original);\n+        }\n+#endif\n+    }\n+",
      "path": "src/common/sockman.cpp",
      "position": 89,
      "original_position": 57,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "41c87ddb3d7a18d2c0fa7eccfbde57e9d6e898c2",
      "in_reply_to_id": 1803692315,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Ok I see NODELAY set  by ConnMan in EventNewConnectionAccepted in b94f9d338fd0d3b47a4ea6165ce9cde48f3b19bc\r\n\r\nI'm guessing we dont use KEEPALIVE for bitcoin p2p because we have out own ping/pong protocol",
      "created_at": "2024-10-17T15:19:48Z",
      "updated_at": "2024-10-18T15:14:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1804983489",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1804983489"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 89,
      "original_line": 89,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1804998403",
      "pull_request_review_id": 2373476515,
      "id": 1804998403,
      "node_id": "PRRC_kwDOABII585rlhcD",
      "diff_hunk": "@@ -63,6 +96,16 @@ class SockMan\n     // Pure virtual functions must be implemented by children classes.\n     //\n \n+    /**\n+     * Be notified when a new connection has been accepted.\n+     * @param[in] sock Connected socket to communicate with the peer.\n+     * @param[in] me The address and port at our side of the connection.\n+     * @param[in] them The address and port at the peer's side of the connection.\n+     */\n+    virtual void EventNewConnectionAccepted(std::unique_ptr<Sock>&& sock,",
      "path": "src/common/sockman.h",
      "position": null,
      "original_position": 77,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "b94f9d338fd0d3b47a4ea6165ce9cde48f3b19bc",
      "in_reply_to_id": null,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "b94f9d338fd0d3b47a4ea6165ce9cde48f3b19bc\r\n\r\nSeems weird to me to move the unique pointer to a connected socket out of sockman, implying that sockman itself doesn't own the connections. Peeking ahead at future commits though I think this gets resolved.",
      "created_at": "2024-10-17T15:29:01Z",
      "updated_at": "2024-10-18T15:14:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1804998403",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1804998403"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 105,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1805112369",
      "pull_request_review_id": 2373476515,
      "id": 1805112369,
      "node_id": "PRRC_kwDOABII585rl9Qx",
      "diff_hunk": "@@ -1410,7 +1411,7 @@ class CConnman : private SockMan\n     std::vector<AddedNodeParams> m_added_node_params GUARDED_BY(m_added_nodes_mutex);\n \n     mutable Mutex m_added_nodes_mutex;\n-    std::vector<CNode*> m_nodes GUARDED_BY(m_nodes_mutex);\n+    std::unordered_map<NodeId, CNode*> m_nodes GUARDED_BY(m_nodes_mutex);",
      "path": "src/net.h",
      "position": 306,
      "original_position": 31,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "b96beb27d2b3d06a45644c537c114a08f0ccd285",
      "in_reply_to_id": null,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "b96beb27d2b3d06a45644c537c114a08f0ccd285\r\n\r\nLove this, great optimization and makes a lot of sense.",
      "created_at": "2024-10-17T16:52:54Z",
      "updated_at": "2024-10-18T15:14:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1805112369",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1805112369"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1414,
      "original_line": 1414,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1805115729",
      "pull_request_review_id": 2373476515,
      "id": 1805115729,
      "node_id": "PRRC_kwDOABII585rl-FR",
      "diff_hunk": "@@ -45,12 +45,13 @@ FUZZ_TARGET(connman, .init = initialize_connman)\n     connman.Init(options);\n \n     CNetAddr random_netaddr;\n-    CNode random_node = ConsumeNode(fuzzed_data_provider);\n+    NodeId node_id{0};\n+    CNode random_node = ConsumeNode(fuzzed_data_provider, node_id++);",
      "path": "src/test/fuzz/connman.cpp",
      "position": null,
      "original_position": 6,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "b96beb27d2b3d06a45644c537c114a08f0ccd285",
      "in_reply_to_id": null,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "b96beb27d2b3d06a45644c537c114a08f0ccd285\r\n\r\nWhy not use `GetNewNodeId()` here? (and below) Don't you have a Connman with its own `m_next_node_id`?",
      "created_at": "2024-10-17T16:55:41Z",
      "updated_at": "2024-10-18T15:14:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1805115729",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1805115729"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": 48,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 49,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1805124507",
      "pull_request_review_id": 2373476515,
      "id": 1805124507,
      "node_id": "PRRC_kwDOABII585rmAOb",
      "diff_hunk": "@@ -111,6 +111,22 @@ class SockMan\n     // alone to use the default implementation from SockMan.\n     //\n \n+    /**\n+     * SockMan would only call EventReadyToSend() if this returns true.\n+     * Can be used to temporary pause sends for a node.\n+     * The implementation in SockMan always returns true.\n+     * @param[in] node_id Node for which to confirm or cancel a call to EventReadyToSend().\n+     */\n+    virtual bool ShouldTryToSend(NodeId node_id) const;\n+\n+    /**\n+     * SockMan would only call Recv() on a node's socket if this returns true.\n+     * Can be used to temporary pause receives for a node.",
      "path": "src/common/sockman.h",
      "position": null,
      "original_position": 14,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "bb5b91d430026c4826a2107c8c1a311518cc97ce",
      "in_reply_to_id": null,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "bb5b91d430026c4826a2107c8c1a311518cc97ce\r\n\r\nnit s/temporary/temporarily\r\n\r\nand above",
      "created_at": "2024-10-17T17:03:08Z",
      "updated_at": "2024-10-18T15:14:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1805124507",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1805124507"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 228,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1805134391",
      "pull_request_review_id": 2373476515,
      "id": 1805134391,
      "node_id": "PRRC_kwDOABII585rmCo3",
      "diff_hunk": "@@ -127,6 +127,22 @@ class SockMan\n      */\n     virtual bool ShouldTryToRecv(NodeId node_id) const;\n \n+    /**\n+     * SockMan has completed the current send+recv iteration for a node.\n+     * It will do another send+recv for this node after processing all other nodes.\n+     * Can be used to execute periodic tasks for a given node.\n+     * The implementation in SockMan does nothing.\n+     * @param[in] node_id Node for which send+recv has been done.\n+     */\n+    virtual void EventIOLoopCompletedForNode(NodeId node_id);\n+\n+    /**\n+     * SockMan has completed send+recv for all nodes.\n+     * Can be used to execute periodic tasks for all nodes.\n+     * The implementation in SockMan does nothing.\n+     */\n+    virtual void EventIOLoopCompletedForAllPeers();",
      "path": "src/common/sockman.h",
      "position": null,
      "original_position": 18,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "50cb52470ea6cc4de5a5e5260b8f308353942ec0",
      "in_reply_to_id": null,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "50cb52470ea6cc4de5a5e5260b8f308353942ec0\r\n\r\nThis is great, can be used for timed actions (like locking the wallet) we used to depend on libevent for",
      "created_at": "2024-10-17T17:12:00Z",
      "updated_at": "2024-10-18T15:14:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1805134391",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1805134391"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 257,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1805142536",
      "pull_request_review_id": 2373476515,
      "id": 1805142536,
      "node_id": "PRRC_kwDOABII585rmEoI",
      "diff_hunk": "@@ -2013,6 +2013,29 @@ bool CConnman::ShouldTryToRecv(NodeId node_id) const\n     return !node->fPauseRecv;\n }\n \n+void CConnman::EventIOLoopCompletedForNode(NodeId node_id)\n+{\n+    AssertLockNotHeld(m_nodes_mutex);\n+\n+    CNode* node{GetNodeById(node_id)};\n+    if (node == nullptr) {\n+        return;\n+    }\n+\n+    if (InactivityCheck(*node)) {\n+        node->fDisconnect = true;\n+    }\n+}\n+\n+void CConnman::EventIOLoopCompletedForAllPeers()\n+{\n+    AssertLockNotHeld(m_nodes_mutex);\n+    AssertLockNotHeld(m_reconnections_mutex);\n+\n+    DisconnectNodes();",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 23,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "50cb52470ea6cc4de5a5e5260b8f308353942ec0",
      "in_reply_to_id": null,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "50cb52470ea6cc4de5a5e5260b8f308353942ec0\r\n\r\nInteresting that the parent class handles accepting connections but the child is expected to handle disconnections, and inside the utility event loop function. Of course only the derived class would know when disconnection is appropriate, I wonder if anything it makes sense just to add a comment in `sockman.h` that `EventIOLoopCompletedForAllPeers()` is expected to handle that, erasing items from `m_nodes`",
      "created_at": "2024-10-17T17:19:06Z",
      "updated_at": "2024-10-18T15:14:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1805142536",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1805142536"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2035,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1805157675",
      "pull_request_review_id": 2373476515,
      "id": 1805157675,
      "node_id": "PRRC_kwDOABII585rmIUr",
      "diff_hunk": "@@ -10,6 +10,19 @@\n #include <util/sock.h>\n #include <util/thread.h>\n \n+CService GetBindAddress(const Sock& sock)\n+{\n+    CService addr_bind;\n+    struct sockaddr_storage sockaddr_bind;\n+    socklen_t sockaddr_bind_len = sizeof(sockaddr_bind);\n+    if (!sock.GetSockName((struct sockaddr*)&sockaddr_bind, &sockaddr_bind_len)) {",
      "path": "src/common/sockman.cpp",
      "position": 25,
      "original_position": 9,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "3bb0145514978092ae966e30693cf619e4034837",
      "in_reply_to_id": null,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "3bb0145514978092ae966e30693cf619e4034837\r\n\r\nthe `else {error}` looked backwards to me here at first, might be more clear to use `== 0` instead of `!` but i dunno what the official style is for this.",
      "created_at": "2024-10-17T17:32:07Z",
      "updated_at": "2024-10-18T15:14:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1805157675",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1805157675"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 25,
      "original_line": 25,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1805160999",
      "pull_request_review_id": 2373476515,
      "id": 1805160999,
      "node_id": "PRRC_kwDOABII585rmJIn",
      "diff_hunk": "@@ -10,6 +10,19 @@\n #include <util/sock.h>\n #include <util/thread.h>\n \n+CService GetBindAddress(const Sock& sock)",
      "path": "src/common/sockman.cpp",
      "position": null,
      "original_position": 4,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "3bb0145514978092ae966e30693cf619e4034837",
      "in_reply_to_id": null,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "3bb0145514978092ae966e30693cf619e4034837\r\n\r\nWould this make more sense as a direct method of `Sock` ? Especially now that it returns the simpler `CService` instead of `CAddress`",
      "created_at": "2024-10-17T17:35:04Z",
      "updated_at": "2024-10-18T15:14:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1805160999",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1805160999"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 13,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1805171602",
      "pull_request_review_id": 2373476515,
      "id": 1805171602,
      "node_id": "PRRC_kwDOABII585rmLuS",
      "diff_hunk": "@@ -74,6 +79,37 @@ class SockMan\n      */\n     void JoinSocketsThreads();\n \n+    /**\n+     * A more readable std::tuple<std::string, uint16_t> for host and port.\n+     */\n+    struct StringHostIntPort {\n+        const std::string& host;\n+        uint16_t port;\n+    };\n+\n+    /**\n+     * Make an outbound connection, save the socket internally and return a newly generated node id.\n+     * @param[in] to The address to connect to, either as CService or a host as string and port as\n+     * an integer, if the later is used, then `proxy` must be valid.\n+     * @param[in] is_important If true, then log failures with higher severity.\n+     * @param[in] proxy Proxy to connect through if `proxy.IsValid()` is true.\n+     * @param[out] proxy_failed If `proxy` is valid and the connection failed because of the\n+     * proxy, then it will be set to true.\n+     * @param[out] me If the connection was successful then this is set to the address on the\n+     * local side of the socket.\n+     * @param[out] sock Connected socket, if the operation is successful.\n+     * @param[out] i2p_transient_session I2P session, if the operation is successful.\n+     * @return Newly generated node id, or std::nullopt if the operation fails.\n+     */\n+    std::optional<NodeId> ConnectAndMakeNodeId(const std::variant<CService, StringHostIntPort>& to,",
      "path": "src/common/sockman.h",
      "position": null,
      "original_position": 50,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "3bb0145514978092ae966e30693cf619e4034837",
      "in_reply_to_id": null,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "3bb0145514978092ae966e30693cf619e4034837\r\n\r\nThis is great. Won't be needed immediately for HTTP or StratumV2 but means we can more easily remove libevent from `bitcoin-cli` !",
      "created_at": "2024-10-17T17:44:51Z",
      "updated_at": "2024-10-18T15:14:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1805171602",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1805171602"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 110,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1805205812",
      "pull_request_review_id": 2373476515,
      "id": 1805205812,
      "node_id": "PRRC_kwDOABII585rmUE0",
      "diff_hunk": "@@ -0,0 +1,85 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+\n+bool SockMan::BindListenPort(const CService& addrBind, bilingual_str& strError)\n+{\n+    int nOne = 1;\n+\n+    // Create socket for listening for incoming connections\n+    struct sockaddr_storage sockaddr;\n+    socklen_t len = sizeof(sockaddr);\n+    if (!addrBind.GetSockAddr((struct sockaddr*)&sockaddr, &len))\n+    {\n+        strError = strprintf(Untranslated(\"Bind address family for %s not supported\"), addrBind.ToStringAddrPort());\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"%s\\n\", strError.original);\n+        return false;\n+    }\n+\n+    std::unique_ptr<Sock> sock = CreateSock(addrBind.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP);\n+    if (!sock) {\n+        strError = strprintf(Untranslated(\"Couldn't open socket for incoming connections (socket returned error %s)\"), NetworkErrorString(WSAGetLastError()));\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"%s\\n\", strError.original);\n+        return false;\n+    }\n+\n+    // Allow binding if the port is still in TIME_WAIT state after\n+    // the program was closed and restarted.\n+    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, (sockopt_arg_type)&nOne, sizeof(int)) == SOCKET_ERROR) {\n+        strError = strprintf(Untranslated(\"Error setting SO_REUSEADDR on socket: %s, continuing anyway\"), NetworkErrorString(WSAGetLastError()));\n+        LogPrintf(\"%s\\n\", strError.original);\n+    }\n+\n+    // some systems don't have IPV6_V6ONLY but are always v6only; others do have the option\n+    // and enable it by default or not. Try to enable it, if possible.\n+    if (addrBind.IsIPv6()) {\n+#ifdef IPV6_V6ONLY\n+        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, (sockopt_arg_type)&nOne, sizeof(int)) == SOCKET_ERROR) {\n+            strError = strprintf(Untranslated(\"Error setting IPV6_V6ONLY on socket: %s, continuing anyway\"), NetworkErrorString(WSAGetLastError()));\n+            LogPrintf(\"%s\\n\", strError.original);\n+        }\n+#endif\n+#ifdef WIN32\n+        int nProtLevel = PROTECTION_LEVEL_UNRESTRICTED;\n+        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_PROTECTION_LEVEL, (const char*)&nProtLevel, sizeof(int)) == SOCKET_ERROR) {\n+            strError = strprintf(Untranslated(\"Error setting IPV6_PROTECTION_LEVEL on socket: %s, continuing anyway\"), NetworkErrorString(WSAGetLastError()));\n+            LogPrintf(\"%s\\n\", strError.original);\n+        }\n+#endif\n+    }\n+",
      "path": "src/common/sockman.cpp",
      "position": 89,
      "original_position": 57,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "41c87ddb3d7a18d2c0fa7eccfbde57e9d6e898c2",
      "in_reply_to_id": 1803692315,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Moved to `NewSockAccepted()` in 9d1b352a4d050ec88b59cdf59209c0f086fea4e6",
      "created_at": "2024-10-17T18:04:36Z",
      "updated_at": "2024-10-18T15:14:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1805205812",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1805205812"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 89,
      "original_line": 89,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1805233524",
      "pull_request_review_id": 2373476515,
      "id": 1805233524,
      "node_id": "PRRC_kwDOABII585rma10",
      "diff_hunk": "@@ -63,6 +96,16 @@ class SockMan\n     // Pure virtual functions must be implemented by children classes.\n     //\n \n+    /**\n+     * Be notified when a new connection has been accepted.\n+     * @param[in] sock Connected socket to communicate with the peer.\n+     * @param[in] me The address and port at our side of the connection.\n+     * @param[in] them The address and port at the peer's side of the connection.\n+     */\n+    virtual void EventNewConnectionAccepted(std::unique_ptr<Sock>&& sock,",
      "path": "src/common/sockman.h",
      "position": null,
      "original_position": 77,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "b94f9d338fd0d3b47a4ea6165ce9cde48f3b19bc",
      "in_reply_to_id": 1804998403,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "resolved in b94f9d338fd0d3b47a4ea6165ce9cde48f3b19bc",
      "created_at": "2024-10-17T18:22:07Z",
      "updated_at": "2024-10-18T15:14:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1805233524",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1805233524"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 105,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1806645938",
      "pull_request_review_id": 2373476515,
      "id": 1806645938,
      "node_id": "PRRC_kwDOABII585rrzqy",
      "diff_hunk": "@@ -262,8 +335,16 @@ void SockMan::EventIOLoopCompletedForAllPeers() {}\n \n void SockMan::EventI2PListen(const CService&, bool) {}\n \n+void SockMan::TestOnlyAddExistentNode(NodeId node_id, std::unique_ptr<Sock>&& sock)\n+{\n+    LOCK(m_connected_mutex);\n+    m_connected.emplace(node_id, std::make_shared<NodeSockets>(std::move(sock)));",
      "path": "src/common/sockman.cpp",
      "position": null,
      "original_position": 149,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "c133a634d10e172652ebbf05ca114037c8e551b9",
      "in_reply_to_id": null,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "c133a634d10e172652ebbf05ca114037c8e551b9\r\n\r\nI know this is for testing only, but what happens if there is a NodeId collision (An existing node is inserted with a duplicate ID, replacing a connected node in sockman)?",
      "created_at": "2024-10-18T14:57:30Z",
      "updated_at": "2024-10-18T15:14:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1806645938",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1806645938"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 282,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1806666862",
      "pull_request_review_id": 2373476515,
      "id": 1806666862,
      "node_id": "PRRC_kwDOABII585rr4xu",
      "diff_hunk": "@@ -297,3 +378,151 @@ void SockMan::ThreadI2PAccept()\n         err_wait = err_wait_begin;\n     }\n }\n+\n+void SockMan::ThreadSocketHandler()\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    while (!interruptNet) {\n+        EventIOLoopCompletedForAllPeers();\n+\n+        // Check for the readiness of the already connected sockets and the\n+        // listening sockets in one call (\"readiness\" as in poll(2) or\n+        // select(2)). If none are ready, wait for a short while and return\n+        // empty sets.\n+        auto io_readiness{GenerateWaitSockets()};\n+        if (io_readiness.events_per_sock.empty() ||\n+            !io_readiness.events_per_sock.begin()->first->WaitMany(SELECT_TIMEOUT,",
      "path": "src/common/sockman.cpp",
      "position": null,
      "original_position": 177,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "c133a634d10e172652ebbf05ca114037c8e551b9",
      "in_reply_to_id": null,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "c133a634d10e172652ebbf05ca114037c8e551b9\r\n\r\nYou might want to add another comment here - when I was trying to handle socks myself I found this a bit weird and wrote:\r\n\r\n```\r\n    // WaitMany() mine as well be a static function, the context\r\n    // of the first Sock in the vector is not relevant.\r\n```",
      "created_at": "2024-10-18T15:13:32Z",
      "updated_at": "2024-10-18T15:14:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1806666862",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1806666862"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": 394,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 348,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1867660305",
      "pull_request_review_id": 2475577960,
      "id": 1867660305,
      "node_id": "PRRC_kwDOABII585vUjwR",
      "diff_hunk": "@@ -1796,10 +1796,10 @@ void CConnman::CreateNodeFromAcceptedSocket(std::unique_ptr<Sock>&& sock,\n \n     CNode* pnode = new CNode(id,\n                              std::move(sock),\n-                             addr,\n+                             CAddress{addr, NODE_NONE},\n                              CalculateKeyedNetGroup(addr),\n                              nonce,\n-                             addr_bind,\n+                             CAddress{addr_bind, NODE_NONE},",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 45,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "1bfc1ca9b6b68c6356ffc23ecf01e417152ade95",
      "in_reply_to_id": 1803679987,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "`CNode::addr` needs to be `CAddress` because at least `PeerManagerImpl::PushNodeVersion()` is using `addr.nServices`.\r\n\r\n`CNode::addrBind` indeed does not need to be `CAddress`. I changed it to `CService`.",
      "created_at": "2024-12-03T12:43:35Z",
      "updated_at": "2024-12-03T12:43:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1867660305",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1867660305"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": 1799,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1715,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1867664745",
      "pull_request_review_id": 2475584933,
      "id": 1867664745,
      "node_id": "PRRC_kwDOABII585vUk1p",
      "diff_hunk": "@@ -9,9 +9,12 @@\n #include <util/sock.h>\n #include <util/translation.h>\n \n+#include <atomic>\n #include <memory>\n #include <vector>\n \n+typedef int64_t NodeId;",
      "path": "src/common/sockman.h",
      "position": null,
      "original_position": 8,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "5d4920f630417ceeee1c79304faac6803795cd64",
      "in_reply_to_id": 1804940161,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "\"Peer\" is a good description for this, but that is already used in `net_processing`.",
      "created_at": "2024-12-03T12:46:38Z",
      "updated_at": "2024-12-03T12:46:39Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1867664745",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1867664745"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 23,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1867697664",
      "pull_request_review_id": 2475640361,
      "id": 1867697664,
      "node_id": "PRRC_kwDOABII585vUs4A",
      "diff_hunk": "@@ -45,12 +45,13 @@ FUZZ_TARGET(connman, .init = initialize_connman)\n     connman.Init(options);\n \n     CNetAddr random_netaddr;\n-    CNode random_node = ConsumeNode(fuzzed_data_provider);\n+    NodeId node_id{0};\n+    CNode random_node = ConsumeNode(fuzzed_data_provider, node_id++);",
      "path": "src/test/fuzz/connman.cpp",
      "position": null,
      "original_position": 6,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "b96beb27d2b3d06a45644c537c114a08f0ccd285",
      "in_reply_to_id": 1805115729,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "`GetNewNodeId()` is private. Not worth weakening the encapsulation for this test.",
      "created_at": "2024-12-03T13:10:42Z",
      "updated_at": "2024-12-03T13:10:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1867697664",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1867697664"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": 48,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 49,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1867701118",
      "pull_request_review_id": 2475646217,
      "id": 1867701118,
      "node_id": "PRRC_kwDOABII585vUtt-",
      "diff_hunk": "@@ -111,6 +111,22 @@ class SockMan\n     // alone to use the default implementation from SockMan.\n     //\n \n+    /**\n+     * SockMan would only call EventReadyToSend() if this returns true.\n+     * Can be used to temporary pause sends for a node.\n+     * The implementation in SockMan always returns true.\n+     * @param[in] node_id Node for which to confirm or cancel a call to EventReadyToSend().\n+     */\n+    virtual bool ShouldTryToSend(NodeId node_id) const;\n+\n+    /**\n+     * SockMan would only call Recv() on a node's socket if this returns true.\n+     * Can be used to temporary pause receives for a node.",
      "path": "src/common/sockman.h",
      "position": null,
      "original_position": 14,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "bb5b91d430026c4826a2107c8c1a311518cc97ce",
      "in_reply_to_id": 1805124507,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2024-12-03T13:13:11Z",
      "updated_at": "2024-12-03T13:13:11Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1867701118",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1867701118"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 228,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1867731551",
      "pull_request_review_id": 2475696688,
      "id": 1867731551,
      "node_id": "PRRC_kwDOABII585vU1Jf",
      "diff_hunk": "@@ -2013,6 +2013,29 @@ bool CConnman::ShouldTryToRecv(NodeId node_id) const\n     return !node->fPauseRecv;\n }\n \n+void CConnman::EventIOLoopCompletedForNode(NodeId node_id)\n+{\n+    AssertLockNotHeld(m_nodes_mutex);\n+\n+    CNode* node{GetNodeById(node_id)};\n+    if (node == nullptr) {\n+        return;\n+    }\n+\n+    if (InactivityCheck(*node)) {\n+        node->fDisconnect = true;\n+    }\n+}\n+\n+void CConnman::EventIOLoopCompletedForAllPeers()\n+{\n+    AssertLockNotHeld(m_nodes_mutex);\n+    AssertLockNotHeld(m_reconnections_mutex);\n+\n+    DisconnectNodes();",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 23,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "50cb52470ea6cc4de5a5e5260b8f308353942ec0",
      "in_reply_to_id": 1805142536,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Good observation. I guess this is the nature of things: accepting new connections is driven (initiated) by low level socket event when a new connection arrives, while disconnecting can be low level driven or high level driven - e.g. misbehaving peer at the application layer.\r\n\r\nI extended the comment of `EventIOLoopCompletedForAllPeers()` a little bit:\r\n\r\n```diff\r\n    -+     * Can be used to execute periodic tasks for all nodes.                   \r\n    ++     * Can be used to execute periodic tasks for all nodes, like disconnecting\r\n    ++     * nodes due to higher level logic.           \r\n```",
      "created_at": "2024-12-03T13:34:07Z",
      "updated_at": "2024-12-03T13:34:07Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1867731551",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1867731551"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2035,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1867742015",
      "pull_request_review_id": 2475714232,
      "id": 1867742015,
      "node_id": "PRRC_kwDOABII585vU3s_",
      "diff_hunk": "@@ -10,6 +10,19 @@\n #include <util/sock.h>\n #include <util/thread.h>\n \n+CService GetBindAddress(const Sock& sock)\n+{\n+    CService addr_bind;\n+    struct sockaddr_storage sockaddr_bind;\n+    socklen_t sockaddr_bind_len = sizeof(sockaddr_bind);\n+    if (!sock.GetSockName((struct sockaddr*)&sockaddr_bind, &sockaddr_bind_len)) {",
      "path": "src/common/sockman.cpp",
      "position": 25,
      "original_position": 9,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "3bb0145514978092ae966e30693cf619e4034837",
      "in_reply_to_id": 1805157675,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I don't think we have an official recommendation. My personal preference is to not treat integers as booleans: use `if (x == 0)` instead of `if (!x)` when `x` is an integer. But I am leaving this as it is because it is like that in `master` and this PR only moves it from `net.cpp` to `sockman.cpp` verbatim. I hope it is easier to reviewers to just check that a blob of code is moved without having to validate its correctness since that same code is already in `master`. This helps with such moves:\r\n\r\n`~/.gitconfig`:\r\n```\r\n[diff]  \r\n        colorMoved = dimmed-zebra\r\n        colorMovedWS = allow-indentation-change\r\n```",
      "created_at": "2024-12-03T13:41:11Z",
      "updated_at": "2024-12-03T13:41:11Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1867742015",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1867742015"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 25,
      "original_line": 25,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1867749410",
      "pull_request_review_id": 2475726387,
      "id": 1867749410,
      "node_id": "PRRC_kwDOABII585vU5gi",
      "diff_hunk": "@@ -10,6 +10,19 @@\n #include <util/sock.h>\n #include <util/thread.h>\n \n+CService GetBindAddress(const Sock& sock)",
      "path": "src/common/sockman.cpp",
      "position": null,
      "original_position": 4,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "3bb0145514978092ae966e30693cf619e4034837",
      "in_reply_to_id": 1805160999,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Maybe yes, but `sock.{h,cpp}` does not currently include `netaddress.h` and I guess including it may cause circular dependency. It would also increase the scope of this PR. I am leaving it as it is.",
      "created_at": "2024-12-03T13:46:07Z",
      "updated_at": "2024-12-03T13:46:07Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1867749410",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1867749410"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 13,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1867761722",
      "pull_request_review_id": 2475746404,
      "id": 1867761722,
      "node_id": "PRRC_kwDOABII585vU8g6",
      "diff_hunk": "@@ -262,8 +335,16 @@ void SockMan::EventIOLoopCompletedForAllPeers() {}\n \n void SockMan::EventI2PListen(const CService&, bool) {}\n \n+void SockMan::TestOnlyAddExistentNode(NodeId node_id, std::unique_ptr<Sock>&& sock)\n+{\n+    LOCK(m_connected_mutex);\n+    m_connected.emplace(node_id, std::make_shared<NodeSockets>(std::move(sock)));",
      "path": "src/common/sockman.cpp",
      "position": null,
      "original_position": 149,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "c133a634d10e172652ebbf05ca114037c8e551b9",
      "in_reply_to_id": 1806645938,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "It would be a mess. I added an assert to make it clear that a test which inserts duplicate ids is broken.",
      "created_at": "2024-12-03T13:53:20Z",
      "updated_at": "2024-12-03T13:53:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1867761722",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1867761722"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 282,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1867768931",
      "pull_request_review_id": 2475757783,
      "id": 1867768931,
      "node_id": "PRRC_kwDOABII585vU-Rj",
      "diff_hunk": "@@ -297,3 +378,151 @@ void SockMan::ThreadI2PAccept()\n         err_wait = err_wait_begin;\n     }\n }\n+\n+void SockMan::ThreadSocketHandler()\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    while (!interruptNet) {\n+        EventIOLoopCompletedForAllPeers();\n+\n+        // Check for the readiness of the already connected sockets and the\n+        // listening sockets in one call (\"readiness\" as in poll(2) or\n+        // select(2)). If none are ready, wait for a short while and return\n+        // empty sets.\n+        auto io_readiness{GenerateWaitSockets()};\n+        if (io_readiness.events_per_sock.empty() ||\n+            !io_readiness.events_per_sock.begin()->first->WaitMany(SELECT_TIMEOUT,",
      "path": "src/common/sockman.cpp",
      "position": null,
      "original_position": 177,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "c133a634d10e172652ebbf05ca114037c8e551b9",
      "in_reply_to_id": 1806666862,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done",
      "created_at": "2024-12-03T13:57:46Z",
      "updated_at": "2024-12-03T13:57:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1867768931",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1867768931"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": 394,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 348,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1878764170",
      "pull_request_review_id": 2493471520,
      "id": 1878764170,
      "node_id": "PRRC_kwDOABII585v-6qK",
      "diff_hunk": "@@ -0,0 +1,427 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#ifndef BITCOIN_COMMON_SOCKMAN_H\n+#define BITCOIN_COMMON_SOCKMAN_H\n+\n+#include <i2p.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <util/fs.h>\n+#include <util/sock.h>\n+#include <util/translation.h>\n+\n+#include <atomic>\n+#include <memory>\n+#include <queue>\n+#include <thread>\n+#include <variant>\n+#include <vector>\n+\n+typedef int64_t NodeId;\n+\n+/**\n+ * A socket manager class which handles socket operations.\n+ * To use this class, inherit from it and implement the pure virtual methods.\n+ * Handled operations:\n+ * - binding and listening on sockets\n+ * - starting of necessary threads to process socket operations\n+ * - accepting incoming connections\n+ * - making outbound connections\n+ * - closing connections\n+ * - waiting for IO readiness on sockets and doing send/recv accordingly\n+ */\n+class SockMan\n+{\n+public:\n+\n+    virtual ~SockMan() = default;\n+\n+    //\n+    // Non-virtual functions, to be reused by children classes.\n+    //\n+\n+    /**\n+     * Bind to a new address:port, start listening and add the listen socket to `m_listen`.\n+     * Should be called before `StartSocketsThreads()`.\n+     * @param[in] to Where to bind.\n+     * @param[out] errmsg Error string if an error occurs.\n+     * @retval true Success.\n+     * @retval false Failure, `strError` will be set.\n+     */\n+    bool BindAndStartListening(const CService& to, bilingual_str& errmsg);\n+\n+    /**\n+     * Options to influence `StartSocketsThreads()`.\n+     */\n+    struct Options {\n+        struct I2P {\n+            explicit I2P(const fs::path& file, const Proxy& proxy) : private_key_file{file}, sam_proxy{proxy} {}\n+\n+            const fs::path private_key_file;\n+            const Proxy sam_proxy;\n+        };\n+\n+        /**\n+         * I2P options. If set then a thread will be started that will accept incoming I2P connections.\n+         */\n+        std::optional<I2P> i2p;\n+    };\n+\n+    /**\n+     * Start the necessary threads for sockets IO.\n+     */\n+    void StartSocketsThreads(const Options& options);\n+\n+    /**\n+     * Join (wait for) the threads started by `StartSocketsThreads()` to exit.\n+     */\n+    void JoinSocketsThreads();\n+\n+    /**\n+     * A more readable std::tuple<std::string, uint16_t> for host and port.\n+     */\n+    struct StringHostIntPort {\n+        const std::string& host;\n+        uint16_t port;\n+    };\n+\n+    /**\n+     * Make an outbound connection, save the socket internally and return a newly generated node id.\n+     * @param[in] to The address to connect to, either as CService or a host as string and port as\n+     * an integer, if the later is used, then `proxy` must be valid.\n+     * @param[in] is_important If true, then log failures with higher severity.\n+     * @param[in] proxy Proxy to connect through if `proxy.IsValid()` is true.\n+     * @param[out] proxy_failed If `proxy` is valid and the connection failed because of the\n+     * proxy, then it will be set to true.\n+     * @param[out] me If the connection was successful then this is set to the address on the\n+     * local side of the socket.\n+     * @return Newly generated node id, or std::nullopt if the operation fails.\n+     */\n+    std::optional<NodeId> ConnectAndMakeNodeId(const std::variant<CService, StringHostIntPort>& to,\n+                                               bool is_important,\n+                                               const Proxy& proxy,\n+                                               bool& proxy_failed,\n+                                               CService& me)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex, !m_unused_i2p_sessions_mutex);\n+\n+    /**\n+     * Disconnect a given peer by closing its socket and release resources occupied by it.\n+     * @return Whether the peer existed and its socket was closed by this call.\n+     */\n+    bool CloseConnection(NodeId node_id)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Try to send some data to the given node.\n+     * @param[in] node_id Identifier of the node to send to.\n+     * @param[in] data The data to send, it might happen that only a prefix of this is sent.\n+     * @param[in] will_send_more Used as an optimization if the caller knows that they will\n+     * be sending more data soon after this call.\n+     * @param[out] errmsg If <0 is returned then this will contain a human readable message\n+     * explaining the error.\n+     * @retval >=0 The number of bytes actually sent.\n+     * @retval <0 A permanent error has occurred.\n+     */\n+    ssize_t SendBytes(NodeId node_id,\n+                      Span<const unsigned char> data,",
      "path": "src/common/sockman.h",
      "position": null,
      "original_position": 128,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "645f625e29b36321bcba8db5758b0428b8ebd80f",
      "in_reply_to_id": null,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Why not use std::span? I thought `Span` was only a temporary fill-in until C++20 something something? Also, I'm using std::span elsewhere... is `Span` the preference?",
      "created_at": "2024-12-10T20:12:05Z",
      "updated_at": "2024-12-10T20:12:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1878764170",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1878764170"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 128,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1886282291",
      "pull_request_review_id": 2505319114,
      "id": 1886282291,
      "node_id": "PRRC_kwDOABII585wbmIz",
      "diff_hunk": "@@ -0,0 +1,427 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#ifndef BITCOIN_COMMON_SOCKMAN_H\n+#define BITCOIN_COMMON_SOCKMAN_H\n+\n+#include <i2p.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <util/fs.h>\n+#include <util/sock.h>\n+#include <util/translation.h>\n+\n+#include <atomic>\n+#include <memory>\n+#include <queue>\n+#include <thread>\n+#include <variant>\n+#include <vector>\n+\n+typedef int64_t NodeId;\n+\n+/**\n+ * A socket manager class which handles socket operations.\n+ * To use this class, inherit from it and implement the pure virtual methods.\n+ * Handled operations:\n+ * - binding and listening on sockets\n+ * - starting of necessary threads to process socket operations\n+ * - accepting incoming connections\n+ * - making outbound connections\n+ * - closing connections\n+ * - waiting for IO readiness on sockets and doing send/recv accordingly\n+ */\n+class SockMan\n+{\n+public:\n+\n+    virtual ~SockMan() = default;\n+\n+    //\n+    // Non-virtual functions, to be reused by children classes.\n+    //\n+\n+    /**\n+     * Bind to a new address:port, start listening and add the listen socket to `m_listen`.\n+     * Should be called before `StartSocketsThreads()`.\n+     * @param[in] to Where to bind.\n+     * @param[out] errmsg Error string if an error occurs.\n+     * @retval true Success.\n+     * @retval false Failure, `strError` will be set.\n+     */\n+    bool BindAndStartListening(const CService& to, bilingual_str& errmsg);\n+\n+    /**\n+     * Options to influence `StartSocketsThreads()`.\n+     */\n+    struct Options {\n+        struct I2P {\n+            explicit I2P(const fs::path& file, const Proxy& proxy) : private_key_file{file}, sam_proxy{proxy} {}\n+\n+            const fs::path private_key_file;\n+            const Proxy sam_proxy;\n+        };\n+\n+        /**\n+         * I2P options. If set then a thread will be started that will accept incoming I2P connections.\n+         */\n+        std::optional<I2P> i2p;\n+    };\n+\n+    /**\n+     * Start the necessary threads for sockets IO.\n+     */\n+    void StartSocketsThreads(const Options& options);\n+\n+    /**\n+     * Join (wait for) the threads started by `StartSocketsThreads()` to exit.\n+     */\n+    void JoinSocketsThreads();\n+\n+    /**\n+     * A more readable std::tuple<std::string, uint16_t> for host and port.\n+     */\n+    struct StringHostIntPort {\n+        const std::string& host;\n+        uint16_t port;\n+    };\n+\n+    /**\n+     * Make an outbound connection, save the socket internally and return a newly generated node id.\n+     * @param[in] to The address to connect to, either as CService or a host as string and port as\n+     * an integer, if the later is used, then `proxy` must be valid.\n+     * @param[in] is_important If true, then log failures with higher severity.\n+     * @param[in] proxy Proxy to connect through if `proxy.IsValid()` is true.\n+     * @param[out] proxy_failed If `proxy` is valid and the connection failed because of the\n+     * proxy, then it will be set to true.\n+     * @param[out] me If the connection was successful then this is set to the address on the\n+     * local side of the socket.\n+     * @return Newly generated node id, or std::nullopt if the operation fails.\n+     */\n+    std::optional<NodeId> ConnectAndMakeNodeId(const std::variant<CService, StringHostIntPort>& to,\n+                                               bool is_important,\n+                                               const Proxy& proxy,\n+                                               bool& proxy_failed,\n+                                               CService& me)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex, !m_unused_i2p_sessions_mutex);\n+\n+    /**\n+     * Disconnect a given peer by closing its socket and release resources occupied by it.\n+     * @return Whether the peer existed and its socket was closed by this call.\n+     */\n+    bool CloseConnection(NodeId node_id)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Try to send some data to the given node.\n+     * @param[in] node_id Identifier of the node to send to.\n+     * @param[in] data The data to send, it might happen that only a prefix of this is sent.\n+     * @param[in] will_send_more Used as an optimization if the caller knows that they will\n+     * be sending more data soon after this call.\n+     * @param[out] errmsg If <0 is returned then this will contain a human readable message\n+     * explaining the error.\n+     * @retval >=0 The number of bytes actually sent.\n+     * @retval <0 A permanent error has occurred.\n+     */\n+    ssize_t SendBytes(NodeId node_id,\n+                      Span<const unsigned char> data,",
      "path": "src/common/sockman.h",
      "position": null,
      "original_position": 128,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "645f625e29b36321bcba8db5758b0428b8ebd80f",
      "in_reply_to_id": 1878764170,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Even in relatively new code folks often use `Span`, e.g. #30043. cc @sipa, @laanwj",
      "created_at": "2024-12-16T07:10:15Z",
      "updated_at": "2024-12-16T07:10:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1886282291",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1886282291"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 128,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1891188093",
      "pull_request_review_id": 2513401237,
      "id": 1891188093,
      "node_id": "PRRC_kwDOABII585wuT19",
      "diff_hunk": "@@ -0,0 +1,427 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#ifndef BITCOIN_COMMON_SOCKMAN_H\n+#define BITCOIN_COMMON_SOCKMAN_H\n+\n+#include <i2p.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <util/fs.h>\n+#include <util/sock.h>\n+#include <util/translation.h>\n+\n+#include <atomic>\n+#include <memory>\n+#include <queue>\n+#include <thread>\n+#include <variant>\n+#include <vector>\n+\n+typedef int64_t NodeId;\n+\n+/**\n+ * A socket manager class which handles socket operations.\n+ * To use this class, inherit from it and implement the pure virtual methods.\n+ * Handled operations:\n+ * - binding and listening on sockets\n+ * - starting of necessary threads to process socket operations\n+ * - accepting incoming connections\n+ * - making outbound connections\n+ * - closing connections\n+ * - waiting for IO readiness on sockets and doing send/recv accordingly\n+ */\n+class SockMan\n+{\n+public:\n+\n+    virtual ~SockMan() = default;\n+\n+    //\n+    // Non-virtual functions, to be reused by children classes.\n+    //\n+\n+    /**\n+     * Bind to a new address:port, start listening and add the listen socket to `m_listen`.\n+     * Should be called before `StartSocketsThreads()`.\n+     * @param[in] to Where to bind.\n+     * @param[out] errmsg Error string if an error occurs.\n+     * @retval true Success.\n+     * @retval false Failure, `strError` will be set.\n+     */\n+    bool BindAndStartListening(const CService& to, bilingual_str& errmsg);\n+\n+    /**\n+     * Options to influence `StartSocketsThreads()`.\n+     */\n+    struct Options {\n+        struct I2P {\n+            explicit I2P(const fs::path& file, const Proxy& proxy) : private_key_file{file}, sam_proxy{proxy} {}\n+\n+            const fs::path private_key_file;\n+            const Proxy sam_proxy;\n+        };\n+\n+        /**\n+         * I2P options. If set then a thread will be started that will accept incoming I2P connections.\n+         */\n+        std::optional<I2P> i2p;\n+    };\n+\n+    /**\n+     * Start the necessary threads for sockets IO.\n+     */\n+    void StartSocketsThreads(const Options& options);\n+\n+    /**\n+     * Join (wait for) the threads started by `StartSocketsThreads()` to exit.\n+     */\n+    void JoinSocketsThreads();\n+\n+    /**\n+     * A more readable std::tuple<std::string, uint16_t> for host and port.\n+     */\n+    struct StringHostIntPort {\n+        const std::string& host;\n+        uint16_t port;\n+    };\n+\n+    /**\n+     * Make an outbound connection, save the socket internally and return a newly generated node id.\n+     * @param[in] to The address to connect to, either as CService or a host as string and port as\n+     * an integer, if the later is used, then `proxy` must be valid.\n+     * @param[in] is_important If true, then log failures with higher severity.\n+     * @param[in] proxy Proxy to connect through if `proxy.IsValid()` is true.\n+     * @param[out] proxy_failed If `proxy` is valid and the connection failed because of the\n+     * proxy, then it will be set to true.\n+     * @param[out] me If the connection was successful then this is set to the address on the\n+     * local side of the socket.\n+     * @return Newly generated node id, or std::nullopt if the operation fails.\n+     */\n+    std::optional<NodeId> ConnectAndMakeNodeId(const std::variant<CService, StringHostIntPort>& to,\n+                                               bool is_important,\n+                                               const Proxy& proxy,\n+                                               bool& proxy_failed,\n+                                               CService& me)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex, !m_unused_i2p_sessions_mutex);\n+\n+    /**\n+     * Disconnect a given peer by closing its socket and release resources occupied by it.\n+     * @return Whether the peer existed and its socket was closed by this call.\n+     */\n+    bool CloseConnection(NodeId node_id)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Try to send some data to the given node.\n+     * @param[in] node_id Identifier of the node to send to.\n+     * @param[in] data The data to send, it might happen that only a prefix of this is sent.\n+     * @param[in] will_send_more Used as an optimization if the caller knows that they will\n+     * be sending more data soon after this call.\n+     * @param[out] errmsg If <0 is returned then this will contain a human readable message\n+     * explaining the error.\n+     * @retval >=0 The number of bytes actually sent.\n+     * @retval <0 A permanent error has occurred.\n+     */\n+    ssize_t SendBytes(NodeId node_id,\n+                      Span<const unsigned char> data,",
      "path": "src/common/sockman.h",
      "position": null,
      "original_position": 128,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "645f625e29b36321bcba8db5758b0428b8ebd80f",
      "in_reply_to_id": 1878764170,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Must have been just inertia. The caller of the newly added `SendBytes()` has an argument that is already `Span` from elsewhere in the code, coming from here:\r\n\r\nhttps://github.com/bitcoin/bitcoin/blob/c1252b14d714448295200a595086dd3e78b46c8f/src/net.h#L307-L311\r\n\r\nNow I changed the argument of the newly added `SendBytes()` to `std::span`, looks better and the `Span` variable is accepted. Thanks!\r\n\r\nwen `s/Span/std::span/` all over the place?",
      "created_at": "2024-12-19T05:47:48Z",
      "updated_at": "2024-12-19T05:47:48Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1891188093",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1891188093"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 128,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1892975685",
      "pull_request_review_id": 2515908987,
      "id": 1892975685,
      "node_id": "PRRC_kwDOABII585w1IRF",
      "diff_hunk": "@@ -0,0 +1,427 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#ifndef BITCOIN_COMMON_SOCKMAN_H\n+#define BITCOIN_COMMON_SOCKMAN_H\n+\n+#include <i2p.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <util/fs.h>\n+#include <util/sock.h>\n+#include <util/translation.h>\n+\n+#include <atomic>\n+#include <memory>\n+#include <queue>\n+#include <thread>\n+#include <variant>\n+#include <vector>\n+\n+typedef int64_t NodeId;\n+\n+/**\n+ * A socket manager class which handles socket operations.\n+ * To use this class, inherit from it and implement the pure virtual methods.\n+ * Handled operations:\n+ * - binding and listening on sockets\n+ * - starting of necessary threads to process socket operations\n+ * - accepting incoming connections\n+ * - making outbound connections\n+ * - closing connections\n+ * - waiting for IO readiness on sockets and doing send/recv accordingly\n+ */\n+class SockMan\n+{\n+public:\n+\n+    virtual ~SockMan() = default;\n+\n+    //\n+    // Non-virtual functions, to be reused by children classes.\n+    //\n+\n+    /**\n+     * Bind to a new address:port, start listening and add the listen socket to `m_listen`.\n+     * Should be called before `StartSocketsThreads()`.\n+     * @param[in] to Where to bind.\n+     * @param[out] errmsg Error string if an error occurs.\n+     * @retval true Success.\n+     * @retval false Failure, `strError` will be set.\n+     */\n+    bool BindAndStartListening(const CService& to, bilingual_str& errmsg);\n+\n+    /**\n+     * Options to influence `StartSocketsThreads()`.\n+     */\n+    struct Options {\n+        struct I2P {\n+            explicit I2P(const fs::path& file, const Proxy& proxy) : private_key_file{file}, sam_proxy{proxy} {}\n+\n+            const fs::path private_key_file;\n+            const Proxy sam_proxy;\n+        };\n+\n+        /**\n+         * I2P options. If set then a thread will be started that will accept incoming I2P connections.\n+         */\n+        std::optional<I2P> i2p;\n+    };\n+\n+    /**\n+     * Start the necessary threads for sockets IO.\n+     */\n+    void StartSocketsThreads(const Options& options);\n+\n+    /**\n+     * Join (wait for) the threads started by `StartSocketsThreads()` to exit.\n+     */\n+    void JoinSocketsThreads();\n+\n+    /**\n+     * A more readable std::tuple<std::string, uint16_t> for host and port.\n+     */\n+    struct StringHostIntPort {\n+        const std::string& host;\n+        uint16_t port;\n+    };\n+\n+    /**\n+     * Make an outbound connection, save the socket internally and return a newly generated node id.\n+     * @param[in] to The address to connect to, either as CService or a host as string and port as\n+     * an integer, if the later is used, then `proxy` must be valid.\n+     * @param[in] is_important If true, then log failures with higher severity.\n+     * @param[in] proxy Proxy to connect through if `proxy.IsValid()` is true.\n+     * @param[out] proxy_failed If `proxy` is valid and the connection failed because of the\n+     * proxy, then it will be set to true.\n+     * @param[out] me If the connection was successful then this is set to the address on the\n+     * local side of the socket.\n+     * @return Newly generated node id, or std::nullopt if the operation fails.\n+     */\n+    std::optional<NodeId> ConnectAndMakeNodeId(const std::variant<CService, StringHostIntPort>& to,\n+                                               bool is_important,\n+                                               const Proxy& proxy,\n+                                               bool& proxy_failed,\n+                                               CService& me)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex, !m_unused_i2p_sessions_mutex);\n+\n+    /**\n+     * Disconnect a given peer by closing its socket and release resources occupied by it.\n+     * @return Whether the peer existed and its socket was closed by this call.\n+     */\n+    bool CloseConnection(NodeId node_id)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Try to send some data to the given node.\n+     * @param[in] node_id Identifier of the node to send to.\n+     * @param[in] data The data to send, it might happen that only a prefix of this is sent.\n+     * @param[in] will_send_more Used as an optimization if the caller knows that they will\n+     * be sending more data soon after this call.\n+     * @param[out] errmsg If <0 is returned then this will contain a human readable message\n+     * explaining the error.\n+     * @retval >=0 The number of bytes actually sent.\n+     * @retval <0 A permanent error has occurred.\n+     */\n+    ssize_t SendBytes(NodeId node_id,\n+                      Span<const unsigned char> data,",
      "path": "src/common/sockman.h",
      "position": null,
      "original_position": 128,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "645f625e29b36321bcba8db5758b0428b8ebd80f",
      "in_reply_to_id": 1878764170,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> wen `s/Span/std::span/` all over the place?\r\n\r\nnow: https://github.com/bitcoin/bitcoin/pull/31519",
      "created_at": "2024-12-19T18:36:33Z",
      "updated_at": "2024-12-19T18:36:33Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1892975685",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1892975685"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 128,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1914992602",
      "pull_request_review_id": 2550005361,
      "id": 1914992602,
      "node_id": "PRRC_kwDOABII585yJHfa",
      "diff_hunk": "@@ -3145,13 +3145,16 @@ bool CConnman::Bind(const CService& addr_, unsigned int flags, NetPermissionFlag\n     const CService addr{MaybeFlipIPv6toCJDNS(addr_)};\n \n     bilingual_str strError;\n-    if (!BindListenPort(addr, strError)) {\n+    if (!BindAndStartListening(addr, strError)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"%s\\n\", strError.original);\n         if ((flags & BF_REPORT_ERROR) && m_client_interface) {\n             m_client_interface->ThreadSafeMessageBox(strError, \"\", CClientUIInterface::MSG_ERROR);\n         }\n         return false;\n     }\n \n+    LogPrintLevel(BCLog::NET, BCLog::Level::Info, \"Bound to and listening at %s\\n\", addr.ToStringAddrPort());",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 13,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "4c23aacc2b82083f96255963f543dc35fff28334",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "4c23aacc2b82083f96255963f543dc35fff28334: I'm inclined to say \"listening **on** %s\"\r\n\r\nAs in: we bind _to_ a port in order to listen _on_ it.\r\n\r\nThe linux manual for `listen` also uses \"on\", as in \"listen for connections on a socket\"\r\nhttps://man7.org/linux/man-pages/man2/listen.2.html",
      "created_at": "2025-01-14T15:05:33Z",
      "updated_at": "2025-01-14T15:31:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1914992602",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1914992602"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3156,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1915015927",
      "pull_request_review_id": 2550005361,
      "id": 1915015927,
      "node_id": "PRRC_kwDOABII585yJNL3",
      "diff_hunk": "@@ -9,68 +9,77 @@\n #include <netbase.h>\n #include <util/sock.h>\n \n-bool SockMan::BindListenPort(const CService& addrBind, bilingual_str& strError)\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& errmsg)",
      "path": "src/common/sockman.cpp",
      "position": null,
      "original_position": 5,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "4c23aacc2b82083f96255963f543dc35fff28334",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "4c23aacc2b82083f96255963f543dc35fff28334: since you need to print log statements here in a few places anyway, might as well drop the `errmsg` argument and always print logs here.",
      "created_at": "2025-01-14T15:15:03Z",
      "updated_at": "2025-01-14T15:31:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1915015927",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1915015927"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 32,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1915209026",
      "pull_request_review_id": 2550364600,
      "id": 1915209026,
      "node_id": "PRRC_kwDOABII585yJ8VC",
      "diff_hunk": "@@ -9,68 +9,77 @@\n #include <netbase.h>\n #include <util/sock.h>\n \n-bool SockMan::BindListenPort(const CService& addrBind, bilingual_str& strError)\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& errmsg)",
      "path": "src/common/sockman.cpp",
      "position": null,
      "original_position": 5,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "4c23aacc2b82083f96255963f543dc35fff28334",
      "in_reply_to_id": 1915015927,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "`BindAndStartListening()` needs to return an error string to the caller, because the caller not only logs it but also passes it to `ThreadSafeMessageBox()`.",
      "created_at": "2025-01-14T16:38:24Z",
      "updated_at": "2025-01-14T16:38:24Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1915209026",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1915209026"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 32,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1915209813",
      "pull_request_review_id": 2550365991,
      "id": 1915209813,
      "node_id": "PRRC_kwDOABII585yJ8hV",
      "diff_hunk": "@@ -3145,13 +3145,16 @@ bool CConnman::Bind(const CService& addr_, unsigned int flags, NetPermissionFlag\n     const CService addr{MaybeFlipIPv6toCJDNS(addr_)};\n \n     bilingual_str strError;\n-    if (!BindListenPort(addr, strError)) {\n+    if (!BindAndStartListening(addr, strError)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"%s\\n\", strError.original);\n         if ((flags & BF_REPORT_ERROR) && m_client_interface) {\n             m_client_interface->ThreadSafeMessageBox(strError, \"\", CClientUIInterface::MSG_ERROR);\n         }\n         return false;\n     }\n \n+    LogPrintLevel(BCLog::NET, BCLog::Level::Info, \"Bound to and listening at %s\\n\", addr.ToStringAddrPort());",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 13,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "4c23aacc2b82083f96255963f543dc35fff28334",
      "in_reply_to_id": 1914992602,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done, `s/at/on/`",
      "created_at": "2025-01-14T16:38:52Z",
      "updated_at": "2025-01-14T16:38:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1915209813",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1915209813"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3156,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1915228277",
      "pull_request_review_id": 2550393864,
      "id": 1915228277,
      "node_id": "PRRC_kwDOABII585yKBB1",
      "diff_hunk": "@@ -9,68 +9,77 @@\n #include <netbase.h>\n #include <util/sock.h>\n \n-bool SockMan::BindListenPort(const CService& addrBind, bilingual_str& strError)\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& errmsg)",
      "path": "src/common/sockman.cpp",
      "position": null,
      "original_position": 5,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "4c23aacc2b82083f96255963f543dc35fff28334",
      "in_reply_to_id": 1915015927,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Ah ok, I missed that bit.",
      "created_at": "2025-01-14T16:45:41Z",
      "updated_at": "2025-01-14T16:45:42Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1915228277",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1915228277"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 32,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1916382790",
      "pull_request_review_id": 2552280742,
      "id": 1916382790,
      "node_id": "PRRC_kwDOABII585yOa5G",
      "diff_hunk": "@@ -1737,7 +1737,10 @@ void CConnman::AcceptConnection(const ListenSocket& hListenSocket) {\n     const CService addr_bind{MaybeFlipIPv6toCJDNS(GetBindAddress(*sock))};\n \n     NetPermissionFlags permission_flags = NetPermissionFlags::None;\n-    hListenSocket.AddSocketPermissionFlags(permission_flags);\n+    auto it{m_listen_permissions.find(addr_bind)};\n+    if (it != m_listen_permissions.end()) {",
      "path": "src/net.cpp",
      "position": 402,
      "original_position": 6,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "fd81820214e695ba228a954506397c3d781fe3fe",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "fd81820214e695ba228a954506397c3d781fe3fe: do want to add an `Assume` here, given that `Bind` always adds an entry?",
      "created_at": "2025-01-15T11:18:27Z",
      "updated_at": "2025-01-15T11:28:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1916382790",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1916382790"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1680,
      "original_line": 1680,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1916431512",
      "pull_request_review_id": 2552366143,
      "id": 1916431512,
      "node_id": "PRRC_kwDOABII585yOmyY",
      "diff_hunk": "@@ -2195,7 +2169,16 @@ void CConnman::SocketHandlerListening(const Sock::EventsPerSock& events_per_sock\n         }\n         const auto it = events_per_sock.find(sock);\n         if (it != events_per_sock.end() && it->second.occurred & Sock::RECV) {\n-            AcceptConnection(*sock);\n+            CService addr_accepted;\n+\n+            auto sock_accepted{AcceptConnection(*sock, addr_accepted)};\n+\n+            if (sock_accepted) {\n+                addr_accepted = MaybeFlipIPv6toCJDNS(addr_accepted);",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 60,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "0241b04cf406d482abfac3fddfad9a9c28725f32",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "0241b04cf406d482abfac3fddfad9a9c28725f32: previously this would not get called if `addr.SetSockAddr` failed in `AcceptConnection`. I suspect it doesn't matter though.",
      "created_at": "2025-01-15T11:54:18Z",
      "updated_at": "2025-01-15T12:37:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1916431512",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1916431512"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2177,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1916457190",
      "pull_request_review_id": 2552366143,
      "id": 1916457190,
      "node_id": "PRRC_kwDOABII585yOtDm",
      "diff_hunk": "@@ -9,9 +9,12 @@\n #include <util/sock.h>\n #include <util/translation.h>\n \n+#include <atomic>\n #include <memory>\n #include <vector>\n \n+typedef int64_t NodeId;",
      "path": "src/common/sockman.h",
      "position": null,
      "original_position": 8,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "5d4920f630417ceeee1c79304faac6803795cd64",
      "in_reply_to_id": 1804940161,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "1b05e1d4ba55a42ba74026b68fa4e616b973e06d: maybe `ConnectionId`?\r\n\r\nAnd then in net.h use `typedef ConnectionId NodeId;`\r\n\r\nhttps://github.com/Sjors/bitcoin/commit/f33049b45b7013022ed4c75c0bc52d878fe15fd5\r\n\r\nMost of the churn would be in `sockman.{h,cpp}`, so that seems acceptable.\r\n\r\nThat said, I don't think it's very important.",
      "created_at": "2025-01-15T12:01:48Z",
      "updated_at": "2025-01-15T12:37:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1916457190",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1916457190"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 23,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1916636569",
      "pull_request_review_id": 2552728389,
      "id": 1916636569,
      "node_id": "PRRC_kwDOABII585yPY2Z",
      "diff_hunk": "@@ -59,6 +66,26 @@ class SockMan\n \n private:\n \n+    //\n+    // Pure virtual functions must be implemented by children classes.\n+    //\n+\n+    //\n+    // Non-pure virtual functions can be overridden by children classes or left\n+    // alone to use the default implementation from SockMan.\n+    //\n+\n+    /**\n+     * Be notified of a change in the state of listening for incoming I2P connections.\n+     * The default behavior, implemented by `SockMan`, is to ignore this event.\n+     * @param[in] addr Our listening address.\n+     * @param[in] success If true then the listen succeeded and we are now",
      "path": "src/common/sockman.h",
      "position": null,
      "original_position": 31,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "14fcef6b0d1d1fa9395f9af2bafbf3de63d14ac2",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "14fcef6b0d1d1fa9395f9af2bafbf3de63d14ac2: I find this confusing.\r\n\r\nI think the problem starts with the strange naming of `ThreadI2PAccept`, instead of `ThreadI2PHandler` akin to `ThreadSocketHandler`.\r\n\r\nAnyway, what that thread seems to do is, in a loop, try to `Listen` on the socket and once listening, `Accept(` new connections.\r\n\r\nWhenever listening fails or succeeds it calls `EventI2PListen` which then calls `AddLocal` / `RemoveLocal` to keep the announced public addresses up to date.\r\n\r\nWith that in mind, I would call this new method `EventI2PConnectivity` and rename `success` to either `connected` or `listening`. Then the rest makes sense.",
      "created_at": "2025-01-15T13:17:31Z",
      "updated_at": "2025-01-15T13:33:18Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1916636569",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1916636569"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 263,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1916699333",
      "pull_request_review_id": 2552832660,
      "id": 1916699333,
      "node_id": "PRRC_kwDOABII585yPoLF",
      "diff_hunk": "@@ -1150,7 +1151,7 @@ class CConnman : private SockMan\n     void ForEachNode(const NodeFn& func)\n     {\n         LOCK(m_nodes_mutex);\n-        for (auto&& node : m_nodes) {\n+        for (auto& [id, node] : m_nodes) {",
      "path": "src/net.h",
      "position": null,
      "original_position": 13,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "21c5e05619c8a6eb736bb1c61725f4b5f669ffb4",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "21c5e05619c8a6eb736bb1c61725f4b5f669ffb4: maybe use `[_, node]` in places where you don't need the `id`.\r\n\r\nIt's a bit unfortunate that you can't (?) directly loop over all `T` in `std::unordered_map<Key, T>`. Since most of the time we don't need `Key` (`id`) here.",
      "created_at": "2025-01-15T13:59:48Z",
      "updated_at": "2025-01-15T14:25:01Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1916699333",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1916699333"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1154,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1916714492",
      "pull_request_review_id": 2552832660,
      "id": 1916714492,
      "node_id": "PRRC_kwDOABII585yPr38",
      "diff_hunk": "@@ -133,6 +133,22 @@ class SockMan\n     // alone to use the default implementation from SockMan.\n     //\n \n+    /**\n+     * SockMan would only call EventReadyToSend() if this returns true.",
      "path": "src/common/sockman.h",
      "position": 244,
      "original_position": 5,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "dc6393cb93c4851a363b69fd474656cac1ae3b3b",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "dc6393cb93c4851a363b69fd474656cac1ae3b3b: `EventReadyToSend` doesn't exist yet in this commit, so maybe the commit message can announce it.",
      "created_at": "2025-01-15T14:10:09Z",
      "updated_at": "2025-01-15T14:25:01Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1916714492",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1916714492"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 244,
      "original_line": 244,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1916723639",
      "pull_request_review_id": 2552832660,
      "id": 1916723639,
      "node_id": "PRRC_kwDOABII585yPuG3",
      "diff_hunk": "@@ -2009,25 +2019,46 @@ bool CConnman::InactivityCheck(const CNode& node) const\n     return false;\n }\n \n+bool CConnman::ShouldTryToSend(NodeId node_id) const\n+{\n+    AssertLockNotHeld(m_nodes_mutex);\n+\n+    CNode* node{GetNodeById(node_id)};\n+    if (node == nullptr) {\n+        return false;\n+    }\n+    LOCK(node->cs_vSend);\n+    // Sending is possible if either there are bytes to send right now, or if there will be\n+    // once a potential message from vSendMsg is handed to the transport. GetBytesToSend\n+    // determines both of these in a single call.\n+    const auto& [to_send, more, _msg_type] = node->m_transport->GetBytesToSend(!node->vSendMsg.empty());\n+    return !to_send.empty() || more;\n+}\n+\n+bool CConnman::ShouldTryToRecv(NodeId node_id) const\n+{\n+    AssertLockNotHeld(m_nodes_mutex);\n+\n+    CNode* node{GetNodeById(node_id)};\n+    if (node == nullptr) {\n+        return false;\n+    }\n+    return !node->fPauseRecv;\n+}\n+\n Sock::EventsPerSock CConnman::GenerateWaitSockets(Span<CNode* const> nodes)\n {\n+    AssertLockNotHeld(m_nodes_mutex);\n+\n     Sock::EventsPerSock events_per_sock;\n \n     for (const auto& sock : m_listen) {\n         events_per_sock.emplace(sock, Sock::Events{Sock::RECV});\n     }\n \n     for (CNode* pnode : nodes) {\n-        bool select_recv = !pnode->fPauseRecv;\n-        bool select_send;\n-        {\n-            LOCK(pnode->cs_vSend);\n-            // Sending is possible if either there are bytes to send right now, or if there will be\n-            // once a potential message from vSendMsg is handed to the transport. GetBytesToSend\n-            // determines both of these in a single call.\n-            const auto& [to_send, more, _msg_type] = pnode->m_transport->GetBytesToSend(!pnode->vSendMsg.empty());\n-            select_send = !to_send.empty() || more;\n-        }\n+        const bool select_recv{ShouldTryToRecv(pnode->GetId())};",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 69,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "dc6393cb93c4851a363b69fd474656cac1ae3b3b",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "dc6393cb93c4851a363b69fd474656cac1ae3b3b: it would be good to annotate in `CConnman::SocketHandlerConnected` above `sendSet = it->second.occurred & Sock::SEND;` that `Sock::SEND` is unset when `ShouldTryToRecv` is `false`.",
      "created_at": "2025-01-15T14:16:14Z",
      "updated_at": "2025-01-15T14:25:01Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1916723639",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1916723639"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2060,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1920546152",
      "pull_request_review_id": 2559620130,
      "id": 1920546152,
      "node_id": "PRRC_kwDOABII585yeTVo",
      "diff_hunk": "@@ -0,0 +1,532 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+#include <cassert>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+static CService GetBindAddress(const Sock& sock)\n+{\n+    CService addr_bind;\n+    struct sockaddr_storage sockaddr_bind;\n+    socklen_t sockaddr_bind_len = sizeof(sockaddr_bind);\n+    if (!sock.GetSockName((struct sockaddr*)&sockaddr_bind, &sockaddr_bind_len)) {\n+        addr_bind.SetSockAddr((const struct sockaddr*)&sockaddr_bind);\n+    } else {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"getsockname failed\\n\");\n+    }\n+    return addr_bind;\n+}\n+\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& errmsg)\n+{\n+    // Create socket for listening for incoming connections\n+    struct sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {\n+        errmsg = Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()));\n+        return false;\n+    }\n+\n+    std::unique_ptr<Sock> sock{CreateSock(to.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP)};\n+    if (!sock) {\n+        errmsg = Untranslated(strprintf(\"Cannot create %s listen socket: %s\",\n+                                        to.ToStringAddrPort(),\n+                                        NetworkErrorString(WSAGetLastError())));\n+        return false;\n+    }\n+\n+    int one{1};\n+\n+    // Allow binding if the port is still in TIME_WAIT state after\n+    // the program was closed and restarted.\n+    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+        LogPrintLevel(BCLog::NET,\n+                      BCLog::Level::Info,\n+                      \"Cannot set SO_REUSEADDR on %s listen socket: %s, continuing anyway\\n\",\n+                      to.ToStringAddrPort(),\n+                      NetworkErrorString(WSAGetLastError()));\n+    }\n+\n+    // some systems don't have IPV6_V6ONLY but are always v6only; others do have the option\n+    // and enable it by default or not. Try to enable it, if possible.\n+    if (to.IsIPv6()) {\n+#ifdef IPV6_V6ONLY\n+        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_V6ONLY on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+#ifdef WIN32\n+        int prot_level{PROTECTION_LEVEL_UNRESTRICTED};\n+        if (sock->SetSockOpt(IPPROTO_IPV6,\n+                             IPV6_PROTECTION_LEVEL,\n+                             reinterpret_cast<const char*>(&prot_level),\n+                             sizeof(prot_level)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_PROTECTION_LEVEL on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+    }\n+\n+    if (sock->Bind(reinterpret_cast<sockaddr*>(&storage), len) == SOCKET_ERROR) {\n+        const int err{WSAGetLastError()};\n+        errmsg = strprintf(_(\"Cannot bind to %s: %s%s\"),\n+                           to.ToStringAddrPort(),\n+                           NetworkErrorString(err),\n+                           err == WSAEADDRINUSE\n+                               ? std::string{\" (\"} + CLIENT_NAME + \" already running?)\"\n+                               : \"\");\n+        return false;\n+    }\n+\n+    // Listen for incoming connections\n+    if (sock->Listen(SOMAXCONN) == SOCKET_ERROR) {\n+        errmsg = strprintf(_(\"Cannot listen to %s: %s\"), to.ToStringAddrPort(), NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    m_listen.emplace_back(std::move(sock));\n+\n+    return true;\n+}\n+\n+void SockMan::StartSocketsThreads(const Options& options)\n+{\n+    m_thread_socket_handler = std::thread(&util::TraceThread, \"net\", [this] { ThreadSocketHandler(); });",
      "path": "src/common/sockman.cpp",
      "position": null,
      "original_position": 113,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "bcf1254e91782a33b5a1db542f3758831e0bfe2e",
      "in_reply_to_id": null,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Does this hard-coded thread name cause any issues if sockman is used more than once?",
      "created_at": "2025-01-17T17:47:59Z",
      "updated_at": "2025-01-17T17:48:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1920546152",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1920546152"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 113,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1927267574",
      "pull_request_review_id": 2570362263,
      "id": 1927267574,
      "node_id": "PRRC_kwDOABII585y38T2",
      "diff_hunk": "@@ -0,0 +1,428 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#ifndef BITCOIN_COMMON_SOCKMAN_H\n+#define BITCOIN_COMMON_SOCKMAN_H\n+\n+#include <i2p.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <util/fs.h>\n+#include <util/sock.h>\n+#include <util/translation.h>\n+\n+#include <atomic>\n+#include <memory>\n+#include <queue>\n+#include <span>\n+#include <thread>\n+#include <variant>\n+#include <vector>\n+\n+typedef int64_t NodeId;\n+\n+/**\n+ * A socket manager class which handles socket operations.\n+ * To use this class, inherit from it and implement the pure virtual methods.\n+ * Handled operations:\n+ * - binding and listening on sockets\n+ * - starting of necessary threads to process socket operations\n+ * - accepting incoming connections\n+ * - making outbound connections\n+ * - closing connections\n+ * - waiting for IO readiness on sockets and doing send/recv accordingly\n+ */\n+class SockMan\n+{\n+public:\n+\n+    virtual ~SockMan() = default;\n+\n+    //\n+    // Non-virtual functions, to be reused by children classes.\n+    //\n+\n+    /**\n+     * Bind to a new address:port, start listening and add the listen socket to `m_listen`.\n+     * Should be called before `StartSocketsThreads()`.\n+     * @param[in] to Where to bind.\n+     * @param[out] errmsg Error string if an error occurs.\n+     * @retval true Success.\n+     * @retval false Failure, `strError` will be set.\n+     */\n+    bool BindAndStartListening(const CService& to, bilingual_str& errmsg);\n+\n+    /**\n+     * Options to influence `StartSocketsThreads()`.\n+     */\n+    struct Options {\n+        struct I2P {\n+            explicit I2P(const fs::path& file, const Proxy& proxy) : private_key_file{file}, sam_proxy{proxy} {}\n+\n+            const fs::path private_key_file;\n+            const Proxy sam_proxy;\n+        };\n+\n+        /**\n+         * I2P options. If set then a thread will be started that will accept incoming I2P connections.\n+         */\n+        std::optional<I2P> i2p;\n+    };\n+\n+    /**\n+     * Start the necessary threads for sockets IO.\n+     */\n+    void StartSocketsThreads(const Options& options);\n+\n+    /**\n+     * Join (wait for) the threads started by `StartSocketsThreads()` to exit.\n+     */\n+    void JoinSocketsThreads();\n+\n+    /**\n+     * A more readable std::tuple<std::string, uint16_t> for host and port.\n+     */\n+    struct StringHostIntPort {\n+        const std::string& host;\n+        uint16_t port;\n+    };\n+\n+    /**\n+     * Make an outbound connection, save the socket internally and return a newly generated node id.\n+     * @param[in] to The address to connect to, either as CService or a host as string and port as\n+     * an integer, if the later is used, then `proxy` must be valid.\n+     * @param[in] is_important If true, then log failures with higher severity.\n+     * @param[in] proxy Proxy to connect through if `proxy.IsValid()` is true.\n+     * @param[out] proxy_failed If `proxy` is valid and the connection failed because of the\n+     * proxy, then it will be set to true.\n+     * @param[out] me If the connection was successful then this is set to the address on the\n+     * local side of the socket.\n+     * @return Newly generated node id, or std::nullopt if the operation fails.\n+     */\n+    std::optional<NodeId> ConnectAndMakeNodeId(const std::variant<CService, StringHostIntPort>& to,\n+                                               bool is_important,\n+                                               const Proxy& proxy,\n+                                               bool& proxy_failed,\n+                                               CService& me)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex, !m_unused_i2p_sessions_mutex);\n+\n+    /**\n+     * Disconnect a given peer by closing its socket and release resources occupied by it.\n+     * @return Whether the peer existed and its socket was closed by this call.\n+     */\n+    bool CloseConnection(NodeId node_id)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Try to send some data to the given node.\n+     * @param[in] node_id Identifier of the node to send to.\n+     * @param[in] data The data to send, it might happen that only a prefix of this is sent.\n+     * @param[in] will_send_more Used as an optimization if the caller knows that they will\n+     * be sending more data soon after this call.\n+     * @param[out] errmsg If <0 is returned then this will contain a human readable message\n+     * explaining the error.\n+     * @retval >=0 The number of bytes actually sent.\n+     * @retval <0 A permanent error has occurred.\n+     */\n+    ssize_t SendBytes(NodeId node_id,\n+                      std::span<const unsigned char> data,\n+                      bool will_send_more,\n+                      std::string& errmsg) const\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Close all sockets.\n+     */\n+    void CloseSockets();\n+\n+    /**\n+     * This is signaled when network activity should cease.\n+     * A pointer to it is saved in `m_i2p_sam_session`, so make sure that\n+     * the lifetime of `interruptNet` is not shorter than\n+     * the lifetime of `m_i2p_sam_session`.\n+     */\n+    CThreadInterrupt interruptNet;\n+\n+protected:\n+\n+    /**\n+     * During some tests mocked sockets are created outside of `SockMan`, make it\n+     * possible to add those so that send/recv can be exercised.\n+     */\n+    void TestOnlyAddExistentNode(NodeId node_id, std::unique_ptr<Sock>&& sock)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+private:\n+\n+    /**\n+     * Cap on the size of `m_unused_i2p_sessions`, to ensure it does not\n+     * unexpectedly use too much memory.\n+     */\n+    static constexpr size_t MAX_UNUSED_I2P_SESSIONS_SIZE{10};\n+\n+    //\n+    // Pure virtual functions must be implemented by children classes.\n+    //\n+\n+    /**\n+     * Be notified when a new connection has been accepted.\n+     * @param[in] node_id Id of the newly accepted connection.\n+     * @param[in] me The address and port at our side of the connection.\n+     * @param[in] them The address and port at the peer's side of the connection.\n+     * @retval true The new connection was accepted at the higher level.\n+     * @retval false The connection was refused at the higher level, so the\n+     * associated socket and node_id should be discarded by `SockMan`.\n+     */\n+    virtual bool EventNewConnectionAccepted(NodeId node_id,\n+                                            const CService& me,\n+                                            const CService& them) = 0;\n+\n+    /**\n+     * Called when the socket is ready to send data and `ShouldTryToSend()` has\n+     * returned true. This is where the higher level code serializes its messages\n+     * and calls `SockMan::SendBytes()`.\n+     * @param[in] node_id Id of the node whose socket is ready to send.\n+     * @param[out] cancel_recv Should always be set upon return and if it is true,\n+     * then the next attempt to receive data from that node will be omitted.\n+     */\n+    virtual void EventReadyToSend(NodeId node_id, bool& cancel_recv) = 0;",
      "path": "src/common/sockman.h",
      "position": null,
      "original_position": 189,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "bcf1254e91782a33b5a1db542f3758831e0bfe2e",
      "in_reply_to_id": null,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I might be misunderstanding `cancel_recv`, in my HTTP server I set it to `true` when I'm planning on disconnecting a node like if there was an error sending data or if `\"Connection: close\"` is set. However this causes weird behavior where new connections get hung up forever. In particular, `interface_rpc.py` stalls on the ultimate node shutdown and eventually times out after 120 seconds of rpc `stop` not working. When I set `cancel_recv=false` everywhere, i don't have this issue. (Still a lot of other issues to clean up in this branch!)\r\n\r\nhttps://github.com/pinheadmz/bitcoin/commit/df1965a4e97ce7f3df067df9b3dcc2bbd8e6e15b",
      "created_at": "2025-01-23T16:18:36Z",
      "updated_at": "2025-01-23T16:18:36Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1927267574",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1927267574"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": 181,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 196,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1932200054",
      "pull_request_review_id": 2578302481,
      "id": 1932200054,
      "node_id": "PRRC_kwDOABII585zKwh2",
      "diff_hunk": "@@ -1737,7 +1737,10 @@ void CConnman::AcceptConnection(const ListenSocket& hListenSocket) {\n     const CService addr_bind{MaybeFlipIPv6toCJDNS(GetBindAddress(*sock))};\n \n     NetPermissionFlags permission_flags = NetPermissionFlags::None;\n-    hListenSocket.AddSocketPermissionFlags(permission_flags);\n+    auto it{m_listen_permissions.find(addr_bind)};\n+    if (it != m_listen_permissions.end()) {",
      "path": "src/net.cpp",
      "position": 402,
      "original_position": 6,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "fd81820214e695ba228a954506397c3d781fe3fe",
      "in_reply_to_id": 1916382790,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Right, currently `Bind()` always adds an entry, but I do not want to impose that because the code here does not require it. It is fine if there is nothing in `m_listen_permissions`. Then the permissions will remain at `NetPermissionFlags::None`. So it is kind of optional for `Bind()` to add an entry to `m_listen_permissions` and no reason to enforce it.",
      "created_at": "2025-01-28T13:49:17Z",
      "updated_at": "2025-01-28T13:49:18Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1932200054",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1932200054"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1680,
      "original_line": 1680,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1932221561",
      "pull_request_review_id": 2578339856,
      "id": 1932221561,
      "node_id": "PRRC_kwDOABII585zK1x5",
      "diff_hunk": "@@ -2195,7 +2169,16 @@ void CConnman::SocketHandlerListening(const Sock::EventsPerSock& events_per_sock\n         }\n         const auto it = events_per_sock.find(sock);\n         if (it != events_per_sock.end() && it->second.occurred & Sock::RECV) {\n-            AcceptConnection(*sock);\n+            CService addr_accepted;\n+\n+            auto sock_accepted{AcceptConnection(*sock, addr_accepted)};\n+\n+            if (sock_accepted) {\n+                addr_accepted = MaybeFlipIPv6toCJDNS(addr_accepted);",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 60,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "0241b04cf406d482abfac3fddfad9a9c28725f32",
      "in_reply_to_id": 1916431512,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Yes, good observation! Indeed the flip will do nothing on the invalid `0.0.0.0` `addr_accepted`.\r\n\r\nThe code in `master` is also a bit odd that it continues if `addr.SetSockAddr()` fails in `CConnman::AcceptConnection()` and it will pass the default constructed, invalid `0.0.0.0` address to `CreateNodeFromAcceptedSocket()`. I didn't change that in this PR as it would be a functional change that is not needed for this PR.",
      "created_at": "2025-01-28T14:01:14Z",
      "updated_at": "2025-01-28T14:01:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1932221561",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1932221561"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2177,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1932350726",
      "pull_request_review_id": 2578576538,
      "id": 1932350726,
      "node_id": "PRRC_kwDOABII585zLVUG",
      "diff_hunk": "@@ -59,6 +66,26 @@ class SockMan\n \n private:\n \n+    //\n+    // Pure virtual functions must be implemented by children classes.\n+    //\n+\n+    //\n+    // Non-pure virtual functions can be overridden by children classes or left\n+    // alone to use the default implementation from SockMan.\n+    //\n+\n+    /**\n+     * Be notified of a change in the state of listening for incoming I2P connections.\n+     * The default behavior, implemented by `SockMan`, is to ignore this event.\n+     * @param[in] addr Our listening address.\n+     * @param[in] success If true then the listen succeeded and we are now",
      "path": "src/common/sockman.h",
      "position": null,
      "original_position": 31,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "14fcef6b0d1d1fa9395f9af2bafbf3de63d14ac2",
      "in_reply_to_id": 1916636569,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "`ThreadI2PAccept` vs `ThreadI2PHandler`. The thing is that this thread is only accepting connections. It does not do anything about I2P connections that are already established. `ThreadSocketHandler` does both accepting new connections and doing send/recv on existent connections.\r\n\r\nYes, your observation is correct. Listening can fail temporary, e.g. if the I2P router daemon is restarted. This is unlike the TCP listening where once `bind()` and `listen()` succeed, then we are listening until we decide to close the socket. Tor is like I2P - it can fail to listen for a while if the Tor daemon is restarted. Our Tor code has the deficiency that it does not handle that, so it would act as if we are listening (e.g. advertising our Tor address) even if we are not listening.\r\n\r\nCurrent `EventI2PListen` vs `EventI2PConnectivity` - I think \"Connectivity\" would be too broad because this method is only called in the event where we start or stop listening for incoming I2P connections. It is not related to whether we have existent I2P connections or to our ability to make new outgoing I2P connections which \"Connectivity\" would imply.",
      "created_at": "2025-01-28T15:09:34Z",
      "updated_at": "2025-01-28T15:09:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1932350726",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1932350726"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 263,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1932408258",
      "pull_request_review_id": 2578675533,
      "id": 1932408258,
      "node_id": "PRRC_kwDOABII585zLjXC",
      "diff_hunk": "@@ -59,6 +66,26 @@ class SockMan\n \n private:\n \n+    //\n+    // Pure virtual functions must be implemented by children classes.\n+    //\n+\n+    //\n+    // Non-pure virtual functions can be overridden by children classes or left\n+    // alone to use the default implementation from SockMan.\n+    //\n+\n+    /**\n+     * Be notified of a change in the state of listening for incoming I2P connections.\n+     * The default behavior, implemented by `SockMan`, is to ignore this event.\n+     * @param[in] addr Our listening address.\n+     * @param[in] success If true then the listen succeeded and we are now",
      "path": "src/common/sockman.h",
      "position": null,
      "original_position": 31,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "14fcef6b0d1d1fa9395f9af2bafbf3de63d14ac2",
      "in_reply_to_id": 1916636569,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Maybe `EventI2PReady` or `EventI2PStatus`? Something to distinguish it from listen.",
      "created_at": "2025-01-28T15:41:46Z",
      "updated_at": "2025-01-28T15:41:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1932408258",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1932408258"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 263,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1932474919",
      "pull_request_review_id": 2578787874,
      "id": 1932474919,
      "node_id": "PRRC_kwDOABII585zLzon",
      "diff_hunk": "@@ -1150,7 +1151,7 @@ class CConnman : private SockMan\n     void ForEachNode(const NodeFn& func)\n     {\n         LOCK(m_nodes_mutex);\n-        for (auto&& node : m_nodes) {\n+        for (auto& [id, node] : m_nodes) {",
      "path": "src/net.h",
      "position": null,
      "original_position": 13,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "21c5e05619c8a6eb736bb1c61725f4b5f669ffb4",
      "in_reply_to_id": 1916699333,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Changed to `[_, node]`, thanks! :)",
      "created_at": "2025-01-28T16:19:53Z",
      "updated_at": "2025-01-28T16:19:54Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1932474919",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1932474919"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1154,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1932501557",
      "pull_request_review_id": 2578830820,
      "id": 1932501557,
      "node_id": "PRRC_kwDOABII585zL6I1",
      "diff_hunk": "@@ -133,6 +133,22 @@ class SockMan\n     // alone to use the default implementation from SockMan.\n     //\n \n+    /**\n+     * SockMan would only call EventReadyToSend() if this returns true.",
      "path": "src/common/sockman.h",
      "position": 244,
      "original_position": 5,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "dc6393cb93c4851a363b69fd474656cac1ae3b3b",
      "in_reply_to_id": 1916714492,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Right! Adjusted the comments.",
      "created_at": "2025-01-28T16:33:39Z",
      "updated_at": "2025-01-28T16:33:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1932501557",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1932501557"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 244,
      "original_line": 244,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1932523735",
      "pull_request_review_id": 2578867201,
      "id": 1932523735,
      "node_id": "PRRC_kwDOABII585zL_jX",
      "diff_hunk": "@@ -2009,25 +2019,46 @@ bool CConnman::InactivityCheck(const CNode& node) const\n     return false;\n }\n \n+bool CConnman::ShouldTryToSend(NodeId node_id) const\n+{\n+    AssertLockNotHeld(m_nodes_mutex);\n+\n+    CNode* node{GetNodeById(node_id)};\n+    if (node == nullptr) {\n+        return false;\n+    }\n+    LOCK(node->cs_vSend);\n+    // Sending is possible if either there are bytes to send right now, or if there will be\n+    // once a potential message from vSendMsg is handed to the transport. GetBytesToSend\n+    // determines both of these in a single call.\n+    const auto& [to_send, more, _msg_type] = node->m_transport->GetBytesToSend(!node->vSendMsg.empty());\n+    return !to_send.empty() || more;\n+}\n+\n+bool CConnman::ShouldTryToRecv(NodeId node_id) const\n+{\n+    AssertLockNotHeld(m_nodes_mutex);\n+\n+    CNode* node{GetNodeById(node_id)};\n+    if (node == nullptr) {\n+        return false;\n+    }\n+    return !node->fPauseRecv;\n+}\n+\n Sock::EventsPerSock CConnman::GenerateWaitSockets(Span<CNode* const> nodes)\n {\n+    AssertLockNotHeld(m_nodes_mutex);\n+\n     Sock::EventsPerSock events_per_sock;\n \n     for (const auto& sock : m_listen) {\n         events_per_sock.emplace(sock, Sock::Events{Sock::RECV});\n     }\n \n     for (CNode* pnode : nodes) {\n-        bool select_recv = !pnode->fPauseRecv;\n-        bool select_send;\n-        {\n-            LOCK(pnode->cs_vSend);\n-            // Sending is possible if either there are bytes to send right now, or if there will be\n-            // once a potential message from vSendMsg is handed to the transport. GetBytesToSend\n-            // determines both of these in a single call.\n-            const auto& [to_send, more, _msg_type] = pnode->m_transport->GetBytesToSend(!pnode->vSendMsg.empty());\n-            select_send = !to_send.empty() || more;\n-        }\n+        const bool select_recv{ShouldTryToRecv(pnode->GetId())};",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 69,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "dc6393cb93c4851a363b69fd474656cac1ae3b3b",
      "in_reply_to_id": 1916723639,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Hmm, you probably mean `ShouldTryToSend` is `false`, right? And then the same applies to receiving. Amended this:\r\n\r\n```diff\r\n-                recvSet = it->second.occurred & Sock::RECV;\r\n-                sendSet = it->second.occurred & Sock::SEND;\r\n+                recvSet = it->second.occurred & Sock::RECV; // Sock::RECV could only be set if ShouldTryToRecv() has returned true in GenerateWaitSockets().\r\n+                sendSet = it->second.occurred & Sock::SEND; // Sock::SEND could only be set if ShouldTryToSend() has returned true in GenerateWaitSockets().\r\n```",
      "created_at": "2025-01-28T16:47:52Z",
      "updated_at": "2025-01-28T16:47:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1932523735",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1932523735"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2060,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1932564964",
      "pull_request_review_id": 2578936007,
      "id": 1932564964,
      "node_id": "PRRC_kwDOABII585zMJnk",
      "diff_hunk": "@@ -0,0 +1,532 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+#include <cassert>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+static CService GetBindAddress(const Sock& sock)\n+{\n+    CService addr_bind;\n+    struct sockaddr_storage sockaddr_bind;\n+    socklen_t sockaddr_bind_len = sizeof(sockaddr_bind);\n+    if (!sock.GetSockName((struct sockaddr*)&sockaddr_bind, &sockaddr_bind_len)) {\n+        addr_bind.SetSockAddr((const struct sockaddr*)&sockaddr_bind);\n+    } else {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"getsockname failed\\n\");\n+    }\n+    return addr_bind;\n+}\n+\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& errmsg)\n+{\n+    // Create socket for listening for incoming connections\n+    struct sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {\n+        errmsg = Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()));\n+        return false;\n+    }\n+\n+    std::unique_ptr<Sock> sock{CreateSock(to.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP)};\n+    if (!sock) {\n+        errmsg = Untranslated(strprintf(\"Cannot create %s listen socket: %s\",\n+                                        to.ToStringAddrPort(),\n+                                        NetworkErrorString(WSAGetLastError())));\n+        return false;\n+    }\n+\n+    int one{1};\n+\n+    // Allow binding if the port is still in TIME_WAIT state after\n+    // the program was closed and restarted.\n+    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+        LogPrintLevel(BCLog::NET,\n+                      BCLog::Level::Info,\n+                      \"Cannot set SO_REUSEADDR on %s listen socket: %s, continuing anyway\\n\",\n+                      to.ToStringAddrPort(),\n+                      NetworkErrorString(WSAGetLastError()));\n+    }\n+\n+    // some systems don't have IPV6_V6ONLY but are always v6only; others do have the option\n+    // and enable it by default or not. Try to enable it, if possible.\n+    if (to.IsIPv6()) {\n+#ifdef IPV6_V6ONLY\n+        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_V6ONLY on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+#ifdef WIN32\n+        int prot_level{PROTECTION_LEVEL_UNRESTRICTED};\n+        if (sock->SetSockOpt(IPPROTO_IPV6,\n+                             IPV6_PROTECTION_LEVEL,\n+                             reinterpret_cast<const char*>(&prot_level),\n+                             sizeof(prot_level)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_PROTECTION_LEVEL on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+    }\n+\n+    if (sock->Bind(reinterpret_cast<sockaddr*>(&storage), len) == SOCKET_ERROR) {\n+        const int err{WSAGetLastError()};\n+        errmsg = strprintf(_(\"Cannot bind to %s: %s%s\"),\n+                           to.ToStringAddrPort(),\n+                           NetworkErrorString(err),\n+                           err == WSAEADDRINUSE\n+                               ? std::string{\" (\"} + CLIENT_NAME + \" already running?)\"\n+                               : \"\");\n+        return false;\n+    }\n+\n+    // Listen for incoming connections\n+    if (sock->Listen(SOMAXCONN) == SOCKET_ERROR) {\n+        errmsg = strprintf(_(\"Cannot listen to %s: %s\"), to.ToStringAddrPort(), NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    m_listen.emplace_back(std::move(sock));\n+\n+    return true;\n+}\n+\n+void SockMan::StartSocketsThreads(const Options& options)\n+{\n+    m_thread_socket_handler = std::thread(&util::TraceThread, \"net\", [this] { ThreadSocketHandler(); });",
      "path": "src/common/sockman.cpp",
      "position": null,
      "original_position": 113,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "bcf1254e91782a33b5a1db542f3758831e0bfe2e",
      "in_reply_to_id": 1920546152,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Yes, it would mess up the logging. I put both `\"net\"` and `\"i2paccept\"` in `SockMan::Options`, so that they are not hardcoded here anymore and can be set by the callers of `SockMan`.",
      "created_at": "2025-01-28T17:15:25Z",
      "updated_at": "2025-01-28T17:15:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1932564964",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1932564964"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 113,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1932753931",
      "pull_request_review_id": 2579242754,
      "id": 1932753931,
      "node_id": "PRRC_kwDOABII585zM3wL",
      "diff_hunk": "@@ -0,0 +1,428 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#ifndef BITCOIN_COMMON_SOCKMAN_H\n+#define BITCOIN_COMMON_SOCKMAN_H\n+\n+#include <i2p.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <util/fs.h>\n+#include <util/sock.h>\n+#include <util/translation.h>\n+\n+#include <atomic>\n+#include <memory>\n+#include <queue>\n+#include <span>\n+#include <thread>\n+#include <variant>\n+#include <vector>\n+\n+typedef int64_t NodeId;\n+\n+/**\n+ * A socket manager class which handles socket operations.\n+ * To use this class, inherit from it and implement the pure virtual methods.\n+ * Handled operations:\n+ * - binding and listening on sockets\n+ * - starting of necessary threads to process socket operations\n+ * - accepting incoming connections\n+ * - making outbound connections\n+ * - closing connections\n+ * - waiting for IO readiness on sockets and doing send/recv accordingly\n+ */\n+class SockMan\n+{\n+public:\n+\n+    virtual ~SockMan() = default;\n+\n+    //\n+    // Non-virtual functions, to be reused by children classes.\n+    //\n+\n+    /**\n+     * Bind to a new address:port, start listening and add the listen socket to `m_listen`.\n+     * Should be called before `StartSocketsThreads()`.\n+     * @param[in] to Where to bind.\n+     * @param[out] errmsg Error string if an error occurs.\n+     * @retval true Success.\n+     * @retval false Failure, `strError` will be set.\n+     */\n+    bool BindAndStartListening(const CService& to, bilingual_str& errmsg);\n+\n+    /**\n+     * Options to influence `StartSocketsThreads()`.\n+     */\n+    struct Options {\n+        struct I2P {\n+            explicit I2P(const fs::path& file, const Proxy& proxy) : private_key_file{file}, sam_proxy{proxy} {}\n+\n+            const fs::path private_key_file;\n+            const Proxy sam_proxy;\n+        };\n+\n+        /**\n+         * I2P options. If set then a thread will be started that will accept incoming I2P connections.\n+         */\n+        std::optional<I2P> i2p;\n+    };\n+\n+    /**\n+     * Start the necessary threads for sockets IO.\n+     */\n+    void StartSocketsThreads(const Options& options);\n+\n+    /**\n+     * Join (wait for) the threads started by `StartSocketsThreads()` to exit.\n+     */\n+    void JoinSocketsThreads();\n+\n+    /**\n+     * A more readable std::tuple<std::string, uint16_t> for host and port.\n+     */\n+    struct StringHostIntPort {\n+        const std::string& host;\n+        uint16_t port;\n+    };\n+\n+    /**\n+     * Make an outbound connection, save the socket internally and return a newly generated node id.\n+     * @param[in] to The address to connect to, either as CService or a host as string and port as\n+     * an integer, if the later is used, then `proxy` must be valid.\n+     * @param[in] is_important If true, then log failures with higher severity.\n+     * @param[in] proxy Proxy to connect through if `proxy.IsValid()` is true.\n+     * @param[out] proxy_failed If `proxy` is valid and the connection failed because of the\n+     * proxy, then it will be set to true.\n+     * @param[out] me If the connection was successful then this is set to the address on the\n+     * local side of the socket.\n+     * @return Newly generated node id, or std::nullopt if the operation fails.\n+     */\n+    std::optional<NodeId> ConnectAndMakeNodeId(const std::variant<CService, StringHostIntPort>& to,\n+                                               bool is_important,\n+                                               const Proxy& proxy,\n+                                               bool& proxy_failed,\n+                                               CService& me)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex, !m_unused_i2p_sessions_mutex);\n+\n+    /**\n+     * Disconnect a given peer by closing its socket and release resources occupied by it.\n+     * @return Whether the peer existed and its socket was closed by this call.\n+     */\n+    bool CloseConnection(NodeId node_id)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Try to send some data to the given node.\n+     * @param[in] node_id Identifier of the node to send to.\n+     * @param[in] data The data to send, it might happen that only a prefix of this is sent.\n+     * @param[in] will_send_more Used as an optimization if the caller knows that they will\n+     * be sending more data soon after this call.\n+     * @param[out] errmsg If <0 is returned then this will contain a human readable message\n+     * explaining the error.\n+     * @retval >=0 The number of bytes actually sent.\n+     * @retval <0 A permanent error has occurred.\n+     */\n+    ssize_t SendBytes(NodeId node_id,\n+                      std::span<const unsigned char> data,\n+                      bool will_send_more,\n+                      std::string& errmsg) const\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Close all sockets.\n+     */\n+    void CloseSockets();\n+\n+    /**\n+     * This is signaled when network activity should cease.\n+     * A pointer to it is saved in `m_i2p_sam_session`, so make sure that\n+     * the lifetime of `interruptNet` is not shorter than\n+     * the lifetime of `m_i2p_sam_session`.\n+     */\n+    CThreadInterrupt interruptNet;\n+\n+protected:\n+\n+    /**\n+     * During some tests mocked sockets are created outside of `SockMan`, make it\n+     * possible to add those so that send/recv can be exercised.\n+     */\n+    void TestOnlyAddExistentNode(NodeId node_id, std::unique_ptr<Sock>&& sock)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+private:\n+\n+    /**\n+     * Cap on the size of `m_unused_i2p_sessions`, to ensure it does not\n+     * unexpectedly use too much memory.\n+     */\n+    static constexpr size_t MAX_UNUSED_I2P_SESSIONS_SIZE{10};\n+\n+    //\n+    // Pure virtual functions must be implemented by children classes.\n+    //\n+\n+    /**\n+     * Be notified when a new connection has been accepted.\n+     * @param[in] node_id Id of the newly accepted connection.\n+     * @param[in] me The address and port at our side of the connection.\n+     * @param[in] them The address and port at the peer's side of the connection.\n+     * @retval true The new connection was accepted at the higher level.\n+     * @retval false The connection was refused at the higher level, so the\n+     * associated socket and node_id should be discarded by `SockMan`.\n+     */\n+    virtual bool EventNewConnectionAccepted(NodeId node_id,\n+                                            const CService& me,\n+                                            const CService& them) = 0;\n+\n+    /**\n+     * Called when the socket is ready to send data and `ShouldTryToSend()` has\n+     * returned true. This is where the higher level code serializes its messages\n+     * and calls `SockMan::SendBytes()`.\n+     * @param[in] node_id Id of the node whose socket is ready to send.\n+     * @param[out] cancel_recv Should always be set upon return and if it is true,\n+     * then the next attempt to receive data from that node will be omitted.\n+     */\n+    virtual void EventReadyToSend(NodeId node_id, bool& cancel_recv) = 0;",
      "path": "src/common/sockman.h",
      "position": null,
      "original_position": 189,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "bcf1254e91782a33b5a1db542f3758831e0bfe2e",
      "in_reply_to_id": 1927267574,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> `@param[out] cancel_recv Should always be set upon return`\r\n\r\nI think the problem was that `HTTPServer::EventReadyToSend()` could end up not setting `cancel_recv` in which case it remains uninitialized, containing a \"random\" value from the stack at the caller (which was probably `true`, so it canceled all receives from the client, never receiving anything causing an infinite loop):\r\n\r\n```cpp\r\n              bool cancel_recv;\r\n  \r\n              EventReadyToSend(node_id, cancel_recv);\r\n  \r\n              if (cancel_recv) {\r\n                  recv_ready = false;\r\n              }\r\n```\r\n\r\nValgrind or memory sanitizer should complain about this code reading uninitialized value in `if (cancel_recv)`.\r\n\r\nThe below fixes it, remove the last commit from your branch and move the setting of `cancel_recv` from the bottom to the top of the method. So that `cancel_recv` is set in all code paths inside `HTTPServer::EventReadyToSend()`.\r\n\r\n```diff\r\n--- i/src/httpserver.cpp\r\n+++ w/src/httpserver.cpp\r\n@@ -1123,12 +1123,15 @@ bool HTTPServer::EventNewConnectionAccepted(NodeId node_id,\r\n     m_connected_clients.emplace(client->m_node_id, std::move(client));\r\n     return true;\r\n }\r\n \r\n void HTTPServer::EventReadyToSend(NodeId node_id, bool& cancel_recv)\r\n {\r\n+    // Next attempt to receive data from this node is permitted\r\n+    cancel_recv = false;\r\n+\r\n     // Get the HTTPClient\r\n     auto client{WITH_LOCK(m_clients_mutex, return GetClientById(node_id);)};\r\n     if (client == nullptr) {\r\n         return;\r\n     }\r\n \r\n@@ -1149,26 +1152,26 @@ void HTTPServer::EventReadyToSend(NodeId node_id, bool& cancel_recv)\r\n             LogDebug(\r\n                 BCLog::HTTP,\r\n                 \"Error sending HTTP response headers to client %s (id=%lld): %s\\n\",\r\n                 client->m_origin,\r\n                 client->m_node_id,\r\n                 err);\r\n-            cancel_recv = false;\r\n+            cancel_recv = true;\r\n             client->m_disconnect = true;\r\n             return;\r\n         }\r\n \r\n         ssize_t body_bytes_sent = SendBytes(node_id, MakeUCharSpan(res.m_body), /*will_send_more=*/true, err);\r\n         if (body_bytes_sent < 0) {\r\n             LogDebug(\r\n                 BCLog::HTTP,\r\n                 \"Error sending HTTP response body to client %s (id=%lld): %s\\n\",\r\n                 client->m_origin,\r\n                 client->m_node_id,\r\n                 err);\r\n-            cancel_recv = false;\r\n+            cancel_recv = true;\r\n             client->m_disconnect = true;\r\n             return;\r\n         }\r\n \r\n         LogDebug(\r\n             BCLog::HTTP,\r\n@@ -1176,20 +1179,17 @@ void HTTPServer::EventReadyToSend(NodeId node_id, bool& cancel_recv)\r\n             hdr_bytes_sent + body_bytes_sent,\r\n             client->m_origin,\r\n             client->m_node_id);\r\n \r\n         // Our work is done here\r\n         if (!res.m_keep_alive) {\r\n-            cancel_recv = false;\r\n+            cancel_recv = true;\r\n             client->m_disconnect = true;\r\n             return;\r\n         }\r\n     }\r\n-\r\n-    // Next attempt to receive data from this node is permitted\r\n-    cancel_recv = false;\r\n }\r\n \r\n void HTTPServer::EventGotData(NodeId node_id, const uint8_t* data, size_t n)\r\n {\r\n     // Get the HTTPClient\r\n     auto client{WITH_LOCK(m_clients_mutex, return GetClientById(node_id);)};\r\n```",
      "created_at": "2025-01-28T19:36:29Z",
      "updated_at": "2025-01-28T19:36:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1932753931",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1932753931"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": 181,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 196,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1932812651",
      "pull_request_review_id": 2579341743,
      "id": 1932812651,
      "node_id": "PRRC_kwDOABII585zNGFr",
      "diff_hunk": "@@ -0,0 +1,428 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#ifndef BITCOIN_COMMON_SOCKMAN_H\n+#define BITCOIN_COMMON_SOCKMAN_H\n+\n+#include <i2p.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <util/fs.h>\n+#include <util/sock.h>\n+#include <util/translation.h>\n+\n+#include <atomic>\n+#include <memory>\n+#include <queue>\n+#include <span>\n+#include <thread>\n+#include <variant>\n+#include <vector>\n+\n+typedef int64_t NodeId;\n+\n+/**\n+ * A socket manager class which handles socket operations.\n+ * To use this class, inherit from it and implement the pure virtual methods.\n+ * Handled operations:\n+ * - binding and listening on sockets\n+ * - starting of necessary threads to process socket operations\n+ * - accepting incoming connections\n+ * - making outbound connections\n+ * - closing connections\n+ * - waiting for IO readiness on sockets and doing send/recv accordingly\n+ */\n+class SockMan\n+{\n+public:\n+\n+    virtual ~SockMan() = default;\n+\n+    //\n+    // Non-virtual functions, to be reused by children classes.\n+    //\n+\n+    /**\n+     * Bind to a new address:port, start listening and add the listen socket to `m_listen`.\n+     * Should be called before `StartSocketsThreads()`.\n+     * @param[in] to Where to bind.\n+     * @param[out] errmsg Error string if an error occurs.\n+     * @retval true Success.\n+     * @retval false Failure, `strError` will be set.\n+     */\n+    bool BindAndStartListening(const CService& to, bilingual_str& errmsg);\n+\n+    /**\n+     * Options to influence `StartSocketsThreads()`.\n+     */\n+    struct Options {\n+        struct I2P {\n+            explicit I2P(const fs::path& file, const Proxy& proxy) : private_key_file{file}, sam_proxy{proxy} {}\n+\n+            const fs::path private_key_file;\n+            const Proxy sam_proxy;\n+        };\n+\n+        /**\n+         * I2P options. If set then a thread will be started that will accept incoming I2P connections.\n+         */\n+        std::optional<I2P> i2p;\n+    };\n+\n+    /**\n+     * Start the necessary threads for sockets IO.\n+     */\n+    void StartSocketsThreads(const Options& options);\n+\n+    /**\n+     * Join (wait for) the threads started by `StartSocketsThreads()` to exit.\n+     */\n+    void JoinSocketsThreads();\n+\n+    /**\n+     * A more readable std::tuple<std::string, uint16_t> for host and port.\n+     */\n+    struct StringHostIntPort {\n+        const std::string& host;\n+        uint16_t port;\n+    };\n+\n+    /**\n+     * Make an outbound connection, save the socket internally and return a newly generated node id.\n+     * @param[in] to The address to connect to, either as CService or a host as string and port as\n+     * an integer, if the later is used, then `proxy` must be valid.\n+     * @param[in] is_important If true, then log failures with higher severity.\n+     * @param[in] proxy Proxy to connect through if `proxy.IsValid()` is true.\n+     * @param[out] proxy_failed If `proxy` is valid and the connection failed because of the\n+     * proxy, then it will be set to true.\n+     * @param[out] me If the connection was successful then this is set to the address on the\n+     * local side of the socket.\n+     * @return Newly generated node id, or std::nullopt if the operation fails.\n+     */\n+    std::optional<NodeId> ConnectAndMakeNodeId(const std::variant<CService, StringHostIntPort>& to,\n+                                               bool is_important,\n+                                               const Proxy& proxy,\n+                                               bool& proxy_failed,\n+                                               CService& me)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex, !m_unused_i2p_sessions_mutex);\n+\n+    /**\n+     * Disconnect a given peer by closing its socket and release resources occupied by it.\n+     * @return Whether the peer existed and its socket was closed by this call.\n+     */\n+    bool CloseConnection(NodeId node_id)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Try to send some data to the given node.\n+     * @param[in] node_id Identifier of the node to send to.\n+     * @param[in] data The data to send, it might happen that only a prefix of this is sent.\n+     * @param[in] will_send_more Used as an optimization if the caller knows that they will\n+     * be sending more data soon after this call.\n+     * @param[out] errmsg If <0 is returned then this will contain a human readable message\n+     * explaining the error.\n+     * @retval >=0 The number of bytes actually sent.\n+     * @retval <0 A permanent error has occurred.\n+     */\n+    ssize_t SendBytes(NodeId node_id,\n+                      std::span<const unsigned char> data,\n+                      bool will_send_more,\n+                      std::string& errmsg) const\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Close all sockets.\n+     */\n+    void CloseSockets();\n+\n+    /**\n+     * This is signaled when network activity should cease.\n+     * A pointer to it is saved in `m_i2p_sam_session`, so make sure that\n+     * the lifetime of `interruptNet` is not shorter than\n+     * the lifetime of `m_i2p_sam_session`.\n+     */\n+    CThreadInterrupt interruptNet;\n+\n+protected:\n+\n+    /**\n+     * During some tests mocked sockets are created outside of `SockMan`, make it\n+     * possible to add those so that send/recv can be exercised.\n+     */\n+    void TestOnlyAddExistentNode(NodeId node_id, std::unique_ptr<Sock>&& sock)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+private:\n+\n+    /**\n+     * Cap on the size of `m_unused_i2p_sessions`, to ensure it does not\n+     * unexpectedly use too much memory.\n+     */\n+    static constexpr size_t MAX_UNUSED_I2P_SESSIONS_SIZE{10};\n+\n+    //\n+    // Pure virtual functions must be implemented by children classes.\n+    //\n+\n+    /**\n+     * Be notified when a new connection has been accepted.\n+     * @param[in] node_id Id of the newly accepted connection.\n+     * @param[in] me The address and port at our side of the connection.\n+     * @param[in] them The address and port at the peer's side of the connection.\n+     * @retval true The new connection was accepted at the higher level.\n+     * @retval false The connection was refused at the higher level, so the\n+     * associated socket and node_id should be discarded by `SockMan`.\n+     */\n+    virtual bool EventNewConnectionAccepted(NodeId node_id,\n+                                            const CService& me,\n+                                            const CService& them) = 0;\n+\n+    /**\n+     * Called when the socket is ready to send data and `ShouldTryToSend()` has\n+     * returned true. This is where the higher level code serializes its messages\n+     * and calls `SockMan::SendBytes()`.\n+     * @param[in] node_id Id of the node whose socket is ready to send.\n+     * @param[out] cancel_recv Should always be set upon return and if it is true,\n+     * then the next attempt to receive data from that node will be omitted.\n+     */\n+    virtual void EventReadyToSend(NodeId node_id, bool& cancel_recv) = 0;",
      "path": "src/common/sockman.h",
      "position": null,
      "original_position": 189,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "bcf1254e91782a33b5a1db542f3758831e0bfe2e",
      "in_reply_to_id": 1927267574,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "awesome thank you",
      "created_at": "2025-01-28T20:23:58Z",
      "updated_at": "2025-01-28T20:23:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1932812651",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1932812651"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": 181,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 196,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1934587454",
      "pull_request_review_id": 2582270517,
      "id": 1934587454,
      "node_id": "PRRC_kwDOABII585zT3Y-",
      "diff_hunk": "@@ -0,0 +1,435 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#ifndef BITCOIN_COMMON_SOCKMAN_H\n+#define BITCOIN_COMMON_SOCKMAN_H\n+\n+#include <i2p.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <util/fs.h>\n+#include <util/sock.h>\n+#include <util/translation.h>\n+\n+#include <atomic>\n+#include <memory>\n+#include <queue>\n+#include <span>\n+#include <thread>\n+#include <variant>\n+#include <vector>\n+\n+typedef int64_t NodeId;\n+\n+/**\n+ * A socket manager class which handles socket operations.\n+ * To use this class, inherit from it and implement the pure virtual methods.\n+ * Handled operations:\n+ * - binding and listening on sockets\n+ * - starting of necessary threads to process socket operations\n+ * - accepting incoming connections\n+ * - making outbound connections\n+ * - closing connections\n+ * - waiting for IO readiness on sockets and doing send/recv accordingly\n+ */\n+class SockMan\n+{\n+public:\n+\n+    virtual ~SockMan() = default;\n+\n+    //\n+    // Non-virtual functions, to be reused by children classes.\n+    //\n+\n+    /**\n+     * Bind to a new address:port, start listening and add the listen socket to `m_listen`.\n+     * Should be called before `StartSocketsThreads()`.\n+     * @param[in] to Where to bind.\n+     * @param[out] errmsg Error string if an error occurs.\n+     * @retval true Success.\n+     * @retval false Failure, `strError` will be set.\n+     */\n+    bool BindAndStartListening(const CService& to, bilingual_str& errmsg);",
      "path": "src/common/sockman.h",
      "position": null,
      "original_position": 54,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "266ac3267390270e6794d478aa1fbe40e88ffb0f",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "`strError` only appears in the comment, and \"error message\" should probably be snake_case:\r\n```suggestion\r\n     * @param[out] err_msg Error string if an error occurs.\r\n     * @retval true Success.\r\n     * @retval false Failure, `err_msg` will be set.\r\n     */\r\n    bool BindAndStartListening(const CService& to, bilingual_str& err_msg);\r\n```",
      "created_at": "2025-01-29T21:01:53Z",
      "updated_at": "2025-02-01T20:37:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1934587454",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1934587454"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": 50,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 54,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1934686592",
      "pull_request_review_id": 2582270517,
      "id": 1934686592,
      "node_id": "PRRC_kwDOABII585zUPmA",
      "diff_hunk": "@@ -3440,19 +3199,19 @@ void CConnman::StopNodes()\n     }\n \n     // Delete peer connections.\n-    std::vector<CNode*> nodes;\n+    decltype(m_nodes) nodes;\n     WITH_LOCK(m_nodes_mutex, nodes.swap(m_nodes));\n-    for (CNode* pnode : nodes) {\n-        LogDebug(BCLog::NET, \"%s\\n\", pnode->DisconnectMsg(fLogIPs));\n-        pnode->CloseSocketDisconnect();\n+    for (auto& [_, pnode] : nodes) {\n+        MarkAsDisconnectAndCloseConnection(*pnode);\n         DeleteNode(pnode);\n     }\n \n     for (CNode* pnode : m_nodes_disconnected) {\n         DeleteNode(pnode);\n     }\n     m_nodes_disconnected.clear();\n-    vhListenSocket.clear();\n+    m_listen_permissions.clear();",
      "path": "src/net.cpp",
      "position": 1239,
      "original_position": 1219,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "266ac3267390270e6794d478aa1fbe40e88ffb0f",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Do we ever want to remove individual entries from `m_listen_permissions` upon disconnect of single peers, long before `.clear()`?\r\n\r\nSame goes for `m_listen`. I'm not claiming `vhListenSocket` was any better before this PR.",
      "created_at": "2025-01-29T21:39:34Z",
      "updated_at": "2025-02-01T20:37:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1934686592",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1934686592"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 3244,
      "original_line": 3244,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1934690968",
      "pull_request_review_id": 2582270517,
      "id": 1934690968,
      "node_id": "PRRC_kwDOABII585zUQqY",
      "diff_hunk": "@@ -3212,13 +2972,18 @@ bool CConnman::Bind(const CService& addr_, unsigned int flags, NetPermissionFlag\n     const CService addr{MaybeFlipIPv6toCJDNS(addr_)};\n \n     bilingual_str strError;\n-    if (!BindListenPort(addr, strError, permissions)) {\n+    if (!BindAndStartListening(addr, strError)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"%s\\n\", strError.original);\n         if ((flags & BF_REPORT_ERROR) && m_client_interface) {\n             m_client_interface->ThreadSafeMessageBox(strError, \"\", CClientUIInterface::MSG_ERROR);\n         }\n         return false;\n     }\n \n+    LogPrintLevel(BCLog::NET, BCLog::Level::Info, \"Bound to and listening on %s\\n\", addr.ToStringAddrPort());\n+\n+    m_listen_permissions.emplace(addr, permissions);",
      "path": "src/net.cpp",
      "position": 1149,
      "original_position": 1129,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "266ac3267390270e6794d478aa1fbe40e88ffb0f",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Seems like `.emplace()` will [not replace existing entries](https://en.cppreference.com/w/cpp/container/unordered_map/emplace). In the off chance that someone takes a peer offline and then restarts it with other permissions, would it not be better to do this?\r\n```suggestion\r\n    m_listen_permissions[addr] = permissions;\r\n```",
      "created_at": "2025-01-29T21:42:23Z",
      "updated_at": "2025-02-01T20:37:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1934690968",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1934690968"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 3015,
      "original_line": 3015,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1934710097",
      "pull_request_review_id": 2582270517,
      "id": 1934710097,
      "node_id": "PRRC_kwDOABII585zUVVR",
      "diff_hunk": "@@ -1704,115 +1647,81 @@ bool CConnman::AttemptToEvictConnection()\n         return false;\n     }\n     LOCK(m_nodes_mutex);\n-    for (CNode* pnode : m_nodes) {\n-        if (pnode->GetId() == *node_id_to_evict) {\n-            LogDebug(BCLog::NET, \"selected %s connection for eviction peer=%d; disconnecting\\n\", pnode->ConnectionTypeAsString(), pnode->GetId());\n-            pnode->fDisconnect = true;\n-            return true;\n-        }\n+    auto it{m_nodes.find(*node_id_to_evict)};\n+    if (it != m_nodes.end()) {\n+        auto id{it->first};\n+        auto node{it->second};\n+        LogDebug(BCLog::NET, \"selected %s connection for eviction peer=%d; disconnecting\\n\", node->ConnectionTypeAsString(), id);\n+        node->fDisconnect = true;\n+        return true;\n     }\n     return false;\n }\n \n-void CConnman::AcceptConnection(const ListenSocket& hListenSocket) {\n-    struct sockaddr_storage sockaddr;\n-    socklen_t len = sizeof(sockaddr);\n-    auto sock = hListenSocket.sock->Accept((struct sockaddr*)&sockaddr, &len);\n-    CAddress addr;\n-\n-    if (!sock) {\n-        const int nErr = WSAGetLastError();\n-        if (nErr != WSAEWOULDBLOCK) {\n-            LogPrintf(\"socket error accept failed: %s\\n\", NetworkErrorString(nErr));\n-        }\n-        return;\n-    }\n-\n-    if (!addr.SetSockAddr((const struct sockaddr*)&sockaddr)) {\n-        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"Unknown socket family\\n\");\n-    } else {\n-        addr = CAddress{MaybeFlipIPv6toCJDNS(addr), NODE_NONE};\n-    }\n+bool CConnman::EventNewConnectionAccepted(NodeId node_id,\n+                                          const CService& addr_bind_,\n+                                          const CService& addr_)\n+{\n+    const CService addr_bind{MaybeFlipIPv6toCJDNS(addr_bind_)};\n+    const CService addr{MaybeFlipIPv6toCJDNS(addr_)};\n \n-    const CAddress addr_bind{MaybeFlipIPv6toCJDNS(GetBindAddress(*sock)), NODE_NONE};\n+    int nInbound = 0;\n \n     NetPermissionFlags permission_flags = NetPermissionFlags::None;\n-    hListenSocket.AddSocketPermissionFlags(permission_flags);\n-\n-    CreateNodeFromAcceptedSocket(std::move(sock), permission_flags, addr_bind, addr);\n-}\n-\n-void CConnman::CreateNodeFromAcceptedSocket(std::unique_ptr<Sock>&& sock,\n-                                            NetPermissionFlags permission_flags,\n-                                            const CAddress& addr_bind,\n-                                            const CAddress& addr)\n-{\n-    int nInbound = 0;\n+    auto it{m_listen_permissions.find(addr_bind)};\n+    if (it != m_listen_permissions.end()) {\n+        NetPermissions::AddFlag(permission_flags, it->second);\n+    }",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 388,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "266ac3267390270e6794d478aa1fbe40e88ffb0f",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In fd81820214e695ba228a954506397c3d781fe3fe:\r\nnit: Possible less mutating simplification (assumes `NetPermissionFlags::None == 0`):\r\n```diff\r\n-     NetPermissionFlags permission_flags = NetPermissionFlags::None;\r\n-     auto it{m_listen_permissions.find(addr_bind)};\r\n-     if (it != m_listen_permissions.end()) {\r\n-         NetPermissions::AddFlag(permission_flags, it->second);\r\n-     }\r\n+     auto it{m_listen_permissions.find(addr_bind)};\r\n+     NetPermissionFlags permission_flags = it != m_listen_permissions.end() ?\r\n+         it->second : NetPermissionFlags::None;\r\n```",
      "created_at": "2025-01-29T21:57:39Z",
      "updated_at": "2025-02-01T20:37:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1934710097",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1934710097"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": 1670,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1682,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1934722181",
      "pull_request_review_id": 2582270517,
      "id": 1934722181,
      "node_id": "PRRC_kwDOABII585zUYSF",
      "diff_hunk": "@@ -0,0 +1,435 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#ifndef BITCOIN_COMMON_SOCKMAN_H\n+#define BITCOIN_COMMON_SOCKMAN_H\n+\n+#include <i2p.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <util/fs.h>\n+#include <util/sock.h>\n+#include <util/translation.h>\n+\n+#include <atomic>\n+#include <memory>\n+#include <queue>\n+#include <span>\n+#include <thread>\n+#include <variant>\n+#include <vector>\n+\n+typedef int64_t NodeId;\n+\n+/**\n+ * A socket manager class which handles socket operations.\n+ * To use this class, inherit from it and implement the pure virtual methods.\n+ * Handled operations:\n+ * - binding and listening on sockets\n+ * - starting of necessary threads to process socket operations\n+ * - accepting incoming connections\n+ * - making outbound connections\n+ * - closing connections\n+ * - waiting for IO readiness on sockets and doing send/recv accordingly\n+ */\n+class SockMan\n+{\n+public:\n+\n+    virtual ~SockMan() = default;\n+\n+    //\n+    // Non-virtual functions, to be reused by children classes.\n+    //\n+\n+    /**\n+     * Bind to a new address:port, start listening and add the listen socket to `m_listen`.\n+     * Should be called before `StartSocketsThreads()`.\n+     * @param[in] to Where to bind.\n+     * @param[out] errmsg Error string if an error occurs.\n+     * @retval true Success.\n+     * @retval false Failure, `strError` will be set.\n+     */\n+    bool BindAndStartListening(const CService& to, bilingual_str& errmsg);\n+\n+    /**\n+     * Options to influence `StartSocketsThreads()`.\n+     */\n+    struct Options {\n+        std::string_view socket_handler_thread_name;\n+\n+        struct I2P {\n+            explicit I2P(const fs::path& file, const Proxy& proxy, std::string_view accept_thread_name)\n+                : private_key_file{file},\n+                  sam_proxy{proxy},\n+                  accept_thread_name{accept_thread_name}\n+            {}\n+\n+            const fs::path private_key_file;\n+            const Proxy sam_proxy;\n+            const std::string_view accept_thread_name;\n+        };\n+\n+        /**\n+         * I2P options. If set then a thread will be started that will accept incoming I2P connections.\n+         */\n+        std::optional<I2P> i2p;\n+    };\n+\n+    /**\n+     * Start the necessary threads for sockets IO.\n+     */\n+    void StartSocketsThreads(const Options& options);\n+\n+    /**\n+     * Join (wait for) the threads started by `StartSocketsThreads()` to exit.\n+     */\n+    void JoinSocketsThreads();\n+\n+    /**\n+     * A more readable std::tuple<std::string, uint16_t> for host and port.\n+     */\n+    struct StringHostIntPort {\n+        const std::string& host;\n+        uint16_t port;\n+    };\n+\n+    /**\n+     * Make an outbound connection, save the socket internally and return a newly generated node id.\n+     * @param[in] to The address to connect to, either as CService or a host as string and port as\n+     * an integer, if the later is used, then `proxy` must be valid.\n+     * @param[in] is_important If true, then log failures with higher severity.\n+     * @param[in] proxy Proxy to connect through if `proxy.IsValid()` is true.\n+     * @param[out] proxy_failed If `proxy` is valid and the connection failed because of the\n+     * proxy, then it will be set to true.\n+     * @param[out] me If the connection was successful then this is set to the address on the\n+     * local side of the socket.\n+     * @return Newly generated node id, or std::nullopt if the operation fails.\n+     */\n+    std::optional<NodeId> ConnectAndMakeNodeId(const std::variant<CService, StringHostIntPort>& to,\n+                                               bool is_important,\n+                                               const Proxy& proxy,\n+                                               bool& proxy_failed,\n+                                               CService& me)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex, !m_unused_i2p_sessions_mutex);\n+\n+    /**\n+     * Disconnect a given peer by closing its socket and release resources occupied by it.\n+     * @return Whether the peer existed and its socket was closed by this call.\n+     */\n+    bool CloseConnection(NodeId node_id)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Try to send some data to the given node.\n+     * @param[in] node_id Identifier of the node to send to.\n+     * @param[in] data The data to send, it might happen that only a prefix of this is sent.\n+     * @param[in] will_send_more Used as an optimization if the caller knows that they will\n+     * be sending more data soon after this call.\n+     * @param[out] errmsg If <0 is returned then this will contain a human readable message\n+     * explaining the error.\n+     * @retval >=0 The number of bytes actually sent.\n+     * @retval <0 A permanent error has occurred.\n+     */\n+    ssize_t SendBytes(NodeId node_id,\n+                      std::span<const unsigned char> data,\n+                      bool will_send_more,\n+                      std::string& errmsg) const\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Close all sockets.\n+     */\n+    void CloseSockets();\n+\n+    /**\n+     * This is signaled when network activity should cease.\n+     * A pointer to it is saved in `m_i2p_sam_session`, so make sure that\n+     * the lifetime of `interruptNet` is not shorter than\n+     * the lifetime of `m_i2p_sam_session`.\n+     */\n+    CThreadInterrupt interruptNet;\n+\n+protected:\n+\n+    /**\n+     * During some tests mocked sockets are created outside of `SockMan`, make it\n+     * possible to add those so that send/recv can be exercised.\n+     */\n+    void TestOnlyAddExistentNode(NodeId node_id, std::unique_ptr<Sock>&& sock)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+private:\n+\n+    /**\n+     * Cap on the size of `m_unused_i2p_sessions`, to ensure it does not\n+     * unexpectedly use too much memory.\n+     */\n+    static constexpr size_t MAX_UNUSED_I2P_SESSIONS_SIZE{10};\n+\n+    //\n+    // Pure virtual functions must be implemented by children classes.\n+    //\n+\n+    /**\n+     * Be notified when a new connection has been accepted.\n+     * @param[in] node_id Id of the newly accepted connection.\n+     * @param[in] me The address and port at our side of the connection.\n+     * @param[in] them The address and port at the peer's side of the connection.\n+     * @retval true The new connection was accepted at the higher level.\n+     * @retval false The connection was refused at the higher level, so the\n+     * associated socket and node_id should be discarded by `SockMan`.\n+     */\n+    virtual bool EventNewConnectionAccepted(NodeId node_id,\n+                                            const CService& me,\n+                                            const CService& them) = 0;\n+\n+    /**\n+     * Called when the socket is ready to send data and `ShouldTryToSend()` has\n+     * returned true. This is where the higher level code serializes its messages\n+     * and calls `SockMan::SendBytes()`.\n+     * @param[in] node_id Id of the node whose socket is ready to send.\n+     * @param[out] cancel_recv Should always be set upon return and if it is true,\n+     * then the next attempt to receive data from that node will be omitted.\n+     */\n+    virtual void EventReadyToSend(NodeId node_id, bool& cancel_recv) = 0;\n+\n+    /**\n+     * Called when new data has been received.\n+     * @param[in] node_id Node for which the data arrived.\n+     * @param[in] data Data buffer.\n+     * @param[in] n Number of bytes in `data`.\n+     */\n+    virtual void EventGotData(NodeId node_id, const uint8_t* data, size_t n) = 0;\n+\n+    /**\n+     * Called when the remote peer has sent an EOF on the socket. This is a graceful\n+     * close of their writing side, we can still send and they will receive, if it\n+     * makes sense at the application level.\n+     * @param[in] node_id Node whose socket got EOF.\n+     */\n+    virtual void EventGotEOF(NodeId node_id) = 0;\n+\n+    /**\n+     * Called when we get an irrecoverable error trying to read from a socket.\n+     * @param[in] node_id Node whose socket got an error.\n+     * @param[in] errmsg Message describing the error.\n+     */\n+    virtual void EventGotPermanentReadError(NodeId node_id, const std::string& errmsg) = 0;\n+\n+    //\n+    // Non-pure virtual functions can be overridden by children classes or left\n+    // alone to use the default implementation from SockMan.\n+    //\n+\n+    /**\n+     * Can be used to temporarily pause sends for a node.\n+     * SockMan would only call EventReadyToSend() if this returns true.\n+     * The implementation in SockMan always returns true.\n+     * @param[in] node_id Node for which to confirm or cancel a call to EventReadyToSend().\n+     */\n+    virtual bool ShouldTryToSend(NodeId node_id) const;\n+\n+    /**\n+     * SockMan would only call Recv() on a node's socket if this returns true.\n+     * Can be used to temporarily pause receives for a node.\n+     * The implementation in SockMan always returns true.\n+     * @param[in] node_id Node for which to confirm or cancel a receive.\n+     */\n+    virtual bool ShouldTryToRecv(NodeId node_id) const;\n+\n+    /**\n+     * SockMan has completed the current send+recv iteration for a node.\n+     * It will do another send+recv for this node after processing all other nodes.\n+     * Can be used to execute periodic tasks for a given node.\n+     * The implementation in SockMan does nothing.\n+     * @param[in] node_id Node for which send+recv has been done.\n+     */\n+    virtual void EventIOLoopCompletedForNode(NodeId node_id);\n+\n+    /**\n+     * SockMan has completed send+recv for all nodes.\n+     * Can be used to execute periodic tasks for all nodes, like disconnecting\n+     * nodes due to higher level logic.\n+     * The implementation in SockMan does nothing.\n+     */\n+    virtual void EventIOLoopCompletedForAllPeers();\n+\n+    /**\n+     * Be notified of a change in the state of listening for incoming I2P connections.\n+     * The default behavior, implemented by `SockMan`, is to ignore this event.\n+     * @param[in] addr Our listening address.\n+     * @param[in] success If true then the listen succeeded and we are now\n+     * listening for incoming I2P connections at `addr`. If false then the\n+     * call failed and now we are not listening (even if this was invoked\n+     * before with `true`).\n+     */\n+    virtual void EventI2PListen(const CService& addr, bool success);\n+\n+    /**\n+     * The sockets used by a connected node - a data socket and an optional I2P session.\n+     */\n+    struct NodeSockets {\n+        explicit NodeSockets(std::unique_ptr<Sock>&& s)\n+            : sock{std::move(s)}\n+        {\n+        }\n+\n+        explicit NodeSockets(std::shared_ptr<Sock>&& s, std::unique_ptr<i2p::sam::Session>&& sess)\n+            : sock{std::move(s)},\n+              i2p_transient_session{std::move(sess)}\n+        {\n+        }\n+\n+        /**\n+         * Mutex that serializes the Send() and Recv() calls on `sock`.\n+         */\n+        Mutex mutex;\n+\n+        /**\n+         * Underlying socket.\n+         * `shared_ptr` (instead of `unique_ptr`) is used to avoid premature close of the\n+         * underlying file descriptor by one thread while another thread is poll(2)-ing\n+         * it for activity.\n+         * @see https://github.com/bitcoin/bitcoin/issues/21744 for details.\n+         */\n+        std::shared_ptr<Sock> sock;\n+\n+        /**\n+         * When transient I2P sessions are used, then each node has its own session, otherwise\n+         * all nodes use the session from `m_i2p_sam_session` and share the same I2P address.\n+         * I2P sessions involve a data/transport socket (in `sock`) and a control socket\n+         * (in `i2p_transient_session`). For transient sessions, once the data socket `sock` is\n+         * closed, the control socket is not going to be used anymore and would be just taking\n+         * resources. Storing it here makes its deletion together with `sock` automatic.\n+         */\n+        std::unique_ptr<i2p::sam::Session> i2p_transient_session;\n+    };\n+\n+    /**\n+     * Info about which socket has which event ready and its node id.\n+     */\n+    struct IOReadiness {\n+        Sock::EventsPerSock events_per_sock;\n+        std::unordered_map<Sock::EventsPerSock::key_type, NodeId> node_ids_per_sock;\n+    };\n+\n+    /**\n+     * Accept incoming I2P connections in a loop and call\n+     * `EventNewConnectionAccepted()` for each new connection.\n+     */\n+    void ThreadI2PAccept()\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Check connected and listening sockets for IO readiness and process them accordingly.\n+     */\n+    void ThreadSocketHandler()\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Accept a connection.\n+     * @param[in] listen_sock Socket on which to accept the connection.\n+     * @param[out] addr Address of the peer that was accepted.\n+     * @return Newly created socket for the accepted connection.\n+     */\n+    std::unique_ptr<Sock> AcceptConnection(const Sock& listen_sock, CService& addr);\n+\n+    /**\n+     * After a new socket with a peer has been created, configure its flags,\n+     * make a new node id and call `EventNewConnectionAccepted()`.\n+     * @param[in] sock The newly created socket.\n+     * @param[in] me Address at our end of the connection.\n+     * @param[in] them Address of the new peer.\n+     */\n+    void NewSockAccepted(std::unique_ptr<Sock>&& sock, const CService& me, const CService& them)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Generate an id for a newly created node.\n+     */\n+    NodeId GetNewNodeId();\n+\n+    /**\n+     * Generate a collection of sockets to check for IO readiness.\n+     * @return Sockets to check for readiness plus an aux map to find the\n+     * corresponding node id given a socket.\n+     */\n+    IOReadiness GenerateWaitSockets()\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Do the read/write for connected sockets that are ready for IO.\n+     * @param[in] io_readiness Which sockets are ready and their node ids.\n+     */\n+    void SocketHandlerConnected(const IOReadiness& io_readiness)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Accept incoming connections, one from each read-ready listening socket.\n+     * @param[in] events_per_sock Sockets that are ready for IO.\n+     */\n+    void SocketHandlerListening(const Sock::EventsPerSock& events_per_sock)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Retrieve an entry from m_connected.\n+     * @param[in] node_id Node id to search for.\n+     * @return NodeSockets for the given node id or empty shared_ptr if not found.\n+     */\n+    std::shared_ptr<NodeSockets> GetNodeSockets(NodeId node_id) const\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * The id to assign to the next created node. Used to generate ids of nodes.\n+     */\n+    std::atomic<NodeId> m_next_node_id{0};\n+\n+    /**\n+     * Thread that sends to and receives from sockets and accepts connections.\n+     */\n+    std::thread m_thread_socket_handler;\n+\n+    /**\n+     * Thread that accepts incoming I2P connections in a loop, can be stopped via `interruptNet`.\n+     */\n+    std::thread m_thread_i2p_accept;\n+\n+    /**\n+     * Mutex protecting m_i2p_sam_sessions.\n+     */\n+    Mutex m_unused_i2p_sessions_mutex;\n+\n+    /**\n+     * A pool of created I2P SAM transient sessions that should be used instead\n+     * of creating new ones in order to reduce the load on the I2P network.\n+     * Creating a session in I2P is not cheap, thus if this is not empty, then\n+     * pick an entry from it instead of creating a new session. If connecting to\n+     * a host fails, then the created session is put to this pool for reuse.\n+     */\n+    std::queue<std::unique_ptr<i2p::sam::Session>> m_unused_i2p_sessions GUARDED_BY(m_unused_i2p_sessions_mutex);\n+\n+    /**\n+     * I2P SAM session.\n+     * Used to accept incoming and make outgoing I2P connections from a persistent\n+     * address.\n+     */\n+    std::unique_ptr<i2p::sam::Session> m_i2p_sam_session;\n+\n+    /**\n+     * List of listening sockets.\n+     */\n+    std::vector<std::shared_ptr<Sock>> m_listen;",
      "path": "src/common/sockman.h",
      "position": 451,
      "original_position": 423,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "266ac3267390270e6794d478aa1fbe40e88ffb0f",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: The comment adds no information.\r\n```suggestion\r\n    std::vector<std::shared_ptr<Sock>> m_listen;\r\n```\r\nSame for `m_unused_i2p_sessions_mutex`.",
      "created_at": "2025-01-29T22:04:48Z",
      "updated_at": "2025-02-01T20:37:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1934722181",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1934722181"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": 448,
      "original_start_line": 420,
      "start_side": "RIGHT",
      "line": 451,
      "original_line": 451,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1934731306",
      "pull_request_review_id": 2582270517,
      "id": 1934731306,
      "node_id": "PRRC_kwDOABII585zUagq",
      "diff_hunk": "@@ -0,0 +1,533 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+#include <cassert>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+static CService GetBindAddress(const Sock& sock)\n+{\n+    CService addr_bind;\n+    struct sockaddr_storage sockaddr_bind;\n+    socklen_t sockaddr_bind_len = sizeof(sockaddr_bind);\n+    if (!sock.GetSockName((struct sockaddr*)&sockaddr_bind, &sockaddr_bind_len)) {\n+        addr_bind.SetSockAddr((const struct sockaddr*)&sockaddr_bind);\n+    } else {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"getsockname failed\\n\");\n+    }\n+    return addr_bind;\n+}\n+\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& errmsg)\n+{\n+    // Create socket for listening for incoming connections\n+    struct sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {\n+        errmsg = Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()));\n+        return false;\n+    }\n+\n+    std::unique_ptr<Sock> sock{CreateSock(to.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP)};\n+    if (!sock) {\n+        errmsg = Untranslated(strprintf(\"Cannot create %s listen socket: %s\",\n+                                        to.ToStringAddrPort(),\n+                                        NetworkErrorString(WSAGetLastError())));\n+        return false;\n+    }\n+\n+    int one{1};\n+\n+    // Allow binding if the port is still in TIME_WAIT state after\n+    // the program was closed and restarted.\n+    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+        LogPrintLevel(BCLog::NET,\n+                      BCLog::Level::Info,\n+                      \"Cannot set SO_REUSEADDR on %s listen socket: %s, continuing anyway\\n\",\n+                      to.ToStringAddrPort(),\n+                      NetworkErrorString(WSAGetLastError()));\n+    }\n+\n+    // some systems don't have IPV6_V6ONLY but are always v6only; others do have the option\n+    // and enable it by default or not. Try to enable it, if possible.\n+    if (to.IsIPv6()) {\n+#ifdef IPV6_V6ONLY\n+        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_V6ONLY on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+#ifdef WIN32\n+        int prot_level{PROTECTION_LEVEL_UNRESTRICTED};\n+        if (sock->SetSockOpt(IPPROTO_IPV6,\n+                             IPV6_PROTECTION_LEVEL,\n+                             reinterpret_cast<const char*>(&prot_level),\n+                             sizeof(prot_level)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_PROTECTION_LEVEL on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+    }\n+\n+    if (sock->Bind(reinterpret_cast<sockaddr*>(&storage), len) == SOCKET_ERROR) {\n+        const int err{WSAGetLastError()};\n+        errmsg = strprintf(_(\"Cannot bind to %s: %s%s\"),\n+                           to.ToStringAddrPort(),\n+                           NetworkErrorString(err),\n+                           err == WSAEADDRINUSE\n+                               ? std::string{\" (\"} + CLIENT_NAME + \" already running?)\"\n+                               : \"\");\n+        return false;\n+    }\n+\n+    // Listen for incoming connections\n+    if (sock->Listen(SOMAXCONN) == SOCKET_ERROR) {\n+        errmsg = strprintf(_(\"Cannot listen to %s: %s\"), to.ToStringAddrPort(), NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    m_listen.emplace_back(std::move(sock));\n+\n+    return true;\n+}\n+\n+void SockMan::StartSocketsThreads(const Options& options)\n+{\n+    m_thread_socket_handler = std::thread(\n+        &util::TraceThread, options.socket_handler_thread_name, [this] { ThreadSocketHandler(); });\n+\n+    if (options.i2p.has_value()) {\n+        m_i2p_sam_session = std::make_unique<i2p::sam::Session>(\n+            options.i2p->private_key_file, options.i2p->sam_proxy, &interruptNet);\n+\n+        m_thread_i2p_accept =\n+            std::thread(&util::TraceThread, options.i2p->accept_thread_name, [this] { ThreadI2PAccept(); });\n+    }\n+}\n+\n+void SockMan::JoinSocketsThreads()\n+{\n+    if (m_thread_i2p_accept.joinable()) {\n+        m_thread_i2p_accept.join();\n+    }\n+\n+    if (m_thread_socket_handler.joinable()) {\n+        m_thread_socket_handler.join();\n+    }\n+}\n+\n+std::optional<NodeId>\n+SockMan::ConnectAndMakeNodeId(const std::variant<CService, StringHostIntPort>& to,\n+                              bool is_important,\n+                              const Proxy& proxy,\n+                              bool& proxy_failed,\n+                              CService& me)\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+    AssertLockNotHeld(m_unused_i2p_sessions_mutex);\n+\n+    std::unique_ptr<Sock> sock;\n+    std::unique_ptr<i2p::sam::Session> i2p_transient_session;\n+\n+    Assume(!me.IsValid());\n+\n+    if (std::holds_alternative<CService>(to)) {\n+        const CService& addr_to{std::get<CService>(to)};\n+        if (addr_to.IsI2P()) {\n+            if (!Assume(proxy.IsValid())) {\n+                return std::nullopt;\n+            }\n+\n+            i2p::Connection conn;\n+            bool connected{false};\n+\n+            if (m_i2p_sam_session) {\n+                connected = m_i2p_sam_session->Connect(addr_to, conn, proxy_failed);\n+            } else {\n+                {\n+                    LOCK(m_unused_i2p_sessions_mutex);\n+                    if (m_unused_i2p_sessions.empty()) {\n+                        i2p_transient_session = std::make_unique<i2p::sam::Session>(proxy, &interruptNet);\n+                    } else {\n+                        i2p_transient_session.swap(m_unused_i2p_sessions.front());\n+                        m_unused_i2p_sessions.pop();\n+                    }\n+                }\n+                connected = i2p_transient_session->Connect(addr_to, conn, proxy_failed);\n+                if (!connected) {\n+                    LOCK(m_unused_i2p_sessions_mutex);\n+                    if (m_unused_i2p_sessions.size() < MAX_UNUSED_I2P_SESSIONS_SIZE) {\n+                        m_unused_i2p_sessions.emplace(i2p_transient_session.release());\n+                    }\n+                }\n+            }\n+\n+            if (connected) {\n+                sock = std::move(conn.sock);\n+                me = conn.me;\n+            }\n+        } else if (proxy.IsValid()) {\n+            sock = ConnectThroughProxy(proxy, addr_to.ToStringAddr(), addr_to.GetPort(), proxy_failed);\n+        } else {\n+            sock = ConnectDirectly(addr_to, is_important);\n+        }\n+    } else {\n+        if (!Assume(proxy.IsValid())) {\n+            return std::nullopt;\n+        }\n+\n+        const auto& hostport{std::get<StringHostIntPort>(to)};\n+\n+        bool dummy_proxy_failed;\n+        sock = ConnectThroughProxy(proxy, hostport.host, hostport.port, dummy_proxy_failed);\n+    }\n+\n+    if (!sock) {\n+        return std::nullopt;\n+    }\n+\n+    if (!me.IsValid()) {\n+        me = GetBindAddress(*sock);\n+    }\n+\n+    const NodeId node_id{GetNewNodeId()};\n+\n+    {\n+        LOCK(m_connected_mutex);\n+        m_connected.emplace(node_id, std::make_shared<NodeSockets>(std::move(sock),\n+                                                                   std::move(i2p_transient_session)));\n+    }\n+\n+    return node_id;\n+}\n+\n+bool SockMan::CloseConnection(NodeId node_id)\n+{\n+    LOCK(m_connected_mutex);\n+    return m_connected.erase(node_id) > 0;\n+}\n+\n+ssize_t SockMan::SendBytes(NodeId node_id,\n+                           std::span<const unsigned char> data,\n+                           bool will_send_more,\n+                           std::string& errmsg) const\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    if (data.empty()) {\n+        return 0;\n+    }\n+\n+    auto node_sockets{GetNodeSockets(node_id)};\n+    if (!node_sockets) {\n+        // Bail out immediately and just leave things in the caller's send queue.\n+        return 0;\n+    }\n+\n+    int flags{MSG_NOSIGNAL | MSG_DONTWAIT};\n+#ifdef MSG_MORE\n+    if (will_send_more) {\n+        flags |= MSG_MORE;\n+    }\n+#endif\n+\n+    const ssize_t sent{WITH_LOCK(\n+        node_sockets->mutex,\n+        return node_sockets->sock->Send(reinterpret_cast<const char*>(data.data()), data.size(), flags);)};\n+\n+    if (sent >= 0) {\n+        return sent;\n+    }\n+\n+    const int err{WSAGetLastError()};\n+    if (err == WSAEWOULDBLOCK || err == WSAEMSGSIZE || err == WSAEINTR || err == WSAEINPROGRESS) {\n+        return 0;\n+    }\n+    errmsg = NetworkErrorString(err);\n+    return -1;\n+}\n+\n+void SockMan::CloseSockets()",
      "path": "src/common/sockman.cpp",
      "position": null,
      "original_position": 267,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "266ac3267390270e6794d478aa1fbe40e88ffb0f",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: Might have a more precise name since we are releasing references to `shared_ptr`s?\r\n```suggestion\r\nvoid SockMan::ReleaseSockets()\r\n```",
      "created_at": "2025-01-29T22:15:01Z",
      "updated_at": "2025-02-01T20:37:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1934731306",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1934731306"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 267,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1934736289",
      "pull_request_review_id": 2582270517,
      "id": 1934736289,
      "node_id": "PRRC_kwDOABII585zUbuh",
      "diff_hunk": "@@ -3212,13 +2972,18 @@ bool CConnman::Bind(const CService& addr_, unsigned int flags, NetPermissionFlag\n     const CService addr{MaybeFlipIPv6toCJDNS(addr_)};\n \n     bilingual_str strError;\n-    if (!BindListenPort(addr, strError, permissions)) {\n+    if (!BindAndStartListening(addr, strError)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"%s\\n\", strError.original);",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 1120,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "266ac3267390270e6794d478aa1fbe40e88ffb0f",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: Sufficiently critical for a generic error?\r\n```suggestion\r\n        LogError(\"%s\", strError.original);\r\n```\r\n(Can also omit trailing newline here and in other added/modified log lines).",
      "created_at": "2025-01-29T22:20:07Z",
      "updated_at": "2025-02-01T20:37:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1934736289",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1934736289"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2975,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1934748506",
      "pull_request_review_id": 2582270517,
      "id": 1934748506,
      "node_id": "PRRC_kwDOABII585zUeta",
      "diff_hunk": "@@ -0,0 +1,533 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+#include <cassert>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+static CService GetBindAddress(const Sock& sock)\n+{\n+    CService addr_bind;\n+    struct sockaddr_storage sockaddr_bind;\n+    socklen_t sockaddr_bind_len = sizeof(sockaddr_bind);\n+    if (!sock.GetSockName((struct sockaddr*)&sockaddr_bind, &sockaddr_bind_len)) {\n+        addr_bind.SetSockAddr((const struct sockaddr*)&sockaddr_bind);\n+    } else {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"getsockname failed\\n\");\n+    }\n+    return addr_bind;\n+}\n+\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& errmsg)\n+{\n+    // Create socket for listening for incoming connections\n+    struct sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {\n+        errmsg = Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()));\n+        return false;\n+    }\n+\n+    std::unique_ptr<Sock> sock{CreateSock(to.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP)};\n+    if (!sock) {\n+        errmsg = Untranslated(strprintf(\"Cannot create %s listen socket: %s\",\n+                                        to.ToStringAddrPort(),\n+                                        NetworkErrorString(WSAGetLastError())));\n+        return false;\n+    }\n+\n+    int one{1};\n+\n+    // Allow binding if the port is still in TIME_WAIT state after\n+    // the program was closed and restarted.\n+    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+        LogPrintLevel(BCLog::NET,\n+                      BCLog::Level::Info,\n+                      \"Cannot set SO_REUSEADDR on %s listen socket: %s, continuing anyway\\n\",\n+                      to.ToStringAddrPort(),\n+                      NetworkErrorString(WSAGetLastError()));\n+    }\n+\n+    // some systems don't have IPV6_V6ONLY but are always v6only; others do have the option\n+    // and enable it by default or not. Try to enable it, if possible.\n+    if (to.IsIPv6()) {\n+#ifdef IPV6_V6ONLY\n+        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_V6ONLY on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+#ifdef WIN32\n+        int prot_level{PROTECTION_LEVEL_UNRESTRICTED};\n+        if (sock->SetSockOpt(IPPROTO_IPV6,\n+                             IPV6_PROTECTION_LEVEL,\n+                             reinterpret_cast<const char*>(&prot_level),\n+                             sizeof(prot_level)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_PROTECTION_LEVEL on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+    }\n+\n+    if (sock->Bind(reinterpret_cast<sockaddr*>(&storage), len) == SOCKET_ERROR) {\n+        const int err{WSAGetLastError()};\n+        errmsg = strprintf(_(\"Cannot bind to %s: %s%s\"),\n+                           to.ToStringAddrPort(),\n+                           NetworkErrorString(err),\n+                           err == WSAEADDRINUSE\n+                               ? std::string{\" (\"} + CLIENT_NAME + \" already running?)\"\n+                               : \"\");",
      "path": "src/common/sockman.cpp",
      "position": null,
      "original_position": 96,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "266ac3267390270e6794d478aa1fbe40e88ffb0f",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Problem: \" (<CLIENT_NAME> already running?)\"-`string` is untranslated.\r\n\r\nWould suggest bringing back old strings to reduce translation churn, or ensuring the new version is fully translated. Old strings:\r\n```suggestion\r\n        if (err == WSAEADDRINUSE) {\r\n            err_msg = strprintf(_(\"Unable to bind to %s on this computer. %s is probably already running.\"), to.ToStringAddrPort(), CLIENT_NAME);\r\n        } else {\r\n            err_msg = strprintf(_(\"Unable to bind to %s on this computer (bind returned error %s)\"), to.ToStringAddrPort(), NetworkErrorString(nErr));\r\n        }\r\n```",
      "created_at": "2025-01-29T22:34:10Z",
      "updated_at": "2025-02-01T20:37:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1934748506",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1934748506"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": 91,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 96,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1934754380",
      "pull_request_review_id": 2582270517,
      "id": 1934754380,
      "node_id": "PRRC_kwDOABII585zUgJM",
      "diff_hunk": "@@ -0,0 +1,533 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+#include <cassert>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+static CService GetBindAddress(const Sock& sock)\n+{\n+    CService addr_bind;\n+    struct sockaddr_storage sockaddr_bind;\n+    socklen_t sockaddr_bind_len = sizeof(sockaddr_bind);\n+    if (!sock.GetSockName((struct sockaddr*)&sockaddr_bind, &sockaddr_bind_len)) {\n+        addr_bind.SetSockAddr((const struct sockaddr*)&sockaddr_bind);\n+    } else {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"getsockname failed\\n\");\n+    }\n+    return addr_bind;\n+}\n+\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& errmsg)\n+{\n+    // Create socket for listening for incoming connections\n+    struct sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {\n+        errmsg = Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()));\n+        return false;\n+    }\n+\n+    std::unique_ptr<Sock> sock{CreateSock(to.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP)};\n+    if (!sock) {\n+        errmsg = Untranslated(strprintf(\"Cannot create %s listen socket: %s\",\n+                                        to.ToStringAddrPort(),\n+                                        NetworkErrorString(WSAGetLastError())));\n+        return false;\n+    }\n+\n+    int one{1};\n+\n+    // Allow binding if the port is still in TIME_WAIT state after\n+    // the program was closed and restarted.\n+    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+        LogPrintLevel(BCLog::NET,\n+                      BCLog::Level::Info,\n+                      \"Cannot set SO_REUSEADDR on %s listen socket: %s, continuing anyway\\n\",\n+                      to.ToStringAddrPort(),\n+                      NetworkErrorString(WSAGetLastError()));",
      "path": "src/common/sockman.cpp",
      "position": 60,
      "original_position": 59,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "266ac3267390270e6794d478aa1fbe40e88ffb0f",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: Curious why you changed these to be categorized (used to be `LogPrintf()` without category) - worth noting in commit message?\r\n```suggestion\r\n        LogInfo(\"Cannot set SO_REUSEADDR on %s listen socket: %s, continuing anyway\",\r\n                to.ToStringAddrPort(),\r\n                NetworkErrorString(WSAGetLastError()));\r\n```",
      "created_at": "2025-01-29T22:41:14Z",
      "updated_at": "2025-02-01T20:37:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1934754380",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1934754380"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": 56,
      "original_start_line": 55,
      "start_side": "RIGHT",
      "line": 60,
      "original_line": 60,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1934755815",
      "pull_request_review_id": 2582270517,
      "id": 1934755815,
      "node_id": "PRRC_kwDOABII585zUgfn",
      "diff_hunk": "@@ -0,0 +1,533 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+#include <cassert>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+static CService GetBindAddress(const Sock& sock)\n+{\n+    CService addr_bind;\n+    struct sockaddr_storage sockaddr_bind;\n+    socklen_t sockaddr_bind_len = sizeof(sockaddr_bind);\n+    if (!sock.GetSockName((struct sockaddr*)&sockaddr_bind, &sockaddr_bind_len)) {\n+        addr_bind.SetSockAddr((const struct sockaddr*)&sockaddr_bind);\n+    } else {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"getsockname failed\\n\");\n+    }\n+    return addr_bind;\n+}\n+\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& errmsg)\n+{\n+    // Create socket for listening for incoming connections\n+    struct sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {\n+        errmsg = Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()));\n+        return false;\n+    }\n+\n+    std::unique_ptr<Sock> sock{CreateSock(to.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP)};\n+    if (!sock) {\n+        errmsg = Untranslated(strprintf(\"Cannot create %s listen socket: %s\",\n+                                        to.ToStringAddrPort(),\n+                                        NetworkErrorString(WSAGetLastError())));\n+        return false;\n+    }\n+\n+    int one{1};\n+\n+    // Allow binding if the port is still in TIME_WAIT state after\n+    // the program was closed and restarted.\n+    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+        LogPrintLevel(BCLog::NET,\n+                      BCLog::Level::Info,\n+                      \"Cannot set SO_REUSEADDR on %s listen socket: %s, continuing anyway\\n\",\n+                      to.ToStringAddrPort(),\n+                      NetworkErrorString(WSAGetLastError()));\n+    }\n+\n+    // some systems don't have IPV6_V6ONLY but are always v6only; others do have the option\n+    // and enable it by default or not. Try to enable it, if possible.\n+    if (to.IsIPv6()) {\n+#ifdef IPV6_V6ONLY\n+        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_V6ONLY on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+#ifdef WIN32\n+        int prot_level{PROTECTION_LEVEL_UNRESTRICTED};\n+        if (sock->SetSockOpt(IPPROTO_IPV6,\n+                             IPV6_PROTECTION_LEVEL,\n+                             reinterpret_cast<const char*>(&prot_level),\n+                             sizeof(prot_level)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_PROTECTION_LEVEL on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+    }\n+\n+    if (sock->Bind(reinterpret_cast<sockaddr*>(&storage), len) == SOCKET_ERROR) {\n+        const int err{WSAGetLastError()};\n+        errmsg = strprintf(_(\"Cannot bind to %s: %s%s\"),\n+                           to.ToStringAddrPort(),\n+                           NetworkErrorString(err),\n+                           err == WSAEADDRINUSE\n+                               ? std::string{\" (\"} + CLIENT_NAME + \" already running?)\"\n+                               : \"\");\n+        return false;\n+    }\n+\n+    // Listen for incoming connections\n+    if (sock->Listen(SOMAXCONN) == SOCKET_ERROR) {\n+        errmsg = strprintf(_(\"Cannot listen to %s: %s\"), to.ToStringAddrPort(), NetworkErrorString(WSAGetLastError()));",
      "path": "src/common/sockman.cpp",
      "position": null,
      "original_position": 102,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "266ac3267390270e6794d478aa1fbe40e88ffb0f",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: listen to -> listen on?\r\n```suggestion\r\n        errmsg = strprintf(_(\"Cannot listen on %s: %s\"), to.ToStringAddrPort(), NetworkErrorString(WSAGetLastError()));\r\n```",
      "created_at": "2025-01-29T22:42:59Z",
      "updated_at": "2025-02-01T20:37:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1934755815",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1934755815"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 102,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1935267717",
      "pull_request_review_id": 2582270517,
      "id": 1935267717,
      "node_id": "PRRC_kwDOABII585zWdeF",
      "diff_hunk": "@@ -0,0 +1,533 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+#include <cassert>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+static CService GetBindAddress(const Sock& sock)\n+{\n+    CService addr_bind;\n+    struct sockaddr_storage sockaddr_bind;\n+    socklen_t sockaddr_bind_len = sizeof(sockaddr_bind);\n+    if (!sock.GetSockName((struct sockaddr*)&sockaddr_bind, &sockaddr_bind_len)) {\n+        addr_bind.SetSockAddr((const struct sockaddr*)&sockaddr_bind);",
      "path": "src/common/sockman.cpp",
      "position": null,
      "original_position": 25,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "266ac3267390270e6794d478aa1fbe40e88ffb0f",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: Leftover `struct` for instance and C-style casts post-modernization. Also in `BindAndStartListening`.\r\n\r\n```suggestion\r\n    sockaddr_storage sockaddr_bind;\r\n    socklen_t sockaddr_bind_len = sizeof(sockaddr_bind);\r\n    if (!sock.GetSockName(reinterpret_cast<sockaddr*>(&sockaddr_bind), &sockaddr_bind_len)) {\r\n        addr_bind.SetSockAddr(reinterpret_cast<const sockaddr*>(&sockaddr_bind));\r\n```",
      "created_at": "2025-01-30T09:18:37Z",
      "updated_at": "2025-02-01T20:37:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1935267717",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1935267717"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": 22,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 25,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1935292076",
      "pull_request_review_id": 2582270517,
      "id": 1935292076,
      "node_id": "PRRC_kwDOABII585zWjas",
      "diff_hunk": "@@ -0,0 +1,435 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#ifndef BITCOIN_COMMON_SOCKMAN_H\n+#define BITCOIN_COMMON_SOCKMAN_H\n+\n+#include <i2p.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <util/fs.h>\n+#include <util/sock.h>\n+#include <util/translation.h>\n+\n+#include <atomic>\n+#include <memory>\n+#include <queue>\n+#include <span>\n+#include <thread>\n+#include <variant>\n+#include <vector>\n+\n+typedef int64_t NodeId;\n+\n+/**\n+ * A socket manager class which handles socket operations.\n+ * To use this class, inherit from it and implement the pure virtual methods.\n+ * Handled operations:\n+ * - binding and listening on sockets\n+ * - starting of necessary threads to process socket operations\n+ * - accepting incoming connections\n+ * - making outbound connections\n+ * - closing connections\n+ * - waiting for IO readiness on sockets and doing send/recv accordingly\n+ */\n+class SockMan\n+{\n+public:\n+\n+    virtual ~SockMan() = default;",
      "path": "src/common/sockman.h",
      "position": 54,
      "original_position": 40,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "266ac3267390270e6794d478aa1fbe40e88ffb0f",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Since it's only inherited privately, destructor could be non-`virtual` and `protected` unless we want to destroy by `SockMan`-reference?\r\n\r\nHappy to see you made the virtual methods only called by `SockMan` private. :)",
      "created_at": "2025-01-30T09:35:02Z",
      "updated_at": "2025-02-01T20:37:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1935292076",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1935292076"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 54,
      "original_line": 54,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1935304394",
      "pull_request_review_id": 2582270517,
      "id": 1935304394,
      "node_id": "PRRC_kwDOABII585zWmbK",
      "diff_hunk": "@@ -3037,117 +2899,20 @@ void CConnman::ThreadMessageHandler()\n     }\n }\n \n-void CConnman::ThreadI2PAcceptIncoming()\n+void CConnman::EventI2PListen(const CService& addr, bool success)\n {\n-    static constexpr auto err_wait_begin = 1s;\n-    static constexpr auto err_wait_cap = 5min;\n-    auto err_wait = err_wait_begin;\n-\n-    bool advertising_listen_addr = false;\n-    i2p::Connection conn;\n-\n-    auto SleepOnFailure = [&]() {\n-        interruptNet.sleep_for(err_wait);\n-        if (err_wait < err_wait_cap) {\n-            err_wait += 1s;\n-        }\n-    };\n-\n-    while (!interruptNet) {\n-\n-        if (!m_i2p_sam_session->Listen(conn)) {\n-            if (advertising_listen_addr && conn.me.IsValid()) {\n-                RemoveLocal(conn.me);\n-                advertising_listen_addr = false;\n-            }\n-            SleepOnFailure();\n-            continue;\n+    if (success) {\n+        if (!m_i2p_advertising_listen_addr) {\n+            AddLocal(addr, LOCAL_MANUAL);\n+            m_i2p_advertising_listen_addr = true;\n         }\n-\n-        if (!advertising_listen_addr) {\n-            AddLocal(conn.me, LOCAL_MANUAL);\n-            advertising_listen_addr = true;\n-        }\n-\n-        if (!m_i2p_sam_session->Accept(conn)) {\n-            SleepOnFailure();\n-            continue;\n-        }\n-\n-        CreateNodeFromAcceptedSocket(std::move(conn.sock), NetPermissionFlags::None,\n-                                     CAddress{conn.me, NODE_NONE}, CAddress{conn.peer, NODE_NONE});\n-\n-        err_wait = err_wait_begin;\n-    }\n-}\n-\n-bool CConnman::BindListenPort(const CService& addrBind, bilingual_str& strError, NetPermissionFlags permissions)\n-{\n-    int nOne = 1;\n-\n-    // Create socket for listening for incoming connections\n-    struct sockaddr_storage sockaddr;\n-    socklen_t len = sizeof(sockaddr);\n-    if (!addrBind.GetSockAddr((struct sockaddr*)&sockaddr, &len))\n-    {\n-        strError = Untranslated(strprintf(\"Bind address family for %s not supported\", addrBind.ToStringAddrPort()));\n-        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"%s\\n\", strError.original);\n-        return false;\n-    }\n-\n-    std::unique_ptr<Sock> sock = CreateSock(addrBind.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP);\n-    if (!sock) {\n-        strError = Untranslated(strprintf(\"Couldn't open socket for incoming connections (socket returned error %s)\", NetworkErrorString(WSAGetLastError())));\n-        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"%s\\n\", strError.original);\n-        return false;\n-    }\n-\n-    // Allow binding if the port is still in TIME_WAIT state after\n-    // the program was closed and restarted.\n-    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, (sockopt_arg_type)&nOne, sizeof(int)) == SOCKET_ERROR) {\n-        strError = Untranslated(strprintf(\"Error setting SO_REUSEADDR on socket: %s, continuing anyway\", NetworkErrorString(WSAGetLastError())));\n-        LogPrintf(\"%s\\n\", strError.original);\n-    }\n-\n-    // some systems don't have IPV6_V6ONLY but are always v6only; others do have the option\n-    // and enable it by default or not. Try to enable it, if possible.\n-    if (addrBind.IsIPv6()) {\n-#ifdef IPV6_V6ONLY\n-        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, (sockopt_arg_type)&nOne, sizeof(int)) == SOCKET_ERROR) {\n-            strError = Untranslated(strprintf(\"Error setting IPV6_V6ONLY on socket: %s, continuing anyway\", NetworkErrorString(WSAGetLastError())));\n-            LogPrintf(\"%s\\n\", strError.original);\n-        }\n-#endif\n-#ifdef WIN32\n-        int nProtLevel = PROTECTION_LEVEL_UNRESTRICTED;\n-        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_PROTECTION_LEVEL, (const char*)&nProtLevel, sizeof(int)) == SOCKET_ERROR) {\n-            strError = Untranslated(strprintf(\"Error setting IPV6_PROTECTION_LEVEL on socket: %s, continuing anyway\", NetworkErrorString(WSAGetLastError())));\n-            LogPrintf(\"%s\\n\", strError.original);\n-        }\n-#endif\n+        return;",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 1071,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "266ac3267390270e6794d478aa1fbe40e88ffb0f",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: Could replace `return` with `else if` below?",
      "created_at": "2025-01-30T09:43:42Z",
      "updated_at": "2025-02-01T20:37:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1935304394",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1935304394"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2908,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1935326693",
      "pull_request_review_id": 2582270517,
      "id": 1935326693,
      "node_id": "PRRC_kwDOABII585zWr3l",
      "diff_hunk": "@@ -0,0 +1,435 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#ifndef BITCOIN_COMMON_SOCKMAN_H\n+#define BITCOIN_COMMON_SOCKMAN_H\n+\n+#include <i2p.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <util/fs.h>\n+#include <util/sock.h>\n+#include <util/translation.h>\n+\n+#include <atomic>\n+#include <memory>\n+#include <queue>\n+#include <span>\n+#include <thread>\n+#include <variant>\n+#include <vector>\n+\n+typedef int64_t NodeId;\n+\n+/**\n+ * A socket manager class which handles socket operations.\n+ * To use this class, inherit from it and implement the pure virtual methods.\n+ * Handled operations:\n+ * - binding and listening on sockets\n+ * - starting of necessary threads to process socket operations\n+ * - accepting incoming connections\n+ * - making outbound connections\n+ * - closing connections\n+ * - waiting for IO readiness on sockets and doing send/recv accordingly\n+ */\n+class SockMan\n+{\n+public:\n+\n+    virtual ~SockMan() = default;\n+\n+    //\n+    // Non-virtual functions, to be reused by children classes.\n+    //\n+\n+    /**\n+     * Bind to a new address:port, start listening and add the listen socket to `m_listen`.\n+     * Should be called before `StartSocketsThreads()`.\n+     * @param[in] to Where to bind.\n+     * @param[out] errmsg Error string if an error occurs.\n+     * @retval true Success.\n+     * @retval false Failure, `strError` will be set.\n+     */\n+    bool BindAndStartListening(const CService& to, bilingual_str& errmsg);\n+\n+    /**\n+     * Options to influence `StartSocketsThreads()`.\n+     */\n+    struct Options {\n+        std::string_view socket_handler_thread_name;\n+\n+        struct I2P {\n+            explicit I2P(const fs::path& file, const Proxy& proxy, std::string_view accept_thread_name)\n+                : private_key_file{file},\n+                  sam_proxy{proxy},\n+                  accept_thread_name{accept_thread_name}\n+            {}\n+\n+            const fs::path private_key_file;\n+            const Proxy sam_proxy;\n+            const std::string_view accept_thread_name;\n+        };\n+\n+        /**\n+         * I2P options. If set then a thread will be started that will accept incoming I2P connections.\n+         */\n+        std::optional<I2P> i2p;\n+    };\n+\n+    /**\n+     * Start the necessary threads for sockets IO.\n+     */\n+    void StartSocketsThreads(const Options& options);\n+\n+    /**\n+     * Join (wait for) the threads started by `StartSocketsThreads()` to exit.\n+     */\n+    void JoinSocketsThreads();",
      "path": "src/common/sockman.h",
      "position": 102,
      "original_position": 88,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "266ac3267390270e6794d478aa1fbe40e88ffb0f",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: One plural word is enough?\r\n```suggestion\r\n     * Start the necessary threads for socket IO.\r\n     */\r\n    void StartSocketThreads(const Options& options);\r\n\r\n    /**\r\n     * Join (wait for) the threads started by `StartSocketThreads()` to exit.\r\n     */\r\n    void JoinSocketThreads();\r\n```",
      "created_at": "2025-01-30T09:58:31Z",
      "updated_at": "2025-02-01T20:37:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1935326693",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1935326693"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": 95,
      "original_start_line": 81,
      "start_side": "RIGHT",
      "line": 102,
      "original_line": 102,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1935367810",
      "pull_request_review_id": 2582270517,
      "id": 1935367810,
      "node_id": "PRRC_kwDOABII585zW16C",
      "diff_hunk": "@@ -3636,14 +3395,14 @@ bool CConnman::DisconnectNode(const CNetAddr& addr)\n bool CConnman::DisconnectNode(NodeId id)\n {\n     LOCK(m_nodes_mutex);\n-    for(CNode* pnode : m_nodes) {\n-        if (id == pnode->GetId()) {\n-            LogDebug(BCLog::NET, \"disconnect by id peer=%d; disconnecting\\n\", pnode->GetId());\n-            pnode->fDisconnect = true;\n-            return true;\n-        }\n+    auto it{m_nodes.find(id)};\n+    if (it == m_nodes.end()) {",
      "path": "src/net.cpp",
      "position": 1282,
      "original_position": 1262,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "266ac3267390270e6794d478aa1fbe40e88ffb0f",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: Could go with something closer to original?\r\n```C++\r\n    if (auto it{m_nodes.find(id)}; it != m_nodes.end()) {\r\n        auto node{it->second};\r\n        LogDebug(BCLog::NET, \"disconnect by id peer=%d; disconnecting\\n\", id);\r\n        node->fDisconnect = true;\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n```\r\nSame pattern of `auto it{m_nodes.find(` appearing on it's own line when it could be hoisted into the `if` to reduce scope is repeated elsewhere too.",
      "created_at": "2025-01-30T10:26:46Z",
      "updated_at": "2025-02-01T20:37:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1935367810",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1935367810"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": 3429,
      "original_start_line": 3398,
      "start_side": "RIGHT",
      "line": 3430,
      "original_line": 3430,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1935376623",
      "pull_request_review_id": 2582270517,
      "id": 1935376623,
      "node_id": "PRRC_kwDOABII585zW4Dv",
      "diff_hunk": "@@ -5077,10 +5077,15 @@ void PeerManagerImpl::EvictExtraOutboundPeers(std::chrono::seconds now)\n \n         m_connman.ForEachNode([&](CNode* pnode) {\n             if (!pnode->IsBlockOnlyConn() || pnode->fDisconnect) return;\n-            if (pnode->GetId() > youngest_peer.first) {\n-                next_youngest_peer = youngest_peer;\n-                youngest_peer.first = pnode->GetId();\n-                youngest_peer.second = pnode->m_last_block_time;\n+            if (pnode->GetId() > next_youngest_peer.first) {\n+                if (pnode->GetId() > youngest_peer.first) {\n+                    next_youngest_peer = youngest_peer;\n+                    youngest_peer.first = pnode->GetId();\n+                    youngest_peer.second = pnode->m_last_block_time;\n+                } else {\n+                    next_youngest_peer.first = pnode->GetId();\n+                    next_youngest_peer.second = pnode->m_last_block_time;\n+                }",
      "path": "src/net_processing.cpp",
      "position": 16,
      "original_position": 16,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "266ac3267390270e6794d478aa1fbe40e88ffb0f",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Seems like a slight behavior change warranting it's own commit or at least a mention in the commit message doing the change?",
      "created_at": "2025-01-30T10:32:56Z",
      "updated_at": "2025-02-01T20:37:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1935376623",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1935376623"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": 5090,
      "original_start_line": 5085,
      "start_side": "RIGHT",
      "line": 5093,
      "original_line": 5093,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1935384176",
      "pull_request_review_id": 2582270517,
      "id": 1935384176,
      "node_id": "PRRC_kwDOABII585zW55w",
      "diff_hunk": "@@ -151,12 +150,12 @@ BOOST_FIXTURE_TEST_CASE(test_addnode_getaddednodeinfo_and_connection_detection,\n     }\n \n     BOOST_TEST_MESSAGE(\"\\nCheck that all connected peers are correctly detected as connected\");\n-    for (auto node : connman->TestNodes()) {\n+    for (const auto& [_, node] : connman->TestNodes()) {\n         BOOST_CHECK(connman->AlreadyConnectedPublic(node->addr));\n     }\n \n     // Clean up\n-    for (auto node : connman->TestNodes()) {\n+    for (const auto& [id, node] : connman->TestNodes()) {",
      "path": "src/test/net_peer_connection_tests.cpp",
      "position": null,
      "original_position": 40,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "266ac3267390270e6794d478aa1fbe40e88ffb0f",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit:\r\n```suggestion\r\n    for (const auto& [_, node] : connman->TestNodes()) {\r\n```",
      "created_at": "2025-01-30T10:38:33Z",
      "updated_at": "2025-02-01T20:37:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1935384176",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1935384176"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 158,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1935390847",
      "pull_request_review_id": 2582270517,
      "id": 1935390847,
      "node_id": "PRRC_kwDOABII585zW7h_",
      "diff_hunk": "@@ -64,13 +64,15 @@ FUZZ_TARGET(connman, .init = initialize_connman)\n     connman.Init(options);\n \n     CNetAddr random_netaddr;\n-    CNode random_node = ConsumeNode(fuzzed_data_provider);\n+    NodeId node_id{0};\n+    CNode& random_node{*ConsumeNodeAsUniquePtr(fuzzed_data_provider, node_id++).release()};",
      "path": "src/test/fuzz/connman.cpp",
      "position": 6,
      "original_position": 6,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "266ac3267390270e6794d478aa1fbe40e88ffb0f",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Why are we now setting the `node_id` so deterministically?",
      "created_at": "2025-01-30T10:43:22Z",
      "updated_at": "2025-02-01T20:37:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1935390847",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1935390847"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": 67,
      "original_start_line": 67,
      "start_side": "RIGHT",
      "line": 68,
      "original_line": 68,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1935397798",
      "pull_request_review_id": 2582270517,
      "id": 1935397798,
      "node_id": "PRRC_kwDOABII585zW9Om",
      "diff_hunk": "@@ -42,24 +42,30 @@ struct ConnmanTestMsg : public CConnman {\n         m_peer_connect_timeout = timeout;\n     }\n \n-    std::vector<CNode*> TestNodes()\n+    auto TestNodes()\n     {\n         LOCK(m_nodes_mutex);\n         return m_nodes;\n     }\n \n+    void AddTestNode(CNode& node, std::unique_ptr<Sock>&& sock)\n+    {\n+        TestOnlyAddExistentNode(node.GetId(), std::move(sock));\n+        AddTestNode(node);\n+    }\n+\n     void AddTestNode(CNode& node)\n     {\n         LOCK(m_nodes_mutex);\n-        m_nodes.push_back(&node);\n+        m_nodes.emplace(node.GetId(), &node);",
      "path": "src/test/util/net.h",
      "position": null,
      "original_position": 21,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "266ac3267390270e6794d478aa1fbe40e88ffb0f",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Might want to assert in case a test assigns ids randomly and the birthday paradox occurs on annoyingly rare test-runs.\r\n```suggestion\r\n        auto [_, success] = m_nodes.emplace(node.GetId(), &node);\r\n        Assert(success);\r\n```",
      "created_at": "2025-01-30T10:48:34Z",
      "updated_at": "2025-02-01T20:37:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1935397798",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1935397798"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 60,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1935414710",
      "pull_request_review_id": 2582270517,
      "id": 1935414710,
      "node_id": "PRRC_kwDOABII585zXBW2",
      "diff_hunk": "@@ -2191,6 +2222,7 @@ void CConnman::SocketHandlerListening(const Sock::EventsPerSock& events_per_sock\n \n void CConnman::ThreadSocketHandler()\n {\n+    AssertLockNotHeld(m_nodes_mutex);",
      "path": "src/net.cpp",
      "position": 888,
      "original_position": 89,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "7aca044a932e163445f2fccec7739aa7768cf36e",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "7aca044a932e163445f2fccec7739aa7768cf36e: Why assert this at the beginning of the thread, is it to help linters/sanitizers?",
      "created_at": "2025-01-30T11:00:02Z",
      "updated_at": "2025-02-01T20:37:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1935414710",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1935414710"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 2092,
      "original_line": 2092,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1935423919",
      "pull_request_review_id": 2582270517,
      "id": 1935423919,
      "node_id": "PRRC_kwDOABII585zXDmv",
      "diff_hunk": "@@ -1660,9 +1588,24 @@ std::pair<size_t, bool> CConnman::SocketSendData(CNode& node) const\n         assert(node.m_send_memusage == 0);\n     }\n     node.vSendMsg.erase(node.vSendMsg.begin(), it);\n+\n+    if (nSentSize > 0) {\n+        RecordBytesSent(nSentSize);\n+    }\n+\n     return {nSentSize, data_left};\n }\n \n+CNode* CConnman::GetNodeById(NodeId node_id) const\n+{\n+    LOCK(m_nodes_mutex);\n+    auto it{m_nodes.find(node_id)};\n+    if (it != m_nodes.end()) {\n+        return it->second;",
      "path": "src/net.cpp",
      "position": 306,
      "original_position": 301,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "266ac3267390270e6794d478aa1fbe40e88ffb0f",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "An issue here is that we return a `CNode*`, unlock `m_nodes_mutex`, then another thread comes along and deletes the node - leaving the caller with a dangling pointer.\r\n\r\nMaybe there are implementation details that make that impossible right now, but it would feel safer to instead have this function require the caller locks `m_nodes_mutex`, or do an `AddRef()` internally and require caller to do `Release()`. (Switching to `shared_ptr` instead of custom ref-counting might be more straight forward but maybe too disruptive).",
      "created_at": "2025-01-30T11:07:10Z",
      "updated_at": "2025-02-01T20:37:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1935423919",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1935423919"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": 1604,
      "original_start_line": 1601,
      "start_side": "RIGHT",
      "line": 1607,
      "original_line": 1607,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1935798322",
      "pull_request_review_id": 2582270517,
      "id": 1935798322,
      "node_id": "PRRC_kwDOABII585zYfAy",
      "diff_hunk": "@@ -0,0 +1,435 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#ifndef BITCOIN_COMMON_SOCKMAN_H\n+#define BITCOIN_COMMON_SOCKMAN_H\n+\n+#include <i2p.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <util/fs.h>\n+#include <util/sock.h>\n+#include <util/translation.h>\n+\n+#include <atomic>\n+#include <memory>\n+#include <queue>\n+#include <span>\n+#include <thread>\n+#include <variant>\n+#include <vector>\n+\n+typedef int64_t NodeId;\n+\n+/**\n+ * A socket manager class which handles socket operations.\n+ * To use this class, inherit from it and implement the pure virtual methods.\n+ * Handled operations:\n+ * - binding and listening on sockets\n+ * - starting of necessary threads to process socket operations\n+ * - accepting incoming connections\n+ * - making outbound connections\n+ * - closing connections\n+ * - waiting for IO readiness on sockets and doing send/recv accordingly\n+ */\n+class SockMan\n+{\n+public:\n+\n+    virtual ~SockMan() = default;\n+\n+    //\n+    // Non-virtual functions, to be reused by children classes.\n+    //\n+\n+    /**\n+     * Bind to a new address:port, start listening and add the listen socket to `m_listen`.\n+     * Should be called before `StartSocketsThreads()`.\n+     * @param[in] to Where to bind.\n+     * @param[out] errmsg Error string if an error occurs.\n+     * @retval true Success.\n+     * @retval false Failure, `strError` will be set.\n+     */\n+    bool BindAndStartListening(const CService& to, bilingual_str& errmsg);\n+\n+    /**\n+     * Options to influence `StartSocketsThreads()`.\n+     */\n+    struct Options {\n+        std::string_view socket_handler_thread_name;\n+\n+        struct I2P {\n+            explicit I2P(const fs::path& file, const Proxy& proxy, std::string_view accept_thread_name)\n+                : private_key_file{file},\n+                  sam_proxy{proxy},\n+                  accept_thread_name{accept_thread_name}\n+            {}\n+\n+            const fs::path private_key_file;\n+            const Proxy sam_proxy;\n+            const std::string_view accept_thread_name;\n+        };\n+\n+        /**\n+         * I2P options. If set then a thread will be started that will accept incoming I2P connections.\n+         */\n+        std::optional<I2P> i2p;\n+    };\n+\n+    /**\n+     * Start the necessary threads for sockets IO.\n+     */\n+    void StartSocketsThreads(const Options& options);\n+\n+    /**\n+     * Join (wait for) the threads started by `StartSocketsThreads()` to exit.\n+     */\n+    void JoinSocketsThreads();\n+\n+    /**\n+     * A more readable std::tuple<std::string, uint16_t> for host and port.\n+     */\n+    struct StringHostIntPort {\n+        const std::string& host;\n+        uint16_t port;\n+    };\n+\n+    /**\n+     * Make an outbound connection, save the socket internally and return a newly generated node id.\n+     * @param[in] to The address to connect to, either as CService or a host as string and port as\n+     * an integer, if the later is used, then `proxy` must be valid.\n+     * @param[in] is_important If true, then log failures with higher severity.\n+     * @param[in] proxy Proxy to connect through if `proxy.IsValid()` is true.\n+     * @param[out] proxy_failed If `proxy` is valid and the connection failed because of the\n+     * proxy, then it will be set to true.\n+     * @param[out] me If the connection was successful then this is set to the address on the\n+     * local side of the socket.\n+     * @return Newly generated node id, or std::nullopt if the operation fails.\n+     */\n+    std::optional<NodeId> ConnectAndMakeNodeId(const std::variant<CService, StringHostIntPort>& to,\n+                                               bool is_important,\n+                                               const Proxy& proxy,\n+                                               bool& proxy_failed,\n+                                               CService& me)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex, !m_unused_i2p_sessions_mutex);\n+\n+    /**\n+     * Disconnect a given peer by closing its socket and release resources occupied by it.\n+     * @return Whether the peer existed and its socket was closed by this call.\n+     */\n+    bool CloseConnection(NodeId node_id)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Try to send some data to the given node.\n+     * @param[in] node_id Identifier of the node to send to.\n+     * @param[in] data The data to send, it might happen that only a prefix of this is sent.\n+     * @param[in] will_send_more Used as an optimization if the caller knows that they will\n+     * be sending more data soon after this call.\n+     * @param[out] errmsg If <0 is returned then this will contain a human readable message\n+     * explaining the error.\n+     * @retval >=0 The number of bytes actually sent.\n+     * @retval <0 A permanent error has occurred.\n+     */\n+    ssize_t SendBytes(NodeId node_id,\n+                      std::span<const unsigned char> data,\n+                      bool will_send_more,\n+                      std::string& errmsg) const\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Close all sockets.\n+     */\n+    void CloseSockets();\n+\n+    /**\n+     * This is signaled when network activity should cease.\n+     * A pointer to it is saved in `m_i2p_sam_session`, so make sure that\n+     * the lifetime of `interruptNet` is not shorter than\n+     * the lifetime of `m_i2p_sam_session`.\n+     */\n+    CThreadInterrupt interruptNet;\n+\n+protected:\n+\n+    /**\n+     * During some tests mocked sockets are created outside of `SockMan`, make it\n+     * possible to add those so that send/recv can be exercised.\n+     */\n+    void TestOnlyAddExistentNode(NodeId node_id, std::unique_ptr<Sock>&& sock)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+private:\n+\n+    /**\n+     * Cap on the size of `m_unused_i2p_sessions`, to ensure it does not\n+     * unexpectedly use too much memory.\n+     */\n+    static constexpr size_t MAX_UNUSED_I2P_SESSIONS_SIZE{10};\n+\n+    //\n+    // Pure virtual functions must be implemented by children classes.\n+    //\n+\n+    /**\n+     * Be notified when a new connection has been accepted.\n+     * @param[in] node_id Id of the newly accepted connection.\n+     * @param[in] me The address and port at our side of the connection.\n+     * @param[in] them The address and port at the peer's side of the connection.\n+     * @retval true The new connection was accepted at the higher level.\n+     * @retval false The connection was refused at the higher level, so the\n+     * associated socket and node_id should be discarded by `SockMan`.\n+     */\n+    virtual bool EventNewConnectionAccepted(NodeId node_id,\n+                                            const CService& me,\n+                                            const CService& them) = 0;\n+\n+    /**\n+     * Called when the socket is ready to send data and `ShouldTryToSend()` has\n+     * returned true. This is where the higher level code serializes its messages\n+     * and calls `SockMan::SendBytes()`.\n+     * @param[in] node_id Id of the node whose socket is ready to send.\n+     * @param[out] cancel_recv Should always be set upon return and if it is true,\n+     * then the next attempt to receive data from that node will be omitted.\n+     */\n+    virtual void EventReadyToSend(NodeId node_id, bool& cancel_recv) = 0;\n+\n+    /**\n+     * Called when new data has been received.\n+     * @param[in] node_id Node for which the data arrived.\n+     * @param[in] data Data buffer.\n+     * @param[in] n Number of bytes in `data`.\n+     */\n+    virtual void EventGotData(NodeId node_id, const uint8_t* data, size_t n) = 0;",
      "path": "src/common/sockman.h",
      "position": null,
      "original_position": 204,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "7866c736c87a908cef75dc6901c9c0594c65b0eb",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: Could use `span`,  and maybe even `byte`?\r\n```suggestion\r\n    virtual void EventGotData(NodeId node_id, const std::span<std::byte> data) = 0;\r\n```",
      "created_at": "2025-01-30T15:19:37Z",
      "updated_at": "2025-02-01T20:37:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1935798322",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1935798322"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 204,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1935808313",
      "pull_request_review_id": 2584231283,
      "id": 1935808313,
      "node_id": "PRRC_kwDOABII585zYhc5",
      "diff_hunk": "@@ -1312,6 +1312,12 @@ class CConnman : private SockMan\n     virtual bool ShouldTryToRecv(NodeId node_id) const override\n         EXCLUSIVE_LOCKS_REQUIRED(!m_nodes_mutex);\n \n+    virtual void EventIOLoopCompletedForNode(NodeId node_id) override\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_nodes_mutex);\n+\n+    virtual void EventIOLoopCompletedForAllPeers() override\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_nodes_mutex, !m_reconnections_mutex);\n+ ",
      "path": "src/net.h",
      "position": null,
      "original_position": 9,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "248ec2d2687fae47b63688e00b9ef18d4c0c9676",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "248ec2d2687fae47b63688e00b9ef18d4c0c9676 nit: when I run the linter (along with all other tests) on this commit it complains about trailing whitespace.\r\n\r\n```diff\r\ndiff --git a/src/net.cpp b/src/net.cpp\r\nindex 8d0dd84d91..0228ddce57 100644\r\n--- a/src/net.cpp\r\n+++ b/src/net.cpp\r\n@@ -2068,7 +2068,7 @@ void CConnman::EventIOLoopCompletedForAllPeers()\r\n     DisconnectNodes();\r\n     NotifyNumConnectionsChanged();\r\n }\r\n- \r\n+\r\n Sock::EventsPerSock CConnman::GenerateWaitSockets(Span<CNode* const> nodes)\r\n {\r\n     AssertLockNotHeld(m_nodes_mutex);\r\ndiff --git a/src/net.h b/src/net.h\r\nindex 8778bcb88a..6c2c202fbb 100644\r\n--- a/src/net.h\r\n+++ b/src/net.h\r\n@@ -1317,7 +1317,7 @@ private:\r\n \r\n     virtual void EventIOLoopCompletedForAllPeers() override\r\n         EXCLUSIVE_LOCKS_REQUIRED(!m_nodes_mutex, !m_reconnections_mutex);\r\n- \r\n+\r\n     /**\r\n      * Generate a collection of sockets to check for IO readiness.\r\n      * @param[in] nodes Select from these nodes' sockets.\r\n```",
      "created_at": "2025-01-30T15:25:18Z",
      "updated_at": "2025-01-30T15:25:18Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1935808313",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1935808313"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1320,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1935839489",
      "pull_request_review_id": 2582270517,
      "id": 1935839489,
      "node_id": "PRRC_kwDOABII585zYpEB",
      "diff_hunk": "@@ -0,0 +1,533 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+#include <cassert>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+static CService GetBindAddress(const Sock& sock)\n+{\n+    CService addr_bind;\n+    struct sockaddr_storage sockaddr_bind;\n+    socklen_t sockaddr_bind_len = sizeof(sockaddr_bind);\n+    if (!sock.GetSockName((struct sockaddr*)&sockaddr_bind, &sockaddr_bind_len)) {\n+        addr_bind.SetSockAddr((const struct sockaddr*)&sockaddr_bind);\n+    } else {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"getsockname failed\\n\");\n+    }\n+    return addr_bind;\n+}\n+\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& errmsg)\n+{\n+    // Create socket for listening for incoming connections\n+    struct sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {\n+        errmsg = Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()));\n+        return false;\n+    }\n+\n+    std::unique_ptr<Sock> sock{CreateSock(to.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP)};\n+    if (!sock) {\n+        errmsg = Untranslated(strprintf(\"Cannot create %s listen socket: %s\",\n+                                        to.ToStringAddrPort(),\n+                                        NetworkErrorString(WSAGetLastError())));\n+        return false;\n+    }\n+\n+    int one{1};\n+\n+    // Allow binding if the port is still in TIME_WAIT state after\n+    // the program was closed and restarted.\n+    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+        LogPrintLevel(BCLog::NET,\n+                      BCLog::Level::Info,\n+                      \"Cannot set SO_REUSEADDR on %s listen socket: %s, continuing anyway\\n\",\n+                      to.ToStringAddrPort(),\n+                      NetworkErrorString(WSAGetLastError()));\n+    }\n+\n+    // some systems don't have IPV6_V6ONLY but are always v6only; others do have the option\n+    // and enable it by default or not. Try to enable it, if possible.\n+    if (to.IsIPv6()) {\n+#ifdef IPV6_V6ONLY\n+        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_V6ONLY on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+#ifdef WIN32\n+        int prot_level{PROTECTION_LEVEL_UNRESTRICTED};\n+        if (sock->SetSockOpt(IPPROTO_IPV6,\n+                             IPV6_PROTECTION_LEVEL,\n+                             reinterpret_cast<const char*>(&prot_level),\n+                             sizeof(prot_level)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_PROTECTION_LEVEL on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+    }\n+\n+    if (sock->Bind(reinterpret_cast<sockaddr*>(&storage), len) == SOCKET_ERROR) {\n+        const int err{WSAGetLastError()};\n+        errmsg = strprintf(_(\"Cannot bind to %s: %s%s\"),\n+                           to.ToStringAddrPort(),\n+                           NetworkErrorString(err),\n+                           err == WSAEADDRINUSE\n+                               ? std::string{\" (\"} + CLIENT_NAME + \" already running?)\"\n+                               : \"\");\n+        return false;\n+    }\n+\n+    // Listen for incoming connections\n+    if (sock->Listen(SOMAXCONN) == SOCKET_ERROR) {\n+        errmsg = strprintf(_(\"Cannot listen to %s: %s\"), to.ToStringAddrPort(), NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    m_listen.emplace_back(std::move(sock));\n+\n+    return true;\n+}\n+\n+void SockMan::StartSocketsThreads(const Options& options)\n+{\n+    m_thread_socket_handler = std::thread(\n+        &util::TraceThread, options.socket_handler_thread_name, [this] { ThreadSocketHandler(); });\n+\n+    if (options.i2p.has_value()) {\n+        m_i2p_sam_session = std::make_unique<i2p::sam::Session>(\n+            options.i2p->private_key_file, options.i2p->sam_proxy, &interruptNet);\n+\n+        m_thread_i2p_accept =\n+            std::thread(&util::TraceThread, options.i2p->accept_thread_name, [this] { ThreadI2PAccept(); });\n+    }\n+}\n+\n+void SockMan::JoinSocketsThreads()\n+{\n+    if (m_thread_i2p_accept.joinable()) {\n+        m_thread_i2p_accept.join();\n+    }\n+\n+    if (m_thread_socket_handler.joinable()) {\n+        m_thread_socket_handler.join();\n+    }\n+}\n+\n+std::optional<NodeId>\n+SockMan::ConnectAndMakeNodeId(const std::variant<CService, StringHostIntPort>& to,\n+                              bool is_important,\n+                              const Proxy& proxy,\n+                              bool& proxy_failed,\n+                              CService& me)\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+    AssertLockNotHeld(m_unused_i2p_sessions_mutex);\n+\n+    std::unique_ptr<Sock> sock;\n+    std::unique_ptr<i2p::sam::Session> i2p_transient_session;\n+\n+    Assume(!me.IsValid());\n+\n+    if (std::holds_alternative<CService>(to)) {\n+        const CService& addr_to{std::get<CService>(to)};",
      "path": "src/common/sockman.cpp",
      "position": 156,
      "original_position": 152,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "7866c736c87a908cef75dc6901c9c0594c65b0eb",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit:\r\n```suggestion\r\n    if (auto addr_to{std::get_if<CService>(&to)}) {\r\n```",
      "created_at": "2025-01-30T15:42:49Z",
      "updated_at": "2025-02-01T20:37:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1935839489",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1935839489"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": 155,
      "original_start_line": 151,
      "start_side": "RIGHT",
      "line": 156,
      "original_line": 156,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1936898358",
      "pull_request_review_id": 2586038876,
      "id": 1936898358,
      "node_id": "PRRC_kwDOABII585zcrk2",
      "diff_hunk": "@@ -42,9 +42,6 @@ FUZZ_TARGET(net, .init = initialize_net)\n     LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000) {\n         CallOneOf(\n             fuzzed_data_provider,\n-            [&] {\n-                node.CloseSocketDisconnect();",
      "path": "src/test/fuzz/net.cpp",
      "position": 5,
      "original_position": 5,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "f7dd4373b06daf34033fa84fa99408a3938e4ad4",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "f7dd4373b06daf34033fa84fa99408a3938e4ad4: would it make sense to call `MarkAsDisconnectAndCloseConnection` in the connman fuzzer?",
      "created_at": "2025-01-31T09:01:10Z",
      "updated_at": "2025-01-31T14:24:13Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1936898358",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1936898358"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 46,
      "original_line": 46,
      "side": "LEFT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1937072454",
      "pull_request_review_id": 2582270517,
      "id": 1937072454,
      "node_id": "PRRC_kwDOABII585zdWFG",
      "diff_hunk": "@@ -1696,10 +1696,14 @@ bool CConnman::AttemptToEvictConnection()\n     return false;\n }\n \n-void CConnman::EventNewConnectionAccepted(std::unique_ptr<Sock>&& sock,\n-                                          const CService& addr_bind,\n-                                          const CService& addr)\n+void CConnman::EventNewConnectionAccepted(NodeId node_id,\n+                                          std::unique_ptr<Sock>&& sock,\n+                                          const CService& addr_bind_,\n+                                          const CService& addr_)\n {\n+    const CService addr_bind{MaybeFlipIPv6toCJDNS(addr_bind_)};\n+    const CService addr{MaybeFlipIPv6toCJDNS(addr_)};",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 13,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "0be688360318511ecebcfc9cbabacfa6960fa5ef",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In commit 0be688360318511ecebcfc9cbabacfa6960fa5ef:\r\nThe new code has the `ThreadI2PAccept()` -> `NewSockAccepted()` -> `EventNewConnectionAccepted()` which now contains:\r\n```\r\n    const CService addr_bind{MaybeFlipIPv6toCJDNS(addr_bind_)};\r\n    const CService addr{MaybeFlipIPv6toCJDNS(addr_)};\r\n```\r\nIs it okay to combine I2P with CJDNS, is this a bugfix?",
      "created_at": "2025-01-31T11:18:34Z",
      "updated_at": "2025-02-01T20:37:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1937072454",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1937072454"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": 1699,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1705,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1937107332",
      "pull_request_review_id": 2586038876,
      "id": 1937107332,
      "node_id": "PRRC_kwDOABII585zdemE",
      "diff_hunk": "@@ -267,17 +302,107 @@ class SockMan\n      */\n     virtual void EventI2PListen(const CService& addr, bool success);\n \n+    /**\n+     * The sockets used by a connected node - a data socket and an optional I2P session.\n+     */\n+    struct NodeSockets {",
      "path": "src/common/sockman.h",
      "position": null,
      "original_position": 146,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "f7dd4373b06daf34033fa84fa99408a3938e4ad4",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "f7dd4373b06daf34033fa84fa99408a3938e4ad4: why plural and not `NodeSocket`?\r\n\r\nDoes the I2P session `sess` also contain a socket? Or does it use `s`?",
      "created_at": "2025-01-31T11:49:37Z",
      "updated_at": "2025-01-31T14:24:13Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1937107332",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1937107332"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 308,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1937302384",
      "pull_request_review_id": 2586038876,
      "id": 1937302384,
      "node_id": "PRRC_kwDOABII585zeONw",
      "diff_hunk": "@@ -267,17 +302,107 @@ class SockMan\n      */\n     virtual void EventI2PListen(const CService& addr, bool success);\n \n+    /**\n+     * The sockets used by a connected node - a data socket and an optional I2P session.\n+     */\n+    struct NodeSockets {\n+        explicit NodeSockets(std::unique_ptr<Sock>&& s)\n+            : sock{std::move(s)}\n+        {\n+        }\n+\n+        explicit NodeSockets(std::shared_ptr<Sock>&& s, std::unique_ptr<i2p::sam::Session>&& sess)\n+            : sock{std::move(s)},\n+              i2p_transient_session{std::move(sess)}\n+        {\n+        }\n+\n+        /**\n+         * Mutex that serializes the Send() and Recv() calls on `sock`.\n+         */\n+        Mutex mutex;\n+\n+        /**\n+         * Underlying socket.\n+         * `shared_ptr` (instead of `unique_ptr`) is used to avoid premature close of the\n+         * underlying file descriptor by one thread while another thread is poll(2)-ing\n+         * it for activity.\n+         * @see https://github.com/bitcoin/bitcoin/issues/21744 for details.\n+         */\n+        std::shared_ptr<Sock> sock;\n+\n+        /**\n+         * When transient I2P sessions are used, then each node has its own session, otherwise\n+         * all nodes use the session from `m_i2p_sam_session` and share the same I2P address.\n+         * I2P sessions involve a data/transport socket (in `sock`) and a control socket\n+         * (in `i2p_transient_session`). For transient sessions, once the data socket `sock` is\n+         * closed, the control socket is not going to be used anymore and would be just taking\n+         * resources. Storing it here makes its deletion together with `sock` automatic.\n+         */\n+        std::unique_ptr<i2p::sam::Session> i2p_transient_session;\n+    };\n+\n+    /**\n+     * Info about which socket has which event ready and its node id.\n+     */\n+    struct IOReadiness {\n+        Sock::EventsPerSock events_per_sock;\n+        std::unordered_map<Sock::EventsPerSock::key_type, NodeId> node_ids_per_sock;",
      "path": "src/common/sockman.h",
      "position": null,
      "original_position": 188,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "f7dd4373b06daf34033fa84fa99408a3938e4ad4",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "f7dd4373b06daf34033fa84fa99408a3938e4ad4: it would be useful to document these two values.",
      "created_at": "2025-01-31T13:14:26Z",
      "updated_at": "2025-01-31T14:24:13Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1937302384",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1937302384"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 350,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1937394233",
      "pull_request_review_id": 2586038876,
      "id": 1937394233,
      "node_id": "PRRC_kwDOABII585zeko5",
      "diff_hunk": "@@ -297,3 +382,152 @@ void SockMan::ThreadI2PAccept()\n         err_wait = err_wait_begin;\n     }\n }\n+\n+void SockMan::ThreadSocketHandler()\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    while (!interruptNet) {\n+        EventIOLoopCompletedForAllPeers();\n+\n+        // Check for the readiness of the already connected sockets and the\n+        // listening sockets in one call (\"readiness\" as in poll(2) or\n+        // select(2)). If none are ready, wait for a short while and return\n+        // empty sets.\n+        auto io_readiness{GenerateWaitSockets()};\n+        if (io_readiness.events_per_sock.empty() ||\n+            // WaitMany() may as well be a static method, the context of the first Sock in the vector is not relevant.\n+            !io_readiness.events_per_sock.begin()->first->WaitMany(SELECT_TIMEOUT,\n+                                                                   io_readiness.events_per_sock)) {\n+            interruptNet.sleep_for(SELECT_TIMEOUT);\n+        }\n+\n+        // Service (send/receive) each of the already connected sockets.\n+        SocketHandlerConnected(io_readiness);\n+\n+        // Accept new connections from listening sockets.\n+        SocketHandlerListening(io_readiness.events_per_sock);\n+    }\n+}\n+\n+SockMan::IOReadiness SockMan::GenerateWaitSockets()\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    IOReadiness io_readiness;\n+\n+    for (const auto& sock : m_listen) {\n+        io_readiness.events_per_sock.emplace(sock, Sock::Events{Sock::RECV});\n+    }\n+\n+    auto connected_snapshot{WITH_LOCK(m_connected_mutex, return m_connected;)};\n+\n+    for (const auto& [node_id, node_sockets] : connected_snapshot) {\n+        const bool select_recv{ShouldTryToRecv(node_id)};\n+        const bool select_send{ShouldTryToSend(node_id)};\n+        if (!select_recv && !select_send) continue;\n+\n+        Sock::Event event = (select_send ? Sock::SEND : 0) | (select_recv ? Sock::RECV : 0);\n+        io_readiness.events_per_sock.emplace(node_sockets->sock, Sock::Events{event});\n+        io_readiness.node_ids_per_sock.emplace(node_sockets->sock, node_id);\n+    }\n+\n+    return io_readiness;\n+}\n+\n+void SockMan::SocketHandlerConnected(const IOReadiness& io_readiness)\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    for (const auto& [sock, events] : io_readiness.events_per_sock) {\n+        if (interruptNet) {\n+            return;\n+        }\n+\n+        auto it{io_readiness.node_ids_per_sock.find(sock)};\n+        if (it == io_readiness.node_ids_per_sock.end()) {\n+            continue;\n+        }\n+        const NodeId node_id{it->second};\n+\n+        bool send_ready = events.occurred & Sock::SEND; // Sock::SEND could only be set if ShouldTryToSend() has returned true in GenerateWaitSockets().\n+        bool recv_ready = events.occurred & Sock::RECV; // Sock::RECV could only be set if ShouldTryToRecv() has returned true in GenerateWaitSockets().\n+        bool err_ready = events.occurred & Sock::ERR;\n+\n+        if (send_ready) {\n+            bool cancel_recv;\n+\n+            EventReadyToSend(node_id, cancel_recv);\n+\n+            if (cancel_recv) {\n+                recv_ready = false;\n+            }\n+        }\n+\n+        if (recv_ready || err_ready) {\n+            uint8_t buf[0x10000]; // typical socket buffer is 8K-64K\n+\n+            auto node_sockets{GetNodeSockets(node_id)};\n+            if (!node_sockets) {\n+                continue;\n+            }\n+\n+            const ssize_t nrecv{WITH_LOCK(\n+                node_sockets->mutex,\n+                return node_sockets->sock->Recv(buf, sizeof(buf), MSG_DONTWAIT);)};\n+\n+            switch (nrecv) {",
      "path": "src/common/sockman.cpp",
      "position": null,
      "original_position": 261,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "f7dd4373b06daf34033fa84fa99408a3938e4ad4",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "f7dd4373b06daf34033fa84fa99408a3938e4ad4: maybe add a comment here that both `-1` and `0` still warrant (require?) reaching `EventIOLoopCompletedForNode`, so we can't just have individual `if ... continue` guards for them. ",
      "created_at": "2025-01-31T14:21:08Z",
      "updated_at": "2025-01-31T14:24:13Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1937394233",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1937394233"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 479,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1937937184",
      "pull_request_review_id": 2582270517,
      "id": 1937937184,
      "node_id": "PRRC_kwDOABII585zgpMg",
      "diff_hunk": "@@ -678,16 +676,6 @@ class CNode\n \n     const NetPermissionFlags m_permission_flags;\n \n-    /**\n-     * Socket used for communication with the node.\n-     * May not own a Sock object (after `CloseSocketDisconnect()` or during tests).\n-     * `shared_ptr` (instead of `unique_ptr`) is used to avoid premature close of\n-     * the underlying file descriptor by one thread while another thread is\n-     * poll(2)-ing it for activity.\n-     * @see https://github.com/bitcoin/bitcoin/issues/21744 for details.\n-     */\n-    std::shared_ptr<Sock> m_sock GUARDED_BY(m_sock_mutex);",
      "path": "src/net.h",
      "position": 47,
      "original_position": 56,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "7866c736c87a908cef75dc6901c9c0594c65b0eb",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Forgot to remove `CNode::m_sock_mutex`.",
      "created_at": "2025-01-31T20:14:40Z",
      "updated_at": "2025-02-01T20:37:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1937937184",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1937937184"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 689,
      "original_line": 689,
      "side": "LEFT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1937940500",
      "pull_request_review_id": 2582270517,
      "id": 1937940500,
      "node_id": "PRRC_kwDOABII585zgqAU",
      "diff_hunk": "@@ -1611,45 +1554,29 @@ std::pair<size_t, bool> CConnman::SocketSendData(CNode& node) const\n         if (expected_more.has_value()) Assume(!data.empty() == *expected_more);\n         expected_more = more;\n         data_left = !data.empty(); // will be overwritten on next loop if all of data gets sent\n-        int nBytes = 0;\n-        if (!data.empty()) {\n-            LOCK(node.m_sock_mutex);\n-            // There is no socket in case we've already disconnected, or in test cases without\n-            // real connections. In these cases, we bail out immediately and just leave things\n-            // in the send queue and transport.\n-            if (!node.m_sock) {\n-                break;\n-            }\n-            int flags = MSG_NOSIGNAL | MSG_DONTWAIT;\n-#ifdef MSG_MORE\n-            if (more) {\n-                flags |= MSG_MORE;\n-            }\n-#endif\n-            nBytes = node.m_sock->Send(reinterpret_cast<const char*>(data.data()), data.size(), flags);\n-        }\n-        if (nBytes > 0) {\n+\n+        std::string errmsg;\n+\n+        const ssize_t sent{SendBytes(node.GetId(), data, more, errmsg)};\n+\n+        if (sent > 0) {",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 252,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "7866c736c87a908cef75dc6901c9c0594c65b0eb",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: Much whitespace\r\n```suggestion\r\n        std::string errmsg;\r\n        const ssize_t sent{SendBytes(node.GetId(), data, more, errmsg)};\r\n        if (sent > 0) {\r\n```",
      "created_at": "2025-01-31T20:18:35Z",
      "updated_at": "2025-02-01T20:37:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1937940500",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1937940500"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": 1558,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1565,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1938288697",
      "pull_request_review_id": 2582270517,
      "id": 1938288697,
      "node_id": "PRRC_kwDOABII585zh_A5",
      "diff_hunk": "@@ -1705,115 +1647,80 @@ bool CConnman::AttemptToEvictConnection()\n         return false;\n     }\n     LOCK(m_nodes_mutex);\n-    for (CNode* pnode : m_nodes) {\n-        if (pnode->GetId() == *node_id_to_evict) {\n-            LogDebug(BCLog::NET, \"selected %s connection for eviction, %s\", pnode->ConnectionTypeAsString(), pnode->DisconnectMsg(fLogIPs));\n-            pnode->fDisconnect = true;\n-            return true;\n-        }\n+    auto it{m_nodes.find(*node_id_to_evict)};\n+    if (it != m_nodes.end()) {\n+        auto node{it->second};\n+        LogDebug(BCLog::NET, \"selected %s connection for eviction, %s\", node->ConnectionTypeAsString(), node->DisconnectMsg(fLogIPs));\n+        node->fDisconnect = true;\n+        return true;\n     }\n     return false;\n }\n \n-void CConnman::AcceptConnection(const ListenSocket& hListenSocket) {\n-    struct sockaddr_storage sockaddr;\n-    socklen_t len = sizeof(sockaddr);\n-    auto sock = hListenSocket.sock->Accept((struct sockaddr*)&sockaddr, &len);\n-    CAddress addr;\n-\n-    if (!sock) {\n-        const int nErr = WSAGetLastError();\n-        if (nErr != WSAEWOULDBLOCK) {\n-            LogPrintf(\"socket error accept failed: %s\\n\", NetworkErrorString(nErr));\n-        }\n-        return;\n-    }\n-\n-    if (!addr.SetSockAddr((const struct sockaddr*)&sockaddr)) {\n-        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"Unknown socket family\\n\");\n-    } else {\n-        addr = CAddress{MaybeFlipIPv6toCJDNS(addr), NODE_NONE};\n-    }\n+bool CConnman::EventNewConnectionAccepted(NodeId node_id,\n+                                          const CService& addr_bind_,\n+                                          const CService& addr_)",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 365,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "7866c736c87a908cef75dc6901c9c0594c65b0eb",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: Don't you want to rename these arguments to the new interface names from `SockMan` and *net.h*?",
      "created_at": "2025-02-01T14:57:00Z",
      "updated_at": "2025-02-01T20:37:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1938288697",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1938288697"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": 1661,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1662,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1938295568",
      "pull_request_review_id": 2582270517,
      "id": 1938295568,
      "node_id": "PRRC_kwDOABII585ziAsQ",
      "diff_hunk": "@@ -1611,45 +1554,29 @@ std::pair<size_t, bool> CConnman::SocketSendData(CNode& node) const\n         if (expected_more.has_value()) Assume(!data.empty() == *expected_more);\n         expected_more = more;\n         data_left = !data.empty(); // will be overwritten on next loop if all of data gets sent\n-        int nBytes = 0;\n-        if (!data.empty()) {\n-            LOCK(node.m_sock_mutex);\n-            // There is no socket in case we've already disconnected, or in test cases without\n-            // real connections. In these cases, we bail out immediately and just leave things\n-            // in the send queue and transport.\n-            if (!node.m_sock) {\n-                break;\n-            }\n-            int flags = MSG_NOSIGNAL | MSG_DONTWAIT;\n-#ifdef MSG_MORE\n-            if (more) {\n-                flags |= MSG_MORE;\n-            }\n-#endif\n-            nBytes = node.m_sock->Send(reinterpret_cast<const char*>(data.data()), data.size(), flags);\n-        }\n-        if (nBytes > 0) {\n+\n+        std::string errmsg;\n+\n+        const ssize_t sent{SendBytes(node.GetId(), data, more, errmsg)};\n+\n+        if (sent > 0) {\n             node.m_last_send = GetTime<std::chrono::seconds>();\n-            node.nSendBytes += nBytes;\n+            node.nSendBytes += sent;\n             // Notify transport that bytes have been processed.\n-            node.m_transport->MarkBytesSent(nBytes);\n+            node.m_transport->MarkBytesSent(sent);\n             // Update statistics per message type.\n             if (!msg_type.empty()) { // don't report v2 handshake bytes for now\n-                node.AccountForSentBytes(msg_type, nBytes);\n+                node.AccountForSentBytes(msg_type, sent);\n             }\n-            nSentSize += nBytes;\n-            if ((size_t)nBytes != data.size()) {\n+            nSentSize += sent;\n+            if (static_cast<size_t>(sent) != data.size()) {\n                 // could not send full message; stop sending more\n                 break;\n             }\n         } else {\n-            if (nBytes < 0) {\n-                // error\n-                int nErr = WSAGetLastError();\n-                if (nErr != WSAEWOULDBLOCK && nErr != WSAEMSGSIZE && nErr != WSAEINTR && nErr != WSAEINPROGRESS) {\n-                    LogDebug(BCLog::NET, \"socket send error, %s: %s\\n\", node.DisconnectMsg(fLogIPs), NetworkErrorString(nErr));\n-                    node.CloseSocketDisconnect();\n-                }\n+            if (sent < 0) {\n+                LogDebug(BCLog::NET, \"socket send error, %s: %s\\n\", node.DisconnectMsg(fLogIPs), errmsg);\n+                MarkAsDisconnectAndCloseConnection(node);",
      "path": "src/net.cpp",
      "position": 285,
      "original_position": 281,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "7866c736c87a908cef75dc6901c9c0594c65b0eb",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Before looking at this PR, I was playing around with the idea of changing the raw access of `CNode::fDisconnect` everywhere into two functions, `QueueDisconnect` and `DisconnectNow`. One would just set the flag and the other would also release the socket reference. My idea was to have both of them require a `reason`-argument and an optional `BCLog::Level`-argument. They would log internally if `fDisconnect` was not already set, instead of having every call site log. `MarkAsDisconnectAndCloseConnection`, seems like an opportunity to do such a thing.\r\n\r\n[WIP disconnecting++ branch](https://github.com/bitcoin/bitcoin/compare/master...hodlinator:bitcoin:2025/01/disconnecting++)\r\n\r\nTotally fine with considering it out of scope for this PR.\r\n```suggestion\r\n                MarkAsDisconnectAndCloseConnection(node, \"socket send error: %s\", err_msg);\r\n```\r\n",
      "created_at": "2025-02-01T15:46:50Z",
      "updated_at": "2025-02-01T20:37:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1938295568",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1938295568"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": 1581,
      "original_start_line": 1578,
      "start_side": "RIGHT",
      "line": 1582,
      "original_line": 1582,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1938338721",
      "pull_request_review_id": 2582270517,
      "id": 1938338721,
      "node_id": "PRRC_kwDOABII585ziLOh",
      "diff_hunk": "@@ -0,0 +1,533 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+#include <cassert>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+static CService GetBindAddress(const Sock& sock)\n+{\n+    CService addr_bind;\n+    struct sockaddr_storage sockaddr_bind;\n+    socklen_t sockaddr_bind_len = sizeof(sockaddr_bind);\n+    if (!sock.GetSockName((struct sockaddr*)&sockaddr_bind, &sockaddr_bind_len)) {\n+        addr_bind.SetSockAddr((const struct sockaddr*)&sockaddr_bind);\n+    } else {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"getsockname failed\\n\");\n+    }\n+    return addr_bind;\n+}\n+\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& errmsg)\n+{\n+    // Create socket for listening for incoming connections\n+    struct sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {\n+        errmsg = Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()));\n+        return false;\n+    }\n+\n+    std::unique_ptr<Sock> sock{CreateSock(to.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP)};\n+    if (!sock) {\n+        errmsg = Untranslated(strprintf(\"Cannot create %s listen socket: %s\",\n+                                        to.ToStringAddrPort(),\n+                                        NetworkErrorString(WSAGetLastError())));\n+        return false;\n+    }\n+\n+    int one{1};\n+\n+    // Allow binding if the port is still in TIME_WAIT state after\n+    // the program was closed and restarted.\n+    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+        LogPrintLevel(BCLog::NET,\n+                      BCLog::Level::Info,\n+                      \"Cannot set SO_REUSEADDR on %s listen socket: %s, continuing anyway\\n\",\n+                      to.ToStringAddrPort(),\n+                      NetworkErrorString(WSAGetLastError()));\n+    }\n+\n+    // some systems don't have IPV6_V6ONLY but are always v6only; others do have the option\n+    // and enable it by default or not. Try to enable it, if possible.\n+    if (to.IsIPv6()) {\n+#ifdef IPV6_V6ONLY\n+        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_V6ONLY on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+#ifdef WIN32\n+        int prot_level{PROTECTION_LEVEL_UNRESTRICTED};\n+        if (sock->SetSockOpt(IPPROTO_IPV6,\n+                             IPV6_PROTECTION_LEVEL,\n+                             reinterpret_cast<const char*>(&prot_level),\n+                             sizeof(prot_level)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_PROTECTION_LEVEL on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+    }\n+\n+    if (sock->Bind(reinterpret_cast<sockaddr*>(&storage), len) == SOCKET_ERROR) {\n+        const int err{WSAGetLastError()};\n+        errmsg = strprintf(_(\"Cannot bind to %s: %s%s\"),\n+                           to.ToStringAddrPort(),\n+                           NetworkErrorString(err),\n+                           err == WSAEADDRINUSE\n+                               ? std::string{\" (\"} + CLIENT_NAME + \" already running?)\"\n+                               : \"\");\n+        return false;\n+    }\n+\n+    // Listen for incoming connections\n+    if (sock->Listen(SOMAXCONN) == SOCKET_ERROR) {\n+        errmsg = strprintf(_(\"Cannot listen to %s: %s\"), to.ToStringAddrPort(), NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    m_listen.emplace_back(std::move(sock));\n+\n+    return true;\n+}\n+\n+void SockMan::StartSocketsThreads(const Options& options)\n+{\n+    m_thread_socket_handler = std::thread(\n+        &util::TraceThread, options.socket_handler_thread_name, [this] { ThreadSocketHandler(); });\n+\n+    if (options.i2p.has_value()) {\n+        m_i2p_sam_session = std::make_unique<i2p::sam::Session>(\n+            options.i2p->private_key_file, options.i2p->sam_proxy, &interruptNet);\n+\n+        m_thread_i2p_accept =\n+            std::thread(&util::TraceThread, options.i2p->accept_thread_name, [this] { ThreadI2PAccept(); });\n+    }\n+}\n+\n+void SockMan::JoinSocketsThreads()\n+{\n+    if (m_thread_i2p_accept.joinable()) {\n+        m_thread_i2p_accept.join();\n+    }\n+\n+    if (m_thread_socket_handler.joinable()) {\n+        m_thread_socket_handler.join();\n+    }\n+}\n+\n+std::optional<NodeId>\n+SockMan::ConnectAndMakeNodeId(const std::variant<CService, StringHostIntPort>& to,\n+                              bool is_important,\n+                              const Proxy& proxy,\n+                              bool& proxy_failed,\n+                              CService& me)\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+    AssertLockNotHeld(m_unused_i2p_sessions_mutex);\n+\n+    std::unique_ptr<Sock> sock;\n+    std::unique_ptr<i2p::sam::Session> i2p_transient_session;\n+\n+    Assume(!me.IsValid());\n+\n+    if (std::holds_alternative<CService>(to)) {\n+        const CService& addr_to{std::get<CService>(to)};\n+        if (addr_to.IsI2P()) {\n+            if (!Assume(proxy.IsValid())) {\n+                return std::nullopt;\n+            }\n+\n+            i2p::Connection conn;\n+            bool connected{false};\n+\n+            if (m_i2p_sam_session) {\n+                connected = m_i2p_sam_session->Connect(addr_to, conn, proxy_failed);\n+            } else {\n+                {\n+                    LOCK(m_unused_i2p_sessions_mutex);\n+                    if (m_unused_i2p_sessions.empty()) {\n+                        i2p_transient_session = std::make_unique<i2p::sam::Session>(proxy, &interruptNet);\n+                    } else {\n+                        i2p_transient_session.swap(m_unused_i2p_sessions.front());\n+                        m_unused_i2p_sessions.pop();\n+                    }\n+                }\n+                connected = i2p_transient_session->Connect(addr_to, conn, proxy_failed);\n+                if (!connected) {\n+                    LOCK(m_unused_i2p_sessions_mutex);\n+                    if (m_unused_i2p_sessions.size() < MAX_UNUSED_I2P_SESSIONS_SIZE) {\n+                        m_unused_i2p_sessions.emplace(i2p_transient_session.release());\n+                    }\n+                }\n+            }\n+\n+            if (connected) {\n+                sock = std::move(conn.sock);\n+                me = conn.me;\n+            }\n+        } else if (proxy.IsValid()) {\n+            sock = ConnectThroughProxy(proxy, addr_to.ToStringAddr(), addr_to.GetPort(), proxy_failed);\n+        } else {\n+            sock = ConnectDirectly(addr_to, is_important);\n+        }\n+    } else {\n+        if (!Assume(proxy.IsValid())) {\n+            return std::nullopt;\n+        }\n+\n+        const auto& hostport{std::get<StringHostIntPort>(to)};\n+\n+        bool dummy_proxy_failed;\n+        sock = ConnectThroughProxy(proxy, hostport.host, hostport.port, dummy_proxy_failed);\n+    }\n+\n+    if (!sock) {\n+        return std::nullopt;\n+    }\n+\n+    if (!me.IsValid()) {\n+        me = GetBindAddress(*sock);\n+    }\n+\n+    const NodeId node_id{GetNewNodeId()};\n+\n+    {\n+        LOCK(m_connected_mutex);\n+        m_connected.emplace(node_id, std::make_shared<NodeSockets>(std::move(sock),\n+                                                                   std::move(i2p_transient_session)));\n+    }\n+\n+    return node_id;\n+}\n+\n+bool SockMan::CloseConnection(NodeId node_id)\n+{\n+    LOCK(m_connected_mutex);\n+    return m_connected.erase(node_id) > 0;\n+}\n+\n+ssize_t SockMan::SendBytes(NodeId node_id,\n+                           std::span<const unsigned char> data,\n+                           bool will_send_more,\n+                           std::string& errmsg) const\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    if (data.empty()) {\n+        return 0;\n+    }\n+\n+    auto node_sockets{GetNodeSockets(node_id)};\n+    if (!node_sockets) {\n+        // Bail out immediately and just leave things in the caller's send queue.\n+        return 0;\n+    }\n+\n+    int flags{MSG_NOSIGNAL | MSG_DONTWAIT};\n+#ifdef MSG_MORE\n+    if (will_send_more) {\n+        flags |= MSG_MORE;\n+    }\n+#endif\n+\n+    const ssize_t sent{WITH_LOCK(\n+        node_sockets->mutex,\n+        return node_sockets->sock->Send(reinterpret_cast<const char*>(data.data()), data.size(), flags);)};\n+\n+    if (sent >= 0) {\n+        return sent;\n+    }\n+\n+    const int err{WSAGetLastError()};\n+    if (err == WSAEWOULDBLOCK || err == WSAEMSGSIZE || err == WSAEINTR || err == WSAEINPROGRESS) {\n+        return 0;\n+    }\n+    errmsg = NetworkErrorString(err);\n+    return -1;\n+}\n+\n+void SockMan::CloseSockets()\n+{\n+    m_listen.clear();\n+}\n+\n+bool SockMan::ShouldTryToSend(NodeId node_id) const { return true; }\n+\n+bool SockMan::ShouldTryToRecv(NodeId node_id) const { return true; }\n+\n+void SockMan::EventIOLoopCompletedForNode(NodeId node_id) {}\n+\n+void SockMan::EventIOLoopCompletedForAllPeers() {}\n+\n+void SockMan::EventI2PListen(const CService&, bool) {}\n+\n+void SockMan::TestOnlyAddExistentNode(NodeId node_id, std::unique_ptr<Sock>&& sock)\n+{\n+    LOCK(m_connected_mutex);\n+    const auto result{m_connected.emplace(node_id, std::make_shared<NodeSockets>(std::move(sock)))};\n+    assert(result.second);\n+}\n+\n+void SockMan::ThreadI2PAccept()\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    static constexpr auto err_wait_begin = 1s;\n+    static constexpr auto err_wait_cap = 5min;\n+    auto err_wait = err_wait_begin;\n+\n+    i2p::Connection conn;\n+\n+    auto SleepOnFailure = [&]() {\n+        interruptNet.sleep_for(err_wait);\n+        if (err_wait < err_wait_cap) {\n+            err_wait += 1s;\n+        }\n+    };\n+\n+    while (!interruptNet) {\n+\n+        if (!m_i2p_sam_session->Listen(conn)) {\n+            EventI2PListen(conn.me, /*success=*/false);\n+            SleepOnFailure();\n+            continue;\n+        }\n+\n+        EventI2PListen(conn.me, /*success=*/true);\n+\n+        if (!m_i2p_sam_session->Accept(conn)) {\n+            SleepOnFailure();\n+            continue;\n+        }\n+\n+        NewSockAccepted(std::move(conn.sock), conn.me, conn.peer);\n+\n+        err_wait = err_wait_begin;\n+    }\n+}\n+\n+void SockMan::ThreadSocketHandler()\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    while (!interruptNet) {\n+        EventIOLoopCompletedForAllPeers();\n+\n+        // Check for the readiness of the already connected sockets and the\n+        // listening sockets in one call (\"readiness\" as in poll(2) or\n+        // select(2)). If none are ready, wait for a short while and return\n+        // empty sets.\n+        auto io_readiness{GenerateWaitSockets()};\n+        if (io_readiness.events_per_sock.empty() ||\n+            // WaitMany() may as well be a static method, the context of the first Sock in the vector is not relevant.\n+            !io_readiness.events_per_sock.begin()->first->WaitMany(SELECT_TIMEOUT,\n+                                                                   io_readiness.events_per_sock)) {\n+            interruptNet.sleep_for(SELECT_TIMEOUT);\n+        }\n+\n+        // Service (send/receive) each of the already connected sockets.\n+        SocketHandlerConnected(io_readiness);\n+\n+        // Accept new connections from listening sockets.\n+        SocketHandlerListening(io_readiness.events_per_sock);\n+    }\n+}\n+\n+std::unique_ptr<Sock> SockMan::AcceptConnection(const Sock& listen_sock, CService& addr)\n+{\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+\n+    auto sock{listen_sock.Accept(reinterpret_cast<sockaddr*>(&storage), &len)};\n+\n+    if (!sock) {\n+        const int err{WSAGetLastError()};\n+        if (err != WSAEWOULDBLOCK) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Error,\n+                          \"Cannot accept new connection: %s\\n\",\n+                          NetworkErrorString(err));\n+        }\n+        return {};\n+    }\n+\n+    if (!addr.SetSockAddr(reinterpret_cast<sockaddr*>(&storage))) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"Unknown socket family\\n\");\n+    }\n+\n+    return sock;\n+}\n+\n+void SockMan::NewSockAccepted(std::unique_ptr<Sock>&& sock, const CService& me, const CService& them)\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    if (!sock->IsSelectable()) {\n+        LogPrintf(\"connection from %s dropped: non-selectable socket\\n\", them.ToStringAddrPort());\n+        return;\n+    }\n+\n+    // According to the internet TCP_NODELAY is not carried into accepted sockets\n+    // on all platforms.  Set it again here just to be sure.\n+    const int on{1};\n+    if (sock->SetSockOpt(IPPROTO_TCP, TCP_NODELAY, &on, sizeof(on)) == SOCKET_ERROR) {\n+        LogDebug(BCLog::NET, \"connection from %s: unable to set TCP_NODELAY, continuing anyway\\n\",\n+                 them.ToStringAddrPort());\n+    }\n+\n+    const NodeId node_id{GetNewNodeId()};\n+\n+    {\n+        LOCK(m_connected_mutex);\n+        m_connected.emplace(node_id, std::make_shared<NodeSockets>(std::move(sock)));\n+    }\n+\n+    if (!EventNewConnectionAccepted(node_id, me, them)) {\n+        CloseConnection(node_id);\n+    }\n+}\n+\n+NodeId SockMan::GetNewNodeId()\n+{\n+    return m_next_node_id.fetch_add(1, std::memory_order_relaxed);\n+}\n+\n+SockMan::IOReadiness SockMan::GenerateWaitSockets()\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    IOReadiness io_readiness;\n+\n+    for (const auto& sock : m_listen) {\n+        io_readiness.events_per_sock.emplace(sock, Sock::Events{Sock::RECV});\n+    }\n+\n+    auto connected_snapshot{WITH_LOCK(m_connected_mutex, return m_connected;)};\n+\n+    for (const auto& [node_id, node_sockets] : connected_snapshot) {\n+        const bool select_recv{ShouldTryToRecv(node_id)};\n+        const bool select_send{ShouldTryToSend(node_id)};\n+        if (!select_recv && !select_send) continue;\n+\n+        Sock::Event event = (select_send ? Sock::SEND : 0) | (select_recv ? Sock::RECV : 0);\n+        io_readiness.events_per_sock.emplace(node_sockets->sock, Sock::Events{event});\n+        io_readiness.node_ids_per_sock.emplace(node_sockets->sock, node_id);\n+    }\n+\n+    return io_readiness;\n+}\n+\n+void SockMan::SocketHandlerConnected(const IOReadiness& io_readiness)\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    for (const auto& [sock, events] : io_readiness.events_per_sock) {\n+        if (interruptNet) {\n+            return;\n+        }\n+\n+        auto it{io_readiness.node_ids_per_sock.find(sock)};\n+        if (it == io_readiness.node_ids_per_sock.end()) {\n+            continue;\n+        }\n+        const NodeId node_id{it->second};\n+\n+        bool send_ready = events.occurred & Sock::SEND; // Sock::SEND could only be set if ShouldTryToSend() has returned true in GenerateWaitSockets().\n+        bool recv_ready = events.occurred & Sock::RECV; // Sock::RECV could only be set if ShouldTryToRecv() has returned true in GenerateWaitSockets().\n+        bool err_ready = events.occurred & Sock::ERR;\n+\n+        if (send_ready) {\n+            bool cancel_recv;\n+\n+            EventReadyToSend(node_id, cancel_recv);\n+\n+            if (cancel_recv) {\n+                recv_ready = false;\n+            }\n+        }\n+\n+        if (recv_ready || err_ready) {\n+            uint8_t buf[0x10000]; // typical socket buffer is 8K-64K\n+\n+            auto node_sockets{GetNodeSockets(node_id)};\n+            if (!node_sockets) {\n+                continue;\n+            }\n+\n+            const ssize_t nrecv{WITH_LOCK(\n+                node_sockets->mutex,\n+                return node_sockets->sock->Recv(buf, sizeof(buf), MSG_DONTWAIT);)};\n+\n+            switch (nrecv) {\n+            case -1: {\n+                const int err = WSAGetLastError();\n+                if (err != WSAEWOULDBLOCK && err != WSAEMSGSIZE && err != WSAEINTR && err != WSAEINPROGRESS) {\n+                    EventGotPermanentReadError(node_id, NetworkErrorString(err));\n+                }\n+                break;\n+            }\n+            case 0:\n+                EventGotEOF(node_id);\n+                break;\n+            default:\n+                EventGotData(node_id, buf, nrecv);\n+                break;",
      "path": "src/common/sockman.cpp",
      "position": null,
      "original_position": 492,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "7866c736c87a908cef75dc6901c9c0594c65b0eb",
      "in_reply_to_id": null,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Worth double-checking in case it doesn't hold for all third-party `recv()`-implementations?\r\n```suggestion\r\n            default:\r\n                Assert(nrecv > 0); // Should have caught all negative values above.\r\n                EventGotData(node_id, buf, nrecv);\r\n                break;\r\n```",
      "created_at": "2025-02-01T20:18:34Z",
      "updated_at": "2025-02-01T21:11:23Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1938338721",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1938338721"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": 490,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 492,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1939042762",
      "pull_request_review_id": 2589331430,
      "id": 1939042762,
      "node_id": "PRRC_kwDOABII585zk3HK",
      "diff_hunk": "@@ -0,0 +1,435 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#ifndef BITCOIN_COMMON_SOCKMAN_H\n+#define BITCOIN_COMMON_SOCKMAN_H\n+\n+#include <i2p.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <util/fs.h>\n+#include <util/sock.h>\n+#include <util/translation.h>\n+\n+#include <atomic>\n+#include <memory>\n+#include <queue>\n+#include <span>\n+#include <thread>\n+#include <variant>\n+#include <vector>\n+\n+typedef int64_t NodeId;\n+\n+/**\n+ * A socket manager class which handles socket operations.\n+ * To use this class, inherit from it and implement the pure virtual methods.\n+ * Handled operations:\n+ * - binding and listening on sockets\n+ * - starting of necessary threads to process socket operations\n+ * - accepting incoming connections\n+ * - making outbound connections\n+ * - closing connections\n+ * - waiting for IO readiness on sockets and doing send/recv accordingly\n+ */\n+class SockMan\n+{\n+public:\n+\n+    virtual ~SockMan() = default;\n+\n+    //\n+    // Non-virtual functions, to be reused by children classes.\n+    //\n+\n+    /**\n+     * Bind to a new address:port, start listening and add the listen socket to `m_listen`.\n+     * Should be called before `StartSocketsThreads()`.\n+     * @param[in] to Where to bind.\n+     * @param[out] errmsg Error string if an error occurs.\n+     * @retval true Success.\n+     * @retval false Failure, `strError` will be set.\n+     */\n+    bool BindAndStartListening(const CService& to, bilingual_str& errmsg);\n+\n+    /**\n+     * Options to influence `StartSocketsThreads()`.\n+     */\n+    struct Options {\n+        std::string_view socket_handler_thread_name;\n+\n+        struct I2P {\n+            explicit I2P(const fs::path& file, const Proxy& proxy, std::string_view accept_thread_name)\n+                : private_key_file{file},\n+                  sam_proxy{proxy},\n+                  accept_thread_name{accept_thread_name}\n+            {}\n+\n+            const fs::path private_key_file;\n+            const Proxy sam_proxy;\n+            const std::string_view accept_thread_name;\n+        };\n+\n+        /**\n+         * I2P options. If set then a thread will be started that will accept incoming I2P connections.\n+         */\n+        std::optional<I2P> i2p;\n+    };\n+\n+    /**\n+     * Start the necessary threads for sockets IO.\n+     */\n+    void StartSocketsThreads(const Options& options);\n+\n+    /**\n+     * Join (wait for) the threads started by `StartSocketsThreads()` to exit.\n+     */\n+    void JoinSocketsThreads();\n+\n+    /**\n+     * A more readable std::tuple<std::string, uint16_t> for host and port.\n+     */\n+    struct StringHostIntPort {\n+        const std::string& host;\n+        uint16_t port;\n+    };\n+\n+    /**\n+     * Make an outbound connection, save the socket internally and return a newly generated node id.\n+     * @param[in] to The address to connect to, either as CService or a host as string and port as\n+     * an integer, if the later is used, then `proxy` must be valid.\n+     * @param[in] is_important If true, then log failures with higher severity.\n+     * @param[in] proxy Proxy to connect through if `proxy.IsValid()` is true.\n+     * @param[out] proxy_failed If `proxy` is valid and the connection failed because of the\n+     * proxy, then it will be set to true.\n+     * @param[out] me If the connection was successful then this is set to the address on the\n+     * local side of the socket.\n+     * @return Newly generated node id, or std::nullopt if the operation fails.\n+     */\n+    std::optional<NodeId> ConnectAndMakeNodeId(const std::variant<CService, StringHostIntPort>& to,\n+                                               bool is_important,\n+                                               const Proxy& proxy,\n+                                               bool& proxy_failed,\n+                                               CService& me)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex, !m_unused_i2p_sessions_mutex);\n+\n+    /**\n+     * Disconnect a given peer by closing its socket and release resources occupied by it.\n+     * @return Whether the peer existed and its socket was closed by this call.\n+     */\n+    bool CloseConnection(NodeId node_id)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Try to send some data to the given node.\n+     * @param[in] node_id Identifier of the node to send to.\n+     * @param[in] data The data to send, it might happen that only a prefix of this is sent.\n+     * @param[in] will_send_more Used as an optimization if the caller knows that they will\n+     * be sending more data soon after this call.\n+     * @param[out] errmsg If <0 is returned then this will contain a human readable message\n+     * explaining the error.\n+     * @retval >=0 The number of bytes actually sent.\n+     * @retval <0 A permanent error has occurred.\n+     */\n+    ssize_t SendBytes(NodeId node_id,\n+                      std::span<const unsigned char> data,\n+                      bool will_send_more,\n+                      std::string& errmsg) const\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Close all sockets.\n+     */\n+    void CloseSockets();\n+\n+    /**\n+     * This is signaled when network activity should cease.\n+     * A pointer to it is saved in `m_i2p_sam_session`, so make sure that\n+     * the lifetime of `interruptNet` is not shorter than\n+     * the lifetime of `m_i2p_sam_session`.\n+     */\n+    CThreadInterrupt interruptNet;\n+\n+protected:\n+\n+    /**\n+     * During some tests mocked sockets are created outside of `SockMan`, make it\n+     * possible to add those so that send/recv can be exercised.\n+     */\n+    void TestOnlyAddExistentNode(NodeId node_id, std::unique_ptr<Sock>&& sock)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+private:\n+\n+    /**\n+     * Cap on the size of `m_unused_i2p_sessions`, to ensure it does not\n+     * unexpectedly use too much memory.\n+     */\n+    static constexpr size_t MAX_UNUSED_I2P_SESSIONS_SIZE{10};\n+\n+    //\n+    // Pure virtual functions must be implemented by children classes.\n+    //\n+\n+    /**\n+     * Be notified when a new connection has been accepted.\n+     * @param[in] node_id Id of the newly accepted connection.\n+     * @param[in] me The address and port at our side of the connection.\n+     * @param[in] them The address and port at the peer's side of the connection.\n+     * @retval true The new connection was accepted at the higher level.\n+     * @retval false The connection was refused at the higher level, so the\n+     * associated socket and node_id should be discarded by `SockMan`.\n+     */\n+    virtual bool EventNewConnectionAccepted(NodeId node_id,\n+                                            const CService& me,\n+                                            const CService& them) = 0;\n+\n+    /**\n+     * Called when the socket is ready to send data and `ShouldTryToSend()` has\n+     * returned true. This is where the higher level code serializes its messages\n+     * and calls `SockMan::SendBytes()`.\n+     * @param[in] node_id Id of the node whose socket is ready to send.\n+     * @param[out] cancel_recv Should always be set upon return and if it is true,\n+     * then the next attempt to receive data from that node will be omitted.\n+     */\n+    virtual void EventReadyToSend(NodeId node_id, bool& cancel_recv) = 0;\n+\n+    /**\n+     * Called when new data has been received.\n+     * @param[in] node_id Node for which the data arrived.\n+     * @param[in] data Data buffer.\n+     * @param[in] n Number of bytes in `data`.\n+     */\n+    virtual void EventGotData(NodeId node_id, const uint8_t* data, size_t n) = 0;\n+\n+    /**\n+     * Called when the remote peer has sent an EOF on the socket. This is a graceful\n+     * close of their writing side, we can still send and they will receive, if it\n+     * makes sense at the application level.\n+     * @param[in] node_id Node whose socket got EOF.\n+     */\n+    virtual void EventGotEOF(NodeId node_id) = 0;\n+\n+    /**\n+     * Called when we get an irrecoverable error trying to read from a socket.\n+     * @param[in] node_id Node whose socket got an error.\n+     * @param[in] errmsg Message describing the error.\n+     */\n+    virtual void EventGotPermanentReadError(NodeId node_id, const std::string& errmsg) = 0;\n+\n+    //\n+    // Non-pure virtual functions can be overridden by children classes or left\n+    // alone to use the default implementation from SockMan.\n+    //\n+\n+    /**\n+     * Can be used to temporarily pause sends for a node.\n+     * SockMan would only call EventReadyToSend() if this returns true.\n+     * The implementation in SockMan always returns true.\n+     * @param[in] node_id Node for which to confirm or cancel a call to EventReadyToSend().\n+     */\n+    virtual bool ShouldTryToSend(NodeId node_id) const;\n+\n+    /**\n+     * SockMan would only call Recv() on a node's socket if this returns true.\n+     * Can be used to temporarily pause receives for a node.\n+     * The implementation in SockMan always returns true.\n+     * @param[in] node_id Node for which to confirm or cancel a receive.\n+     */\n+    virtual bool ShouldTryToRecv(NodeId node_id) const;\n+\n+    /**\n+     * SockMan has completed the current send+recv iteration for a node.\n+     * It will do another send+recv for this node after processing all other nodes.\n+     * Can be used to execute periodic tasks for a given node.\n+     * The implementation in SockMan does nothing.\n+     * @param[in] node_id Node for which send+recv has been done.\n+     */\n+    virtual void EventIOLoopCompletedForNode(NodeId node_id);\n+\n+    /**\n+     * SockMan has completed send+recv for all nodes.\n+     * Can be used to execute periodic tasks for all nodes, like disconnecting\n+     * nodes due to higher level logic.\n+     * The implementation in SockMan does nothing.\n+     */\n+    virtual void EventIOLoopCompletedForAllPeers();\n+\n+    /**\n+     * Be notified of a change in the state of listening for incoming I2P connections.\n+     * The default behavior, implemented by `SockMan`, is to ignore this event.\n+     * @param[in] addr Our listening address.\n+     * @param[in] success If true then the listen succeeded and we are now\n+     * listening for incoming I2P connections at `addr`. If false then the\n+     * call failed and now we are not listening (even if this was invoked\n+     * before with `true`).\n+     */\n+    virtual void EventI2PListen(const CService& addr, bool success);\n+\n+    /**\n+     * The sockets used by a connected node - a data socket and an optional I2P session.\n+     */\n+    struct NodeSockets {\n+        explicit NodeSockets(std::unique_ptr<Sock>&& s)\n+            : sock{std::move(s)}\n+        {\n+        }\n+\n+        explicit NodeSockets(std::shared_ptr<Sock>&& s, std::unique_ptr<i2p::sam::Session>&& sess)\n+            : sock{std::move(s)},\n+              i2p_transient_session{std::move(sess)}\n+        {\n+        }\n+\n+        /**\n+         * Mutex that serializes the Send() and Recv() calls on `sock`.\n+         */\n+        Mutex mutex;\n+\n+        /**\n+         * Underlying socket.\n+         * `shared_ptr` (instead of `unique_ptr`) is used to avoid premature close of the\n+         * underlying file descriptor by one thread while another thread is poll(2)-ing\n+         * it for activity.\n+         * @see https://github.com/bitcoin/bitcoin/issues/21744 for details.\n+         */\n+        std::shared_ptr<Sock> sock;\n+\n+        /**\n+         * When transient I2P sessions are used, then each node has its own session, otherwise\n+         * all nodes use the session from `m_i2p_sam_session` and share the same I2P address.\n+         * I2P sessions involve a data/transport socket (in `sock`) and a control socket\n+         * (in `i2p_transient_session`). For transient sessions, once the data socket `sock` is\n+         * closed, the control socket is not going to be used anymore and would be just taking\n+         * resources. Storing it here makes its deletion together with `sock` automatic.\n+         */\n+        std::unique_ptr<i2p::sam::Session> i2p_transient_session;\n+    };\n+\n+    /**\n+     * Info about which socket has which event ready and its node id.\n+     */\n+    struct IOReadiness {\n+        Sock::EventsPerSock events_per_sock;\n+        std::unordered_map<Sock::EventsPerSock::key_type, NodeId> node_ids_per_sock;\n+    };\n+\n+    /**\n+     * Accept incoming I2P connections in a loop and call\n+     * `EventNewConnectionAccepted()` for each new connection.\n+     */\n+    void ThreadI2PAccept()\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Check connected and listening sockets for IO readiness and process them accordingly.\n+     */\n+    void ThreadSocketHandler()\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Accept a connection.\n+     * @param[in] listen_sock Socket on which to accept the connection.\n+     * @param[out] addr Address of the peer that was accepted.\n+     * @return Newly created socket for the accepted connection.\n+     */\n+    std::unique_ptr<Sock> AcceptConnection(const Sock& listen_sock, CService& addr);\n+\n+    /**\n+     * After a new socket with a peer has been created, configure its flags,\n+     * make a new node id and call `EventNewConnectionAccepted()`.\n+     * @param[in] sock The newly created socket.\n+     * @param[in] me Address at our end of the connection.\n+     * @param[in] them Address of the new peer.\n+     */\n+    void NewSockAccepted(std::unique_ptr<Sock>&& sock, const CService& me, const CService& them)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Generate an id for a newly created node.\n+     */\n+    NodeId GetNewNodeId();\n+\n+    /**\n+     * Generate a collection of sockets to check for IO readiness.\n+     * @return Sockets to check for readiness plus an aux map to find the\n+     * corresponding node id given a socket.\n+     */\n+    IOReadiness GenerateWaitSockets()\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Do the read/write for connected sockets that are ready for IO.\n+     * @param[in] io_readiness Which sockets are ready and their node ids.\n+     */\n+    void SocketHandlerConnected(const IOReadiness& io_readiness)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Accept incoming connections, one from each read-ready listening socket.\n+     * @param[in] events_per_sock Sockets that are ready for IO.\n+     */\n+    void SocketHandlerListening(const Sock::EventsPerSock& events_per_sock)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Retrieve an entry from m_connected.\n+     * @param[in] node_id Node id to search for.\n+     * @return NodeSockets for the given node id or empty shared_ptr if not found.\n+     */\n+    std::shared_ptr<NodeSockets> GetNodeSockets(NodeId node_id) const\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * The id to assign to the next created node. Used to generate ids of nodes.\n+     */\n+    std::atomic<NodeId> m_next_node_id{0};\n+\n+    /**\n+     * Thread that sends to and receives from sockets and accepts connections.\n+     */\n+    std::thread m_thread_socket_handler;\n+\n+    /**\n+     * Thread that accepts incoming I2P connections in a loop, can be stopped via `interruptNet`.\n+     */\n+    std::thread m_thread_i2p_accept;\n+\n+    /**\n+     * Mutex protecting m_i2p_sam_sessions.\n+     */\n+    Mutex m_unused_i2p_sessions_mutex;\n+\n+    /**\n+     * A pool of created I2P SAM transient sessions that should be used instead\n+     * of creating new ones in order to reduce the load on the I2P network.\n+     * Creating a session in I2P is not cheap, thus if this is not empty, then\n+     * pick an entry from it instead of creating a new session. If connecting to\n+     * a host fails, then the created session is put to this pool for reuse.\n+     */\n+    std::queue<std::unique_ptr<i2p::sam::Session>> m_unused_i2p_sessions GUARDED_BY(m_unused_i2p_sessions_mutex);\n+\n+    /**\n+     * I2P SAM session.\n+     * Used to accept incoming and make outgoing I2P connections from a persistent\n+     * address.\n+     */\n+    std::unique_ptr<i2p::sam::Session> m_i2p_sam_session;\n+\n+    /**\n+     * List of listening sockets.\n+     */\n+    std::vector<std::shared_ptr<Sock>> m_listen;",
      "path": "src/common/sockman.h",
      "position": 451,
      "original_position": 423,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "266ac3267390270e6794d478aa1fbe40e88ffb0f",
      "in_reply_to_id": 1934722181,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "It's easier to read in doxygen html, and can always be expanded.",
      "created_at": "2025-02-03T09:19:44Z",
      "updated_at": "2025-02-03T09:19:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1939042762",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1939042762"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": 448,
      "original_start_line": 420,
      "start_side": "RIGHT",
      "line": 451,
      "original_line": 451,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1939058572",
      "pull_request_review_id": 2589357825,
      "id": 1939058572,
      "node_id": "PRRC_kwDOABII585zk6-M",
      "diff_hunk": "@@ -0,0 +1,533 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+#include <cassert>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+static CService GetBindAddress(const Sock& sock)\n+{\n+    CService addr_bind;\n+    struct sockaddr_storage sockaddr_bind;\n+    socklen_t sockaddr_bind_len = sizeof(sockaddr_bind);\n+    if (!sock.GetSockName((struct sockaddr*)&sockaddr_bind, &sockaddr_bind_len)) {\n+        addr_bind.SetSockAddr((const struct sockaddr*)&sockaddr_bind);\n+    } else {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"getsockname failed\\n\");\n+    }\n+    return addr_bind;\n+}\n+\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& errmsg)\n+{\n+    // Create socket for listening for incoming connections\n+    struct sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {\n+        errmsg = Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()));\n+        return false;\n+    }\n+\n+    std::unique_ptr<Sock> sock{CreateSock(to.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP)};\n+    if (!sock) {\n+        errmsg = Untranslated(strprintf(\"Cannot create %s listen socket: %s\",\n+                                        to.ToStringAddrPort(),\n+                                        NetworkErrorString(WSAGetLastError())));\n+        return false;\n+    }\n+\n+    int one{1};\n+\n+    // Allow binding if the port is still in TIME_WAIT state after\n+    // the program was closed and restarted.\n+    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+        LogPrintLevel(BCLog::NET,\n+                      BCLog::Level::Info,\n+                      \"Cannot set SO_REUSEADDR on %s listen socket: %s, continuing anyway\\n\",\n+                      to.ToStringAddrPort(),\n+                      NetworkErrorString(WSAGetLastError()));\n+    }\n+\n+    // some systems don't have IPV6_V6ONLY but are always v6only; others do have the option\n+    // and enable it by default or not. Try to enable it, if possible.\n+    if (to.IsIPv6()) {\n+#ifdef IPV6_V6ONLY\n+        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_V6ONLY on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+#ifdef WIN32\n+        int prot_level{PROTECTION_LEVEL_UNRESTRICTED};\n+        if (sock->SetSockOpt(IPPROTO_IPV6,\n+                             IPV6_PROTECTION_LEVEL,\n+                             reinterpret_cast<const char*>(&prot_level),\n+                             sizeof(prot_level)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_PROTECTION_LEVEL on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+    }\n+\n+    if (sock->Bind(reinterpret_cast<sockaddr*>(&storage), len) == SOCKET_ERROR) {\n+        const int err{WSAGetLastError()};\n+        errmsg = strprintf(_(\"Cannot bind to %s: %s%s\"),\n+                           to.ToStringAddrPort(),\n+                           NetworkErrorString(err),\n+                           err == WSAEADDRINUSE\n+                               ? std::string{\" (\"} + CLIENT_NAME + \" already running?)\"\n+                               : \"\");\n+        return false;\n+    }\n+\n+    // Listen for incoming connections\n+    if (sock->Listen(SOMAXCONN) == SOCKET_ERROR) {\n+        errmsg = strprintf(_(\"Cannot listen to %s: %s\"), to.ToStringAddrPort(), NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    m_listen.emplace_back(std::move(sock));\n+\n+    return true;\n+}\n+\n+void SockMan::StartSocketsThreads(const Options& options)\n+{\n+    m_thread_socket_handler = std::thread(\n+        &util::TraceThread, options.socket_handler_thread_name, [this] { ThreadSocketHandler(); });\n+\n+    if (options.i2p.has_value()) {\n+        m_i2p_sam_session = std::make_unique<i2p::sam::Session>(\n+            options.i2p->private_key_file, options.i2p->sam_proxy, &interruptNet);\n+\n+        m_thread_i2p_accept =\n+            std::thread(&util::TraceThread, options.i2p->accept_thread_name, [this] { ThreadI2PAccept(); });\n+    }\n+}\n+\n+void SockMan::JoinSocketsThreads()\n+{\n+    if (m_thread_i2p_accept.joinable()) {\n+        m_thread_i2p_accept.join();\n+    }\n+\n+    if (m_thread_socket_handler.joinable()) {\n+        m_thread_socket_handler.join();\n+    }\n+}\n+\n+std::optional<NodeId>\n+SockMan::ConnectAndMakeNodeId(const std::variant<CService, StringHostIntPort>& to,\n+                              bool is_important,\n+                              const Proxy& proxy,\n+                              bool& proxy_failed,\n+                              CService& me)\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+    AssertLockNotHeld(m_unused_i2p_sessions_mutex);\n+\n+    std::unique_ptr<Sock> sock;\n+    std::unique_ptr<i2p::sam::Session> i2p_transient_session;\n+\n+    Assume(!me.IsValid());\n+\n+    if (std::holds_alternative<CService>(to)) {\n+        const CService& addr_to{std::get<CService>(to)};\n+        if (addr_to.IsI2P()) {\n+            if (!Assume(proxy.IsValid())) {\n+                return std::nullopt;\n+            }\n+\n+            i2p::Connection conn;\n+            bool connected{false};\n+\n+            if (m_i2p_sam_session) {\n+                connected = m_i2p_sam_session->Connect(addr_to, conn, proxy_failed);\n+            } else {\n+                {\n+                    LOCK(m_unused_i2p_sessions_mutex);\n+                    if (m_unused_i2p_sessions.empty()) {\n+                        i2p_transient_session = std::make_unique<i2p::sam::Session>(proxy, &interruptNet);\n+                    } else {\n+                        i2p_transient_session.swap(m_unused_i2p_sessions.front());\n+                        m_unused_i2p_sessions.pop();\n+                    }\n+                }\n+                connected = i2p_transient_session->Connect(addr_to, conn, proxy_failed);\n+                if (!connected) {\n+                    LOCK(m_unused_i2p_sessions_mutex);\n+                    if (m_unused_i2p_sessions.size() < MAX_UNUSED_I2P_SESSIONS_SIZE) {\n+                        m_unused_i2p_sessions.emplace(i2p_transient_session.release());\n+                    }\n+                }\n+            }\n+\n+            if (connected) {\n+                sock = std::move(conn.sock);\n+                me = conn.me;\n+            }\n+        } else if (proxy.IsValid()) {\n+            sock = ConnectThroughProxy(proxy, addr_to.ToStringAddr(), addr_to.GetPort(), proxy_failed);\n+        } else {\n+            sock = ConnectDirectly(addr_to, is_important);\n+        }\n+    } else {\n+        if (!Assume(proxy.IsValid())) {\n+            return std::nullopt;\n+        }\n+\n+        const auto& hostport{std::get<StringHostIntPort>(to)};\n+\n+        bool dummy_proxy_failed;\n+        sock = ConnectThroughProxy(proxy, hostport.host, hostport.port, dummy_proxy_failed);\n+    }\n+\n+    if (!sock) {\n+        return std::nullopt;\n+    }\n+\n+    if (!me.IsValid()) {\n+        me = GetBindAddress(*sock);\n+    }\n+\n+    const NodeId node_id{GetNewNodeId()};\n+\n+    {\n+        LOCK(m_connected_mutex);\n+        m_connected.emplace(node_id, std::make_shared<NodeSockets>(std::move(sock),\n+                                                                   std::move(i2p_transient_session)));\n+    }\n+\n+    return node_id;\n+}\n+\n+bool SockMan::CloseConnection(NodeId node_id)\n+{\n+    LOCK(m_connected_mutex);\n+    return m_connected.erase(node_id) > 0;\n+}\n+\n+ssize_t SockMan::SendBytes(NodeId node_id,\n+                           std::span<const unsigned char> data,\n+                           bool will_send_more,\n+                           std::string& errmsg) const\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    if (data.empty()) {\n+        return 0;\n+    }\n+\n+    auto node_sockets{GetNodeSockets(node_id)};\n+    if (!node_sockets) {\n+        // Bail out immediately and just leave things in the caller's send queue.\n+        return 0;\n+    }\n+\n+    int flags{MSG_NOSIGNAL | MSG_DONTWAIT};\n+#ifdef MSG_MORE\n+    if (will_send_more) {\n+        flags |= MSG_MORE;\n+    }\n+#endif\n+\n+    const ssize_t sent{WITH_LOCK(\n+        node_sockets->mutex,\n+        return node_sockets->sock->Send(reinterpret_cast<const char*>(data.data()), data.size(), flags);)};\n+\n+    if (sent >= 0) {\n+        return sent;\n+    }\n+\n+    const int err{WSAGetLastError()};\n+    if (err == WSAEWOULDBLOCK || err == WSAEMSGSIZE || err == WSAEINTR || err == WSAEINPROGRESS) {\n+        return 0;\n+    }\n+    errmsg = NetworkErrorString(err);\n+    return -1;\n+}\n+\n+void SockMan::CloseSockets()",
      "path": "src/common/sockman.cpp",
      "position": null,
      "original_position": 267,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "266ac3267390270e6794d478aa1fbe40e88ffb0f",
      "in_reply_to_id": 1934731306,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "IIUC the difference between release and close is only relevant in edge cases. The main purpose of this function it to close them. I would keep the name, but maybe document the function to point out the edge case.",
      "created_at": "2025-02-03T09:30:21Z",
      "updated_at": "2025-02-03T09:30:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1939058572",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1939058572"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 267,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1939064794",
      "pull_request_review_id": 2589367577,
      "id": 1939064794,
      "node_id": "PRRC_kwDOABII585zk8fa",
      "diff_hunk": "@@ -3212,13 +2972,18 @@ bool CConnman::Bind(const CService& addr_, unsigned int flags, NetPermissionFlag\n     const CService addr{MaybeFlipIPv6toCJDNS(addr_)};\n \n     bilingual_str strError;\n-    if (!BindListenPort(addr, strError, permissions)) {\n+    if (!BindAndStartListening(addr, strError)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"%s\\n\", strError.original);",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 1120,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "266ac3267390270e6794d478aa1fbe40e88ffb0f",
      "in_reply_to_id": 1934736289,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "According to developer notes, `LogError` is for:\r\n\r\n> severe problems that require the node (or a subsystem) to shut down\r\n  entirely\r\n\r\nAnd IIUC we indeed shut down here.\r\n",
      "created_at": "2025-02-03T09:34:24Z",
      "updated_at": "2025-02-03T09:34:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1939064794",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1939064794"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2975,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1939369971",
      "pull_request_review_id": 2589896239,
      "id": 1939369971,
      "node_id": "PRRC_kwDOABII585zmG_z",
      "diff_hunk": "@@ -1696,10 +1696,14 @@ bool CConnman::AttemptToEvictConnection()\n     return false;\n }\n \n-void CConnman::EventNewConnectionAccepted(std::unique_ptr<Sock>&& sock,\n-                                          const CService& addr_bind,\n-                                          const CService& addr)\n+void CConnman::EventNewConnectionAccepted(NodeId node_id,\n+                                          std::unique_ptr<Sock>&& sock,\n+                                          const CService& addr_bind_,\n+                                          const CService& addr_)\n {\n+    const CService addr_bind{MaybeFlipIPv6toCJDNS(addr_bind_)};\n+    const CService addr{MaybeFlipIPv6toCJDNS(addr_)};",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 13,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "0be688360318511ecebcfc9cbabacfa6960fa5ef",
      "in_reply_to_id": 1937072454,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "`MaybeFlipIPv6toCJDNS` only does something if `addr_(bind_)` `IsIPv6()`, which checks `m_net == NET_IPV6`. \r\n\r\nThis is the default for a `CNetAddr`, however deeply buried in `ThreadI2PAccept` - > `i2p::sam::Session::Accept` -> `DestB64ToAddr` -> `DestBinToAddr` -> `CNetAddr::SetSpecial` -> `SetI2P`  do we find `m_net = NET_I2P`. So the flip won't interfere with an I2P connection (in the case its prefix coincidentally matches the IPv6 CJDNS prefix).\r\n\r\nBut maybe you should add a `Assume(IsI2P(conn.peer))`;\r\n\r\n(in 0be688360318511ecebcfc9cbabacfa6960fa5ef \"net: tweak EventNewConnectionAccepted()\")",
      "created_at": "2025-02-03T13:22:17Z",
      "updated_at": "2025-02-03T13:33:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1939369971",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1939369971"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": 1699,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1705,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1939396960",
      "pull_request_review_id": 2589941779,
      "id": 1939396960,
      "node_id": "PRRC_kwDOABII585zmNlg",
      "diff_hunk": "@@ -454,52 +439,29 @@ CNode* CConnman::ConnectNode(CAddress addrConnect, const char *pszDest, bool fCo\n     // Connect\n     std::unique_ptr<Sock> sock;\n     Proxy proxy;\n-    CService addr_bind;\n-    assert(!addr_bind.IsValid());\n+    assert(!proxy.IsValid());",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 30,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "91d97a198fb57d47870ce094454c3776bc737ba0",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In 91d97a198fb57d47870ce094454c3776bc737ba0 \"net: split CConnman::ConnectNode()\": why this new `assert`? If you need it all, maybe make it an `Assume`?",
      "created_at": "2025-02-03T13:41:29Z",
      "updated_at": "2025-02-03T13:56:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1939396960",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1939396960"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 442,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1939408935",
      "pull_request_review_id": 2589941779,
      "id": 1939408935,
      "node_id": "PRRC_kwDOABII585zmQgn",
      "diff_hunk": "@@ -79,6 +84,37 @@ class SockMan\n      */\n     void JoinSocketsThreads();\n \n+    /**\n+     * A more readable std::tuple<std::string, uint16_t> for host and port.\n+     */\n+    struct StringHostIntPort {\n+        const std::string& host;\n+        uint16_t port;\n+    };\n+\n+    /**\n+     * Make an outbound connection, save the socket internally and return a newly generated node id.\n+     * @param[in] to The address to connect to, either as CService or a host as string and port as\n+     * an integer, if the later is used, then `proxy` must be valid.\n+     * @param[in] is_important If true, then log failures with higher severity.\n+     * @param[in] proxy Proxy to connect through if `proxy.IsValid()` is true.",
      "path": "src/common/sockman.h",
      "position": null,
      "original_position": 41,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "91d97a198fb57d47870ce094454c3776bc737ba0",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In 91d97a198fb57d47870ce094454c3776bc737ba0 \"net: split CConnman::ConnectNode()\": looking at the body of `ConnectAndMakeNodeId` the code paths with and without proxy are vastly different. They also have separate call sites.\r\n\r\nSo instead of using an `std::variant`, it seems more clear to just have both `ConnectAndMakeNodeId` and `ProxyConnectAndMakeNodeId`.",
      "created_at": "2025-02-03T13:49:55Z",
      "updated_at": "2025-02-03T13:56:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1939408935",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1939408935"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 100,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1944720234",
      "pull_request_review_id": 2598666946,
      "id": 1944720234,
      "node_id": "PRRC_kwDOABII585z6hNq",
      "diff_hunk": "@@ -9,9 +9,12 @@\n #include <util/sock.h>\n #include <util/translation.h>\n \n+#include <atomic>\n #include <memory>\n #include <vector>\n \n+typedef int64_t NodeId;",
      "path": "src/common/sockman.h",
      "position": null,
      "original_position": 8,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "5d4920f630417ceeee1c79304faac6803795cd64",
      "in_reply_to_id": 1804940161,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Changed. This is now `SockMan::Id` and in `net.h`: `using NodeId = SockMan::Id;`. In SockMan comments change the word \"node\" to \"connection\". This caused a lot of mechanical renames within this PR, but it looks better now, thanks!\r\n\r\n`SockMan::GetNewNodeId()` renamed to\r\n`SockMan::GetNewId()`\r\n\r\n`SockMan::EventIOLoopCompletedForNode()` renamed to\r\n`SockMan::EventIOLoopCompletedForOne()`\r\n\r\n`SockMan::EventIOLoopCompletedForAllPeers()` renamed to\r\n`SockMan::EventIOLoopCompletedForAll()`\r\n\r\n`SockMan::ConnectAndMakeNodeId()` renamed to\r\n`SockMan::ConnectAndMakeId()`.\r\n\r\nWill be in next push.",
      "created_at": "2025-02-06T13:24:45Z",
      "updated_at": "2025-02-06T13:24:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1944720234",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1944720234"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 23,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1944816545",
      "pull_request_review_id": 2598833936,
      "id": 1944816545,
      "node_id": "PRRC_kwDOABII585z64uh",
      "diff_hunk": "@@ -59,6 +66,26 @@ class SockMan\n \n private:\n \n+    //\n+    // Pure virtual functions must be implemented by children classes.\n+    //\n+\n+    //\n+    // Non-pure virtual functions can be overridden by children classes or left\n+    // alone to use the default implementation from SockMan.\n+    //\n+\n+    /**\n+     * Be notified of a change in the state of listening for incoming I2P connections.\n+     * The default behavior, implemented by `SockMan`, is to ignore this event.\n+     * @param[in] addr Our listening address.\n+     * @param[in] success If true then the listen succeeded and we are now",
      "path": "src/common/sockman.h",
      "position": null,
      "original_position": 31,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "14fcef6b0d1d1fa9395f9af2bafbf3de63d14ac2",
      "in_reply_to_id": 1916636569,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Changed to `EventI2PStatus()` and instead of `bool` it now takes an enum with (currently) two possible values: `START_LISTENING` and `STOP_LISTENING`. Will be in next push.",
      "created_at": "2025-02-06T14:23:44Z",
      "updated_at": "2025-02-06T14:23:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1944816545",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1944816545"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 263,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1944828644",
      "pull_request_review_id": 2598853964,
      "id": 1944828644,
      "node_id": "PRRC_kwDOABII585z67rk",
      "diff_hunk": "@@ -1312,6 +1312,12 @@ class CConnman : private SockMan\n     virtual bool ShouldTryToRecv(NodeId node_id) const override\n         EXCLUSIVE_LOCKS_REQUIRED(!m_nodes_mutex);\n \n+    virtual void EventIOLoopCompletedForNode(NodeId node_id) override\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_nodes_mutex);\n+\n+    virtual void EventIOLoopCompletedForAllPeers() override\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_nodes_mutex, !m_reconnections_mutex);\n+ ",
      "path": "src/net.h",
      "position": null,
      "original_position": 9,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "248ec2d2687fae47b63688e00b9ef18d4c0c9676",
      "in_reply_to_id": 1935808313,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Fixed.",
      "created_at": "2025-02-06T14:30:31Z",
      "updated_at": "2025-02-06T14:30:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1944828644",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1944828644"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1320,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1944876407",
      "pull_request_review_id": 2598933914,
      "id": 1944876407,
      "node_id": "PRRC_kwDOABII585z7HV3",
      "diff_hunk": "@@ -42,9 +42,6 @@ FUZZ_TARGET(net, .init = initialize_net)\n     LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10000) {\n         CallOneOf(\n             fuzzed_data_provider,\n-            [&] {\n-                node.CloseSocketDisconnect();",
      "path": "src/test/fuzz/net.cpp",
      "position": 5,
      "original_position": 5,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "f7dd4373b06daf34033fa84fa99408a3938e4ad4",
      "in_reply_to_id": 1936898358,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Yes, done.",
      "created_at": "2025-02-06T14:56:57Z",
      "updated_at": "2025-02-06T14:56:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1944876407",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1944876407"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 46,
      "original_line": 46,
      "side": "LEFT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1944879162",
      "pull_request_review_id": 2598938658,
      "id": 1944879162,
      "node_id": "PRRC_kwDOABII585z7IA6",
      "diff_hunk": "@@ -0,0 +1,533 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+#include <cassert>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};",
      "path": "src/common/sockman.cpp",
      "position": 17,
      "original_position": 17,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "7866c736c87a908cef75dc6901c9c0594c65b0eb",
      "in_reply_to_id": null,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I think libevent might actually use `45` for the `poll()` loop: \r\n\r\nhttps://github.com/libevent/libevent/blob/112421c8fa4840acd73502f2ab6a674fc025de37/http-internal.h#L17-L20\r\n\r\nWhat's the best way to determine this constant? Sockman-based HTTP certainly gets through the functional test suite a lot faster when this value is reduced (I tried `10` here)",
      "created_at": "2025-02-06T14:58:32Z",
      "updated_at": "2025-02-06T14:58:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1944879162",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1944879162"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 17,
      "original_line": 17,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1944883037",
      "pull_request_review_id": 2598945429,
      "id": 1944883037,
      "node_id": "PRRC_kwDOABII585z7I9d",
      "diff_hunk": "@@ -267,17 +302,107 @@ class SockMan\n      */\n     virtual void EventI2PListen(const CService& addr, bool success);\n \n+    /**\n+     * The sockets used by a connected node - a data socket and an optional I2P session.\n+     */\n+    struct NodeSockets {",
      "path": "src/common/sockman.h",
      "position": null,
      "original_position": 146,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "f7dd4373b06daf34033fa84fa99408a3938e4ad4",
      "in_reply_to_id": 1937107332,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Yes, the I2P session contains a socket:\r\n\r\nhttps://github.com/bitcoin/bitcoin/blob/d6c229d8bd4a6203a7255c140aa35c59fb20378b/src/i2p.h#L251-L260",
      "created_at": "2025-02-06T15:00:51Z",
      "updated_at": "2025-02-06T15:00:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1944883037",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1944883037"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 308,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1944896725",
      "pull_request_review_id": 2598968703,
      "id": 1944896725,
      "node_id": "PRRC_kwDOABII585z7MTV",
      "diff_hunk": "@@ -267,17 +302,107 @@ class SockMan\n      */\n     virtual void EventI2PListen(const CService& addr, bool success);\n \n+    /**\n+     * The sockets used by a connected node - a data socket and an optional I2P session.\n+     */\n+    struct NodeSockets {\n+        explicit NodeSockets(std::unique_ptr<Sock>&& s)\n+            : sock{std::move(s)}\n+        {\n+        }\n+\n+        explicit NodeSockets(std::shared_ptr<Sock>&& s, std::unique_ptr<i2p::sam::Session>&& sess)\n+            : sock{std::move(s)},\n+              i2p_transient_session{std::move(sess)}\n+        {\n+        }\n+\n+        /**\n+         * Mutex that serializes the Send() and Recv() calls on `sock`.\n+         */\n+        Mutex mutex;\n+\n+        /**\n+         * Underlying socket.\n+         * `shared_ptr` (instead of `unique_ptr`) is used to avoid premature close of the\n+         * underlying file descriptor by one thread while another thread is poll(2)-ing\n+         * it for activity.\n+         * @see https://github.com/bitcoin/bitcoin/issues/21744 for details.\n+         */\n+        std::shared_ptr<Sock> sock;\n+\n+        /**\n+         * When transient I2P sessions are used, then each node has its own session, otherwise\n+         * all nodes use the session from `m_i2p_sam_session` and share the same I2P address.\n+         * I2P sessions involve a data/transport socket (in `sock`) and a control socket\n+         * (in `i2p_transient_session`). For transient sessions, once the data socket `sock` is\n+         * closed, the control socket is not going to be used anymore and would be just taking\n+         * resources. Storing it here makes its deletion together with `sock` automatic.\n+         */\n+        std::unique_ptr<i2p::sam::Session> i2p_transient_session;\n+    };\n+\n+    /**\n+     * Info about which socket has which event ready and its node id.\n+     */\n+    struct IOReadiness {\n+        Sock::EventsPerSock events_per_sock;\n+        std::unordered_map<Sock::EventsPerSock::key_type, NodeId> node_ids_per_sock;",
      "path": "src/common/sockman.h",
      "position": null,
      "original_position": 188,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "f7dd4373b06daf34033fa84fa99408a3938e4ad4",
      "in_reply_to_id": 1937302384,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-02-06T15:08:52Z",
      "updated_at": "2025-02-06T15:08:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1944896725",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1944896725"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 350,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1944904841",
      "pull_request_review_id": 2598982813,
      "id": 1944904841,
      "node_id": "PRRC_kwDOABII585z7OSJ",
      "diff_hunk": "@@ -297,3 +382,152 @@ void SockMan::ThreadI2PAccept()\n         err_wait = err_wait_begin;\n     }\n }\n+\n+void SockMan::ThreadSocketHandler()\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    while (!interruptNet) {\n+        EventIOLoopCompletedForAllPeers();\n+\n+        // Check for the readiness of the already connected sockets and the\n+        // listening sockets in one call (\"readiness\" as in poll(2) or\n+        // select(2)). If none are ready, wait for a short while and return\n+        // empty sets.\n+        auto io_readiness{GenerateWaitSockets()};\n+        if (io_readiness.events_per_sock.empty() ||\n+            // WaitMany() may as well be a static method, the context of the first Sock in the vector is not relevant.\n+            !io_readiness.events_per_sock.begin()->first->WaitMany(SELECT_TIMEOUT,\n+                                                                   io_readiness.events_per_sock)) {\n+            interruptNet.sleep_for(SELECT_TIMEOUT);\n+        }\n+\n+        // Service (send/receive) each of the already connected sockets.\n+        SocketHandlerConnected(io_readiness);\n+\n+        // Accept new connections from listening sockets.\n+        SocketHandlerListening(io_readiness.events_per_sock);\n+    }\n+}\n+\n+SockMan::IOReadiness SockMan::GenerateWaitSockets()\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    IOReadiness io_readiness;\n+\n+    for (const auto& sock : m_listen) {\n+        io_readiness.events_per_sock.emplace(sock, Sock::Events{Sock::RECV});\n+    }\n+\n+    auto connected_snapshot{WITH_LOCK(m_connected_mutex, return m_connected;)};\n+\n+    for (const auto& [node_id, node_sockets] : connected_snapshot) {\n+        const bool select_recv{ShouldTryToRecv(node_id)};\n+        const bool select_send{ShouldTryToSend(node_id)};\n+        if (!select_recv && !select_send) continue;\n+\n+        Sock::Event event = (select_send ? Sock::SEND : 0) | (select_recv ? Sock::RECV : 0);\n+        io_readiness.events_per_sock.emplace(node_sockets->sock, Sock::Events{event});\n+        io_readiness.node_ids_per_sock.emplace(node_sockets->sock, node_id);\n+    }\n+\n+    return io_readiness;\n+}\n+\n+void SockMan::SocketHandlerConnected(const IOReadiness& io_readiness)\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    for (const auto& [sock, events] : io_readiness.events_per_sock) {\n+        if (interruptNet) {\n+            return;\n+        }\n+\n+        auto it{io_readiness.node_ids_per_sock.find(sock)};\n+        if (it == io_readiness.node_ids_per_sock.end()) {\n+            continue;\n+        }\n+        const NodeId node_id{it->second};\n+\n+        bool send_ready = events.occurred & Sock::SEND; // Sock::SEND could only be set if ShouldTryToSend() has returned true in GenerateWaitSockets().\n+        bool recv_ready = events.occurred & Sock::RECV; // Sock::RECV could only be set if ShouldTryToRecv() has returned true in GenerateWaitSockets().\n+        bool err_ready = events.occurred & Sock::ERR;\n+\n+        if (send_ready) {\n+            bool cancel_recv;\n+\n+            EventReadyToSend(node_id, cancel_recv);\n+\n+            if (cancel_recv) {\n+                recv_ready = false;\n+            }\n+        }\n+\n+        if (recv_ready || err_ready) {\n+            uint8_t buf[0x10000]; // typical socket buffer is 8K-64K\n+\n+            auto node_sockets{GetNodeSockets(node_id)};\n+            if (!node_sockets) {\n+                continue;\n+            }\n+\n+            const ssize_t nrecv{WITH_LOCK(\n+                node_sockets->mutex,\n+                return node_sockets->sock->Recv(buf, sizeof(buf), MSG_DONTWAIT);)};\n+\n+            switch (nrecv) {",
      "path": "src/common/sockman.cpp",
      "position": null,
      "original_position": 261,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "f7dd4373b06daf34033fa84fa99408a3938e4ad4",
      "in_reply_to_id": 1937394233,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-02-06T15:13:38Z",
      "updated_at": "2025-02-06T15:13:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1944904841",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1944904841"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 479,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1945120612",
      "pull_request_review_id": 2599369355,
      "id": 1945120612,
      "node_id": "PRRC_kwDOABII585z8C9k",
      "diff_hunk": "@@ -0,0 +1,533 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+#include <cassert>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+static CService GetBindAddress(const Sock& sock)\n+{\n+    CService addr_bind;\n+    struct sockaddr_storage sockaddr_bind;\n+    socklen_t sockaddr_bind_len = sizeof(sockaddr_bind);\n+    if (!sock.GetSockName((struct sockaddr*)&sockaddr_bind, &sockaddr_bind_len)) {\n+        addr_bind.SetSockAddr((const struct sockaddr*)&sockaddr_bind);\n+    } else {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"getsockname failed\\n\");\n+    }\n+    return addr_bind;\n+}\n+\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& errmsg)\n+{\n+    // Create socket for listening for incoming connections\n+    struct sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {\n+        errmsg = Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()));\n+        return false;\n+    }\n+\n+    std::unique_ptr<Sock> sock{CreateSock(to.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP)};\n+    if (!sock) {\n+        errmsg = Untranslated(strprintf(\"Cannot create %s listen socket: %s\",\n+                                        to.ToStringAddrPort(),\n+                                        NetworkErrorString(WSAGetLastError())));\n+        return false;\n+    }\n+\n+    int one{1};\n+\n+    // Allow binding if the port is still in TIME_WAIT state after\n+    // the program was closed and restarted.\n+    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+        LogPrintLevel(BCLog::NET,\n+                      BCLog::Level::Info,\n+                      \"Cannot set SO_REUSEADDR on %s listen socket: %s, continuing anyway\\n\",\n+                      to.ToStringAddrPort(),\n+                      NetworkErrorString(WSAGetLastError()));\n+    }\n+\n+    // some systems don't have IPV6_V6ONLY but are always v6only; others do have the option\n+    // and enable it by default or not. Try to enable it, if possible.\n+    if (to.IsIPv6()) {\n+#ifdef IPV6_V6ONLY\n+        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_V6ONLY on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+#ifdef WIN32\n+        int prot_level{PROTECTION_LEVEL_UNRESTRICTED};\n+        if (sock->SetSockOpt(IPPROTO_IPV6,\n+                             IPV6_PROTECTION_LEVEL,\n+                             reinterpret_cast<const char*>(&prot_level),\n+                             sizeof(prot_level)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_PROTECTION_LEVEL on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+    }\n+\n+    if (sock->Bind(reinterpret_cast<sockaddr*>(&storage), len) == SOCKET_ERROR) {\n+        const int err{WSAGetLastError()};\n+        errmsg = strprintf(_(\"Cannot bind to %s: %s%s\"),\n+                           to.ToStringAddrPort(),\n+                           NetworkErrorString(err),\n+                           err == WSAEADDRINUSE\n+                               ? std::string{\" (\"} + CLIENT_NAME + \" already running?)\"\n+                               : \"\");\n+        return false;\n+    }\n+\n+    // Listen for incoming connections\n+    if (sock->Listen(SOMAXCONN) == SOCKET_ERROR) {\n+        errmsg = strprintf(_(\"Cannot listen to %s: %s\"), to.ToStringAddrPort(), NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    m_listen.emplace_back(std::move(sock));\n+\n+    return true;\n+}\n+\n+void SockMan::StartSocketsThreads(const Options& options)\n+{\n+    m_thread_socket_handler = std::thread(\n+        &util::TraceThread, options.socket_handler_thread_name, [this] { ThreadSocketHandler(); });\n+\n+    if (options.i2p.has_value()) {\n+        m_i2p_sam_session = std::make_unique<i2p::sam::Session>(\n+            options.i2p->private_key_file, options.i2p->sam_proxy, &interruptNet);\n+\n+        m_thread_i2p_accept =\n+            std::thread(&util::TraceThread, options.i2p->accept_thread_name, [this] { ThreadI2PAccept(); });\n+    }\n+}\n+\n+void SockMan::JoinSocketsThreads()\n+{\n+    if (m_thread_i2p_accept.joinable()) {\n+        m_thread_i2p_accept.join();\n+    }\n+\n+    if (m_thread_socket_handler.joinable()) {\n+        m_thread_socket_handler.join();\n+    }\n+}\n+\n+std::optional<NodeId>\n+SockMan::ConnectAndMakeNodeId(const std::variant<CService, StringHostIntPort>& to,\n+                              bool is_important,\n+                              const Proxy& proxy,\n+                              bool& proxy_failed,\n+                              CService& me)\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+    AssertLockNotHeld(m_unused_i2p_sessions_mutex);\n+\n+    std::unique_ptr<Sock> sock;\n+    std::unique_ptr<i2p::sam::Session> i2p_transient_session;\n+\n+    Assume(!me.IsValid());\n+\n+    if (std::holds_alternative<CService>(to)) {\n+        const CService& addr_to{std::get<CService>(to)};\n+        if (addr_to.IsI2P()) {\n+            if (!Assume(proxy.IsValid())) {\n+                return std::nullopt;\n+            }\n+\n+            i2p::Connection conn;\n+            bool connected{false};\n+\n+            if (m_i2p_sam_session) {\n+                connected = m_i2p_sam_session->Connect(addr_to, conn, proxy_failed);\n+            } else {\n+                {\n+                    LOCK(m_unused_i2p_sessions_mutex);\n+                    if (m_unused_i2p_sessions.empty()) {\n+                        i2p_transient_session = std::make_unique<i2p::sam::Session>(proxy, &interruptNet);\n+                    } else {\n+                        i2p_transient_session.swap(m_unused_i2p_sessions.front());\n+                        m_unused_i2p_sessions.pop();\n+                    }\n+                }\n+                connected = i2p_transient_session->Connect(addr_to, conn, proxy_failed);\n+                if (!connected) {\n+                    LOCK(m_unused_i2p_sessions_mutex);\n+                    if (m_unused_i2p_sessions.size() < MAX_UNUSED_I2P_SESSIONS_SIZE) {\n+                        m_unused_i2p_sessions.emplace(i2p_transient_session.release());\n+                    }\n+                }\n+            }\n+\n+            if (connected) {\n+                sock = std::move(conn.sock);\n+                me = conn.me;\n+            }\n+        } else if (proxy.IsValid()) {\n+            sock = ConnectThroughProxy(proxy, addr_to.ToStringAddr(), addr_to.GetPort(), proxy_failed);\n+        } else {\n+            sock = ConnectDirectly(addr_to, is_important);\n+        }\n+    } else {\n+        if (!Assume(proxy.IsValid())) {\n+            return std::nullopt;\n+        }\n+\n+        const auto& hostport{std::get<StringHostIntPort>(to)};\n+\n+        bool dummy_proxy_failed;\n+        sock = ConnectThroughProxy(proxy, hostport.host, hostport.port, dummy_proxy_failed);\n+    }\n+\n+    if (!sock) {\n+        return std::nullopt;\n+    }\n+\n+    if (!me.IsValid()) {\n+        me = GetBindAddress(*sock);\n+    }\n+\n+    const NodeId node_id{GetNewNodeId()};\n+\n+    {\n+        LOCK(m_connected_mutex);\n+        m_connected.emplace(node_id, std::make_shared<NodeSockets>(std::move(sock),\n+                                                                   std::move(i2p_transient_session)));\n+    }\n+\n+    return node_id;\n+}\n+\n+bool SockMan::CloseConnection(NodeId node_id)\n+{\n+    LOCK(m_connected_mutex);\n+    return m_connected.erase(node_id) > 0;\n+}\n+\n+ssize_t SockMan::SendBytes(NodeId node_id,\n+                           std::span<const unsigned char> data,\n+                           bool will_send_more,\n+                           std::string& errmsg) const\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    if (data.empty()) {\n+        return 0;\n+    }\n+\n+    auto node_sockets{GetNodeSockets(node_id)};\n+    if (!node_sockets) {\n+        // Bail out immediately and just leave things in the caller's send queue.\n+        return 0;\n+    }\n+\n+    int flags{MSG_NOSIGNAL | MSG_DONTWAIT};\n+#ifdef MSG_MORE\n+    if (will_send_more) {\n+        flags |= MSG_MORE;\n+    }\n+#endif\n+\n+    const ssize_t sent{WITH_LOCK(\n+        node_sockets->mutex,\n+        return node_sockets->sock->Send(reinterpret_cast<const char*>(data.data()), data.size(), flags);)};\n+\n+    if (sent >= 0) {\n+        return sent;\n+    }\n+\n+    const int err{WSAGetLastError()};\n+    if (err == WSAEWOULDBLOCK || err == WSAEMSGSIZE || err == WSAEINTR || err == WSAEINPROGRESS) {\n+        return 0;\n+    }\n+    errmsg = NetworkErrorString(err);\n+    return -1;\n+}\n+\n+void SockMan::CloseSockets()\n+{\n+    m_listen.clear();\n+}\n+\n+bool SockMan::ShouldTryToSend(NodeId node_id) const { return true; }\n+\n+bool SockMan::ShouldTryToRecv(NodeId node_id) const { return true; }\n+\n+void SockMan::EventIOLoopCompletedForNode(NodeId node_id) {}\n+\n+void SockMan::EventIOLoopCompletedForAllPeers() {}\n+\n+void SockMan::EventI2PListen(const CService&, bool) {}\n+\n+void SockMan::TestOnlyAddExistentNode(NodeId node_id, std::unique_ptr<Sock>&& sock)\n+{\n+    LOCK(m_connected_mutex);\n+    const auto result{m_connected.emplace(node_id, std::make_shared<NodeSockets>(std::move(sock)))};\n+    assert(result.second);\n+}\n+\n+void SockMan::ThreadI2PAccept()\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    static constexpr auto err_wait_begin = 1s;\n+    static constexpr auto err_wait_cap = 5min;\n+    auto err_wait = err_wait_begin;\n+\n+    i2p::Connection conn;\n+\n+    auto SleepOnFailure = [&]() {\n+        interruptNet.sleep_for(err_wait);\n+        if (err_wait < err_wait_cap) {\n+            err_wait += 1s;\n+        }\n+    };\n+\n+    while (!interruptNet) {\n+\n+        if (!m_i2p_sam_session->Listen(conn)) {\n+            EventI2PListen(conn.me, /*success=*/false);\n+            SleepOnFailure();\n+            continue;\n+        }\n+\n+        EventI2PListen(conn.me, /*success=*/true);\n+\n+        if (!m_i2p_sam_session->Accept(conn)) {\n+            SleepOnFailure();\n+            continue;\n+        }\n+\n+        NewSockAccepted(std::move(conn.sock), conn.me, conn.peer);\n+\n+        err_wait = err_wait_begin;\n+    }\n+}\n+\n+void SockMan::ThreadSocketHandler()\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    while (!interruptNet) {\n+        EventIOLoopCompletedForAllPeers();\n+\n+        // Check for the readiness of the already connected sockets and the\n+        // listening sockets in one call (\"readiness\" as in poll(2) or\n+        // select(2)). If none are ready, wait for a short while and return\n+        // empty sets.\n+        auto io_readiness{GenerateWaitSockets()};\n+        if (io_readiness.events_per_sock.empty() ||\n+            // WaitMany() may as well be a static method, the context of the first Sock in the vector is not relevant.\n+            !io_readiness.events_per_sock.begin()->first->WaitMany(SELECT_TIMEOUT,\n+                                                                   io_readiness.events_per_sock)) {\n+            interruptNet.sleep_for(SELECT_TIMEOUT);\n+        }",
      "path": "src/common/sockman.cpp",
      "position": 351,
      "original_position": 344,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "7866c736c87a908cef75dc6901c9c0594c65b0eb",
      "in_reply_to_id": null,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "if `WaitMany()` returns false, we would have already waited the duration of `SELECT_TIMEOUT` -- do we need to `sleep_for()` again?",
      "created_at": "2025-02-06T17:07:13Z",
      "updated_at": "2025-02-06T17:07:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1945120612",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1945120612"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": 346,
      "original_start_line": 339,
      "start_side": "RIGHT",
      "line": 351,
      "original_line": 351,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1945293526",
      "pull_request_review_id": 2599669056,
      "id": 1945293526,
      "node_id": "PRRC_kwDOABII585z8tLW",
      "diff_hunk": "@@ -0,0 +1,533 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+#include <cassert>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+static CService GetBindAddress(const Sock& sock)\n+{\n+    CService addr_bind;\n+    struct sockaddr_storage sockaddr_bind;\n+    socklen_t sockaddr_bind_len = sizeof(sockaddr_bind);\n+    if (!sock.GetSockName((struct sockaddr*)&sockaddr_bind, &sockaddr_bind_len)) {\n+        addr_bind.SetSockAddr((const struct sockaddr*)&sockaddr_bind);\n+    } else {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"getsockname failed\\n\");\n+    }\n+    return addr_bind;\n+}\n+\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& errmsg)\n+{\n+    // Create socket for listening for incoming connections\n+    struct sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {\n+        errmsg = Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()));\n+        return false;\n+    }\n+\n+    std::unique_ptr<Sock> sock{CreateSock(to.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP)};\n+    if (!sock) {\n+        errmsg = Untranslated(strprintf(\"Cannot create %s listen socket: %s\",\n+                                        to.ToStringAddrPort(),\n+                                        NetworkErrorString(WSAGetLastError())));\n+        return false;\n+    }\n+\n+    int one{1};\n+\n+    // Allow binding if the port is still in TIME_WAIT state after\n+    // the program was closed and restarted.\n+    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+        LogPrintLevel(BCLog::NET,\n+                      BCLog::Level::Info,\n+                      \"Cannot set SO_REUSEADDR on %s listen socket: %s, continuing anyway\\n\",\n+                      to.ToStringAddrPort(),\n+                      NetworkErrorString(WSAGetLastError()));\n+    }\n+\n+    // some systems don't have IPV6_V6ONLY but are always v6only; others do have the option\n+    // and enable it by default or not. Try to enable it, if possible.\n+    if (to.IsIPv6()) {\n+#ifdef IPV6_V6ONLY\n+        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_V6ONLY on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+#ifdef WIN32\n+        int prot_level{PROTECTION_LEVEL_UNRESTRICTED};\n+        if (sock->SetSockOpt(IPPROTO_IPV6,\n+                             IPV6_PROTECTION_LEVEL,\n+                             reinterpret_cast<const char*>(&prot_level),\n+                             sizeof(prot_level)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_PROTECTION_LEVEL on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+    }\n+\n+    if (sock->Bind(reinterpret_cast<sockaddr*>(&storage), len) == SOCKET_ERROR) {\n+        const int err{WSAGetLastError()};\n+        errmsg = strprintf(_(\"Cannot bind to %s: %s%s\"),\n+                           to.ToStringAddrPort(),\n+                           NetworkErrorString(err),\n+                           err == WSAEADDRINUSE\n+                               ? std::string{\" (\"} + CLIENT_NAME + \" already running?)\"\n+                               : \"\");\n+        return false;\n+    }\n+\n+    // Listen for incoming connections\n+    if (sock->Listen(SOMAXCONN) == SOCKET_ERROR) {\n+        errmsg = strprintf(_(\"Cannot listen to %s: %s\"), to.ToStringAddrPort(), NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    m_listen.emplace_back(std::move(sock));\n+\n+    return true;\n+}\n+\n+void SockMan::StartSocketsThreads(const Options& options)\n+{\n+    m_thread_socket_handler = std::thread(\n+        &util::TraceThread, options.socket_handler_thread_name, [this] { ThreadSocketHandler(); });\n+\n+    if (options.i2p.has_value()) {\n+        m_i2p_sam_session = std::make_unique<i2p::sam::Session>(\n+            options.i2p->private_key_file, options.i2p->sam_proxy, &interruptNet);\n+\n+        m_thread_i2p_accept =\n+            std::thread(&util::TraceThread, options.i2p->accept_thread_name, [this] { ThreadI2PAccept(); });\n+    }\n+}\n+\n+void SockMan::JoinSocketsThreads()\n+{\n+    if (m_thread_i2p_accept.joinable()) {\n+        m_thread_i2p_accept.join();\n+    }\n+\n+    if (m_thread_socket_handler.joinable()) {\n+        m_thread_socket_handler.join();\n+    }\n+}\n+\n+std::optional<NodeId>\n+SockMan::ConnectAndMakeNodeId(const std::variant<CService, StringHostIntPort>& to,\n+                              bool is_important,\n+                              const Proxy& proxy,\n+                              bool& proxy_failed,\n+                              CService& me)\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+    AssertLockNotHeld(m_unused_i2p_sessions_mutex);\n+\n+    std::unique_ptr<Sock> sock;\n+    std::unique_ptr<i2p::sam::Session> i2p_transient_session;\n+\n+    Assume(!me.IsValid());\n+\n+    if (std::holds_alternative<CService>(to)) {\n+        const CService& addr_to{std::get<CService>(to)};\n+        if (addr_to.IsI2P()) {\n+            if (!Assume(proxy.IsValid())) {\n+                return std::nullopt;\n+            }\n+\n+            i2p::Connection conn;\n+            bool connected{false};\n+\n+            if (m_i2p_sam_session) {\n+                connected = m_i2p_sam_session->Connect(addr_to, conn, proxy_failed);\n+            } else {\n+                {\n+                    LOCK(m_unused_i2p_sessions_mutex);\n+                    if (m_unused_i2p_sessions.empty()) {\n+                        i2p_transient_session = std::make_unique<i2p::sam::Session>(proxy, &interruptNet);\n+                    } else {\n+                        i2p_transient_session.swap(m_unused_i2p_sessions.front());\n+                        m_unused_i2p_sessions.pop();\n+                    }\n+                }\n+                connected = i2p_transient_session->Connect(addr_to, conn, proxy_failed);\n+                if (!connected) {\n+                    LOCK(m_unused_i2p_sessions_mutex);\n+                    if (m_unused_i2p_sessions.size() < MAX_UNUSED_I2P_SESSIONS_SIZE) {\n+                        m_unused_i2p_sessions.emplace(i2p_transient_session.release());\n+                    }\n+                }\n+            }\n+\n+            if (connected) {\n+                sock = std::move(conn.sock);\n+                me = conn.me;\n+            }\n+        } else if (proxy.IsValid()) {\n+            sock = ConnectThroughProxy(proxy, addr_to.ToStringAddr(), addr_to.GetPort(), proxy_failed);\n+        } else {\n+            sock = ConnectDirectly(addr_to, is_important);\n+        }\n+    } else {\n+        if (!Assume(proxy.IsValid())) {\n+            return std::nullopt;\n+        }\n+\n+        const auto& hostport{std::get<StringHostIntPort>(to)};\n+\n+        bool dummy_proxy_failed;\n+        sock = ConnectThroughProxy(proxy, hostport.host, hostport.port, dummy_proxy_failed);\n+    }\n+\n+    if (!sock) {\n+        return std::nullopt;\n+    }\n+\n+    if (!me.IsValid()) {\n+        me = GetBindAddress(*sock);\n+    }\n+\n+    const NodeId node_id{GetNewNodeId()};\n+\n+    {\n+        LOCK(m_connected_mutex);\n+        m_connected.emplace(node_id, std::make_shared<NodeSockets>(std::move(sock),\n+                                                                   std::move(i2p_transient_session)));\n+    }\n+\n+    return node_id;\n+}\n+\n+bool SockMan::CloseConnection(NodeId node_id)\n+{\n+    LOCK(m_connected_mutex);\n+    return m_connected.erase(node_id) > 0;\n+}\n+\n+ssize_t SockMan::SendBytes(NodeId node_id,\n+                           std::span<const unsigned char> data,\n+                           bool will_send_more,\n+                           std::string& errmsg) const\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    if (data.empty()) {\n+        return 0;\n+    }\n+\n+    auto node_sockets{GetNodeSockets(node_id)};\n+    if (!node_sockets) {\n+        // Bail out immediately and just leave things in the caller's send queue.\n+        return 0;\n+    }\n+\n+    int flags{MSG_NOSIGNAL | MSG_DONTWAIT};\n+#ifdef MSG_MORE\n+    if (will_send_more) {\n+        flags |= MSG_MORE;\n+    }\n+#endif\n+\n+    const ssize_t sent{WITH_LOCK(\n+        node_sockets->mutex,\n+        return node_sockets->sock->Send(reinterpret_cast<const char*>(data.data()), data.size(), flags);)};\n+\n+    if (sent >= 0) {\n+        return sent;\n+    }\n+\n+    const int err{WSAGetLastError()};\n+    if (err == WSAEWOULDBLOCK || err == WSAEMSGSIZE || err == WSAEINTR || err == WSAEINPROGRESS) {\n+        return 0;\n+    }\n+    errmsg = NetworkErrorString(err);\n+    return -1;\n+}\n+\n+void SockMan::CloseSockets()\n+{\n+    m_listen.clear();\n+}\n+\n+bool SockMan::ShouldTryToSend(NodeId node_id) const { return true; }\n+\n+bool SockMan::ShouldTryToRecv(NodeId node_id) const { return true; }\n+\n+void SockMan::EventIOLoopCompletedForNode(NodeId node_id) {}\n+\n+void SockMan::EventIOLoopCompletedForAllPeers() {}\n+\n+void SockMan::EventI2PListen(const CService&, bool) {}\n+\n+void SockMan::TestOnlyAddExistentNode(NodeId node_id, std::unique_ptr<Sock>&& sock)\n+{\n+    LOCK(m_connected_mutex);\n+    const auto result{m_connected.emplace(node_id, std::make_shared<NodeSockets>(std::move(sock)))};\n+    assert(result.second);\n+}\n+\n+void SockMan::ThreadI2PAccept()\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    static constexpr auto err_wait_begin = 1s;\n+    static constexpr auto err_wait_cap = 5min;\n+    auto err_wait = err_wait_begin;\n+\n+    i2p::Connection conn;\n+\n+    auto SleepOnFailure = [&]() {\n+        interruptNet.sleep_for(err_wait);\n+        if (err_wait < err_wait_cap) {\n+            err_wait += 1s;\n+        }\n+    };\n+\n+    while (!interruptNet) {\n+\n+        if (!m_i2p_sam_session->Listen(conn)) {\n+            EventI2PListen(conn.me, /*success=*/false);\n+            SleepOnFailure();\n+            continue;\n+        }\n+\n+        EventI2PListen(conn.me, /*success=*/true);\n+\n+        if (!m_i2p_sam_session->Accept(conn)) {\n+            SleepOnFailure();\n+            continue;\n+        }\n+\n+        NewSockAccepted(std::move(conn.sock), conn.me, conn.peer);\n+\n+        err_wait = err_wait_begin;\n+    }\n+}\n+\n+void SockMan::ThreadSocketHandler()\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    while (!interruptNet) {\n+        EventIOLoopCompletedForAllPeers();\n+\n+        // Check for the readiness of the already connected sockets and the\n+        // listening sockets in one call (\"readiness\" as in poll(2) or\n+        // select(2)). If none are ready, wait for a short while and return\n+        // empty sets.\n+        auto io_readiness{GenerateWaitSockets()};\n+        if (io_readiness.events_per_sock.empty() ||\n+            // WaitMany() may as well be a static method, the context of the first Sock in the vector is not relevant.\n+            !io_readiness.events_per_sock.begin()->first->WaitMany(SELECT_TIMEOUT,\n+                                                                   io_readiness.events_per_sock)) {\n+            interruptNet.sleep_for(SELECT_TIMEOUT);\n+        }",
      "path": "src/common/sockman.cpp",
      "position": 351,
      "original_position": 344,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "7866c736c87a908cef75dc6901c9c0594c65b0eb",
      "in_reply_to_id": 1945120612,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "For example I tried this. I expected a performance boost but didn't really observe one:\r\n\r\n```cpp\r\n\r\n        auto io_readiness{GenerateWaitSockets()};\r\n        if (io_readiness.events_per_sock.empty()) {\r\n            interruptNet.sleep_for(SELECT_TIMEOUT);\r\n        } else {\r\n            // WaitMany() may as well be a static method, the context of the first Sock in the vector is not relevant.\r\n            io_readiness.events_per_sock.begin()->first->WaitMany(SELECT_TIMEOUT,\r\n                                                                   io_readiness.events_per_sock);\r\n        }\r\n```",
      "created_at": "2025-02-06T19:19:57Z",
      "updated_at": "2025-02-06T19:19:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1945293526",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1945293526"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": 346,
      "original_start_line": 339,
      "start_side": "RIGHT",
      "line": 351,
      "original_line": 351,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1945972101",
      "pull_request_review_id": 2600830767,
      "id": 1945972101,
      "node_id": "PRRC_kwDOABII585z_S2F",
      "diff_hunk": "@@ -0,0 +1,435 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#ifndef BITCOIN_COMMON_SOCKMAN_H\n+#define BITCOIN_COMMON_SOCKMAN_H\n+\n+#include <i2p.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <util/fs.h>\n+#include <util/sock.h>\n+#include <util/translation.h>\n+\n+#include <atomic>\n+#include <memory>\n+#include <queue>\n+#include <span>\n+#include <thread>\n+#include <variant>\n+#include <vector>\n+\n+typedef int64_t NodeId;\n+\n+/**\n+ * A socket manager class which handles socket operations.\n+ * To use this class, inherit from it and implement the pure virtual methods.\n+ * Handled operations:\n+ * - binding and listening on sockets\n+ * - starting of necessary threads to process socket operations\n+ * - accepting incoming connections\n+ * - making outbound connections\n+ * - closing connections\n+ * - waiting for IO readiness on sockets and doing send/recv accordingly\n+ */\n+class SockMan\n+{\n+public:\n+\n+    virtual ~SockMan() = default;\n+\n+    //\n+    // Non-virtual functions, to be reused by children classes.\n+    //\n+\n+    /**\n+     * Bind to a new address:port, start listening and add the listen socket to `m_listen`.\n+     * Should be called before `StartSocketsThreads()`.\n+     * @param[in] to Where to bind.\n+     * @param[out] errmsg Error string if an error occurs.\n+     * @retval true Success.\n+     * @retval false Failure, `strError` will be set.\n+     */\n+    bool BindAndStartListening(const CService& to, bilingual_str& errmsg);",
      "path": "src/common/sockman.h",
      "position": null,
      "original_position": 54,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "266ac3267390270e6794d478aa1fbe40e88ffb0f",
      "in_reply_to_id": 1934587454,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-02-07T05:26:15Z",
      "updated_at": "2025-02-07T05:26:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1945972101",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1945972101"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": 50,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 54,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1945976586",
      "pull_request_review_id": 2600837749,
      "id": 1945976586,
      "node_id": "PRRC_kwDOABII585z_T8K",
      "diff_hunk": "@@ -3440,19 +3199,19 @@ void CConnman::StopNodes()\n     }\n \n     // Delete peer connections.\n-    std::vector<CNode*> nodes;\n+    decltype(m_nodes) nodes;\n     WITH_LOCK(m_nodes_mutex, nodes.swap(m_nodes));\n-    for (CNode* pnode : nodes) {\n-        LogDebug(BCLog::NET, \"%s\\n\", pnode->DisconnectMsg(fLogIPs));\n-        pnode->CloseSocketDisconnect();\n+    for (auto& [_, pnode] : nodes) {\n+        MarkAsDisconnectAndCloseConnection(*pnode);\n         DeleteNode(pnode);\n     }\n \n     for (CNode* pnode : m_nodes_disconnected) {\n         DeleteNode(pnode);\n     }\n     m_nodes_disconnected.clear();\n-    vhListenSocket.clear();\n+    m_listen_permissions.clear();",
      "path": "src/net.cpp",
      "position": 1239,
      "original_position": 1219,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "266ac3267390270e6794d478aa1fbe40e88ffb0f",
      "in_reply_to_id": 1934686592,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "No, we do not want to remove entries from `m_listen_permissions` or from `m_listen` when disconnecting a single peer. The entries in those two maps are per listening address. E.g. if we listen on `1.1.1.1:8333` and designate that every peer that connects to that address gets `permissions1` and listen on `2.2.2.2:8333` and peers that connect to that address get `permissions2`. This stays unchanged as peers connect and disconnect. We would want to remove entries from those maps if we stop listening - i.e. if we close the listening socket. This is only done at shutdown.",
      "created_at": "2025-02-07T05:33:18Z",
      "updated_at": "2025-02-07T05:33:18Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1945976586",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1945976586"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 3244,
      "original_line": 3244,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1945983707",
      "pull_request_review_id": 2600848932,
      "id": 1945983707,
      "node_id": "PRRC_kwDOABII585z_Vrb",
      "diff_hunk": "@@ -3212,13 +2972,18 @@ bool CConnman::Bind(const CService& addr_, unsigned int flags, NetPermissionFlag\n     const CService addr{MaybeFlipIPv6toCJDNS(addr_)};\n \n     bilingual_str strError;\n-    if (!BindListenPort(addr, strError, permissions)) {\n+    if (!BindAndStartListening(addr, strError)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"%s\\n\", strError.original);\n         if ((flags & BF_REPORT_ERROR) && m_client_interface) {\n             m_client_interface->ThreadSafeMessageBox(strError, \"\", CClientUIInterface::MSG_ERROR);\n         }\n         return false;\n     }\n \n+    LogPrintLevel(BCLog::NET, BCLog::Level::Info, \"Bound to and listening on %s\\n\", addr.ToStringAddrPort());\n+\n+    m_listen_permissions.emplace(addr, permissions);",
      "path": "src/net.cpp",
      "position": 1149,
      "original_position": 1129,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "266ac3267390270e6794d478aa1fbe40e88ffb0f",
      "in_reply_to_id": 1934690968,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "`addr` is our listening address. We can't listen on the same address two times:\r\n\r\nIf I put this in my `bitcoind.conf`:\r\n```\r\nbind=127.0.0.1:20001\r\nbind=127.0.0.1:20002\r\nbind=127.0.0.1:20003\r\nbind=127.0.0.1:20003\r\n```\r\n\r\nI get:\r\n\r\n```\r\n2025-02-07T05:39:56Z [net:info] Bound to and listening on 127.0.0.1:20001\r\n2025-02-07T05:39:56Z [net:info] Bound to and listening on 127.0.0.1:20002\r\n2025-02-07T05:39:56Z [net:info] Bound to and listening on 127.0.0.1:20003\r\n2025-02-07T05:39:56Z [net:error] Cannot bind to 127.0.0.1:20003: Address already in use (48) (Bitcoin Core already running?)\r\n```\r\nand startup is aborted.\r\n\r\nI could add `Assume()` or return an error from here if insertion fails due to an already existent entry?",
      "created_at": "2025-02-07T05:44:41Z",
      "updated_at": "2025-02-07T05:44:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1945983707",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1945983707"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 3015,
      "original_line": 3015,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1945989789",
      "pull_request_review_id": 2600858560,
      "id": 1945989789,
      "node_id": "PRRC_kwDOABII585z_XKd",
      "diff_hunk": "@@ -1704,115 +1647,81 @@ bool CConnman::AttemptToEvictConnection()\n         return false;\n     }\n     LOCK(m_nodes_mutex);\n-    for (CNode* pnode : m_nodes) {\n-        if (pnode->GetId() == *node_id_to_evict) {\n-            LogDebug(BCLog::NET, \"selected %s connection for eviction peer=%d; disconnecting\\n\", pnode->ConnectionTypeAsString(), pnode->GetId());\n-            pnode->fDisconnect = true;\n-            return true;\n-        }\n+    auto it{m_nodes.find(*node_id_to_evict)};\n+    if (it != m_nodes.end()) {\n+        auto id{it->first};\n+        auto node{it->second};\n+        LogDebug(BCLog::NET, \"selected %s connection for eviction peer=%d; disconnecting\\n\", node->ConnectionTypeAsString(), id);\n+        node->fDisconnect = true;\n+        return true;\n     }\n     return false;\n }\n \n-void CConnman::AcceptConnection(const ListenSocket& hListenSocket) {\n-    struct sockaddr_storage sockaddr;\n-    socklen_t len = sizeof(sockaddr);\n-    auto sock = hListenSocket.sock->Accept((struct sockaddr*)&sockaddr, &len);\n-    CAddress addr;\n-\n-    if (!sock) {\n-        const int nErr = WSAGetLastError();\n-        if (nErr != WSAEWOULDBLOCK) {\n-            LogPrintf(\"socket error accept failed: %s\\n\", NetworkErrorString(nErr));\n-        }\n-        return;\n-    }\n-\n-    if (!addr.SetSockAddr((const struct sockaddr*)&sockaddr)) {\n-        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"Unknown socket family\\n\");\n-    } else {\n-        addr = CAddress{MaybeFlipIPv6toCJDNS(addr), NODE_NONE};\n-    }\n+bool CConnman::EventNewConnectionAccepted(NodeId node_id,\n+                                          const CService& addr_bind_,\n+                                          const CService& addr_)\n+{\n+    const CService addr_bind{MaybeFlipIPv6toCJDNS(addr_bind_)};\n+    const CService addr{MaybeFlipIPv6toCJDNS(addr_)};\n \n-    const CAddress addr_bind{MaybeFlipIPv6toCJDNS(GetBindAddress(*sock)), NODE_NONE};\n+    int nInbound = 0;\n \n     NetPermissionFlags permission_flags = NetPermissionFlags::None;\n-    hListenSocket.AddSocketPermissionFlags(permission_flags);\n-\n-    CreateNodeFromAcceptedSocket(std::move(sock), permission_flags, addr_bind, addr);\n-}\n-\n-void CConnman::CreateNodeFromAcceptedSocket(std::unique_ptr<Sock>&& sock,\n-                                            NetPermissionFlags permission_flags,\n-                                            const CAddress& addr_bind,\n-                                            const CAddress& addr)\n-{\n-    int nInbound = 0;\n+    auto it{m_listen_permissions.find(addr_bind)};\n+    if (it != m_listen_permissions.end()) {\n+        NetPermissions::AddFlag(permission_flags, it->second);\n+    }",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 388,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "266ac3267390270e6794d478aa1fbe40e88ffb0f",
      "in_reply_to_id": 1934710097,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "The proposed snippet is more elegant and performant, I like it. It relies, however, on `None` being `0` and will break in a subtle way if that is changed. I will leave it as it is. This is executed once per newly accepted connection which is not super-often and the performance gain would be negligible.",
      "created_at": "2025-02-07T05:53:49Z",
      "updated_at": "2025-02-07T05:53:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1945989789",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1945989789"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": 1670,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1682,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1945991471",
      "pull_request_review_id": 2600861045,
      "id": 1945991471,
      "node_id": "PRRC_kwDOABII585z_Xkv",
      "diff_hunk": "@@ -0,0 +1,435 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#ifndef BITCOIN_COMMON_SOCKMAN_H\n+#define BITCOIN_COMMON_SOCKMAN_H\n+\n+#include <i2p.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <util/fs.h>\n+#include <util/sock.h>\n+#include <util/translation.h>\n+\n+#include <atomic>\n+#include <memory>\n+#include <queue>\n+#include <span>\n+#include <thread>\n+#include <variant>\n+#include <vector>\n+\n+typedef int64_t NodeId;\n+\n+/**\n+ * A socket manager class which handles socket operations.\n+ * To use this class, inherit from it and implement the pure virtual methods.\n+ * Handled operations:\n+ * - binding and listening on sockets\n+ * - starting of necessary threads to process socket operations\n+ * - accepting incoming connections\n+ * - making outbound connections\n+ * - closing connections\n+ * - waiting for IO readiness on sockets and doing send/recv accordingly\n+ */\n+class SockMan\n+{\n+public:\n+\n+    virtual ~SockMan() = default;\n+\n+    //\n+    // Non-virtual functions, to be reused by children classes.\n+    //\n+\n+    /**\n+     * Bind to a new address:port, start listening and add the listen socket to `m_listen`.\n+     * Should be called before `StartSocketsThreads()`.\n+     * @param[in] to Where to bind.\n+     * @param[out] errmsg Error string if an error occurs.\n+     * @retval true Success.\n+     * @retval false Failure, `strError` will be set.\n+     */\n+    bool BindAndStartListening(const CService& to, bilingual_str& errmsg);\n+\n+    /**\n+     * Options to influence `StartSocketsThreads()`.\n+     */\n+    struct Options {\n+        std::string_view socket_handler_thread_name;\n+\n+        struct I2P {\n+            explicit I2P(const fs::path& file, const Proxy& proxy, std::string_view accept_thread_name)\n+                : private_key_file{file},\n+                  sam_proxy{proxy},\n+                  accept_thread_name{accept_thread_name}\n+            {}\n+\n+            const fs::path private_key_file;\n+            const Proxy sam_proxy;\n+            const std::string_view accept_thread_name;\n+        };\n+\n+        /**\n+         * I2P options. If set then a thread will be started that will accept incoming I2P connections.\n+         */\n+        std::optional<I2P> i2p;\n+    };\n+\n+    /**\n+     * Start the necessary threads for sockets IO.\n+     */\n+    void StartSocketsThreads(const Options& options);\n+\n+    /**\n+     * Join (wait for) the threads started by `StartSocketsThreads()` to exit.\n+     */\n+    void JoinSocketsThreads();\n+\n+    /**\n+     * A more readable std::tuple<std::string, uint16_t> for host and port.\n+     */\n+    struct StringHostIntPort {\n+        const std::string& host;\n+        uint16_t port;\n+    };\n+\n+    /**\n+     * Make an outbound connection, save the socket internally and return a newly generated node id.\n+     * @param[in] to The address to connect to, either as CService or a host as string and port as\n+     * an integer, if the later is used, then `proxy` must be valid.\n+     * @param[in] is_important If true, then log failures with higher severity.\n+     * @param[in] proxy Proxy to connect through if `proxy.IsValid()` is true.\n+     * @param[out] proxy_failed If `proxy` is valid and the connection failed because of the\n+     * proxy, then it will be set to true.\n+     * @param[out] me If the connection was successful then this is set to the address on the\n+     * local side of the socket.\n+     * @return Newly generated node id, or std::nullopt if the operation fails.\n+     */\n+    std::optional<NodeId> ConnectAndMakeNodeId(const std::variant<CService, StringHostIntPort>& to,\n+                                               bool is_important,\n+                                               const Proxy& proxy,\n+                                               bool& proxy_failed,\n+                                               CService& me)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex, !m_unused_i2p_sessions_mutex);\n+\n+    /**\n+     * Disconnect a given peer by closing its socket and release resources occupied by it.\n+     * @return Whether the peer existed and its socket was closed by this call.\n+     */\n+    bool CloseConnection(NodeId node_id)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Try to send some data to the given node.\n+     * @param[in] node_id Identifier of the node to send to.\n+     * @param[in] data The data to send, it might happen that only a prefix of this is sent.\n+     * @param[in] will_send_more Used as an optimization if the caller knows that they will\n+     * be sending more data soon after this call.\n+     * @param[out] errmsg If <0 is returned then this will contain a human readable message\n+     * explaining the error.\n+     * @retval >=0 The number of bytes actually sent.\n+     * @retval <0 A permanent error has occurred.\n+     */\n+    ssize_t SendBytes(NodeId node_id,\n+                      std::span<const unsigned char> data,\n+                      bool will_send_more,\n+                      std::string& errmsg) const\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Close all sockets.\n+     */\n+    void CloseSockets();\n+\n+    /**\n+     * This is signaled when network activity should cease.\n+     * A pointer to it is saved in `m_i2p_sam_session`, so make sure that\n+     * the lifetime of `interruptNet` is not shorter than\n+     * the lifetime of `m_i2p_sam_session`.\n+     */\n+    CThreadInterrupt interruptNet;\n+\n+protected:\n+\n+    /**\n+     * During some tests mocked sockets are created outside of `SockMan`, make it\n+     * possible to add those so that send/recv can be exercised.\n+     */\n+    void TestOnlyAddExistentNode(NodeId node_id, std::unique_ptr<Sock>&& sock)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+private:\n+\n+    /**\n+     * Cap on the size of `m_unused_i2p_sessions`, to ensure it does not\n+     * unexpectedly use too much memory.\n+     */\n+    static constexpr size_t MAX_UNUSED_I2P_SESSIONS_SIZE{10};\n+\n+    //\n+    // Pure virtual functions must be implemented by children classes.\n+    //\n+\n+    /**\n+     * Be notified when a new connection has been accepted.\n+     * @param[in] node_id Id of the newly accepted connection.\n+     * @param[in] me The address and port at our side of the connection.\n+     * @param[in] them The address and port at the peer's side of the connection.\n+     * @retval true The new connection was accepted at the higher level.\n+     * @retval false The connection was refused at the higher level, so the\n+     * associated socket and node_id should be discarded by `SockMan`.\n+     */\n+    virtual bool EventNewConnectionAccepted(NodeId node_id,\n+                                            const CService& me,\n+                                            const CService& them) = 0;\n+\n+    /**\n+     * Called when the socket is ready to send data and `ShouldTryToSend()` has\n+     * returned true. This is where the higher level code serializes its messages\n+     * and calls `SockMan::SendBytes()`.\n+     * @param[in] node_id Id of the node whose socket is ready to send.\n+     * @param[out] cancel_recv Should always be set upon return and if it is true,\n+     * then the next attempt to receive data from that node will be omitted.\n+     */\n+    virtual void EventReadyToSend(NodeId node_id, bool& cancel_recv) = 0;\n+\n+    /**\n+     * Called when new data has been received.\n+     * @param[in] node_id Node for which the data arrived.\n+     * @param[in] data Data buffer.\n+     * @param[in] n Number of bytes in `data`.\n+     */\n+    virtual void EventGotData(NodeId node_id, const uint8_t* data, size_t n) = 0;\n+\n+    /**\n+     * Called when the remote peer has sent an EOF on the socket. This is a graceful\n+     * close of their writing side, we can still send and they will receive, if it\n+     * makes sense at the application level.\n+     * @param[in] node_id Node whose socket got EOF.\n+     */\n+    virtual void EventGotEOF(NodeId node_id) = 0;\n+\n+    /**\n+     * Called when we get an irrecoverable error trying to read from a socket.\n+     * @param[in] node_id Node whose socket got an error.\n+     * @param[in] errmsg Message describing the error.\n+     */\n+    virtual void EventGotPermanentReadError(NodeId node_id, const std::string& errmsg) = 0;\n+\n+    //\n+    // Non-pure virtual functions can be overridden by children classes or left\n+    // alone to use the default implementation from SockMan.\n+    //\n+\n+    /**\n+     * Can be used to temporarily pause sends for a node.\n+     * SockMan would only call EventReadyToSend() if this returns true.\n+     * The implementation in SockMan always returns true.\n+     * @param[in] node_id Node for which to confirm or cancel a call to EventReadyToSend().\n+     */\n+    virtual bool ShouldTryToSend(NodeId node_id) const;\n+\n+    /**\n+     * SockMan would only call Recv() on a node's socket if this returns true.\n+     * Can be used to temporarily pause receives for a node.\n+     * The implementation in SockMan always returns true.\n+     * @param[in] node_id Node for which to confirm or cancel a receive.\n+     */\n+    virtual bool ShouldTryToRecv(NodeId node_id) const;\n+\n+    /**\n+     * SockMan has completed the current send+recv iteration for a node.\n+     * It will do another send+recv for this node after processing all other nodes.\n+     * Can be used to execute periodic tasks for a given node.\n+     * The implementation in SockMan does nothing.\n+     * @param[in] node_id Node for which send+recv has been done.\n+     */\n+    virtual void EventIOLoopCompletedForNode(NodeId node_id);\n+\n+    /**\n+     * SockMan has completed send+recv for all nodes.\n+     * Can be used to execute periodic tasks for all nodes, like disconnecting\n+     * nodes due to higher level logic.\n+     * The implementation in SockMan does nothing.\n+     */\n+    virtual void EventIOLoopCompletedForAllPeers();\n+\n+    /**\n+     * Be notified of a change in the state of listening for incoming I2P connections.\n+     * The default behavior, implemented by `SockMan`, is to ignore this event.\n+     * @param[in] addr Our listening address.\n+     * @param[in] success If true then the listen succeeded and we are now\n+     * listening for incoming I2P connections at `addr`. If false then the\n+     * call failed and now we are not listening (even if this was invoked\n+     * before with `true`).\n+     */\n+    virtual void EventI2PListen(const CService& addr, bool success);\n+\n+    /**\n+     * The sockets used by a connected node - a data socket and an optional I2P session.\n+     */\n+    struct NodeSockets {\n+        explicit NodeSockets(std::unique_ptr<Sock>&& s)\n+            : sock{std::move(s)}\n+        {\n+        }\n+\n+        explicit NodeSockets(std::shared_ptr<Sock>&& s, std::unique_ptr<i2p::sam::Session>&& sess)\n+            : sock{std::move(s)},\n+              i2p_transient_session{std::move(sess)}\n+        {\n+        }\n+\n+        /**\n+         * Mutex that serializes the Send() and Recv() calls on `sock`.\n+         */\n+        Mutex mutex;\n+\n+        /**\n+         * Underlying socket.\n+         * `shared_ptr` (instead of `unique_ptr`) is used to avoid premature close of the\n+         * underlying file descriptor by one thread while another thread is poll(2)-ing\n+         * it for activity.\n+         * @see https://github.com/bitcoin/bitcoin/issues/21744 for details.\n+         */\n+        std::shared_ptr<Sock> sock;\n+\n+        /**\n+         * When transient I2P sessions are used, then each node has its own session, otherwise\n+         * all nodes use the session from `m_i2p_sam_session` and share the same I2P address.\n+         * I2P sessions involve a data/transport socket (in `sock`) and a control socket\n+         * (in `i2p_transient_session`). For transient sessions, once the data socket `sock` is\n+         * closed, the control socket is not going to be used anymore and would be just taking\n+         * resources. Storing it here makes its deletion together with `sock` automatic.\n+         */\n+        std::unique_ptr<i2p::sam::Session> i2p_transient_session;\n+    };\n+\n+    /**\n+     * Info about which socket has which event ready and its node id.\n+     */\n+    struct IOReadiness {\n+        Sock::EventsPerSock events_per_sock;\n+        std::unordered_map<Sock::EventsPerSock::key_type, NodeId> node_ids_per_sock;\n+    };\n+\n+    /**\n+     * Accept incoming I2P connections in a loop and call\n+     * `EventNewConnectionAccepted()` for each new connection.\n+     */\n+    void ThreadI2PAccept()\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Check connected and listening sockets for IO readiness and process them accordingly.\n+     */\n+    void ThreadSocketHandler()\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Accept a connection.\n+     * @param[in] listen_sock Socket on which to accept the connection.\n+     * @param[out] addr Address of the peer that was accepted.\n+     * @return Newly created socket for the accepted connection.\n+     */\n+    std::unique_ptr<Sock> AcceptConnection(const Sock& listen_sock, CService& addr);\n+\n+    /**\n+     * After a new socket with a peer has been created, configure its flags,\n+     * make a new node id and call `EventNewConnectionAccepted()`.\n+     * @param[in] sock The newly created socket.\n+     * @param[in] me Address at our end of the connection.\n+     * @param[in] them Address of the new peer.\n+     */\n+    void NewSockAccepted(std::unique_ptr<Sock>&& sock, const CService& me, const CService& them)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Generate an id for a newly created node.\n+     */\n+    NodeId GetNewNodeId();\n+\n+    /**\n+     * Generate a collection of sockets to check for IO readiness.\n+     * @return Sockets to check for readiness plus an aux map to find the\n+     * corresponding node id given a socket.\n+     */\n+    IOReadiness GenerateWaitSockets()\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Do the read/write for connected sockets that are ready for IO.\n+     * @param[in] io_readiness Which sockets are ready and their node ids.\n+     */\n+    void SocketHandlerConnected(const IOReadiness& io_readiness)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Accept incoming connections, one from each read-ready listening socket.\n+     * @param[in] events_per_sock Sockets that are ready for IO.\n+     */\n+    void SocketHandlerListening(const Sock::EventsPerSock& events_per_sock)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Retrieve an entry from m_connected.\n+     * @param[in] node_id Node id to search for.\n+     * @return NodeSockets for the given node id or empty shared_ptr if not found.\n+     */\n+    std::shared_ptr<NodeSockets> GetNodeSockets(NodeId node_id) const\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * The id to assign to the next created node. Used to generate ids of nodes.\n+     */\n+    std::atomic<NodeId> m_next_node_id{0};\n+\n+    /**\n+     * Thread that sends to and receives from sockets and accepts connections.\n+     */\n+    std::thread m_thread_socket_handler;\n+\n+    /**\n+     * Thread that accepts incoming I2P connections in a loop, can be stopped via `interruptNet`.\n+     */\n+    std::thread m_thread_i2p_accept;\n+\n+    /**\n+     * Mutex protecting m_i2p_sam_sessions.\n+     */\n+    Mutex m_unused_i2p_sessions_mutex;\n+\n+    /**\n+     * A pool of created I2P SAM transient sessions that should be used instead\n+     * of creating new ones in order to reduce the load on the I2P network.\n+     * Creating a session in I2P is not cheap, thus if this is not empty, then\n+     * pick an entry from it instead of creating a new session. If connecting to\n+     * a host fails, then the created session is put to this pool for reuse.\n+     */\n+    std::queue<std::unique_ptr<i2p::sam::Session>> m_unused_i2p_sessions GUARDED_BY(m_unused_i2p_sessions_mutex);\n+\n+    /**\n+     * I2P SAM session.\n+     * Used to accept incoming and make outgoing I2P connections from a persistent\n+     * address.\n+     */\n+    std::unique_ptr<i2p::sam::Session> m_i2p_sam_session;\n+\n+    /**\n+     * List of listening sockets.\n+     */\n+    std::vector<std::shared_ptr<Sock>> m_listen;",
      "path": "src/common/sockman.h",
      "position": 451,
      "original_position": 423,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "266ac3267390270e6794d478aa1fbe40e88ffb0f",
      "in_reply_to_id": 1934722181,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Agree, will leave it as it is.",
      "created_at": "2025-02-07T05:56:04Z",
      "updated_at": "2025-02-07T05:56:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1945991471",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1945991471"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": 448,
      "original_start_line": 420,
      "start_side": "RIGHT",
      "line": 451,
      "original_line": 451,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946000478",
      "pull_request_review_id": 2600875349,
      "id": 1946000478,
      "node_id": "PRRC_kwDOABII585z_Zxe",
      "diff_hunk": "@@ -0,0 +1,533 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+#include <cassert>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+static CService GetBindAddress(const Sock& sock)\n+{\n+    CService addr_bind;\n+    struct sockaddr_storage sockaddr_bind;\n+    socklen_t sockaddr_bind_len = sizeof(sockaddr_bind);\n+    if (!sock.GetSockName((struct sockaddr*)&sockaddr_bind, &sockaddr_bind_len)) {\n+        addr_bind.SetSockAddr((const struct sockaddr*)&sockaddr_bind);\n+    } else {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"getsockname failed\\n\");\n+    }\n+    return addr_bind;\n+}\n+\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& errmsg)\n+{\n+    // Create socket for listening for incoming connections\n+    struct sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {\n+        errmsg = Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()));\n+        return false;\n+    }\n+\n+    std::unique_ptr<Sock> sock{CreateSock(to.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP)};\n+    if (!sock) {\n+        errmsg = Untranslated(strprintf(\"Cannot create %s listen socket: %s\",\n+                                        to.ToStringAddrPort(),\n+                                        NetworkErrorString(WSAGetLastError())));\n+        return false;\n+    }\n+\n+    int one{1};\n+\n+    // Allow binding if the port is still in TIME_WAIT state after\n+    // the program was closed and restarted.\n+    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+        LogPrintLevel(BCLog::NET,\n+                      BCLog::Level::Info,\n+                      \"Cannot set SO_REUSEADDR on %s listen socket: %s, continuing anyway\\n\",\n+                      to.ToStringAddrPort(),\n+                      NetworkErrorString(WSAGetLastError()));\n+    }\n+\n+    // some systems don't have IPV6_V6ONLY but are always v6only; others do have the option\n+    // and enable it by default or not. Try to enable it, if possible.\n+    if (to.IsIPv6()) {\n+#ifdef IPV6_V6ONLY\n+        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_V6ONLY on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+#ifdef WIN32\n+        int prot_level{PROTECTION_LEVEL_UNRESTRICTED};\n+        if (sock->SetSockOpt(IPPROTO_IPV6,\n+                             IPV6_PROTECTION_LEVEL,\n+                             reinterpret_cast<const char*>(&prot_level),\n+                             sizeof(prot_level)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_PROTECTION_LEVEL on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+    }\n+\n+    if (sock->Bind(reinterpret_cast<sockaddr*>(&storage), len) == SOCKET_ERROR) {\n+        const int err{WSAGetLastError()};\n+        errmsg = strprintf(_(\"Cannot bind to %s: %s%s\"),\n+                           to.ToStringAddrPort(),\n+                           NetworkErrorString(err),\n+                           err == WSAEADDRINUSE\n+                               ? std::string{\" (\"} + CLIENT_NAME + \" already running?)\"\n+                               : \"\");\n+        return false;\n+    }\n+\n+    // Listen for incoming connections\n+    if (sock->Listen(SOMAXCONN) == SOCKET_ERROR) {\n+        errmsg = strprintf(_(\"Cannot listen to %s: %s\"), to.ToStringAddrPort(), NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    m_listen.emplace_back(std::move(sock));\n+\n+    return true;\n+}\n+\n+void SockMan::StartSocketsThreads(const Options& options)\n+{\n+    m_thread_socket_handler = std::thread(\n+        &util::TraceThread, options.socket_handler_thread_name, [this] { ThreadSocketHandler(); });\n+\n+    if (options.i2p.has_value()) {\n+        m_i2p_sam_session = std::make_unique<i2p::sam::Session>(\n+            options.i2p->private_key_file, options.i2p->sam_proxy, &interruptNet);\n+\n+        m_thread_i2p_accept =\n+            std::thread(&util::TraceThread, options.i2p->accept_thread_name, [this] { ThreadI2PAccept(); });\n+    }\n+}\n+\n+void SockMan::JoinSocketsThreads()\n+{\n+    if (m_thread_i2p_accept.joinable()) {\n+        m_thread_i2p_accept.join();\n+    }\n+\n+    if (m_thread_socket_handler.joinable()) {\n+        m_thread_socket_handler.join();\n+    }\n+}\n+\n+std::optional<NodeId>\n+SockMan::ConnectAndMakeNodeId(const std::variant<CService, StringHostIntPort>& to,\n+                              bool is_important,\n+                              const Proxy& proxy,\n+                              bool& proxy_failed,\n+                              CService& me)\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+    AssertLockNotHeld(m_unused_i2p_sessions_mutex);\n+\n+    std::unique_ptr<Sock> sock;\n+    std::unique_ptr<i2p::sam::Session> i2p_transient_session;\n+\n+    Assume(!me.IsValid());\n+\n+    if (std::holds_alternative<CService>(to)) {\n+        const CService& addr_to{std::get<CService>(to)};\n+        if (addr_to.IsI2P()) {\n+            if (!Assume(proxy.IsValid())) {\n+                return std::nullopt;\n+            }\n+\n+            i2p::Connection conn;\n+            bool connected{false};\n+\n+            if (m_i2p_sam_session) {\n+                connected = m_i2p_sam_session->Connect(addr_to, conn, proxy_failed);\n+            } else {\n+                {\n+                    LOCK(m_unused_i2p_sessions_mutex);\n+                    if (m_unused_i2p_sessions.empty()) {\n+                        i2p_transient_session = std::make_unique<i2p::sam::Session>(proxy, &interruptNet);\n+                    } else {\n+                        i2p_transient_session.swap(m_unused_i2p_sessions.front());\n+                        m_unused_i2p_sessions.pop();\n+                    }\n+                }\n+                connected = i2p_transient_session->Connect(addr_to, conn, proxy_failed);\n+                if (!connected) {\n+                    LOCK(m_unused_i2p_sessions_mutex);\n+                    if (m_unused_i2p_sessions.size() < MAX_UNUSED_I2P_SESSIONS_SIZE) {\n+                        m_unused_i2p_sessions.emplace(i2p_transient_session.release());\n+                    }\n+                }\n+            }\n+\n+            if (connected) {\n+                sock = std::move(conn.sock);\n+                me = conn.me;\n+            }\n+        } else if (proxy.IsValid()) {\n+            sock = ConnectThroughProxy(proxy, addr_to.ToStringAddr(), addr_to.GetPort(), proxy_failed);\n+        } else {\n+            sock = ConnectDirectly(addr_to, is_important);\n+        }\n+    } else {\n+        if (!Assume(proxy.IsValid())) {\n+            return std::nullopt;\n+        }\n+\n+        const auto& hostport{std::get<StringHostIntPort>(to)};\n+\n+        bool dummy_proxy_failed;\n+        sock = ConnectThroughProxy(proxy, hostport.host, hostport.port, dummy_proxy_failed);\n+    }\n+\n+    if (!sock) {\n+        return std::nullopt;\n+    }\n+\n+    if (!me.IsValid()) {\n+        me = GetBindAddress(*sock);\n+    }\n+\n+    const NodeId node_id{GetNewNodeId()};\n+\n+    {\n+        LOCK(m_connected_mutex);\n+        m_connected.emplace(node_id, std::make_shared<NodeSockets>(std::move(sock),\n+                                                                   std::move(i2p_transient_session)));\n+    }\n+\n+    return node_id;\n+}\n+\n+bool SockMan::CloseConnection(NodeId node_id)\n+{\n+    LOCK(m_connected_mutex);\n+    return m_connected.erase(node_id) > 0;\n+}\n+\n+ssize_t SockMan::SendBytes(NodeId node_id,\n+                           std::span<const unsigned char> data,\n+                           bool will_send_more,\n+                           std::string& errmsg) const\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    if (data.empty()) {\n+        return 0;\n+    }\n+\n+    auto node_sockets{GetNodeSockets(node_id)};\n+    if (!node_sockets) {\n+        // Bail out immediately and just leave things in the caller's send queue.\n+        return 0;\n+    }\n+\n+    int flags{MSG_NOSIGNAL | MSG_DONTWAIT};\n+#ifdef MSG_MORE\n+    if (will_send_more) {\n+        flags |= MSG_MORE;\n+    }\n+#endif\n+\n+    const ssize_t sent{WITH_LOCK(\n+        node_sockets->mutex,\n+        return node_sockets->sock->Send(reinterpret_cast<const char*>(data.data()), data.size(), flags);)};\n+\n+    if (sent >= 0) {\n+        return sent;\n+    }\n+\n+    const int err{WSAGetLastError()};\n+    if (err == WSAEWOULDBLOCK || err == WSAEMSGSIZE || err == WSAEINTR || err == WSAEINPROGRESS) {\n+        return 0;\n+    }\n+    errmsg = NetworkErrorString(err);\n+    return -1;\n+}\n+\n+void SockMan::CloseSockets()",
      "path": "src/common/sockman.cpp",
      "position": null,
      "original_position": 267,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "266ac3267390270e6794d478aa1fbe40e88ffb0f",
      "in_reply_to_id": 1934731306,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "This method was only dealing with listening sockets, so the name `CloseSockets()` with a comment \"Close all sockets\" was confusing. Renamed to `StopListening()`.",
      "created_at": "2025-02-07T06:07:38Z",
      "updated_at": "2025-02-07T06:07:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1946000478",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946000478"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 267,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946227366",
      "pull_request_review_id": 2601232024,
      "id": 1946227366,
      "node_id": "PRRC_kwDOABII5850ARKm",
      "diff_hunk": "@@ -3212,13 +2972,18 @@ bool CConnman::Bind(const CService& addr_, unsigned int flags, NetPermissionFlag\n     const CService addr{MaybeFlipIPv6toCJDNS(addr_)};\n \n     bilingual_str strError;\n-    if (!BindListenPort(addr, strError, permissions)) {\n+    if (!BindAndStartListening(addr, strError)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"%s\\n\", strError.original);",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 1120,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "266ac3267390270e6794d478aa1fbe40e88ffb0f",
      "in_reply_to_id": 1934736289,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Changed to `LogError()` and removed the newline. I did not know the trailing newlines are now unnecessary (since bbbb2e43ee95c9a8866aa1f65e3f001f752dfed2).",
      "created_at": "2025-02-07T09:26:38Z",
      "updated_at": "2025-02-07T09:26:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1946227366",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946227366"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2975,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946240012",
      "pull_request_review_id": 2601251958,
      "id": 1946240012,
      "node_id": "PRRC_kwDOABII5850AUQM",
      "diff_hunk": "@@ -0,0 +1,533 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+#include <cassert>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+static CService GetBindAddress(const Sock& sock)\n+{\n+    CService addr_bind;\n+    struct sockaddr_storage sockaddr_bind;\n+    socklen_t sockaddr_bind_len = sizeof(sockaddr_bind);\n+    if (!sock.GetSockName((struct sockaddr*)&sockaddr_bind, &sockaddr_bind_len)) {\n+        addr_bind.SetSockAddr((const struct sockaddr*)&sockaddr_bind);\n+    } else {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"getsockname failed\\n\");\n+    }\n+    return addr_bind;\n+}\n+\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& errmsg)\n+{\n+    // Create socket for listening for incoming connections\n+    struct sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {\n+        errmsg = Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()));\n+        return false;\n+    }\n+\n+    std::unique_ptr<Sock> sock{CreateSock(to.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP)};\n+    if (!sock) {\n+        errmsg = Untranslated(strprintf(\"Cannot create %s listen socket: %s\",\n+                                        to.ToStringAddrPort(),\n+                                        NetworkErrorString(WSAGetLastError())));\n+        return false;\n+    }\n+\n+    int one{1};\n+\n+    // Allow binding if the port is still in TIME_WAIT state after\n+    // the program was closed and restarted.\n+    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+        LogPrintLevel(BCLog::NET,\n+                      BCLog::Level::Info,\n+                      \"Cannot set SO_REUSEADDR on %s listen socket: %s, continuing anyway\\n\",\n+                      to.ToStringAddrPort(),\n+                      NetworkErrorString(WSAGetLastError()));\n+    }\n+\n+    // some systems don't have IPV6_V6ONLY but are always v6only; others do have the option\n+    // and enable it by default or not. Try to enable it, if possible.\n+    if (to.IsIPv6()) {\n+#ifdef IPV6_V6ONLY\n+        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_V6ONLY on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+#ifdef WIN32\n+        int prot_level{PROTECTION_LEVEL_UNRESTRICTED};\n+        if (sock->SetSockOpt(IPPROTO_IPV6,\n+                             IPV6_PROTECTION_LEVEL,\n+                             reinterpret_cast<const char*>(&prot_level),\n+                             sizeof(prot_level)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_PROTECTION_LEVEL on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+    }\n+\n+    if (sock->Bind(reinterpret_cast<sockaddr*>(&storage), len) == SOCKET_ERROR) {\n+        const int err{WSAGetLastError()};\n+        errmsg = strprintf(_(\"Cannot bind to %s: %s%s\"),\n+                           to.ToStringAddrPort(),\n+                           NetworkErrorString(err),\n+                           err == WSAEADDRINUSE\n+                               ? std::string{\" (\"} + CLIENT_NAME + \" already running?)\"\n+                               : \"\");",
      "path": "src/common/sockman.cpp",
      "position": null,
      "original_position": 96,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "266ac3267390270e6794d478aa1fbe40e88ffb0f",
      "in_reply_to_id": 1934748506,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-02-07T09:35:15Z",
      "updated_at": "2025-02-07T09:35:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1946240012",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946240012"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": 91,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 96,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946244171",
      "pull_request_review_id": 2601259465,
      "id": 1946244171,
      "node_id": "PRRC_kwDOABII5850AVRL",
      "diff_hunk": "@@ -0,0 +1,533 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+#include <cassert>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+static CService GetBindAddress(const Sock& sock)\n+{\n+    CService addr_bind;\n+    struct sockaddr_storage sockaddr_bind;\n+    socklen_t sockaddr_bind_len = sizeof(sockaddr_bind);\n+    if (!sock.GetSockName((struct sockaddr*)&sockaddr_bind, &sockaddr_bind_len)) {\n+        addr_bind.SetSockAddr((const struct sockaddr*)&sockaddr_bind);\n+    } else {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"getsockname failed\\n\");\n+    }\n+    return addr_bind;\n+}\n+\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& errmsg)\n+{\n+    // Create socket for listening for incoming connections\n+    struct sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {\n+        errmsg = Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()));\n+        return false;\n+    }\n+\n+    std::unique_ptr<Sock> sock{CreateSock(to.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP)};\n+    if (!sock) {\n+        errmsg = Untranslated(strprintf(\"Cannot create %s listen socket: %s\",\n+                                        to.ToStringAddrPort(),\n+                                        NetworkErrorString(WSAGetLastError())));\n+        return false;\n+    }\n+\n+    int one{1};\n+\n+    // Allow binding if the port is still in TIME_WAIT state after\n+    // the program was closed and restarted.\n+    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+        LogPrintLevel(BCLog::NET,\n+                      BCLog::Level::Info,\n+                      \"Cannot set SO_REUSEADDR on %s listen socket: %s, continuing anyway\\n\",\n+                      to.ToStringAddrPort(),\n+                      NetworkErrorString(WSAGetLastError()));",
      "path": "src/common/sockman.cpp",
      "position": 60,
      "original_position": 59,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "266ac3267390270e6794d478aa1fbe40e88ffb0f",
      "in_reply_to_id": 1934754380,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-02-07T09:38:33Z",
      "updated_at": "2025-02-07T09:38:33Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1946244171",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946244171"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": 56,
      "original_start_line": 55,
      "start_side": "RIGHT",
      "line": 60,
      "original_line": 60,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946265398",
      "pull_request_review_id": 2601294413,
      "id": 1946265398,
      "node_id": "PRRC_kwDOABII5850Aac2",
      "diff_hunk": "@@ -3440,19 +3199,19 @@ void CConnman::StopNodes()\n     }\n \n     // Delete peer connections.\n-    std::vector<CNode*> nodes;\n+    decltype(m_nodes) nodes;\n     WITH_LOCK(m_nodes_mutex, nodes.swap(m_nodes));\n-    for (CNode* pnode : nodes) {\n-        LogDebug(BCLog::NET, \"%s\\n\", pnode->DisconnectMsg(fLogIPs));\n-        pnode->CloseSocketDisconnect();\n+    for (auto& [_, pnode] : nodes) {\n+        MarkAsDisconnectAndCloseConnection(*pnode);\n         DeleteNode(pnode);\n     }\n \n     for (CNode* pnode : m_nodes_disconnected) {\n         DeleteNode(pnode);\n     }\n     m_nodes_disconnected.clear();\n-    vhListenSocket.clear();\n+    m_listen_permissions.clear();",
      "path": "src/net.cpp",
      "position": 1239,
      "original_position": 1219,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "266ac3267390270e6794d478aa1fbe40e88ffb0f",
      "in_reply_to_id": 1934686592,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": ":facepalm: makes total sense, I was thinking about the remote sockets.",
      "created_at": "2025-02-07T09:53:55Z",
      "updated_at": "2025-02-07T09:53:55Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1946265398",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946265398"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 3244,
      "original_line": 3244,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946267787",
      "pull_request_review_id": 2601298241,
      "id": 1946267787,
      "node_id": "PRRC_kwDOABII5850AbCL",
      "diff_hunk": "@@ -3212,13 +2972,18 @@ bool CConnman::Bind(const CService& addr_, unsigned int flags, NetPermissionFlag\n     const CService addr{MaybeFlipIPv6toCJDNS(addr_)};\n \n     bilingual_str strError;\n-    if (!BindListenPort(addr, strError, permissions)) {\n+    if (!BindAndStartListening(addr, strError)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"%s\\n\", strError.original);\n         if ((flags & BF_REPORT_ERROR) && m_client_interface) {\n             m_client_interface->ThreadSafeMessageBox(strError, \"\", CClientUIInterface::MSG_ERROR);\n         }\n         return false;\n     }\n \n+    LogPrintLevel(BCLog::NET, BCLog::Level::Info, \"Bound to and listening on %s\\n\", addr.ToStringAddrPort());\n+\n+    m_listen_permissions.emplace(addr, permissions);",
      "path": "src/net.cpp",
      "position": 1149,
      "original_position": 1129,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "266ac3267390270e6794d478aa1fbe40e88ffb0f",
      "in_reply_to_id": 1934690968,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Yeah, sorry, me confusing sockets again. An `Assume()` would be nice though.",
      "created_at": "2025-02-07T09:55:36Z",
      "updated_at": "2025-02-07T09:55:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1946267787",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946267787"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 3015,
      "original_line": 3015,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946271517",
      "pull_request_review_id": 2601304282,
      "id": 1946271517,
      "node_id": "PRRC_kwDOABII5850Ab8d",
      "diff_hunk": "@@ -0,0 +1,533 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+#include <cassert>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+static CService GetBindAddress(const Sock& sock)\n+{\n+    CService addr_bind;\n+    struct sockaddr_storage sockaddr_bind;\n+    socklen_t sockaddr_bind_len = sizeof(sockaddr_bind);\n+    if (!sock.GetSockName((struct sockaddr*)&sockaddr_bind, &sockaddr_bind_len)) {\n+        addr_bind.SetSockAddr((const struct sockaddr*)&sockaddr_bind);\n+    } else {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"getsockname failed\\n\");\n+    }\n+    return addr_bind;\n+}\n+\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& errmsg)\n+{\n+    // Create socket for listening for incoming connections\n+    struct sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {\n+        errmsg = Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()));\n+        return false;\n+    }\n+\n+    std::unique_ptr<Sock> sock{CreateSock(to.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP)};\n+    if (!sock) {\n+        errmsg = Untranslated(strprintf(\"Cannot create %s listen socket: %s\",\n+                                        to.ToStringAddrPort(),\n+                                        NetworkErrorString(WSAGetLastError())));\n+        return false;\n+    }\n+\n+    int one{1};\n+\n+    // Allow binding if the port is still in TIME_WAIT state after\n+    // the program was closed and restarted.\n+    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+        LogPrintLevel(BCLog::NET,\n+                      BCLog::Level::Info,\n+                      \"Cannot set SO_REUSEADDR on %s listen socket: %s, continuing anyway\\n\",\n+                      to.ToStringAddrPort(),\n+                      NetworkErrorString(WSAGetLastError()));\n+    }\n+\n+    // some systems don't have IPV6_V6ONLY but are always v6only; others do have the option\n+    // and enable it by default or not. Try to enable it, if possible.\n+    if (to.IsIPv6()) {\n+#ifdef IPV6_V6ONLY\n+        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_V6ONLY on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+#ifdef WIN32\n+        int prot_level{PROTECTION_LEVEL_UNRESTRICTED};\n+        if (sock->SetSockOpt(IPPROTO_IPV6,\n+                             IPV6_PROTECTION_LEVEL,\n+                             reinterpret_cast<const char*>(&prot_level),\n+                             sizeof(prot_level)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_PROTECTION_LEVEL on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+    }\n+\n+    if (sock->Bind(reinterpret_cast<sockaddr*>(&storage), len) == SOCKET_ERROR) {\n+        const int err{WSAGetLastError()};\n+        errmsg = strprintf(_(\"Cannot bind to %s: %s%s\"),\n+                           to.ToStringAddrPort(),\n+                           NetworkErrorString(err),\n+                           err == WSAEADDRINUSE\n+                               ? std::string{\" (\"} + CLIENT_NAME + \" already running?)\"\n+                               : \"\");\n+        return false;\n+    }\n+\n+    // Listen for incoming connections\n+    if (sock->Listen(SOMAXCONN) == SOCKET_ERROR) {\n+        errmsg = strprintf(_(\"Cannot listen to %s: %s\"), to.ToStringAddrPort(), NetworkErrorString(WSAGetLastError()));",
      "path": "src/common/sockman.cpp",
      "position": null,
      "original_position": 102,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "266ac3267390270e6794d478aa1fbe40e88ffb0f",
      "in_reply_to_id": 1934755815,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-02-07T09:58:21Z",
      "updated_at": "2025-02-07T09:58:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1946271517",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946271517"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 102,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946284407",
      "pull_request_review_id": 2601326987,
      "id": 1946284407,
      "node_id": "PRRC_kwDOABII5850AfF3",
      "diff_hunk": "@@ -0,0 +1,533 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+#include <cassert>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+static CService GetBindAddress(const Sock& sock)\n+{\n+    CService addr_bind;\n+    struct sockaddr_storage sockaddr_bind;\n+    socklen_t sockaddr_bind_len = sizeof(sockaddr_bind);\n+    if (!sock.GetSockName((struct sockaddr*)&sockaddr_bind, &sockaddr_bind_len)) {\n+        addr_bind.SetSockAddr((const struct sockaddr*)&sockaddr_bind);",
      "path": "src/common/sockman.cpp",
      "position": null,
      "original_position": 25,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "266ac3267390270e6794d478aa1fbe40e88ffb0f",
      "in_reply_to_id": 1935267717,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Removed `struct` from `BindAndStartListening()` in commit `style: modernize the style of SockMan::BindListenPort()`.\r\n\r\n`GetBindAddress()` was just moved verbatim without any mods from `net.cpp` to `sockman.cpp` in another commit. This makes it easier to review with\r\n```\r\n[diff]  \r\n        colorMoved = dimmed-zebra\r\n        colorMovedWS = allow-indentation-change\r\n```\r\nin `~/.gitconfig`. Will leave it as it is. Don't want to bloat this PR further with one more \"style changing\" commit.",
      "created_at": "2025-02-07T10:08:11Z",
      "updated_at": "2025-02-07T10:08:11Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1946284407",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946284407"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": 22,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 25,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946299108",
      "pull_request_review_id": 2601353885,
      "id": 1946299108,
      "node_id": "PRRC_kwDOABII5850Airk",
      "diff_hunk": "@@ -3037,117 +2899,20 @@ void CConnman::ThreadMessageHandler()\n     }\n }\n \n-void CConnman::ThreadI2PAcceptIncoming()\n+void CConnman::EventI2PListen(const CService& addr, bool success)\n {\n-    static constexpr auto err_wait_begin = 1s;\n-    static constexpr auto err_wait_cap = 5min;\n-    auto err_wait = err_wait_begin;\n-\n-    bool advertising_listen_addr = false;\n-    i2p::Connection conn;\n-\n-    auto SleepOnFailure = [&]() {\n-        interruptNet.sleep_for(err_wait);\n-        if (err_wait < err_wait_cap) {\n-            err_wait += 1s;\n-        }\n-    };\n-\n-    while (!interruptNet) {\n-\n-        if (!m_i2p_sam_session->Listen(conn)) {\n-            if (advertising_listen_addr && conn.me.IsValid()) {\n-                RemoveLocal(conn.me);\n-                advertising_listen_addr = false;\n-            }\n-            SleepOnFailure();\n-            continue;\n+    if (success) {\n+        if (!m_i2p_advertising_listen_addr) {\n+            AddLocal(addr, LOCAL_MANUAL);\n+            m_i2p_advertising_listen_addr = true;\n         }\n-\n-        if (!advertising_listen_addr) {\n-            AddLocal(conn.me, LOCAL_MANUAL);\n-            advertising_listen_addr = true;\n-        }\n-\n-        if (!m_i2p_sam_session->Accept(conn)) {\n-            SleepOnFailure();\n-            continue;\n-        }\n-\n-        CreateNodeFromAcceptedSocket(std::move(conn.sock), NetPermissionFlags::None,\n-                                     CAddress{conn.me, NODE_NONE}, CAddress{conn.peer, NODE_NONE});\n-\n-        err_wait = err_wait_begin;\n-    }\n-}\n-\n-bool CConnman::BindListenPort(const CService& addrBind, bilingual_str& strError, NetPermissionFlags permissions)\n-{\n-    int nOne = 1;\n-\n-    // Create socket for listening for incoming connections\n-    struct sockaddr_storage sockaddr;\n-    socklen_t len = sizeof(sockaddr);\n-    if (!addrBind.GetSockAddr((struct sockaddr*)&sockaddr, &len))\n-    {\n-        strError = Untranslated(strprintf(\"Bind address family for %s not supported\", addrBind.ToStringAddrPort()));\n-        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"%s\\n\", strError.original);\n-        return false;\n-    }\n-\n-    std::unique_ptr<Sock> sock = CreateSock(addrBind.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP);\n-    if (!sock) {\n-        strError = Untranslated(strprintf(\"Couldn't open socket for incoming connections (socket returned error %s)\", NetworkErrorString(WSAGetLastError())));\n-        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"%s\\n\", strError.original);\n-        return false;\n-    }\n-\n-    // Allow binding if the port is still in TIME_WAIT state after\n-    // the program was closed and restarted.\n-    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, (sockopt_arg_type)&nOne, sizeof(int)) == SOCKET_ERROR) {\n-        strError = Untranslated(strprintf(\"Error setting SO_REUSEADDR on socket: %s, continuing anyway\", NetworkErrorString(WSAGetLastError())));\n-        LogPrintf(\"%s\\n\", strError.original);\n-    }\n-\n-    // some systems don't have IPV6_V6ONLY but are always v6only; others do have the option\n-    // and enable it by default or not. Try to enable it, if possible.\n-    if (addrBind.IsIPv6()) {\n-#ifdef IPV6_V6ONLY\n-        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, (sockopt_arg_type)&nOne, sizeof(int)) == SOCKET_ERROR) {\n-            strError = Untranslated(strprintf(\"Error setting IPV6_V6ONLY on socket: %s, continuing anyway\", NetworkErrorString(WSAGetLastError())));\n-            LogPrintf(\"%s\\n\", strError.original);\n-        }\n-#endif\n-#ifdef WIN32\n-        int nProtLevel = PROTECTION_LEVEL_UNRESTRICTED;\n-        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_PROTECTION_LEVEL, (const char*)&nProtLevel, sizeof(int)) == SOCKET_ERROR) {\n-            strError = Untranslated(strprintf(\"Error setting IPV6_PROTECTION_LEVEL on socket: %s, continuing anyway\", NetworkErrorString(WSAGetLastError())));\n-            LogPrintf(\"%s\\n\", strError.original);\n-        }\n-#endif\n+        return;",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 1071,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "266ac3267390270e6794d478aa1fbe40e88ffb0f",
      "in_reply_to_id": 1935304394,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In general, less indentation makes the code more readable, so I prefer to have `return;` and then the subsequent code to be with less indentation.\r\n\r\nAnyway this code was changed and now uses `switch` (see `CConnman::EventI2PStatus()` after I push).",
      "created_at": "2025-02-07T10:18:35Z",
      "updated_at": "2025-02-07T10:18:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1946299108",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946299108"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2908,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946303871",
      "pull_request_review_id": 2601361778,
      "id": 1946303871,
      "node_id": "PRRC_kwDOABII5850Aj1_",
      "diff_hunk": "@@ -0,0 +1,435 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#ifndef BITCOIN_COMMON_SOCKMAN_H\n+#define BITCOIN_COMMON_SOCKMAN_H\n+\n+#include <i2p.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <util/fs.h>\n+#include <util/sock.h>\n+#include <util/translation.h>\n+\n+#include <atomic>\n+#include <memory>\n+#include <queue>\n+#include <span>\n+#include <thread>\n+#include <variant>\n+#include <vector>\n+\n+typedef int64_t NodeId;\n+\n+/**\n+ * A socket manager class which handles socket operations.\n+ * To use this class, inherit from it and implement the pure virtual methods.\n+ * Handled operations:\n+ * - binding and listening on sockets\n+ * - starting of necessary threads to process socket operations\n+ * - accepting incoming connections\n+ * - making outbound connections\n+ * - closing connections\n+ * - waiting for IO readiness on sockets and doing send/recv accordingly\n+ */\n+class SockMan\n+{\n+public:\n+\n+    virtual ~SockMan() = default;",
      "path": "src/common/sockman.h",
      "position": 54,
      "original_position": 40,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "266ac3267390270e6794d478aa1fbe40e88ffb0f",
      "in_reply_to_id": 1935292076,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```\r\nerror: delete called on non-final 'CConnman' that has virtual functions but non-virtual destructor [-Werror,-Wdelete-non-abstract-non-virtual-dtor]\r\n```",
      "created_at": "2025-02-07T10:22:11Z",
      "updated_at": "2025-02-07T10:22:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1946303871",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946303871"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 54,
      "original_line": 54,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946311849",
      "pull_request_review_id": 2601374407,
      "id": 1946311849,
      "node_id": "PRRC_kwDOABII5850Alyp",
      "diff_hunk": "@@ -0,0 +1,435 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#ifndef BITCOIN_COMMON_SOCKMAN_H\n+#define BITCOIN_COMMON_SOCKMAN_H\n+\n+#include <i2p.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <util/fs.h>\n+#include <util/sock.h>\n+#include <util/translation.h>\n+\n+#include <atomic>\n+#include <memory>\n+#include <queue>\n+#include <span>\n+#include <thread>\n+#include <variant>\n+#include <vector>\n+\n+typedef int64_t NodeId;\n+\n+/**\n+ * A socket manager class which handles socket operations.\n+ * To use this class, inherit from it and implement the pure virtual methods.\n+ * Handled operations:\n+ * - binding and listening on sockets\n+ * - starting of necessary threads to process socket operations\n+ * - accepting incoming connections\n+ * - making outbound connections\n+ * - closing connections\n+ * - waiting for IO readiness on sockets and doing send/recv accordingly\n+ */\n+class SockMan\n+{\n+public:\n+\n+    virtual ~SockMan() = default;\n+\n+    //\n+    // Non-virtual functions, to be reused by children classes.\n+    //\n+\n+    /**\n+     * Bind to a new address:port, start listening and add the listen socket to `m_listen`.\n+     * Should be called before `StartSocketsThreads()`.\n+     * @param[in] to Where to bind.\n+     * @param[out] errmsg Error string if an error occurs.\n+     * @retval true Success.\n+     * @retval false Failure, `strError` will be set.\n+     */\n+    bool BindAndStartListening(const CService& to, bilingual_str& errmsg);\n+\n+    /**\n+     * Options to influence `StartSocketsThreads()`.\n+     */\n+    struct Options {\n+        std::string_view socket_handler_thread_name;\n+\n+        struct I2P {\n+            explicit I2P(const fs::path& file, const Proxy& proxy, std::string_view accept_thread_name)\n+                : private_key_file{file},\n+                  sam_proxy{proxy},\n+                  accept_thread_name{accept_thread_name}\n+            {}\n+\n+            const fs::path private_key_file;\n+            const Proxy sam_proxy;\n+            const std::string_view accept_thread_name;\n+        };\n+\n+        /**\n+         * I2P options. If set then a thread will be started that will accept incoming I2P connections.\n+         */\n+        std::optional<I2P> i2p;\n+    };\n+\n+    /**\n+     * Start the necessary threads for sockets IO.\n+     */\n+    void StartSocketsThreads(const Options& options);\n+\n+    /**\n+     * Join (wait for) the threads started by `StartSocketsThreads()` to exit.\n+     */\n+    void JoinSocketsThreads();",
      "path": "src/common/sockman.h",
      "position": 102,
      "original_position": 88,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "266ac3267390270e6794d478aa1fbe40e88ffb0f",
      "in_reply_to_id": 1935326693,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "There are multiple sockets and multiple threads. \"socket threads\" looks like there is one socket and multiple threads. Will leave it as it is.",
      "created_at": "2025-02-07T10:28:14Z",
      "updated_at": "2025-02-07T10:28:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1946311849",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946311849"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": 95,
      "original_start_line": 81,
      "start_side": "RIGHT",
      "line": 102,
      "original_line": 102,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946320421",
      "pull_request_review_id": 2601388736,
      "id": 1946320421,
      "node_id": "PRRC_kwDOABII5850An4l",
      "diff_hunk": "@@ -3636,14 +3395,14 @@ bool CConnman::DisconnectNode(const CNetAddr& addr)\n bool CConnman::DisconnectNode(NodeId id)\n {\n     LOCK(m_nodes_mutex);\n-    for(CNode* pnode : m_nodes) {\n-        if (id == pnode->GetId()) {\n-            LogDebug(BCLog::NET, \"disconnect by id peer=%d; disconnecting\\n\", pnode->GetId());\n-            pnode->fDisconnect = true;\n-            return true;\n-        }\n+    auto it{m_nodes.find(id)};\n+    if (it == m_nodes.end()) {",
      "path": "src/net.cpp",
      "position": 1282,
      "original_position": 1262,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "266ac3267390270e6794d478aa1fbe40e88ffb0f",
      "in_reply_to_id": 1935367810,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Less indentation makes the code more readable in general. So I prefer:\r\n\r\n```\r\nif (A) {\r\n    return;\r\n}\r\nCODE;\r\n```\r\nover:\r\n```\r\nif (!A) {\r\n    CODE;\r\n} else {\r\n    return;\r\n}\r\n```\r\n\r\nReduced scope is nice, but I find `if (auto it{m_nodes.find(id)}; it != m_nodes.end()) {` hard to read. Sometimes I confuse it for a for-loop: `for (foo; bar; baz) {`. Also in this particular case the function ends right after this, so the scope of `it` is the same.\r\n\r\nWill leave it as it is.",
      "created_at": "2025-02-07T10:34:47Z",
      "updated_at": "2025-02-07T12:50:11Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1946320421",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946320421"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": 3429,
      "original_start_line": 3398,
      "start_side": "RIGHT",
      "line": 3430,
      "original_line": 3430,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946344669",
      "pull_request_review_id": 2601428806,
      "id": 1946344669,
      "node_id": "PRRC_kwDOABII5850Atzd",
      "diff_hunk": "@@ -5077,10 +5077,15 @@ void PeerManagerImpl::EvictExtraOutboundPeers(std::chrono::seconds now)\n \n         m_connman.ForEachNode([&](CNode* pnode) {\n             if (!pnode->IsBlockOnlyConn() || pnode->fDisconnect) return;\n-            if (pnode->GetId() > youngest_peer.first) {\n-                next_youngest_peer = youngest_peer;\n-                youngest_peer.first = pnode->GetId();\n-                youngest_peer.second = pnode->m_last_block_time;\n+            if (pnode->GetId() > next_youngest_peer.first) {\n+                if (pnode->GetId() > youngest_peer.first) {\n+                    next_youngest_peer = youngest_peer;\n+                    youngest_peer.first = pnode->GetId();\n+                    youngest_peer.second = pnode->m_last_block_time;\n+                } else {\n+                    next_youngest_peer.first = pnode->GetId();\n+                    next_youngest_peer.second = pnode->m_last_block_time;\n+                }",
      "path": "src/net_processing.cpp",
      "position": 16,
      "original_position": 16,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "266ac3267390270e6794d478aa1fbe40e88ffb0f",
      "in_reply_to_id": 1935376623,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "There should be no change in behavior. Note that the original code in `master` was very subtle - it required that `ForEachNode()` would iterate the nodes in increasing order of `id`:\r\n\r\n```cpp\r\nstd::pair<NodeId, std::chrono::seconds> youngest_peer{-1, 0}, next_youngest_peer{-1, 0};\r\n\r\nm_connman.ForEachNode([&](CNode* pnode) {\r\n    if (!pnode->IsBlockOnlyConn() || pnode->fDisconnect) return;\r\n    if (pnode->GetId() > youngest_peer.first) {\r\n        next_youngest_peer = youngest_peer;\r\n        youngest_peer.first = pnode->GetId();\r\n        youngest_peer.second = pnode->m_last_block_time;\r\n    }\r\n});\r\n```\r\nThe condition `pnode->GetId() > youngest_peer.first` would be `true` every time. Because of that, this code is equivalent to:\r\n\r\n```cpp\r\nstd::pair<NodeId, std::chrono::seconds> youngest_peer{-1, 0}, next_youngest_peer{-1, 0};\r\n\r\nm_connman.ForEachNode([&](CNode* pnode) {\r\n    if (!pnode->IsBlockOnlyConn() || pnode->fDisconnect) return;\r\n    next_youngest_peer = youngest_peer;\r\n    youngest_peer.first = pnode->GetId();\r\n    youngest_peer.second = pnode->m_last_block_time;\r\n});\r\n```\r\n\r\nThe new code will again select the two youngest peers (the two with the bigger `id`s), but does not require that the iterating is in increasing order of `id`:\r\n\r\n```cpp\r\nstd::pair<NodeId, std::chrono::seconds> youngest_peer{-1, 0}, next_youngest_peer{-1, 0};\r\n\r\nm_connman.ForEachNode([&](CNode* pnode) {\r\n    if (!pnode->IsBlockOnlyConn() || pnode->fDisconnect) return;\r\n    if (pnode->GetId() > next_youngest_peer.first) {\r\n        if (pnode->GetId() > youngest_peer.first) {\r\n            next_youngest_peer = youngest_peer;\r\n            youngest_peer.first = pnode->GetId();\r\n            youngest_peer.second = pnode->m_last_block_time;\r\n        } else {  \r\n            next_youngest_peer.first = pnode->GetId();\r\n            next_youngest_peer.second = pnode->m_last_block_time;\r\n        }\r\n    }\r\n});\r\n```",
      "created_at": "2025-02-07T10:53:36Z",
      "updated_at": "2025-02-07T10:53:36Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1946344669",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946344669"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": 5090,
      "original_start_line": 5085,
      "start_side": "RIGHT",
      "line": 5093,
      "original_line": 5093,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946347206",
      "pull_request_review_id": 2601432656,
      "id": 1946347206,
      "node_id": "PRRC_kwDOABII5850AubG",
      "diff_hunk": "@@ -151,12 +150,12 @@ BOOST_FIXTURE_TEST_CASE(test_addnode_getaddednodeinfo_and_connection_detection,\n     }\n \n     BOOST_TEST_MESSAGE(\"\\nCheck that all connected peers are correctly detected as connected\");\n-    for (auto node : connman->TestNodes()) {\n+    for (const auto& [_, node] : connman->TestNodes()) {\n         BOOST_CHECK(connman->AlreadyConnectedPublic(node->addr));\n     }\n \n     // Clean up\n-    for (auto node : connman->TestNodes()) {\n+    for (const auto& [id, node] : connman->TestNodes()) {",
      "path": "src/test/net_peer_connection_tests.cpp",
      "position": null,
      "original_position": 40,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "266ac3267390270e6794d478aa1fbe40e88ffb0f",
      "in_reply_to_id": 1935384176,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-02-07T10:55:25Z",
      "updated_at": "2025-02-07T10:55:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1946347206",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946347206"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 158,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946353102",
      "pull_request_review_id": 2601442348,
      "id": 1946353102,
      "node_id": "PRRC_kwDOABII5850Av3O",
      "diff_hunk": "@@ -64,13 +64,15 @@ FUZZ_TARGET(connman, .init = initialize_connman)\n     connman.Init(options);\n \n     CNetAddr random_netaddr;\n-    CNode random_node = ConsumeNode(fuzzed_data_provider);\n+    NodeId node_id{0};\n+    CNode& random_node{*ConsumeNodeAsUniquePtr(fuzzed_data_provider, node_id++).release()};",
      "path": "src/test/fuzz/connman.cpp",
      "position": 6,
      "original_position": 6,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "266ac3267390270e6794d478aa1fbe40e88ffb0f",
      "in_reply_to_id": 1935390847,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "To avoid overlaps. In `master`, without this PR, this test could generate nodes with duplicate `id`s.",
      "created_at": "2025-02-07T11:00:05Z",
      "updated_at": "2025-02-07T11:00:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1946353102",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946353102"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": 67,
      "original_start_line": 67,
      "start_side": "RIGHT",
      "line": 68,
      "original_line": 68,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946359353",
      "pull_request_review_id": 2601452621,
      "id": 1946359353,
      "node_id": "PRRC_kwDOABII5850AxY5",
      "diff_hunk": "@@ -42,24 +42,30 @@ struct ConnmanTestMsg : public CConnman {\n         m_peer_connect_timeout = timeout;\n     }\n \n-    std::vector<CNode*> TestNodes()\n+    auto TestNodes()\n     {\n         LOCK(m_nodes_mutex);\n         return m_nodes;\n     }\n \n+    void AddTestNode(CNode& node, std::unique_ptr<Sock>&& sock)\n+    {\n+        TestOnlyAddExistentNode(node.GetId(), std::move(sock));\n+        AddTestNode(node);\n+    }\n+\n     void AddTestNode(CNode& node)\n     {\n         LOCK(m_nodes_mutex);\n-        m_nodes.push_back(&node);\n+        m_nodes.emplace(node.GetId(), &node);",
      "path": "src/test/util/net.h",
      "position": null,
      "original_position": 21,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "266ac3267390270e6794d478aa1fbe40e88ffb0f",
      "in_reply_to_id": 1935397798,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-02-07T11:05:10Z",
      "updated_at": "2025-02-07T11:05:11Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1946359353",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946359353"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 60,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946367832",
      "pull_request_review_id": 2601467074,
      "id": 1946367832,
      "node_id": "PRRC_kwDOABII5850AzdY",
      "diff_hunk": "@@ -0,0 +1,435 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#ifndef BITCOIN_COMMON_SOCKMAN_H\n+#define BITCOIN_COMMON_SOCKMAN_H\n+\n+#include <i2p.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <util/fs.h>\n+#include <util/sock.h>\n+#include <util/translation.h>\n+\n+#include <atomic>\n+#include <memory>\n+#include <queue>\n+#include <span>\n+#include <thread>\n+#include <variant>\n+#include <vector>\n+\n+typedef int64_t NodeId;\n+\n+/**\n+ * A socket manager class which handles socket operations.\n+ * To use this class, inherit from it and implement the pure virtual methods.\n+ * Handled operations:\n+ * - binding and listening on sockets\n+ * - starting of necessary threads to process socket operations\n+ * - accepting incoming connections\n+ * - making outbound connections\n+ * - closing connections\n+ * - waiting for IO readiness on sockets and doing send/recv accordingly\n+ */\n+class SockMan\n+{\n+public:\n+\n+    virtual ~SockMan() = default;",
      "path": "src/common/sockman.h",
      "position": 54,
      "original_position": 40,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "266ac3267390270e6794d478aa1fbe40e88ffb0f",
      "in_reply_to_id": 1935292076,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Ah, and we can't make `CConnman` `final` while we have `struct ConnmanTestMsg : public CConnman`, got it. Should have tested before suggesting.",
      "created_at": "2025-02-07T11:12:08Z",
      "updated_at": "2025-02-07T11:12:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1946367832",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946367832"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 54,
      "original_line": 54,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946368965",
      "pull_request_review_id": 2601468958,
      "id": 1946368965,
      "node_id": "PRRC_kwDOABII5850AzvF",
      "diff_hunk": "@@ -2191,6 +2222,7 @@ void CConnman::SocketHandlerListening(const Sock::EventsPerSock& events_per_sock\n \n void CConnman::ThreadSocketHandler()\n {\n+    AssertLockNotHeld(m_nodes_mutex);",
      "path": "src/net.cpp",
      "position": 888,
      "original_position": 89,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "7aca044a932e163445f2fccec7739aa7768cf36e",
      "in_reply_to_id": 1935414710,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "It is for every function, not just \"thread\" ones - `doc/developer-notes.md` says:\r\n\r\n>  - Combine annotations in function declarations with run-time asserts in\r\n>    function definitions ...\r\n\r\nThis means:\r\n\r\n```cpp\r\nvoid f() EXCLUSIVE_LOCKS_REQUIRED(!m);\r\n\r\n...\r\n\r\nvoid f()\r\n{\r\n    AssertLockNotHeld(m);\r\n    ...\r\n}\r\n```\r\n\r\nThe reasoning is that the annotation `EXCLUSIVE_LOCKS_REQUIRED` can be ignored. It is nice that the check is done at compile time, but if the compiler is not clang then it will be ignored, or if the compiler is clang but is running without `-Werror`, then it will only result in a compile warning which is likely to be missed in the build output. In other words, it is possible to create a violating code and compile and run it with both gcc and clang. In that case `AssertLockNotHeld()` will stop the program at runtime.",
      "created_at": "2025-02-07T11:13:05Z",
      "updated_at": "2025-02-07T11:13:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1946368965",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946368965"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 2092,
      "original_line": 2092,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946371426",
      "pull_request_review_id": 2601473180,
      "id": 1946371426,
      "node_id": "PRRC_kwDOABII5850A0Vi",
      "diff_hunk": "@@ -0,0 +1,435 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#ifndef BITCOIN_COMMON_SOCKMAN_H\n+#define BITCOIN_COMMON_SOCKMAN_H\n+\n+#include <i2p.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <util/fs.h>\n+#include <util/sock.h>\n+#include <util/translation.h>\n+\n+#include <atomic>\n+#include <memory>\n+#include <queue>\n+#include <span>\n+#include <thread>\n+#include <variant>\n+#include <vector>\n+\n+typedef int64_t NodeId;\n+\n+/**\n+ * A socket manager class which handles socket operations.\n+ * To use this class, inherit from it and implement the pure virtual methods.\n+ * Handled operations:\n+ * - binding and listening on sockets\n+ * - starting of necessary threads to process socket operations\n+ * - accepting incoming connections\n+ * - making outbound connections\n+ * - closing connections\n+ * - waiting for IO readiness on sockets and doing send/recv accordingly\n+ */\n+class SockMan\n+{\n+public:\n+\n+    virtual ~SockMan() = default;\n+\n+    //\n+    // Non-virtual functions, to be reused by children classes.\n+    //\n+\n+    /**\n+     * Bind to a new address:port, start listening and add the listen socket to `m_listen`.\n+     * Should be called before `StartSocketsThreads()`.\n+     * @param[in] to Where to bind.\n+     * @param[out] errmsg Error string if an error occurs.\n+     * @retval true Success.\n+     * @retval false Failure, `strError` will be set.\n+     */\n+    bool BindAndStartListening(const CService& to, bilingual_str& errmsg);\n+\n+    /**\n+     * Options to influence `StartSocketsThreads()`.\n+     */\n+    struct Options {\n+        std::string_view socket_handler_thread_name;\n+\n+        struct I2P {\n+            explicit I2P(const fs::path& file, const Proxy& proxy, std::string_view accept_thread_name)\n+                : private_key_file{file},\n+                  sam_proxy{proxy},\n+                  accept_thread_name{accept_thread_name}\n+            {}\n+\n+            const fs::path private_key_file;\n+            const Proxy sam_proxy;\n+            const std::string_view accept_thread_name;\n+        };\n+\n+        /**\n+         * I2P options. If set then a thread will be started that will accept incoming I2P connections.\n+         */\n+        std::optional<I2P> i2p;\n+    };\n+\n+    /**\n+     * Start the necessary threads for sockets IO.\n+     */\n+    void StartSocketsThreads(const Options& options);\n+\n+    /**\n+     * Join (wait for) the threads started by `StartSocketsThreads()` to exit.\n+     */\n+    void JoinSocketsThreads();",
      "path": "src/common/sockman.h",
      "position": 102,
      "original_position": 88,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "266ac3267390270e6794d478aa1fbe40e88ffb0f",
      "in_reply_to_id": 1935326693,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "`SocketsAndThreads` would be clearer, but I think the current name is fine.",
      "created_at": "2025-02-07T11:15:13Z",
      "updated_at": "2025-02-07T11:15:13Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1946371426",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946371426"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": 95,
      "original_start_line": 81,
      "start_side": "RIGHT",
      "line": 102,
      "original_line": 102,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946377084",
      "pull_request_review_id": 2601482565,
      "id": 1946377084,
      "node_id": "PRRC_kwDOABII5850A1t8",
      "diff_hunk": "@@ -0,0 +1,435 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#ifndef BITCOIN_COMMON_SOCKMAN_H\n+#define BITCOIN_COMMON_SOCKMAN_H\n+\n+#include <i2p.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <util/fs.h>\n+#include <util/sock.h>\n+#include <util/translation.h>\n+\n+#include <atomic>\n+#include <memory>\n+#include <queue>\n+#include <span>\n+#include <thread>\n+#include <variant>\n+#include <vector>\n+\n+typedef int64_t NodeId;\n+\n+/**\n+ * A socket manager class which handles socket operations.\n+ * To use this class, inherit from it and implement the pure virtual methods.\n+ * Handled operations:\n+ * - binding and listening on sockets\n+ * - starting of necessary threads to process socket operations\n+ * - accepting incoming connections\n+ * - making outbound connections\n+ * - closing connections\n+ * - waiting for IO readiness on sockets and doing send/recv accordingly\n+ */\n+class SockMan\n+{\n+public:\n+\n+    virtual ~SockMan() = default;\n+\n+    //\n+    // Non-virtual functions, to be reused by children classes.\n+    //\n+\n+    /**\n+     * Bind to a new address:port, start listening and add the listen socket to `m_listen`.\n+     * Should be called before `StartSocketsThreads()`.\n+     * @param[in] to Where to bind.\n+     * @param[out] errmsg Error string if an error occurs.\n+     * @retval true Success.\n+     * @retval false Failure, `strError` will be set.\n+     */\n+    bool BindAndStartListening(const CService& to, bilingual_str& errmsg);\n+\n+    /**\n+     * Options to influence `StartSocketsThreads()`.\n+     */\n+    struct Options {\n+        std::string_view socket_handler_thread_name;\n+\n+        struct I2P {\n+            explicit I2P(const fs::path& file, const Proxy& proxy, std::string_view accept_thread_name)\n+                : private_key_file{file},\n+                  sam_proxy{proxy},\n+                  accept_thread_name{accept_thread_name}\n+            {}\n+\n+            const fs::path private_key_file;\n+            const Proxy sam_proxy;\n+            const std::string_view accept_thread_name;\n+        };\n+\n+        /**\n+         * I2P options. If set then a thread will be started that will accept incoming I2P connections.\n+         */\n+        std::optional<I2P> i2p;\n+    };\n+\n+    /**\n+     * Start the necessary threads for sockets IO.\n+     */\n+    void StartSocketsThreads(const Options& options);\n+\n+    /**\n+     * Join (wait for) the threads started by `StartSocketsThreads()` to exit.\n+     */\n+    void JoinSocketsThreads();",
      "path": "src/common/sockman.h",
      "position": 102,
      "original_position": 88,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "266ac3267390270e6794d478aa1fbe40e88ffb0f",
      "in_reply_to_id": 1935326693,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "We open/close sockets, we don't start/join them, so I prefer the current name over adding \"And\".",
      "created_at": "2025-02-07T11:20:08Z",
      "updated_at": "2025-02-07T11:20:08Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1946377084",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946377084"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": 95,
      "original_start_line": 81,
      "start_side": "RIGHT",
      "line": 102,
      "original_line": 102,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946381130",
      "pull_request_review_id": 2601489607,
      "id": 1946381130,
      "node_id": "PRRC_kwDOABII5850A2tK",
      "diff_hunk": "@@ -2191,6 +2222,7 @@ void CConnman::SocketHandlerListening(const Sock::EventsPerSock& events_per_sock\n \n void CConnman::ThreadSocketHandler()\n {\n+    AssertLockNotHeld(m_nodes_mutex);",
      "path": "src/net.cpp",
      "position": 888,
      "original_position": 89,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "7aca044a932e163445f2fccec7739aa7768cf36e",
      "in_reply_to_id": 1935414710,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Ah, so it's done as a general rule even if it makes less logical sense for the function at the root of a thread (as nothing can have taken the lock before it unless the thread is wrapped in some kind of utility that is weird enough to take locks).",
      "created_at": "2025-02-07T11:23:55Z",
      "updated_at": "2025-02-07T11:23:55Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1946381130",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946381130"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 2092,
      "original_line": 2092,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946444771",
      "pull_request_review_id": 2601593568,
      "id": 1946444771,
      "node_id": "PRRC_kwDOABII5850BGPj",
      "diff_hunk": "@@ -5077,10 +5077,15 @@ void PeerManagerImpl::EvictExtraOutboundPeers(std::chrono::seconds now)\n \n         m_connman.ForEachNode([&](CNode* pnode) {\n             if (!pnode->IsBlockOnlyConn() || pnode->fDisconnect) return;\n-            if (pnode->GetId() > youngest_peer.first) {\n-                next_youngest_peer = youngest_peer;\n-                youngest_peer.first = pnode->GetId();\n-                youngest_peer.second = pnode->m_last_block_time;\n+            if (pnode->GetId() > next_youngest_peer.first) {\n+                if (pnode->GetId() > youngest_peer.first) {\n+                    next_youngest_peer = youngest_peer;\n+                    youngest_peer.first = pnode->GetId();\n+                    youngest_peer.second = pnode->m_last_block_time;\n+                } else {\n+                    next_youngest_peer.first = pnode->GetId();\n+                    next_youngest_peer.second = pnode->m_last_block_time;\n+                }",
      "path": "src/net_processing.cpp",
      "position": 16,
      "original_position": 16,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "266ac3267390270e6794d478aa1fbe40e88ffb0f",
      "in_reply_to_id": 1935376623,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Ah, that was subtle, thanks for laying it out so clearly.\r\n\r\nMaybe amend the commit message in \"net: index nodes in CConnman by id\" with something like:\r\n> Change `PeerManagerImpl::EvictExtraOutboundPeers` to account for nodes no longer always being in order. The old code would have failed to update `next_youngest_peer` correctly if `CConnman::m_nodes` hadn't always had node ids in ascending order.",
      "created_at": "2025-02-07T12:19:21Z",
      "updated_at": "2025-02-07T12:19:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1946444771",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946444771"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": 5090,
      "original_start_line": 5085,
      "start_side": "RIGHT",
      "line": 5093,
      "original_line": 5093,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946505928",
      "pull_request_review_id": 2601696724,
      "id": 1946505928,
      "node_id": "PRRC_kwDOABII5850BVLI",
      "diff_hunk": "@@ -1660,9 +1588,24 @@ std::pair<size_t, bool> CConnman::SocketSendData(CNode& node) const\n         assert(node.m_send_memusage == 0);\n     }\n     node.vSendMsg.erase(node.vSendMsg.begin(), it);\n+\n+    if (nSentSize > 0) {\n+        RecordBytesSent(nSentSize);\n+    }\n+\n     return {nSentSize, data_left};\n }\n \n+CNode* CConnman::GetNodeById(NodeId node_id) const\n+{\n+    LOCK(m_nodes_mutex);\n+    auto it{m_nodes.find(node_id)};\n+    if (it != m_nodes.end()) {\n+        return it->second;",
      "path": "src/net.cpp",
      "position": 306,
      "original_position": 301,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "266ac3267390270e6794d478aa1fbe40e88ffb0f",
      "in_reply_to_id": 1935423919,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Maybe it is worth doing this: https://github.com/bitcoin/bitcoin/pull/30988#issuecomment-2485715952. It is a super good change and normally I would do it, but the reason I didn't is that it will increase the size of this PR which, I am afraid, would turn reviewers away.\r\n\r\nI will proceed to other suggestions and give this some thought...",
      "created_at": "2025-02-07T13:12:28Z",
      "updated_at": "2025-02-07T13:12:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1946505928",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946505928"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": 1604,
      "original_start_line": 1601,
      "start_side": "RIGHT",
      "line": 1607,
      "original_line": 1607,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946520524",
      "pull_request_review_id": 2601721609,
      "id": 1946520524,
      "node_id": "PRRC_kwDOABII5850BYvM",
      "diff_hunk": "@@ -0,0 +1,435 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#ifndef BITCOIN_COMMON_SOCKMAN_H\n+#define BITCOIN_COMMON_SOCKMAN_H\n+\n+#include <i2p.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <util/fs.h>\n+#include <util/sock.h>\n+#include <util/translation.h>\n+\n+#include <atomic>\n+#include <memory>\n+#include <queue>\n+#include <span>\n+#include <thread>\n+#include <variant>\n+#include <vector>\n+\n+typedef int64_t NodeId;\n+\n+/**\n+ * A socket manager class which handles socket operations.\n+ * To use this class, inherit from it and implement the pure virtual methods.\n+ * Handled operations:\n+ * - binding and listening on sockets\n+ * - starting of necessary threads to process socket operations\n+ * - accepting incoming connections\n+ * - making outbound connections\n+ * - closing connections\n+ * - waiting for IO readiness on sockets and doing send/recv accordingly\n+ */\n+class SockMan\n+{\n+public:\n+\n+    virtual ~SockMan() = default;\n+\n+    //\n+    // Non-virtual functions, to be reused by children classes.\n+    //\n+\n+    /**\n+     * Bind to a new address:port, start listening and add the listen socket to `m_listen`.\n+     * Should be called before `StartSocketsThreads()`.\n+     * @param[in] to Where to bind.\n+     * @param[out] errmsg Error string if an error occurs.\n+     * @retval true Success.\n+     * @retval false Failure, `strError` will be set.\n+     */\n+    bool BindAndStartListening(const CService& to, bilingual_str& errmsg);\n+\n+    /**\n+     * Options to influence `StartSocketsThreads()`.\n+     */\n+    struct Options {\n+        std::string_view socket_handler_thread_name;\n+\n+        struct I2P {\n+            explicit I2P(const fs::path& file, const Proxy& proxy, std::string_view accept_thread_name)\n+                : private_key_file{file},\n+                  sam_proxy{proxy},\n+                  accept_thread_name{accept_thread_name}\n+            {}\n+\n+            const fs::path private_key_file;\n+            const Proxy sam_proxy;\n+            const std::string_view accept_thread_name;\n+        };\n+\n+        /**\n+         * I2P options. If set then a thread will be started that will accept incoming I2P connections.\n+         */\n+        std::optional<I2P> i2p;\n+    };\n+\n+    /**\n+     * Start the necessary threads for sockets IO.\n+     */\n+    void StartSocketsThreads(const Options& options);\n+\n+    /**\n+     * Join (wait for) the threads started by `StartSocketsThreads()` to exit.\n+     */\n+    void JoinSocketsThreads();\n+\n+    /**\n+     * A more readable std::tuple<std::string, uint16_t> for host and port.\n+     */\n+    struct StringHostIntPort {\n+        const std::string& host;\n+        uint16_t port;\n+    };\n+\n+    /**\n+     * Make an outbound connection, save the socket internally and return a newly generated node id.\n+     * @param[in] to The address to connect to, either as CService or a host as string and port as\n+     * an integer, if the later is used, then `proxy` must be valid.\n+     * @param[in] is_important If true, then log failures with higher severity.\n+     * @param[in] proxy Proxy to connect through if `proxy.IsValid()` is true.\n+     * @param[out] proxy_failed If `proxy` is valid and the connection failed because of the\n+     * proxy, then it will be set to true.\n+     * @param[out] me If the connection was successful then this is set to the address on the\n+     * local side of the socket.\n+     * @return Newly generated node id, or std::nullopt if the operation fails.\n+     */\n+    std::optional<NodeId> ConnectAndMakeNodeId(const std::variant<CService, StringHostIntPort>& to,\n+                                               bool is_important,\n+                                               const Proxy& proxy,\n+                                               bool& proxy_failed,\n+                                               CService& me)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex, !m_unused_i2p_sessions_mutex);\n+\n+    /**\n+     * Disconnect a given peer by closing its socket and release resources occupied by it.\n+     * @return Whether the peer existed and its socket was closed by this call.\n+     */\n+    bool CloseConnection(NodeId node_id)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Try to send some data to the given node.\n+     * @param[in] node_id Identifier of the node to send to.\n+     * @param[in] data The data to send, it might happen that only a prefix of this is sent.\n+     * @param[in] will_send_more Used as an optimization if the caller knows that they will\n+     * be sending more data soon after this call.\n+     * @param[out] errmsg If <0 is returned then this will contain a human readable message\n+     * explaining the error.\n+     * @retval >=0 The number of bytes actually sent.\n+     * @retval <0 A permanent error has occurred.\n+     */\n+    ssize_t SendBytes(NodeId node_id,\n+                      std::span<const unsigned char> data,\n+                      bool will_send_more,\n+                      std::string& errmsg) const\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Close all sockets.\n+     */\n+    void CloseSockets();\n+\n+    /**\n+     * This is signaled when network activity should cease.\n+     * A pointer to it is saved in `m_i2p_sam_session`, so make sure that\n+     * the lifetime of `interruptNet` is not shorter than\n+     * the lifetime of `m_i2p_sam_session`.\n+     */\n+    CThreadInterrupt interruptNet;\n+\n+protected:\n+\n+    /**\n+     * During some tests mocked sockets are created outside of `SockMan`, make it\n+     * possible to add those so that send/recv can be exercised.\n+     */\n+    void TestOnlyAddExistentNode(NodeId node_id, std::unique_ptr<Sock>&& sock)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+private:\n+\n+    /**\n+     * Cap on the size of `m_unused_i2p_sessions`, to ensure it does not\n+     * unexpectedly use too much memory.\n+     */\n+    static constexpr size_t MAX_UNUSED_I2P_SESSIONS_SIZE{10};\n+\n+    //\n+    // Pure virtual functions must be implemented by children classes.\n+    //\n+\n+    /**\n+     * Be notified when a new connection has been accepted.\n+     * @param[in] node_id Id of the newly accepted connection.\n+     * @param[in] me The address and port at our side of the connection.\n+     * @param[in] them The address and port at the peer's side of the connection.\n+     * @retval true The new connection was accepted at the higher level.\n+     * @retval false The connection was refused at the higher level, so the\n+     * associated socket and node_id should be discarded by `SockMan`.\n+     */\n+    virtual bool EventNewConnectionAccepted(NodeId node_id,\n+                                            const CService& me,\n+                                            const CService& them) = 0;\n+\n+    /**\n+     * Called when the socket is ready to send data and `ShouldTryToSend()` has\n+     * returned true. This is where the higher level code serializes its messages\n+     * and calls `SockMan::SendBytes()`.\n+     * @param[in] node_id Id of the node whose socket is ready to send.\n+     * @param[out] cancel_recv Should always be set upon return and if it is true,\n+     * then the next attempt to receive data from that node will be omitted.\n+     */\n+    virtual void EventReadyToSend(NodeId node_id, bool& cancel_recv) = 0;\n+\n+    /**\n+     * Called when new data has been received.\n+     * @param[in] node_id Node for which the data arrived.\n+     * @param[in] data Data buffer.\n+     * @param[in] n Number of bytes in `data`.\n+     */\n+    virtual void EventGotData(NodeId node_id, const uint8_t* data, size_t n) = 0;",
      "path": "src/common/sockman.h",
      "position": null,
      "original_position": 204,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "7866c736c87a908cef75dc6901c9c0594c65b0eb",
      "in_reply_to_id": 1935798322,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done, but used `uint8_t` because `ReceiveMsgBytes()` (in `master`) takes a span of that and conversion is not possible.",
      "created_at": "2025-02-07T13:24:35Z",
      "updated_at": "2025-02-07T13:24:36Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1946520524",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946520524"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 204,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946527624",
      "pull_request_review_id": 2601733335,
      "id": 1946527624,
      "node_id": "PRRC_kwDOABII5850BaeI",
      "diff_hunk": "@@ -0,0 +1,435 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#ifndef BITCOIN_COMMON_SOCKMAN_H\n+#define BITCOIN_COMMON_SOCKMAN_H\n+\n+#include <i2p.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <util/fs.h>\n+#include <util/sock.h>\n+#include <util/translation.h>\n+\n+#include <atomic>\n+#include <memory>\n+#include <queue>\n+#include <span>\n+#include <thread>\n+#include <variant>\n+#include <vector>\n+\n+typedef int64_t NodeId;\n+\n+/**\n+ * A socket manager class which handles socket operations.\n+ * To use this class, inherit from it and implement the pure virtual methods.\n+ * Handled operations:\n+ * - binding and listening on sockets\n+ * - starting of necessary threads to process socket operations\n+ * - accepting incoming connections\n+ * - making outbound connections\n+ * - closing connections\n+ * - waiting for IO readiness on sockets and doing send/recv accordingly\n+ */\n+class SockMan\n+{\n+public:\n+\n+    virtual ~SockMan() = default;\n+\n+    //\n+    // Non-virtual functions, to be reused by children classes.\n+    //\n+\n+    /**\n+     * Bind to a new address:port, start listening and add the listen socket to `m_listen`.\n+     * Should be called before `StartSocketsThreads()`.\n+     * @param[in] to Where to bind.\n+     * @param[out] errmsg Error string if an error occurs.\n+     * @retval true Success.\n+     * @retval false Failure, `strError` will be set.\n+     */\n+    bool BindAndStartListening(const CService& to, bilingual_str& errmsg);\n+\n+    /**\n+     * Options to influence `StartSocketsThreads()`.\n+     */\n+    struct Options {\n+        std::string_view socket_handler_thread_name;\n+\n+        struct I2P {\n+            explicit I2P(const fs::path& file, const Proxy& proxy, std::string_view accept_thread_name)\n+                : private_key_file{file},\n+                  sam_proxy{proxy},\n+                  accept_thread_name{accept_thread_name}\n+            {}\n+\n+            const fs::path private_key_file;\n+            const Proxy sam_proxy;\n+            const std::string_view accept_thread_name;\n+        };\n+\n+        /**\n+         * I2P options. If set then a thread will be started that will accept incoming I2P connections.\n+         */\n+        std::optional<I2P> i2p;\n+    };\n+\n+    /**\n+     * Start the necessary threads for sockets IO.\n+     */\n+    void StartSocketsThreads(const Options& options);\n+\n+    /**\n+     * Join (wait for) the threads started by `StartSocketsThreads()` to exit.\n+     */\n+    void JoinSocketsThreads();\n+\n+    /**\n+     * A more readable std::tuple<std::string, uint16_t> for host and port.\n+     */\n+    struct StringHostIntPort {\n+        const std::string& host;\n+        uint16_t port;\n+    };\n+\n+    /**\n+     * Make an outbound connection, save the socket internally and return a newly generated node id.\n+     * @param[in] to The address to connect to, either as CService or a host as string and port as\n+     * an integer, if the later is used, then `proxy` must be valid.\n+     * @param[in] is_important If true, then log failures with higher severity.\n+     * @param[in] proxy Proxy to connect through if `proxy.IsValid()` is true.\n+     * @param[out] proxy_failed If `proxy` is valid and the connection failed because of the\n+     * proxy, then it will be set to true.\n+     * @param[out] me If the connection was successful then this is set to the address on the\n+     * local side of the socket.\n+     * @return Newly generated node id, or std::nullopt if the operation fails.\n+     */\n+    std::optional<NodeId> ConnectAndMakeNodeId(const std::variant<CService, StringHostIntPort>& to,\n+                                               bool is_important,\n+                                               const Proxy& proxy,\n+                                               bool& proxy_failed,\n+                                               CService& me)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex, !m_unused_i2p_sessions_mutex);\n+\n+    /**\n+     * Disconnect a given peer by closing its socket and release resources occupied by it.\n+     * @return Whether the peer existed and its socket was closed by this call.\n+     */\n+    bool CloseConnection(NodeId node_id)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Try to send some data to the given node.\n+     * @param[in] node_id Identifier of the node to send to.\n+     * @param[in] data The data to send, it might happen that only a prefix of this is sent.\n+     * @param[in] will_send_more Used as an optimization if the caller knows that they will\n+     * be sending more data soon after this call.\n+     * @param[out] errmsg If <0 is returned then this will contain a human readable message\n+     * explaining the error.\n+     * @retval >=0 The number of bytes actually sent.\n+     * @retval <0 A permanent error has occurred.\n+     */\n+    ssize_t SendBytes(NodeId node_id,\n+                      std::span<const unsigned char> data,\n+                      bool will_send_more,\n+                      std::string& errmsg) const\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Close all sockets.\n+     */\n+    void CloseSockets();\n+\n+    /**\n+     * This is signaled when network activity should cease.\n+     * A pointer to it is saved in `m_i2p_sam_session`, so make sure that\n+     * the lifetime of `interruptNet` is not shorter than\n+     * the lifetime of `m_i2p_sam_session`.\n+     */\n+    CThreadInterrupt interruptNet;\n+\n+protected:\n+\n+    /**\n+     * During some tests mocked sockets are created outside of `SockMan`, make it\n+     * possible to add those so that send/recv can be exercised.\n+     */\n+    void TestOnlyAddExistentNode(NodeId node_id, std::unique_ptr<Sock>&& sock)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+private:\n+\n+    /**\n+     * Cap on the size of `m_unused_i2p_sessions`, to ensure it does not\n+     * unexpectedly use too much memory.\n+     */\n+    static constexpr size_t MAX_UNUSED_I2P_SESSIONS_SIZE{10};\n+\n+    //\n+    // Pure virtual functions must be implemented by children classes.\n+    //\n+\n+    /**\n+     * Be notified when a new connection has been accepted.\n+     * @param[in] node_id Id of the newly accepted connection.\n+     * @param[in] me The address and port at our side of the connection.\n+     * @param[in] them The address and port at the peer's side of the connection.\n+     * @retval true The new connection was accepted at the higher level.\n+     * @retval false The connection was refused at the higher level, so the\n+     * associated socket and node_id should be discarded by `SockMan`.\n+     */\n+    virtual bool EventNewConnectionAccepted(NodeId node_id,\n+                                            const CService& me,\n+                                            const CService& them) = 0;\n+\n+    /**\n+     * Called when the socket is ready to send data and `ShouldTryToSend()` has\n+     * returned true. This is where the higher level code serializes its messages\n+     * and calls `SockMan::SendBytes()`.\n+     * @param[in] node_id Id of the node whose socket is ready to send.\n+     * @param[out] cancel_recv Should always be set upon return and if it is true,\n+     * then the next attempt to receive data from that node will be omitted.\n+     */\n+    virtual void EventReadyToSend(NodeId node_id, bool& cancel_recv) = 0;\n+\n+    /**\n+     * Called when new data has been received.\n+     * @param[in] node_id Node for which the data arrived.\n+     * @param[in] data Data buffer.\n+     * @param[in] n Number of bytes in `data`.\n+     */\n+    virtual void EventGotData(NodeId node_id, const uint8_t* data, size_t n) = 0;",
      "path": "src/common/sockman.h",
      "position": null,
      "original_position": 204,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "7866c736c87a908cef75dc6901c9c0594c65b0eb",
      "in_reply_to_id": 1935798322,
      "user": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> conversion is not possible.\r\n\r\nIt should be possible to convert std::byte* to uint8_t* (and vice-versa). The two are the almost the same anyway (https://en.cppreference.com/w/cpp/types/byte). And a span is just a pointer+size, so conversion between the two span types should also be possible.",
      "created_at": "2025-02-07T13:30:08Z",
      "updated_at": "2025-02-07T13:30:08Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1946527624",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946527624"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 204,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946537723",
      "pull_request_review_id": 2601751064,
      "id": 1946537723,
      "node_id": "PRRC_kwDOABII5850Bc77",
      "diff_hunk": "@@ -0,0 +1,533 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+#include <cassert>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+static CService GetBindAddress(const Sock& sock)\n+{\n+    CService addr_bind;\n+    struct sockaddr_storage sockaddr_bind;\n+    socklen_t sockaddr_bind_len = sizeof(sockaddr_bind);\n+    if (!sock.GetSockName((struct sockaddr*)&sockaddr_bind, &sockaddr_bind_len)) {\n+        addr_bind.SetSockAddr((const struct sockaddr*)&sockaddr_bind);\n+    } else {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"getsockname failed\\n\");\n+    }\n+    return addr_bind;\n+}\n+\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& errmsg)\n+{\n+    // Create socket for listening for incoming connections\n+    struct sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {\n+        errmsg = Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()));\n+        return false;\n+    }\n+\n+    std::unique_ptr<Sock> sock{CreateSock(to.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP)};\n+    if (!sock) {\n+        errmsg = Untranslated(strprintf(\"Cannot create %s listen socket: %s\",\n+                                        to.ToStringAddrPort(),\n+                                        NetworkErrorString(WSAGetLastError())));\n+        return false;\n+    }\n+\n+    int one{1};\n+\n+    // Allow binding if the port is still in TIME_WAIT state after\n+    // the program was closed and restarted.\n+    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+        LogPrintLevel(BCLog::NET,\n+                      BCLog::Level::Info,\n+                      \"Cannot set SO_REUSEADDR on %s listen socket: %s, continuing anyway\\n\",\n+                      to.ToStringAddrPort(),\n+                      NetworkErrorString(WSAGetLastError()));\n+    }\n+\n+    // some systems don't have IPV6_V6ONLY but are always v6only; others do have the option\n+    // and enable it by default or not. Try to enable it, if possible.\n+    if (to.IsIPv6()) {\n+#ifdef IPV6_V6ONLY\n+        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_V6ONLY on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+#ifdef WIN32\n+        int prot_level{PROTECTION_LEVEL_UNRESTRICTED};\n+        if (sock->SetSockOpt(IPPROTO_IPV6,\n+                             IPV6_PROTECTION_LEVEL,\n+                             reinterpret_cast<const char*>(&prot_level),\n+                             sizeof(prot_level)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_PROTECTION_LEVEL on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+    }\n+\n+    if (sock->Bind(reinterpret_cast<sockaddr*>(&storage), len) == SOCKET_ERROR) {\n+        const int err{WSAGetLastError()};\n+        errmsg = strprintf(_(\"Cannot bind to %s: %s%s\"),\n+                           to.ToStringAddrPort(),\n+                           NetworkErrorString(err),\n+                           err == WSAEADDRINUSE\n+                               ? std::string{\" (\"} + CLIENT_NAME + \" already running?)\"\n+                               : \"\");\n+        return false;\n+    }\n+\n+    // Listen for incoming connections\n+    if (sock->Listen(SOMAXCONN) == SOCKET_ERROR) {\n+        errmsg = strprintf(_(\"Cannot listen to %s: %s\"), to.ToStringAddrPort(), NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    m_listen.emplace_back(std::move(sock));\n+\n+    return true;\n+}\n+\n+void SockMan::StartSocketsThreads(const Options& options)\n+{\n+    m_thread_socket_handler = std::thread(\n+        &util::TraceThread, options.socket_handler_thread_name, [this] { ThreadSocketHandler(); });\n+\n+    if (options.i2p.has_value()) {\n+        m_i2p_sam_session = std::make_unique<i2p::sam::Session>(\n+            options.i2p->private_key_file, options.i2p->sam_proxy, &interruptNet);\n+\n+        m_thread_i2p_accept =\n+            std::thread(&util::TraceThread, options.i2p->accept_thread_name, [this] { ThreadI2PAccept(); });\n+    }\n+}\n+\n+void SockMan::JoinSocketsThreads()\n+{\n+    if (m_thread_i2p_accept.joinable()) {\n+        m_thread_i2p_accept.join();\n+    }\n+\n+    if (m_thread_socket_handler.joinable()) {\n+        m_thread_socket_handler.join();\n+    }\n+}\n+\n+std::optional<NodeId>\n+SockMan::ConnectAndMakeNodeId(const std::variant<CService, StringHostIntPort>& to,\n+                              bool is_important,\n+                              const Proxy& proxy,\n+                              bool& proxy_failed,\n+                              CService& me)\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+    AssertLockNotHeld(m_unused_i2p_sessions_mutex);\n+\n+    std::unique_ptr<Sock> sock;\n+    std::unique_ptr<i2p::sam::Session> i2p_transient_session;\n+\n+    Assume(!me.IsValid());\n+\n+    if (std::holds_alternative<CService>(to)) {\n+        const CService& addr_to{std::get<CService>(to)};",
      "path": "src/common/sockman.cpp",
      "position": 156,
      "original_position": 152,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "7866c736c87a908cef75dc6901c9c0594c65b0eb",
      "in_reply_to_id": 1935839489,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "That would make `addr_to` a pointer, so `*addr_to` would have to be used in the 6 places below. I slightly prefer the current \"if holds alternative CService\" because it is dump and easy to follow. Leaving it as it is.",
      "created_at": "2025-02-07T13:37:52Z",
      "updated_at": "2025-02-07T13:37:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1946537723",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946537723"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": 155,
      "original_start_line": 151,
      "start_side": "RIGHT",
      "line": 156,
      "original_line": 156,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946544583",
      "pull_request_review_id": 2601762205,
      "id": 1946544583,
      "node_id": "PRRC_kwDOABII5850BenH",
      "diff_hunk": "@@ -1696,10 +1696,14 @@ bool CConnman::AttemptToEvictConnection()\n     return false;\n }\n \n-void CConnman::EventNewConnectionAccepted(std::unique_ptr<Sock>&& sock,\n-                                          const CService& addr_bind,\n-                                          const CService& addr)\n+void CConnman::EventNewConnectionAccepted(NodeId node_id,\n+                                          std::unique_ptr<Sock>&& sock,\n+                                          const CService& addr_bind_,\n+                                          const CService& addr_)\n {\n+    const CService addr_bind{MaybeFlipIPv6toCJDNS(addr_bind_)};\n+    const CService addr{MaybeFlipIPv6toCJDNS(addr_)};",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 13,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "0be688360318511ecebcfc9cbabacfa6960fa5ef",
      "in_reply_to_id": 1937072454,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Yeah, `EventNewConnectionAccepted()` is generic used also for non-I2P connections and the flip will not do anything on I2P addresses.\r\n\r\n> But maybe you should add a Assume(IsI2P(conn.peer));\r\n\r\nIn which function?",
      "created_at": "2025-02-07T13:42:48Z",
      "updated_at": "2025-02-07T13:42:48Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1946544583",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946544583"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": 1699,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1705,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946547841",
      "pull_request_review_id": 2601767717,
      "id": 1946547841,
      "node_id": "PRRC_kwDOABII5850BfaB",
      "diff_hunk": "@@ -678,16 +676,6 @@ class CNode\n \n     const NetPermissionFlags m_permission_flags;\n \n-    /**\n-     * Socket used for communication with the node.\n-     * May not own a Sock object (after `CloseSocketDisconnect()` or during tests).\n-     * `shared_ptr` (instead of `unique_ptr`) is used to avoid premature close of\n-     * the underlying file descriptor by one thread while another thread is\n-     * poll(2)-ing it for activity.\n-     * @see https://github.com/bitcoin/bitcoin/issues/21744 for details.\n-     */\n-    std::shared_ptr<Sock> m_sock GUARDED_BY(m_sock_mutex);",
      "path": "src/net.h",
      "position": 47,
      "original_position": 56,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "7866c736c87a908cef75dc6901c9c0594c65b0eb",
      "in_reply_to_id": 1937937184,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Removed!",
      "created_at": "2025-02-07T13:45:22Z",
      "updated_at": "2025-02-07T13:45:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1946547841",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946547841"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 689,
      "original_line": 689,
      "side": "LEFT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946550609",
      "pull_request_review_id": 2601772424,
      "id": 1946550609,
      "node_id": "PRRC_kwDOABII5850BgFR",
      "diff_hunk": "@@ -1611,45 +1554,29 @@ std::pair<size_t, bool> CConnman::SocketSendData(CNode& node) const\n         if (expected_more.has_value()) Assume(!data.empty() == *expected_more);\n         expected_more = more;\n         data_left = !data.empty(); // will be overwritten on next loop if all of data gets sent\n-        int nBytes = 0;\n-        if (!data.empty()) {\n-            LOCK(node.m_sock_mutex);\n-            // There is no socket in case we've already disconnected, or in test cases without\n-            // real connections. In these cases, we bail out immediately and just leave things\n-            // in the send queue and transport.\n-            if (!node.m_sock) {\n-                break;\n-            }\n-            int flags = MSG_NOSIGNAL | MSG_DONTWAIT;\n-#ifdef MSG_MORE\n-            if (more) {\n-                flags |= MSG_MORE;\n-            }\n-#endif\n-            nBytes = node.m_sock->Send(reinterpret_cast<const char*>(data.data()), data.size(), flags);\n-        }\n-        if (nBytes > 0) {\n+\n+        std::string errmsg;\n+\n+        const ssize_t sent{SendBytes(node.GetId(), data, more, errmsg)};\n+\n+        if (sent > 0) {",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 252,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "7866c736c87a908cef75dc6901c9c0594c65b0eb",
      "in_reply_to_id": 1937940500,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-02-07T13:47:26Z",
      "updated_at": "2025-02-07T13:47:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1946550609",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946550609"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": 1558,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1565,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946557003",
      "pull_request_review_id": 2601786124,
      "id": 1946557003,
      "node_id": "PRRC_kwDOABII5850BhpL",
      "diff_hunk": "@@ -1696,10 +1696,14 @@ bool CConnman::AttemptToEvictConnection()\n     return false;\n }\n \n-void CConnman::EventNewConnectionAccepted(std::unique_ptr<Sock>&& sock,\n-                                          const CService& addr_bind,\n-                                          const CService& addr)\n+void CConnman::EventNewConnectionAccepted(NodeId node_id,\n+                                          std::unique_ptr<Sock>&& sock,\n+                                          const CService& addr_bind_,\n+                                          const CService& addr_)\n {\n+    const CService addr_bind{MaybeFlipIPv6toCJDNS(addr_bind_)};\n+    const CService addr{MaybeFlipIPv6toCJDNS(addr_)};",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 13,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "0be688360318511ecebcfc9cbabacfa6960fa5ef",
      "in_reply_to_id": 1937072454,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I think in `ThreadI2PAccept()` right before it calls `NewSockAccepted()` ",
      "created_at": "2025-02-07T13:51:24Z",
      "updated_at": "2025-02-07T13:51:42Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1946557003",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946557003"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": 1699,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1705,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946563897",
      "pull_request_review_id": 2601798338,
      "id": 1946563897,
      "node_id": "PRRC_kwDOABII5850BjU5",
      "diff_hunk": "@@ -1705,115 +1647,80 @@ bool CConnman::AttemptToEvictConnection()\n         return false;\n     }\n     LOCK(m_nodes_mutex);\n-    for (CNode* pnode : m_nodes) {\n-        if (pnode->GetId() == *node_id_to_evict) {\n-            LogDebug(BCLog::NET, \"selected %s connection for eviction, %s\", pnode->ConnectionTypeAsString(), pnode->DisconnectMsg(fLogIPs));\n-            pnode->fDisconnect = true;\n-            return true;\n-        }\n+    auto it{m_nodes.find(*node_id_to_evict)};\n+    if (it != m_nodes.end()) {\n+        auto node{it->second};\n+        LogDebug(BCLog::NET, \"selected %s connection for eviction, %s\", node->ConnectionTypeAsString(), node->DisconnectMsg(fLogIPs));\n+        node->fDisconnect = true;\n+        return true;\n     }\n     return false;\n }\n \n-void CConnman::AcceptConnection(const ListenSocket& hListenSocket) {\n-    struct sockaddr_storage sockaddr;\n-    socklen_t len = sizeof(sockaddr);\n-    auto sock = hListenSocket.sock->Accept((struct sockaddr*)&sockaddr, &len);\n-    CAddress addr;\n-\n-    if (!sock) {\n-        const int nErr = WSAGetLastError();\n-        if (nErr != WSAEWOULDBLOCK) {\n-            LogPrintf(\"socket error accept failed: %s\\n\", NetworkErrorString(nErr));\n-        }\n-        return;\n-    }\n-\n-    if (!addr.SetSockAddr((const struct sockaddr*)&sockaddr)) {\n-        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"Unknown socket family\\n\");\n-    } else {\n-        addr = CAddress{MaybeFlipIPv6toCJDNS(addr), NODE_NONE};\n-    }\n+bool CConnman::EventNewConnectionAccepted(NodeId node_id,\n+                                          const CService& addr_bind_,\n+                                          const CService& addr_)",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 365,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "7866c736c87a908cef75dc6901c9c0594c65b0eb",
      "in_reply_to_id": 1938288697,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-02-07T13:56:04Z",
      "updated_at": "2025-02-07T13:56:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1946563897",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946563897"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": 1661,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1662,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946583867",
      "pull_request_review_id": 2601832518,
      "id": 1946583867,
      "node_id": "PRRC_kwDOABII5850BoM7",
      "diff_hunk": "@@ -1611,45 +1554,29 @@ std::pair<size_t, bool> CConnman::SocketSendData(CNode& node) const\n         if (expected_more.has_value()) Assume(!data.empty() == *expected_more);\n         expected_more = more;\n         data_left = !data.empty(); // will be overwritten on next loop if all of data gets sent\n-        int nBytes = 0;\n-        if (!data.empty()) {\n-            LOCK(node.m_sock_mutex);\n-            // There is no socket in case we've already disconnected, or in test cases without\n-            // real connections. In these cases, we bail out immediately and just leave things\n-            // in the send queue and transport.\n-            if (!node.m_sock) {\n-                break;\n-            }\n-            int flags = MSG_NOSIGNAL | MSG_DONTWAIT;\n-#ifdef MSG_MORE\n-            if (more) {\n-                flags |= MSG_MORE;\n-            }\n-#endif\n-            nBytes = node.m_sock->Send(reinterpret_cast<const char*>(data.data()), data.size(), flags);\n-        }\n-        if (nBytes > 0) {\n+\n+        std::string errmsg;\n+\n+        const ssize_t sent{SendBytes(node.GetId(), data, more, errmsg)};\n+\n+        if (sent > 0) {\n             node.m_last_send = GetTime<std::chrono::seconds>();\n-            node.nSendBytes += nBytes;\n+            node.nSendBytes += sent;\n             // Notify transport that bytes have been processed.\n-            node.m_transport->MarkBytesSent(nBytes);\n+            node.m_transport->MarkBytesSent(sent);\n             // Update statistics per message type.\n             if (!msg_type.empty()) { // don't report v2 handshake bytes for now\n-                node.AccountForSentBytes(msg_type, nBytes);\n+                node.AccountForSentBytes(msg_type, sent);\n             }\n-            nSentSize += nBytes;\n-            if ((size_t)nBytes != data.size()) {\n+            nSentSize += sent;\n+            if (static_cast<size_t>(sent) != data.size()) {\n                 // could not send full message; stop sending more\n                 break;\n             }\n         } else {\n-            if (nBytes < 0) {\n-                // error\n-                int nErr = WSAGetLastError();\n-                if (nErr != WSAEWOULDBLOCK && nErr != WSAEMSGSIZE && nErr != WSAEINTR && nErr != WSAEINPROGRESS) {\n-                    LogDebug(BCLog::NET, \"socket send error, %s: %s\\n\", node.DisconnectMsg(fLogIPs), NetworkErrorString(nErr));\n-                    node.CloseSocketDisconnect();\n-                }\n+            if (sent < 0) {\n+                LogDebug(BCLog::NET, \"socket send error, %s: %s\\n\", node.DisconnectMsg(fLogIPs), errmsg);\n+                MarkAsDisconnectAndCloseConnection(node);",
      "path": "src/net.cpp",
      "position": 285,
      "original_position": 281,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "7866c736c87a908cef75dc6901c9c0594c65b0eb",
      "in_reply_to_id": 1938295568,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Hmm, is not straight forward. From all callers of `MarkAsDisconnectAndCloseConnection()`:\r\n\r\n* 3 unconditional `LogDebug(BCLog::NET`\r\n* 1 no log\r\n* 2 conditional `LogDebug(BCLog::NET` based on `fDisconnect`\r\n\r\nSo it is not like all the callers do the same thing. Maybe it is ok to consolidate those into one behavior, but would be a functional change that is not the purpose of this PR. Leaving it as it is, but sounds like something to explore as a followup.",
      "created_at": "2025-02-07T14:08:32Z",
      "updated_at": "2025-02-07T14:08:33Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1946583867",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946583867"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": 1581,
      "original_start_line": 1578,
      "start_side": "RIGHT",
      "line": 1582,
      "original_line": 1582,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946597696",
      "pull_request_review_id": 2601855760,
      "id": 1946597696,
      "node_id": "PRRC_kwDOABII5850BrlA",
      "diff_hunk": "@@ -0,0 +1,533 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+#include <cassert>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+static CService GetBindAddress(const Sock& sock)\n+{\n+    CService addr_bind;\n+    struct sockaddr_storage sockaddr_bind;\n+    socklen_t sockaddr_bind_len = sizeof(sockaddr_bind);\n+    if (!sock.GetSockName((struct sockaddr*)&sockaddr_bind, &sockaddr_bind_len)) {\n+        addr_bind.SetSockAddr((const struct sockaddr*)&sockaddr_bind);\n+    } else {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"getsockname failed\\n\");\n+    }\n+    return addr_bind;\n+}\n+\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& errmsg)\n+{\n+    // Create socket for listening for incoming connections\n+    struct sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {\n+        errmsg = Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()));\n+        return false;\n+    }\n+\n+    std::unique_ptr<Sock> sock{CreateSock(to.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP)};\n+    if (!sock) {\n+        errmsg = Untranslated(strprintf(\"Cannot create %s listen socket: %s\",\n+                                        to.ToStringAddrPort(),\n+                                        NetworkErrorString(WSAGetLastError())));\n+        return false;\n+    }\n+\n+    int one{1};\n+\n+    // Allow binding if the port is still in TIME_WAIT state after\n+    // the program was closed and restarted.\n+    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+        LogPrintLevel(BCLog::NET,\n+                      BCLog::Level::Info,\n+                      \"Cannot set SO_REUSEADDR on %s listen socket: %s, continuing anyway\\n\",\n+                      to.ToStringAddrPort(),\n+                      NetworkErrorString(WSAGetLastError()));\n+    }\n+\n+    // some systems don't have IPV6_V6ONLY but are always v6only; others do have the option\n+    // and enable it by default or not. Try to enable it, if possible.\n+    if (to.IsIPv6()) {\n+#ifdef IPV6_V6ONLY\n+        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_V6ONLY on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+#ifdef WIN32\n+        int prot_level{PROTECTION_LEVEL_UNRESTRICTED};\n+        if (sock->SetSockOpt(IPPROTO_IPV6,\n+                             IPV6_PROTECTION_LEVEL,\n+                             reinterpret_cast<const char*>(&prot_level),\n+                             sizeof(prot_level)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_PROTECTION_LEVEL on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+    }\n+\n+    if (sock->Bind(reinterpret_cast<sockaddr*>(&storage), len) == SOCKET_ERROR) {\n+        const int err{WSAGetLastError()};\n+        errmsg = strprintf(_(\"Cannot bind to %s: %s%s\"),\n+                           to.ToStringAddrPort(),\n+                           NetworkErrorString(err),\n+                           err == WSAEADDRINUSE\n+                               ? std::string{\" (\"} + CLIENT_NAME + \" already running?)\"\n+                               : \"\");\n+        return false;\n+    }\n+\n+    // Listen for incoming connections\n+    if (sock->Listen(SOMAXCONN) == SOCKET_ERROR) {\n+        errmsg = strprintf(_(\"Cannot listen to %s: %s\"), to.ToStringAddrPort(), NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    m_listen.emplace_back(std::move(sock));\n+\n+    return true;\n+}\n+\n+void SockMan::StartSocketsThreads(const Options& options)\n+{\n+    m_thread_socket_handler = std::thread(\n+        &util::TraceThread, options.socket_handler_thread_name, [this] { ThreadSocketHandler(); });\n+\n+    if (options.i2p.has_value()) {\n+        m_i2p_sam_session = std::make_unique<i2p::sam::Session>(\n+            options.i2p->private_key_file, options.i2p->sam_proxy, &interruptNet);\n+\n+        m_thread_i2p_accept =\n+            std::thread(&util::TraceThread, options.i2p->accept_thread_name, [this] { ThreadI2PAccept(); });\n+    }\n+}\n+\n+void SockMan::JoinSocketsThreads()\n+{\n+    if (m_thread_i2p_accept.joinable()) {\n+        m_thread_i2p_accept.join();\n+    }\n+\n+    if (m_thread_socket_handler.joinable()) {\n+        m_thread_socket_handler.join();\n+    }\n+}\n+\n+std::optional<NodeId>\n+SockMan::ConnectAndMakeNodeId(const std::variant<CService, StringHostIntPort>& to,\n+                              bool is_important,\n+                              const Proxy& proxy,\n+                              bool& proxy_failed,\n+                              CService& me)\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+    AssertLockNotHeld(m_unused_i2p_sessions_mutex);\n+\n+    std::unique_ptr<Sock> sock;\n+    std::unique_ptr<i2p::sam::Session> i2p_transient_session;\n+\n+    Assume(!me.IsValid());\n+\n+    if (std::holds_alternative<CService>(to)) {\n+        const CService& addr_to{std::get<CService>(to)};\n+        if (addr_to.IsI2P()) {\n+            if (!Assume(proxy.IsValid())) {\n+                return std::nullopt;\n+            }\n+\n+            i2p::Connection conn;\n+            bool connected{false};\n+\n+            if (m_i2p_sam_session) {\n+                connected = m_i2p_sam_session->Connect(addr_to, conn, proxy_failed);\n+            } else {\n+                {\n+                    LOCK(m_unused_i2p_sessions_mutex);\n+                    if (m_unused_i2p_sessions.empty()) {\n+                        i2p_transient_session = std::make_unique<i2p::sam::Session>(proxy, &interruptNet);\n+                    } else {\n+                        i2p_transient_session.swap(m_unused_i2p_sessions.front());\n+                        m_unused_i2p_sessions.pop();\n+                    }\n+                }\n+                connected = i2p_transient_session->Connect(addr_to, conn, proxy_failed);\n+                if (!connected) {\n+                    LOCK(m_unused_i2p_sessions_mutex);\n+                    if (m_unused_i2p_sessions.size() < MAX_UNUSED_I2P_SESSIONS_SIZE) {\n+                        m_unused_i2p_sessions.emplace(i2p_transient_session.release());\n+                    }\n+                }\n+            }\n+\n+            if (connected) {\n+                sock = std::move(conn.sock);\n+                me = conn.me;\n+            }\n+        } else if (proxy.IsValid()) {\n+            sock = ConnectThroughProxy(proxy, addr_to.ToStringAddr(), addr_to.GetPort(), proxy_failed);\n+        } else {\n+            sock = ConnectDirectly(addr_to, is_important);\n+        }\n+    } else {\n+        if (!Assume(proxy.IsValid())) {\n+            return std::nullopt;\n+        }\n+\n+        const auto& hostport{std::get<StringHostIntPort>(to)};\n+\n+        bool dummy_proxy_failed;\n+        sock = ConnectThroughProxy(proxy, hostport.host, hostport.port, dummy_proxy_failed);\n+    }\n+\n+    if (!sock) {\n+        return std::nullopt;\n+    }\n+\n+    if (!me.IsValid()) {\n+        me = GetBindAddress(*sock);\n+    }\n+\n+    const NodeId node_id{GetNewNodeId()};\n+\n+    {\n+        LOCK(m_connected_mutex);\n+        m_connected.emplace(node_id, std::make_shared<NodeSockets>(std::move(sock),\n+                                                                   std::move(i2p_transient_session)));\n+    }\n+\n+    return node_id;\n+}\n+\n+bool SockMan::CloseConnection(NodeId node_id)\n+{\n+    LOCK(m_connected_mutex);\n+    return m_connected.erase(node_id) > 0;\n+}\n+\n+ssize_t SockMan::SendBytes(NodeId node_id,\n+                           std::span<const unsigned char> data,\n+                           bool will_send_more,\n+                           std::string& errmsg) const\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    if (data.empty()) {\n+        return 0;\n+    }\n+\n+    auto node_sockets{GetNodeSockets(node_id)};\n+    if (!node_sockets) {\n+        // Bail out immediately and just leave things in the caller's send queue.\n+        return 0;\n+    }\n+\n+    int flags{MSG_NOSIGNAL | MSG_DONTWAIT};\n+#ifdef MSG_MORE\n+    if (will_send_more) {\n+        flags |= MSG_MORE;\n+    }\n+#endif\n+\n+    const ssize_t sent{WITH_LOCK(\n+        node_sockets->mutex,\n+        return node_sockets->sock->Send(reinterpret_cast<const char*>(data.data()), data.size(), flags);)};\n+\n+    if (sent >= 0) {\n+        return sent;\n+    }\n+\n+    const int err{WSAGetLastError()};\n+    if (err == WSAEWOULDBLOCK || err == WSAEMSGSIZE || err == WSAEINTR || err == WSAEINPROGRESS) {\n+        return 0;\n+    }\n+    errmsg = NetworkErrorString(err);\n+    return -1;\n+}\n+\n+void SockMan::CloseSockets()\n+{\n+    m_listen.clear();\n+}\n+\n+bool SockMan::ShouldTryToSend(NodeId node_id) const { return true; }\n+\n+bool SockMan::ShouldTryToRecv(NodeId node_id) const { return true; }\n+\n+void SockMan::EventIOLoopCompletedForNode(NodeId node_id) {}\n+\n+void SockMan::EventIOLoopCompletedForAllPeers() {}\n+\n+void SockMan::EventI2PListen(const CService&, bool) {}\n+\n+void SockMan::TestOnlyAddExistentNode(NodeId node_id, std::unique_ptr<Sock>&& sock)\n+{\n+    LOCK(m_connected_mutex);\n+    const auto result{m_connected.emplace(node_id, std::make_shared<NodeSockets>(std::move(sock)))};\n+    assert(result.second);\n+}\n+\n+void SockMan::ThreadI2PAccept()\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    static constexpr auto err_wait_begin = 1s;\n+    static constexpr auto err_wait_cap = 5min;\n+    auto err_wait = err_wait_begin;\n+\n+    i2p::Connection conn;\n+\n+    auto SleepOnFailure = [&]() {\n+        interruptNet.sleep_for(err_wait);\n+        if (err_wait < err_wait_cap) {\n+            err_wait += 1s;\n+        }\n+    };\n+\n+    while (!interruptNet) {\n+\n+        if (!m_i2p_sam_session->Listen(conn)) {\n+            EventI2PListen(conn.me, /*success=*/false);\n+            SleepOnFailure();\n+            continue;\n+        }\n+\n+        EventI2PListen(conn.me, /*success=*/true);\n+\n+        if (!m_i2p_sam_session->Accept(conn)) {\n+            SleepOnFailure();\n+            continue;\n+        }\n+\n+        NewSockAccepted(std::move(conn.sock), conn.me, conn.peer);\n+\n+        err_wait = err_wait_begin;\n+    }\n+}\n+\n+void SockMan::ThreadSocketHandler()\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    while (!interruptNet) {\n+        EventIOLoopCompletedForAllPeers();\n+\n+        // Check for the readiness of the already connected sockets and the\n+        // listening sockets in one call (\"readiness\" as in poll(2) or\n+        // select(2)). If none are ready, wait for a short while and return\n+        // empty sets.\n+        auto io_readiness{GenerateWaitSockets()};\n+        if (io_readiness.events_per_sock.empty() ||\n+            // WaitMany() may as well be a static method, the context of the first Sock in the vector is not relevant.\n+            !io_readiness.events_per_sock.begin()->first->WaitMany(SELECT_TIMEOUT,\n+                                                                   io_readiness.events_per_sock)) {\n+            interruptNet.sleep_for(SELECT_TIMEOUT);\n+        }\n+\n+        // Service (send/receive) each of the already connected sockets.\n+        SocketHandlerConnected(io_readiness);\n+\n+        // Accept new connections from listening sockets.\n+        SocketHandlerListening(io_readiness.events_per_sock);\n+    }\n+}\n+\n+std::unique_ptr<Sock> SockMan::AcceptConnection(const Sock& listen_sock, CService& addr)\n+{\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+\n+    auto sock{listen_sock.Accept(reinterpret_cast<sockaddr*>(&storage), &len)};\n+\n+    if (!sock) {\n+        const int err{WSAGetLastError()};\n+        if (err != WSAEWOULDBLOCK) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Error,\n+                          \"Cannot accept new connection: %s\\n\",\n+                          NetworkErrorString(err));\n+        }\n+        return {};\n+    }\n+\n+    if (!addr.SetSockAddr(reinterpret_cast<sockaddr*>(&storage))) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"Unknown socket family\\n\");\n+    }\n+\n+    return sock;\n+}\n+\n+void SockMan::NewSockAccepted(std::unique_ptr<Sock>&& sock, const CService& me, const CService& them)\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    if (!sock->IsSelectable()) {\n+        LogPrintf(\"connection from %s dropped: non-selectable socket\\n\", them.ToStringAddrPort());\n+        return;\n+    }\n+\n+    // According to the internet TCP_NODELAY is not carried into accepted sockets\n+    // on all platforms.  Set it again here just to be sure.\n+    const int on{1};\n+    if (sock->SetSockOpt(IPPROTO_TCP, TCP_NODELAY, &on, sizeof(on)) == SOCKET_ERROR) {\n+        LogDebug(BCLog::NET, \"connection from %s: unable to set TCP_NODELAY, continuing anyway\\n\",\n+                 them.ToStringAddrPort());\n+    }\n+\n+    const NodeId node_id{GetNewNodeId()};\n+\n+    {\n+        LOCK(m_connected_mutex);\n+        m_connected.emplace(node_id, std::make_shared<NodeSockets>(std::move(sock)));\n+    }\n+\n+    if (!EventNewConnectionAccepted(node_id, me, them)) {\n+        CloseConnection(node_id);\n+    }\n+}\n+\n+NodeId SockMan::GetNewNodeId()\n+{\n+    return m_next_node_id.fetch_add(1, std::memory_order_relaxed);\n+}\n+\n+SockMan::IOReadiness SockMan::GenerateWaitSockets()\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    IOReadiness io_readiness;\n+\n+    for (const auto& sock : m_listen) {\n+        io_readiness.events_per_sock.emplace(sock, Sock::Events{Sock::RECV});\n+    }\n+\n+    auto connected_snapshot{WITH_LOCK(m_connected_mutex, return m_connected;)};\n+\n+    for (const auto& [node_id, node_sockets] : connected_snapshot) {\n+        const bool select_recv{ShouldTryToRecv(node_id)};\n+        const bool select_send{ShouldTryToSend(node_id)};\n+        if (!select_recv && !select_send) continue;\n+\n+        Sock::Event event = (select_send ? Sock::SEND : 0) | (select_recv ? Sock::RECV : 0);\n+        io_readiness.events_per_sock.emplace(node_sockets->sock, Sock::Events{event});\n+        io_readiness.node_ids_per_sock.emplace(node_sockets->sock, node_id);\n+    }\n+\n+    return io_readiness;\n+}\n+\n+void SockMan::SocketHandlerConnected(const IOReadiness& io_readiness)\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    for (const auto& [sock, events] : io_readiness.events_per_sock) {\n+        if (interruptNet) {\n+            return;\n+        }\n+\n+        auto it{io_readiness.node_ids_per_sock.find(sock)};\n+        if (it == io_readiness.node_ids_per_sock.end()) {\n+            continue;\n+        }\n+        const NodeId node_id{it->second};\n+\n+        bool send_ready = events.occurred & Sock::SEND; // Sock::SEND could only be set if ShouldTryToSend() has returned true in GenerateWaitSockets().\n+        bool recv_ready = events.occurred & Sock::RECV; // Sock::RECV could only be set if ShouldTryToRecv() has returned true in GenerateWaitSockets().\n+        bool err_ready = events.occurred & Sock::ERR;\n+\n+        if (send_ready) {\n+            bool cancel_recv;\n+\n+            EventReadyToSend(node_id, cancel_recv);\n+\n+            if (cancel_recv) {\n+                recv_ready = false;\n+            }\n+        }\n+\n+        if (recv_ready || err_ready) {\n+            uint8_t buf[0x10000]; // typical socket buffer is 8K-64K\n+\n+            auto node_sockets{GetNodeSockets(node_id)};\n+            if (!node_sockets) {\n+                continue;\n+            }\n+\n+            const ssize_t nrecv{WITH_LOCK(\n+                node_sockets->mutex,\n+                return node_sockets->sock->Recv(buf, sizeof(buf), MSG_DONTWAIT);)};\n+\n+            switch (nrecv) {\n+            case -1: {\n+                const int err = WSAGetLastError();\n+                if (err != WSAEWOULDBLOCK && err != WSAEMSGSIZE && err != WSAEINTR && err != WSAEINPROGRESS) {\n+                    EventGotPermanentReadError(node_id, NetworkErrorString(err));\n+                }\n+                break;\n+            }\n+            case 0:\n+                EventGotEOF(node_id);\n+                break;\n+            default:\n+                EventGotData(node_id, buf, nrecv);\n+                break;",
      "path": "src/common/sockman.cpp",
      "position": null,
      "original_position": 492,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "7866c736c87a908cef75dc6901c9c0594c65b0eb",
      "in_reply_to_id": 1938338721,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Hmm, if we are worried that `recv(2)` will return a value less than `-1`, then we would better treat that as an error instead of terminating the whole program. Changed the `switch` to `if/else`, treating all negative values as an error.",
      "created_at": "2025-02-07T14:17:41Z",
      "updated_at": "2025-02-07T14:17:42Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1946597696",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946597696"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": 490,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 492,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946649911",
      "pull_request_review_id": 2601941148,
      "id": 1946649911,
      "node_id": "PRRC_kwDOABII5850B4U3",
      "diff_hunk": "@@ -454,52 +439,29 @@ CNode* CConnman::ConnectNode(CAddress addrConnect, const char *pszDest, bool fCo\n     // Connect\n     std::unique_ptr<Sock> sock;\n     Proxy proxy;\n-    CService addr_bind;\n-    assert(!addr_bind.IsValid());\n+    assert(!proxy.IsValid());",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 30,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "91d97a198fb57d47870ce094454c3776bc737ba0",
      "in_reply_to_id": 1939396960,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Because later on in `ConnectAndMakeId()` there is logic that will be confused if the default constructed proxy is valid. But it is better to use a `std::optional` to designate \"no proxy\" instead of default-contructed-and-invalid proxy. Then this assert/Assume is not necessary. Changed.",
      "created_at": "2025-02-07T14:49:00Z",
      "updated_at": "2025-02-07T14:49:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1946649911",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946649911"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 442,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946658211",
      "pull_request_review_id": 2601955373,
      "id": 1946658211,
      "node_id": "PRRC_kwDOABII5850B6Wj",
      "diff_hunk": "@@ -79,6 +84,37 @@ class SockMan\n      */\n     void JoinSocketsThreads();\n \n+    /**\n+     * A more readable std::tuple<std::string, uint16_t> for host and port.\n+     */\n+    struct StringHostIntPort {\n+        const std::string& host;\n+        uint16_t port;\n+    };\n+\n+    /**\n+     * Make an outbound connection, save the socket internally and return a newly generated node id.\n+     * @param[in] to The address to connect to, either as CService or a host as string and port as\n+     * an integer, if the later is used, then `proxy` must be valid.\n+     * @param[in] is_important If true, then log failures with higher severity.\n+     * @param[in] proxy Proxy to connect through if `proxy.IsValid()` is true.",
      "path": "src/common/sockman.h",
      "position": null,
      "original_position": 41,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "91d97a198fb57d47870ce094454c3776bc737ba0",
      "in_reply_to_id": 1939408935,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "But there is still some common code that would have to be duplicated:\r\n\r\n```cpp\r\n{\r\n    AssertLockNotHeld(m_connected_mutex);\r\n    AssertLockNotHeld(m_unused_i2p_sessions_mutex);\r\n\r\n    std::unique_ptr<Sock> sock;\r\n    std::unique_ptr<i2p::sam::Session> i2p_transient_session;\r\n\r\n    Assume(!me.IsValid());\r\n\r\n    if (std::holds_alternative<CService>(to)) {\r\n        ...\r\n    } else {\r\n        ...\r\n    }\r\n\r\n    if (!sock) {\r\n        return std::nullopt;\r\n    }\r\n\r\n    if (!me.IsValid()) {\r\n        me = GetBindAddress(*sock);\r\n    }\r\n\r\n    const Id id{GetNewId()};\r\n\r\n    {\r\n        LOCK(m_connected_mutex);\r\n        m_connected.emplace(id, std::make_shared<ConnectionSockets>(std::move(sock),\r\n                                                                    std::move(i2p_transient_session)));\r\n    }\r\n\r\n    return id;\r\n}\r\n```",
      "created_at": "2025-02-07T14:54:05Z",
      "updated_at": "2025-02-07T14:54:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1946658211",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946658211"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 100,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946672405",
      "pull_request_review_id": 2601980017,
      "id": 1946672405,
      "node_id": "PRRC_kwDOABII5850B90V",
      "diff_hunk": "@@ -79,6 +84,37 @@ class SockMan\n      */\n     void JoinSocketsThreads();\n \n+    /**\n+     * A more readable std::tuple<std::string, uint16_t> for host and port.\n+     */\n+    struct StringHostIntPort {\n+        const std::string& host;\n+        uint16_t port;\n+    };\n+\n+    /**\n+     * Make an outbound connection, save the socket internally and return a newly generated node id.\n+     * @param[in] to The address to connect to, either as CService or a host as string and port as\n+     * an integer, if the later is used, then `proxy` must be valid.\n+     * @param[in] is_important If true, then log failures with higher severity.\n+     * @param[in] proxy Proxy to connect through if `proxy.IsValid()` is true.",
      "path": "src/common/sockman.h",
      "position": null,
      "original_position": 41,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "91d97a198fb57d47870ce094454c3776bc737ba0",
      "in_reply_to_id": 1939408935,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Everything starting at `if (!sock)` could go into a helper function? FinishConnectStuff()",
      "created_at": "2025-02-07T15:02:24Z",
      "updated_at": "2025-02-07T15:02:39Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1946672405",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946672405"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 100,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946684778",
      "pull_request_review_id": 2602001044,
      "id": 1946684778,
      "node_id": "PRRC_kwDOABII5850CA1q",
      "diff_hunk": "@@ -0,0 +1,435 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#ifndef BITCOIN_COMMON_SOCKMAN_H\n+#define BITCOIN_COMMON_SOCKMAN_H\n+\n+#include <i2p.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <util/fs.h>\n+#include <util/sock.h>\n+#include <util/translation.h>\n+\n+#include <atomic>\n+#include <memory>\n+#include <queue>\n+#include <span>\n+#include <thread>\n+#include <variant>\n+#include <vector>\n+\n+typedef int64_t NodeId;\n+\n+/**\n+ * A socket manager class which handles socket operations.\n+ * To use this class, inherit from it and implement the pure virtual methods.\n+ * Handled operations:\n+ * - binding and listening on sockets\n+ * - starting of necessary threads to process socket operations\n+ * - accepting incoming connections\n+ * - making outbound connections\n+ * - closing connections\n+ * - waiting for IO readiness on sockets and doing send/recv accordingly\n+ */\n+class SockMan\n+{\n+public:\n+\n+    virtual ~SockMan() = default;",
      "path": "src/common/sockman.h",
      "position": 54,
      "original_position": 40,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "266ac3267390270e6794d478aa1fbe40e88ffb0f",
      "in_reply_to_id": 1935292076,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "(Could still make the `SockMan` destructor `protected` and non-`virtual` if the `CConnman` destructor was made `virtual`, but there is little to gain from it).",
      "created_at": "2025-02-07T15:10:18Z",
      "updated_at": "2025-02-07T15:10:18Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1946684778",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946684778"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 54,
      "original_line": 54,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946733390",
      "pull_request_review_id": 2602087596,
      "id": 1946733390,
      "node_id": "PRRC_kwDOABII5850CMtO",
      "diff_hunk": "@@ -0,0 +1,533 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+#include <cassert>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};",
      "path": "src/common/sockman.cpp",
      "position": 17,
      "original_position": 17,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "7866c736c87a908cef75dc6901c9c0594c65b0eb",
      "in_reply_to_id": 1944879162,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I just copied this from `master`:\r\n\r\n```cpp\r\nstatic const uint64_t SELECT_TIMEOUT_MILLISECONDS = 50;\r\n```\r\n\r\nI guess some empirical testing... This constant is used in two places: in `WaitMany()` and in the sleep if no sockets at all, maybe those two should be separate constants (btw the same is in `master`).",
      "created_at": "2025-02-07T15:41:48Z",
      "updated_at": "2025-02-07T15:41:48Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1946733390",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946733390"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 17,
      "original_line": 17,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946776269",
      "pull_request_review_id": 2602155439,
      "id": 1946776269,
      "node_id": "PRRC_kwDOABII5850CXLN",
      "diff_hunk": "@@ -0,0 +1,533 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+#include <cassert>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+static CService GetBindAddress(const Sock& sock)\n+{\n+    CService addr_bind;\n+    struct sockaddr_storage sockaddr_bind;\n+    socklen_t sockaddr_bind_len = sizeof(sockaddr_bind);\n+    if (!sock.GetSockName((struct sockaddr*)&sockaddr_bind, &sockaddr_bind_len)) {\n+        addr_bind.SetSockAddr((const struct sockaddr*)&sockaddr_bind);\n+    } else {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"getsockname failed\\n\");\n+    }\n+    return addr_bind;\n+}\n+\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& errmsg)\n+{\n+    // Create socket for listening for incoming connections\n+    struct sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {\n+        errmsg = Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()));\n+        return false;\n+    }\n+\n+    std::unique_ptr<Sock> sock{CreateSock(to.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP)};\n+    if (!sock) {\n+        errmsg = Untranslated(strprintf(\"Cannot create %s listen socket: %s\",\n+                                        to.ToStringAddrPort(),\n+                                        NetworkErrorString(WSAGetLastError())));\n+        return false;\n+    }\n+\n+    int one{1};\n+\n+    // Allow binding if the port is still in TIME_WAIT state after\n+    // the program was closed and restarted.\n+    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+        LogPrintLevel(BCLog::NET,\n+                      BCLog::Level::Info,\n+                      \"Cannot set SO_REUSEADDR on %s listen socket: %s, continuing anyway\\n\",\n+                      to.ToStringAddrPort(),\n+                      NetworkErrorString(WSAGetLastError()));\n+    }\n+\n+    // some systems don't have IPV6_V6ONLY but are always v6only; others do have the option\n+    // and enable it by default or not. Try to enable it, if possible.\n+    if (to.IsIPv6()) {\n+#ifdef IPV6_V6ONLY\n+        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_V6ONLY on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+#ifdef WIN32\n+        int prot_level{PROTECTION_LEVEL_UNRESTRICTED};\n+        if (sock->SetSockOpt(IPPROTO_IPV6,\n+                             IPV6_PROTECTION_LEVEL,\n+                             reinterpret_cast<const char*>(&prot_level),\n+                             sizeof(prot_level)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_PROTECTION_LEVEL on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+    }\n+\n+    if (sock->Bind(reinterpret_cast<sockaddr*>(&storage), len) == SOCKET_ERROR) {\n+        const int err{WSAGetLastError()};\n+        errmsg = strprintf(_(\"Cannot bind to %s: %s%s\"),\n+                           to.ToStringAddrPort(),\n+                           NetworkErrorString(err),\n+                           err == WSAEADDRINUSE\n+                               ? std::string{\" (\"} + CLIENT_NAME + \" already running?)\"\n+                               : \"\");\n+        return false;\n+    }\n+\n+    // Listen for incoming connections\n+    if (sock->Listen(SOMAXCONN) == SOCKET_ERROR) {\n+        errmsg = strprintf(_(\"Cannot listen to %s: %s\"), to.ToStringAddrPort(), NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    m_listen.emplace_back(std::move(sock));\n+\n+    return true;\n+}\n+\n+void SockMan::StartSocketsThreads(const Options& options)\n+{\n+    m_thread_socket_handler = std::thread(\n+        &util::TraceThread, options.socket_handler_thread_name, [this] { ThreadSocketHandler(); });\n+\n+    if (options.i2p.has_value()) {\n+        m_i2p_sam_session = std::make_unique<i2p::sam::Session>(\n+            options.i2p->private_key_file, options.i2p->sam_proxy, &interruptNet);\n+\n+        m_thread_i2p_accept =\n+            std::thread(&util::TraceThread, options.i2p->accept_thread_name, [this] { ThreadI2PAccept(); });\n+    }\n+}\n+\n+void SockMan::JoinSocketsThreads()\n+{\n+    if (m_thread_i2p_accept.joinable()) {\n+        m_thread_i2p_accept.join();\n+    }\n+\n+    if (m_thread_socket_handler.joinable()) {\n+        m_thread_socket_handler.join();\n+    }\n+}\n+\n+std::optional<NodeId>\n+SockMan::ConnectAndMakeNodeId(const std::variant<CService, StringHostIntPort>& to,\n+                              bool is_important,\n+                              const Proxy& proxy,\n+                              bool& proxy_failed,\n+                              CService& me)\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+    AssertLockNotHeld(m_unused_i2p_sessions_mutex);\n+\n+    std::unique_ptr<Sock> sock;\n+    std::unique_ptr<i2p::sam::Session> i2p_transient_session;\n+\n+    Assume(!me.IsValid());\n+\n+    if (std::holds_alternative<CService>(to)) {\n+        const CService& addr_to{std::get<CService>(to)};\n+        if (addr_to.IsI2P()) {\n+            if (!Assume(proxy.IsValid())) {\n+                return std::nullopt;\n+            }\n+\n+            i2p::Connection conn;\n+            bool connected{false};\n+\n+            if (m_i2p_sam_session) {\n+                connected = m_i2p_sam_session->Connect(addr_to, conn, proxy_failed);\n+            } else {\n+                {\n+                    LOCK(m_unused_i2p_sessions_mutex);\n+                    if (m_unused_i2p_sessions.empty()) {\n+                        i2p_transient_session = std::make_unique<i2p::sam::Session>(proxy, &interruptNet);\n+                    } else {\n+                        i2p_transient_session.swap(m_unused_i2p_sessions.front());\n+                        m_unused_i2p_sessions.pop();\n+                    }\n+                }\n+                connected = i2p_transient_session->Connect(addr_to, conn, proxy_failed);\n+                if (!connected) {\n+                    LOCK(m_unused_i2p_sessions_mutex);\n+                    if (m_unused_i2p_sessions.size() < MAX_UNUSED_I2P_SESSIONS_SIZE) {\n+                        m_unused_i2p_sessions.emplace(i2p_transient_session.release());\n+                    }\n+                }\n+            }\n+\n+            if (connected) {\n+                sock = std::move(conn.sock);\n+                me = conn.me;\n+            }\n+        } else if (proxy.IsValid()) {\n+            sock = ConnectThroughProxy(proxy, addr_to.ToStringAddr(), addr_to.GetPort(), proxy_failed);\n+        } else {\n+            sock = ConnectDirectly(addr_to, is_important);\n+        }\n+    } else {\n+        if (!Assume(proxy.IsValid())) {\n+            return std::nullopt;\n+        }\n+\n+        const auto& hostport{std::get<StringHostIntPort>(to)};\n+\n+        bool dummy_proxy_failed;\n+        sock = ConnectThroughProxy(proxy, hostport.host, hostport.port, dummy_proxy_failed);\n+    }\n+\n+    if (!sock) {\n+        return std::nullopt;\n+    }\n+\n+    if (!me.IsValid()) {\n+        me = GetBindAddress(*sock);\n+    }\n+\n+    const NodeId node_id{GetNewNodeId()};\n+\n+    {\n+        LOCK(m_connected_mutex);\n+        m_connected.emplace(node_id, std::make_shared<NodeSockets>(std::move(sock),\n+                                                                   std::move(i2p_transient_session)));\n+    }\n+\n+    return node_id;\n+}\n+\n+bool SockMan::CloseConnection(NodeId node_id)\n+{\n+    LOCK(m_connected_mutex);\n+    return m_connected.erase(node_id) > 0;\n+}\n+\n+ssize_t SockMan::SendBytes(NodeId node_id,\n+                           std::span<const unsigned char> data,\n+                           bool will_send_more,\n+                           std::string& errmsg) const\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    if (data.empty()) {\n+        return 0;\n+    }\n+\n+    auto node_sockets{GetNodeSockets(node_id)};\n+    if (!node_sockets) {\n+        // Bail out immediately and just leave things in the caller's send queue.\n+        return 0;\n+    }\n+\n+    int flags{MSG_NOSIGNAL | MSG_DONTWAIT};\n+#ifdef MSG_MORE\n+    if (will_send_more) {\n+        flags |= MSG_MORE;\n+    }\n+#endif\n+\n+    const ssize_t sent{WITH_LOCK(\n+        node_sockets->mutex,\n+        return node_sockets->sock->Send(reinterpret_cast<const char*>(data.data()), data.size(), flags);)};\n+\n+    if (sent >= 0) {\n+        return sent;\n+    }\n+\n+    const int err{WSAGetLastError()};\n+    if (err == WSAEWOULDBLOCK || err == WSAEMSGSIZE || err == WSAEINTR || err == WSAEINPROGRESS) {\n+        return 0;\n+    }\n+    errmsg = NetworkErrorString(err);\n+    return -1;\n+}\n+\n+void SockMan::CloseSockets()\n+{\n+    m_listen.clear();\n+}\n+\n+bool SockMan::ShouldTryToSend(NodeId node_id) const { return true; }\n+\n+bool SockMan::ShouldTryToRecv(NodeId node_id) const { return true; }\n+\n+void SockMan::EventIOLoopCompletedForNode(NodeId node_id) {}\n+\n+void SockMan::EventIOLoopCompletedForAllPeers() {}\n+\n+void SockMan::EventI2PListen(const CService&, bool) {}\n+\n+void SockMan::TestOnlyAddExistentNode(NodeId node_id, std::unique_ptr<Sock>&& sock)\n+{\n+    LOCK(m_connected_mutex);\n+    const auto result{m_connected.emplace(node_id, std::make_shared<NodeSockets>(std::move(sock)))};\n+    assert(result.second);\n+}\n+\n+void SockMan::ThreadI2PAccept()\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    static constexpr auto err_wait_begin = 1s;\n+    static constexpr auto err_wait_cap = 5min;\n+    auto err_wait = err_wait_begin;\n+\n+    i2p::Connection conn;\n+\n+    auto SleepOnFailure = [&]() {\n+        interruptNet.sleep_for(err_wait);\n+        if (err_wait < err_wait_cap) {\n+            err_wait += 1s;\n+        }\n+    };\n+\n+    while (!interruptNet) {\n+\n+        if (!m_i2p_sam_session->Listen(conn)) {\n+            EventI2PListen(conn.me, /*success=*/false);\n+            SleepOnFailure();\n+            continue;\n+        }\n+\n+        EventI2PListen(conn.me, /*success=*/true);\n+\n+        if (!m_i2p_sam_session->Accept(conn)) {\n+            SleepOnFailure();\n+            continue;\n+        }\n+\n+        NewSockAccepted(std::move(conn.sock), conn.me, conn.peer);\n+\n+        err_wait = err_wait_begin;\n+    }\n+}\n+\n+void SockMan::ThreadSocketHandler()\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+\n+    while (!interruptNet) {\n+        EventIOLoopCompletedForAllPeers();\n+\n+        // Check for the readiness of the already connected sockets and the\n+        // listening sockets in one call (\"readiness\" as in poll(2) or\n+        // select(2)). If none are ready, wait for a short while and return\n+        // empty sets.\n+        auto io_readiness{GenerateWaitSockets()};\n+        if (io_readiness.events_per_sock.empty() ||\n+            // WaitMany() may as well be a static method, the context of the first Sock in the vector is not relevant.\n+            !io_readiness.events_per_sock.begin()->first->WaitMany(SELECT_TIMEOUT,\n+                                                                   io_readiness.events_per_sock)) {\n+            interruptNet.sleep_for(SELECT_TIMEOUT);\n+        }",
      "path": "src/common/sockman.cpp",
      "position": 351,
      "original_position": 344,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "7866c736c87a908cef75dc6901c9c0594c65b0eb",
      "in_reply_to_id": 1945120612,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> if WaitMany() returns false, we would have already waited\r\n\r\nNo, `false` means an error, e.g. `poll(2)` returning `-1`. A timeout is signaled by a return value of `true` and all `what[].occurred` returned as `0`.",
      "created_at": "2025-02-07T16:06:44Z",
      "updated_at": "2025-02-07T16:06:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1946776269",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1946776269"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": 346,
      "original_start_line": 339,
      "start_side": "RIGHT",
      "line": 351,
      "original_line": 351,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1948692321",
      "pull_request_review_id": 2605156978,
      "id": 1948692321,
      "node_id": "PRRC_kwDOABII5850Jq9h",
      "diff_hunk": "@@ -5077,10 +5077,15 @@ void PeerManagerImpl::EvictExtraOutboundPeers(std::chrono::seconds now)\n \n         m_connman.ForEachNode([&](CNode* pnode) {\n             if (!pnode->IsBlockOnlyConn() || pnode->fDisconnect) return;\n-            if (pnode->GetId() > youngest_peer.first) {\n-                next_youngest_peer = youngest_peer;\n-                youngest_peer.first = pnode->GetId();\n-                youngest_peer.second = pnode->m_last_block_time;\n+            if (pnode->GetId() > next_youngest_peer.first) {\n+                if (pnode->GetId() > youngest_peer.first) {\n+                    next_youngest_peer = youngest_peer;\n+                    youngest_peer.first = pnode->GetId();\n+                    youngest_peer.second = pnode->m_last_block_time;\n+                } else {\n+                    next_youngest_peer.first = pnode->GetId();\n+                    next_youngest_peer.second = pnode->m_last_block_time;\n+                }",
      "path": "src/net_processing.cpp",
      "position": 16,
      "original_position": 16,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "266ac3267390270e6794d478aa1fbe40e88ffb0f",
      "in_reply_to_id": 1935376623,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done, will be in next push.",
      "created_at": "2025-02-10T09:20:47Z",
      "updated_at": "2025-02-10T09:20:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1948692321",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1948692321"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": 5090,
      "original_start_line": 5085,
      "start_side": "RIGHT",
      "line": 5093,
      "original_line": 5093,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1948716391",
      "pull_request_review_id": 2605196784,
      "id": 1948716391,
      "node_id": "PRRC_kwDOABII5850Jw1n",
      "diff_hunk": "@@ -0,0 +1,435 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#ifndef BITCOIN_COMMON_SOCKMAN_H\n+#define BITCOIN_COMMON_SOCKMAN_H\n+\n+#include <i2p.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <util/fs.h>\n+#include <util/sock.h>\n+#include <util/translation.h>\n+\n+#include <atomic>\n+#include <memory>\n+#include <queue>\n+#include <span>\n+#include <thread>\n+#include <variant>\n+#include <vector>\n+\n+typedef int64_t NodeId;\n+\n+/**\n+ * A socket manager class which handles socket operations.\n+ * To use this class, inherit from it and implement the pure virtual methods.\n+ * Handled operations:\n+ * - binding and listening on sockets\n+ * - starting of necessary threads to process socket operations\n+ * - accepting incoming connections\n+ * - making outbound connections\n+ * - closing connections\n+ * - waiting for IO readiness on sockets and doing send/recv accordingly\n+ */\n+class SockMan\n+{\n+public:\n+\n+    virtual ~SockMan() = default;\n+\n+    //\n+    // Non-virtual functions, to be reused by children classes.\n+    //\n+\n+    /**\n+     * Bind to a new address:port, start listening and add the listen socket to `m_listen`.\n+     * Should be called before `StartSocketsThreads()`.\n+     * @param[in] to Where to bind.\n+     * @param[out] errmsg Error string if an error occurs.\n+     * @retval true Success.\n+     * @retval false Failure, `strError` will be set.\n+     */\n+    bool BindAndStartListening(const CService& to, bilingual_str& errmsg);\n+\n+    /**\n+     * Options to influence `StartSocketsThreads()`.\n+     */\n+    struct Options {\n+        std::string_view socket_handler_thread_name;\n+\n+        struct I2P {\n+            explicit I2P(const fs::path& file, const Proxy& proxy, std::string_view accept_thread_name)\n+                : private_key_file{file},\n+                  sam_proxy{proxy},\n+                  accept_thread_name{accept_thread_name}\n+            {}\n+\n+            const fs::path private_key_file;\n+            const Proxy sam_proxy;\n+            const std::string_view accept_thread_name;\n+        };\n+\n+        /**\n+         * I2P options. If set then a thread will be started that will accept incoming I2P connections.\n+         */\n+        std::optional<I2P> i2p;\n+    };\n+\n+    /**\n+     * Start the necessary threads for sockets IO.\n+     */\n+    void StartSocketsThreads(const Options& options);\n+\n+    /**\n+     * Join (wait for) the threads started by `StartSocketsThreads()` to exit.\n+     */\n+    void JoinSocketsThreads();\n+\n+    /**\n+     * A more readable std::tuple<std::string, uint16_t> for host and port.\n+     */\n+    struct StringHostIntPort {\n+        const std::string& host;\n+        uint16_t port;\n+    };\n+\n+    /**\n+     * Make an outbound connection, save the socket internally and return a newly generated node id.\n+     * @param[in] to The address to connect to, either as CService or a host as string and port as\n+     * an integer, if the later is used, then `proxy` must be valid.\n+     * @param[in] is_important If true, then log failures with higher severity.\n+     * @param[in] proxy Proxy to connect through if `proxy.IsValid()` is true.\n+     * @param[out] proxy_failed If `proxy` is valid and the connection failed because of the\n+     * proxy, then it will be set to true.\n+     * @param[out] me If the connection was successful then this is set to the address on the\n+     * local side of the socket.\n+     * @return Newly generated node id, or std::nullopt if the operation fails.\n+     */\n+    std::optional<NodeId> ConnectAndMakeNodeId(const std::variant<CService, StringHostIntPort>& to,\n+                                               bool is_important,\n+                                               const Proxy& proxy,\n+                                               bool& proxy_failed,\n+                                               CService& me)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex, !m_unused_i2p_sessions_mutex);\n+\n+    /**\n+     * Disconnect a given peer by closing its socket and release resources occupied by it.\n+     * @return Whether the peer existed and its socket was closed by this call.\n+     */\n+    bool CloseConnection(NodeId node_id)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Try to send some data to the given node.\n+     * @param[in] node_id Identifier of the node to send to.\n+     * @param[in] data The data to send, it might happen that only a prefix of this is sent.\n+     * @param[in] will_send_more Used as an optimization if the caller knows that they will\n+     * be sending more data soon after this call.\n+     * @param[out] errmsg If <0 is returned then this will contain a human readable message\n+     * explaining the error.\n+     * @retval >=0 The number of bytes actually sent.\n+     * @retval <0 A permanent error has occurred.\n+     */\n+    ssize_t SendBytes(NodeId node_id,\n+                      std::span<const unsigned char> data,\n+                      bool will_send_more,\n+                      std::string& errmsg) const\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Close all sockets.\n+     */\n+    void CloseSockets();\n+\n+    /**\n+     * This is signaled when network activity should cease.\n+     * A pointer to it is saved in `m_i2p_sam_session`, so make sure that\n+     * the lifetime of `interruptNet` is not shorter than\n+     * the lifetime of `m_i2p_sam_session`.\n+     */\n+    CThreadInterrupt interruptNet;\n+\n+protected:\n+\n+    /**\n+     * During some tests mocked sockets are created outside of `SockMan`, make it\n+     * possible to add those so that send/recv can be exercised.\n+     */\n+    void TestOnlyAddExistentNode(NodeId node_id, std::unique_ptr<Sock>&& sock)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+private:\n+\n+    /**\n+     * Cap on the size of `m_unused_i2p_sessions`, to ensure it does not\n+     * unexpectedly use too much memory.\n+     */\n+    static constexpr size_t MAX_UNUSED_I2P_SESSIONS_SIZE{10};\n+\n+    //\n+    // Pure virtual functions must be implemented by children classes.\n+    //\n+\n+    /**\n+     * Be notified when a new connection has been accepted.\n+     * @param[in] node_id Id of the newly accepted connection.\n+     * @param[in] me The address and port at our side of the connection.\n+     * @param[in] them The address and port at the peer's side of the connection.\n+     * @retval true The new connection was accepted at the higher level.\n+     * @retval false The connection was refused at the higher level, so the\n+     * associated socket and node_id should be discarded by `SockMan`.\n+     */\n+    virtual bool EventNewConnectionAccepted(NodeId node_id,\n+                                            const CService& me,\n+                                            const CService& them) = 0;\n+\n+    /**\n+     * Called when the socket is ready to send data and `ShouldTryToSend()` has\n+     * returned true. This is where the higher level code serializes its messages\n+     * and calls `SockMan::SendBytes()`.\n+     * @param[in] node_id Id of the node whose socket is ready to send.\n+     * @param[out] cancel_recv Should always be set upon return and if it is true,\n+     * then the next attempt to receive data from that node will be omitted.\n+     */\n+    virtual void EventReadyToSend(NodeId node_id, bool& cancel_recv) = 0;\n+\n+    /**\n+     * Called when new data has been received.\n+     * @param[in] node_id Node for which the data arrived.\n+     * @param[in] data Data buffer.\n+     * @param[in] n Number of bytes in `data`.\n+     */\n+    virtual void EventGotData(NodeId node_id, const uint8_t* data, size_t n) = 0;",
      "path": "src/common/sockman.h",
      "position": null,
      "original_position": 204,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "7866c736c87a908cef75dc6901c9c0594c65b0eb",
      "in_reply_to_id": 1935798322,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "By default trying to pass `std::span<std::byte>` to a function that takes `std::span<uint8_t>` gives:\r\n\r\n```\r\nno known conversion from 'span<std::byte>' to 'span<uint8_t>'\r\n```\r\n\r\nIf I really insist then I can convert it like:\r\n\r\n```cpp\r\nvoid f(std::span<uint8_t> s);\r\n...\r\nstd::span<std::byte> a;\r\nf(std::span<uint8_t>{reinterpret_cast<uint8_t*>(a.data()), a.size()});\r\n```\r\n\r\nI find it cleaner to use `uint8_t` because it is already used in the existent code (`ReceiveMsgBytes()`) and avoid such forced coversion.",
      "created_at": "2025-02-10T09:35:46Z",
      "updated_at": "2025-02-10T09:35:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1948716391",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1948716391"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 204,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1948784579",
      "pull_request_review_id": 2605309190,
      "id": 1948784579,
      "node_id": "PRRC_kwDOABII5850KBfD",
      "diff_hunk": "@@ -0,0 +1,435 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#ifndef BITCOIN_COMMON_SOCKMAN_H\n+#define BITCOIN_COMMON_SOCKMAN_H\n+\n+#include <i2p.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <util/fs.h>\n+#include <util/sock.h>\n+#include <util/translation.h>\n+\n+#include <atomic>\n+#include <memory>\n+#include <queue>\n+#include <span>\n+#include <thread>\n+#include <variant>\n+#include <vector>\n+\n+typedef int64_t NodeId;\n+\n+/**\n+ * A socket manager class which handles socket operations.\n+ * To use this class, inherit from it and implement the pure virtual methods.\n+ * Handled operations:\n+ * - binding and listening on sockets\n+ * - starting of necessary threads to process socket operations\n+ * - accepting incoming connections\n+ * - making outbound connections\n+ * - closing connections\n+ * - waiting for IO readiness on sockets and doing send/recv accordingly\n+ */\n+class SockMan\n+{\n+public:\n+\n+    virtual ~SockMan() = default;\n+\n+    //\n+    // Non-virtual functions, to be reused by children classes.\n+    //\n+\n+    /**\n+     * Bind to a new address:port, start listening and add the listen socket to `m_listen`.\n+     * Should be called before `StartSocketsThreads()`.\n+     * @param[in] to Where to bind.\n+     * @param[out] errmsg Error string if an error occurs.\n+     * @retval true Success.\n+     * @retval false Failure, `strError` will be set.\n+     */\n+    bool BindAndStartListening(const CService& to, bilingual_str& errmsg);\n+\n+    /**\n+     * Options to influence `StartSocketsThreads()`.\n+     */\n+    struct Options {\n+        std::string_view socket_handler_thread_name;\n+\n+        struct I2P {\n+            explicit I2P(const fs::path& file, const Proxy& proxy, std::string_view accept_thread_name)\n+                : private_key_file{file},\n+                  sam_proxy{proxy},\n+                  accept_thread_name{accept_thread_name}\n+            {}\n+\n+            const fs::path private_key_file;\n+            const Proxy sam_proxy;\n+            const std::string_view accept_thread_name;\n+        };\n+\n+        /**\n+         * I2P options. If set then a thread will be started that will accept incoming I2P connections.\n+         */\n+        std::optional<I2P> i2p;\n+    };\n+\n+    /**\n+     * Start the necessary threads for sockets IO.\n+     */\n+    void StartSocketsThreads(const Options& options);\n+\n+    /**\n+     * Join (wait for) the threads started by `StartSocketsThreads()` to exit.\n+     */\n+    void JoinSocketsThreads();\n+\n+    /**\n+     * A more readable std::tuple<std::string, uint16_t> for host and port.\n+     */\n+    struct StringHostIntPort {\n+        const std::string& host;\n+        uint16_t port;\n+    };\n+\n+    /**\n+     * Make an outbound connection, save the socket internally and return a newly generated node id.\n+     * @param[in] to The address to connect to, either as CService or a host as string and port as\n+     * an integer, if the later is used, then `proxy` must be valid.\n+     * @param[in] is_important If true, then log failures with higher severity.\n+     * @param[in] proxy Proxy to connect through if `proxy.IsValid()` is true.\n+     * @param[out] proxy_failed If `proxy` is valid and the connection failed because of the\n+     * proxy, then it will be set to true.\n+     * @param[out] me If the connection was successful then this is set to the address on the\n+     * local side of the socket.\n+     * @return Newly generated node id, or std::nullopt if the operation fails.\n+     */\n+    std::optional<NodeId> ConnectAndMakeNodeId(const std::variant<CService, StringHostIntPort>& to,\n+                                               bool is_important,\n+                                               const Proxy& proxy,\n+                                               bool& proxy_failed,\n+                                               CService& me)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex, !m_unused_i2p_sessions_mutex);\n+\n+    /**\n+     * Disconnect a given peer by closing its socket and release resources occupied by it.\n+     * @return Whether the peer existed and its socket was closed by this call.\n+     */\n+    bool CloseConnection(NodeId node_id)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Try to send some data to the given node.\n+     * @param[in] node_id Identifier of the node to send to.\n+     * @param[in] data The data to send, it might happen that only a prefix of this is sent.\n+     * @param[in] will_send_more Used as an optimization if the caller knows that they will\n+     * be sending more data soon after this call.\n+     * @param[out] errmsg If <0 is returned then this will contain a human readable message\n+     * explaining the error.\n+     * @retval >=0 The number of bytes actually sent.\n+     * @retval <0 A permanent error has occurred.\n+     */\n+    ssize_t SendBytes(NodeId node_id,\n+                      std::span<const unsigned char> data,\n+                      bool will_send_more,\n+                      std::string& errmsg) const\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Close all sockets.\n+     */\n+    void CloseSockets();\n+\n+    /**\n+     * This is signaled when network activity should cease.\n+     * A pointer to it is saved in `m_i2p_sam_session`, so make sure that\n+     * the lifetime of `interruptNet` is not shorter than\n+     * the lifetime of `m_i2p_sam_session`.\n+     */\n+    CThreadInterrupt interruptNet;\n+\n+protected:\n+\n+    /**\n+     * During some tests mocked sockets are created outside of `SockMan`, make it\n+     * possible to add those so that send/recv can be exercised.\n+     */\n+    void TestOnlyAddExistentNode(NodeId node_id, std::unique_ptr<Sock>&& sock)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+private:\n+\n+    /**\n+     * Cap on the size of `m_unused_i2p_sessions`, to ensure it does not\n+     * unexpectedly use too much memory.\n+     */\n+    static constexpr size_t MAX_UNUSED_I2P_SESSIONS_SIZE{10};\n+\n+    //\n+    // Pure virtual functions must be implemented by children classes.\n+    //\n+\n+    /**\n+     * Be notified when a new connection has been accepted.\n+     * @param[in] node_id Id of the newly accepted connection.\n+     * @param[in] me The address and port at our side of the connection.\n+     * @param[in] them The address and port at the peer's side of the connection.\n+     * @retval true The new connection was accepted at the higher level.\n+     * @retval false The connection was refused at the higher level, so the\n+     * associated socket and node_id should be discarded by `SockMan`.\n+     */\n+    virtual bool EventNewConnectionAccepted(NodeId node_id,\n+                                            const CService& me,\n+                                            const CService& them) = 0;\n+\n+    /**\n+     * Called when the socket is ready to send data and `ShouldTryToSend()` has\n+     * returned true. This is where the higher level code serializes its messages\n+     * and calls `SockMan::SendBytes()`.\n+     * @param[in] node_id Id of the node whose socket is ready to send.\n+     * @param[out] cancel_recv Should always be set upon return and if it is true,\n+     * then the next attempt to receive data from that node will be omitted.\n+     */\n+    virtual void EventReadyToSend(NodeId node_id, bool& cancel_recv) = 0;\n+\n+    /**\n+     * Called when new data has been received.\n+     * @param[in] node_id Node for which the data arrived.\n+     * @param[in] data Data buffer.\n+     * @param[in] n Number of bytes in `data`.\n+     */\n+    virtual void EventGotData(NodeId node_id, const uint8_t* data, size_t n) = 0;",
      "path": "src/common/sockman.h",
      "position": null,
      "original_position": 204,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "7866c736c87a908cef75dc6901c9c0594c65b0eb",
      "in_reply_to_id": 1935798322,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Certainly won't insist, but another possibility is to use `bit_cast` for trivially constructible types:\r\n```c++\r\nvoid f(std::span<uint8_t> s);\r\n...\r\nstd::span<std::byte> a;\r\nf(std::bit_cast<std::span<uint8_t>>(a));\r\n```",
      "created_at": "2025-02-10T10:20:05Z",
      "updated_at": "2025-02-10T10:20:06Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1948784579",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1948784579"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 204,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1948815820",
      "pull_request_review_id": 2605358564,
      "id": 1948815820,
      "node_id": "PRRC_kwDOABII5850KJHM",
      "diff_hunk": "@@ -0,0 +1,435 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#ifndef BITCOIN_COMMON_SOCKMAN_H\n+#define BITCOIN_COMMON_SOCKMAN_H\n+\n+#include <i2p.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <util/fs.h>\n+#include <util/sock.h>\n+#include <util/translation.h>\n+\n+#include <atomic>\n+#include <memory>\n+#include <queue>\n+#include <span>\n+#include <thread>\n+#include <variant>\n+#include <vector>\n+\n+typedef int64_t NodeId;\n+\n+/**\n+ * A socket manager class which handles socket operations.\n+ * To use this class, inherit from it and implement the pure virtual methods.\n+ * Handled operations:\n+ * - binding and listening on sockets\n+ * - starting of necessary threads to process socket operations\n+ * - accepting incoming connections\n+ * - making outbound connections\n+ * - closing connections\n+ * - waiting for IO readiness on sockets and doing send/recv accordingly\n+ */\n+class SockMan\n+{\n+public:\n+\n+    virtual ~SockMan() = default;\n+\n+    //\n+    // Non-virtual functions, to be reused by children classes.\n+    //\n+\n+    /**\n+     * Bind to a new address:port, start listening and add the listen socket to `m_listen`.\n+     * Should be called before `StartSocketsThreads()`.\n+     * @param[in] to Where to bind.\n+     * @param[out] errmsg Error string if an error occurs.\n+     * @retval true Success.\n+     * @retval false Failure, `strError` will be set.\n+     */\n+    bool BindAndStartListening(const CService& to, bilingual_str& errmsg);\n+\n+    /**\n+     * Options to influence `StartSocketsThreads()`.\n+     */\n+    struct Options {\n+        std::string_view socket_handler_thread_name;\n+\n+        struct I2P {\n+            explicit I2P(const fs::path& file, const Proxy& proxy, std::string_view accept_thread_name)\n+                : private_key_file{file},\n+                  sam_proxy{proxy},\n+                  accept_thread_name{accept_thread_name}\n+            {}\n+\n+            const fs::path private_key_file;\n+            const Proxy sam_proxy;\n+            const std::string_view accept_thread_name;\n+        };\n+\n+        /**\n+         * I2P options. If set then a thread will be started that will accept incoming I2P connections.\n+         */\n+        std::optional<I2P> i2p;\n+    };\n+\n+    /**\n+     * Start the necessary threads for sockets IO.\n+     */\n+    void StartSocketsThreads(const Options& options);\n+\n+    /**\n+     * Join (wait for) the threads started by `StartSocketsThreads()` to exit.\n+     */\n+    void JoinSocketsThreads();\n+\n+    /**\n+     * A more readable std::tuple<std::string, uint16_t> for host and port.\n+     */\n+    struct StringHostIntPort {\n+        const std::string& host;\n+        uint16_t port;\n+    };\n+\n+    /**\n+     * Make an outbound connection, save the socket internally and return a newly generated node id.\n+     * @param[in] to The address to connect to, either as CService or a host as string and port as\n+     * an integer, if the later is used, then `proxy` must be valid.\n+     * @param[in] is_important If true, then log failures with higher severity.\n+     * @param[in] proxy Proxy to connect through if `proxy.IsValid()` is true.\n+     * @param[out] proxy_failed If `proxy` is valid and the connection failed because of the\n+     * proxy, then it will be set to true.\n+     * @param[out] me If the connection was successful then this is set to the address on the\n+     * local side of the socket.\n+     * @return Newly generated node id, or std::nullopt if the operation fails.\n+     */\n+    std::optional<NodeId> ConnectAndMakeNodeId(const std::variant<CService, StringHostIntPort>& to,\n+                                               bool is_important,\n+                                               const Proxy& proxy,\n+                                               bool& proxy_failed,\n+                                               CService& me)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex, !m_unused_i2p_sessions_mutex);\n+\n+    /**\n+     * Disconnect a given peer by closing its socket and release resources occupied by it.\n+     * @return Whether the peer existed and its socket was closed by this call.\n+     */\n+    bool CloseConnection(NodeId node_id)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Try to send some data to the given node.\n+     * @param[in] node_id Identifier of the node to send to.\n+     * @param[in] data The data to send, it might happen that only a prefix of this is sent.\n+     * @param[in] will_send_more Used as an optimization if the caller knows that they will\n+     * be sending more data soon after this call.\n+     * @param[out] errmsg If <0 is returned then this will contain a human readable message\n+     * explaining the error.\n+     * @retval >=0 The number of bytes actually sent.\n+     * @retval <0 A permanent error has occurred.\n+     */\n+    ssize_t SendBytes(NodeId node_id,\n+                      std::span<const unsigned char> data,\n+                      bool will_send_more,\n+                      std::string& errmsg) const\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Close all sockets.\n+     */\n+    void CloseSockets();\n+\n+    /**\n+     * This is signaled when network activity should cease.\n+     * A pointer to it is saved in `m_i2p_sam_session`, so make sure that\n+     * the lifetime of `interruptNet` is not shorter than\n+     * the lifetime of `m_i2p_sam_session`.\n+     */\n+    CThreadInterrupt interruptNet;\n+\n+protected:\n+\n+    /**\n+     * During some tests mocked sockets are created outside of `SockMan`, make it\n+     * possible to add those so that send/recv can be exercised.\n+     */\n+    void TestOnlyAddExistentNode(NodeId node_id, std::unique_ptr<Sock>&& sock)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+private:\n+\n+    /**\n+     * Cap on the size of `m_unused_i2p_sessions`, to ensure it does not\n+     * unexpectedly use too much memory.\n+     */\n+    static constexpr size_t MAX_UNUSED_I2P_SESSIONS_SIZE{10};\n+\n+    //\n+    // Pure virtual functions must be implemented by children classes.\n+    //\n+\n+    /**\n+     * Be notified when a new connection has been accepted.\n+     * @param[in] node_id Id of the newly accepted connection.\n+     * @param[in] me The address and port at our side of the connection.\n+     * @param[in] them The address and port at the peer's side of the connection.\n+     * @retval true The new connection was accepted at the higher level.\n+     * @retval false The connection was refused at the higher level, so the\n+     * associated socket and node_id should be discarded by `SockMan`.\n+     */\n+    virtual bool EventNewConnectionAccepted(NodeId node_id,\n+                                            const CService& me,\n+                                            const CService& them) = 0;\n+\n+    /**\n+     * Called when the socket is ready to send data and `ShouldTryToSend()` has\n+     * returned true. This is where the higher level code serializes its messages\n+     * and calls `SockMan::SendBytes()`.\n+     * @param[in] node_id Id of the node whose socket is ready to send.\n+     * @param[out] cancel_recv Should always be set upon return and if it is true,\n+     * then the next attempt to receive data from that node will be omitted.\n+     */\n+    virtual void EventReadyToSend(NodeId node_id, bool& cancel_recv) = 0;\n+\n+    /**\n+     * Called when new data has been received.\n+     * @param[in] node_id Node for which the data arrived.\n+     * @param[in] data Data buffer.\n+     * @param[in] n Number of bytes in `data`.\n+     */\n+    virtual void EventGotData(NodeId node_id, const uint8_t* data, size_t n) = 0;",
      "path": "src/common/sockman.h",
      "position": null,
      "original_position": 204,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "7866c736c87a908cef75dc6901c9c0594c65b0eb",
      "in_reply_to_id": 1935798322,
      "user": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> `bit_cast`\r\n\r\nWhile this will likely work in practise, I don't think there is any inherent guarantee that the layout of span is identical for all underlying types. So my recommendation would be to just use `std::as_bytes` instead.\r\n\r\n(Same for the reinterpret_cast: While it works, it is a bit verbose and `std::as_bytes` is the existing alias in the std lib, which is already used in the code today.)\r\n\r\nObviously, anything is fine. I just left a comment to say it is possible to convert :sweat_smile: ",
      "created_at": "2025-02-10T10:40:45Z",
      "updated_at": "2025-02-10T10:40:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1948815820",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1948815820"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 204,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1948830315",
      "pull_request_review_id": 2605382552,
      "id": 1948830315,
      "node_id": "PRRC_kwDOABII5850KMpr",
      "diff_hunk": "@@ -0,0 +1,435 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#ifndef BITCOIN_COMMON_SOCKMAN_H\n+#define BITCOIN_COMMON_SOCKMAN_H\n+\n+#include <i2p.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <util/fs.h>\n+#include <util/sock.h>\n+#include <util/translation.h>\n+\n+#include <atomic>\n+#include <memory>\n+#include <queue>\n+#include <span>\n+#include <thread>\n+#include <variant>\n+#include <vector>\n+\n+typedef int64_t NodeId;\n+\n+/**\n+ * A socket manager class which handles socket operations.\n+ * To use this class, inherit from it and implement the pure virtual methods.\n+ * Handled operations:\n+ * - binding and listening on sockets\n+ * - starting of necessary threads to process socket operations\n+ * - accepting incoming connections\n+ * - making outbound connections\n+ * - closing connections\n+ * - waiting for IO readiness on sockets and doing send/recv accordingly\n+ */\n+class SockMan\n+{\n+public:\n+\n+    virtual ~SockMan() = default;\n+\n+    //\n+    // Non-virtual functions, to be reused by children classes.\n+    //\n+\n+    /**\n+     * Bind to a new address:port, start listening and add the listen socket to `m_listen`.\n+     * Should be called before `StartSocketsThreads()`.\n+     * @param[in] to Where to bind.\n+     * @param[out] errmsg Error string if an error occurs.\n+     * @retval true Success.\n+     * @retval false Failure, `strError` will be set.\n+     */\n+    bool BindAndStartListening(const CService& to, bilingual_str& errmsg);\n+\n+    /**\n+     * Options to influence `StartSocketsThreads()`.\n+     */\n+    struct Options {\n+        std::string_view socket_handler_thread_name;\n+\n+        struct I2P {\n+            explicit I2P(const fs::path& file, const Proxy& proxy, std::string_view accept_thread_name)\n+                : private_key_file{file},\n+                  sam_proxy{proxy},\n+                  accept_thread_name{accept_thread_name}\n+            {}\n+\n+            const fs::path private_key_file;\n+            const Proxy sam_proxy;\n+            const std::string_view accept_thread_name;\n+        };\n+\n+        /**\n+         * I2P options. If set then a thread will be started that will accept incoming I2P connections.\n+         */\n+        std::optional<I2P> i2p;\n+    };\n+\n+    /**\n+     * Start the necessary threads for sockets IO.\n+     */\n+    void StartSocketsThreads(const Options& options);\n+\n+    /**\n+     * Join (wait for) the threads started by `StartSocketsThreads()` to exit.\n+     */\n+    void JoinSocketsThreads();\n+\n+    /**\n+     * A more readable std::tuple<std::string, uint16_t> for host and port.\n+     */\n+    struct StringHostIntPort {\n+        const std::string& host;\n+        uint16_t port;\n+    };\n+\n+    /**\n+     * Make an outbound connection, save the socket internally and return a newly generated node id.\n+     * @param[in] to The address to connect to, either as CService or a host as string and port as\n+     * an integer, if the later is used, then `proxy` must be valid.\n+     * @param[in] is_important If true, then log failures with higher severity.\n+     * @param[in] proxy Proxy to connect through if `proxy.IsValid()` is true.\n+     * @param[out] proxy_failed If `proxy` is valid and the connection failed because of the\n+     * proxy, then it will be set to true.\n+     * @param[out] me If the connection was successful then this is set to the address on the\n+     * local side of the socket.\n+     * @return Newly generated node id, or std::nullopt if the operation fails.\n+     */\n+    std::optional<NodeId> ConnectAndMakeNodeId(const std::variant<CService, StringHostIntPort>& to,\n+                                               bool is_important,\n+                                               const Proxy& proxy,\n+                                               bool& proxy_failed,\n+                                               CService& me)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex, !m_unused_i2p_sessions_mutex);\n+\n+    /**\n+     * Disconnect a given peer by closing its socket and release resources occupied by it.\n+     * @return Whether the peer existed and its socket was closed by this call.\n+     */\n+    bool CloseConnection(NodeId node_id)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Try to send some data to the given node.\n+     * @param[in] node_id Identifier of the node to send to.\n+     * @param[in] data The data to send, it might happen that only a prefix of this is sent.\n+     * @param[in] will_send_more Used as an optimization if the caller knows that they will\n+     * be sending more data soon after this call.\n+     * @param[out] errmsg If <0 is returned then this will contain a human readable message\n+     * explaining the error.\n+     * @retval >=0 The number of bytes actually sent.\n+     * @retval <0 A permanent error has occurred.\n+     */\n+    ssize_t SendBytes(NodeId node_id,\n+                      std::span<const unsigned char> data,\n+                      bool will_send_more,\n+                      std::string& errmsg) const\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Close all sockets.\n+     */\n+    void CloseSockets();\n+\n+    /**\n+     * This is signaled when network activity should cease.\n+     * A pointer to it is saved in `m_i2p_sam_session`, so make sure that\n+     * the lifetime of `interruptNet` is not shorter than\n+     * the lifetime of `m_i2p_sam_session`.\n+     */\n+    CThreadInterrupt interruptNet;\n+\n+protected:\n+\n+    /**\n+     * During some tests mocked sockets are created outside of `SockMan`, make it\n+     * possible to add those so that send/recv can be exercised.\n+     */\n+    void TestOnlyAddExistentNode(NodeId node_id, std::unique_ptr<Sock>&& sock)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+private:\n+\n+    /**\n+     * Cap on the size of `m_unused_i2p_sessions`, to ensure it does not\n+     * unexpectedly use too much memory.\n+     */\n+    static constexpr size_t MAX_UNUSED_I2P_SESSIONS_SIZE{10};\n+\n+    //\n+    // Pure virtual functions must be implemented by children classes.\n+    //\n+\n+    /**\n+     * Be notified when a new connection has been accepted.\n+     * @param[in] node_id Id of the newly accepted connection.\n+     * @param[in] me The address and port at our side of the connection.\n+     * @param[in] them The address and port at the peer's side of the connection.\n+     * @retval true The new connection was accepted at the higher level.\n+     * @retval false The connection was refused at the higher level, so the\n+     * associated socket and node_id should be discarded by `SockMan`.\n+     */\n+    virtual bool EventNewConnectionAccepted(NodeId node_id,\n+                                            const CService& me,\n+                                            const CService& them) = 0;\n+\n+    /**\n+     * Called when the socket is ready to send data and `ShouldTryToSend()` has\n+     * returned true. This is where the higher level code serializes its messages\n+     * and calls `SockMan::SendBytes()`.\n+     * @param[in] node_id Id of the node whose socket is ready to send.\n+     * @param[out] cancel_recv Should always be set upon return and if it is true,\n+     * then the next attempt to receive data from that node will be omitted.\n+     */\n+    virtual void EventReadyToSend(NodeId node_id, bool& cancel_recv) = 0;\n+\n+    /**\n+     * Called when new data has been received.\n+     * @param[in] node_id Node for which the data arrived.\n+     * @param[in] data Data buffer.\n+     * @param[in] n Number of bytes in `data`.\n+     */\n+    virtual void EventGotData(NodeId node_id, const uint8_t* data, size_t n) = 0;",
      "path": "src/common/sockman.h",
      "position": null,
      "original_position": 204,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "7866c736c87a908cef75dc6901c9c0594c65b0eb",
      "in_reply_to_id": 1935798322,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Will leave it as `uint8_t` because it is already used in `master` in `ReceiveMsgBytes()` to which we have to pass that variable.",
      "created_at": "2025-02-10T10:50:51Z",
      "updated_at": "2025-02-10T10:50:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1948830315",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1948830315"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 204,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1948853767",
      "pull_request_review_id": 2605420921,
      "id": 1948853767,
      "node_id": "PRRC_kwDOABII5850KSYH",
      "diff_hunk": "@@ -64,13 +64,15 @@ FUZZ_TARGET(connman, .init = initialize_connman)\n     connman.Init(options);\n \n     CNetAddr random_netaddr;\n-    CNode random_node = ConsumeNode(fuzzed_data_provider);\n+    NodeId node_id{0};\n+    CNode& random_node{*ConsumeNodeAsUniquePtr(fuzzed_data_provider, node_id++).release()};",
      "path": "src/test/fuzz/connman.cpp",
      "position": 6,
      "original_position": 6,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "266ac3267390270e6794d478aa1fbe40e88ffb0f",
      "in_reply_to_id": 1935390847,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "(Might be worth noting that in commit message for the change that fixes the bug, 60f6cbb9b9f83e25217d30c889147ad517960ec7 / \"net: index nodes in CConnman by id\").",
      "created_at": "2025-02-10T11:07:59Z",
      "updated_at": "2025-02-10T11:07:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1948853767",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1948853767"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": 67,
      "original_start_line": 67,
      "start_side": "RIGHT",
      "line": 68,
      "original_line": 68,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1948868714",
      "pull_request_review_id": 2605445546,
      "id": 1948868714,
      "node_id": "PRRC_kwDOABII5850KWBq",
      "diff_hunk": "@@ -0,0 +1,435 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#ifndef BITCOIN_COMMON_SOCKMAN_H\n+#define BITCOIN_COMMON_SOCKMAN_H\n+\n+#include <i2p.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <util/fs.h>\n+#include <util/sock.h>\n+#include <util/translation.h>\n+\n+#include <atomic>\n+#include <memory>\n+#include <queue>\n+#include <span>\n+#include <thread>\n+#include <variant>\n+#include <vector>\n+\n+typedef int64_t NodeId;\n+\n+/**\n+ * A socket manager class which handles socket operations.\n+ * To use this class, inherit from it and implement the pure virtual methods.\n+ * Handled operations:\n+ * - binding and listening on sockets\n+ * - starting of necessary threads to process socket operations\n+ * - accepting incoming connections\n+ * - making outbound connections\n+ * - closing connections\n+ * - waiting for IO readiness on sockets and doing send/recv accordingly\n+ */\n+class SockMan\n+{\n+public:\n+\n+    virtual ~SockMan() = default;\n+\n+    //\n+    // Non-virtual functions, to be reused by children classes.\n+    //\n+\n+    /**\n+     * Bind to a new address:port, start listening and add the listen socket to `m_listen`.\n+     * Should be called before `StartSocketsThreads()`.\n+     * @param[in] to Where to bind.\n+     * @param[out] errmsg Error string if an error occurs.\n+     * @retval true Success.\n+     * @retval false Failure, `strError` will be set.\n+     */\n+    bool BindAndStartListening(const CService& to, bilingual_str& errmsg);",
      "path": "src/common/sockman.h",
      "position": null,
      "original_position": 54,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "266ac3267390270e6794d478aa1fbe40e88ffb0f",
      "in_reply_to_id": 1934587454,
      "user": {
        "login": "hodlinator",
        "id": 172445034,
        "node_id": "U_kgDOCkdNag",
        "avatar_url": "https://avatars.githubusercontent.com/u/172445034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hodlinator",
        "html_url": "https://github.com/hodlinator",
        "followers_url": "https://api.github.com/users/hodlinator/followers",
        "following_url": "https://api.github.com/users/hodlinator/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hodlinator/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hodlinator/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hodlinator/subscriptions",
        "organizations_url": "https://api.github.com/users/hodlinator/orgs",
        "repos_url": "https://api.github.com/users/hodlinator/repos",
        "events_url": "https://api.github.com/users/hodlinator/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hodlinator/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Thanks! (PR summary is out of date, but I understand if you don't want to constantly manually update it).",
      "created_at": "2025-02-10T11:19:36Z",
      "updated_at": "2025-02-10T11:19:36Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1948868714",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1948868714"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": 50,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 54,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1948876683",
      "pull_request_review_id": 2605457852,
      "id": 1948876683,
      "node_id": "PRRC_kwDOABII5850KX-L",
      "diff_hunk": "@@ -79,6 +84,37 @@ class SockMan\n      */\n     void JoinSocketsThreads();\n \n+    /**\n+     * A more readable std::tuple<std::string, uint16_t> for host and port.\n+     */\n+    struct StringHostIntPort {\n+        const std::string& host;\n+        uint16_t port;\n+    };\n+\n+    /**\n+     * Make an outbound connection, save the socket internally and return a newly generated node id.\n+     * @param[in] to The address to connect to, either as CService or a host as string and port as\n+     * an integer, if the later is used, then `proxy` must be valid.\n+     * @param[in] is_important If true, then log failures with higher severity.\n+     * @param[in] proxy Proxy to connect through if `proxy.IsValid()` is true.",
      "path": "src/common/sockman.h",
      "position": null,
      "original_position": 41,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "91d97a198fb57d47870ce094454c3776bc737ba0",
      "in_reply_to_id": 1939408935,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I am considering this, but just realized that the distinction is not \"proxy vs no-proxy\" because in both cases of the `std::variant` we may end up connecting via the proxy. The logic (as convoluted as it is, it is the same in `master`) is:\r\n\r\n* if connecting to `CService`\r\n  * if to an I2P `CService` then proxy must be used\r\n  * otherwise the proxy is optional, if provided it will be used\r\n* if connecting to string host, then proxy must be used\r\n\r\nSo, if `std::variant` is to be avoided and two functions provided instead of one, then they should be called something like `ConnectToCService()` and `ConnectToString()` :-|\r\n\r\nEdit: or a bunch of functions covering each case:\r\n```cpp\r\nConnectToI2P(CService, proxy); // proxy must be used\r\nConnectDirectly(CService); // no proxy\r\nConnectViaProxy(CService, proxy);\r\nConnectViaProxy(string, proxy); // overload\r\n```",
      "created_at": "2025-02-10T11:25:27Z",
      "updated_at": "2025-02-10T11:29:39Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1948876683",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1948876683"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 100,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1948908109",
      "pull_request_review_id": 2605511965,
      "id": 1948908109,
      "node_id": "PRRC_kwDOABII5850KfpN",
      "diff_hunk": "@@ -64,13 +64,15 @@ FUZZ_TARGET(connman, .init = initialize_connman)\n     connman.Init(options);\n \n     CNetAddr random_netaddr;\n-    CNode random_node = ConsumeNode(fuzzed_data_provider);\n+    NodeId node_id{0};\n+    CNode& random_node{*ConsumeNodeAsUniquePtr(fuzzed_data_provider, node_id++).release()};",
      "path": "src/test/fuzz/connman.cpp",
      "position": 6,
      "original_position": 6,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "266ac3267390270e6794d478aa1fbe40e88ffb0f",
      "in_reply_to_id": 1935390847,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-02-10T11:42:23Z",
      "updated_at": "2025-02-10T11:42:23Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1948908109",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1948908109"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": 67,
      "original_start_line": 67,
      "start_side": "RIGHT",
      "line": 68,
      "original_line": 68,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1954219601",
      "pull_request_review_id": 2614520175,
      "id": 1954219601,
      "node_id": "PRRC_kwDOABII5850ewZR",
      "diff_hunk": "@@ -1696,10 +1696,14 @@ bool CConnman::AttemptToEvictConnection()\n     return false;\n }\n \n-void CConnman::EventNewConnectionAccepted(std::unique_ptr<Sock>&& sock,\n-                                          const CService& addr_bind,\n-                                          const CService& addr)\n+void CConnman::EventNewConnectionAccepted(NodeId node_id,\n+                                          std::unique_ptr<Sock>&& sock,\n+                                          const CService& addr_bind_,\n+                                          const CService& addr_)\n {\n+    const CService addr_bind{MaybeFlipIPv6toCJDNS(addr_bind_)};\n+    const CService addr{MaybeFlipIPv6toCJDNS(addr_)};",
      "path": "src/net.cpp",
      "position": null,
      "original_position": 13,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "0be688360318511ecebcfc9cbabacfa6960fa5ef",
      "in_reply_to_id": 1937072454,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Added `Assume(IsI2P(conn.peer))` and `Assume(IsI2P(conn.me))` in `ThreadI2PAccept()`.",
      "created_at": "2025-02-13T10:16:39Z",
      "updated_at": "2025-02-13T10:16:39Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1954219601",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1954219601"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": 1699,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1705,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1955976383",
      "pull_request_review_id": 2617479050,
      "id": 1955976383,
      "node_id": "PRRC_kwDOABII5850ldS_",
      "diff_hunk": "@@ -0,0 +1,459 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#ifndef BITCOIN_COMMON_SOCKMAN_H\n+#define BITCOIN_COMMON_SOCKMAN_H\n+\n+#include <i2p.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <util/fs.h>\n+#include <util/sock.h>\n+#include <util/translation.h>\n+\n+#include <atomic>\n+#include <memory>\n+#include <optional>\n+#include <queue>\n+#include <span>\n+#include <thread>\n+#include <variant>\n+#include <vector>\n+\n+/**\n+ * A socket manager class which handles socket operations.\n+ * To use this class, inherit from it and implement the pure virtual methods.\n+ * Handled operations:\n+ * - binding and listening on sockets\n+ * - starting of necessary threads to process socket operations\n+ * - accepting incoming connections\n+ * - making outbound connections\n+ * - closing connections\n+ * - waiting for IO readiness on sockets and doing send/recv accordingly\n+ */\n+class SockMan\n+{\n+public:\n+    /**\n+     * Each connection is assigned an unique id of this type.\n+     */\n+    using Id = int64_t;\n+\n+    /**\n+     * Possible status changes that can be passed to `EventI2PStatus()`.\n+     */\n+    enum class I2PStatus : uint8_t {\n+        /// The listen succeeded and we are now listening for incoming I2P connections.\n+        START_LISTENING,\n+\n+        /// The listen failed and now we are not listening (even if START_LISTENING was signaled before).\n+        STOP_LISTENING,\n+    };\n+\n+    virtual ~SockMan() = default;\n+\n+    //\n+    // Non-virtual functions, to be reused by children classes.\n+    //\n+\n+    /**\n+     * Bind to a new address:port, start listening and add the listen socket to `m_listen`.\n+     * Should be called before `StartSocketsThreads()`.\n+     * @param[in] to Where to bind.\n+     * @param[out] err_msg Error string if an error occurs.\n+     * @retval true Success.\n+     * @retval false Failure, `err_msg` will be set.\n+     */\n+    bool BindAndStartListening(const CService& to, bilingual_str& err_msg);\n+\n+    /**\n+     * Options to influence `StartSocketsThreads()`.\n+     */\n+    struct Options {\n+        std::string_view socket_handler_thread_name;\n+\n+        struct I2P {\n+            explicit I2P(const fs::path& file, const Proxy& proxy, std::string_view accept_thread_name)\n+                : private_key_file{file},\n+                  sam_proxy{proxy},\n+                  accept_thread_name{accept_thread_name}\n+            {}\n+\n+            const fs::path private_key_file;\n+            const Proxy sam_proxy;\n+            const std::string_view accept_thread_name;\n+        };\n+\n+        /**\n+         * I2P options. If set then a thread will be started that will accept incoming I2P connections.\n+         */\n+        std::optional<I2P> i2p;\n+    };\n+\n+    /**\n+     * Start the necessary threads for sockets IO.\n+     */\n+    void StartSocketsThreads(const Options& options);\n+\n+    /**\n+     * Join (wait for) the threads started by `StartSocketsThreads()` to exit.\n+     */\n+    void JoinSocketsThreads();\n+\n+    /**\n+     * A more readable std::tuple<std::string, uint16_t> for host and port.\n+     */\n+    struct StringHostIntPort {\n+        const std::string& host;\n+        uint16_t port;\n+    };\n+\n+    /**\n+     * Make an outbound connection, save the socket internally and return a newly generated connection id.\n+     * @param[in] to The address to connect to, either as CService or a host as string and port as\n+     * an integer, if the later is used, then `proxy` must be valid.\n+     * @param[in] is_important If true, then log failures with higher severity.\n+     * @param[in] proxy Proxy to connect through, if set.\n+     * @param[out] proxy_failed If `proxy` is valid and the connection failed because of the\n+     * proxy, then it will be set to true.\n+     * @param[out] me If the connection was successful then this is set to the address on the\n+     * local side of the socket.\n+     * @return Newly generated id, or std::nullopt if the operation fails.\n+     */\n+    std::optional<SockMan::Id> ConnectAndMakeId(const std::variant<CService, StringHostIntPort>& to,\n+                                                bool is_important,\n+                                                std::optional<Proxy> proxy,\n+                                                bool& proxy_failed,\n+                                                CService& me)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex, !m_unused_i2p_sessions_mutex);\n+\n+    /**\n+     * Destroy a given connection by closing its socket and release resources occupied by it.\n+     * @param[in] id Connection to destroy.\n+     * @return Whether the connection existed and its socket was closed by this call.\n+     */\n+    bool CloseConnection(Id id)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Try to send some data over the given connection.\n+     * @param[in] id Identifier of the connection.\n+     * @param[in] data The data to send, it might happen that only a prefix of this is sent.\n+     * @param[in] will_send_more Used as an optimization if the caller knows that they will\n+     * be sending more data soon after this call.\n+     * @param[out] errmsg If <0 is returned then this will contain a human readable message\n+     * explaining the error.\n+     * @retval >=0 The number of bytes actually sent.\n+     * @retval <0 A permanent error has occurred.\n+     */\n+    ssize_t SendBytes(Id id,\n+                      std::span<const unsigned char> data,\n+                      bool will_send_more,\n+                      std::string& errmsg) const\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Stop listening by closing all listening sockets.\n+     */\n+    void StopListening();\n+\n+    /**\n+     * This is signaled when network activity should cease.\n+     * A pointer to it is saved in `m_i2p_sam_session`, so make sure that\n+     * the lifetime of `interruptNet` is not shorter than\n+     * the lifetime of `m_i2p_sam_session`.\n+     */\n+    CThreadInterrupt interruptNet;\n+\n+protected:\n+\n+    /**\n+     * During some tests mocked sockets are created outside of `SockMan`, make it\n+     * possible to add those so that send/recv can be exercised.\n+     * @param[in] id Connection id to add.\n+     * @param[in,out] sock Socket to associate with the added connection.\n+     */\n+    void TestOnlyAddExistentConnection(Id id, std::unique_ptr<Sock>&& sock)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+private:\n+\n+    /**\n+     * Cap on the size of `m_unused_i2p_sessions`, to ensure it does not\n+     * unexpectedly use too much memory.\n+     */\n+    static constexpr size_t MAX_UNUSED_I2P_SESSIONS_SIZE{10};\n+\n+    //\n+    // Pure virtual functions must be implemented by children classes.\n+    //\n+\n+    /**\n+     * Be notified when a new connection has been accepted.\n+     * @param[in] id Id of the newly accepted connection.\n+     * @param[in] me The address and port at our side of the connection.\n+     * @param[in] them The address and port at the peer's side of the connection.\n+     * @retval true The new connection was accepted at the higher level.\n+     * @retval false The connection was refused at the higher level, so the\n+     * associated socket and id should be discarded by `SockMan`.\n+     */\n+    virtual bool EventNewConnectionAccepted(Id id,\n+                                            const CService& me,\n+                                            const CService& them) = 0;\n+\n+    /**\n+     * Called when the socket is ready to send data and `ShouldTryToSend()` has\n+     * returned true. This is where the higher level code serializes its messages\n+     * and calls `SockMan::SendBytes()`.\n+     * @param[in] id Id of the connection whose socket is ready to send.\n+     * @param[out] cancel_recv Should always be set upon return and if it is true,\n+     * then the next attempt to receive data from that connection will be omitted.\n+     */\n+    virtual void EventReadyToSend(Id id, bool& cancel_recv) = 0;\n+\n+    /**\n+     * Called when new data has been received.\n+     * @param[in] id Connection for which the data arrived.\n+     * @param[in] data Received data.\n+     */\n+    virtual void EventGotData(Id id, std::span<const uint8_t> data) = 0;\n+\n+    /**\n+     * Called when the remote peer has sent an EOF on the socket. This is a graceful\n+     * close of their writing side, we can still send and they will receive, if it\n+     * makes sense at the application level.\n+     * @param[in] id Connection whose socket got EOF.\n+     */\n+    virtual void EventGotEOF(Id id) = 0;\n+\n+    /**\n+     * Called when we get an irrecoverable error trying to read from a socket.\n+     * @param[in] id Connection whose socket got an error.\n+     * @param[in] errmsg Message describing the error.\n+     */\n+    virtual void EventGotPermanentReadError(Id id, const std::string& errmsg) = 0;\n+\n+    //\n+    // Non-pure virtual functions can be overridden by children classes or left\n+    // alone to use the default implementation from SockMan.\n+    //\n+\n+    /**\n+     * Can be used to temporarily pause sends on a connection.\n+     * SockMan would only call EventReadyToSend() if this returns true.\n+     * The implementation in SockMan always returns true.\n+     * @param[in] id Connection for which to confirm or omit the next call to EventReadyToSend().\n+     */\n+    virtual bool ShouldTryToSend(Id id) const;\n+\n+    /**\n+     * SockMan would only call Recv() on a connection's socket if this returns true.\n+     * Can be used to temporarily pause receives on a connection.\n+     * The implementation in SockMan always returns true.\n+     * @param[in] id Connection for which to confirm or omit the next receive.\n+     */\n+    virtual bool ShouldTryToRecv(Id id) const;\n+\n+    /**\n+     * SockMan has completed the current send+recv iteration for a given connection.\n+     * It will do another send+recv for this connection after processing all other connections.\n+     * Can be used to execute periodic tasks for a given connection.\n+     * The implementation in SockMan does nothing.\n+     * @param[in] id Connection for which send+recv has been done.\n+     */\n+    virtual void EventIOLoopCompletedForOne(Id id);\n+\n+    /**\n+     * SockMan has completed send+recv for all connections.\n+     * Can be used to execute periodic tasks for all connections, like closing\n+     * connections due to higher level logic.\n+     * The implementation in SockMan does nothing.\n+     */\n+    virtual void EventIOLoopCompletedForAll();\n+\n+    /**\n+     * Be notified of a change in the state of the I2P connectivity.\n+     * The default behavior, implemented by `SockMan`, is to ignore this event.\n+     * @param[in] addr The address we started or stopped listening on.\n+     * @param[in] new_status New status.\n+     */\n+    virtual void EventI2PStatus(const CService& addr, I2PStatus new_status);\n+\n+    /**\n+     * The sockets used by a connection - a data socket and an optional I2P session socket.\n+     */\n+    struct ConnectionSockets {\n+        explicit ConnectionSockets(std::unique_ptr<Sock>&& s)\n+            : sock{std::move(s)}\n+        {\n+        }\n+\n+        explicit ConnectionSockets(std::shared_ptr<Sock>&& s, std::unique_ptr<i2p::sam::Session>&& sess)\n+            : sock{std::move(s)},\n+              i2p_transient_session{std::move(sess)}\n+        {\n+        }\n+\n+        /**\n+         * Mutex that serializes the Send() and Recv() calls on `sock`.\n+         */\n+        Mutex mutex;\n+\n+        /**\n+         * Underlying socket.\n+         * `shared_ptr` (instead of `unique_ptr`) is used to avoid premature close of the\n+         * underlying file descriptor by one thread while another thread is poll(2)-ing\n+         * it for activity.\n+         * @see https://github.com/bitcoin/bitcoin/issues/21744 for details.\n+         */\n+        std::shared_ptr<Sock> sock;\n+\n+        /**\n+         * When transient I2P sessions are used, then each connection has its own session, otherwise\n+         * all connections use the session from `m_i2p_sam_session` and share the same I2P address.\n+         * I2P sessions involve a data/transport socket (in `sock`) and a control socket\n+         * (in `i2p_transient_session`). For transient sessions, once the data socket `sock` is\n+         * closed, the control socket is not going to be used anymore and would be just taking\n+         * resources. Storing it here makes its deletion together with `sock` automatic.\n+         */\n+        std::unique_ptr<i2p::sam::Session> i2p_transient_session;\n+    };\n+\n+    /**\n+     * Info about which socket has which event ready and its connection id.\n+     */\n+    struct IOReadiness {\n+        /**\n+         * Map of socket -> socket events. For example:\n+         * socket1 -> { requested = SEND|RECV, occurred = RECV }\n+         * socket2 -> { requested = SEND, occurred = SEND }\n+         */\n+        Sock::EventsPerSock events_per_sock;\n+\n+        /**\n+         * Map of socket -> connection id (in `m_connected`). For example\n+         * socket1 -> id=23\n+         * socket2 -> id=56\n+         */\n+        std::unordered_map<Sock::EventsPerSock::key_type, SockMan::Id> ids_per_sock;",
      "path": "src/common/sockman.h",
      "position": null,
      "original_position": 339,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "563afdd975771cd2b87c4a96e0059f1c6f8774ad",
      "in_reply_to_id": null,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Since `key_type` here is `std::shared_ptr<const Sock>` shouldn't this map also use the optimized hash/equal functions defined in:\r\n\r\nhttps://github.com/bitcoin/bitcoin/blob/86528937e5c4da2e12c46085fc41e87ed759258e/src/util/sock.h#L208 ",
      "created_at": "2025-02-14T11:12:28Z",
      "updated_at": "2025-02-14T11:12:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1955976383",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1955976383"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 339,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1956058967",
      "pull_request_review_id": 2617638908,
      "id": 1956058967,
      "node_id": "PRRC_kwDOABII5850lxdX",
      "diff_hunk": "@@ -0,0 +1,459 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#ifndef BITCOIN_COMMON_SOCKMAN_H\n+#define BITCOIN_COMMON_SOCKMAN_H\n+\n+#include <i2p.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <util/fs.h>\n+#include <util/sock.h>\n+#include <util/translation.h>\n+\n+#include <atomic>\n+#include <memory>\n+#include <optional>\n+#include <queue>\n+#include <span>\n+#include <thread>\n+#include <variant>\n+#include <vector>\n+\n+/**\n+ * A socket manager class which handles socket operations.\n+ * To use this class, inherit from it and implement the pure virtual methods.\n+ * Handled operations:\n+ * - binding and listening on sockets\n+ * - starting of necessary threads to process socket operations\n+ * - accepting incoming connections\n+ * - making outbound connections\n+ * - closing connections\n+ * - waiting for IO readiness on sockets and doing send/recv accordingly\n+ */\n+class SockMan\n+{\n+public:\n+    /**\n+     * Each connection is assigned an unique id of this type.\n+     */\n+    using Id = int64_t;\n+\n+    /**\n+     * Possible status changes that can be passed to `EventI2PStatus()`.\n+     */\n+    enum class I2PStatus : uint8_t {\n+        /// The listen succeeded and we are now listening for incoming I2P connections.\n+        START_LISTENING,\n+\n+        /// The listen failed and now we are not listening (even if START_LISTENING was signaled before).\n+        STOP_LISTENING,\n+    };\n+\n+    virtual ~SockMan() = default;\n+\n+    //\n+    // Non-virtual functions, to be reused by children classes.\n+    //\n+\n+    /**\n+     * Bind to a new address:port, start listening and add the listen socket to `m_listen`.\n+     * Should be called before `StartSocketsThreads()`.\n+     * @param[in] to Where to bind.\n+     * @param[out] err_msg Error string if an error occurs.\n+     * @retval true Success.\n+     * @retval false Failure, `err_msg` will be set.\n+     */\n+    bool BindAndStartListening(const CService& to, bilingual_str& err_msg);\n+\n+    /**\n+     * Options to influence `StartSocketsThreads()`.\n+     */\n+    struct Options {\n+        std::string_view socket_handler_thread_name;\n+\n+        struct I2P {\n+            explicit I2P(const fs::path& file, const Proxy& proxy, std::string_view accept_thread_name)\n+                : private_key_file{file},\n+                  sam_proxy{proxy},\n+                  accept_thread_name{accept_thread_name}\n+            {}\n+\n+            const fs::path private_key_file;\n+            const Proxy sam_proxy;\n+            const std::string_view accept_thread_name;\n+        };\n+\n+        /**\n+         * I2P options. If set then a thread will be started that will accept incoming I2P connections.\n+         */\n+        std::optional<I2P> i2p;\n+    };\n+\n+    /**\n+     * Start the necessary threads for sockets IO.\n+     */\n+    void StartSocketsThreads(const Options& options);\n+\n+    /**\n+     * Join (wait for) the threads started by `StartSocketsThreads()` to exit.\n+     */\n+    void JoinSocketsThreads();\n+\n+    /**\n+     * A more readable std::tuple<std::string, uint16_t> for host and port.\n+     */\n+    struct StringHostIntPort {\n+        const std::string& host;\n+        uint16_t port;\n+    };\n+\n+    /**\n+     * Make an outbound connection, save the socket internally and return a newly generated connection id.\n+     * @param[in] to The address to connect to, either as CService or a host as string and port as\n+     * an integer, if the later is used, then `proxy` must be valid.\n+     * @param[in] is_important If true, then log failures with higher severity.\n+     * @param[in] proxy Proxy to connect through, if set.\n+     * @param[out] proxy_failed If `proxy` is valid and the connection failed because of the\n+     * proxy, then it will be set to true.\n+     * @param[out] me If the connection was successful then this is set to the address on the\n+     * local side of the socket.\n+     * @return Newly generated id, or std::nullopt if the operation fails.\n+     */\n+    std::optional<SockMan::Id> ConnectAndMakeId(const std::variant<CService, StringHostIntPort>& to,\n+                                                bool is_important,\n+                                                std::optional<Proxy> proxy,\n+                                                bool& proxy_failed,\n+                                                CService& me)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex, !m_unused_i2p_sessions_mutex);\n+\n+    /**\n+     * Destroy a given connection by closing its socket and release resources occupied by it.\n+     * @param[in] id Connection to destroy.\n+     * @return Whether the connection existed and its socket was closed by this call.\n+     */\n+    bool CloseConnection(Id id)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Try to send some data over the given connection.\n+     * @param[in] id Identifier of the connection.\n+     * @param[in] data The data to send, it might happen that only a prefix of this is sent.\n+     * @param[in] will_send_more Used as an optimization if the caller knows that they will\n+     * be sending more data soon after this call.\n+     * @param[out] errmsg If <0 is returned then this will contain a human readable message\n+     * explaining the error.\n+     * @retval >=0 The number of bytes actually sent.\n+     * @retval <0 A permanent error has occurred.\n+     */\n+    ssize_t SendBytes(Id id,\n+                      std::span<const unsigned char> data,\n+                      bool will_send_more,\n+                      std::string& errmsg) const\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+    /**\n+     * Stop listening by closing all listening sockets.\n+     */\n+    void StopListening();\n+\n+    /**\n+     * This is signaled when network activity should cease.\n+     * A pointer to it is saved in `m_i2p_sam_session`, so make sure that\n+     * the lifetime of `interruptNet` is not shorter than\n+     * the lifetime of `m_i2p_sam_session`.\n+     */\n+    CThreadInterrupt interruptNet;\n+\n+protected:\n+\n+    /**\n+     * During some tests mocked sockets are created outside of `SockMan`, make it\n+     * possible to add those so that send/recv can be exercised.\n+     * @param[in] id Connection id to add.\n+     * @param[in,out] sock Socket to associate with the added connection.\n+     */\n+    void TestOnlyAddExistentConnection(Id id, std::unique_ptr<Sock>&& sock)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_connected_mutex);\n+\n+private:\n+\n+    /**\n+     * Cap on the size of `m_unused_i2p_sessions`, to ensure it does not\n+     * unexpectedly use too much memory.\n+     */\n+    static constexpr size_t MAX_UNUSED_I2P_SESSIONS_SIZE{10};\n+\n+    //\n+    // Pure virtual functions must be implemented by children classes.\n+    //\n+\n+    /**\n+     * Be notified when a new connection has been accepted.\n+     * @param[in] id Id of the newly accepted connection.\n+     * @param[in] me The address and port at our side of the connection.\n+     * @param[in] them The address and port at the peer's side of the connection.\n+     * @retval true The new connection was accepted at the higher level.\n+     * @retval false The connection was refused at the higher level, so the\n+     * associated socket and id should be discarded by `SockMan`.\n+     */\n+    virtual bool EventNewConnectionAccepted(Id id,\n+                                            const CService& me,\n+                                            const CService& them) = 0;\n+\n+    /**\n+     * Called when the socket is ready to send data and `ShouldTryToSend()` has\n+     * returned true. This is where the higher level code serializes its messages\n+     * and calls `SockMan::SendBytes()`.\n+     * @param[in] id Id of the connection whose socket is ready to send.\n+     * @param[out] cancel_recv Should always be set upon return and if it is true,\n+     * then the next attempt to receive data from that connection will be omitted.\n+     */\n+    virtual void EventReadyToSend(Id id, bool& cancel_recv) = 0;\n+\n+    /**\n+     * Called when new data has been received.\n+     * @param[in] id Connection for which the data arrived.\n+     * @param[in] data Received data.\n+     */\n+    virtual void EventGotData(Id id, std::span<const uint8_t> data) = 0;\n+\n+    /**\n+     * Called when the remote peer has sent an EOF on the socket. This is a graceful\n+     * close of their writing side, we can still send and they will receive, if it\n+     * makes sense at the application level.\n+     * @param[in] id Connection whose socket got EOF.\n+     */\n+    virtual void EventGotEOF(Id id) = 0;\n+\n+    /**\n+     * Called when we get an irrecoverable error trying to read from a socket.\n+     * @param[in] id Connection whose socket got an error.\n+     * @param[in] errmsg Message describing the error.\n+     */\n+    virtual void EventGotPermanentReadError(Id id, const std::string& errmsg) = 0;\n+\n+    //\n+    // Non-pure virtual functions can be overridden by children classes or left\n+    // alone to use the default implementation from SockMan.\n+    //\n+\n+    /**\n+     * Can be used to temporarily pause sends on a connection.\n+     * SockMan would only call EventReadyToSend() if this returns true.\n+     * The implementation in SockMan always returns true.\n+     * @param[in] id Connection for which to confirm or omit the next call to EventReadyToSend().\n+     */\n+    virtual bool ShouldTryToSend(Id id) const;\n+\n+    /**\n+     * SockMan would only call Recv() on a connection's socket if this returns true.\n+     * Can be used to temporarily pause receives on a connection.\n+     * The implementation in SockMan always returns true.\n+     * @param[in] id Connection for which to confirm or omit the next receive.\n+     */\n+    virtual bool ShouldTryToRecv(Id id) const;\n+\n+    /**\n+     * SockMan has completed the current send+recv iteration for a given connection.\n+     * It will do another send+recv for this connection after processing all other connections.\n+     * Can be used to execute periodic tasks for a given connection.\n+     * The implementation in SockMan does nothing.\n+     * @param[in] id Connection for which send+recv has been done.\n+     */\n+    virtual void EventIOLoopCompletedForOne(Id id);\n+\n+    /**\n+     * SockMan has completed send+recv for all connections.\n+     * Can be used to execute periodic tasks for all connections, like closing\n+     * connections due to higher level logic.\n+     * The implementation in SockMan does nothing.\n+     */\n+    virtual void EventIOLoopCompletedForAll();\n+\n+    /**\n+     * Be notified of a change in the state of the I2P connectivity.\n+     * The default behavior, implemented by `SockMan`, is to ignore this event.\n+     * @param[in] addr The address we started or stopped listening on.\n+     * @param[in] new_status New status.\n+     */\n+    virtual void EventI2PStatus(const CService& addr, I2PStatus new_status);\n+\n+    /**\n+     * The sockets used by a connection - a data socket and an optional I2P session socket.\n+     */\n+    struct ConnectionSockets {\n+        explicit ConnectionSockets(std::unique_ptr<Sock>&& s)\n+            : sock{std::move(s)}\n+        {\n+        }\n+\n+        explicit ConnectionSockets(std::shared_ptr<Sock>&& s, std::unique_ptr<i2p::sam::Session>&& sess)\n+            : sock{std::move(s)},\n+              i2p_transient_session{std::move(sess)}\n+        {\n+        }\n+\n+        /**\n+         * Mutex that serializes the Send() and Recv() calls on `sock`.\n+         */\n+        Mutex mutex;\n+\n+        /**\n+         * Underlying socket.\n+         * `shared_ptr` (instead of `unique_ptr`) is used to avoid premature close of the\n+         * underlying file descriptor by one thread while another thread is poll(2)-ing\n+         * it for activity.\n+         * @see https://github.com/bitcoin/bitcoin/issues/21744 for details.\n+         */\n+        std::shared_ptr<Sock> sock;\n+\n+        /**\n+         * When transient I2P sessions are used, then each connection has its own session, otherwise\n+         * all connections use the session from `m_i2p_sam_session` and share the same I2P address.\n+         * I2P sessions involve a data/transport socket (in `sock`) and a control socket\n+         * (in `i2p_transient_session`). For transient sessions, once the data socket `sock` is\n+         * closed, the control socket is not going to be used anymore and would be just taking\n+         * resources. Storing it here makes its deletion together with `sock` automatic.\n+         */\n+        std::unique_ptr<i2p::sam::Session> i2p_transient_session;\n+    };\n+\n+    /**\n+     * Info about which socket has which event ready and its connection id.\n+     */\n+    struct IOReadiness {\n+        /**\n+         * Map of socket -> socket events. For example:\n+         * socket1 -> { requested = SEND|RECV, occurred = RECV }\n+         * socket2 -> { requested = SEND, occurred = SEND }\n+         */\n+        Sock::EventsPerSock events_per_sock;\n+\n+        /**\n+         * Map of socket -> connection id (in `m_connected`). For example\n+         * socket1 -> id=23\n+         * socket2 -> id=56\n+         */\n+        std::unordered_map<Sock::EventsPerSock::key_type, SockMan::Id> ids_per_sock;",
      "path": "src/common/sockman.h",
      "position": null,
      "original_position": 339,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "563afdd975771cd2b87c4a96e0059f1c6f8774ad",
      "in_reply_to_id": 1955976383,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Yes, done!",
      "created_at": "2025-02-14T12:18:18Z",
      "updated_at": "2025-02-14T12:18:19Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1956058967",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1956058967"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 339,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1959105072",
      "pull_request_review_id": 2622503578,
      "id": 1959105072,
      "node_id": "PRRC_kwDOABII5850xZIw",
      "diff_hunk": "@@ -1660,9 +1588,24 @@ std::pair<size_t, bool> CConnman::SocketSendData(CNode& node) const\n         assert(node.m_send_memusage == 0);\n     }\n     node.vSendMsg.erase(node.vSendMsg.begin(), it);\n+\n+    if (nSentSize > 0) {\n+        RecordBytesSent(nSentSize);\n+    }\n+\n     return {nSentSize, data_left};\n }\n \n+CNode* CConnman::GetNodeById(NodeId node_id) const\n+{\n+    LOCK(m_nodes_mutex);\n+    auto it{m_nodes.find(node_id)};\n+    if (it != m_nodes.end()) {\n+        return it->second;",
      "path": "src/net.cpp",
      "position": 306,
      "original_position": 301,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "266ac3267390270e6794d478aa1fbe40e88ffb0f",
      "in_reply_to_id": 1935423919,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "After thinking about this a bit more and doing some changes to the code, I decided to:\r\n\r\n1. Open a separate PR to remove the manual ref counting on `CNode` and replace it with `shared_ptr` and change `CConnman::m_nodes` from `vector<CNode*>` to `unordered_set<shared_ptr<CNode>>`. That PR would be independent from this one.\r\n\r\n2. In this PR, change the communication between `SockMan` and `CConman` to be based on pointer to `CNode` instead of node id. Similarly to https://github.com/bitcoin/bitcoin/pull/30988#issuecomment-2485715952. I will start with a raw pointer and the responsibility of destruction will be in `CConnman`, like it is now. If 1. is merged in the mean time before this PR, then I will just change this PR to use `shared_ptr` instead of a raw pointer.",
      "created_at": "2025-02-18T05:44:27Z",
      "updated_at": "2025-02-18T05:44:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1959105072",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1959105072"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": 1604,
      "original_start_line": 1601,
      "start_side": "RIGHT",
      "line": 1607,
      "original_line": 1607,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1977960657",
      "pull_request_review_id": 2654878363,
      "id": 1977960657,
      "node_id": "PRRC_kwDOABII58515UjR",
      "diff_hunk": "@@ -0,0 +1,535 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+#include <cassert>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+/** Get the bind address for a socket as CService. */\n+static CService GetBindAddress(const Sock& sock)\n+{\n+    CService addr_bind;\n+    struct sockaddr_storage sockaddr_bind;\n+    socklen_t sockaddr_bind_len = sizeof(sockaddr_bind);\n+    if (!sock.GetSockName((struct sockaddr*)&sockaddr_bind, &sockaddr_bind_len)) {\n+        addr_bind.SetSockAddr((const struct sockaddr*)&sockaddr_bind, sockaddr_bind_len);\n+    } else {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"getsockname failed\\n\");\n+    }\n+    return addr_bind;\n+}\n+\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& err_msg)\n+{\n+    // Create socket for listening for incoming connections\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {\n+        err_msg = Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()));\n+        return false;\n+    }\n+\n+    std::unique_ptr<Sock> sock{CreateSock(to.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP)};\n+    if (!sock) {\n+        err_msg = Untranslated(strprintf(\"Cannot create %s listen socket: %s\",\n+                                         to.ToStringAddrPort(),\n+                                         NetworkErrorString(WSAGetLastError())));\n+        return false;\n+    }\n+\n+    int one{1};\n+\n+    // Allow binding if the port is still in TIME_WAIT state after\n+    // the program was closed and restarted.\n+    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+        LogPrintLevel(BCLog::NET,\n+                      BCLog::Level::Info,\n+                      \"Cannot set SO_REUSEADDR on %s listen socket: %s, continuing anyway\\n\",\n+                      to.ToStringAddrPort(),\n+                      NetworkErrorString(WSAGetLastError()));\n+    }\n+\n+    // some systems don't have IPV6_V6ONLY but are always v6only; others do have the option\n+    // and enable it by default or not. Try to enable it, if possible.\n+    if (to.IsIPv6()) {\n+#ifdef IPV6_V6ONLY\n+        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_V6ONLY on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+#ifdef WIN32\n+        int prot_level{PROTECTION_LEVEL_UNRESTRICTED};\n+        if (sock->SetSockOpt(IPPROTO_IPV6,\n+                             IPV6_PROTECTION_LEVEL,\n+                             reinterpret_cast<const char*>(&prot_level),\n+                             sizeof(prot_level)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_PROTECTION_LEVEL on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+    }\n+\n+    if (sock->Bind(reinterpret_cast<sockaddr*>(&storage), len) == SOCKET_ERROR) {\n+        const int err{WSAGetLastError()};\n+        if (err == WSAEADDRINUSE) {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer. %s is probably already running.\"),\n+                                to.ToStringAddrPort(),\n+                                CLIENT_NAME);\n+        } else {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer (bind returned error %s)\"),\n+                                to.ToStringAddrPort(),\n+                                NetworkErrorString(err));\n+        }\n+        return false;\n+    }\n+\n+    // Listen for incoming connections\n+    if (sock->Listen(SOMAXCONN) == SOCKET_ERROR) {\n+        err_msg = strprintf(_(\"Cannot listen on %s: %s\"), to.ToStringAddrPort(), NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    m_listen.emplace_back(std::move(sock));\n+\n+    return true;\n+}\n+\n+void SockMan::StartSocketsThreads(const Options& options)\n+{\n+    m_thread_socket_handler = std::thread(\n+        &util::TraceThread, options.socket_handler_thread_name, [this] { ThreadSocketHandler(); });\n+\n+    if (options.i2p.has_value()) {\n+        m_i2p_sam_session = std::make_unique<i2p::sam::Session>(\n+            options.i2p->private_key_file, options.i2p->sam_proxy, &interruptNet);\n+\n+        m_thread_i2p_accept =\n+            std::thread(&util::TraceThread, options.i2p->accept_thread_name, [this] { ThreadI2PAccept(); });\n+    }\n+}\n+\n+void SockMan::JoinSocketsThreads()\n+{\n+    if (m_thread_i2p_accept.joinable()) {\n+        m_thread_i2p_accept.join();\n+    }\n+\n+    if (m_thread_socket_handler.joinable()) {\n+        m_thread_socket_handler.join();\n+    }\n+}\n+\n+std::optional<SockMan::Id>\n+SockMan::ConnectAndMakeId(const std::variant<CService, StringHostIntPort>& to,\n+                          bool is_important,\n+                          std::optional<Proxy> proxy,\n+                          bool& proxy_failed,\n+                          CService& me)\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+    AssertLockNotHeld(m_unused_i2p_sessions_mutex);\n+\n+    std::unique_ptr<Sock> sock;\n+    std::unique_ptr<i2p::sam::Session> i2p_transient_session;\n+\n+    Assume(!me.IsValid());\n+\n+    if (std::holds_alternative<CService>(to)) {\n+        const CService& addr_to{std::get<CService>(to)};\n+        if (addr_to.IsI2P()) {\n+            if (!Assume(proxy.has_value())) {\n+                return std::nullopt;\n+            }\n+\n+            i2p::Connection conn;\n+            bool connected{false};\n+\n+            if (m_i2p_sam_session) {\n+                connected = m_i2p_sam_session->Connect(addr_to, conn, proxy_failed);\n+            } else {\n+                {\n+                    LOCK(m_unused_i2p_sessions_mutex);\n+                    if (m_unused_i2p_sessions.empty()) {\n+                        i2p_transient_session = std::make_unique<i2p::sam::Session>(proxy.value(), &interruptNet);\n+                    } else {\n+                        i2p_transient_session.swap(m_unused_i2p_sessions.front());\n+                        m_unused_i2p_sessions.pop();\n+                    }\n+                }\n+                connected = i2p_transient_session->Connect(addr_to, conn, proxy_failed);\n+                if (!connected) {\n+                    LOCK(m_unused_i2p_sessions_mutex);\n+                    if (m_unused_i2p_sessions.size() < MAX_UNUSED_I2P_SESSIONS_SIZE) {\n+                        m_unused_i2p_sessions.emplace(i2p_transient_session.release());\n+                    }\n+                }\n+            }\n+\n+            if (connected) {\n+                sock = std::move(conn.sock);\n+                me = conn.me;\n+            }\n+        } else if (proxy.has_value()) {\n+            sock = ConnectThroughProxy(proxy.value(), addr_to.ToStringAddr(), addr_to.GetPort(), proxy_failed);\n+        } else {\n+            sock = ConnectDirectly(addr_to, is_important);\n+        }\n+    } else {\n+        if (!Assume(proxy.has_value())) {\n+            return std::nullopt;\n+        }\n+\n+        const auto& hostport{std::get<StringHostIntPort>(to)};\n+\n+        bool dummy_proxy_failed;\n+        sock = ConnectThroughProxy(proxy.value(), hostport.host, hostport.port, dummy_proxy_failed);\n+    }\n+\n+    if (!sock) {\n+        return std::nullopt;\n+    }\n+\n+    if (!me.IsValid()) {\n+        me = GetBindAddress(*sock);\n+    }\n+\n+    const Id id{GetNewId()};\n+\n+    {\n+        LOCK(m_connected_mutex);\n+        m_connected.emplace(id, std::make_shared<ConnectionSockets>(std::move(sock),\n+                                                                    std::move(i2p_transient_session)));\n+    }\n+\n+    return id;\n+}\n+\n+bool SockMan::CloseConnection(Id id)\n+{\n+    LOCK(m_connected_mutex);\n+    return m_connected.erase(id) > 0;\n+}\n+\n+ssize_t SockMan::SendBytes(Id id,\n+                           std::span<const unsigned char> data,\n+                           bool will_send_more,\n+                           std::string& errmsg) const\n+{\n+    AssertLockNotHeld(m_connected_mutex);",
      "path": "src/common/sockman.cpp",
      "position": 236,
      "original_position": 236,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "741f17e51ddac002fadbc735e2ca650117594a3c",
      "in_reply_to_id": null,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I may have a situation in HTTP where SendBytes() is being called from a thread other than the Sockman I/O loop, which would be an \"optimistic send\" directly from a worker thread. `CConnman::PushMessage()` has similar logic, but since p2p doesn't use worker threads I don't think it would cause an issue there. I think this assertion may be the only real conflict for that. `m_connected_mutex` is only used in `GetConnectionSockets()` -- would a little lock-waiting there be so terrible?",
      "created_at": "2025-03-03T18:10:40Z",
      "updated_at": "2025-03-03T18:10:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1977960657",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1977960657"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 236,
      "original_line": 236,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1981016234",
      "pull_request_review_id": 2660486983,
      "id": 1981016234,
      "node_id": "PRRC_kwDOABII5852E-iq",
      "diff_hunk": "@@ -0,0 +1,535 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+#include <cassert>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+/** Get the bind address for a socket as CService. */\n+static CService GetBindAddress(const Sock& sock)\n+{\n+    CService addr_bind;\n+    struct sockaddr_storage sockaddr_bind;\n+    socklen_t sockaddr_bind_len = sizeof(sockaddr_bind);\n+    if (!sock.GetSockName((struct sockaddr*)&sockaddr_bind, &sockaddr_bind_len)) {\n+        addr_bind.SetSockAddr((const struct sockaddr*)&sockaddr_bind, sockaddr_bind_len);\n+    } else {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"getsockname failed\\n\");\n+    }\n+    return addr_bind;\n+}\n+\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& err_msg)\n+{\n+    // Create socket for listening for incoming connections\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {\n+        err_msg = Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()));\n+        return false;\n+    }\n+\n+    std::unique_ptr<Sock> sock{CreateSock(to.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP)};\n+    if (!sock) {\n+        err_msg = Untranslated(strprintf(\"Cannot create %s listen socket: %s\",\n+                                         to.ToStringAddrPort(),\n+                                         NetworkErrorString(WSAGetLastError())));\n+        return false;\n+    }\n+\n+    int one{1};\n+\n+    // Allow binding if the port is still in TIME_WAIT state after\n+    // the program was closed and restarted.\n+    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+        LogPrintLevel(BCLog::NET,\n+                      BCLog::Level::Info,\n+                      \"Cannot set SO_REUSEADDR on %s listen socket: %s, continuing anyway\\n\",\n+                      to.ToStringAddrPort(),\n+                      NetworkErrorString(WSAGetLastError()));\n+    }\n+\n+    // some systems don't have IPV6_V6ONLY but are always v6only; others do have the option\n+    // and enable it by default or not. Try to enable it, if possible.\n+    if (to.IsIPv6()) {\n+#ifdef IPV6_V6ONLY\n+        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_V6ONLY on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+#ifdef WIN32\n+        int prot_level{PROTECTION_LEVEL_UNRESTRICTED};\n+        if (sock->SetSockOpt(IPPROTO_IPV6,\n+                             IPV6_PROTECTION_LEVEL,\n+                             reinterpret_cast<const char*>(&prot_level),\n+                             sizeof(prot_level)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_PROTECTION_LEVEL on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+    }\n+\n+    if (sock->Bind(reinterpret_cast<sockaddr*>(&storage), len) == SOCKET_ERROR) {\n+        const int err{WSAGetLastError()};\n+        if (err == WSAEADDRINUSE) {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer. %s is probably already running.\"),\n+                                to.ToStringAddrPort(),\n+                                CLIENT_NAME);\n+        } else {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer (bind returned error %s)\"),\n+                                to.ToStringAddrPort(),\n+                                NetworkErrorString(err));\n+        }\n+        return false;\n+    }\n+\n+    // Listen for incoming connections\n+    if (sock->Listen(SOMAXCONN) == SOCKET_ERROR) {\n+        err_msg = strprintf(_(\"Cannot listen on %s: %s\"), to.ToStringAddrPort(), NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    m_listen.emplace_back(std::move(sock));\n+\n+    return true;\n+}\n+\n+void SockMan::StartSocketsThreads(const Options& options)\n+{\n+    m_thread_socket_handler = std::thread(\n+        &util::TraceThread, options.socket_handler_thread_name, [this] { ThreadSocketHandler(); });\n+\n+    if (options.i2p.has_value()) {\n+        m_i2p_sam_session = std::make_unique<i2p::sam::Session>(\n+            options.i2p->private_key_file, options.i2p->sam_proxy, &interruptNet);\n+\n+        m_thread_i2p_accept =\n+            std::thread(&util::TraceThread, options.i2p->accept_thread_name, [this] { ThreadI2PAccept(); });\n+    }\n+}\n+\n+void SockMan::JoinSocketsThreads()\n+{\n+    if (m_thread_i2p_accept.joinable()) {\n+        m_thread_i2p_accept.join();\n+    }\n+\n+    if (m_thread_socket_handler.joinable()) {\n+        m_thread_socket_handler.join();\n+    }\n+}\n+\n+std::optional<SockMan::Id>\n+SockMan::ConnectAndMakeId(const std::variant<CService, StringHostIntPort>& to,\n+                          bool is_important,\n+                          std::optional<Proxy> proxy,\n+                          bool& proxy_failed,\n+                          CService& me)\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+    AssertLockNotHeld(m_unused_i2p_sessions_mutex);\n+\n+    std::unique_ptr<Sock> sock;\n+    std::unique_ptr<i2p::sam::Session> i2p_transient_session;\n+\n+    Assume(!me.IsValid());\n+\n+    if (std::holds_alternative<CService>(to)) {\n+        const CService& addr_to{std::get<CService>(to)};\n+        if (addr_to.IsI2P()) {\n+            if (!Assume(proxy.has_value())) {\n+                return std::nullopt;\n+            }\n+\n+            i2p::Connection conn;\n+            bool connected{false};\n+\n+            if (m_i2p_sam_session) {\n+                connected = m_i2p_sam_session->Connect(addr_to, conn, proxy_failed);\n+            } else {\n+                {\n+                    LOCK(m_unused_i2p_sessions_mutex);\n+                    if (m_unused_i2p_sessions.empty()) {\n+                        i2p_transient_session = std::make_unique<i2p::sam::Session>(proxy.value(), &interruptNet);\n+                    } else {\n+                        i2p_transient_session.swap(m_unused_i2p_sessions.front());\n+                        m_unused_i2p_sessions.pop();\n+                    }\n+                }\n+                connected = i2p_transient_session->Connect(addr_to, conn, proxy_failed);\n+                if (!connected) {\n+                    LOCK(m_unused_i2p_sessions_mutex);\n+                    if (m_unused_i2p_sessions.size() < MAX_UNUSED_I2P_SESSIONS_SIZE) {\n+                        m_unused_i2p_sessions.emplace(i2p_transient_session.release());\n+                    }\n+                }\n+            }\n+\n+            if (connected) {\n+                sock = std::move(conn.sock);\n+                me = conn.me;\n+            }\n+        } else if (proxy.has_value()) {\n+            sock = ConnectThroughProxy(proxy.value(), addr_to.ToStringAddr(), addr_to.GetPort(), proxy_failed);\n+        } else {\n+            sock = ConnectDirectly(addr_to, is_important);\n+        }\n+    } else {\n+        if (!Assume(proxy.has_value())) {\n+            return std::nullopt;\n+        }\n+\n+        const auto& hostport{std::get<StringHostIntPort>(to)};\n+\n+        bool dummy_proxy_failed;\n+        sock = ConnectThroughProxy(proxy.value(), hostport.host, hostport.port, dummy_proxy_failed);\n+    }\n+\n+    if (!sock) {\n+        return std::nullopt;\n+    }\n+\n+    if (!me.IsValid()) {\n+        me = GetBindAddress(*sock);\n+    }\n+\n+    const Id id{GetNewId()};\n+\n+    {\n+        LOCK(m_connected_mutex);\n+        m_connected.emplace(id, std::make_shared<ConnectionSockets>(std::move(sock),\n+                                                                    std::move(i2p_transient_session)));\n+    }\n+\n+    return id;\n+}\n+\n+bool SockMan::CloseConnection(Id id)\n+{\n+    LOCK(m_connected_mutex);\n+    return m_connected.erase(id) > 0;\n+}\n+\n+ssize_t SockMan::SendBytes(Id id,\n+                           std::span<const unsigned char> data,\n+                           bool will_send_more,\n+                           std::string& errmsg) const\n+{\n+    AssertLockNotHeld(m_connected_mutex);",
      "path": "src/common/sockman.cpp",
      "position": 236,
      "original_position": 236,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "741f17e51ddac002fadbc735e2ca650117594a3c",
      "in_reply_to_id": 1977960657,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Hmm, the assertion is that the mutex is **not** held by the caller of `SendBytes()`. The mutex is private in `SockMan` so it cannot be held by the HTTP code when it calls `SendBytes()`, no?",
      "created_at": "2025-03-05T09:26:07Z",
      "updated_at": "2025-03-05T09:26:07Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1981016234",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1981016234"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 236,
      "original_line": 236,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1981222955",
      "pull_request_review_id": 2660824284,
      "id": 1981222955,
      "node_id": "PRRC_kwDOABII5852FxAr",
      "diff_hunk": "@@ -0,0 +1,535 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+#include <cassert>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+/** Get the bind address for a socket as CService. */\n+static CService GetBindAddress(const Sock& sock)\n+{\n+    CService addr_bind;\n+    struct sockaddr_storage sockaddr_bind;\n+    socklen_t sockaddr_bind_len = sizeof(sockaddr_bind);\n+    if (!sock.GetSockName((struct sockaddr*)&sockaddr_bind, &sockaddr_bind_len)) {\n+        addr_bind.SetSockAddr((const struct sockaddr*)&sockaddr_bind, sockaddr_bind_len);\n+    } else {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"getsockname failed\\n\");\n+    }\n+    return addr_bind;\n+}\n+\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& err_msg)\n+{\n+    // Create socket for listening for incoming connections\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {\n+        err_msg = Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()));\n+        return false;\n+    }\n+\n+    std::unique_ptr<Sock> sock{CreateSock(to.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP)};\n+    if (!sock) {\n+        err_msg = Untranslated(strprintf(\"Cannot create %s listen socket: %s\",\n+                                         to.ToStringAddrPort(),\n+                                         NetworkErrorString(WSAGetLastError())));\n+        return false;\n+    }\n+\n+    int one{1};\n+\n+    // Allow binding if the port is still in TIME_WAIT state after\n+    // the program was closed and restarted.\n+    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+        LogPrintLevel(BCLog::NET,\n+                      BCLog::Level::Info,\n+                      \"Cannot set SO_REUSEADDR on %s listen socket: %s, continuing anyway\\n\",\n+                      to.ToStringAddrPort(),\n+                      NetworkErrorString(WSAGetLastError()));\n+    }\n+\n+    // some systems don't have IPV6_V6ONLY but are always v6only; others do have the option\n+    // and enable it by default or not. Try to enable it, if possible.\n+    if (to.IsIPv6()) {\n+#ifdef IPV6_V6ONLY\n+        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_V6ONLY on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+#ifdef WIN32\n+        int prot_level{PROTECTION_LEVEL_UNRESTRICTED};\n+        if (sock->SetSockOpt(IPPROTO_IPV6,\n+                             IPV6_PROTECTION_LEVEL,\n+                             reinterpret_cast<const char*>(&prot_level),\n+                             sizeof(prot_level)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_PROTECTION_LEVEL on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+    }\n+\n+    if (sock->Bind(reinterpret_cast<sockaddr*>(&storage), len) == SOCKET_ERROR) {\n+        const int err{WSAGetLastError()};\n+        if (err == WSAEADDRINUSE) {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer. %s is probably already running.\"),\n+                                to.ToStringAddrPort(),\n+                                CLIENT_NAME);\n+        } else {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer (bind returned error %s)\"),\n+                                to.ToStringAddrPort(),\n+                                NetworkErrorString(err));\n+        }\n+        return false;\n+    }\n+\n+    // Listen for incoming connections\n+    if (sock->Listen(SOMAXCONN) == SOCKET_ERROR) {\n+        err_msg = strprintf(_(\"Cannot listen on %s: %s\"), to.ToStringAddrPort(), NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    m_listen.emplace_back(std::move(sock));\n+\n+    return true;\n+}\n+\n+void SockMan::StartSocketsThreads(const Options& options)\n+{\n+    m_thread_socket_handler = std::thread(\n+        &util::TraceThread, options.socket_handler_thread_name, [this] { ThreadSocketHandler(); });\n+\n+    if (options.i2p.has_value()) {\n+        m_i2p_sam_session = std::make_unique<i2p::sam::Session>(\n+            options.i2p->private_key_file, options.i2p->sam_proxy, &interruptNet);\n+\n+        m_thread_i2p_accept =\n+            std::thread(&util::TraceThread, options.i2p->accept_thread_name, [this] { ThreadI2PAccept(); });\n+    }\n+}\n+\n+void SockMan::JoinSocketsThreads()\n+{\n+    if (m_thread_i2p_accept.joinable()) {\n+        m_thread_i2p_accept.join();\n+    }\n+\n+    if (m_thread_socket_handler.joinable()) {\n+        m_thread_socket_handler.join();\n+    }\n+}\n+\n+std::optional<SockMan::Id>\n+SockMan::ConnectAndMakeId(const std::variant<CService, StringHostIntPort>& to,\n+                          bool is_important,\n+                          std::optional<Proxy> proxy,\n+                          bool& proxy_failed,\n+                          CService& me)\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+    AssertLockNotHeld(m_unused_i2p_sessions_mutex);\n+\n+    std::unique_ptr<Sock> sock;\n+    std::unique_ptr<i2p::sam::Session> i2p_transient_session;\n+\n+    Assume(!me.IsValid());\n+\n+    if (std::holds_alternative<CService>(to)) {\n+        const CService& addr_to{std::get<CService>(to)};\n+        if (addr_to.IsI2P()) {\n+            if (!Assume(proxy.has_value())) {\n+                return std::nullopt;\n+            }\n+\n+            i2p::Connection conn;\n+            bool connected{false};\n+\n+            if (m_i2p_sam_session) {\n+                connected = m_i2p_sam_session->Connect(addr_to, conn, proxy_failed);\n+            } else {\n+                {\n+                    LOCK(m_unused_i2p_sessions_mutex);\n+                    if (m_unused_i2p_sessions.empty()) {\n+                        i2p_transient_session = std::make_unique<i2p::sam::Session>(proxy.value(), &interruptNet);\n+                    } else {\n+                        i2p_transient_session.swap(m_unused_i2p_sessions.front());\n+                        m_unused_i2p_sessions.pop();\n+                    }\n+                }\n+                connected = i2p_transient_session->Connect(addr_to, conn, proxy_failed);\n+                if (!connected) {\n+                    LOCK(m_unused_i2p_sessions_mutex);\n+                    if (m_unused_i2p_sessions.size() < MAX_UNUSED_I2P_SESSIONS_SIZE) {\n+                        m_unused_i2p_sessions.emplace(i2p_transient_session.release());\n+                    }\n+                }\n+            }\n+\n+            if (connected) {\n+                sock = std::move(conn.sock);\n+                me = conn.me;\n+            }\n+        } else if (proxy.has_value()) {\n+            sock = ConnectThroughProxy(proxy.value(), addr_to.ToStringAddr(), addr_to.GetPort(), proxy_failed);\n+        } else {\n+            sock = ConnectDirectly(addr_to, is_important);\n+        }\n+    } else {\n+        if (!Assume(proxy.has_value())) {\n+            return std::nullopt;\n+        }\n+\n+        const auto& hostport{std::get<StringHostIntPort>(to)};\n+\n+        bool dummy_proxy_failed;\n+        sock = ConnectThroughProxy(proxy.value(), hostport.host, hostport.port, dummy_proxy_failed);\n+    }\n+\n+    if (!sock) {\n+        return std::nullopt;\n+    }\n+\n+    if (!me.IsValid()) {\n+        me = GetBindAddress(*sock);\n+    }\n+\n+    const Id id{GetNewId()};\n+\n+    {\n+        LOCK(m_connected_mutex);\n+        m_connected.emplace(id, std::make_shared<ConnectionSockets>(std::move(sock),\n+                                                                    std::move(i2p_transient_session)));\n+    }\n+\n+    return id;\n+}\n+\n+bool SockMan::CloseConnection(Id id)\n+{\n+    LOCK(m_connected_mutex);\n+    return m_connected.erase(id) > 0;\n+}\n+\n+ssize_t SockMan::SendBytes(Id id,\n+                           std::span<const unsigned char> data,\n+                           bool will_send_more,\n+                           std::string& errmsg) const\n+{\n+    AssertLockNotHeld(m_connected_mutex);",
      "path": "src/common/sockman.cpp",
      "position": 236,
      "original_position": 236,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "741f17e51ddac002fadbc735e2ca650117594a3c",
      "in_reply_to_id": 1977960657,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "If SendBytes() is called from outside the loop then the lock could be held by something else inside the loop, including another call to SendBytes (ie from EventReadyToSend)",
      "created_at": "2025-03-05T11:30:59Z",
      "updated_at": "2025-03-05T11:30:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1981222955",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1981222955"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 236,
      "original_line": 236,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1981233604",
      "pull_request_review_id": 2660838310,
      "id": 1981233604,
      "node_id": "PRRC_kwDOABII5852FznE",
      "diff_hunk": "@@ -0,0 +1,535 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+#include <cassert>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+/** Get the bind address for a socket as CService. */\n+static CService GetBindAddress(const Sock& sock)\n+{\n+    CService addr_bind;\n+    struct sockaddr_storage sockaddr_bind;\n+    socklen_t sockaddr_bind_len = sizeof(sockaddr_bind);\n+    if (!sock.GetSockName((struct sockaddr*)&sockaddr_bind, &sockaddr_bind_len)) {\n+        addr_bind.SetSockAddr((const struct sockaddr*)&sockaddr_bind, sockaddr_bind_len);\n+    } else {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"getsockname failed\\n\");\n+    }\n+    return addr_bind;\n+}\n+\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& err_msg)\n+{\n+    // Create socket for listening for incoming connections\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {\n+        err_msg = Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()));\n+        return false;\n+    }\n+\n+    std::unique_ptr<Sock> sock{CreateSock(to.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP)};\n+    if (!sock) {\n+        err_msg = Untranslated(strprintf(\"Cannot create %s listen socket: %s\",\n+                                         to.ToStringAddrPort(),\n+                                         NetworkErrorString(WSAGetLastError())));\n+        return false;\n+    }\n+\n+    int one{1};\n+\n+    // Allow binding if the port is still in TIME_WAIT state after\n+    // the program was closed and restarted.\n+    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+        LogPrintLevel(BCLog::NET,\n+                      BCLog::Level::Info,\n+                      \"Cannot set SO_REUSEADDR on %s listen socket: %s, continuing anyway\\n\",\n+                      to.ToStringAddrPort(),\n+                      NetworkErrorString(WSAGetLastError()));\n+    }\n+\n+    // some systems don't have IPV6_V6ONLY but are always v6only; others do have the option\n+    // and enable it by default or not. Try to enable it, if possible.\n+    if (to.IsIPv6()) {\n+#ifdef IPV6_V6ONLY\n+        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_V6ONLY on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+#ifdef WIN32\n+        int prot_level{PROTECTION_LEVEL_UNRESTRICTED};\n+        if (sock->SetSockOpt(IPPROTO_IPV6,\n+                             IPV6_PROTECTION_LEVEL,\n+                             reinterpret_cast<const char*>(&prot_level),\n+                             sizeof(prot_level)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_PROTECTION_LEVEL on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+    }\n+\n+    if (sock->Bind(reinterpret_cast<sockaddr*>(&storage), len) == SOCKET_ERROR) {\n+        const int err{WSAGetLastError()};\n+        if (err == WSAEADDRINUSE) {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer. %s is probably already running.\"),\n+                                to.ToStringAddrPort(),\n+                                CLIENT_NAME);\n+        } else {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer (bind returned error %s)\"),\n+                                to.ToStringAddrPort(),\n+                                NetworkErrorString(err));\n+        }\n+        return false;\n+    }\n+\n+    // Listen for incoming connections\n+    if (sock->Listen(SOMAXCONN) == SOCKET_ERROR) {\n+        err_msg = strprintf(_(\"Cannot listen on %s: %s\"), to.ToStringAddrPort(), NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    m_listen.emplace_back(std::move(sock));\n+\n+    return true;\n+}\n+\n+void SockMan::StartSocketsThreads(const Options& options)\n+{\n+    m_thread_socket_handler = std::thread(\n+        &util::TraceThread, options.socket_handler_thread_name, [this] { ThreadSocketHandler(); });\n+\n+    if (options.i2p.has_value()) {\n+        m_i2p_sam_session = std::make_unique<i2p::sam::Session>(\n+            options.i2p->private_key_file, options.i2p->sam_proxy, &interruptNet);\n+\n+        m_thread_i2p_accept =\n+            std::thread(&util::TraceThread, options.i2p->accept_thread_name, [this] { ThreadI2PAccept(); });\n+    }\n+}\n+\n+void SockMan::JoinSocketsThreads()\n+{\n+    if (m_thread_i2p_accept.joinable()) {\n+        m_thread_i2p_accept.join();\n+    }\n+\n+    if (m_thread_socket_handler.joinable()) {\n+        m_thread_socket_handler.join();\n+    }\n+}\n+\n+std::optional<SockMan::Id>\n+SockMan::ConnectAndMakeId(const std::variant<CService, StringHostIntPort>& to,\n+                          bool is_important,\n+                          std::optional<Proxy> proxy,\n+                          bool& proxy_failed,\n+                          CService& me)\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+    AssertLockNotHeld(m_unused_i2p_sessions_mutex);\n+\n+    std::unique_ptr<Sock> sock;\n+    std::unique_ptr<i2p::sam::Session> i2p_transient_session;\n+\n+    Assume(!me.IsValid());\n+\n+    if (std::holds_alternative<CService>(to)) {\n+        const CService& addr_to{std::get<CService>(to)};\n+        if (addr_to.IsI2P()) {\n+            if (!Assume(proxy.has_value())) {\n+                return std::nullopt;\n+            }\n+\n+            i2p::Connection conn;\n+            bool connected{false};\n+\n+            if (m_i2p_sam_session) {\n+                connected = m_i2p_sam_session->Connect(addr_to, conn, proxy_failed);\n+            } else {\n+                {\n+                    LOCK(m_unused_i2p_sessions_mutex);\n+                    if (m_unused_i2p_sessions.empty()) {\n+                        i2p_transient_session = std::make_unique<i2p::sam::Session>(proxy.value(), &interruptNet);\n+                    } else {\n+                        i2p_transient_session.swap(m_unused_i2p_sessions.front());\n+                        m_unused_i2p_sessions.pop();\n+                    }\n+                }\n+                connected = i2p_transient_session->Connect(addr_to, conn, proxy_failed);\n+                if (!connected) {\n+                    LOCK(m_unused_i2p_sessions_mutex);\n+                    if (m_unused_i2p_sessions.size() < MAX_UNUSED_I2P_SESSIONS_SIZE) {\n+                        m_unused_i2p_sessions.emplace(i2p_transient_session.release());\n+                    }\n+                }\n+            }\n+\n+            if (connected) {\n+                sock = std::move(conn.sock);\n+                me = conn.me;\n+            }\n+        } else if (proxy.has_value()) {\n+            sock = ConnectThroughProxy(proxy.value(), addr_to.ToStringAddr(), addr_to.GetPort(), proxy_failed);\n+        } else {\n+            sock = ConnectDirectly(addr_to, is_important);\n+        }\n+    } else {\n+        if (!Assume(proxy.has_value())) {\n+            return std::nullopt;\n+        }\n+\n+        const auto& hostport{std::get<StringHostIntPort>(to)};\n+\n+        bool dummy_proxy_failed;\n+        sock = ConnectThroughProxy(proxy.value(), hostport.host, hostport.port, dummy_proxy_failed);\n+    }\n+\n+    if (!sock) {\n+        return std::nullopt;\n+    }\n+\n+    if (!me.IsValid()) {\n+        me = GetBindAddress(*sock);\n+    }\n+\n+    const Id id{GetNewId()};\n+\n+    {\n+        LOCK(m_connected_mutex);\n+        m_connected.emplace(id, std::make_shared<ConnectionSockets>(std::move(sock),\n+                                                                    std::move(i2p_transient_session)));\n+    }\n+\n+    return id;\n+}\n+\n+bool SockMan::CloseConnection(Id id)\n+{\n+    LOCK(m_connected_mutex);\n+    return m_connected.erase(id) > 0;\n+}\n+\n+ssize_t SockMan::SendBytes(Id id,\n+                           std::span<const unsigned char> data,\n+                           bool will_send_more,\n+                           std::string& errmsg) const\n+{\n+    AssertLockNotHeld(m_connected_mutex);",
      "path": "src/common/sockman.cpp",
      "position": 236,
      "original_position": 236,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "741f17e51ddac002fadbc735e2ca650117594a3c",
      "in_reply_to_id": 1977960657,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Oh wait. AssertLockNotHeld only applies to the caller? It doesn't require that the mutex is open on all threads and available to lock?",
      "created_at": "2025-03-05T11:33:30Z",
      "updated_at": "2025-03-05T11:33:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1981233604",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1981233604"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 236,
      "original_line": 236,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1981304441",
      "pull_request_review_id": 2660956192,
      "id": 1981304441,
      "node_id": "PRRC_kwDOABII5852GE55",
      "diff_hunk": "@@ -0,0 +1,535 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://opensource.org/license/mit/.\n+\n+#include <bitcoin-build-config.h> // IWYU pragma: keep\n+\n+#include <common/sockman.h>\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/sock.h>\n+#include <util/thread.h>\n+\n+#include <cassert>\n+\n+// The set of sockets cannot be modified while waiting\n+// The sleep time needs to be small to avoid new sockets stalling\n+static constexpr auto SELECT_TIMEOUT{50ms};\n+\n+/** Get the bind address for a socket as CService. */\n+static CService GetBindAddress(const Sock& sock)\n+{\n+    CService addr_bind;\n+    struct sockaddr_storage sockaddr_bind;\n+    socklen_t sockaddr_bind_len = sizeof(sockaddr_bind);\n+    if (!sock.GetSockName((struct sockaddr*)&sockaddr_bind, &sockaddr_bind_len)) {\n+        addr_bind.SetSockAddr((const struct sockaddr*)&sockaddr_bind, sockaddr_bind_len);\n+    } else {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"getsockname failed\\n\");\n+    }\n+    return addr_bind;\n+}\n+\n+bool SockMan::BindAndStartListening(const CService& to, bilingual_str& err_msg)\n+{\n+    // Create socket for listening for incoming connections\n+    sockaddr_storage storage;\n+    socklen_t len{sizeof(storage)};\n+    if (!to.GetSockAddr(reinterpret_cast<sockaddr*>(&storage), &len)) {\n+        err_msg = Untranslated(strprintf(\"Bind address family for %s not supported\", to.ToStringAddrPort()));\n+        return false;\n+    }\n+\n+    std::unique_ptr<Sock> sock{CreateSock(to.GetSAFamily(), SOCK_STREAM, IPPROTO_TCP)};\n+    if (!sock) {\n+        err_msg = Untranslated(strprintf(\"Cannot create %s listen socket: %s\",\n+                                         to.ToStringAddrPort(),\n+                                         NetworkErrorString(WSAGetLastError())));\n+        return false;\n+    }\n+\n+    int one{1};\n+\n+    // Allow binding if the port is still in TIME_WAIT state after\n+    // the program was closed and restarted.\n+    if (sock->SetSockOpt(SOL_SOCKET, SO_REUSEADDR, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+        LogPrintLevel(BCLog::NET,\n+                      BCLog::Level::Info,\n+                      \"Cannot set SO_REUSEADDR on %s listen socket: %s, continuing anyway\\n\",\n+                      to.ToStringAddrPort(),\n+                      NetworkErrorString(WSAGetLastError()));\n+    }\n+\n+    // some systems don't have IPV6_V6ONLY but are always v6only; others do have the option\n+    // and enable it by default or not. Try to enable it, if possible.\n+    if (to.IsIPv6()) {\n+#ifdef IPV6_V6ONLY\n+        if (sock->SetSockOpt(IPPROTO_IPV6, IPV6_V6ONLY, reinterpret_cast<sockopt_arg_type>(&one), sizeof(one)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_V6ONLY on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+#ifdef WIN32\n+        int prot_level{PROTECTION_LEVEL_UNRESTRICTED};\n+        if (sock->SetSockOpt(IPPROTO_IPV6,\n+                             IPV6_PROTECTION_LEVEL,\n+                             reinterpret_cast<const char*>(&prot_level),\n+                             sizeof(prot_level)) == SOCKET_ERROR) {\n+            LogPrintLevel(BCLog::NET,\n+                          BCLog::Level::Info,\n+                          \"Cannot set IPV6_PROTECTION_LEVEL on %s listen socket: %s, continuing anyway\\n\",\n+                          to.ToStringAddrPort(),\n+                          NetworkErrorString(WSAGetLastError()));\n+        }\n+#endif\n+    }\n+\n+    if (sock->Bind(reinterpret_cast<sockaddr*>(&storage), len) == SOCKET_ERROR) {\n+        const int err{WSAGetLastError()};\n+        if (err == WSAEADDRINUSE) {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer. %s is probably already running.\"),\n+                                to.ToStringAddrPort(),\n+                                CLIENT_NAME);\n+        } else {\n+            err_msg = strprintf(_(\"Unable to bind to %s on this computer (bind returned error %s)\"),\n+                                to.ToStringAddrPort(),\n+                                NetworkErrorString(err));\n+        }\n+        return false;\n+    }\n+\n+    // Listen for incoming connections\n+    if (sock->Listen(SOMAXCONN) == SOCKET_ERROR) {\n+        err_msg = strprintf(_(\"Cannot listen on %s: %s\"), to.ToStringAddrPort(), NetworkErrorString(WSAGetLastError()));\n+        return false;\n+    }\n+\n+    m_listen.emplace_back(std::move(sock));\n+\n+    return true;\n+}\n+\n+void SockMan::StartSocketsThreads(const Options& options)\n+{\n+    m_thread_socket_handler = std::thread(\n+        &util::TraceThread, options.socket_handler_thread_name, [this] { ThreadSocketHandler(); });\n+\n+    if (options.i2p.has_value()) {\n+        m_i2p_sam_session = std::make_unique<i2p::sam::Session>(\n+            options.i2p->private_key_file, options.i2p->sam_proxy, &interruptNet);\n+\n+        m_thread_i2p_accept =\n+            std::thread(&util::TraceThread, options.i2p->accept_thread_name, [this] { ThreadI2PAccept(); });\n+    }\n+}\n+\n+void SockMan::JoinSocketsThreads()\n+{\n+    if (m_thread_i2p_accept.joinable()) {\n+        m_thread_i2p_accept.join();\n+    }\n+\n+    if (m_thread_socket_handler.joinable()) {\n+        m_thread_socket_handler.join();\n+    }\n+}\n+\n+std::optional<SockMan::Id>\n+SockMan::ConnectAndMakeId(const std::variant<CService, StringHostIntPort>& to,\n+                          bool is_important,\n+                          std::optional<Proxy> proxy,\n+                          bool& proxy_failed,\n+                          CService& me)\n+{\n+    AssertLockNotHeld(m_connected_mutex);\n+    AssertLockNotHeld(m_unused_i2p_sessions_mutex);\n+\n+    std::unique_ptr<Sock> sock;\n+    std::unique_ptr<i2p::sam::Session> i2p_transient_session;\n+\n+    Assume(!me.IsValid());\n+\n+    if (std::holds_alternative<CService>(to)) {\n+        const CService& addr_to{std::get<CService>(to)};\n+        if (addr_to.IsI2P()) {\n+            if (!Assume(proxy.has_value())) {\n+                return std::nullopt;\n+            }\n+\n+            i2p::Connection conn;\n+            bool connected{false};\n+\n+            if (m_i2p_sam_session) {\n+                connected = m_i2p_sam_session->Connect(addr_to, conn, proxy_failed);\n+            } else {\n+                {\n+                    LOCK(m_unused_i2p_sessions_mutex);\n+                    if (m_unused_i2p_sessions.empty()) {\n+                        i2p_transient_session = std::make_unique<i2p::sam::Session>(proxy.value(), &interruptNet);\n+                    } else {\n+                        i2p_transient_session.swap(m_unused_i2p_sessions.front());\n+                        m_unused_i2p_sessions.pop();\n+                    }\n+                }\n+                connected = i2p_transient_session->Connect(addr_to, conn, proxy_failed);\n+                if (!connected) {\n+                    LOCK(m_unused_i2p_sessions_mutex);\n+                    if (m_unused_i2p_sessions.size() < MAX_UNUSED_I2P_SESSIONS_SIZE) {\n+                        m_unused_i2p_sessions.emplace(i2p_transient_session.release());\n+                    }\n+                }\n+            }\n+\n+            if (connected) {\n+                sock = std::move(conn.sock);\n+                me = conn.me;\n+            }\n+        } else if (proxy.has_value()) {\n+            sock = ConnectThroughProxy(proxy.value(), addr_to.ToStringAddr(), addr_to.GetPort(), proxy_failed);\n+        } else {\n+            sock = ConnectDirectly(addr_to, is_important);\n+        }\n+    } else {\n+        if (!Assume(proxy.has_value())) {\n+            return std::nullopt;\n+        }\n+\n+        const auto& hostport{std::get<StringHostIntPort>(to)};\n+\n+        bool dummy_proxy_failed;\n+        sock = ConnectThroughProxy(proxy.value(), hostport.host, hostport.port, dummy_proxy_failed);\n+    }\n+\n+    if (!sock) {\n+        return std::nullopt;\n+    }\n+\n+    if (!me.IsValid()) {\n+        me = GetBindAddress(*sock);\n+    }\n+\n+    const Id id{GetNewId()};\n+\n+    {\n+        LOCK(m_connected_mutex);\n+        m_connected.emplace(id, std::make_shared<ConnectionSockets>(std::move(sock),\n+                                                                    std::move(i2p_transient_session)));\n+    }\n+\n+    return id;\n+}\n+\n+bool SockMan::CloseConnection(Id id)\n+{\n+    LOCK(m_connected_mutex);\n+    return m_connected.erase(id) > 0;\n+}\n+\n+ssize_t SockMan::SendBytes(Id id,\n+                           std::span<const unsigned char> data,\n+                           bool will_send_more,\n+                           std::string& errmsg) const\n+{\n+    AssertLockNotHeld(m_connected_mutex);",
      "path": "src/common/sockman.cpp",
      "position": 236,
      "original_position": 236,
      "commit_id": "7ef9661fb09d2cd9356cca7476256fea2077bec9",
      "original_commit_id": "741f17e51ddac002fadbc735e2ca650117594a3c",
      "in_reply_to_id": 1977960657,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Right, only to the caller (same thread). Locked or not by other threads is irrelevant for `AssertLockNotHeld()`.",
      "created_at": "2025-03-05T12:25:16Z",
      "updated_at": "2025-03-05T12:25:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30988#discussion_r1981304441",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1981304441"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30988"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 236,
      "original_line": 236,
      "side": "RIGHT"
    }
  ]
}