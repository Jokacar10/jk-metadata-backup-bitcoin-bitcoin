{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043",
    "id": 1855120573,
    "node_id": "PR_kwDOABII585ukuS9",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/30043",
    "diff_url": "https://github.com/bitcoin/bitcoin/pull/30043.diff",
    "patch_url": "https://github.com/bitcoin/bitcoin/pull/30043.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043",
    "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/5c7cacf649a6b474b876a7d219c7dc683a25e33d",
    "number": 30043,
    "state": "closed",
    "locked": false,
    "maintainer_can_modify": false,
    "title": "net: Replace libnatpmp with built-in PCP+NATPMP implementation",
    "user": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false,
      "patch_url": null
    },
    "body": "Continues #30005. Closes #17012..\r\n\r\nThis PR adds PCP (Port Control Protocol) from [RFC6887](https://datatracker.ietf.org/doc/html/rfc6887).  This adds, in addition to the existing IPv4 port mapping (which now uses PCP, with fallback to NAT-PMP), support for IPv6 pinholing-that is, opening a port on the firewall to make it reachable.\r\n\r\nPCP, like NAT-PMP is a simple UDP-based protocol, and the implementation is self-contained, so this gets rid of lthe libnatpnp dependency without adding a new one. It should otherwise be a drop-in replacement. NAT-PMP fallback is implemented so this will not make router support worse.\r\n\r\nFor now it is disabled by default, though in the future (not in this PR) we could consider enable it by default to increase the number of connectable nodes without adding significant attack surface.\r\n\r\nTo test:\r\n```bash\r\nbitcoind -regtest -natpmp=1 -debug=net\r\n```\r\n\r\n(most of the changes in this PR are, ironically, removing the libnatpmp dependency and associated build system and build docs)\r\n\r\n## TODO\r\n\r\n- [x] Default gateway discovery on Linux / FreeBSD\r\n- [x] Default gateway discovery on Windows\r\n- [x] Default gateway discovery on MacOS\r\n- [x] Either solve FreeBSD compile issue (probably upstream issue) or remove FreeBSD support\r\n\r\n## Things to consider for follow-up PRs\r\n\r\n- https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1658764974 avoid unreachable nets (not given to -onlynet=)\r\n\r\n- https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1658949236 could announce an addr:port where we do not listen (no -bind)\r\n\r\n- https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1684368824 could announce the wrong port because it uses GetListenPort()\r\n \r\n- https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1679709347 if we requested one port but another was assigned, then which one to use in the renewal?\r\n\r\n- https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1772017020 Use `GetAdapterAddresses` to discover local addresses for Windows #31014\r\n\r\n- Unit testing: the code is set up to use Sock to support testing harnesses, but none have been written yet. It will also be necessary to createa a mockable steady_clock for this. #31022",
    "labels": [
      {
        "id": 98298007,
        "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
        "name": "P2P",
        "color": "006b75",
        "default": false
      }
    ],
    "milestone": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/milestones/69",
      "html_url": "https://github.com/bitcoin/bitcoin/milestone/69",
      "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones/69/labels",
      "id": 11324346,
      "node_id": "MI_kwDOABII584ArMu6",
      "number": 69,
      "state": "open",
      "title": "29.0",
      "description": "",
      "creator": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "open_issues": 18,
      "closed_issues": 93,
      "created_at": "2024-07-17T08:47:56Z",
      "updated_at": "2025-03-03T19:02:39Z"
    },
    "created_at": "2024-05-05T18:35:03Z",
    "updated_at": "2025-03-03T19:28:31Z",
    "closed_at": "2024-09-30T20:28:11Z",
    "mergeable_state": "unknown",
    "merged": true,
    "merged_at": "2024-09-30T20:28:11Z",
    "merged_by": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false,
      "patch_url": null
    },
    "merge_commit_sha": "c33eb2360e2482eee94b55aef3b8ab2eeff1576e",
    "assignees": [],
    "requested_reviewers": [
      {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    ],
    "requested_teams": [],
    "head": {
      "label": "laanwj:2024-05-pcp",
      "ref": "2024-05-pcp",
      "sha": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "repo": {
        "id": 1750308,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNzUwMzA4",
        "name": "bitcoin",
        "full_name": "laanwj/bitcoin",
        "owner": {
          "login": "laanwj",
          "id": 126646,
          "node_id": "MDQ6VXNlcjEyNjY0Ng==",
          "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/laanwj",
          "html_url": "https://github.com/laanwj",
          "followers_url": "https://api.github.com/users/laanwj/followers",
          "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
          "organizations_url": "https://api.github.com/users/laanwj/orgs",
          "repos_url": "https://api.github.com/users/laanwj/repos",
          "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/laanwj/received_events",
          "type": "User",
          "site_admin": false,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/laanwj/bitcoin",
        "description": "Laanwj's Bitcoin Core fork - see README.md on \"readme\" branch",
        "fork": true,
        "url": "https://api.github.com/repos/laanwj/bitcoin",
        "archive_url": "https://api.github.com/repos/laanwj/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/laanwj/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/laanwj/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/laanwj/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/laanwj/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/laanwj/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/laanwj/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/laanwj/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/laanwj/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/laanwj/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/laanwj/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/laanwj/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/laanwj/bitcoin/events",
        "forks_url": "https://api.github.com/repos/laanwj/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/laanwj/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/laanwj/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/laanwj/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/laanwj/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/laanwj/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/laanwj/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/laanwj/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/laanwj/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/laanwj/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/laanwj/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/laanwj/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/laanwj/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/laanwj/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/laanwj/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/laanwj/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:laanwj/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/laanwj/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/laanwj/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/laanwj/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/laanwj/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/laanwj/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/laanwj/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/laanwj/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/laanwj/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/laanwj/bitcoin/hooks",
        "svn_url": "https://github.com/laanwj/bitcoin",
        "homepage": "",
        "forks_count": 14,
        "stargazers_count": 44,
        "watchers_count": 44,
        "size": 247415,
        "default_branch": "readme",
        "open_issues_count": 0,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2025-02-26T13:43:33Z",
        "created_at": "2011-05-15T07:09:54Z",
        "updated_at": "2024-10-04T16:35:48Z",
        "allow_forking": true
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "d812cf11896a2214467b6fa72d7b763bac6077c5",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false,
        "patch_url": null
      },
      "repo": {
        "id": 1181927,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTgxOTI3",
        "name": "bitcoin",
        "full_name": "bitcoin/bitcoin",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bitcoin",
        "archive_url": "https://api.github.com/repos/bitcoin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bitcoin/hooks",
        "svn_url": "https://github.com/bitcoin/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 36870,
        "stargazers_count": 82285,
        "watchers_count": 82285,
        "size": 276091,
        "default_branch": "master",
        "open_issues_count": 675,
        "is_template": false,
        "topics": [
          "bitcoin",
          "c-plus-plus",
          "cryptocurrency",
          "cryptography",
          "p2p"
        ],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2025-03-03T14:41:08Z",
        "created_at": "2010-12-19T15:16:43Z",
        "updated_at": "2025-03-03T19:55:56Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
      }
    },
    "author_association": "MEMBER",
    "draft": false,
    "additions": 1049,
    "deletions": 283,
    "changed_files": 38,
    "commits": 10,
    "review_comments": 202,
    "comments": 90
  },
  "events": [
    {
      "event": "labeled",
      "id": 12708075166,
      "node_id": "LE_lADOABII586H4P0UzwAAAAL1ddae",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12708075166",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-05T18:35:03Z",
      "label": {
        "name": "P2P",
        "color": "006b75"
      }
    },
    {
      "event": "labeled",
      "id": 12708075167,
      "node_id": "LE_lADOABII586H4P0UzwAAAAL1ddaf",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12708075167",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-05T18:35:03Z",
      "label": {
        "name": "Needs CMake port",
        "color": "0e8a16"
      }
    },
    {
      "event": "commented",
      "id": 2094906184,
      "node_id": "IC_kwDOABII58583btI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2094906184",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-05T18:35:05Z",
      "updated_at": "2024-09-30T20:13:13Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage\nFor detailed information about the code coverage, see the [test coverage report](https://corecheck.dev/bitcoin/bitcoin/pulls/30043).\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| ACK | [vasild](https://github.com/bitcoin/bitcoin/pull/30043#pullrequestreview-2337161558), [Sjors](https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2382905543), [achow101](https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2384063267) |\n| Concept ACK | [theuni](https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2096485412), [fjahr](https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2275938528) |\n\nIf your review is incorrectly listed, please react with 👎 to this comment and the bot will ignore it on the next update.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#30997](https://github.com/bitcoin/bitcoin/pull/30997) (build: Switch to Qt 6 by hebasto)\n* [#30975](https://github.com/bitcoin/bitcoin/pull/30975) (Add multiprocess binaries to release build by Sjors)\n* [#30935](https://github.com/bitcoin/bitcoin/pull/30935) (ci: Approximate MAKEJOBS in image build phase by maflcko)\n* [#30634](https://github.com/bitcoin/bitcoin/pull/30634) (ci: Use clang-19 from apt.llvm.org by maflcko)\n* [#30315](https://github.com/bitcoin/bitcoin/pull/30315) (Stratum v2 Transport by Sjors)\n* [#29641](https://github.com/bitcoin/bitcoin/pull/29641) (scripted-diff: Use LogInfo over LogPrintf [WIP, NOMERGE, DRAFT] by maflcko)\n* [#29346](https://github.com/bitcoin/bitcoin/pull/29346) (Stratum v2 Noise Protocol by Sjors)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2094906184",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12708109392,
      "node_id": "HRFPE_lADOABII586H4P0UzwAAAAL1dlxQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12708109392",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "379d7ba4bb8f3328cef9e41d9e1bd3dec16594fe",
      "commit_url": "https://api.github.com/repos/laanwj/bitcoin/commits/379d7ba4bb8f3328cef9e41d9e1bd3dec16594fe",
      "created_at": "2024-05-05T18:49:06Z"
    },
    {
      "event": "labeled",
      "id": 12708109531,
      "node_id": "LE_lADOABII586H4P0UzwAAAAL1dlzb",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12708109531",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-05T18:49:11Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2094910598,
      "node_id": "IC_kwDOABII58583cyG",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2094910598",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-05T18:49:12Z",
      "updated_at": "2024-05-05T18:49:12Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\n\n🚧 At least one of the CI tasks failed. Make sure to run all tests locally, according to the\ndocumentation.\n\nPossibly this is due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/24606743714</sub>",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2094910598",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12708115600,
      "node_id": "HRFPE_lADOABII586H4P0UzwAAAAL1dnSQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12708115600",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "9462d4559277f4c9ce0b11f2d0a49254bb0eb4f7",
      "commit_url": "https://api.github.com/repos/laanwj/bitcoin/commits/9462d4559277f4c9ce0b11f2d0a49254bb0eb4f7",
      "created_at": "2024-05-05T18:53:00Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12708148684,
      "node_id": "HRFPE_lADOABII586H4P0UzwAAAAL1dvXM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12708148684",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "e4da3063dfb543219aa57cb8a1529b707db2c1a2",
      "commit_url": "https://api.github.com/repos/laanwj/bitcoin/commits/e4da3063dfb543219aa57cb8a1529b707db2c1a2",
      "created_at": "2024-05-05T19:11:58Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12708290177,
      "node_id": "HRFPE_lADOABII586H4P0UzwAAAAL1eR6B",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12708290177",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "d4da95f6aa7a23fb25b5f01e7a4ec1f67bceb0b7",
      "commit_url": "https://api.github.com/repos/laanwj/bitcoin/commits/d4da95f6aa7a23fb25b5f01e7a4ec1f67bceb0b7",
      "created_at": "2024-05-05T20:28:00Z"
    },
    {
      "event": "labeled",
      "id": 12708353739,
      "node_id": "LE_lADOABII586H4P0UzwAAAAL1ehbL",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12708353739",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-05T20:45:32Z",
      "label": {
        "name": "Needs release note",
        "color": "d2db6d"
      }
    },
    {
      "event": "commented",
      "id": 2095761769,
      "node_id": "IC_kwDOABII58586slp",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2095761769",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-06T11:08:46Z",
      "updated_at": "2024-05-06T11:08:46Z",
      "author_association": "MEMBER",
      "body": "Concept ACK",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2095761769",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12714178084,
      "node_id": "HRFPE_lADOABII586H4P0UzwAAAAL10vYk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12714178084",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "e948d4df9ff04e49ecec8452281e1467a196c9c6",
      "commit_url": "https://api.github.com/repos/laanwj/bitcoin/commits/e948d4df9ff04e49ecec8452281e1467a196c9c6",
      "created_at": "2024-05-06T12:14:40Z"
    },
    {
      "event": "commented",
      "id": 2096485412,
      "node_id": "IC_kwDOABII58589dQk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2096485412",
      "actor": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-06T16:49:54Z",
      "updated_at": "2024-05-06T17:25:26Z",
      "author_association": "MEMBER",
      "body": "Whoa :)\r\n\r\n(Concept ACK)",
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2096485412",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "reviewed",
      "id": 2040718091,
      "node_id": "PRR_kwDOABII5855ouML",
      "url": null,
      "actor": null,
      "commit_id": "e7cc02b996fc9f6ae587bcffe1605d9a20c2cc73",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "RFC6887 appendix A describes how a router that supports NAP-PMP but not PCP, will return `UNSUPP_VERSION`. A log message could encourage users to try `-upnp` instead (if not already enabled). Or upgrade their ancient router firmware :-)\r\n\r\nGot distracted during review, will continue later. I'll look into how we can preserve a previously selected NatPMP checkbox in the GUI.",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#pullrequestreview-2040718091",
      "submitted_at": "2024-05-06T16:51:45Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
    },
    {
      "event": "commented",
      "id": 2096670310,
      "node_id": "IC_kwDOABII5858-KZm",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2096670310",
      "actor": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-06T18:37:14Z",
      "updated_at": "2024-05-06T18:37:14Z",
      "author_association": "MEMBER",
      "body": "Regarding the custom lib/self-impl discussion in #30005: \r\nTaking a quick look at the implementation here, I think it's simple enough for us to maintain ourselves. If a nice canonical lib ever emerges we could always jump to it, as there are only a few basic functions and presumably we could probably switch them out close to 1:1.\r\n\r\nThat said, it is a little rough to review as\r\n- It needs to be compared to the letter of the spec, with the assumption that @laanwj is evil or has mis-implemented (I doubt that :)\r\n- It needs to be very defensive, though the attack surface seems quite minimal\r\n- It needs to be aware of real-world violators/benders/extenders of the spec (if any? I have no idea.)\r\n\r\nBut it seems worth the effort to me.",
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2096670310",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "mentioned",
      "id": 12718907040,
      "node_id": "MEE_lADOABII586H4P0UzwAAAAL2Gx6g",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12718907040",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-06T18:37:15Z"
    },
    {
      "event": "subscribed",
      "id": 12718907071,
      "node_id": "SE_lADOABII586H4P0UzwAAAAL2Gx6_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12718907071",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-06T18:37:15Z"
    },
    {
      "event": "labeled",
      "id": 12723051091,
      "node_id": "LE_lADOABII586H4P0UzwAAAAL2WlpT",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12723051091",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-07T04:16:58Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12725837606,
      "node_id": "HRFPE_lADOABII586H4P0UzwAAAAL2hN8m",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12725837606",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "b06edec229d5cfc8d0d1a19bd723852e6bcfd9d9",
      "commit_url": "https://api.github.com/repos/laanwj/bitcoin/commits/b06edec229d5cfc8d0d1a19bd723852e6bcfd9d9",
      "created_at": "2024-05-07T08:57:08Z"
    },
    {
      "event": "commented",
      "id": 2097797401,
      "node_id": "IC_kwDOABII5859CdkZ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2097797401",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-07T08:59:20Z",
      "updated_at": "2024-05-07T08:59:20Z",
      "author_association": "MEMBER",
      "body": "Rebased for #29984",
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2097797401",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "commented",
      "id": 2097968387,
      "node_id": "IC_kwDOABII5859DHUD",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2097968387",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-07T10:18:35Z",
      "updated_at": "2024-05-07T10:28:09Z",
      "author_association": "MEMBER",
      "body": "> That said, it is a little rough to review as\r\n>  It needs to be compared to the letter of the spec, with the assumption that @laanwj is evil or has mis-implemented (I doubt that :)\r\n\r\nIf you're more comfortable comparing it against another implementation there's:\r\n- A kinda haphazard windows implementation here: https://github.com/moonlight-stream/GS-IPv6-Forwarder/blob/master/GSv6Fwd/pcp.cpp\r\n- Miniupnpd's pcp server implementation https://github.com/miniupnp/miniupnp/blob/master/miniupnpd/pcpserver.c\r\n\r\n> It needs to be aware of real-world violators/benders/extenders of the spec (if any? I have no idea.)\r\n\r\nMiniupnpd's is, likely, the most common server implementation in the wild. It's been tested against that. i'm hoping people will test this on various routers and conditions, there will be inevitable edge cases to iron out.\r\n\r\n> If a nice canonical lib ever emerges we could always jump to it\r\n\r\nMaybe, but at some point there's not much difference between implementing a simple request/reply protocol and using a library. At least the RFC is unambigiously documented, which can't be said of many FOSS ABI's. Also, @fanquake (and @gmaxwell in the past) has been hoping for a solution that doesn't introduce a library dependency.",
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2097968387",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "mentioned",
      "id": 12726955693,
      "node_id": "MEE_lADOABII586H4P0UzwAAAAL2le6t",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12726955693",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-07T10:18:37Z"
    },
    {
      "event": "subscribed",
      "id": 12726955727,
      "node_id": "SE_lADOABII586H4P0UzwAAAAL2le7P",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12726955727",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-07T10:18:37Z"
    },
    {
      "event": "mentioned",
      "id": 12726955770,
      "node_id": "MEE_lADOABII586H4P0UzwAAAAL2le76",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12726955770",
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-07T10:18:37Z"
    },
    {
      "event": "subscribed",
      "id": 12726955813,
      "node_id": "SE_lADOABII586H4P0UzwAAAAL2le8l",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12726955813",
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-07T10:18:37Z"
    },
    {
      "event": "mentioned",
      "id": 12727112562,
      "node_id": "MEE_lADOABII586H4P0UzwAAAAL2mFNy",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12727112562",
      "actor": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-07T10:26:22Z"
    },
    {
      "event": "subscribed",
      "id": 12727112583,
      "node_id": "SE_lADOABII586H4P0UzwAAAAL2mFOH",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12727112583",
      "actor": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-07T10:26:22Z"
    },
    {
      "event": "unlabeled",
      "id": 12727171507,
      "node_id": "UNLE_lADOABII586H4P0UzwAAAAL2mTmz",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12727171507",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-07T10:30:00Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 2043665469,
      "node_id": "PRR_kwDOABII5855z9w9",
      "url": null,
      "actor": null,
      "commit_id": "fe53862fd4dca2ce7d3208847ed9e917c30ccb27",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "davidgumberg",
        "id": 2257631,
        "node_id": "MDQ6VXNlcjIyNTc2MzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2257631?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/davidgumberg",
        "html_url": "https://github.com/davidgumberg",
        "followers_url": "https://api.github.com/users/davidgumberg/followers",
        "following_url": "https://api.github.com/users/davidgumberg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/davidgumberg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/davidgumberg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/davidgumberg/subscriptions",
        "organizations_url": "https://api.github.com/users/davidgumberg/orgs",
        "repos_url": "https://api.github.com/users/davidgumberg/repos",
        "events_url": "https://api.github.com/users/davidgumberg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/davidgumberg/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#pullrequestreview-2043665469",
      "submitted_at": "2024-05-07T16:25:33Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
    },
    {
      "event": "commented",
      "id": 2100841942,
      "node_id": "IC_kwDOABII5859OE3W",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2100841942",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-08T15:26:35Z",
      "updated_at": "2024-05-08T15:26:35Z",
      "author_association": "MEMBER",
      "body": "Would prefer this in two steps (add PCP, then remove NAT-PMP)",
      "user": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2100841942",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "commented",
      "id": 2102107669,
      "node_id": "IC_kwDOABII5859S54V",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2102107669",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-09T07:25:43Z",
      "updated_at": "2024-05-29T11:11:52Z",
      "author_association": "MEMBER",
      "body": "> Would prefer this in two steps (add PCP, then remove NAT-PMP)\r\n\r\n~~i'm not planning to do this, the build system commits are already set up this way, but doing it throughout would involve adding another setting in Qt just to remove it later. Same for adding a third mechanism in `portmap.cpp`.~~ Agree with @sjors that having a forest of different port mapping settings is confusing to the user.\r\n\r\nEdit: no longer relevant now that this implements PCP with NAT-PMP fallaback.",
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2102107669",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "mentioned",
      "id": 12753405161,
      "node_id": "MEE_lADOABII586H4P0UzwAAAAL4KYTp",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12753405161",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-09T07:25:45Z"
    },
    {
      "event": "subscribed",
      "id": 12753405171,
      "node_id": "SE_lADOABII586H4P0UzwAAAAL4KYTz",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12753405171",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-09T07:25:45Z"
    },
    {
      "event": "reviewed",
      "id": 2047432934,
      "node_id": "PRR_kwDOABII5856CVjm",
      "url": null,
      "actor": null,
      "commit_id": "b06edec229d5cfc8d0d1a19bd723852e6bcfd9d9",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Tested on Ubuntu 24.04 I'm getting in bound via IPv4 and IPv6.\r\n\r\nWhen a GUI user previously had NAT-PMP selected there would be a `\"natpmp\": true` field in `settings.json`.\r\n\r\nWe need to rename this to `\"tcp\"` in order for the box to remain checked.\r\n\r\nMaybe @ryanofsky has an idea how to do this elegantly?\r\n\r\nA little hack that works is to put the following at the end of `ReadSettings()` in `settings.cpp`: \r\n\r\n```cpp\r\n    // Migrate settings:\r\n    if (values.contains(\"natpmp\")) {\r\n        auto el = values.extract(\"natpmp\");\r\n        el.key() = \"pcp\";\r\n        values.insert(std::move(el));\r\n    }\r\n```\r\n\r\nA bit nicer would be to have a `MigrateSettingsFile()` that's called between `ReadSettingsFile` and `WriteSettingsFile` in `init.cpp`.\r\n\r\n(not to be confused with `OptionsModel::checkAndMigrate()` which is called _before_ settings.json is read)\r\n\r\n---\r\n\r\nMaybe you can split `src/util/netif.h` off into a separate PR, along with b06edec229d5cfc8d0d1a19bd723852e6bcfd9d9.",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#pullrequestreview-2047432934",
      "submitted_at": "2024-05-09T09:56:04Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
    },
    {
      "event": "commented",
      "id": 2102707649,
      "node_id": "IC_kwDOABII5859VMXB",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2102707649",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-09T13:53:04Z",
      "updated_at": "2024-05-09T13:53:04Z",
      "author_association": "MEMBER",
      "body": "In terms of which IPv6 address to use, my understanding is this:\r\n\r\n1. In the olden days the IPv6 address contained part of the MAC address. This ensured uniqueness, but was bad for mobile device privacy; no matter where you went, part of your IP address was constant. Such addresses always (?) contain `0xfffe`. See https://datatracker.ietf.org/doc/html/rfc7707\r\n2. A new standard was introduced that uses a hash of both the MAC address and the prefix, ensuring it's stable if you stay on the same network, but changes when you move. See https://datatracker.ietf.org/doc/html/rfc7217#page-19\r\n3. There's also temporary addresses, which are rotated every couple of hours. See https://datatracker.ietf.org/doc/html/rfc8981\r\n\r\nIf we were able to tell which one one is which, then I think we should pick only one, in order of preference: (2), (3), (1). This reflects our desire to actually get inbound connections, even after a shutdown, while at the same time not doxxing ourselves when on the move (mainly for laptops, perhaps mobile in the future).\r\n\r\nWe can easily detect type (1) by looking for `0xfffe` at the right position (and then least prefer it).\r\n\r\nI believe you can detect (2) by looking for `IFA_F_STABLE_PRIVACY` in `flags` of the `inet6_ifaddr` struct. It seems `getifaddrs` doesn't have access to that. Neither does `/proc/net/if_inet6` since https://patchwork.ozlabs.org/project/netdev/patch/1386680189-7852-1-git-send-email-jiri@resnulli.us/\r\n\r\nAfaik there's also no guarantee about the order of results.\r\n\r\nSo maybe we should just pick one at random rather than announce all three. This also seems orthogonal to PCP.",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2102707649",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "reviewed",
      "id": 2048184349,
      "node_id": "PRR_kwDOABII5856FNAd",
      "url": null,
      "actor": null,
      "commit_id": "b06edec229d5cfc8d0d1a19bd723852e6bcfd9d9",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Regarding gateway discovery on macOS and Windows, the NatPMP C code is probably as good a place to start as any: https://github.com/miniupnp/libnatpmp/blob/master/getgateway.c\r\n\r\nI tested that `-natpmp` works (before this PR) on macOS 14.4.1.\r\n\r\nYou already implemented the `USE_PROC_NET_ROUTE` approach, which unfortunately is the shortest of them.\r\n\r\nHere's another one: https://github.com/libpcp/pcp/blob/master/libpcp/src/net/gateway.c\r\n\r\nLife would be so much easier if RFC6887 had allowed you to send the request to some random destination on the internet and just have the router intercept it (with Hop Limit 1 for privacy).\r\n\r\nOne creative cross-platform way to find the default gateway is, like `traceroute`, to send an ICMP(v6) message towards a random IPv4/6 address (via TCP), with Hop Limit set to 1, wait for the `Destination Unreachable Message` response and get the origin IP. https://datatracker.ietf.org/doc/html/rfc792\r\n\r\nIf PCP servers announced themselves via DNS-Based Service Discovery [rfc6763](https://www.rfc-editor.org/rfc/rfc6763.html) that would also make things easier. But waiting for an amendment of / followup to rfc792 and all routers to implement it ... would take a while. And then you need support _that_ protocol (mostly fetching and parsing DNS TXT records).",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#pullrequestreview-2048184349",
      "submitted_at": "2024-05-09T15:45:32Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
    },
    {
      "event": "labeled",
      "id": 12814729426,
      "node_id": "LE_lADOABII586H4P0UzwAAAAL70UDS",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12814729426",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-15T10:05:44Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2112341321,
      "node_id": "IC_kwDOABII585958VJ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2112341321",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-15T12:00:38Z",
      "updated_at": "2024-05-15T12:02:13Z",
      "author_association": "MEMBER",
      "body": "Thanks!\r\n\r\nOn Windows (Vista and higher, which is all we care about) getting the default gateway is straightforward, there's `GetBestRoute2` that does all the work. It's part of netioapi which we already need for interface enumeration. MacOS's sysctl is a bit uglier.\r\n\r\n> If PCP servers announced themselves via DNS-Based Service Discovery [rfc6763](https://www.rfc-editor.org/rfc/rfc6763.html) that would also make things easier.\r\n\r\ni don't think it really would, we'd need some special library for DNS access, getting TXT records isn't built into libc.\r\n\r\n> One creative cross-platform way to find the default gateway is, like traceroute, to send an ICMP(v6) message towards a random IPv4/6 address (via TCP), with Hop Limit set to 1, wait for the Destination Unreachable Message response and get the origin IP. \r\n\r\nIt's a clever idea, but sending/receiving ICMP needs raw socket privileges on many operating systems.",
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2112341321",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "commented",
      "id": 2114203144,
      "node_id": "IC_kwDOABII585-BC4I",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2114203144",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-16T06:56:01Z",
      "updated_at": "2024-05-16T06:56:01Z",
      "author_association": "MEMBER",
      "body": "> Maybe you can split src/util/netif.h off into a separate PR, along with https://github.com/bitcoin/bitcoin/commit/b06edec229d5cfc8d0d1a19bd723852e6bcfd9d9.\r\n\r\nSure, could do that.\r\n\r\n> So maybe we should just pick one at random rather than announce all three. This also seems orthogonal to PCP.\r\n\r\nThanks, that's interesting.\r\n\r\nOne problem is that routers might fail to pinhole some of the addresses. For example, Fritz!Box refuses to open ports on temporary privacy ones, which aren't a distinguishable range or type (on purpose). Might end up having no open port at all, or only for a temporary address lifetime. So for this PR, i prefer to keep the \"announce all publicly routable\" that is the current `Discover()` behavior for now.\r\n\r\nFine with discussing changes to IPv6 address choosing behavior later, as you say, it's orthogonal to adding PCP. ",
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2114203144",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12828534687,
      "node_id": "HRFPE_lADOABII586H4P0UzwAAAAL8o-ef",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12828534687",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "dafe1c5084ebf70c6ee1d6b7bfc75f7dfd987525",
      "commit_url": "https://api.github.com/repos/laanwj/bitcoin/commits/dafe1c5084ebf70c6ee1d6b7bfc75f7dfd987525",
      "created_at": "2024-05-16T07:43:21Z"
    },
    {
      "event": "commented",
      "id": 2114295253,
      "node_id": "IC_kwDOABII585-BZXV",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2114295253",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-16T07:43:23Z",
      "updated_at": "2024-05-16T08:22:07Z",
      "author_association": "MEMBER",
      "body": "- Rebased for a trivial merge conflict related to clang installation in `.github/workflows/ci.yml`.\r\n- Needed to change the use of `bitcoin_config.h` to make the lint pass.\r\n- Split `netif.h` and `netif.cpp` creation into a seperate commit (could be a seperate PR later).\r\n- Addressed a few comments.",
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2114295253",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12828761197,
      "node_id": "HRFPE_lADOABII586H4P0UzwAAAAL8p1xt",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12828761197",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "9e329fccca3ccaa21432a97e0d7eb9d119fcee06",
      "commit_url": "https://api.github.com/repos/laanwj/bitcoin/commits/9e329fccca3ccaa21432a97e0d7eb9d119fcee06",
      "created_at": "2024-05-16T07:59:52Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12828906304,
      "node_id": "HRFPE_lADOABII586H4P0UzwAAAAL8qZNA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12828906304",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "a1f1c4229d73883341d17e7d7183fc19a0a54a5a",
      "commit_url": "https://api.github.com/repos/laanwj/bitcoin/commits/a1f1c4229d73883341d17e7d7183fc19a0a54a5a",
      "created_at": "2024-05-16T08:10:46Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12829057599,
      "node_id": "HRFPE_lADOABII586H4P0UzwAAAAL8q-I_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12829057599",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "39933a53f3a3d29cfebd8252a9b4ddcb48d3965c",
      "commit_url": "https://api.github.com/repos/laanwj/bitcoin/commits/39933a53f3a3d29cfebd8252a9b4ddcb48d3965c",
      "created_at": "2024-05-16T08:19:47Z"
    },
    {
      "event": "unlabeled",
      "id": 12829976090,
      "node_id": "UNLE_lADOABII586H4P0UzwAAAAL8ueYa",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12829976090",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-16T09:18:32Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "unlabeled",
      "id": 12830308505,
      "node_id": "UNLE_lADOABII586H4P0UzwAAAAL8vviZ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12830308505",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-16T09:37:22Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 2061123015,
      "node_id": "PRR_kwDOABII58562j3H",
      "url": null,
      "actor": null,
      "commit_id": "39933a53f3a3d29cfebd8252a9b4ddcb48d3965c",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Concept ACK",
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#pullrequestreview-2061123015",
      "submitted_at": "2024-05-16T15:48:39Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
    },
    {
      "event": "commented",
      "id": 2115990626,
      "node_id": "IC_kwDOABII585-H3Ri",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2115990626",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-16T19:04:02Z",
      "updated_at": "2024-05-16T19:04:02Z",
      "author_association": "MEMBER",
      "body": "Replaced Linux-specific `QueryDefaultGateway` with @vasild's netlink implementation for Linux and FreeBSD. This may even generalize to more UNIX variants. \r\n\r\nWill tackle Windows next.",
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2115990626",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "mentioned",
      "id": 12838664718,
      "node_id": "MEE_lADOABII586H4P0UzwAAAAL9PnoO",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12838664718",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-16T19:04:04Z"
    },
    {
      "event": "subscribed",
      "id": 12838664735,
      "node_id": "SE_lADOABII586H4P0UzwAAAAL9Pnof",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12838664735",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-16T19:04:04Z"
    },
    {
      "event": "commented",
      "id": 2116158791,
      "node_id": "IC_kwDOABII585-IgVH",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2116158791",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-16T20:53:46Z",
      "updated_at": "2024-05-16T20:53:46Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\n\n🚧 At least one of the CI tasks failed. Make sure to run all tests locally, according to the\ndocumentation.\n\nPossibly this is due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/25069227736</sub>",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2116158791",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "labeled",
      "id": 12839755974,
      "node_id": "LE_lADOABII586H4P0UzwAAAAL9TyDG",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12839755974",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-16T20:53:46Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12844468124,
      "node_id": "HRFPE_lADOABII586H4P0UzwAAAAL9lwec",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12844468124",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "505e303f63bddaac493dc6104a0fa3858c68d633",
      "commit_url": "https://api.github.com/repos/laanwj/bitcoin/commits/505e303f63bddaac493dc6104a0fa3858c68d633",
      "created_at": "2024-05-17T08:15:35Z"
    },
    {
      "event": "commented",
      "id": 2117004469,
      "node_id": "IC_kwDOABII585-Luy1",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2117004469",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-17T08:18:39Z",
      "updated_at": "2024-05-23T08:30:27Z",
      "author_association": "MEMBER",
      "body": "Added a ~~(mostly untested for now)~~ Windows implementation of `QueryDefaultGateway`, if someone could test this it'd be very helpful. i will try in WINE later.\r\n\r\nEdit: Wine has only a stub for `GetBestRoute2`, so tested on Amazon EC2 actual windows, can't check PCP due to lack of a suitable router there, but IP address and default gateway finding works:\r\n```\r\n2024-05-17T14:17:48Z [net] pcp: gateway [IPv4]: 172.31.16.1\r\n2024-05-17T14:17:48Z [net] pcp: Requesting port mapping for addr 0.0.0.0 port 18444 from gateway 172.31.16.1                                                                                                                                   \r\n2024-05-17T14:17:48Z [net] pcp: Internal address after connect: 172.31.28.xxx                                                                             \r\n2024-05-17T14:17:51Z [net] pcp: gateway [IPv6]: fe80::58:f4ff:feca:xxxx%7\r\n2024-05-17T14:17:51Z [net] pcp: Requesting port mapping for addr 2600:1f1c:b80:8af0:e073:32d6:80b3:xxxx port 18444 from gateway fe80::58:f4ff:feca:xxxx%7\r\n2024-05-17T14:17:51Z [net] pcp: Internal address after connect: 2600:1f1c:b80:8af0:e073:32d6:80b3:xxxx\r\n```",
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2117004469",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12844612544,
      "node_id": "HRFPE_lADOABII586H4P0UzwAAAAL9mTvA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12844612544",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "841deffd44d7a78452deab39adadbf991249128a",
      "commit_url": "https://api.github.com/repos/laanwj/bitcoin/commits/841deffd44d7a78452deab39adadbf991249128a",
      "created_at": "2024-05-17T08:27:09Z"
    },
    {
      "event": "reviewed",
      "id": 2062857416,
      "node_id": "PRR_kwDOABII58569LTI",
      "url": null,
      "actor": null,
      "commit_id": "841deffd44d7a78452deab39adadbf991249128a",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#pullrequestreview-2062857416",
      "submitted_at": "2024-05-17T09:56:09Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
    },
    {
      "event": "commented",
      "id": 2117698802,
      "node_id": "IC_kwDOABII585-OYTy",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2117698802",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-17T14:11:05Z",
      "updated_at": "2024-05-17T14:11:05Z",
      "author_association": "MEMBER",
      "body": "Do we have any information about real-world deployment of PCP vs NAT-PMP? I see PCP dates from 2013, but do we know if it was adopted immediately (and/or, how many older routing devices are in common use)?\r\n\r\nRFC 6887 Appendix A explains how one can be compatible with both, though I don't know how much work it would be to implement.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2117698802",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12849248423,
      "node_id": "HRFPE_lADOABII586H4P0UzwAAAAL93_in",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12849248423",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "ff3566143a7ae3bf009b9e44e49221dd3e81ae3e",
      "commit_url": "https://api.github.com/repos/laanwj/bitcoin/commits/ff3566143a7ae3bf009b9e44e49221dd3e81ae3e",
      "created_at": "2024-05-17T14:19:10Z"
    },
    {
      "event": "commented",
      "id": 2117723501,
      "node_id": "IC_kwDOABII585-OeVt",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2117723501",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-17T14:22:21Z",
      "updated_at": "2024-05-23T08:30:01Z",
      "author_association": "MEMBER",
      "body": "i have no idea, also no idea how to get that information; to be honest if we can remotely avoid it, i'd prefer not to implement unnecessary compatibility stuff, with the added complexity that entails, this is already a lot to ask people to review as-is.\r\n\r\nEdit: but this is what we did.",
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2117723501",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "commented",
      "id": 2117736423,
      "node_id": "IC_kwDOABII585-Ohfn",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2117736423",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-17T14:28:45Z",
      "updated_at": "2024-05-17T14:28:45Z",
      "author_association": "MEMBER",
      "body": "@laanwj Yeah, fair enough. Absent any reports of \"doesn't work on my router while nat-pmp worked\" (which we're quite unlikely to get) there is really no way to assess that.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2117736423",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "mentioned",
      "id": 12849395247,
      "node_id": "MEE_lADOABII586H4P0UzwAAAAL94jYv",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12849395247",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-17T14:28:46Z"
    },
    {
      "event": "subscribed",
      "id": 12849395263,
      "node_id": "SE_lADOABII586H4P0UzwAAAAL94jY_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12849395263",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-17T14:28:46Z"
    },
    {
      "event": "commented",
      "id": 2117749832,
      "node_id": "IC_kwDOABII585-OkxI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2117749832",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-17T14:35:58Z",
      "updated_at": "2024-05-17T14:43:48Z",
      "author_association": "MEMBER",
      "body": "> Yeah, fair enough. Absent any reports of \"doesn't work on my router while nat-pmp worked\" (which we're quite unlikely to get) there is really no way to assess that.\r\n\r\nFor what it's worth, initial support for PCP was added in miniupnpd in [2013](https://github.com/miniupnp/miniupnp/commit/9e1ffd5cd9836053cfd83d95014c729ad0e36872). So the implementation wasn't lagging much behind the standard. Of course, not all routers use miniupnpd but it's extremely common.\r\n\r\nIf we get reports like that, we can decide to re-add NAT-PMP in a similar way as the current code., without reintroducing the dependency. It's not that different, it can share the gateway finding code, for one.",
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2117749832",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12850791054,
      "node_id": "HRFPE_lADOABII586H4P0UzwAAAAL994KO",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12850791054",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "86ca549b6820aa9c744442e793cc6da8b9c7e602",
      "commit_url": "https://api.github.com/repos/laanwj/bitcoin/commits/86ca549b6820aa9c744442e793cc6da8b9c7e602",
      "created_at": "2024-05-17T16:18:19Z"
    },
    {
      "event": "unlabeled",
      "id": 12852678828,
      "node_id": "UNLE_lADOABII586H4P0UzwAAAAL-FFCs",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12852678828",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-17T19:42:50Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "labeled",
      "id": 12852949423,
      "node_id": "LE_lADOABII586H4P0UzwAAAAL-GHGv",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12852949423",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-17T20:14:22Z",
      "label": {
        "name": "DrahtBot Guix build requested",
        "color": "bfd4f2"
      }
    },
    {
      "event": "unlabeled",
      "id": 12852979243,
      "node_id": "UNLE_lADOABII586H4P0UzwAAAAL-GOYr",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12852979243",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-17T20:17:37Z",
      "label": {
        "name": "DrahtBot Guix build requested",
        "color": "bfd4f2"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12852991459,
      "node_id": "HRFPE_lADOABII586H4P0UzwAAAAL-GRXj",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12852991459",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "f4e4da67c146a420e2960ba8fd43c545b464c89d",
      "commit_url": "https://api.github.com/repos/laanwj/bitcoin/commits/f4e4da67c146a420e2960ba8fd43c545b464c89d",
      "created_at": "2024-05-17T20:19:18Z"
    },
    {
      "event": "labeled",
      "id": 12854216312,
      "node_id": "LE_lADOABII586H4P0UzwAAAAL-K8Z4",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12854216312",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-18T00:54:53Z",
      "label": {
        "name": "DrahtBot Guix build requested",
        "color": "bfd4f2"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12855798667,
      "node_id": "HRFPE_lADOABII586H4P0UzwAAAAL-Q-uL",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12855798667",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "8e54924560cbf4a8313fac2525cc7bb43b02c8be",
      "commit_url": "https://api.github.com/repos/laanwj/bitcoin/commits/8e54924560cbf4a8313fac2525cc7bb43b02c8be",
      "created_at": "2024-05-18T12:14:21Z"
    },
    {
      "event": "commented",
      "id": 2118804764,
      "node_id": "IC_kwDOABII585-SmUc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2118804764",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-18T12:15:33Z",
      "updated_at": "2024-05-18T12:24:31Z",
      "author_association": "MEMBER",
      "body": "MacOS implementation of default gateway finding was added as well (i've tested it on MacOS Monterey, but could always use more, especially ARM macs would be interesting). This concludes the coverage of default gateway-finding on the major platforms.",
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2118804764",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12857839384,
      "node_id": "HRFPE_lADOABII586H4P0UzwAAAAL-Yw8Y",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12857839384",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "eecfb23c01199f8239b1cffb92b8beed4889a841",
      "commit_url": "https://api.github.com/repos/laanwj/bitcoin/commits/eecfb23c01199f8239b1cffb92b8beed4889a841",
      "created_at": "2024-05-19T08:07:48Z"
    },
    {
      "event": "commented",
      "id": 2119145090,
      "node_id": "IC_kwDOABII585-T5aC",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2119145090",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-19T08:09:16Z",
      "updated_at": "2024-05-19T08:10:35Z",
      "author_association": "MEMBER",
      "body": "Squashed all fixups into their logical commit. This should be in a good state for review now. The only TODO that is left to do is the Qt settings migration (so that if the user had enabled `natpmp`, `pcp` will now be enabled), i could use some help with that because i don't really know the new mechanism.",
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2119145090",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "labeled",
      "id": 12859208394,
      "node_id": "LE_lADOABII586H4P0UzwAAAAL-d_LK",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12859208394",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-19T20:45:24Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "unlabeled",
      "id": 12863069886,
      "node_id": "UNLE_lADOABII586H4P0UzwAAAAL-st6-",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12863069886",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-20T08:34:57Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2121393948,
      "node_id": "IC_kwDOABII585-cecc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2121393948",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-20T23:32:08Z",
      "updated_at": "2024-05-20T23:32:08Z",
      "author_association": "MEMBER",
      "body": "Trying this with `-pcp=1` on my home internet connection:\r\n```\r\n2024-05-20T23:28:41.625432Z [net] pcp: gateway [IPv4]: 192.168.1.1\r\n2024-05-20T23:28:41.625469Z [net] pcp: Requesting port mapping for addr 0.0.0.0 port 8333 from gateway 192.168.1.1\r\n2024-05-20T23:28:41.625529Z [net] pcp: Internal address after connect: 192.168.1.254\r\n2024-05-20T23:28:41.626388Z [net] pcp: Received response of 8 bytes: 008100010046cfb7\r\n2024-05-20T23:28:41.626404Z [net:warning] pcp: Response too small\r\n2024-05-20T23:28:42.627214Z [net] pcp: Timeout\r\n2024-05-20T23:28:42.627258Z [net] pcp: Retrying (1)\r\n2024-05-20T23:28:42.627870Z [net] pcp: Received response of 8 bytes: 008100010046cfb8\r\n2024-05-20T23:28:42.627901Z [net:warning] pcp: Response too small\r\n2024-05-20T23:28:43.628167Z [net] pcp: Timeout\r\n2024-05-20T23:28:43.628228Z [net] pcp: Retrying (2)\r\n2024-05-20T23:28:43.628976Z [net] pcp: Received response of 8 bytes: 008100010046cfb9\r\n2024-05-20T23:28:43.628999Z [net:warning] pcp: Response too small\r\n2024-05-20T23:28:44.629173Z [net] pcp: Timeout\r\n2024-05-20T23:28:44.629225Z [net] pcp: Giving up after 3 tries\r\n2024-05-20T23:28:44.632097Z [net] pcp: Could not determine IPv6 default gateway\r\n```\r\n",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2121393948",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "unsubscribed",
      "id": 12873229963,
      "node_id": "UE_lADOABII586H4P0UzwAAAAL_TeaL",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12873229963",
      "actor": {
        "login": "TriCellsTechnologies",
        "id": 50978938,
        "node_id": "MDQ6VXNlcjUwOTc4OTM4",
        "avatar_url": "https://avatars.githubusercontent.com/u/50978938?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TriCellsTechnologies",
        "html_url": "https://github.com/TriCellsTechnologies",
        "followers_url": "https://api.github.com/users/TriCellsTechnologies/followers",
        "following_url": "https://api.github.com/users/TriCellsTechnologies/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TriCellsTechnologies/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TriCellsTechnologies/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TriCellsTechnologies/subscriptions",
        "organizations_url": "https://api.github.com/users/TriCellsTechnologies/orgs",
        "repos_url": "https://api.github.com/users/TriCellsTechnologies/repos",
        "events_url": "https://api.github.com/users/TriCellsTechnologies/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TriCellsTechnologies/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-21T03:18:36Z"
    },
    {
      "event": "commented",
      "id": 2121977231,
      "node_id": "IC_kwDOABII585-es2P",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2121977231",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-21T07:47:40Z",
      "updated_at": "2024-05-21T07:47:40Z",
      "author_association": "MEMBER",
      "body": "> Trying this with -pcp=1 on my home internet connection:\r\n\r\nThanks for testing!\r\nThe received packet is not a valid PCP response (too short). But interpreting it as one anyway, the version byte is 0x00, result code is 0x01 (UNSUPP_VERSION). So you might have one of those routers that supports NAT-PMP only.",
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2121977231",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "commented",
      "id": 2122446973,
      "node_id": "IC_kwDOABII585-gfh9",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2122446973",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-21T11:44:12Z",
      "updated_at": "2024-05-21T11:44:12Z",
      "author_association": "MEMBER",
      "body": "@laanwj This is a router provided by Verizon (a large US ISP) in 2021.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2122446973",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "mentioned",
      "id": 12878911423,
      "node_id": "MEE_lADOABII586H4P0UzwAAAAL_pJe_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12878911423",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-21T11:44:14Z"
    },
    {
      "event": "subscribed",
      "id": 12878911446,
      "node_id": "SE_lADOABII586H4P0UzwAAAAL_pJfW",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12878911446",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-21T11:44:14Z"
    },
    {
      "event": "commented",
      "id": 2122543090,
      "node_id": "IC_kwDOABII585-g2_y",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2122543090",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-21T12:39:06Z",
      "updated_at": "2024-05-21T12:39:06Z",
      "author_association": "MEMBER",
      "body": "> @laanwj This is a router provided by Verizon (a large US ISP) in 2021.\r\n\r\nThat's curious, especially as NAT-PMP doesn't have any IPv6 support. i'm assuming you don't have any output for IPv6?",
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2122543090",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "mentioned",
      "id": 12879602909,
      "node_id": "MEE_lADOABII586H4P0UzwAAAAL_ryTd",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12879602909",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-21T12:39:08Z"
    },
    {
      "event": "subscribed",
      "id": 12879602924,
      "node_id": "SE_lADOABII586H4P0UzwAAAAL_ryTs",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12879602924",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-21T12:39:08Z"
    },
    {
      "event": "commented",
      "id": 2123920625,
      "node_id": "IC_kwDOABII585-mHTx",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2123920625",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-22T05:55:19Z",
      "updated_at": "2024-05-22T05:55:19Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--9cd9c72976c961c55c7acef8f6ba82cd-->\n### Guix builds (on x86_64) [untrusted test-only build, possibly unsafe, not for production use]\n\n| File | commit a786fd2041913d82ca90b561de309421bd24e41b<br>(master) | commit 7718a5c42f086b7c78000770a68170ff83c79038<br>(master and this pull) |\n|--|--|--|\n| SHA256SUMS.part | [`14f282b5bf7ebcd4...`](https://drahtbot.space/guix/bitcoin/bitcoin/a786fd2041913d82ca90b561de309421bd24e41b/SHA256SUMS.part) | [`bde34ea3844bc5a1...`](https://drahtbot.space/guix/bitcoin/bitcoin/7718a5c42f086b7c78000770a68170ff83c79038/SHA256SUMS.part) |\n| *-aarch64-linux-gnu-debug.tar.gz | [`b2364625629230d1...`](https://drahtbot.space/guix/bitcoin/bitcoin/a786fd2041913d82ca90b561de309421bd24e41b/bitcoin-a786fd204191-aarch64-linux-gnu-debug.tar.gz) | [`0ddcad066c06e5b5...`](https://drahtbot.space/guix/bitcoin/bitcoin/7718a5c42f086b7c78000770a68170ff83c79038/bitcoin-7718a5c42f08-aarch64-linux-gnu-debug.tar.gz) |\n| *-aarch64-linux-gnu.tar.gz | [`b05fc0561baa0966...`](https://drahtbot.space/guix/bitcoin/bitcoin/a786fd2041913d82ca90b561de309421bd24e41b/bitcoin-a786fd204191-aarch64-linux-gnu.tar.gz) | [`cefac02d8a5e9782...`](https://drahtbot.space/guix/bitcoin/bitcoin/7718a5c42f086b7c78000770a68170ff83c79038/bitcoin-7718a5c42f08-aarch64-linux-gnu.tar.gz) |\n| *-arm-linux-gnueabihf-debug.tar.gz | [`4545637daf89882c...`](https://drahtbot.space/guix/bitcoin/bitcoin/a786fd2041913d82ca90b561de309421bd24e41b/bitcoin-a786fd204191-arm-linux-gnueabihf-debug.tar.gz) | [`391b99ffa321ccd8...`](https://drahtbot.space/guix/bitcoin/bitcoin/7718a5c42f086b7c78000770a68170ff83c79038/bitcoin-7718a5c42f08-arm-linux-gnueabihf-debug.tar.gz) |\n| *-arm-linux-gnueabihf.tar.gz | [`27115f4c7e251175...`](https://drahtbot.space/guix/bitcoin/bitcoin/a786fd2041913d82ca90b561de309421bd24e41b/bitcoin-a786fd204191-arm-linux-gnueabihf.tar.gz) | [`46f4d4ec47bc6a05...`](https://drahtbot.space/guix/bitcoin/bitcoin/7718a5c42f086b7c78000770a68170ff83c79038/bitcoin-7718a5c42f08-arm-linux-gnueabihf.tar.gz) |\n| *-arm64-apple-darwin-unsigned.tar.gz | [`cf3950f9d05fb1c0...`](https://drahtbot.space/guix/bitcoin/bitcoin/a786fd2041913d82ca90b561de309421bd24e41b/bitcoin-a786fd204191-arm64-apple-darwin-unsigned.tar.gz) | [`436221ec28ee31a4...`](https://drahtbot.space/guix/bitcoin/bitcoin/7718a5c42f086b7c78000770a68170ff83c79038/bitcoin-7718a5c42f08-arm64-apple-darwin-unsigned.tar.gz) |\n| *-arm64-apple-darwin-unsigned.zip | [`b1c32e004722a3b4...`](https://drahtbot.space/guix/bitcoin/bitcoin/a786fd2041913d82ca90b561de309421bd24e41b/bitcoin-a786fd204191-arm64-apple-darwin-unsigned.zip) | [`8c509e13ed24a312...`](https://drahtbot.space/guix/bitcoin/bitcoin/7718a5c42f086b7c78000770a68170ff83c79038/bitcoin-7718a5c42f08-arm64-apple-darwin-unsigned.zip) |\n| *-arm64-apple-darwin.tar.gz | [`f09a38acef4b141b...`](https://drahtbot.space/guix/bitcoin/bitcoin/a786fd2041913d82ca90b561de309421bd24e41b/bitcoin-a786fd204191-arm64-apple-darwin.tar.gz) | [`b769aecd340fd798...`](https://drahtbot.space/guix/bitcoin/bitcoin/7718a5c42f086b7c78000770a68170ff83c79038/bitcoin-7718a5c42f08-arm64-apple-darwin.tar.gz) |\n| *-powerpc64-linux-gnu-debug.tar.gz | [`75cfe8d73120b00d...`](https://drahtbot.space/guix/bitcoin/bitcoin/a786fd2041913d82ca90b561de309421bd24e41b/bitcoin-a786fd204191-powerpc64-linux-gnu-debug.tar.gz) | [`feb0c0e88628b733...`](https://drahtbot.space/guix/bitcoin/bitcoin/7718a5c42f086b7c78000770a68170ff83c79038/bitcoin-7718a5c42f08-powerpc64-linux-gnu-debug.tar.gz) |\n| *-powerpc64-linux-gnu.tar.gz | [`d4f8c1296886fac4...`](https://drahtbot.space/guix/bitcoin/bitcoin/a786fd2041913d82ca90b561de309421bd24e41b/bitcoin-a786fd204191-powerpc64-linux-gnu.tar.gz) | [`2588795e780f8e6c...`](https://drahtbot.space/guix/bitcoin/bitcoin/7718a5c42f086b7c78000770a68170ff83c79038/bitcoin-7718a5c42f08-powerpc64-linux-gnu.tar.gz) |\n| *-riscv64-linux-gnu-debug.tar.gz | [`a8f56aee14e85f29...`](https://drahtbot.space/guix/bitcoin/bitcoin/a786fd2041913d82ca90b561de309421bd24e41b/bitcoin-a786fd204191-riscv64-linux-gnu-debug.tar.gz) | [`2d8829895961918e...`](https://drahtbot.space/guix/bitcoin/bitcoin/7718a5c42f086b7c78000770a68170ff83c79038/bitcoin-7718a5c42f08-riscv64-linux-gnu-debug.tar.gz) |\n| *-riscv64-linux-gnu.tar.gz | [`d8a4ae4295e6aa9f...`](https://drahtbot.space/guix/bitcoin/bitcoin/a786fd2041913d82ca90b561de309421bd24e41b/bitcoin-a786fd204191-riscv64-linux-gnu.tar.gz) | [`94779be512d355c9...`](https://drahtbot.space/guix/bitcoin/bitcoin/7718a5c42f086b7c78000770a68170ff83c79038/bitcoin-7718a5c42f08-riscv64-linux-gnu.tar.gz) |\n| *-x86_64-apple-darwin-unsigned.tar.gz | [`ff9ae232120c85f9...`](https://drahtbot.space/guix/bitcoin/bitcoin/a786fd2041913d82ca90b561de309421bd24e41b/bitcoin-a786fd204191-x86_64-apple-darwin-unsigned.tar.gz) | [`295c1ee6c4dc4526...`](https://drahtbot.space/guix/bitcoin/bitcoin/7718a5c42f086b7c78000770a68170ff83c79038/bitcoin-7718a5c42f08-x86_64-apple-darwin-unsigned.tar.gz) |\n| *-x86_64-apple-darwin-unsigned.zip | [`9917159a6fd59954...`](https://drahtbot.space/guix/bitcoin/bitcoin/a786fd2041913d82ca90b561de309421bd24e41b/bitcoin-a786fd204191-x86_64-apple-darwin-unsigned.zip) | [`9c28f7151880f1f4...`](https://drahtbot.space/guix/bitcoin/bitcoin/7718a5c42f086b7c78000770a68170ff83c79038/bitcoin-7718a5c42f08-x86_64-apple-darwin-unsigned.zip) |\n| *-x86_64-apple-darwin.tar.gz | [`61112274cace86c4...`](https://drahtbot.space/guix/bitcoin/bitcoin/a786fd2041913d82ca90b561de309421bd24e41b/bitcoin-a786fd204191-x86_64-apple-darwin.tar.gz) | [`27bf6a03f1abce44...`](https://drahtbot.space/guix/bitcoin/bitcoin/7718a5c42f086b7c78000770a68170ff83c79038/bitcoin-7718a5c42f08-x86_64-apple-darwin.tar.gz) |\n| *-x86_64-linux-gnu-debug.tar.gz | [`557d05bc585a2910...`](https://drahtbot.space/guix/bitcoin/bitcoin/a786fd2041913d82ca90b561de309421bd24e41b/bitcoin-a786fd204191-x86_64-linux-gnu-debug.tar.gz) | [`36db8ad04f331f36...`](https://drahtbot.space/guix/bitcoin/bitcoin/7718a5c42f086b7c78000770a68170ff83c79038/bitcoin-7718a5c42f08-x86_64-linux-gnu-debug.tar.gz) |\n| *-x86_64-linux-gnu.tar.gz | [`4928355769a494d7...`](https://drahtbot.space/guix/bitcoin/bitcoin/a786fd2041913d82ca90b561de309421bd24e41b/bitcoin-a786fd204191-x86_64-linux-gnu.tar.gz) | [`5365b31596e65699...`](https://drahtbot.space/guix/bitcoin/bitcoin/7718a5c42f086b7c78000770a68170ff83c79038/bitcoin-7718a5c42f08-x86_64-linux-gnu.tar.gz) |\n| *.tar.gz | [`49c2acd89613cf65...`](https://drahtbot.space/guix/bitcoin/bitcoin/a786fd2041913d82ca90b561de309421bd24e41b/bitcoin-a786fd204191.tar.gz) | [`51524f7ae096c36f...`](https://drahtbot.space/guix/bitcoin/bitcoin/7718a5c42f086b7c78000770a68170ff83c79038/bitcoin-7718a5c42f08.tar.gz) |\n| guix_build.log | [`88d5371b29f8bb75...`](https://drahtbot.space/guix/bitcoin/bitcoin/a786fd2041913d82ca90b561de309421bd24e41b/guix_build.log) | [`d18448a1f3d9cc20...`](https://drahtbot.space/guix/bitcoin/bitcoin/7718a5c42f086b7c78000770a68170ff83c79038/guix_build.log) |\n| guix_build.log.diff |  | [`3207cbd48d885913...`](https://drahtbot.space/guix/bitcoin/bitcoin/7718a5c42f086b7c78000770a68170ff83c79038/guix_build.log.diff) |\n\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2123920625",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "unlabeled",
      "id": 12888639046,
      "node_id": "UNLE_lADOABII586H4P0UzwAAAAMAOQZG",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12888639046",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-22T05:55:19Z",
      "label": {
        "name": "DrahtBot Guix build requested",
        "color": "bfd4f2"
      }
    },
    {
      "event": "commented",
      "id": 2124254747,
      "node_id": "IC_kwDOABII585-nY4b",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2124254747",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-22T09:04:57Z",
      "updated_at": "2024-05-23T08:29:27Z",
      "author_association": "MEMBER",
      "body": "> The only TODO that is left to do is the Qt settings migration \r\n\r\nAvoiding this complexity is another reason to add a NAT-PMP fallback, then we'd be right to keep the option named the same and only change the descriptions.\r\n\r\nEdit: done",
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2124254747",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "commented",
      "id": 2124488325,
      "node_id": "IC_kwDOABII585-oR6F",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2124488325",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-22T10:47:13Z",
      "updated_at": "2024-05-22T12:09:44Z",
      "author_association": "MEMBER",
      "body": "> Avoiding this complexity is another reason to add a NAT-PMP fallback, then we'd be right to keep the option named the same and only change the descriptions.\r\n\r\nIf you think such a fallback is easier than dealing with QT settings migration :-)\r\n\r\nWe can just sort them PCP, NAT-PMP, UPNP in the GUI. If we also add the word \"recommended\" to PCP, it should mitigate choice-paralysis. Then in the future we can add a little green dot to indicate that it actually works.\r\n\r\nI tested e6656f981019331db869e5bed1fcb5247bafbc3f  on Windows , (Intel) macOS and Linux.\r\n\r\nOn macOS 14.5 it opens IPv4 and IPv6 ports, which eventually leads to inbound connections (I used a non-8333 port so it takes a while).\r\n\r\nThe OPNsense status page only shows IPv4 mappings, not IPv6 hole punch, but the latter clearly works too.\r\n\r\nOn Windows IPv4 mapping works:\r\n\r\n```\r\n2024-05-22T11:54:07Z [net:info] pcp: Mapping successful: we got x.x.x.x:x for 1260 seconds.\r\n2024-05-22T11:54:07Z [net:info] pcp: ExternalIPv4Address:port = x.x.x.x:x\r\n2024-05-22T11:54:07Z AddLocal(x.x.x.x:x,3)\r\n```\r\n\r\nAnd it gets plenty of inbound IPv4 connections.\r\n\r\nIPv6 mapping failed - I think; the message itself isn't specific that this was IPv6:\r\n\r\n```\r\n2024-05-22T11:54:07Z [net:warning] pcp: Mapping failed with result NO_RESOURCES (code 8)\r\n2024-05-22T11:54:07Z [net:warning] pcp: Mapping failed with result NO_RESOURCES (code 8)\r\n2024-05-22T11:54:08Z [net:warning] pcp: Mapping failed with result NO_RESOURCES (code 8)\r\n```\r\n\r\nWhen I restarted the node I noticed that it didn't even try for IPv6 and that the AddLocal / Discover messages for IPv6 addresses happened _after_ the IPv4 mapping was successful. So maybe it needs to wait a bit? But then upon a third restart I got the same sequence of events, but this time it gave a `NO_RESOURCES` error again (with IPv4 working fine).\r\n\r\nOh and now I'm getting `NO_RESOURCES` on my Mac as well, so I guess I just upset the router.",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2124488325",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "commented",
      "id": 2124574440,
      "node_id": "IC_kwDOABII585-om7o",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2124574440",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-22T11:34:49Z",
      "updated_at": "2024-05-22T11:46:40Z",
      "author_association": "MEMBER",
      "body": "> If you think such a fallback is easier than dealing with QT settings migration :-)\r\n\r\nYes. It also avoids having to rename the command-line option. It would make the new code a drop-in replacement that also supports IPv6, no change for users.\r\n\r\nIt's a matter of handling UNSUPP_VERSION packets (the one @sipa gets), then re-trying through NAT-PMP, for IPv4. i'm already halfway implementing it.\r\n\r\n(see https://datatracker.ietf.org/doc/html/rfc6886#section-3.5 and https://datatracker.ietf.org/doc/html/rfc6887#appendix-A)",
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2124574440",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "mentioned",
      "id": 12893162712,
      "node_id": "MEE_lADOABII586H4P0UzwAAAAMAfgzY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12893162712",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-22T11:45:11Z"
    },
    {
      "event": "subscribed",
      "id": 12893162730,
      "node_id": "SE_lADOABII586H4P0UzwAAAAMAfgzq",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12893162730",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-22T11:45:11Z"
    },
    {
      "event": "commented",
      "id": 2124640155,
      "node_id": "IC_kwDOABII585-o2-b",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2124640155",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-22T12:11:37Z",
      "updated_at": "2024-05-22T12:22:36Z",
      "author_association": "MEMBER",
      "body": "Restarting the node with the same port seems to trigger the `NO_RESOURCES` error with IPv6. I guess that's because the previous \"lease\" is still valid. It worked fine on Windows once I picked a fresh port.\r\n\r\nDuring a clean shutdown, we should probably ask the gateway to delete the mapping :\r\n\r\n```\r\nRequested lifetime (in common header):  Requested lifetime of this\r\n      mapping, in seconds.  The value 0 indicates \"delete\".\r\n```\r\n\r\nUpdate: despite the `NO_RESOURCES` I still get inbound IPv6 connections, so we can also just ignore it, but then we don't know when to renew.",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2124640155",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "commented",
      "id": 2124663276,
      "node_id": "IC_kwDOABII585-o8ns",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2124663276",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-22T12:23:52Z",
      "updated_at": "2024-05-22T12:28:53Z",
      "author_association": "MEMBER",
      "body": "> During a clean shutdown, we should probably ask the gateway to delete the mapping :\r\n\r\ni wasn't sure about this! Yes, it would be cleaner, but also complicates the code (it would have to keep track of current mappings state). In normal use it's unlikely for a user to restart a node in such a small timespan, and having a node unconnectable for a few minutes isn't a big deal. The mappings aren't too long (20 min) and expire automatically, and it will re-try periodically until it gets one. So it's a problem that solves itself.",
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2124663276",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "commented",
      "id": 2124675374,
      "node_id": "IC_kwDOABII585-o_ku",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2124675374",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-22T12:30:28Z",
      "updated_at": "2024-05-22T12:32:21Z",
      "author_association": "MEMBER",
      "body": "If we auto-renew every 20 minutes then I guess that's fine. Maybe just add a comment somewhere that we _could_ explicitly delete the mapping upon shutdown.\r\n\r\nAs well as clarifying the log message for `NO_RESOURCES` with something like \"This is expected after a restart and should clear after N minutes.\".",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2124675374",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "reviewed",
      "id": 2071201793,
      "node_id": "PRR_kwDOABII5857dAgB",
      "url": null,
      "actor": null,
      "commit_id": "e6656f981019331db869e5bed1fcb5247bafbc3f",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#pullrequestreview-2071201793",
      "submitted_at": "2024-05-22T13:33:28Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
    },
    {
      "event": "reviewed",
      "id": 2071531696,
      "node_id": "PRR_kwDOABII5857eRCw",
      "url": null,
      "actor": null,
      "commit_id": "bebfafcf98d8ed1432407b7603991d54f7cc26c2",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#pullrequestreview-2071531696",
      "submitted_at": "2024-05-22T14:56:04Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12897178949,
      "node_id": "HRFPE_lADOABII586H4P0UzwAAAAMAu1VF",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12897178949",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "bd2cc38d8afb1c09dfc4a77f5195bf2a9e58ad90",
      "commit_url": "https://api.github.com/repos/laanwj/bitcoin/commits/bd2cc38d8afb1c09dfc4a77f5195bf2a9e58ad90",
      "created_at": "2024-05-22T16:14:37Z"
    },
    {
      "event": "renamed",
      "id": 12897186674,
      "node_id": "RTE_lADOABII586H4P0UzwAAAAMAu3Ny",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12897186674",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-22T16:15:02Z",
      "rename": {
        "from": "net: Replace libnatpmp with built-in PCP implementation",
        "to": "net: Replace libnatpmp with built-in PCP+NATPMP implementation"
      }
    },
    {
      "event": "commented",
      "id": 2125210478,
      "node_id": "IC_kwDOABII585-rCNu",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2125210478",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-22T16:21:40Z",
      "updated_at": "2024-05-22T16:49:48Z",
      "author_association": "MEMBER",
      "body": "Okay - added a NAT-PMP fallback and removed all user visible run-time option changes, except for mentioning PCP in documentation.",
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2125210478",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "reviewed",
      "id": 2071782134,
      "node_id": "PRR_kwDOABII5857fOL2",
      "url": null,
      "actor": null,
      "commit_id": "bd2cc38d8afb1c09dfc4a77f5195bf2a9e58ad90",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#pullrequestreview-2071782134",
      "submitted_at": "2024-05-22T16:30:11Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
    },
    {
      "event": "labeled",
      "id": 12897511994,
      "node_id": "LE_lADOABII586H4P0UzwAAAAMAwGo6",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12897511994",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-22T16:31:20Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2125242381,
      "node_id": "IC_kwDOABII585-rKAN",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2125242381",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-22T16:31:21Z",
      "updated_at": "2024-05-22T16:31:21Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\n\n🚧 At least one of the CI tasks failed. Make sure to run all tests locally, according to the\ndocumentation.\n\nPossibly this is due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/25289226001</sub>",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2125242381",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "reviewed",
      "id": 2071999619,
      "node_id": "PRR_kwDOABII5857gDSD",
      "url": null,
      "actor": null,
      "commit_id": "70a32f654dd74c4e2fedb0b79e27648d633acbd6",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Took a cursory look at the linux / bsd approach.",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#pullrequestreview-2071999619",
      "submitted_at": "2024-05-22T18:56:40Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12900467496,
      "node_id": "HRFPE_lADOABII586H4P0UzwAAAAMA7YMo",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12900467496",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "f5d8ffd467bba644b1fb855ef020197345953cf3",
      "commit_url": "https://api.github.com/repos/laanwj/bitcoin/commits/f5d8ffd467bba644b1fb855ef020197345953cf3",
      "created_at": "2024-05-22T20:44:58Z"
    },
    {
      "event": "unlabeled",
      "id": 12902339940,
      "node_id": "UNLE_lADOABII586H4P0UzwAAAAMBChVk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12902339940",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-23T01:42:09Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2126064090,
      "node_id": "IC_kwDOABII585-uSna",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2126064090",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-23T02:11:39Z",
      "updated_at": "2024-05-23T02:12:04Z",
      "author_association": "MEMBER",
      "body": "Success! My node is reachable publicly, without configuration.\r\n\r\n```\r\n2024-05-23T02:06:39.536932Z [net] pcp: gateway [IPv4]: 192.168.1.1\r\n2024-05-23T02:06:39.536973Z [net] pcp: Requesting port mapping for addr 0.0.0.0 port 8333 from gateway 192.168.1.1\r\n2024-05-23T02:06:39.537027Z [net] pcp: Internal address after connect: 192.168.1.254\r\n...\r\n2024-05-23T02:06:39.538066Z [net] pcp: Received response of 8 bytes: [...]\r\n2024-05-23T02:06:39.538101Z [net] pcp: Got unsupported version response, falling back to NAT-PMP\r\n2024-05-23T02:06:39.538118Z [net] natpmp: Requesting port mapping port 8333 from gateway 192.168.1.1\r\n2024-05-23T02:06:39.539006Z [net] natpmp: Received response of 12 bytes: [...]\r\n...\r\n2024-05-23T02:06:39.551712Z [net] natpmp: Received response of 16 bytes: [...]\r\n2024-05-23T02:06:39.551736Z [net:info] natpmp: Mapping successful: we got [...] for 1200 seconds.\r\n2024-05-23T02:06:39.551774Z [net:info] natpmp: ExternalIPv4Address:port = [...]\r\n2024-05-23T02:06:39.551787Z AddLocal([...],3)\r\n2024-05-23T02:06:39.551826Z [net] pcp: Could not determine IPv6 default gateway\r\n```\r\n(IP address scrubbed)",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2126064090",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "commented",
      "id": 2126357008,
      "node_id": "IC_kwDOABII585-vaIQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2126357008",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-23T06:49:45Z",
      "updated_at": "2024-05-23T06:49:45Z",
      "author_association": "MEMBER",
      "body": "> Success! My node is reachable publicly, without configuration.\r\n\r\nNice!!! Thanks for testing again.",
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2126357008",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "reviewed",
      "id": 2073273200,
      "node_id": "PRR_kwDOABII5857k6Nw",
      "url": null,
      "actor": null,
      "commit_id": "82b0bff51fedff2ce5e47cae1c75b9172766d8ef",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#pullrequestreview-2073273200",
      "submitted_at": "2024-05-23T08:36:01Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
    },
    {
      "event": "reviewed",
      "id": 2073411892,
      "node_id": "PRR_kwDOABII5857lcE0",
      "url": null,
      "actor": null,
      "commit_id": "82b0bff51fedff2ce5e47cae1c75b9172766d8ef",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#pullrequestreview-2073411892",
      "submitted_at": "2024-05-23T09:29:51Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
    },
    {
      "event": "reviewed",
      "id": 2073514261,
      "node_id": "PRR_kwDOABII5857l1EV",
      "url": null,
      "actor": null,
      "commit_id": "82b0bff51fedff2ce5e47cae1c75b9172766d8ef",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#pullrequestreview-2073514261",
      "submitted_at": "2024-05-23T10:17:19Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12908367122,
      "node_id": "HRFPE_lADOABII586H4P0UzwAAAAMBZg0S",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12908367122",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "721b70092cba7f589075f4a2040f9f97be05322b",
      "commit_url": "https://api.github.com/repos/laanwj/bitcoin/commits/721b70092cba7f589075f4a2040f9f97be05322b",
      "created_at": "2024-05-23T12:02:11Z"
    },
    {
      "event": "reviewed",
      "id": 2073809550,
      "node_id": "PRR_kwDOABII5857m9KO",
      "url": null,
      "actor": null,
      "commit_id": "89ac09777d4d60a331fe1c482d87ecdd1aeb01a0",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Finished macOS review of QueryDefaultGatewayImpl.",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#pullrequestreview-2073809550",
      "submitted_at": "2024-05-23T13:50:47Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
    },
    {
      "event": "labeled",
      "id": 12911083472,
      "node_id": "LE_lADOABII586H4P0UzwAAAAMBj3_Q",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12911083472",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-23T15:08:21Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2127381964,
      "node_id": "IC_kwDOABII585-zUXM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2127381964",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-23T15:08:22Z",
      "updated_at": "2024-05-23T15:08:22Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\n\n🚧 At least one of the CI tasks failed. Make sure to run all tests locally, according to the\ndocumentation.\n\nPossibly this is due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/25337033465</sub>",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2127381964",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "reviewed",
      "id": 2074328030,
      "node_id": "PRR_kwDOABII5857o7ve",
      "url": null,
      "actor": null,
      "commit_id": "82b1c25b9ca61f5b0382a5196e0ff7016b4d1429",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#pullrequestreview-2074328030",
      "submitted_at": "2024-05-23T15:25:54Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12914056207,
      "node_id": "HRFPE_lADOABII586H4P0UzwAAAAMBvNwP",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12914056207",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "71788566bf458dc6056407c1798481c256cdc784",
      "commit_url": "https://api.github.com/repos/laanwj/bitcoin/commits/71788566bf458dc6056407c1798481c256cdc784",
      "created_at": "2024-05-23T19:02:10Z"
    },
    {
      "event": "commented",
      "id": 2128880081,
      "node_id": "IC_kwDOABII585-5CHR",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2128880081",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T08:15:40Z",
      "updated_at": "2024-05-24T08:29:23Z",
      "author_association": "MEMBER",
      "body": "Ok, happy with `QueryDefaultGateway(Impl)` as of 9a265c6d75136991125730b8a6a901e95cfeb8f6, except for not compiling on BSD 13.2:\r\n\r\n```\r\nutil/netif.cpp:84:82: error: use of undeclared identifier 'typeof'; did you mean 'typeid'?\r\n    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\r\n```\r\n\r\nIt also throws a warning:\r\n\r\n```\r\nutil/netif.cpp:84:47: warning: comparison of integers of different signs: 'int' and 'size_t' (aka 'unsigned long') [-Wsign-compare]\r\n    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\r\n```\r\n\r\nFreeBSD clang version 14.0.5\r\n\r\nSo I guess that's not supposed to work, since clang 15.0 is the minimum.\r\n\r\n```\r\npkg install llvm15\r\n./configure CC=/usr/local/bin/clang15 CXX=/usr/local/bin/clang++15 MAKE=gmake\r\ngmake\r\n```\r\n\r\nThat still results in the same error and warning though.\r\n\r\n",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2128880081",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "commented",
      "id": 2129306509,
      "node_id": "IC_kwDOABII585-6qON",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2129306509",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T11:33:17Z",
      "updated_at": "2024-05-24T11:49:55Z",
      "author_association": "MEMBER",
      "body": "Do you know what's the minimum FreeBSD version it can be compiled on? Let's bump the version bound to that.\r\n\r\n> util/netif.cpp:84:82: error: use of undeclared identifier 'typeof'; did you mean 'typeid'?\r\n>    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\r\n\r\nIt is strange though. There isn't even a \"typeof\" on that line. It must be part of the system macro itself? In which case, why do they provide macros that don't work with their own compilers.\r\n\r\nEdit: googling for the issue, `typeof` is a GCC specific extension that's not available in C++. It should be using `__typeof__` instead. Unfortunately, it is not in our own code.",
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2129306509",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "commented",
      "id": 2129309096,
      "node_id": "IC_kwDOABII585-6q2o",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2129309096",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T11:34:53Z",
      "updated_at": "2024-05-24T11:34:53Z",
      "author_association": "MEMBER",
      "body": "> Do you know what's the minimum FreeBSD version it can be compiled on? Let's bump the version bound to that.\r\n\r\nI'll spin up some more recent VMs to test, probably next week though. ",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2129309096",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "commented",
      "id": 2129331327,
      "node_id": "IC_kwDOABII585-6wR_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2129331327",
      "actor": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T11:46:54Z",
      "updated_at": "2024-05-24T11:46:54Z",
      "author_association": "MEMBER",
      "body": "For testing, something like https://github.com/bitcoin/bitcoin/pull/30164 could be used",
      "user": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2129331327",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "reviewed",
      "id": 2076503238,
      "node_id": "PRR_kwDOABII5857xOzG",
      "url": null,
      "actor": null,
      "commit_id": "9a265c6d75136991125730b8a6a901e95cfeb8f6",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "`pcp.{h,cpp}` (mostly) look good to me as well, but I haven't tested the NAT-PMP fallback. As do the changes to `mapport.{h,cpp}`.\r\n\r\nNext on my review list is the remaining code that drops the old Nat-PMP dependency, but that's all a lot simpler.\r\n",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#pullrequestreview-2076503238",
      "submitted_at": "2024-05-24T12:10:06Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
    },
    {
      "event": "commented",
      "id": 2129421039,
      "node_id": "IC_kwDOABII585-7GLv",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2129421039",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T12:30:57Z",
      "updated_at": "2024-05-24T12:30:57Z",
      "author_association": "MEMBER",
      "body": "The first two commits of https://github.com/bitcoin/bitcoin/pull/26812 would make it possible to test and fuzz how this code interacts with a router.",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2129421039",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12927527825,
      "node_id": "HRFPE_lADOABII586H4P0UzwAAAAMCimuR",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12927527825",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "1cbbcba42cf1c050022a73cb02b9d385fa184f2e",
      "commit_url": "https://api.github.com/repos/laanwj/bitcoin/commits/1cbbcba42cf1c050022a73cb02b9d385fa184f2e",
      "created_at": "2024-05-24T16:52:16Z"
    },
    {
      "event": "commented",
      "id": 2130021361,
      "node_id": "IC_kwDOABII585-9Yvx",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2130021361",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T17:13:47Z",
      "updated_at": "2024-05-24T17:13:47Z",
      "author_association": "MEMBER",
      "body": "1cbbcba42cf1c050022a73cb02b9d385fa184f2e: squashed all fixups to clean up the list of commits, no other changes",
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2130021361",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "unlabeled",
      "id": 12928863130,
      "node_id": "UNLE_lADOABII586H4P0UzwAAAAMCnsua",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12928863130",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-24T19:25:31Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2131092539,
      "node_id": "IC_kwDOABII585_BeQ7",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2131092539",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-25T07:47:49Z",
      "updated_at": "2024-05-25T07:50:20Z",
      "author_association": "MEMBER",
      "body": "> The first two commits of https://github.com/bitcoin/bitcoin/pull/26812 would make it possible to test and fuzz how this code interacts with a router.\r\n\r\nSo ive been thinking about this, do we have a mockable way to do `std::optional<Sock> socket(int domain, int type, int protocol)`? i was thinking of passing in a `SocketFactory` (please don't kill me, this could be just a functor 😅 ). It's slightly nicer than passing in a pre-made `Sock` because it allows testing the \"create a socket of the right family\" logic.\r\n(also ping @vasild)",
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2131092539",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "mentioned",
      "id": 12931681061,
      "node_id": "MEE_lADOABII586H4P0UzwAAAAMCycsl",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12931681061",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-25T07:47:50Z"
    },
    {
      "event": "subscribed",
      "id": 12931681063,
      "node_id": "SE_lADOABII586H4P0UzwAAAAMCycsn",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12931681063",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-25T07:47:50Z"
    },
    {
      "event": "commented",
      "id": 2132952090,
      "node_id": "IC_kwDOABII585_IkQa",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2132952090",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-27T08:33:20Z",
      "updated_at": "2024-05-27T08:33:20Z",
      "author_association": "MEMBER",
      "body": "> Do you know what's the minimum FreeBSD version it can be compiled on? Let's bump the version bound to that.\r\n\r\nJust tried on 14.0 with its default clang 16 and I get the same error. So we should either find a workaround or disable FreeBSD for this feature and a TODO comment. I don't know how popular this is as a desktop distro?",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2132952090",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "commented",
      "id": 2133003388,
      "node_id": "IC_kwDOABII585_Iwx8",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2133003388",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-27T09:00:05Z",
      "updated_at": "2024-05-27T09:17:45Z",
      "author_association": "MEMBER",
      "body": "> Just tried on 14.0 with its default clang 16 and I get the same error. So we should either find a workaround or disable FreeBSD for this feature and a TODO comment. I don't know how popular this is as a desktop distro?\r\n\r\ni would feel bad disabling FreeBSD support after @vasild contributed the code for that, but if this gets close to merge and FreeBSD is still broken i'll remove it (added a TODO).\r\ni expect `#define typeof __typeof__` would go a long way to work around this error.",
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2133003388",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "mentioned",
      "id": 12942897234,
      "node_id": "MEE_lADOABII586H4P0UzwAAAAMDdPBS",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12942897234",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-27T09:00:07Z"
    },
    {
      "event": "subscribed",
      "id": 12942897247,
      "node_id": "SE_lADOABII586H4P0UzwAAAAMDdPBf",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12942897247",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-27T09:00:07Z"
    },
    {
      "event": "reviewed",
      "id": 2080398804,
      "node_id": "PRR_kwDOABII5858AF3U",
      "url": null,
      "actor": null,
      "commit_id": "97ae5d4eefe4a1f17c0742407875661c17654296",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Finished the rest of my code review and tested 97ae5d4eefe4 again on Intel macOS 14.5, Ubuntu 24.04 and Windows. \r\n\r\nI noticed that the renewal for IPv6 fails (at least on Ubuntu and macOS) with `NO_RESOURCES`. IPv4 renewal works fine. Ten minutes later it tries again and the mapping succeeds.\r\n\r\nIIUC OPNsense uses miniupnpd 2.3.1, which is two years behind but [at first glance](https://github.com/miniupnp/miniupnp/compare/miniupnpd_2_3_1...miniupnpd_2_3_6) I don't see any recent fixes related to renewals, nor any open issues.s\r\n\r\nOne possible explanation could be that the router doesn't implement the protocol correctly, in terms of when it allows renewal. If that's the case, it may be worth implementing the recommended retry intervals. We should also log the approximate time remaining so it's a bit easier to debug the router behavior.\r\n\r\n--- \r\n\r\nWindows decided to quarantine bitocin-qt.exe (built with guix). I haven't seen that before in earlier tests, so I wonder if it's related to this change.\r\n\r\n<img src=\"https://github.com/bitcoin/bitcoin/assets/10217/225483a9-d9c5-4d47-834f-1ca4b1590c8f\" width=\"400\" />\r\n\r\nThe timing suggests it happened 10 minutes after the ports were intially opened, so I'm guessing a renewal attempt triggered it, but I forgot to turn on more verbose logging.",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#pullrequestreview-2080398804",
      "submitted_at": "2024-05-27T10:14:08Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
    },
    {
      "event": "commented",
      "id": 2133203743,
      "node_id": "IC_kwDOABII585_Jhsf",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2133203743",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-27T10:45:09Z",
      "updated_at": "2024-05-27T10:48:18Z",
      "author_association": "MEMBER",
      "body": "> I noticed that the renewal for IPv6 fails (at least on Ubuntu and macOS) with NO_RESOURCES. IPv4 renewal works fine. Ten minutes later it tries again and the mapping succeeds.\r\n\r\nIs this after re-launching bitcoind? Mind that restarting will roll a new mapping nonce, which means that from the point of your router it's a new application trying to get the port, which will prevent it from making the mapping until the old mapping expires. But that should go away after one cycle and not happen again the next one, as the nonce is stored and reused for renewals (as is specified in the RFC).\r\n\r\ni doubt this has anything to do with specifiic intervals. If renewal is avoided while there is already a mapping *at all* then there will be holes in reachability, which is worse than some spurious errors.\r\n\r\n> Windows decided to quarantine bitocin-qt.exe (built with guix). I haven't seen that before in earlier tests, so I wonder if it's related to this change.\r\n\r\nPossible, but that would be strange, given that we're not communicating to any different ports than before. Were you building with libnatpmp before? (oh, a guix build, yes it will have libnatpmp enabled).\r\nThings like this make me so close to just closing this PR in frustration tbh.\r\n",
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2133203743",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "commented",
      "id": 2133212294,
      "node_id": "IC_kwDOABII585_JjyG",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2133212294",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-27T10:50:09Z",
      "updated_at": "2024-05-27T11:06:32Z",
      "author_association": "MEMBER",
      "body": "> Is this after re-launching bitcoind? \r\n\r\nNo, I hadn't run the node in a while. At startup it opens the port, only renewal fails. Leaving the node running, this seems to happen half the time, as you would expect: port is opened, renewal fails, mapping expires, so opening succeeds again, renewal fails, etc.\r\n\r\n> Were you building with libnatpmp before? \r\n\r\nNo, I had that disabled in the past. I'll see if I can trigger it again with more detailed logs. But you're right, it might be an existing issue.\r\n\r\n---\r\n\r\nI downloaded v27.0 and tried it on Windows, but NAT-PMP doesn't work at all there (`natpmp: Port mapping failed`). It tried turning the windows firewall off but that made no difference. It does on macOS (`[mapport] natpmp: Port mapping successful. External address = ...`).",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2133212294",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "commented",
      "id": 2133233029,
      "node_id": "IC_kwDOABII585_Jo2F",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2133233029",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-27T11:02:08Z",
      "updated_at": "2024-05-27T11:02:08Z",
      "author_association": "MEMBER",
      "body": "> No, I hadn't run the node in a while. At startup it opens the port, only renewal fails. Leaving the node running, this seems to happen half the time, as you would expect: port is opened, renewal fails, mapping expires, so opening succeeds again, renewal fails, etc.\r\n\r\nThis is the opposite from what's expected.\r\n\r\n- But it only happens for IPv6, not IPv4. i wonder if that's because IPv4 is the first mapping created? Maybe it doesn't like the same nonce being used for multiple different mappings existing at the same time?\r\nMaybe try putting the IPv6 block first and see if it reverses the issue? Or at least makes it succeed for the first IPv6 address.\r\n\r\n- Alternatively, maybe try generating a new nonce every call to `PCPRequestPortMap`. This violates the protocol but ... if it's implemented wrongly on the server this may trigger it to generate a fresh mapping. i dunno...\r\n",
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2133233029",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "commented",
      "id": 2133257542,
      "node_id": "IC_kwDOABII585_Ju1G",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2133257542",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-27T11:17:11Z",
      "updated_at": "2024-05-27T11:24:20Z",
      "author_association": "MEMBER",
      "body": "On macOS I recompiled with `PORT_MAPPING_REANNOUNCE_PERIOD` set to 5 minutes and IPv4 commented out. At startup it adds three mappings. After a few minutes at renewal it complains with `NO_RESOURCES`",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2133257542",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "commented",
      "id": 2133264508,
      "node_id": "IC_kwDOABII585_Jwh8",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2133264508",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-27T11:21:35Z",
      "updated_at": "2024-05-27T11:21:35Z",
      "author_association": "MEMBER",
      "body": "> After a few minutes at renewal it complains with NO_RESOURCES.\r\n\r\nDoes it complain for all three mappings?",
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2133264508",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "commented",
      "id": 2133270608,
      "node_id": "IC_kwDOABII585_JyBQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2133270608",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-27T11:25:17Z",
      "updated_at": "2024-05-27T11:25:17Z",
      "author_association": "MEMBER",
      "body": "Yes, for all three.\r\n\r\nI then recompiled and set the renewal interval at 6/8 - 7/8. Started the node again (using a fresh port). Same pattern: three mappings succeeed, at renewal all three complain about NO_RESOURCES. (And then a few minutes later they succesfully get a mapping again).",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2133270608",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "commented",
      "id": 2133279400,
      "node_id": "IC_kwDOABII585_J0Ko",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2133279400",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-27T11:30:36Z",
      "updated_at": "2024-05-27T11:48:01Z",
      "author_association": "MEMBER",
      "body": "Actually this might be an existing bug: https://github.com/miniupnp/miniupnp/commit/7bd0877b8fd9a1c1c59cdf426b4640b3cee2bf61\r\n\r\nI'll see if I can convince OPNsense to ship >= 2.3.6, tracking at https://github.com/opnsense/plugins/issues/4003.",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2133279400",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "commented",
      "id": 2133309242,
      "node_id": "IC_kwDOABII585_J7c6",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2133309242",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-27T11:48:20Z",
      "updated_at": "2024-05-28T14:58:43Z",
      "author_association": "MEMBER",
      "body": "That does look like an issue that would affect renewal, but i'm not sure it would cause this specific issue, if i understand correctly it'd bump the renewal timestamp so far it would live forever. It wouln't make it complain about the port being used. Unless it's an old mapping that sticks around. But that wouldn'e explain why it only happens on renewal.",
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2133309242",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "commented",
      "id": 2133341499,
      "node_id": "IC_kwDOABII585_KDU7",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2133341499",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-27T12:06:33Z",
      "updated_at": "2024-05-27T12:06:33Z",
      "author_association": "MEMBER",
      "body": "> generating a new nonce every time for every mapping\r\n\r\nThat doesn't seem like a good idea. IIUC the nonce is used to recognise the requesting application, and to distinguish a renew request from some other app trying to use the same port.",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2133341499",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "commented",
      "id": 2133347999,
      "node_id": "IC_kwDOABII585_KE6f",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2133347999",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-27T12:10:06Z",
      "updated_at": "2024-05-27T12:10:06Z",
      "author_association": "MEMBER",
      "body": "> That doesn't seem like a good idea. IIUC the nonce is used to recognise the requesting application, and to distinguish a renew request from some other app trying to use the same port.\r\n\r\nIt's not supposed to be a good idea, but i wonder if it works around the issue with your router, if they implemented the protocol wrongly. i honestly have no idea what could be the problem here i'm just guessing.",
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2133347999",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "commented",
      "id": 2133381489,
      "node_id": "IC_kwDOABII585_KNFx",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2133381489",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-27T12:29:07Z",
      "updated_at": "2024-05-27T16:54:45Z",
      "author_association": "MEMBER",
      "body": "I thought perhaps the issue was that miniupnpd checks whether at least half the lease time went by and would refuse if not. So then if the lease time was too far in the future, it wouldn't allow renewal.\r\n\r\nBut looking through the source code it doesn't appear to care about that. There's a few places that can trigger a `PCP_ERR_NO_RESOURCES` reply, but so far those don't offer an obvious explanation.\r\n\r\n---\r\n\r\nThe pinhole code is mostly seperate from port mappings. Depending on `pcp_msg_info->is_fw` it will call `CreatePCPMap_FW` for an IPv6 pinhole. My guess is this function doesn't recognise the renewal attempt as such, treats it as a new request and then fails. I need to figure out how to read the router log messages.\r\n\r\n---\r\n\r\nFigured out how to get verbose logging (https://github.com/opnsense/plugins/issues/4004).\r\n\r\nIt does log `updating pinhole to` before the failure, so it _does_ find the existing route and knows that it should update. The line after that log statement calls `upnp_update_inboundpinhole` and interprets any failure as `PCP_ERR_NO_RESOURCES`. There's only two ways that can fail:\r\n\r\n1. If `#if defined(USE_PF) || defined(USE_NETFILTER)` is false, because it'll return `-42; /* not implemented */`. But `upnp_find_inboundpinhole` has the same guard, so that can't be it.\r\n\r\n2. If `update_pinhole` fails, which can only fail if `get_pinhole` fails. That implies that the `uid` returned by `find_pinhole` is wrong.\r\n \r\nI'm probably still missing something... I should test if deleting an IPv6 pinhole does work.\r\n\r\n---\r\n\r\nDeleting a pinhole succeeds. The log message is wrong (`PCP: UDP port 8 mapping removed`), which is an unrelated bug https://github.com/miniupnp/miniupnp/issues/743.\r\n\r\nI also tried opening only a single pinhole, to rule out some race condition. But that doesn't make a difference.\r\n\r\n---\r\n\r\nAnyway, I'm fairly sure it's not a bug in this PR.",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2133381489",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "reviewed",
      "id": 2080835616,
      "node_id": "PRR_kwDOABII5858Bwgg",
      "url": null,
      "actor": null,
      "commit_id": "97ae5d4eefe4a1f17c0742407875661c17654296",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#pullrequestreview-2080835616",
      "submitted_at": "2024-05-27T12:38:16Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
    },
    {
      "event": "commented",
      "id": 2135121750,
      "node_id": "IC_kwDOABII585_Q19W",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2135121750",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-28T12:40:58Z",
      "updated_at": "2024-05-28T12:42:18Z",
      "author_association": "MEMBER",
      "body": "Thanks for investigating in detail.\r\nFWIW, i'm not seeing that problem on TurrisOS (openwrt) with miniupnpd 2.3.3. Renewals work fine, both with 20 minute and 5 minute reannounce period. Both for IPv4 and IPv6. So it's either something that was solved in the meantime, or something different in your networking situation.",
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2135121750",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "commented",
      "id": 2135196336,
      "node_id": "IC_kwDOABII585_RIKw",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2135196336",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-28T13:17:11Z",
      "updated_at": "2024-05-28T13:17:11Z",
      "author_association": "MEMBER",
      "body": "Both our setups are at miniupnpd 2.3.3; the plugin description incorrectly says 2.3.1: https://github.com/opnsense/plugins/issues/4003#issuecomment-2133421334\r\n\r\nSo perhaps there's a difference in how miniupnpd controls the router / firewall itself, which causes the renewal to fail on my end. This is above my pay grade...",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2135196336",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "commented",
      "id": 2135219680,
      "node_id": "IC_kwDOABII585_RN3g",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2135219680",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-28T13:27:45Z",
      "updated_at": "2024-05-28T13:58:40Z",
      "author_association": "MEMBER",
      "body": "i've been trying to build the package myself, and there's miniupnpd-nftables and miniupnpd-iptables, do you know which one you have? i see i have -iptables installed at the moment, it appears.\r\n\r\nEdit: i installed the -nftables variant and rebooted, and it's giving me `NO_RESOURCES` even on first rquest, for IPv4 and IPv6! Restored the -iptables variant and it worked again. No idea if it's the same issue of course. May just be a kernel issue.",
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2135219680",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "commented",
      "id": 2135407342,
      "node_id": "IC_kwDOABII585_R7ru",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2135407342",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-28T14:41:24Z",
      "updated_at": "2024-05-28T17:35:33Z",
      "author_association": "MEMBER",
      "body": "No idea. [OPNsense](https://opnsense.org/about/about-opnsense/) is built on FreeBSD and I think the plugin just relies on whatever miniupnpd comes with the OS:\r\n\r\n```\r\n# pkg info miniupnpd\r\nminiupnpd-2.3.3_3,1\r\nName           : miniupnpd\r\nVersion        : 2.3.3_3,1\r\nInstalled on   : Thu May  2 10:44:17 2024 CEST\r\nOrigin         : net/miniupnpd\r\nArchitecture   : FreeBSD:13:amd64\r\nPrefix         : /usr/local\r\nCategories     : net\r\nLicenses       : BSD3CLAUSE\r\nMaintainer     : squat@squat.no\r\nWWW            : http://miniupnp.free.fr/\r\nComment        : UPnP IGD implementation which uses pf\r\nOptions        :\r\n\tCHECK_PORTINUSE: on\r\n\tIPV6           : on\r\n\tLEASEFILE      : off\r\n\tUPNP_IGDV2     : off\r\n\tUPNP_STRICT    : off\r\nShared Libs required:\r\n\tlibssl.so.12\r\n\tlibpfctl.so.0\r\n\tlibcrypto.so.12\r\nAnnotations    :\r\n\tFreeBSD_version: 1302001\r\n\tcpe            : cpe:2.3:a:miniupnp_project:miniupnpd:2.3.3:::::freebsd13:x64:3\r\n\trepo_type      : binary\r\n\trepository     : OPNsense\r\nFlat size      : 160KiB\r\nDescription    :\r\nMini UPnPd is a lightweight implementation of a UPnP IGD daemon. This is\r\nsupposed to be run on your gateway machine to allow client systems to redirect\r\nports and punch holes in the firewall.\r\n```\r\n\r\n---\r\n\r\nI installed 2.3.6 from source and got the same `NO_RESOURCES` error upon IPv6 pinhole renewal. Tried 5fcf0c281fd4e3fa3f32114824c1dee8f78cca03 for good measure. Ditto fail.\r\n\r\n---\r\n\r\nUpdate: @laanwj ~figured it out~ pinned it down: https://github.com/miniupnp/miniupnp/issues/747",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2135407342",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "mentioned",
      "id": 12961158349,
      "node_id": "MEE_lADOABII586H4P0UzwAAAAMEi5TN",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12961158349",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-28T17:34:56Z"
    },
    {
      "event": "subscribed",
      "id": 12961158371,
      "node_id": "SE_lADOABII586H4P0UzwAAAAMEi5Tj",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12961158371",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-28T17:34:56Z"
    },
    {
      "event": "comment_deleted",
      "id": 12962810793,
      "node_id": "CDE_lADOABII586H4P0UzwAAAAMEpMup",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12962810793",
      "actor": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-28T20:22:09Z"
    },
    {
      "event": "reviewed",
      "id": 2085328315,
      "node_id": "PRR_kwDOABII5858S5W7",
      "url": null,
      "actor": null,
      "commit_id": "357ab7179d95635a86cb86bc2f498a62230b2b24",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#pullrequestreview-2085328315",
      "submitted_at": "2024-05-29T12:56:20Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
    },
    {
      "event": "commented",
      "id": 2138493184,
      "node_id": "IC_kwDOABII585_dtEA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2138493184",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-30T01:10:12Z",
      "updated_at": "2024-05-30T01:10:12Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\n\n🚧 At least one of the CI tasks failed. Make sure to run all tests locally, according to the\ndocumentation.\n\nPossibly this is due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/25552745115</sub>",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2138493184",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "labeled",
      "id": 12978734449,
      "node_id": "LE_lADOABII586H4P0UzwAAAAMFl8Vx",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12978734449",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-30T01:10:12Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2138880741,
      "node_id": "IC_kwDOABII585_fLrl",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2138880741",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-30T07:41:55Z",
      "updated_at": "2024-05-30T08:04:38Z",
      "author_association": "MEMBER",
      "body": "I was able to build b4535d48aed26c3b3f61c8839b041d076b02d132 on my BSD 13.2 VM (errors and warnings are gone).\r\n\r\nOpening ports fails, maybe because it's a VM, but \"Address family not supported by protocol family\" seems an odd error for that.\r\n\r\n```\r\n2024-05-23T01:58:47Z [net:error] socket(AF_NETLINK): Address family not supported by protocol family (47)\r\n2024-05-23T01:58:47Z [net] portmap: Could not determine IPv4 default gateway\r\n2024-05-23T01:58:47Z [net:error] socket(AF_NETLINK): Address family not supported by protocol family (47)\r\n2024-05-23T01:58:47Z addcon thread start\r\n2024-05-23T01:58:47Z [net] portmap: Could not determine IPv6 default gateway\r\n```\r\n\r\n---\r\n\r\nOn BSB 14.0 it seems to work fine:\r\n\r\n```\r\n2024-05-27T17:37:34Z mapport thread start\r\n2024-05-27T17:37:34Z [net] portmap: gateway [IPv4]: 10.0.2.2\r\n2024-05-27T17:37:34Z [net] pcp: Requesting port mapping for addr 0.0.0.0 port 38333 from gateway 10.0.2.2\r\n2024-05-27T17:37:34Z Bound to [::]:38333\r\n2024-05-27T17:37:34Z [net] pcp: Internal address after connect: 10.0.2.15\r\n2024-05-27T17:37:34Z Bound to 0.0.0.0:38333\r\n2024-05-27T17:37:35Z [net] pcp: Timeout\r\n2024-05-27T17:37:35Z [net] pcp: Retrying (1)\r\n2024-05-27T17:37:36Z [net] pcp: Timeout\r\n2024-05-27T17:37:36Z [net] pcp: Retrying (2)\r\n2024-05-27T17:37:37Z [net] pcp: Timeout\r\n2024-05-27T17:37:37Z [net] pcp: Giving up after 3 tries\r\n\r\n```\r\n\r\n(it doesn't actually get a mapping, but that's expected because VirtualBox doesn't come with PCP, afaik)",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2138880741",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "commented",
      "id": 2138887357,
      "node_id": "IC_kwDOABII585_fNS9",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2138887357",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-30T07:45:53Z",
      "updated_at": "2024-05-30T08:19:57Z",
      "author_association": "MEMBER",
      "body": "Thanks for testing. Sounds like AF_NETLINK is not actually supported on that kernel, even though the necessary stuff is in the headers.\r\n\r\n> On BSB 14.0 it seems to work fine:\r\n\r\nSo let's bump the minimum to FreeBSD 14.0 instead?\r\n\r\n> (it doesn't actually get a mapping, but that's expected because VirtualBox doesn't come with PCP, afaik)\r\n\r\nIt'd likely work if you set VirtualBox's VM networking to bridged instead of local NAT.\r\n",
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2138887357",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "commented",
      "id": 2139467569,
      "node_id": "IC_kwDOABII585_ha8x",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2139467569",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-30T12:39:33Z",
      "updated_at": "2024-05-30T12:39:33Z",
      "author_association": "MEMBER",
      "body": "With a bridged network it indeed works.\r\n\r\nAlso, as suggested by @vasild, doing `kldload /boot/kernel/netlink.ko` makes things work on FreeBSD 13.2.",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2139467569",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "mentioned",
      "id": 12985505958,
      "node_id": "MEE_lADOABII586H4P0UzwAAAAMF_xim",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12985505958",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-30T12:39:35Z"
    },
    {
      "event": "subscribed",
      "id": 12985505989,
      "node_id": "SE_lADOABII586H4P0UzwAAAAMF_xjF",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12985505989",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-30T12:39:35Z"
    },
    {
      "event": "unlabeled",
      "id": 12991810223,
      "node_id": "UNLE_lADOABII586H4P0UzwAAAAMGX0qv",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12991810223",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-30T21:03:03Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2142841652,
      "node_id": "IC_kwDOABII585_uSs0",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2142841652",
      "actor": {
        "login": "Self-Hosting-Group",
        "id": 155233284,
        "node_id": "U_kgDOCUCsBA",
        "avatar_url": "https://avatars.githubusercontent.com/u/155233284?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Self-Hosting-Group",
        "html_url": "https://github.com/Self-Hosting-Group",
        "followers_url": "https://api.github.com/users/Self-Hosting-Group/followers",
        "following_url": "https://api.github.com/users/Self-Hosting-Group/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Self-Hosting-Group/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Self-Hosting-Group/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Self-Hosting-Group/subscriptions",
        "organizations_url": "https://api.github.com/users/Self-Hosting-Group/orgs",
        "repos_url": "https://api.github.com/users/Self-Hosting-Group/repos",
        "events_url": "https://api.github.com/users/Self-Hosting-Group/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Self-Hosting-Group/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-31T19:10:26Z",
      "updated_at": "2024-05-31T19:10:26Z",
      "author_association": "NONE",
      "body": "Maybe too late or has been looked at. A PCP/NAT-PMP library https://github.com/libpcp/pcp",
      "user": {
        "login": "Self-Hosting-Group",
        "id": 155233284,
        "node_id": "U_kgDOCUCsBA",
        "avatar_url": "https://avatars.githubusercontent.com/u/155233284?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Self-Hosting-Group",
        "html_url": "https://github.com/Self-Hosting-Group",
        "followers_url": "https://api.github.com/users/Self-Hosting-Group/followers",
        "following_url": "https://api.github.com/users/Self-Hosting-Group/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Self-Hosting-Group/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Self-Hosting-Group/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Self-Hosting-Group/subscriptions",
        "organizations_url": "https://api.github.com/users/Self-Hosting-Group/orgs",
        "repos_url": "https://api.github.com/users/Self-Hosting-Group/repos",
        "events_url": "https://api.github.com/users/Self-Hosting-Group/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Self-Hosting-Group/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2142841652",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "commented",
      "id": 2143396412,
      "node_id": "IC_kwDOABII585_waI8",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2143396412",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-01T10:25:11Z",
      "updated_at": "2024-06-01T10:27:06Z",
      "author_association": "MEMBER",
      "body": "> Maybe too late or has been looked at. A PCP/NAT-PMP library https://github.com/libpcp/pcp\r\n\r\nYes, some revievers have been looking at it as reference/comparison.\r\n\r\nThis has been said before but: implementing a self-contained version of the RFCs here is intentional, we don't want to introduce a dependency on a third-party library. It shoudn't be needed for a straightforward fixed packet-based protocol. The intent is to have code that integrates with bitcoin core's frameworks for logging, networking and testing/fuzzing. At some point we want to be confident enough about it to enable it by default.\r\n",
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2143396412",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "commented",
      "id": 2159928038,
      "node_id": "IC_kwDOABII586AveLm",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2159928038",
      "actor": {
        "login": "Self-Hosting-Group",
        "id": 155233284,
        "node_id": "U_kgDOCUCsBA",
        "avatar_url": "https://avatars.githubusercontent.com/u/155233284?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Self-Hosting-Group",
        "html_url": "https://github.com/Self-Hosting-Group",
        "followers_url": "https://api.github.com/users/Self-Hosting-Group/followers",
        "following_url": "https://api.github.com/users/Self-Hosting-Group/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Self-Hosting-Group/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Self-Hosting-Group/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Self-Hosting-Group/subscriptions",
        "organizations_url": "https://api.github.com/users/Self-Hosting-Group/orgs",
        "repos_url": "https://api.github.com/users/Self-Hosting-Group/repos",
        "events_url": "https://api.github.com/users/Self-Hosting-Group/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Self-Hosting-Group/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-11T06:50:17Z",
      "updated_at": "2024-06-11T06:50:17Z",
      "author_association": "NONE",
      "body": "@laanwj Thank you for the explanation.",
      "user": {
        "login": "Self-Hosting-Group",
        "id": 155233284,
        "node_id": "U_kgDOCUCsBA",
        "avatar_url": "https://avatars.githubusercontent.com/u/155233284?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Self-Hosting-Group",
        "html_url": "https://github.com/Self-Hosting-Group",
        "followers_url": "https://api.github.com/users/Self-Hosting-Group/followers",
        "following_url": "https://api.github.com/users/Self-Hosting-Group/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Self-Hosting-Group/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Self-Hosting-Group/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Self-Hosting-Group/subscriptions",
        "organizations_url": "https://api.github.com/users/Self-Hosting-Group/orgs",
        "repos_url": "https://api.github.com/users/Self-Hosting-Group/repos",
        "events_url": "https://api.github.com/users/Self-Hosting-Group/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Self-Hosting-Group/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2159928038",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "mentioned",
      "id": 13111600284,
      "node_id": "MEE_lADOABII586H4P0UzwAAAAMNgySc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13111600284",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-11T06:50:18Z"
    },
    {
      "event": "subscribed",
      "id": 13111600305,
      "node_id": "SE_lADOABII586H4P0UzwAAAAMNgySx",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13111600305",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-11T06:50:19Z"
    },
    {
      "event": "labeled",
      "id": 13138031446,
      "node_id": "LE_lADOABII586H4P0UzwAAAAMPFnNW",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13138031446",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-12T22:28:39Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13169164837,
      "node_id": "HRFPE_lADOABII586H4P0UzwAAAAMQ8YIl",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13169164837",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "db8f6f0965d359f763071169642a642740218163",
      "commit_url": "https://api.github.com/repos/laanwj/bitcoin/commits/db8f6f0965d359f763071169642a642740218163",
      "created_at": "2024-06-15T13:31:30Z"
    },
    {
      "event": "commented",
      "id": 2169622121,
      "node_id": "IC_kwDOABII586BUc5p",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2169622121",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-15T13:32:25Z",
      "updated_at": "2024-06-15T14:15:02Z",
      "author_association": "MEMBER",
      "body": "Force push: rebased for small conflict in `src/Makefile.am`, collected fixup commits, added @vasild as co-author on the netif commit, no other changes.\r\n\r\nEdit: also had to change a `util::HasPrefix` to fix the build.",
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2169622121",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13169176889,
      "node_id": "HRFPE_lADOABII586H4P0UzwAAAAMQ8bE5",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13169176889",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "459f2c5492161001608ea7c247bcdba556fe001f",
      "commit_url": "https://api.github.com/repos/laanwj/bitcoin/commits/459f2c5492161001608ea7c247bcdba556fe001f",
      "created_at": "2024-06-15T13:34:55Z"
    },
    {
      "event": "mentioned",
      "id": 13169179108,
      "node_id": "MEE_lADOABII586H4P0UzwAAAAMQ8bnk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13169179108",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-15T13:35:30Z"
    },
    {
      "event": "subscribed",
      "id": 13169179112,
      "node_id": "SE_lADOABII586H4P0UzwAAAAMQ8bno",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13169179112",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-15T13:35:30Z"
    },
    {
      "event": "labeled",
      "id": 13169326840,
      "node_id": "LE_lADOABII586H4P0UzwAAAAMQ8_r4",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13169326840",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-15T14:10:16Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13169333241,
      "node_id": "HRFPE_lADOABII586H4P0UzwAAAAMQ9BP5",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13169333241",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "faacd264417bd7f3f08c5ff497458030b3a54fbc",
      "commit_url": "https://api.github.com/repos/laanwj/bitcoin/commits/faacd264417bd7f3f08c5ff497458030b3a54fbc",
      "created_at": "2024-06-15T14:14:15Z"
    },
    {
      "event": "unlabeled",
      "id": 13169626306,
      "node_id": "UNLE_lADOABII586H4P0UzwAAAAMQ-IzC",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13169626306",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-15T15:12:01Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "unlabeled",
      "id": 13169787931,
      "node_id": "UNLE_lADOABII586H4P0UzwAAAAMQ-wQb",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13169787931",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-15T15:40:23Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "comment_deleted",
      "id": 13171124502,
      "node_id": "CDE_lADOABII586H4P0UzwAAAAMRD2kW",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13171124502",
      "actor": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-15T19:03:48Z"
    },
    {
      "event": "reviewed",
      "id": 2122801091,
      "node_id": "PRR_kwDOABII585-h1_D",
      "url": null,
      "actor": null,
      "commit_id": "faacd264417bd7f3f08c5ff497458030b3a54fbc",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "tACK faacd264417bd7f3f08c5ff497458030b3a54fbc\r\n\r\nTested on Intel macOS 13.6.7, FreeBSD 13.2, Windows and Ubuntu 24.04.\r\n\r\nLetting Windows run a bit longer to see if its \"defender\" leaves us alone now.",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#pullrequestreview-2122801091",
      "submitted_at": "2024-06-17T14:18:05Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
    },
    {
      "event": "review_requested",
      "id": 13186642676,
      "node_id": "RRE_lADOABII586H4P0UzwAAAAMR_DL0",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13186642676",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-17T14:18:11Z",
      "requested_reviewer": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "review_requested",
      "id": 13186642868,
      "node_id": "RRE_lADOABII586H4P0UzwAAAAMR_DO0",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13186642868",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-17T14:18:12Z",
      "requested_reviewer": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "labeled",
      "id": 13202141967,
      "node_id": "LE_lADOABII586H4P0UzwAAAAMS6LMP",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13202141967",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-18T14:28:15Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "unlabeled",
      "id": 13205179059,
      "node_id": "UNLE_lADOABII586H4P0UzwAAAAMTFwqz",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13205179059",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-18T18:44:59Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 2126279596,
      "node_id": "PRR_kwDOABII585-vHOs",
      "url": null,
      "actor": null,
      "commit_id": "faacd264417bd7f3f08c5ff497458030b3a54fbc",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Just a quick look so far.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#pullrequestreview-2126279596",
      "submitted_at": "2024-06-18T19:49:29Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
    },
    {
      "event": "referenced",
      "id": 13232552275,
      "node_id": "REFE_lADOABII586H4P0UzwAAAAMUuLlT",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13232552275",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "a961ad1bebc54912b88d072abf22ab7d3cf46bf1",
      "commit_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a961ad1bebc54912b88d072abf22ab7d3cf46bf1",
      "created_at": "2024-06-20T17:45:05Z"
    },
    {
      "event": "reviewed",
      "id": 2132874534,
      "node_id": "PRR_kwDOABII585_IRUm",
      "url": null,
      "actor": null,
      "commit_id": "faacd264417bd7f3f08c5ff497458030b3a54fbc",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Posting review midway, up to 237792601fb911cf2e5abebc9226d63f4cd35cec (incl)",
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#pullrequestreview-2132874534",
      "submitted_at": "2024-06-21T16:39:14Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
    },
    {
      "event": "review_requested",
      "id": 13244868693,
      "node_id": "RRE_lADOABII586H4P0UzwAAAAMVdKhV",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13244868693",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-21T16:39:19Z",
      "requested_reviewer": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13270061425,
      "node_id": "HRFPE_lADOABII586H4P0UzwAAAAMW9RFx",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13270061425",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "4ac9beb9f1c4e7ae2bcc1ad2a7394f00229942b6",
      "commit_url": "https://api.github.com/repos/laanwj/bitcoin/commits/4ac9beb9f1c4e7ae2bcc1ad2a7394f00229942b6",
      "created_at": "2024-06-24T18:09:53Z"
    },
    {
      "event": "commented",
      "id": 2187135835,
      "node_id": "IC_kwDOABII586CXQtb",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2187135835",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-24T18:11:06Z",
      "updated_at": "2024-06-24T18:11:06Z",
      "author_association": "MEMBER",
      "body": "Force push: rebased to get `CreateSock()` from #30202.",
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2187135835",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13270095362,
      "node_id": "HRFPE_lADOABII586H4P0UzwAAAAMW9ZYC",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13270095362",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "2338718648e6b7b9eebafd6c9525fadbac9a0fcc",
      "commit_url": "https://api.github.com/repos/laanwj/bitcoin/commits/2338718648e6b7b9eebafd6c9525fadbac9a0fcc",
      "created_at": "2024-06-24T18:13:23Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13270360647,
      "node_id": "HRFPE_lADOABII586H4P0UzwAAAAMW-aJH",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13270360647",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "63cb827086fb69f9a4e9d15109fa3be4030dcc58",
      "commit_url": "https://api.github.com/repos/laanwj/bitcoin/commits/63cb827086fb69f9a4e9d15109fa3be4030dcc58",
      "created_at": "2024-06-24T18:40:37Z"
    },
    {
      "event": "labeled",
      "id": 13270361734,
      "node_id": "LE_lADOABII586H4P0UzwAAAAMW-aaG",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13270361734",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-24T18:40:43Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "unlabeled",
      "id": 13271572974,
      "node_id": "UNLE_lADOABII586H4P0UzwAAAAMXDCHu",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13271572974",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-24T20:48:53Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "comment_deleted",
      "id": 13271947475,
      "node_id": "CDE_lADOABII586H4P0UzwAAAAMXEdjT",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13271947475",
      "actor": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-24T21:25:11Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 13295749196,
      "node_id": "HRFPE_lADOABII586H4P0UzwAAAAMYfQhM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13295749196",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "23916f2a7717b463799207b4b81b5795f2e9d7e3",
      "commit_url": "https://api.github.com/repos/laanwj/bitcoin/commits/23916f2a7717b463799207b4b81b5795f2e9d7e3",
      "created_at": "2024-06-26T09:54:36Z"
    },
    {
      "event": "commented",
      "id": 2191932755,
      "node_id": "IC_kwDOABII586Cpj1T",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2191932755",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-06-26T14:59:39Z",
      "updated_at": "2024-06-26T14:59:39Z",
      "author_association": "MEMBER",
      "body": "Force push was to squash all fixups (no other changes).",
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2191932755",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "reviewed",
      "id": 2142210219,
      "node_id": "PRR_kwDOABII585_r4ir",
      "url": null,
      "actor": null,
      "commit_id": "23916f2a7717b463799207b4b81b5795f2e9d7e3",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#pullrequestreview-2142210219",
      "submitted_at": "2024-06-26T15:31:49Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
    },
    {
      "event": "reviewed",
      "id": 2141814858,
      "node_id": "PRR_kwDOABII585_qYBK",
      "url": null,
      "actor": null,
      "commit_id": "23916f2a7717b463799207b4b81b5795f2e9d7e3",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Approach ACK 23916f2a7717b463799207b4b81b5795f2e9d7e3",
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#pullrequestreview-2141814858",
      "submitted_at": "2024-06-28T15:24:45Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
    },
    {
      "event": "labeled",
      "id": 13415378642,
      "node_id": "LE_lADOABII586H4P0UzwAAAAMfnm7S",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13415378642",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-08T00:09:50Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2212634605,
      "node_id": "IC_kwDOABII586D4h_t",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2212634605",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-08T00:09:51Z",
      "updated_at": "2024-07-08T00:09:51Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\n\n🚧 At least one of the CI tasks failed. Make sure to run all tests locally, according to the\ndocumentation.\n\nPossibly this is due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/26699347768</sub>",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2212634605",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "commented",
      "id": 2213708169,
      "node_id": "IC_kwDOABII586D8oGJ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2213708169",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-08T11:09:04Z",
      "updated_at": "2024-07-08T11:09:37Z",
      "author_association": "MEMBER",
      "body": "Compared to faacd264417bd7f3f08c5ff497458030b3a54fbc I'm now (23916f2a7717b463799207b4b81b5795f2e9d7e3) getting \"Could not determine [IPv4/IPv6] default gateway\". The changes to `defined(__APPLE__)` in `netif.cpp` don't give me any immediate hint of what could explain this.",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2213708169",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "reviewed",
      "id": 2163132612,
      "node_id": "PRR_kwDOABII586A7sjE",
      "url": null,
      "actor": null,
      "commit_id": "9a067b5ac154154ec9008a0e8f2d8f03e994a589",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#pullrequestreview-2163132612",
      "submitted_at": "2024-07-08T12:19:20Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
    },
    {
      "event": "labeled",
      "id": 13644778219,
      "node_id": "LE_lADOABII586H4P0UzwAAAAMtSsrr",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13644778219",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-07-25T12:11:06Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "milestoned",
      "id": 13807706792,
      "node_id": "MIE_lADOABII586H4P0UzwAAAAM3AOKo",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13807706792",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-08T14:13:02Z",
      "milestone": {
        "title": "29.0"
      }
    },
    {
      "event": "commented",
      "id": 2275938528,
      "node_id": "IC_kwDOABII586HqBDg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2275938528",
      "actor": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-08T14:13:13Z",
      "updated_at": "2024-08-08T14:13:13Z",
      "author_association": "CONTRIBUTOR",
      "body": "Concept ACK",
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2275938528",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "commented",
      "id": 2312583122,
      "node_id": "IC_kwDOABII586J1zfS",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2312583122",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-27T13:34:53Z",
      "updated_at": "2024-08-27T17:00:13Z",
      "author_association": "MEMBER",
      "body": "i still intend to do this, but honestly i've kind of lost track of the scope. Can we first aim to fix the bugs here, then merge an implementation that works in the common case, and at least doesn't have more problems than the current `libnatpmp` implementation?\r\n\r\nThen later on we can make sure all edge cases with `bind`, `listenport`, routers assigning different ports, etc. are handled.\r\n\r\nEdit: had to rebase for some CI script changes",
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2312583122",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "commented",
      "id": 2312700483,
      "node_id": "IC_kwDOABII586J2QJD",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2312700483",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-27T14:16:05Z",
      "updated_at": "2024-08-27T14:16:05Z",
      "author_association": "MEMBER",
      "body": "@laanwj I suggest adding a \"Suggested Followups\" section to the PR description, where you can list known issues that can be punted.",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2312700483",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "mentioned",
      "id": 14029683877,
      "node_id": "MEE_lADOABII586H4P0UzwAAAANEO_yl",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14029683877",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-27T14:16:06Z"
    },
    {
      "event": "subscribed",
      "id": 14029683897,
      "node_id": "SE_lADOABII586H4P0UzwAAAANEO_y5",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14029683897",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-27T14:16:06Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 14031840700,
      "node_id": "HRFPE_lADOABII586H4P0UzwAAAANEXOW8",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14031840700",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "3db52bf4a9255538b8ef691a6c9a9edd9c273f84",
      "commit_url": "https://api.github.com/repos/laanwj/bitcoin/commits/3db52bf4a9255538b8ef691a6c9a9edd9c273f84",
      "created_at": "2024-08-27T16:29:47Z"
    },
    {
      "event": "unlabeled",
      "id": 14032377243,
      "node_id": "UNLE_lADOABII586H4P0UzwAAAANEZRWb",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14032377243",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-27T17:13:34Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "unlabeled",
      "id": 14033089559,
      "node_id": "UNLE_lADOABII586H4P0UzwAAAANEb_QX",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14033089559",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-27T18:18:35Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "labeled",
      "id": 14043942113,
      "node_id": "LE_lADOABII586H4P0UzwAAAANFFYzh",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14043942113",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-28T10:03:21Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "unlabeled",
      "id": 14055876382,
      "node_id": "UNLE_lADOABII586H4P0UzwAAAANFy6ce",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14055876382",
      "actor": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-08-29T05:19:09Z",
      "label": {
        "name": "Needs CMake port",
        "color": "0e8a16"
      }
    },
    {
      "event": "reviewed",
      "id": 2282566304,
      "node_id": "PRR_kwDOABII586IDTKg",
      "url": null,
      "actor": null,
      "commit_id": "4ef4eee3b7806ad3710c12cbf4e305a814ba8b40",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#pullrequestreview-2282566304",
      "submitted_at": "2024-09-05T10:52:17Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
    },
    {
      "event": "commented",
      "id": 2331219145,
      "node_id": "IC_kwDOABII586K85TJ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2331219145",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-05T10:54:47Z",
      "updated_at": "2024-09-05T10:54:57Z",
      "author_association": "MEMBER",
      "body": "@laanwj is there anything you still want to change here, or should we review it first as-is?",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2331219145",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "mentioned",
      "id": 14144788089,
      "node_id": "MEE_lADOABII586H4P0UzwAAAANLGFZ5",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14144788089",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-05T10:54:48Z"
    },
    {
      "event": "subscribed",
      "id": 14144788103,
      "node_id": "SE_lADOABII586H4P0UzwAAAANLGFaH",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14144788103",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-05T10:54:48Z"
    },
    {
      "event": "commented",
      "id": 2331961628,
      "node_id": "IC_kwDOABII586K_ukc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2331961628",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-05T15:06:04Z",
      "updated_at": "2024-09-05T15:06:04Z",
      "author_association": "MEMBER",
      "body": "Well. At the least i still need to port it to the new build system (and rebase and squash). There are likely some other smaller comments and nits here and there that i can easily address, but it's kind of become a mess (no one's fault but github and how it handles PRs with lots of comments), so need to take some time to sort it out.",
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2331961628",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "commented",
      "id": 2343920319,
      "node_id": "IC_kwDOABII586LtWK_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2343920319",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-11T14:57:59Z",
      "updated_at": "2024-09-11T14:57:59Z",
      "author_association": "CONTRIBUTOR",
      "body": "I reread my suggestions from https://github.com/bitcoin/bitcoin/pull/30043#pullrequestreview-2141814858, from those I see the following important enough that I work on them in a followup (but even better if they are addressed in this PR):\r\n\r\nhttps://github.com/bitcoin/bitcoin/pull/30043#discussion_r1658764974 avoid unreachable nets (not given to `-onlynet=`)\r\n\r\nhttps://github.com/bitcoin/bitcoin/pull/30043#discussion_r1658949236 could announce an addr:port where we do not listen (no -bind)\r\n\r\nhttps://github.com/bitcoin/bitcoin/pull/30043#discussion_r1684368824 could announce the wrong port because it uses `GetListenPort()`\r\n\r\nhttps://github.com/bitcoin/bitcoin/pull/30043#discussion_r1679709347 if we requested one port but another was assigned, then which one to use in the renewal?\r\n",
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2343920319",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDc1NGU0MjU0Mzg4ZWM4YWMxYmU2Y2Y4MDdiZjMwMGNkNDNmZDNkYTU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/754e4254388ec8ac1be6cf807bf300cd43fd3da5",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/754e4254388ec8ac1be6cf807bf300cd43fd3da5",
      "tree": {
        "sha": "05b8173cca31aa198de639b8b0ec089d83291cea",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/05b8173cca31aa198de639b8b0ec089d83291cea"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/33adc7521cc8bb24b941d959022b084002ba7c60",
          "sha": "33adc7521cc8bb24b941d959022b084002ba7c60",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/33adc7521cc8bb24b941d959022b084002ba7c60"
        }
      ],
      "message": "crypto: Add missing WriteBE16 function\n\nAlso add fuzz test, mimicing the WriteLE16 one.",
      "committer": {
        "name": "laanwj",
        "email": "126646+laanwj@users.noreply.github.com",
        "date": "2024-09-21T10:37:36Z"
      },
      "author": {
        "name": "laanwj",
        "email": "126646+laanwj@users.noreply.github.com",
        "date": "2024-04-28T19:39:20Z"
      },
      "sha": "754e4254388ec8ac1be6cf807bf300cd43fd3da5"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 14349169310,
      "node_id": "HRFPE_lADOABII586H4P0UzwAAAANXRvKe",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14349169310",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "2288625e12d8d3f8fd0a9186d4d5b7069a0904a0",
      "commit_url": "https://api.github.com/repos/laanwj/bitcoin/commits/2288625e12d8d3f8fd0a9186d4d5b7069a0904a0",
      "created_at": "2024-09-21T11:54:31Z"
    },
    {
      "event": "commented",
      "id": 2365160404,
      "node_id": "IC_kwDOABII586M-XvU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2365160404",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-21T11:58:48Z",
      "updated_at": "2024-09-21T12:01:17Z",
      "author_association": "MEMBER",
      "body": "Did a rebase for the changes since last master, including CMake and comparing Span<> using `std::equal_range`. No other changes.\r\n\r\n> https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1658764974 avoid unreachable nets (not given to -onlynet=)\r\n> https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1658949236 could announce an addr:port where we do not listen (no -bind)\r\n> https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1684368824 could announce the wrong port because it uses GetListenPort()\r\n> https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1679709347 if we requested one port but another was assigned, then which one to use in the renewal?\r\n\r\ni agree these are reasonably important, but i'm not going to do them in the scope of this PR. This is more or less equivalent with regard to these edge cases as the current NATPMP code that it replaces. It's  useful as-is for most normal home users.\r\n\r\n(sorry, this already scope crept so much from the initial \"IPv6 pinholing support\" that this was, let's just try to agree on these changes now)\r\n\r\nEdit: added the four points above to \"Things to consider for follow-ups\" section in OP.",
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2365160404",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 14349208199,
      "node_id": "HRFPE_lADOABII586H4P0UzwAAAANXR4qH",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14349208199",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "4476210653ce17eef15ea3e5bc4aa1d3bdc135f1",
      "commit_url": "https://api.github.com/repos/laanwj/bitcoin/commits/4476210653ce17eef15ea3e5bc4aa1d3bdc135f1",
      "created_at": "2024-09-21T12:12:54Z"
    },
    {
      "event": "unlabeled",
      "id": 14349274478,
      "node_id": "UNLE_lADOABII586H4P0UzwAAAANXSI1u",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14349274478",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-21T12:48:02Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "labeled",
      "id": 14349400570,
      "node_id": "LE_lADOABII586H4P0UzwAAAANXSnn6",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14349400570",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-21T13:29:52Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGUwMjAzMDQzMmI3N2FiYmYyN2JiNGY2N2Q4NzlkM2FkNmQ2MzY2ZTY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e02030432b77abbf27bb4f67d879d3ad6d6366e6",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/e02030432b77abbf27bb4f67d879d3ad6d6366e6",
      "tree": {
        "sha": "897fbc9c41ea07c07e6b0937e349f86e0b3b1af3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/897fbc9c41ea07c07e6b0937e349f86e0b3b1af3"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/754e4254388ec8ac1be6cf807bf300cd43fd3da5",
          "sha": "754e4254388ec8ac1be6cf807bf300cd43fd3da5",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/754e4254388ec8ac1be6cf807bf300cd43fd3da5"
        }
      ],
      "message": "net: Add netif utility\n\nThis adds an utility header with two functions that will be needed for\nPCP, `QueryDefaultGateway` and `GetLocalAddresses`.\n\nCo-authored-by: Vasil Dimov <vd@FreeBSD.org>",
      "committer": {
        "name": "laanwj",
        "email": "126646+laanwj@users.noreply.github.com",
        "date": "2024-09-21T13:42:28Z"
      },
      "author": {
        "name": "laanwj",
        "email": "126646+laanwj@users.noreply.github.com",
        "date": "2024-05-16T08:16:41Z"
      },
      "sha": "e02030432b77abbf27bb4f67d879d3ad6d6366e6"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGQ3MmRmNjNkMTY5NDE1NzZiMzUyM2NmZWFhNDk5ODVjZjNjZDRkNDI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d72df63d16941576b3523cfeaa49985cf3cd4d42",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/d72df63d16941576b3523cfeaa49985cf3cd4d42",
      "tree": {
        "sha": "cd81ab1bdbc5df4a57b91b6bf55e64674545c8b7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/cd81ab1bdbc5df4a57b91b6bf55e64674545c8b7"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e02030432b77abbf27bb4f67d879d3ad6d6366e6",
          "sha": "e02030432b77abbf27bb4f67d879d3ad6d6366e6",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/e02030432b77abbf27bb4f67d879d3ad6d6366e6"
        }
      ],
      "message": "net: Use GetLocalAddresses in Discover\n\nThis has the same code, it's unnecessary to duplicate it.",
      "committer": {
        "name": "laanwj",
        "email": "126646+laanwj@users.noreply.github.com",
        "date": "2024-09-21T13:42:29Z"
      },
      "author": {
        "name": "laanwj",
        "email": "126646+laanwj@users.noreply.github.com",
        "date": "2024-05-05T14:14:43Z"
      },
      "sha": "d72df63d16941576b3523cfeaa49985cf3cd4d42"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 14349424182,
      "node_id": "HRFPE_lADOABII586H4P0UzwAAAANXStY2",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14349424182",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "6ea0eb954bc810da71cd057c116f5c2d359a1f37",
      "commit_url": "https://api.github.com/repos/laanwj/bitcoin/commits/6ea0eb954bc810da71cd057c116f5c2d359a1f37",
      "created_at": "2024-09-21T13:42:47Z"
    },
    {
      "event": "comment_deleted",
      "id": 14349430871,
      "node_id": "CDE_lADOABII586H4P0UzwAAAANXSvBX",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14349430871",
      "actor": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-21T13:45:57Z"
    },
    {
      "event": "unlabeled",
      "id": 14349778132,
      "node_id": "UNLE_lADOABII586H4P0UzwAAAANXUDzU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14349778132",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-21T15:02:18Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2367668253,
      "node_id": "IC_kwDOABII586NH8Ad",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2367668253",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-23T09:26:04Z",
      "updated_at": "2024-09-23T09:26:13Z",
      "author_association": "MEMBER",
      "body": "re-tACK 6ea0eb954bc810da71cd057c116f5c2d359a1f37\r\n\r\nTested against my OPNsense router running miniupnpd 2.3.6 with pf backend, on Intel macOS 13.7 and 15.0, Ubuntu 24.04, FreeBSD 14 and Windows 11.",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2367668253",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "review_requested",
      "id": 14360282262,
      "node_id": "RRE_lADOABII586H4P0UzwAAAANX8ISW",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14360282262",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-23T09:26:14Z",
      "requested_reviewer": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "review_requested",
      "id": 14360282450,
      "node_id": "RRE_lADOABII586H4P0UzwAAAANX8IVS",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14360282450",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-23T09:26:15Z",
      "requested_reviewer": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "review_requested",
      "id": 14360282671,
      "node_id": "RRE_lADOABII586H4P0UzwAAAANX8IYv",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14360282671",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-23T09:26:16Z",
      "requested_reviewer": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "reviewed",
      "id": 2323214511,
      "node_id": "PRR_kwDOABII586KeXCv",
      "url": null,
      "actor": null,
      "commit_id": "6ea0eb954bc810da71cd057c116f5c2d359a1f37",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#pullrequestreview-2323214511",
      "submitted_at": "2024-09-23T21:43:34Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
    },
    {
      "event": "commented",
      "id": 2371111205,
      "node_id": "IC_kwDOABII586NVEkl",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2371111205",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-24T12:18:32Z",
      "updated_at": "2024-09-24T12:19:29Z",
      "author_association": "MEMBER",
      "body": "Tested on my Spectrum-provided cable modem from Ubuntu 24.01, and am getting inbound connections (through NATPMP fallback).",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2371111205",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "reviewed",
      "id": 2331760053,
      "node_id": "PRR_kwDOABII586K-9W1",
      "url": null,
      "actor": null,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "ACK 6c89fab9fddb8952ed2ba13048cd87856a2f9397 (modulo squashing the fixup commit)\r\n\r\nThank you!",
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#pullrequestreview-2331760053",
      "submitted_at": "2024-09-26T16:04:57Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
    },
    {
      "event": "review_requested",
      "id": 14419225691,
      "node_id": "RRE_lADOABII586H4P0UzwAAAANbc-xb",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14419225691",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-26T16:05:06Z",
      "requested_reviewer": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "commented",
      "id": 2377541658,
      "node_id": "IC_kwDOABII586Ntmga",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2377541658",
      "actor": {
        "login": "ffrediani",
        "id": 7507739,
        "node_id": "MDQ6VXNlcjc1MDc3Mzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7507739?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ffrediani",
        "html_url": "https://github.com/ffrediani",
        "followers_url": "https://api.github.com/users/ffrediani/followers",
        "following_url": "https://api.github.com/users/ffrediani/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ffrediani/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ffrediani/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ffrediani/subscriptions",
        "organizations_url": "https://api.github.com/users/ffrediani/orgs",
        "repos_url": "https://api.github.com/users/ffrediani/repos",
        "events_url": "https://api.github.com/users/ffrediani/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ffrediani/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-26T17:29:43Z",
      "updated_at": "2024-09-26T17:37:44Z",
      "author_association": "NONE",
      "body": "Great improvement to have more home nodes serving content back to network in IPv6, specially in times of IPv4 exhaustion.\r\n\r\nWhat would be the configuration in bitcoin.conf file ?\r\n\r\nnatpmp=1 will keep doing for IPv4 only ?\r\npcp=1 will do for IPv6 only or for both and complement the existing IPv4 and replace natpmp=1 in the future ?",
      "user": {
        "login": "ffrediani",
        "id": 7507739,
        "node_id": "MDQ6VXNlcjc1MDc3Mzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7507739?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ffrediani",
        "html_url": "https://github.com/ffrediani",
        "followers_url": "https://api.github.com/users/ffrediani/followers",
        "following_url": "https://api.github.com/users/ffrediani/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ffrediani/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ffrediani/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ffrediani/subscriptions",
        "organizations_url": "https://api.github.com/users/ffrediani/orgs",
        "repos_url": "https://api.github.com/users/ffrediani/repos",
        "events_url": "https://api.github.com/users/ffrediani/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ffrediani/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2377541658",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "commented",
      "id": 2377557615,
      "node_id": "IC_kwDOABII586NtqZv",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2377557615",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-26T17:35:13Z",
      "updated_at": "2024-09-26T17:35:13Z",
      "author_association": "MEMBER",
      "body": "In this PR, `natpmp=1` controls both PCP and NAT-PMP.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2377557615",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDk3Yzk3MTc3Y2RiMmY1OTZhYTdkNGE2NWM0YmRlODdkZTUwYTk2ZjI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/97c97177cdb2f596aa7d4a65c4bde87de50a96f2",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/97c97177cdb2f596aa7d4a65c4bde87de50a96f2",
      "tree": {
        "sha": "bde80bef3f19e09821e4d01bcb1627f3fc3a8e7a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/bde80bef3f19e09821e4d01bcb1627f3fc3a8e7a"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d72df63d16941576b3523cfeaa49985cf3cd4d42",
          "sha": "d72df63d16941576b3523cfeaa49985cf3cd4d42",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/d72df63d16941576b3523cfeaa49985cf3cd4d42"
        }
      ],
      "message": "net: Add PCP and NATPMP implementation\n\nAdd a RFC 6886 NATPMP and RFC 6887 Port Control Protocol (PCP)\nimplementation, to replace libnatpmp.",
      "committer": {
        "name": "laanwj",
        "email": "126646+laanwj@users.noreply.github.com",
        "date": "2024-09-30T09:37:55Z"
      },
      "author": {
        "name": "laanwj",
        "email": "126646+laanwj@users.noreply.github.com",
        "date": "2024-05-16T08:17:57Z"
      },
      "sha": "97c97177cdb2f596aa7d4a65c4bde87de50a96f2"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDUyZjhlZjY2YzYxYjgyNDU3YTE2MWYzYjkwY2M4N2Y1N2QxZGRhODA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/52f8ef66c61b82457a161f3b90cc87f57d1dda80",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/52f8ef66c61b82457a161f3b90cc87f57d1dda80",
      "tree": {
        "sha": "6cf7341f4452f4f4649d42d1108cc4683027b41e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6cf7341f4452f4f4649d42d1108cc4683027b41e"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/97c97177cdb2f596aa7d4a65c4bde87de50a96f2",
          "sha": "97c97177cdb2f596aa7d4a65c4bde87de50a96f2",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/97c97177cdb2f596aa7d4a65c4bde87de50a96f2"
        }
      ],
      "message": "net: Replace libnatpmp with built-in NATPMP+PCP implementation in mapport",
      "committer": {
        "name": "laanwj",
        "email": "126646+laanwj@users.noreply.github.com",
        "date": "2024-09-30T09:37:55Z"
      },
      "author": {
        "name": "laanwj",
        "email": "126646+laanwj@users.noreply.github.com",
        "date": "2024-05-05T14:20:45Z"
      },
      "sha": "52f8ef66c61b82457a161f3b90cc87f57d1dda80"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDdiMDQ3MDk4NjJmNDhlOTAyMGM3YmVmNzljYjMxZGQ3OTRjZjkxZDA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7b04709862f48e9020c7bef79cb31dd794cf91d0",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/7b04709862f48e9020c7bef79cb31dd794cf91d0",
      "tree": {
        "sha": "fda09fd733c82523fea3903cfbb855dca96491a9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fda09fd733c82523fea3903cfbb855dca96491a9"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/52f8ef66c61b82457a161f3b90cc87f57d1dda80",
          "sha": "52f8ef66c61b82457a161f3b90cc87f57d1dda80",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/52f8ef66c61b82457a161f3b90cc87f57d1dda80"
        }
      ],
      "message": "qt: Changes for built-in PCP+NAT-PMP\n\nChange option help, and remove conditionals.",
      "committer": {
        "name": "laanwj",
        "email": "126646+laanwj@users.noreply.github.com",
        "date": "2024-09-30T09:37:55Z"
      },
      "author": {
        "name": "laanwj",
        "email": "126646+laanwj@users.noreply.github.com",
        "date": "2024-05-05T17:17:53Z"
      },
      "sha": "7b04709862f48e9020c7bef79cb31dd794cf91d0"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDIwYTE4YmY2YWEzOGU4N2Y3MmUyNjQ1NDgyZDAwZDBjNzdhMzQ0ZjU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/20a18bf6aa38e87f72e2645482d00d0c77a344f5",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/20a18bf6aa38e87f72e2645482d00d0c77a344f5",
      "tree": {
        "sha": "5e541c5c1464ce1c42e83bffb25d99540f70dc63",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5e541c5c1464ce1c42e83bffb25d99540f70dc63"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7b04709862f48e9020c7bef79cb31dd794cf91d0",
          "sha": "7b04709862f48e9020c7bef79cb31dd794cf91d0",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/7b04709862f48e9020c7bef79cb31dd794cf91d0"
        }
      ],
      "message": "build: Drop libnatpmp from build system",
      "committer": {
        "name": "laanwj",
        "email": "126646+laanwj@users.noreply.github.com",
        "date": "2024-09-30T09:37:55Z"
      },
      "author": {
        "name": "laanwj",
        "email": "126646+laanwj@users.noreply.github.com",
        "date": "2024-05-05T14:40:11Z"
      },
      "sha": "20a18bf6aa38e87f72e2645482d00d0c77a344f5"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDA2MWMzZTMyYTI2YzZjMDRiZjczNGQ2MjYyNzQwMzc1OGQ3ZTUxZDk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/061c3e32a26c6c04bf734d62627403758d7e51d9",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/061c3e32a26c6c04bf734d62627403758d7e51d9",
      "tree": {
        "sha": "4198e50cf33e47628a592ce5e94bc28bf623cad3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4198e50cf33e47628a592ce5e94bc28bf623cad3"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/20a18bf6aa38e87f72e2645482d00d0c77a344f5",
          "sha": "20a18bf6aa38e87f72e2645482d00d0c77a344f5",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/20a18bf6aa38e87f72e2645482d00d0c77a344f5"
        }
      ],
      "message": "depends: Drop natpmp and associated option from depends",
      "committer": {
        "name": "laanwj",
        "email": "126646+laanwj@users.noreply.github.com",
        "date": "2024-09-30T09:37:55Z"
      },
      "author": {
        "name": "laanwj",
        "email": "126646+laanwj@users.noreply.github.com",
        "date": "2024-05-05T14:46:49Z"
      },
      "sha": "061c3e32a26c6c04bf734d62627403758d7e51d9"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDdlN2VjOTg0ZGE1MGY0NTQ5MWI5OTRhYWFiMTgwZTc3MzVhZDFkOGY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7e7ec984da50f45491b994aaab180e7735ad1d8f",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/7e7ec984da50f45491b994aaab180e7735ad1d8f",
      "tree": {
        "sha": "c165ac8ce4b8ecc8695b8c266edccd2178a76bce",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c165ac8ce4b8ecc8695b8c266edccd2178a76bce"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/061c3e32a26c6c04bf734d62627403758d7e51d9",
          "sha": "061c3e32a26c6c04bf734d62627403758d7e51d9",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/061c3e32a26c6c04bf734d62627403758d7e51d9"
        }
      ],
      "message": "doc: Remove mention of natpmp build options",
      "committer": {
        "name": "laanwj",
        "email": "126646+laanwj@users.noreply.github.com",
        "date": "2024-09-30T09:37:56Z"
      },
      "author": {
        "name": "laanwj",
        "email": "126646+laanwj@users.noreply.github.com",
        "date": "2024-05-05T14:49:16Z"
      },
      "sha": "7e7ec984da50f45491b994aaab180e7735ad1d8f"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDVjN2NhY2Y2NDlhNmI0NzRiODc2YTdkMjE5YzdkYzY4M2EyNWUzM2Q",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "tree": {
        "sha": "5cafd2bdcf912de417c8c30804c329b3882fb230",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5cafd2bdcf912de417c8c30804c329b3882fb230"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7e7ec984da50f45491b994aaab180e7735ad1d8f",
          "sha": "7e7ec984da50f45491b994aaab180e7735ad1d8f",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/7e7ec984da50f45491b994aaab180e7735ad1d8f"
        }
      ],
      "message": "ci: Remove natpmp build option and libnatpmp dependency",
      "committer": {
        "name": "laanwj",
        "email": "126646+laanwj@users.noreply.github.com",
        "date": "2024-09-30T09:37:56Z"
      },
      "author": {
        "name": "laanwj",
        "email": "126646+laanwj@users.noreply.github.com",
        "date": "2024-05-05T14:54:12Z"
      },
      "sha": "5c7cacf649a6b474b876a7d219c7dc683a25e33d"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 14452831761,
      "node_id": "HRFPE_lADOABII586H4P0UzwAAAANddLYR",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14452831761",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "commit_url": "https://api.github.com/repos/laanwj/bitcoin/commits/5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "created_at": "2024-09-30T09:39:25Z"
    },
    {
      "event": "commented",
      "id": 2382630708,
      "node_id": "IC_kwDOABII586OBA80",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2382630708",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-30T09:40:25Z",
      "updated_at": "2024-09-30T09:40:59Z",
      "author_association": "MEMBER",
      "body": "Force push: auto-squashed the fixup commit.\r\n\r\n> In this PR, natpmp=1 controls both PCP and NAT-PMP.\r\n\r\nYes, after initial discussion we decided to add no new command line, or UI options. PCP is regarded a newer version of NATPMP (which is strictly true) that has some extra mapping features as well as IPv6 support. The help message has been updated to reflect this.",
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2382630708",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "reviewed",
      "id": 2337161558,
      "node_id": "PRR_kwDOABII586LTkFW",
      "url": null,
      "actor": null,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "ACK 5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#pullrequestreview-2337161558",
      "submitted_at": "2024-09-30T11:01:54Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
    },
    {
      "event": "commented",
      "id": 2382905543,
      "node_id": "IC_kwDOABII586OCEDH",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2382905543",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-30T11:20:00Z",
      "updated_at": "2024-09-30T11:20:00Z",
      "author_association": "MEMBER",
      "body": "ACK 5c7cacf649a6b474b876a7d219c7dc683a25e33d\r\n\r\nJust a documentation squash since my last test and review.",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2382905543",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "commented",
      "id": 2384063267,
      "node_id": "IC_kwDOABII586OGesj",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2384063267",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-30T20:13:06Z",
      "updated_at": "2024-09-30T20:13:06Z",
      "author_association": "MEMBER",
      "body": "ACK 5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2384063267",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "merged",
      "id": 14461967522,
      "node_id": "ME_lADOABII586H4P0UzwAAAANeAByi",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14461967522",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "c33eb2360e2482eee94b55aef3b8ab2eeff1576e",
      "commit_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c33eb2360e2482eee94b55aef3b8ab2eeff1576e",
      "created_at": "2024-09-30T20:28:11Z"
    },
    {
      "event": "closed",
      "id": 14461967587,
      "node_id": "CE_lADOABII586H4P0UzwAAAANeABzj",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14461967587",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-09-30T20:28:12Z"
    },
    {
      "event": "commented",
      "id": 2385471084,
      "node_id": "IC_kwDOABII586OL2Zs",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2385471084",
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-10-01T10:58:50Z",
      "updated_at": "2024-10-01T10:58:50Z",
      "author_association": "MEMBER",
      "body": "From the tidy job (https://api.cirrus-ci.com/v1/task/4831368570470400/logs/ci.log):\r\n```bash\r\n[21:19:24.426] Built target bitcoin_crypto_avx2\r\n[21:19:26.500] Error: netif.cpp.o depends on netaddress.cpp.o symbol 'CNetAddr::CNetAddr(in_addr const&)', can suppess with:\r\n[21:19:26.500]     SUPPRESS[\"netif.cpp.o netaddress.cpp.o _ZN8CNetAddrC1ERK7in_addr\"]=1\r\n[21:19:26.502] Error: pcp.cpp.o depends on netaddress.cpp.o symbol 'CNetAddr::CNetAddr(in_addr const&)', can suppess with:\r\n[21:19:26.502]     SUPPRESS[\"pcp.cpp.o netaddress.cpp.o _ZN8CNetAddrC1ERK7in_addr\"]=1\r\n[21:19:26.516] Error: netif.cpp.o depends on netaddress.cpp.o symbol 'CNetAddr::CNetAddr(in6_addr const&, unsigned int)', can suppess with:\r\n[21:19:26.516]     SUPPRESS[\"netif.cpp.o netaddress.cpp.o _ZN8CNetAddrC1ERK8in6_addrj\"]=1\r\n[21:19:26.517] Error: pcp.cpp.o depends on netaddress.cpp.o symbol 'CNetAddr::CNetAddr(in6_addr const&, unsigned int)', can suppess with:\r\n[21:19:26.517]     SUPPRESS[\"pcp.cpp.o netaddress.cpp.o _ZN8CNetAddrC1ERK8in6_addrj\"]=1\r\n[21:19:26.530] Error: pcp.cpp.o depends on netaddress.cpp.o symbol 'CService::SetSockAddr(sockaddr const*)', can suppess with:\r\n[21:19:26.530]     SUPPRESS[\"pcp.cpp.o netaddress.cpp.o _ZN8CService11SetSockAddrEPK8sockaddr\"]=1\r\n[21:19:26.542] Error: pcp.cpp.o depends on netaddress.cpp.o symbol 'CService::CService(in_addr const&, unsigned short)', can suppess with:\r\n[21:19:26.542]     SUPPRESS[\"pcp.cpp.o netaddress.cpp.o _ZN8CServiceC1ERK7in_addrt\"]=1\r\n[21:19:26.554] Error: pcp.cpp.o depends on netaddress.cpp.o symbol 'CService::CService(CNetAddr const&, unsigned short)', can suppess with:\r\n[21:19:26.554]     SUPPRESS[\"pcp.cpp.o netaddress.cpp.o _ZN8CServiceC1ERK8CNetAddrt\"]=1\r\n[21:19:26.567] Error: pcp.cpp.o depends on netaddress.cpp.o symbol 'CService::CService()', can suppess with:\r\n[21:19:26.567]     SUPPRESS[\"pcp.cpp.o netaddress.cpp.o _ZN8CServiceC1Ev\"]=1\r\n[21:19:26.579] Error: pcp.cpp.o depends on netaddress.cpp.o symbol 'CNetAddr::GetIn6Addr(in6_addr*) const', can suppess with:\r\n[21:19:26.579]     SUPPRESS[\"pcp.cpp.o netaddress.cpp.o _ZNK8CNetAddr10GetIn6AddrEP8in6_addr\"]=1\r\n[21:19:26.590] Error: pcp.cpp.o depends on netaddress.cpp.o symbol 'CNetAddr::ToStringAddr[abi:cxx11]() const', can suppess with:\r\n[21:19:26.590]     SUPPRESS[\"pcp.cpp.o netaddress.cpp.o _ZNK8CNetAddr12ToStringAddrB5cxx11Ev\"]=1\r\n[21:19:26.603] Error: pcp.cpp.o depends on netaddress.cpp.o symbol 'CNetAddr::GetInAddr(in_addr*) const', can suppess with:\r\n[21:19:26.603]     SUPPRESS[\"pcp.cpp.o netaddress.cpp.o _ZNK8CNetAddr9GetInAddrEP7in_addr\"]=1\r\n[21:19:26.617] Error: netif.cpp.o depends on netaddress.cpp.o symbol 'CNetAddr::IsBindAny() const', can suppess with:\r\n[21:19:26.617]     SUPPRESS[\"netif.cpp.o netaddress.cpp.o _ZNK8CNetAddr9IsBindAnyEv\"]=1\r\n[21:19:26.631] Error: pcp.cpp.o depends on netaddress.cpp.o symbol 'CService::GetSockAddr(sockaddr*, unsigned int*) const', can suppess with:\r\n[21:19:26.631]     SUPPRESS[\"pcp.cpp.o netaddress.cpp.o _ZNK8CService11GetSockAddrEP8sockaddrPj\"]=1\r\n[21:19:26.645] Error: pcp.cpp.o depends on netaddress.cpp.o symbol 'CService::ToStringAddrPort[abi:cxx11]() const', can suppess with:\r\n[21:19:26.645]     SUPPRESS[\"pcp.cpp.o netaddress.cpp.o _ZNK8CService16ToStringAddrPortB5cxx11Ev\"]=1\r\n[21:19:26.669] Error: Unexpected dependencies were detected. Check previous output.\r\n```",
      "user": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2385471084",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "referenced",
      "id": 14953582620,
      "node_id": "REFE_lADOABII586H4P0UzwAAAAN7TZAc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14953582620",
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "a10acc7d80a4b612af694cce8bec5e23991a1f34",
      "commit_url": "https://api.github.com/repos/fanquake/oss-fuzz/commits/a10acc7d80a4b612af694cce8bec5e23991a1f34",
      "created_at": "2024-10-28T09:48:01Z"
    },
    {
      "event": "referenced",
      "id": 14955358633,
      "node_id": "REFE_lADOABII586H4P0UzwAAAAN7aKmp",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14955358633",
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "6e21dedbf2b3029c729108f225469b321a1b3d39",
      "commit_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6e21dedbf2b3029c729108f225469b321a1b3d39",
      "created_at": "2024-10-28T10:47:40Z"
    },
    {
      "event": "referenced",
      "id": 14955373961,
      "node_id": "REFE_lADOABII586H4P0UzwAAAAN7aOWJ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14955373961",
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "d7b64152a93e23e6451b56b3226921d56db7b053",
      "commit_url": "https://api.github.com/repos/fanquake/oss-fuzz/commits/d7b64152a93e23e6451b56b3226921d56db7b053",
      "created_at": "2024-10-28T10:48:35Z"
    },
    {
      "event": "referenced",
      "id": 15064745878,
      "node_id": "REFE_lADOABII586H4P0UzwAAAAOB7ceW",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15064745878",
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "4534b12a8066b040101953f78bb04ac41f992d72",
      "commit_url": "https://api.github.com/repos/fanquake/oss-fuzz/commits/4534b12a8066b040101953f78bb04ac41f992d72",
      "created_at": "2024-11-01T11:15:31Z"
    },
    {
      "event": "referenced",
      "id": 15068354905,
      "node_id": "REFE_lADOABII586H4P0UzwAAAAOCJNlZ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15068354905",
      "actor": {
        "login": "vitorguidi",
        "id": 5733577,
        "node_id": "MDQ6VXNlcjU3MzM1Nzc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5733577?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vitorguidi",
        "html_url": "https://github.com/vitorguidi",
        "followers_url": "https://api.github.com/users/vitorguidi/followers",
        "following_url": "https://api.github.com/users/vitorguidi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vitorguidi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vitorguidi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vitorguidi/subscriptions",
        "organizations_url": "https://api.github.com/users/vitorguidi/orgs",
        "repos_url": "https://api.github.com/users/vitorguidi/repos",
        "events_url": "https://api.github.com/users/vitorguidi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vitorguidi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "e0b8762553228ca700fb38859d367f3e5a55b73b",
      "commit_url": "https://api.github.com/repos/google/oss-fuzz/commits/e0b8762553228ca700fb38859d367f3e5a55b73b",
      "created_at": "2024-11-01T13:47:51Z"
    },
    {
      "event": "referenced",
      "id": 15084730966,
      "node_id": "REFE_lADOABII586H4P0UzwAAAAODHrpW",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15084730966",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "8bb47d4c2c57eb33cdb346ea75c549954d5f9cb1",
      "commit_url": "https://api.github.com/repos/TheCharlatan/rust-bitcoinkernel/commits/8bb47d4c2c57eb33cdb346ea75c549954d5f9cb1",
      "created_at": "2024-11-02T20:58:30Z"
    },
    {
      "event": "referenced",
      "id": 16247899945,
      "node_id": "REFE_lADOABII586H4P0UzwAAAAPIc0cp",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16247899945",
      "actor": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "f8d3e0edf47d50cfb3d0279f026e9a4d1e6a3a6b",
      "commit_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f8d3e0edf47d50cfb3d0279f026e9a4d1e6a3a6b",
      "created_at": "2025-02-10T13:47:26Z"
    },
    {
      "event": "commented",
      "id": 2695347851,
      "node_id": "IC_kwDOABII586gp76L",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2695347851",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-03T19:28:23Z",
      "updated_at": "2025-03-03T19:28:23Z",
      "author_association": "MEMBER",
      "body": "Removing the \"Needs release note label\" since there are notes for #31130. Lmk if this doesn't sound right.",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2695347851",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/30043"
    },
    {
      "event": "unlabeled",
      "id": 16539735249,
      "node_id": "UNLE_lADOABII586H4P0UzwAAAAPZ2FTR",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16539735249",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-03T19:28:31Z",
      "label": {
        "name": "Needs release note",
        "color": "d2db6d"
      }
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1590975165",
      "pull_request_review_id": 2040718091,
      "id": 1590975165,
      "node_id": "PRRC_kwDOABII585e1Fq9",
      "diff_hunk": "@@ -760,8 +757,8 @@ void InitParameterInteraction(ArgsManager& args)\n         // do not map ports or try to retrieve public IP when not listening (pointless)\n         if (args.SoftSetBoolArg(\"-upnp\", false))\n             LogPrintf(\"%s: parameter interaction: -listen=0 -> setting -upnp=0\\n\", __func__);\n-        if (args.SoftSetBoolArg(\"-natpmp\", false)) {",
      "path": "src/init.cpp",
      "position": null,
      "original_position": 29,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "a2d67c320f8a28da98e6c8352bd67648a9b831a8",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "a2d67c320f8a28da98e6c8352bd67648a9b831a8: I think you need to keep this (and above) until `-natpmp` is removed.",
      "created_at": "2024-05-06T12:53:51Z",
      "updated_at": "2024-05-06T16:51:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1590975165",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1590975165"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 783,
      "side": "LEFT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1592075348",
      "pull_request_review_id": 2042519681,
      "id": 1592075348,
      "node_id": "PRRC_kwDOABII585e5SRU",
      "diff_hunk": "@@ -760,8 +757,8 @@ void InitParameterInteraction(ArgsManager& args)\n         // do not map ports or try to retrieve public IP when not listening (pointless)\n         if (args.SoftSetBoolArg(\"-upnp\", false))\n             LogPrintf(\"%s: parameter interaction: -listen=0 -> setting -upnp=0\\n\", __func__);\n-        if (args.SoftSetBoolArg(\"-natpmp\", false)) {",
      "path": "src/init.cpp",
      "position": null,
      "original_position": 29,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "a2d67c320f8a28da98e6c8352bd67648a9b831a8",
      "in_reply_to_id": 1590975165,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Yes, good point.",
      "created_at": "2024-05-07T08:59:41Z",
      "updated_at": "2024-05-07T08:59:42Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1592075348",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1592075348"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 783,
      "side": "LEFT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1592765102",
      "pull_request_review_id": 2043665469,
      "id": 1592765102,
      "node_id": "PRRC_kwDOABII585e76qu",
      "diff_hunk": "@@ -0,0 +1,236 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/pcp.h>\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <random.h>\n+#include <util/netif.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+// RFC 6887 Port Control Protocol (PCP) implementation.\n+// PCP uses network byte order (big-endian).\n+// References to sections and figures in the code below refer to https://datatracker.ietf.org/doc/html/rfc6887.\n+\n+//! Mapping of PCP result code to string (7.4).\n+static const std::map<uint8_t, std::string> PCP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"MALFORMED_REQUEST\"},\n+    {4,  \"UNSUPP_OPCODE\"},\n+    {5,  \"UNSUPP_OPTION\"},\n+    {6,  \"MALFORMED_OPTION\"},\n+    {7,  \"NETWORK_FAILURE\"},\n+    {8,  \"NO_RESOURCES\"},\n+    {9,  \"UNSUPP_PROTOCOL\"},\n+    {10, \"USER_EX_QUOTA\"},\n+    {11, \"CANNOT_PROVIDE_EXTERNAL\"},\n+    {12, \"ADDRESS_MISMATCH\"},\n+    {13, \"EXCESSIVE_REMOTE_PEER\"},\n+};\n+\n+std::string PCPResultString(uint8_t result_code)\n+{\n+    auto result_i = PCP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == PCP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Wrap address in IPv6 according to RFC. wrapped_addr needs to be able to store 16 bytes.\n+[[nodiscard]] static bool PCPWrapAddress(uint8_t *wrapped_addr, const CNetAddr &addr)\n+{\n+    if (addr.IsIPv4()) {\n+        struct in_addr addr4;\n+        if (!addr.GetInAddr(&addr4)) return false;\n+        // Section 5: \"When the address field holds an IPv4 address, an IPv4-mapped IPv6 address [RFC4291] is used (::ffff:0:0/96).\"\n+        memcpy(wrapped_addr, IPV4_IN_IPV6_PREFIX.data(), IPV4_IN_IPV6_PREFIX.size());\n+        memcpy(wrapped_addr + IPV4_IN_IPV6_PREFIX.size(), &addr4, ADDR_IPV4_SIZE);\n+        return true;\n+    } else if (addr.IsIPv6()) {\n+        struct in6_addr addr6;\n+        if (!addr.GetIn6Addr(&addr6)) return false;\n+        memcpy(wrapped_addr, &addr6, ADDR_IPV6_SIZE);\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+//! Unwrap PCP-encoded address.\n+static CNetAddr PCPUnwrapAddress(const uint8_t *wrapped_addr)\n+{\n+    if (memcmp(wrapped_addr, IPV4_IN_IPV6_PREFIX.data(), IPV4_IN_IPV6_PREFIX.size()) == 0) {\n+        struct in_addr addr4;\n+        memcpy(&addr4, wrapped_addr + IPV4_IN_IPV6_PREFIX.size(), ADDR_IPV4_SIZE);\n+        return CNetAddr(addr4);\n+    } else {\n+        struct in6_addr addr6;\n+        memcpy(&addr6, wrapped_addr, ADDR_IPV6_SIZE);\n+        return CNetAddr(addr6);\n+    }\n+}\n+\n+std::optional<MappingResult> PCPRequestPortMap(const PCPMappingNonce &nonce, const CNetAddr &gateway, const CNetAddr &bind, uint16_t port, uint32_t lifetime, int num_tries, bool option_prefer_failure)\n+{\n+    struct sockaddr_storage dest_addr, bind_addr;\n+    socklen_t dest_addrlen = sizeof(struct sockaddr_storage), bind_addrlen = sizeof(struct sockaddr_storage);\n+\n+    LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp: Requesting port mapping for addr %s port %d from gateway %s\\n\", bind.ToStringAddr(), port, gateway.ToStringAddr());",
      "path": "src/util/pcp.cpp",
      "position": null,
      "original_position": 83,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "fe53862fd4dca2ce7d3208847ed9e917c30ccb27",
      "in_reply_to_id": null,
      "user": {
        "login": "davidgumberg",
        "id": 2257631,
        "node_id": "MDQ6VXNlcjIyNTc2MzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2257631?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/davidgumberg",
        "html_url": "https://github.com/davidgumberg",
        "followers_url": "https://api.github.com/users/davidgumberg/followers",
        "following_url": "https://api.github.com/users/davidgumberg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/davidgumberg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/davidgumberg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/davidgumberg/subscriptions",
        "organizations_url": "https://api.github.com/users/davidgumberg/orgs",
        "repos_url": "https://api.github.com/users/davidgumberg/repos",
        "events_url": "https://api.github.com/users/davidgumberg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/davidgumberg/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit:\r\n```suggestion\r\n    LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"pcp: Requesting port mapping for addr %s port %d from gateway %s\\n\", bind.ToStringAddr(), port, gateway.ToStringAddr());\r\n```",
      "created_at": "2024-05-07T16:25:32Z",
      "updated_at": "2024-05-07T16:25:33Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1592765102",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1592765102"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 83,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1595141704",
      "pull_request_review_id": 2047432934,
      "id": 1595141704,
      "node_id": "PRRC_kwDOABII585fE-5I",
      "diff_hunk": "@@ -108,9 +108,7 @@ OptionsDialog::OptionsDialog(QWidget* parent, bool enableWallet)\n #ifndef USE_UPNP\n     ui->mapPortUpnp->setEnabled(false);\n #endif\n-#ifndef USE_NATPMP\n-    ui->mapPortNatpmp->setEnabled(false);\n-#endif\n+    ui->mapPortPCP->setEnabled(false);",
      "path": "src/qt/optionsdialog.cpp",
      "position": null,
      "original_position": 7,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "73037f27fc21765414c298b171dfdeee130c549b",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "73037f27fc21765414c298b171dfdeee130c549b: needs to be `true`, but you can actually drop this line.",
      "created_at": "2024-05-09T08:29:52Z",
      "updated_at": "2024-05-09T09:56:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1595141704",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1595141704"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 111,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1595145827",
      "pull_request_review_id": 2047432934,
      "id": 1595145827,
      "node_id": "PRRC_kwDOABII585fE_5j",
      "diff_hunk": "@@ -326,12 +326,12 @@\n         </widget>\n        </item>\n        <item>\n-        <widget class=\"QCheckBox\" name=\"mapPortNatpmp\">\n+        <widget class=\"QCheckBox\" name=\"mapPortPCP\">\n          <property name=\"toolTip\">\n-          <string>Automatically open the Bitcoin client port on the router. This only works when your router supports NAT-PMP and it is enabled. The external port could be random.</string>\n+          <string>Automatically open the Bitcoin client port on the router. This only works when your router supports PCP and it is enabled. The external port could be random.</string>",
      "path": "src/qt/forms/optionsdialog.ui",
      "position": null,
      "original_position": 8,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "73037f27fc21765414c298b171dfdeee130c549b",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "73037f27fc21765414c298b171dfdeee130c549b: maybe add: \"PCP is the successor to NAT-PMP.\", in case someone who didn't read the release notes is confused why that option disappeared.",
      "created_at": "2024-05-09T08:34:02Z",
      "updated_at": "2024-05-09T09:56:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1595145827",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1595145827"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 331,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1595583401",
      "pull_request_review_id": 2048184349,
      "id": 1595583401,
      "node_id": "PRRC_kwDOABII585fGqup",
      "diff_hunk": "@@ -47,105 +44,73 @@ static std::atomic<MapPortProtoFlag> g_mapport_current_proto{MapPortProtoFlag::N\n using namespace std::chrono_literals;\n static constexpr auto PORT_MAPPING_REANNOUNCE_PERIOD{20min};\n static constexpr auto PORT_MAPPING_RETRY_PERIOD{5min};\n+static constexpr auto PORT_MAPPING_REANNOUNCE_MARGIN{60s};\n \n-#ifdef USE_NATPMP\n-static uint16_t g_mapport_external_port = 0;\n-static bool NatpmpInit(natpmp_t* natpmp)\n+static bool ProcessPCP()\n {\n-    const int r_init = initnatpmp(natpmp, /* detect gateway automatically */ 0, /* forced gateway - NOT APPLIED*/ 0);\n-    if (r_init == 0) return true;\n-    LogPrintf(\"natpmp: initnatpmp() failed with %d error.\\n\", r_init);\n-    return false;\n-}\n+    // The same nonce is used for all mappings, this is allowed by the spec, and simplifies keeping track of them.\n+    PCPMappingNonce pcp_nonce;\n+    GetRandBytes(pcp_nonce);\n \n-static bool NatpmpDiscover(natpmp_t* natpmp, struct in_addr& external_ipv4_addr)\n-{\n-    const int r_send = sendpublicaddressrequest(natpmp);\n-    if (r_send == 2 /* OK */) {\n-        int r_read;\n-        natpmpresp_t response;\n-        do {\n-            r_read = readnatpmpresponseorretry(natpmp, &response);\n-        } while (r_read == NATPMP_TRYAGAIN);\n-\n-        if (r_read == 0) {\n-            external_ipv4_addr = response.pnu.publicaddress.addr;\n-            return true;\n-        } else if (r_read == NATPMP_ERR_NOGATEWAYSUPPORT) {\n-            LogPrintf(\"natpmp: The gateway does not support NAT-PMP.\\n\");\n+    bool ret = false;\n+    const uint16_t private_port = GetListenPort();\n+    // Request reannounce period plus safety margin.\n+    const uint32_t requested_lifetime = std::chrono::seconds(PORT_MAPPING_REANNOUNCE_PERIOD + PORT_MAPPING_REANNOUNCE_MARGIN).count();\n+    std::chrono::seconds sleep_time;\n+\n+    do {\n+        uint32_t actual_lifetime = requested_lifetime;\n+        ret = false; // Set to true if any mapping succeeds.\n+\n+        // IPv4\n+        std::optional<CNetAddr> gateway4 = QueryDefaultGateway(NET_IPV4);\n+        if (!gateway4) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"pcp: Could not determine IPv4 default gateway\\n\");\n         } else {\n-            LogPrintf(\"natpmp: readnatpmpresponseorretry() for public address failed with %d error.\\n\", r_read);\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"pcp: gateway [IPv4]: %s\\n\", gateway4->ToStringAddr());\n+\n+            // Open a port mapping on whatever local address we have toward the gateway.\n+            struct in_addr inaddr_any;\n+            inaddr_any.s_addr = htonl(INADDR_ANY);\n+            std::optional<MappingResult> res = PCPRequestPortMap(pcp_nonce, *gateway4, CNetAddr(inaddr_any), private_port, requested_lifetime);\n+            if (res) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Info, \"pcp: ExternalIPv4Address:port = %s\\n\", res->external.ToStringAddrPort());\n+                AddLocal(res->external, LOCAL_MAPPED);\n+                ret = true;\n+                actual_lifetime = std::min(actual_lifetime, res->lifetime);\n+            }\n         }\n-    } else {\n-        LogPrintf(\"natpmp: sendpublicaddressrequest() failed with %d error.\\n\", r_send);\n-    }\n \n-    return false;\n-}\n-\n-static bool NatpmpMapping(natpmp_t* natpmp, const struct in_addr& external_ipv4_addr, uint16_t private_port, bool& external_ip_discovered)\n-{\n-    const uint16_t suggested_external_port = g_mapport_external_port ? g_mapport_external_port : private_port;\n-    const int r_send = sendnewportmappingrequest(natpmp, NATPMP_PROTOCOL_TCP, private_port, suggested_external_port, 3600 /*seconds*/);\n-    if (r_send == 12 /* OK */) {\n-        int r_read;\n-        natpmpresp_t response;\n-        do {\n-            r_read = readnatpmpresponseorretry(natpmp, &response);\n-        } while (r_read == NATPMP_TRYAGAIN);\n-\n-        if (r_read == 0) {\n-            auto pm = response.pnu.newportmapping;\n-            if (private_port == pm.privateport && pm.lifetime > 0) {\n-                g_mapport_external_port = pm.mappedpublicport;\n-                const CService external{external_ipv4_addr, pm.mappedpublicport};\n-                if (!external_ip_discovered && fDiscover) {\n-                    AddLocal(external, LOCAL_MAPPED);\n-                    external_ip_discovered = true;\n+        // IPv6\n+        std::optional<CNetAddr> gateway6 = QueryDefaultGateway(NET_IPV6);\n+        if (!gateway6) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"pcp: Could not determine IPv6 default gateway\\n\");",
      "path": "src/mapport.cpp",
      "position": null,
      "original_position": 119,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "6cf4809c6b93e1720dfdfe4e3320cfd8939686b6",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "6cf4809c6b93e1720dfdfe4e3320cfd8939686b6: This is `::Warning` worthy.",
      "created_at": "2024-05-09T15:10:12Z",
      "updated_at": "2024-05-09T15:45:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1595583401",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1595583401"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 92,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1602742155",
      "pull_request_review_id": 2059790357,
      "id": 1602742155,
      "node_id": "PRRC_kwDOABII585fh-eL",
      "diff_hunk": "@@ -47,105 +44,73 @@ static std::atomic<MapPortProtoFlag> g_mapport_current_proto{MapPortProtoFlag::N\n using namespace std::chrono_literals;\n static constexpr auto PORT_MAPPING_REANNOUNCE_PERIOD{20min};\n static constexpr auto PORT_MAPPING_RETRY_PERIOD{5min};\n+static constexpr auto PORT_MAPPING_REANNOUNCE_MARGIN{60s};\n \n-#ifdef USE_NATPMP\n-static uint16_t g_mapport_external_port = 0;\n-static bool NatpmpInit(natpmp_t* natpmp)\n+static bool ProcessPCP()\n {\n-    const int r_init = initnatpmp(natpmp, /* detect gateway automatically */ 0, /* forced gateway - NOT APPLIED*/ 0);\n-    if (r_init == 0) return true;\n-    LogPrintf(\"natpmp: initnatpmp() failed with %d error.\\n\", r_init);\n-    return false;\n-}\n+    // The same nonce is used for all mappings, this is allowed by the spec, and simplifies keeping track of them.\n+    PCPMappingNonce pcp_nonce;\n+    GetRandBytes(pcp_nonce);\n \n-static bool NatpmpDiscover(natpmp_t* natpmp, struct in_addr& external_ipv4_addr)\n-{\n-    const int r_send = sendpublicaddressrequest(natpmp);\n-    if (r_send == 2 /* OK */) {\n-        int r_read;\n-        natpmpresp_t response;\n-        do {\n-            r_read = readnatpmpresponseorretry(natpmp, &response);\n-        } while (r_read == NATPMP_TRYAGAIN);\n-\n-        if (r_read == 0) {\n-            external_ipv4_addr = response.pnu.publicaddress.addr;\n-            return true;\n-        } else if (r_read == NATPMP_ERR_NOGATEWAYSUPPORT) {\n-            LogPrintf(\"natpmp: The gateway does not support NAT-PMP.\\n\");\n+    bool ret = false;\n+    const uint16_t private_port = GetListenPort();\n+    // Request reannounce period plus safety margin.\n+    const uint32_t requested_lifetime = std::chrono::seconds(PORT_MAPPING_REANNOUNCE_PERIOD + PORT_MAPPING_REANNOUNCE_MARGIN).count();\n+    std::chrono::seconds sleep_time;\n+\n+    do {\n+        uint32_t actual_lifetime = requested_lifetime;\n+        ret = false; // Set to true if any mapping succeeds.\n+\n+        // IPv4\n+        std::optional<CNetAddr> gateway4 = QueryDefaultGateway(NET_IPV4);\n+        if (!gateway4) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"pcp: Could not determine IPv4 default gateway\\n\");\n         } else {\n-            LogPrintf(\"natpmp: readnatpmpresponseorretry() for public address failed with %d error.\\n\", r_read);\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"pcp: gateway [IPv4]: %s\\n\", gateway4->ToStringAddr());\n+\n+            // Open a port mapping on whatever local address we have toward the gateway.\n+            struct in_addr inaddr_any;\n+            inaddr_any.s_addr = htonl(INADDR_ANY);\n+            std::optional<MappingResult> res = PCPRequestPortMap(pcp_nonce, *gateway4, CNetAddr(inaddr_any), private_port, requested_lifetime);\n+            if (res) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Info, \"pcp: ExternalIPv4Address:port = %s\\n\", res->external.ToStringAddrPort());\n+                AddLocal(res->external, LOCAL_MAPPED);\n+                ret = true;\n+                actual_lifetime = std::min(actual_lifetime, res->lifetime);\n+            }\n         }\n-    } else {\n-        LogPrintf(\"natpmp: sendpublicaddressrequest() failed with %d error.\\n\", r_send);\n-    }\n \n-    return false;\n-}\n-\n-static bool NatpmpMapping(natpmp_t* natpmp, const struct in_addr& external_ipv4_addr, uint16_t private_port, bool& external_ip_discovered)\n-{\n-    const uint16_t suggested_external_port = g_mapport_external_port ? g_mapport_external_port : private_port;\n-    const int r_send = sendnewportmappingrequest(natpmp, NATPMP_PROTOCOL_TCP, private_port, suggested_external_port, 3600 /*seconds*/);\n-    if (r_send == 12 /* OK */) {\n-        int r_read;\n-        natpmpresp_t response;\n-        do {\n-            r_read = readnatpmpresponseorretry(natpmp, &response);\n-        } while (r_read == NATPMP_TRYAGAIN);\n-\n-        if (r_read == 0) {\n-            auto pm = response.pnu.newportmapping;\n-            if (private_port == pm.privateport && pm.lifetime > 0) {\n-                g_mapport_external_port = pm.mappedpublicport;\n-                const CService external{external_ipv4_addr, pm.mappedpublicport};\n-                if (!external_ip_discovered && fDiscover) {\n-                    AddLocal(external, LOCAL_MAPPED);\n-                    external_ip_discovered = true;\n+        // IPv6\n+        std::optional<CNetAddr> gateway6 = QueryDefaultGateway(NET_IPV6);\n+        if (!gateway6) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"pcp: Could not determine IPv6 default gateway\\n\");",
      "path": "src/mapport.cpp",
      "position": null,
      "original_position": 119,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "6cf4809c6b93e1720dfdfe4e3320cfd8939686b6",
      "in_reply_to_id": 1595583401,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "It's hidden as debug because at the moment this is shown when the user doesn't have IPv6. Could boost this to warning if we do the address check first, then don't bother looking for a default gateway if there's none. Will do that.",
      "created_at": "2024-05-16T07:13:39Z",
      "updated_at": "2024-05-16T07:13:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1602742155",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1602742155"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 92,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1602763394",
      "pull_request_review_id": 2059823939,
      "id": 1602763394,
      "node_id": "PRRC_kwDOABII585fiDqC",
      "diff_hunk": "@@ -108,9 +108,7 @@ OptionsDialog::OptionsDialog(QWidget* parent, bool enableWallet)\n #ifndef USE_UPNP\n     ui->mapPortUpnp->setEnabled(false);\n #endif\n-#ifndef USE_NATPMP\n-    ui->mapPortNatpmp->setEnabled(false);\n-#endif\n+    ui->mapPortPCP->setEnabled(false);",
      "path": "src/qt/optionsdialog.cpp",
      "position": null,
      "original_position": 7,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "73037f27fc21765414c298b171dfdeee130c549b",
      "in_reply_to_id": 1595141704,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Whoops, yes, it's `setEnabled`, not setting the default value 😅 .",
      "created_at": "2024-05-16T07:28:29Z",
      "updated_at": "2024-05-16T07:28:54Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1602763394",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1602763394"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 111,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1602770267",
      "pull_request_review_id": 2059835406,
      "id": 1602770267,
      "node_id": "PRRC_kwDOABII585fiFVb",
      "diff_hunk": "@@ -47,105 +44,73 @@ static std::atomic<MapPortProtoFlag> g_mapport_current_proto{MapPortProtoFlag::N\n using namespace std::chrono_literals;\n static constexpr auto PORT_MAPPING_REANNOUNCE_PERIOD{20min};\n static constexpr auto PORT_MAPPING_RETRY_PERIOD{5min};\n+static constexpr auto PORT_MAPPING_REANNOUNCE_MARGIN{60s};\n \n-#ifdef USE_NATPMP\n-static uint16_t g_mapport_external_port = 0;\n-static bool NatpmpInit(natpmp_t* natpmp)\n+static bool ProcessPCP()\n {\n-    const int r_init = initnatpmp(natpmp, /* detect gateway automatically */ 0, /* forced gateway - NOT APPLIED*/ 0);\n-    if (r_init == 0) return true;\n-    LogPrintf(\"natpmp: initnatpmp() failed with %d error.\\n\", r_init);\n-    return false;\n-}\n+    // The same nonce is used for all mappings, this is allowed by the spec, and simplifies keeping track of them.\n+    PCPMappingNonce pcp_nonce;\n+    GetRandBytes(pcp_nonce);\n \n-static bool NatpmpDiscover(natpmp_t* natpmp, struct in_addr& external_ipv4_addr)\n-{\n-    const int r_send = sendpublicaddressrequest(natpmp);\n-    if (r_send == 2 /* OK */) {\n-        int r_read;\n-        natpmpresp_t response;\n-        do {\n-            r_read = readnatpmpresponseorretry(natpmp, &response);\n-        } while (r_read == NATPMP_TRYAGAIN);\n-\n-        if (r_read == 0) {\n-            external_ipv4_addr = response.pnu.publicaddress.addr;\n-            return true;\n-        } else if (r_read == NATPMP_ERR_NOGATEWAYSUPPORT) {\n-            LogPrintf(\"natpmp: The gateway does not support NAT-PMP.\\n\");\n+    bool ret = false;\n+    const uint16_t private_port = GetListenPort();\n+    // Request reannounce period plus safety margin.\n+    const uint32_t requested_lifetime = std::chrono::seconds(PORT_MAPPING_REANNOUNCE_PERIOD + PORT_MAPPING_REANNOUNCE_MARGIN).count();\n+    std::chrono::seconds sleep_time;\n+\n+    do {\n+        uint32_t actual_lifetime = requested_lifetime;\n+        ret = false; // Set to true if any mapping succeeds.\n+\n+        // IPv4\n+        std::optional<CNetAddr> gateway4 = QueryDefaultGateway(NET_IPV4);\n+        if (!gateway4) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"pcp: Could not determine IPv4 default gateway\\n\");\n         } else {\n-            LogPrintf(\"natpmp: readnatpmpresponseorretry() for public address failed with %d error.\\n\", r_read);\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"pcp: gateway [IPv4]: %s\\n\", gateway4->ToStringAddr());\n+\n+            // Open a port mapping on whatever local address we have toward the gateway.\n+            struct in_addr inaddr_any;\n+            inaddr_any.s_addr = htonl(INADDR_ANY);\n+            std::optional<MappingResult> res = PCPRequestPortMap(pcp_nonce, *gateway4, CNetAddr(inaddr_any), private_port, requested_lifetime);\n+            if (res) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Info, \"pcp: ExternalIPv4Address:port = %s\\n\", res->external.ToStringAddrPort());\n+                AddLocal(res->external, LOCAL_MAPPED);\n+                ret = true;\n+                actual_lifetime = std::min(actual_lifetime, res->lifetime);\n+            }\n         }\n-    } else {\n-        LogPrintf(\"natpmp: sendpublicaddressrequest() failed with %d error.\\n\", r_send);\n-    }\n \n-    return false;\n-}\n-\n-static bool NatpmpMapping(natpmp_t* natpmp, const struct in_addr& external_ipv4_addr, uint16_t private_port, bool& external_ip_discovered)\n-{\n-    const uint16_t suggested_external_port = g_mapport_external_port ? g_mapport_external_port : private_port;\n-    const int r_send = sendnewportmappingrequest(natpmp, NATPMP_PROTOCOL_TCP, private_port, suggested_external_port, 3600 /*seconds*/);\n-    if (r_send == 12 /* OK */) {\n-        int r_read;\n-        natpmpresp_t response;\n-        do {\n-            r_read = readnatpmpresponseorretry(natpmp, &response);\n-        } while (r_read == NATPMP_TRYAGAIN);\n-\n-        if (r_read == 0) {\n-            auto pm = response.pnu.newportmapping;\n-            if (private_port == pm.privateport && pm.lifetime > 0) {\n-                g_mapport_external_port = pm.mappedpublicport;\n-                const CService external{external_ipv4_addr, pm.mappedpublicport};\n-                if (!external_ip_discovered && fDiscover) {\n-                    AddLocal(external, LOCAL_MAPPED);\n-                    external_ip_discovered = true;\n+        // IPv6\n+        std::optional<CNetAddr> gateway6 = QueryDefaultGateway(NET_IPV6);\n+        if (!gateway6) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"pcp: Could not determine IPv6 default gateway\\n\");",
      "path": "src/mapport.cpp",
      "position": null,
      "original_position": 119,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "6cf4809c6b93e1720dfdfe4e3320cfd8939686b6",
      "in_reply_to_id": 1595583401,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Will keep this open but leave it as-is for now. For IPv4 i'm not currently sure how to check if we have (Internet) networking besides checking for a default gateway, and i'd like to keep the two paths reasonably symmetric. Just checking for publicly routable addresses isn't going to cut it for IPv4.",
      "created_at": "2024-05-16T07:33:03Z",
      "updated_at": "2024-05-16T07:33:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1602770267",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1602770267"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 92,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1603565742",
      "pull_request_review_id": 2061123015,
      "id": 1603565742,
      "node_id": "PRRC_kwDOABII585flHiu",
      "diff_hunk": "@@ -0,0 +1,116 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+#ifdef HAVE_LINUX_ROUTE_H\n+\n+#include <linux/route.h>\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 19,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "39933a53f3a3d29cfebd8252a9b4ddcb48d3965c",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "The following patch uses a netlink socket to get the information from the kernel, that is supported on (at least) Linux and FreeBSD>=13.2:\r\n\r\n<details>\r\n<summary>[patch] get default gateway using a netlink socket</summary>\r\n\r\n```diff\r\n--- a/src/test/netbase_tests.cpp\r\n+++ b/src/test/netbase_tests.cpp\r\n@@ -1,25 +1,34 @@\r\n // Copyright (c) 2012-2022 The Bitcoin Core developers\r\n // Distributed under the MIT software license, see the accompanying\r\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\r\n \r\n+#include <compat/compat.h>\r\n #include <net_permissions.h>\r\n #include <netaddress.h>\r\n #include <netbase.h>\r\n #include <netgroup.h>\r\n #include <protocol.h>\r\n #include <serialize.h>\r\n #include <streams.h>\r\n #include <test/util/setup_common.h>\r\n #include <util/strencodings.h>\r\n+#include <util/syserror.h>\r\n #include <util/translation.h>\r\n \r\n #include <string>\r\n \r\n #include <boost/test/unit_test.hpp>\r\n \r\n+#ifdef __linux__\r\n+#include <linux/rtnetlink.h>\r\n+#elif defined(__FreeBSD__)\r\n+#include <netlink/netlink.h>\r\n+#include <netlink/netlink_route.h>\r\n+#endif\r\n+\r\n using namespace std::literals;\r\n \r\n BOOST_FIXTURE_TEST_SUITE(netbase_tests, BasicTestingSetup)\r\n \r\n static CNetAddr ResolveIP(const std::string& ip)\r\n {\r\n@@ -610,7 +619,100 @@ BOOST_AUTO_TEST_CASE(isbadport)\r\n             ++total_bad_ports;\r\n         }\r\n     }\r\n     BOOST_CHECK_EQUAL(total_bad_ports, 80);\r\n }\r\n \r\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\r\n+{\r\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\r\n+\r\n+    // Create a netlink socket.\r\n+\r\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\r\n+    if (s < 0) {\r\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", SysErrorString(errno));\r\n+        return std::nullopt;\r\n+    }\r\n+    Sock sock{static_cast<SOCKET>(s)};\r\n+\r\n+    // Send request.\r\n+\r\n+    struct {\r\n+        nlmsghdr hdr; ///< Request header.\r\n+        rtmsg data; ///< Request data, a \"route message\".\r\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\r\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\r\n+    } request;\r\n+\r\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\r\n+    const size_t dst_data_len = network == NET_IPV4 ? 4 : 16;\r\n+\r\n+    memset(&request, 0x0, sizeof(request));\r\n+\r\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\r\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\r\n+#ifdef __linux__\r\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\r\n+#endif\r\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\r\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\r\n+    request.data.rtm_family = network == NET_IPV4 ? AF_INET : AF_INET6;\r\n+    request.data.rtm_dst_len = 0; // Prefix length.\r\n+#ifdef __FreeBSD__\r\n+    request.data.rtm_flags = RTM_F_PREFIX;\r\n+#endif\r\n+    request.dst_hdr.nla_type = RTA_DST;\r\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\r\n+\r\n+    if (sock.Send(&request, sizeof(request), 0) != sizeof(request)) {\r\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", SysErrorString(errno));\r\n+        return std::nullopt;\r\n+    }\r\n+\r\n+    // Receive response.\r\n+\r\n+    char response[4096];\r\n+    ssize_t response_len;\r\n+    do {\r\n+        response_len = sock.Recv(response, sizeof(response), 0);\r\n+    } while (response_len < 0 && (errno == EINTR || errno == EAGAIN));\r\n+    if (response_len < 0) {\r\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", SysErrorString(errno));\r\n+        return std::nullopt;\r\n+    }\r\n+\r\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\r\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\r\n+        int remaining_len = RTM_PAYLOAD(hdr);\r\n+        // Iterate over the attributes.\r\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\r\n+            if (attr->rta_type == RTA_GATEWAY) {\r\n+                if (network == NET_IPV4) {\r\n+                    Assume(sizeof(in_addr) == RTA_PAYLOAD(attr));\r\n+                    return CNetAddr{in_addr{.s_addr = *static_cast<decltype(in_addr::s_addr)*>(RTA_DATA(attr))}};\r\n+                } else {\r\n+                    Assume(sizeof(in6_addr) == RTA_PAYLOAD(attr));\r\n+                    in6_addr gw;\r\n+                    std::memcpy(&gw, RTA_DATA(attr), sizeof(gw));\r\n+                    return CNetAddr{gw};\r\n+                }\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    return std::nullopt;\r\n+}\r\n+\r\n+BOOST_AUTO_TEST_CASE(netlink)\r\n+{\r\n+    for (const auto net : {NET_IPV4, NET_IPV6}) {\r\n+        const auto gw{QueryDefaultGateway(net)};\r\n+        if (gw.has_value()) {\r\n+            printf(\"Default %s gateway: %s\\n\", GetNetworkName(net).c_str(), gw->ToStringAddr().c_str());\r\n+        } else {\r\n+            printf(\"No %s default gateway.\\n\", GetNetworkName(net).c_str());\r\n+        }\r\n+    }\r\n+}\r\n+\r\n BOOST_AUTO_TEST_SUITE_END()\r\n```\r\n</details>\r\n\r\nI find the netlink interface a somewhat difficult to grasp.\r\n\r\nhttps://man7.org/linux/man-pages/man7/netlink.7.html\r\nhttps://man7.org/linux/man-pages/man7/rtnetlink.7.html\r\nhttps://man7.org/linux/man-pages/man3/rtnetlink.3.html\r\nhttps://stackoverflow.com/questions/11788326/extract-current-route-from-netlink-message-code-attached\r\nhttps://www.rfc-editor.org/rfc/rfc3549",
      "created_at": "2024-05-16T15:10:54Z",
      "updated_at": "2024-05-16T15:48:39Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1603565742",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1603565742"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 24,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1603770501",
      "pull_request_review_id": 2061450460,
      "id": 1603770501,
      "node_id": "PRRC_kwDOABII585fl5iF",
      "diff_hunk": "@@ -0,0 +1,116 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+#ifdef HAVE_LINUX_ROUTE_H\n+\n+#include <linux/route.h>\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 19,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "39933a53f3a3d29cfebd8252a9b4ddcb48d3965c",
      "in_reply_to_id": 1603565742,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Huh interesting. i didn't know netlink worked for multiple operating systems, that's much better.",
      "created_at": "2024-05-16T17:31:16Z",
      "updated_at": "2024-05-16T17:31:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1603770501",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1603770501"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 24,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1603876259",
      "pull_request_review_id": 2061615847,
      "id": 1603876259,
      "node_id": "PRRC_kwDOABII585fmTWj",
      "diff_hunk": "@@ -0,0 +1,116 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+#ifdef HAVE_LINUX_ROUTE_H\n+\n+#include <linux/route.h>\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 19,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "39933a53f3a3d29cfebd8252a9b4ddcb48d3965c",
      "in_reply_to_id": 1603565742,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "~~Is it possible to get the `scope_id` for IPv6 addresses? At least my router gives me an link-scope address.~~\r\n\r\nEdit: on linux this is `RTA_OIF`, it appears",
      "created_at": "2024-05-16T18:37:25Z",
      "updated_at": "2024-05-16T19:00:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1603876259",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1603876259"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 24,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1604635967",
      "pull_request_review_id": 2062804021,
      "id": 1604635967,
      "node_id": "PRRC_kwDOABII585fpM0_",
      "diff_hunk": "@@ -0,0 +1,116 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+#ifdef HAVE_LINUX_ROUTE_H\n+\n+#include <linux/route.h>\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 19,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "39933a53f3a3d29cfebd8252a9b4ddcb48d3965c",
      "in_reply_to_id": 1603565742,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Here is a standalone program to get the default gateway using a netlink socket:\r\n\r\n<details>\r\n<summary>netlink_get_default_route.cc</summary>\r\n\r\n```cc\r\n#include <arpa/inet.h>\r\n#include <assert.h>\r\n#include <errno.h>\r\n#include <net/if.h>\r\n#include <netinet/in.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <sys/socket.h>\r\n#include <sys/types.h>\r\n#include <unistd.h>\r\n\r\n#ifdef __linux__\r\n#include <linux/rtnetlink.h>\r\n#elif defined(__FreeBSD__)\r\n#include <netlink/netlink.h>\r\n#include <netlink/netlink_route.h>\r\n#endif\r\n\r\nvoid QueryDefaultGateway(sa_family_t family)\r\n{\r\n    // Create a netlink socket.\r\n\r\n    int sock = socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE);\r\n    if (sock < 0) {\r\n        perror(\"socket(AF_NETLINK)\");\r\n        return;\r\n    }\r\n\r\n    // Send request.\r\n\r\n    struct {\r\n        nlmsghdr hdr; ///< Request header.\r\n        rtmsg data; ///< Request data, a \"route message\".\r\n        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\r\n        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\r\n    } request{};\r\n\r\n    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\r\n    const size_t dst_data_len = family == AF_INET ? 4 : 16;\r\n\r\n    request.hdr.nlmsg_type = RTM_GETROUTE;\r\n    request.hdr.nlmsg_flags = NLM_F_REQUEST;\r\n#ifdef __linux__\r\n    // XXX some strange behavior:\r\n    // Linux IPv4 - this must be present, otherwise no gateway is found\r\n    // Linux IPv6 - this must be present, otherwise no gateway is found\r\n    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\r\n    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\r\n    request.hdr.nlmsg_flags |= NLM_F_DUMP;\r\n#endif\r\n    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\r\n    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\r\n    request.data.rtm_family = family;\r\n    request.data.rtm_dst_len = 0; // Prefix length.\r\n    //request.data.rtm_table = RT_TABLE_MAIN;\r\n    //request.data.rtm_protocol = RTPROT_STATIC;\r\n    //request.data.rtm_scope = RT_SCOPE_UNIVERSE;\r\n    //request.data.rtm_type = RTN_UNICAST;\r\n#ifdef __FreeBSD__\r\n    // XXX some strange behavior:\r\n    // Linux IPv4 - this must be absent, otherwise no gateway is found\r\n    // Linux IPv6 - this must be absent, otherwise no gateway is found\r\n    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\r\n    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\r\n    request.data.rtm_flags = RTM_F_PREFIX;\r\n#endif\r\n    request.dst_hdr.nla_type = RTA_DST;\r\n    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\r\n\r\n    if (send(sock, &request, request.hdr.nlmsg_len, 0) != request.hdr.nlmsg_len) {\r\n        fprintf(stderr, \"send() failed to send %u bytes\\n\", request.hdr.nlmsg_len);\r\n        close(sock);\r\n        return;\r\n    }\r\n\r\n    // Receive response.\r\n\r\n    char response[4096];\r\n    ssize_t response_len;\r\n    do {\r\n        response_len = recv(sock, response, sizeof(response), 0);\r\n    } while (response_len < 0 && (errno == EINTR || errno == EAGAIN));\r\n    if (response_len < 0) {\r\n        fprintf(stderr, \"recv(): %s\\n\", strerror(errno));\r\n        close(sock);\r\n        return;\r\n    }\r\n\r\n    for (nlmsghdr *hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\r\n        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\r\n        int remaining_len = RTM_PAYLOAD(hdr);\r\n\r\n        // Iterate over the attributes.\r\n        rtattr* rta_gateway = nullptr;\r\n        int scope_id = 0;\r\n        for (rtattr *attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\r\n            if (attr->rta_type == RTA_GATEWAY) {\r\n                rta_gateway = attr;\r\n            } else if (attr->rta_type == RTA_OIF) {\r\n                assert(sizeof(int) == RTA_PAYLOAD(attr));\r\n                memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\r\n            }\r\n        }\r\n\r\n        // Found gateway?\r\n        if (rta_gateway != nullptr) {\r\n            char buf[256];\r\n            printf(\"%s gateway: %s\",\r\n                   family == AF_INET ? \"IPv4\" : \"IPv6\",\r\n                   inet_ntop(r->rtm_family, RTA_DATA(rta_gateway), buf, sizeof(buf)));\r\n            if (family == AF_INET6) {\r\n                printf(\", scope id: %d\\n\", scope_id);\r\n            } else {\r\n                printf(\"\\n\");\r\n            }\r\n        }\r\n    }\r\n\r\n    close(sock);\r\n}\r\n\r\nint main(int argc, char** argv)\r\n{\r\n    QueryDefaultGateway(AF_INET);\r\n    QueryDefaultGateway(AF_INET6);\r\n    return 0;\r\n}\r\n```\r\n</details>\r\n\r\nIdeally the `#ifdef __linux__` / `#ifdef __FreeBSD__` parts should not be needed. I am not sure if this is due to the above program doing something wrong or is due to a difference in Linux vs FreeBSD implementations. @AlexanderChernikov, @markjdb, any ideas?",
      "created_at": "2024-05-17T09:30:22Z",
      "updated_at": "2024-05-17T09:30:23Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1604635967",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1604635967"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 24,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1604672913",
      "pull_request_review_id": 2062857416,
      "id": 1604672913,
      "node_id": "PRRC_kwDOABII585fpV2R",
      "diff_hunk": "@@ -0,0 +1,206 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = network == NET_IPV4 ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = network == NET_IPV4 ? AF_INET : AF_INET6;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, sizeof(request), 0) != sizeof(request)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", SysErrorString(errno));",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 63,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "841deffd44d7a78452deab39adadbf991249128a",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I realized that in the IPv4 case this would send the trailing 16-4=12 bytes from `request.dst_data[]`. This seems harmless, but better send exactly what's needed:\r\n\r\n```suggestion\r\n    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != request.hdr.nlmsg_len) {\r\n        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", SysErrorString(errno));\r\n```\r\n\r\nAlso, I am not sure if we should worry about partial writes with netlink sockets, maybe the send can be interrupted? There is a convenience method `Sock::SendComplete()`:\r\n\r\n```cc\r\n    try {\r\n        CThreadInterrupt intr;\r\n        sock.SendComplete(Span{reinterpret_cast<const unsigned char*>(&request), request.hdr.nlmsg_len}, 5s, intr);\r\n    } catch (const std::runtime_error& e) {\r\n        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"writing to netlink socket: %s\\n\", e.what());\r\n        return std::nullopt;\r\n    }\r\n```",
      "created_at": "2024-05-17T09:56:08Z",
      "updated_at": "2024-05-17T09:56:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1604672913",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1604672913"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": 62,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 63,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1604736981",
      "pull_request_review_id": 2062948610,
      "id": 1604736981,
      "node_id": "PRRC_kwDOABII585fplfV",
      "diff_hunk": "@@ -0,0 +1,206 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = network == NET_IPV4 ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = network == NET_IPV4 ? AF_INET : AF_INET6;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, sizeof(request), 0) != sizeof(request)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", SysErrorString(errno));",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 63,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "841deffd44d7a78452deab39adadbf991249128a",
      "in_reply_to_id": 1604672913,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "It's a datagram (packet socket), so *partial* writes and reads cannot happen. Every send is interpreted as a new packet. Using `SendComplete` would be a bug.\r\n\r\nTruncated and corrupted packets could happen in the case of UDP, but as NETLINK is a communication interface with the kernel, that would be rare. No retries are needed. Would still want to detect it and error out gracefully, though, for robustness.\r\n\r\n> I realized that in the IPv4 case this would send the trailing 16-4=12 bytes from request.dst_data[]. This seems harmless, but better send exactly what's needed\r\n\r\nAgreed, will change that.",
      "created_at": "2024-05-17T10:32:41Z",
      "updated_at": "2024-05-17T10:35:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1604736981",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1604736981"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": 62,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 63,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1609954791",
      "pull_request_review_id": 2071201793,
      "id": 1609954791,
      "node_id": "PRRC_kwDOABII585f9fXn",
      "diff_hunk": "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+",
      "path": "src/util/netif.cpp",
      "position": 14,
      "original_position": 14,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "bebfafcf98d8ed1432407b7603991d54f7cc26c2",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "bebfafcf98d8ed1432407b7603991d54f7cc26c2: it would be useful to have a quick recap here of which strategy is used by `QueryDefaultGateway` for which OS.\r\n\r\nI think it will be (slightly) more readable to have a single `QueryDefaultGateway` implementation which then calls `QueryDefaultGatewayWindows`, `QueryDefaultGatewayMac` and `QueryDefaultGatewayLinuxBSD`.\r\n\r\nIt can start with:\r\n\r\n```cpp\r\nAssume(network == NET_IPV4 || network == NET_IPV6)\r\n```\r\n\r\nand end with\r\n\r\n```cpp\r\n#else return std::nullopt;\r\n```",
      "created_at": "2024-05-22T13:26:33Z",
      "updated_at": "2024-05-22T13:33:28Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1609954791",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1609954791"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 14,
      "original_line": 14,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610151853",
      "pull_request_review_id": 2071531696,
      "id": 1610151853,
      "node_id": "PRRC_kwDOABII585f-Pet",
      "diff_hunk": "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)",
      "path": "src/util/netif.cpp",
      "position": 17,
      "original_position": 19,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "bebfafcf98d8ed1432407b7603991d54f7cc26c2",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "bebfafcf98d8ed1432407b7603991d54f7cc26c2 presumably netlink only exists in (the rather recent) FreeBSD >= 13.2? For older versions we need to use the same method as macOS? If so, then we probably need to check this stuff in configure.",
      "created_at": "2024-05-22T14:56:04Z",
      "updated_at": "2024-05-22T14:56:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1610151853",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610151853"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 17,
      "original_line": 17,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610209650",
      "pull_request_review_id": 2071626946,
      "id": 1610209650,
      "node_id": "PRRC_kwDOABII585f-dly",
      "diff_hunk": "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)",
      "path": "src/util/netif.cpp",
      "position": 17,
      "original_position": 19,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "bebfafcf98d8ed1432407b7603991d54f7cc26c2",
      "in_reply_to_id": 1610151853,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "That said, it looks like FreeBSD 13.2 is the oldest [supported release](https://www.freebsd.org/security/#sup) and 12 is pretty much unusable: https://forums.freebsd.org/threads/freebsd-12-2-stable-pkg-update-failed.92034/#post-640223\r\n\r\nI was not able to build `bitcoind` on a FreeBSD 13.2 VM:\r\n\r\n<img width=\"723\" alt=\"bsd 13\" src=\"https://github.com/bitcoin/bitcoin/assets/10217/8b4d0ee5-e8e7-4318-8c22-67791a77974c\">\r\n\r\n(I don't have Virtual Box guest editions installed, so having a hard time copying the output)",
      "created_at": "2024-05-22T15:28:13Z",
      "updated_at": "2024-05-22T16:23:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1610209650",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610209650"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 17,
      "original_line": 17,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610286827",
      "pull_request_review_id": 2071757177,
      "id": 1610286827,
      "node_id": "PRRC_kwDOABII585f-wbr",
      "diff_hunk": "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)",
      "path": "src/util/netif.cpp",
      "position": 17,
      "original_position": 19,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "bebfafcf98d8ed1432407b7603991d54f7cc26c2",
      "in_reply_to_id": 1610151853,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "If so i would prefer not supporting it at all for older FreeBSD. It's so rare compared to the other operating systems already, and most of the userbase will be setting their own firewall. But we indeed need to check that it doesn't cause a compilation error.",
      "created_at": "2024-05-22T16:19:20Z",
      "updated_at": "2024-05-22T16:19:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1610286827",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610286827"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 17,
      "original_line": 17,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610299087",
      "pull_request_review_id": 2071776788,
      "id": 1610299087,
      "node_id": "PRRC_kwDOABII585f-zbP",
      "diff_hunk": "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)",
      "path": "src/util/netif.cpp",
      "position": 17,
      "original_position": 19,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "bebfafcf98d8ed1432407b7603991d54f7cc26c2",
      "in_reply_to_id": 1610151853,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> If so i would prefer not supporting it at all for older FreeBSD.\r\n\r\nSeems fine to me.",
      "created_at": "2024-05-22T16:27:36Z",
      "updated_at": "2024-05-22T16:27:36Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1610299087",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610299087"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 17,
      "original_line": 17,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610302369",
      "pull_request_review_id": 2071782134,
      "id": 1610302369,
      "node_id": "PRRC_kwDOABII585f-0Oh",
      "diff_hunk": "@@ -556,11 +556,7 @@ void SetupServerArgs(ArgsManager& argsman)\n #else\n     hidden_args.emplace_back(\"-upnp\");\n #endif\n-#ifdef USE_NATPMP\n-    argsman.AddArg(\"-natpmp\", strprintf(\"Use NAT-PMP to map the listening port (default: %u)\", DEFAULT_NATPMP), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n-#else\n-    hidden_args.emplace_back(\"-natpmp\");\n-#endif // USE_NATPMP\n+    argsman.AddArg(\"-natpmp\", strprintf(\"Use PCP or NATPMP to map the listening port (default: %u)\", DEFAULT_NATPMP), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);",
      "path": "src/init.cpp",
      "position": null,
      "original_position": 9,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "bd2cc38d8afb1c09dfc4a77f5195bf2a9e58ad90",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Concept ACK on keep just using `-natpmp` for both PCP and NAT-PMP.\r\n\r\n(you lost the `-`)",
      "created_at": "2024-05-22T16:30:11Z",
      "updated_at": "2024-05-22T16:30:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1610302369",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610302369"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 559,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610306635",
      "pull_request_review_id": 2071788733,
      "id": 1610306635,
      "node_id": "PRRC_kwDOABII585f-1RL",
      "diff_hunk": "@@ -556,11 +556,7 @@ void SetupServerArgs(ArgsManager& argsman)\n #else\n     hidden_args.emplace_back(\"-upnp\");\n #endif\n-#ifdef USE_NATPMP\n-    argsman.AddArg(\"-natpmp\", strprintf(\"Use NAT-PMP to map the listening port (default: %u)\", DEFAULT_NATPMP), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n-#else\n-    hidden_args.emplace_back(\"-natpmp\");\n-#endif // USE_NATPMP\n+    argsman.AddArg(\"-natpmp\", strprintf(\"Use PCP or NATPMP to map the listening port (default: %u)\", DEFAULT_NATPMP), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);",
      "path": "src/init.cpp",
      "position": null,
      "original_position": 9,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "bd2cc38d8afb1c09dfc4a77f5195bf2a9e58ad90",
      "in_reply_to_id": 1610302369,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Whoops, fixed",
      "created_at": "2024-05-22T16:33:30Z",
      "updated_at": "2024-05-22T16:33:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1610306635",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610306635"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 559,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610320133",
      "pull_request_review_id": 2071809446,
      "id": 1610320133,
      "node_id": "PRRC_kwDOABII585f-4kF",
      "diff_hunk": "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)",
      "path": "src/util/netif.cpp",
      "position": 17,
      "original_position": 19,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "bebfafcf98d8ed1432407b7603991d54f7cc26c2",
      "in_reply_to_id": 1610151853,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Added a version check for at least 13.2.",
      "created_at": "2024-05-22T16:42:33Z",
      "updated_at": "2024-05-22T16:42:33Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1610320133",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610320133"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 17,
      "original_line": 17,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610438227",
      "pull_request_review_id": 2071999619,
      "id": 1610438227,
      "node_id": "PRRC_kwDOABII585f_VZT",
      "diff_hunk": "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", SysErrorString(errno));",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 31,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "82b0bff51fedff2ce5e47cae1c75b9172766d8ef",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "82b0bff51fedff2ce5e47cae1c75b9172766d8ef: the `SysErrorString` documentation says you should call `NetworkErrorString`, though that will in turn just call `SysErrorString`, since this is never called under `WIN32`.",
      "created_at": "2024-05-22T18:11:22Z",
      "updated_at": "2024-05-22T18:56:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1610438227",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610438227"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 31,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610461378",
      "pull_request_review_id": 2071999619,
      "id": 1610461378,
      "node_id": "PRRC_kwDOABII585f_bDC",
      "diff_hunk": "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = network == NET_IPV4 ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;",
      "path": "src/util/netif.cpp",
      "position": 65,
      "original_position": 50,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "82b0bff51fedff2ce5e47cae1c75b9172766d8ef",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "82b0bff51fedff2ce5e47cae1c75b9172766d8ef Why only on linux? It seems to exist on FreeBSD too: https://man.freebsd.org/cgi/man.cgi?netlink(4)",
      "created_at": "2024-05-22T18:28:41Z",
      "updated_at": "2024-05-22T18:56:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1610461378",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610461378"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 65,
      "original_line": 65,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610491684",
      "pull_request_review_id": 2071999619,
      "id": 1610491684,
      "node_id": "PRRC_kwDOABII585f_ick",
      "diff_hunk": "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = network == NET_IPV4 ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = network == NET_IPV4 ? AF_INET : AF_INET6;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 89,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "82b0bff51fedff2ce5e47cae1c75b9172766d8ef",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "82b0bff51fedff2ce5e47cae1c75b9172766d8ef: IIUC this gets the scope id (https://datatracker.ietf.org/doc/html/rfc4007), but we don't do anything with that except in `IPv6ToString`. So maybe we should just ignore this value (`CNetAddr` initialiser defaults it to 0).\r\n\r\nIf we can't drop it, can we be sure that we encounter `RTA_OIF` _before_ `RTA_GATEWAY`? Otherwise `if (rta_gateway != nullptr)` could trigger prematurely.",
      "created_at": "2024-05-22T18:51:34Z",
      "updated_at": "2024-05-22T18:56:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1610491684",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610491684"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 99,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610511267",
      "pull_request_review_id": 2072137357,
      "id": 1610511267,
      "node_id": "PRRC_kwDOABII585f_nOj",
      "diff_hunk": "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = network == NET_IPV4 ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = network == NET_IPV4 ? AF_INET : AF_INET6;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 89,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "82b0bff51fedff2ce5e47cae1c75b9172766d8ef",
      "in_reply_to_id": 1610491684,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I see this was added here: https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1603876259, and I see it's not actually ignored, e.g. `GetSockAddr` uses it. ~But when we connect to the default gateway, only `m_addr` is copied by `GetSockAddr` (which is called by `PCPRequestPortMap`).~ (see below)",
      "created_at": "2024-05-22T19:03:07Z",
      "updated_at": "2024-05-22T19:50:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1610511267",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610511267"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 99,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610537095",
      "pull_request_review_id": 2072177943,
      "id": 1610537095,
      "node_id": "PRRC_kwDOABII585f_tiH",
      "diff_hunk": "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = network == NET_IPV4 ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = network == NET_IPV4 ? AF_INET : AF_INET6;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 89,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "82b0bff51fedff2ce5e47cae1c75b9172766d8ef",
      "in_reply_to_id": 1610491684,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "The scope ID is extremely important for the default gateway, as it tends to be a scope-local address (it wouldn't work at all here without that).",
      "created_at": "2024-05-22T19:26:09Z",
      "updated_at": "2024-05-22T19:43:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1610537095",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610537095"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 99,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610540459",
      "pull_request_review_id": 2072184582,
      "id": 1610540459,
      "node_id": "PRRC_kwDOABII585f_uWr",
      "diff_hunk": "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = network == NET_IPV4 ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = network == NET_IPV4 ? AF_INET : AF_INET6;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 89,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "82b0bff51fedff2ce5e47cae1c75b9172766d8ef",
      "in_reply_to_id": 1610491684,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> If we can't drop it, can we be sure that we encounter RTA_OIF before RTA_GATEWAY? Otherwise if (rta_gateway != nullptr) could trigger prematurely.\r\n\r\nAFAIK the order of the attributes within a record can be arbitrary. But how can this go wrong? The `rta_gateway` check is only after going over all the attributes, right?\r\n\r\nGetSockAddr does copy the `scope_id` too, see https://github.com/bitcoin/bitcoin/blob/master/src/netaddress.cpp#L883",
      "created_at": "2024-05-22T19:29:06Z",
      "updated_at": "2024-05-22T19:31:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1610540459",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610540459"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 99,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610543822",
      "pull_request_review_id": 2072190170,
      "id": 1610543822,
      "node_id": "PRRC_kwDOABII585f_vLO",
      "diff_hunk": "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", SysErrorString(errno));",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 31,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "82b0bff51fedff2ce5e47cae1c75b9172766d8ef",
      "in_reply_to_id": 1610438227,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Right, will update this (though yeah for POSIX operating systems there's no difference).",
      "created_at": "2024-05-22T19:32:31Z",
      "updated_at": "2024-05-22T19:32:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1610543822",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610543822"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 31,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610547164",
      "pull_request_review_id": 2072196100,
      "id": 1610547164,
      "node_id": "PRRC_kwDOABII585f_v_c",
      "diff_hunk": "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = network == NET_IPV4 ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;",
      "path": "src/util/netif.cpp",
      "position": 65,
      "original_position": 50,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "82b0bff51fedff2ce5e47cae1c75b9172766d8ef",
      "in_reply_to_id": 1610461378,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "For the FreeBSD versus Linux differences see the comments in the standalone tool here: https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1604635967\r\nThe netlink calls behave differently on Linux and FreeBSD, we don't know why this is.",
      "created_at": "2024-05-22T19:35:31Z",
      "updated_at": "2024-05-22T19:35:31Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1610547164",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610547164"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 65,
      "original_line": 65,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610559719",
      "pull_request_review_id": 2072216776,
      "id": 1610559719,
      "node_id": "PRRC_kwDOABII585f_zDn",
      "diff_hunk": "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = network == NET_IPV4 ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = network == NET_IPV4 ? AF_INET : AF_INET6;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 89,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "82b0bff51fedff2ce5e47cae1c75b9172766d8ef",
      "in_reply_to_id": 1610491684,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> The rta_gateway check is only after going over all the attributes, right?\r\n\r\nOh wait, I misread the indentation, yes.\r\n\r\n> GetSockAddr does copy the scope_id too,\r\n\r\nIndeed it does",
      "created_at": "2024-05-22T19:46:35Z",
      "updated_at": "2024-05-22T19:50:36Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1610559719",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610559719"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 99,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610568498",
      "pull_request_review_id": 2072230562,
      "id": 1610568498,
      "node_id": "PRRC_kwDOABII585f_1My",
      "diff_hunk": "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = network == NET_IPV4 ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = network == NET_IPV4 ? AF_INET : AF_INET6;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 89,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "82b0bff51fedff2ce5e47cae1c75b9172766d8ef",
      "in_reply_to_id": 1610491684,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> The scope ID is extremely important for the default gateway, as it tends to be a scope-local address.\r\n\r\nAha: https://blogs.infoblox.com/ipv6-coe/fe80-1-is-a-perfectly-valid-ipv6-default-gateway-address/",
      "created_at": "2024-05-22T19:54:40Z",
      "updated_at": "2024-05-22T19:54:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1610568498",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610568498"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 99,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610572586",
      "pull_request_review_id": 2072237518,
      "id": 1610572586,
      "node_id": "PRRC_kwDOABII585f_2Mq",
      "diff_hunk": "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = network == NET_IPV4 ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;",
      "path": "src/util/netif.cpp",
      "position": 65,
      "original_position": 50,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "82b0bff51fedff2ce5e47cae1c75b9172766d8ef",
      "in_reply_to_id": 1610461378,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Ah, some of these comments are worth preserving until we know more or can point to clear documentation elsewhere. I compressed them a bit:\r\n\r\n```cpp\r\n    // Linux IPv4 / IPv6 - this must be present, otherwise no gateway is found\r\n    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\r\n    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\r\n    request.hdr.nlmsg_flags |= NLM_F_DUMP;\r\n\r\n#ifdef __FreeBSD__\r\n    // Linux IPv4 / IPv6 this must be absent, otherwise no gateway is found\r\n    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\r\n    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\r\n    request.data.rtm_flags = RTM_F_PREFIX;\r\n\r\n```",
      "created_at": "2024-05-22T19:58:38Z",
      "updated_at": "2024-05-22T19:58:48Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1610572586",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610572586"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 65,
      "original_line": 65,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610594332",
      "pull_request_review_id": 2072275774,
      "id": 1610594332,
      "node_id": "PRRC_kwDOABII585f_7gc",
      "diff_hunk": "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = network == NET_IPV4 ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;",
      "path": "src/util/netif.cpp",
      "position": 65,
      "original_position": 50,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "82b0bff51fedff2ce5e47cae1c75b9172766d8ef",
      "in_reply_to_id": 1610461378,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Sure, will add that.\r\nFWIW, this is why i initially went with parsing the route tables from `/proc/net/...`, for Linux that's the most straightforward implementation. Netlink is a bit finnicky, though it should be stable (for the same OS) because it's what the tools like `ip` use.",
      "created_at": "2024-05-22T20:18:28Z",
      "updated_at": "2024-05-22T20:18:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1610594332",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1610594332"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 65,
      "original_line": 65,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611240354",
      "pull_request_review_id": 2073236638,
      "id": 1611240354,
      "node_id": "PRRC_kwDOABII585gCZOi",
      "diff_hunk": "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+",
      "path": "src/util/netif.cpp",
      "position": 14,
      "original_position": 14,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "bebfafcf98d8ed1432407b7603991d54f7cc26c2",
      "in_reply_to_id": 1609954791,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Agree, i think i would prefer\r\n`QueryDefaultGatewayNetlink`\r\n`QueryDefaultGatewaySysctl`\r\n`QueryDefaultGatewayWin32` -- only the WIN32 one is truly OS specific, the other ones are POSIX-ish\r\n",
      "created_at": "2024-05-23T08:26:58Z",
      "updated_at": "2024-05-23T08:26:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611240354",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611240354"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 14,
      "original_line": 14,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611259233",
      "pull_request_review_id": 2073273200,
      "id": 1611259233,
      "node_id": "PRRC_kwDOABII585gCd1h",
      "diff_hunk": "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = network == NET_IPV4 ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = network == NET_IPV4 ? AF_INET : AF_INET6;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (network == NET_IPV4) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (network == NET_IPV6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+    if (network == NET_IPV4) {\n+        destination_address.si_family = AF_INET;\n+    } else if(network == NET_IPV6) {\n+        destination_address.si_family = AF_INET6;\n+    } else {\n+        return std::nullopt;\n+    }\n+\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", SysErrorString(status));",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 139,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "82b0bff51fedff2ce5e47cae1c75b9172766d8ef",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Unlike the linux code, here it does matter to call `NetworkErrorString`, because it calls `Win32ErrorString`, which calls `FormatMessage(W)` as the docs recommend: https://learn.microsoft.com/en-us/windows/win32/api/iphlpapi/nf-iphlpapi-getbestinterfaceex  \r\n\r\nMy understanding is that using `strerror_s` (called by SysErrorString) here would be wrong:  https://stackoverflow.com/a/20057368\r\n\r\nI wonder if we can prevent doing that by accident.",
      "created_at": "2024-05-23T08:36:01Z",
      "updated_at": "2024-05-23T08:36:01Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611259233",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611259233"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 139,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611261160",
      "pull_request_review_id": 2073276171,
      "id": 1611261160,
      "node_id": "PRRC_kwDOABII585gCeTo",
      "diff_hunk": "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = network == NET_IPV4 ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = network == NET_IPV4 ? AF_INET : AF_INET6;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (network == NET_IPV4) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (network == NET_IPV6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+    if (network == NET_IPV4) {\n+        destination_address.si_family = AF_INET;\n+    } else if(network == NET_IPV6) {\n+        destination_address.si_family = AF_INET6;\n+    } else {\n+        return std::nullopt;\n+    }\n+\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", SysErrorString(status));",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 139,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "82b0bff51fedff2ce5e47cae1c75b9172766d8ef",
      "in_reply_to_id": 1611259233,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "That said, this Windows code is a lot simpler than the Linux stuff above (_ducks..._).",
      "created_at": "2024-05-23T08:37:16Z",
      "updated_at": "2024-05-23T08:37:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611261160",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611261160"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 139,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611265859",
      "pull_request_review_id": 2073283651,
      "id": 1611265859,
      "node_id": "PRRC_kwDOABII585gCfdD",
      "diff_hunk": "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = network == NET_IPV4 ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = network == NET_IPV4 ? AF_INET : AF_INET6;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (network == NET_IPV4) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (network == NET_IPV6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+    if (network == NET_IPV4) {\n+        destination_address.si_family = AF_INET;\n+    } else if(network == NET_IPV6) {\n+        destination_address.si_family = AF_INET6;\n+    } else {\n+        return std::nullopt;\n+    }\n+\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", SysErrorString(status));",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 139,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "82b0bff51fedff2ce5e47cae1c75b9172766d8ef",
      "in_reply_to_id": 1611259233,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "OHH, my thinking was that it's a WIN32 API function, not a network function. So i thought `SysErrorString` would be correct. But i think you're right. \"SysError\" is more like \"posix errno emulation error\". Which is not what is needed here.",
      "created_at": "2024-05-23T08:40:35Z",
      "updated_at": "2024-05-23T08:40:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611265859",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611265859"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 139,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611280293",
      "pull_request_review_id": 2073308003,
      "id": 1611280293,
      "node_id": "PRRC_kwDOABII585gCi-l",
      "diff_hunk": "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = network == NET_IPV4 ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = network == NET_IPV4 ? AF_INET : AF_INET6;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (network == NET_IPV4) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (network == NET_IPV6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+    if (network == NET_IPV4) {\n+        destination_address.si_family = AF_INET;\n+    } else if(network == NET_IPV6) {\n+        destination_address.si_family = AF_INET6;\n+    } else {\n+        return std::nullopt;\n+    }\n+\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", SysErrorString(status));",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 139,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "82b0bff51fedff2ce5e47cae1c75b9172766d8ef",
      "in_reply_to_id": 1611259233,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> That said, this Windows code is a lot simpler than the Linux stuff above (ducks...).\r\n\r\nYou mean that centrally-controlled proprietary OSes sometimes have well-documented API's that consider use-cases, while FOSS often uses haphazard grabbag API's that were grown in accordance with one tool (where everyone is expected to parse text output of-)... or some custom library, with equally confusing interface. you can just say that out loud here you know... 😓 \r\nStandards like RFCs, and POSIX (ignoring everyone's custom extensions) are rare exceptions.",
      "created_at": "2024-05-23T08:49:30Z",
      "updated_at": "2024-05-23T08:49:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611280293",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611280293"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 139,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611345455",
      "pull_request_review_id": 2073411892,
      "id": 1611345455,
      "node_id": "PRRC_kwDOABII585gCy4v",
      "diff_hunk": "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = network == NET_IPV4 ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = network == NET_IPV4 ? AF_INET : AF_INET6;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (network == NET_IPV4) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (network == NET_IPV6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+    if (network == NET_IPV4) {\n+        destination_address.si_family = AF_INET;\n+    } else if(network == NET_IPV6) {\n+        destination_address.si_family = AF_INET6;\n+    } else {\n+        return std::nullopt;\n+    }\n+\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", SysErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, SysErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    if (network == NET_IPV4) {\n+        Assume(best_route.NextHop.si_family == AF_INET);",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 153,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "82b0bff51fedff2ce5e47cae1c75b9172766d8ef",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Maybe also check that `NextHop` is not 0.0.0.0 (::/0 for IPv6 below). It's not entirely clear to me from the documentation if that can realistically happen, but doesn't hurt to check either.",
      "created_at": "2024-05-23T09:29:51Z",
      "updated_at": "2024-05-23T09:30:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611345455",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611345455"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 153,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611410019",
      "pull_request_review_id": 2073514261,
      "id": 1611410019,
      "node_id": "PRRC_kwDOABII585gDCpj",
      "diff_hunk": "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = network == NET_IPV4 ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = network == NET_IPV4 ? AF_INET : AF_INET6;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (network == NET_IPV4) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (network == NET_IPV6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+    if (network == NET_IPV4) {\n+        destination_address.si_family = AF_INET;\n+    } else if(network == NET_IPV6) {\n+        destination_address.si_family = AF_INET6;\n+    } else {\n+        return std::nullopt;\n+    }\n+\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", SysErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, SysErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    if (network == NET_IPV4) {\n+        Assume(best_route.NextHop.si_family == AF_INET);\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(network == NET_IPV6) {\n+        Assume(best_route.NextHop.si_family == AF_INET6);\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+\n+// Ensure correct alignment for sockaddrs.\n+#define ROUNDUP(a) \\\n+    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(uint32_t) - 1))) : sizeof(uint32_t))\n+\n+static std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    // MacOS: Get default gateway from route table.\n+    // See man page for route(4) for the format.\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+    int family;\n+    if (network == NET_IPV4) {\n+        family = AF_INET;",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 188,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "82b0bff51fedff2ce5e47cae1c75b9172766d8ef",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Alternatively you could store `net.route.0.inet[4].flags.gateway` here and use `sysctlbyname` below, avoiding the need to construct `mib[]`. Not sure if that's better though, because it's nice to be able to lookup constants like `NET_RT_FLAGS` in headers.",
      "created_at": "2024-05-23T10:17:18Z",
      "updated_at": "2024-05-23T10:17:19Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611410019",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611410019"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 188,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611411388",
      "pull_request_review_id": 2073516447,
      "id": 1611411388,
      "node_id": "PRRC_kwDOABII585gDC-8",
      "diff_hunk": "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = network == NET_IPV4 ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = network == NET_IPV4 ? AF_INET : AF_INET6;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (network == NET_IPV4) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (network == NET_IPV6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+    if (network == NET_IPV4) {\n+        destination_address.si_family = AF_INET;\n+    } else if(network == NET_IPV6) {\n+        destination_address.si_family = AF_INET6;\n+    } else {\n+        return std::nullopt;\n+    }\n+\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", SysErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, SysErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    if (network == NET_IPV4) {\n+        Assume(best_route.NextHop.si_family == AF_INET);",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 153,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "82b0bff51fedff2ce5e47cae1c75b9172766d8ef",
      "in_reply_to_id": 1611345455,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Maybe a general \"is the default gateway address sane\" check might sense? though, up to some point if the OS returns a weird address who are we to question it. Can't get too paranoid about that. The worst that could happen is sending to 0.0.0.0, which wouldn't result in any bad things beyond an error.\r\n\r\nOr do you mean this from a \"what happens if there is no default gateway configured\" angle? yes, we'll have to check what it does in that case. Though i'd expect the call to `GetBestRoute` to fail.",
      "created_at": "2024-05-23T10:18:30Z",
      "updated_at": "2024-05-23T10:28:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611411388",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611411388"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 153,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611416943",
      "pull_request_review_id": 2073525398,
      "id": 1611416943,
      "node_id": "PRRC_kwDOABII585gDEVv",
      "diff_hunk": "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = network == NET_IPV4 ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = network == NET_IPV4 ? AF_INET : AF_INET6;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (network == NET_IPV4) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (network == NET_IPV6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+    if (network == NET_IPV4) {\n+        destination_address.si_family = AF_INET;\n+    } else if(network == NET_IPV6) {\n+        destination_address.si_family = AF_INET6;\n+    } else {\n+        return std::nullopt;\n+    }\n+\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", SysErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, SysErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    if (network == NET_IPV4) {\n+        Assume(best_route.NextHop.si_family == AF_INET);\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(network == NET_IPV6) {\n+        Assume(best_route.NextHop.si_family == AF_INET6);\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+\n+// Ensure correct alignment for sockaddrs.\n+#define ROUNDUP(a) \\\n+    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(uint32_t) - 1))) : sizeof(uint32_t))\n+\n+static std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    // MacOS: Get default gateway from route table.\n+    // See man page for route(4) for the format.\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+    int family;\n+    if (network == NET_IPV4) {\n+        family = AF_INET;",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 188,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "82b0bff51fedff2ce5e47cae1c75b9172766d8ef",
      "in_reply_to_id": 1611410019,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "i prefer using constants to string based APIs, if given the choice. This avoids say, typos.",
      "created_at": "2024-05-23T10:23:11Z",
      "updated_at": "2024-05-23T10:23:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611416943",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611416943"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 188,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611430621",
      "pull_request_review_id": 2073546134,
      "id": 1611430621,
      "node_id": "PRRC_kwDOABII585gDHrd",
      "diff_hunk": "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = network == NET_IPV4 ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = network == NET_IPV4 ? AF_INET : AF_INET6;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (network == NET_IPV4) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (network == NET_IPV6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+    if (network == NET_IPV4) {\n+        destination_address.si_family = AF_INET;\n+    } else if(network == NET_IPV6) {\n+        destination_address.si_family = AF_INET6;\n+    } else {\n+        return std::nullopt;\n+    }\n+\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", SysErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, SysErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    if (network == NET_IPV4) {\n+        Assume(best_route.NextHop.si_family == AF_INET);",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 153,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "82b0bff51fedff2ce5e47cae1c75b9172766d8ef",
      "in_reply_to_id": 1611345455,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "OK, you're right, this could happen: https://learn.microsoft.com/en-us/windows/win32/api/netioapi/ns-netioapi-mib_ipforward_row2\r\n\r\n> NextHop\r\n>\r\n> Type: [SOCKADDR_INET](https://learn.microsoft.com/en-us/windows/desktop/api/ws2ipdef/ns-ws2ipdef-sockaddr_inet)\r\n>\r\n> For a remote route, the IP address of the next system or gateway en route. If the route is to a local loopback address or an IP address on the local link, the next hop is unspecified (all zeros). For a local loopback route, this member should be an IPv4 address of 0.0.0.0 for an IPv4 route entry or an IPv6 address of 0::0 for an IPv6 route entry.\r\n\r\nMaybe this is true for the other operating systems as well, if the gateway address is `.IsBindAny()` it should be considered as absent.\r\n\r\nEdit: done",
      "created_at": "2024-05-23T10:30:46Z",
      "updated_at": "2024-05-23T11:36:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611430621",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611430621"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 153,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611456690",
      "pull_request_review_id": 2073590059,
      "id": 1611456690,
      "node_id": "PRRC_kwDOABII585gDOCy",
      "diff_hunk": "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = network == NET_IPV4 ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = network == NET_IPV4 ? AF_INET : AF_INET6;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (network == NET_IPV4) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (network == NET_IPV6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+    if (network == NET_IPV4) {\n+        destination_address.si_family = AF_INET;\n+    } else if(network == NET_IPV6) {\n+        destination_address.si_family = AF_INET6;\n+    } else {\n+        return std::nullopt;\n+    }\n+\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", SysErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, SysErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    if (network == NET_IPV4) {\n+        Assume(best_route.NextHop.si_family == AF_INET);\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(network == NET_IPV6) {\n+        Assume(best_route.NextHop.si_family == AF_INET6);\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+\n+// Ensure correct alignment for sockaddrs.\n+#define ROUNDUP(a) \\\n+    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(uint32_t) - 1))) : sizeof(uint32_t))\n+\n+static std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    // MacOS: Get default gateway from route table.\n+    // See man page for route(4) for the format.\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+    int family;\n+    if (network == NET_IPV4) {\n+        family = AF_INET;",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 188,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "82b0bff51fedff2ce5e47cae1c75b9172766d8ef",
      "in_reply_to_id": 1611410019,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Seems we could factor out `AddressFamilyFromNetwork` at least, this is repeated in literally every implementation 😄 \r\n\r\nEdit: in `netaddress.h` there is `CService::GetSAFamily()` -- so close but not... sigh.\r\nEdit: done",
      "created_at": "2024-05-23T10:47:25Z",
      "updated_at": "2024-05-23T11:36:42Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611456690",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611456690"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 188,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611522537",
      "pull_request_review_id": 2073699412,
      "id": 1611522537,
      "node_id": "PRRC_kwDOABII585gDeHp",
      "diff_hunk": "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+",
      "path": "src/util/netif.cpp",
      "position": 14,
      "original_position": 14,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "bebfafcf98d8ed1432407b7603991d54f7cc26c2",
      "in_reply_to_id": 1609954791,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "OK, i went for `QueryDefaultGatewayImpl` for now, with an outer function. Naming it different things on different platforms means having to repeat the `#ifdef` forest, which isn't really worth the slight increase in clarity imo.",
      "created_at": "2024-05-23T11:40:08Z",
      "updated_at": "2024-05-23T11:40:08Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611522537",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611522537"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 14,
      "original_line": 14,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611597515",
      "pull_request_review_id": 2073809550,
      "id": 1611597515,
      "node_id": "PRRC_kwDOABII585gDwbL",
      "diff_hunk": "@@ -0,0 +1,287 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1302000)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = family == AF_INET ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    // Linux IPv4 / IPv6 - this must be present, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = family;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    // Linux IPv4 / IPv6 this must be absent, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (family == AF_INET) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (family == AF_INET6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    destination_address.si_family = family;\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    Assume(best_route.NextHop.si_family == family);\n+    if (family == AF_INET) {\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(family == AF_INET6) {\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+\n+// Ensure correct alignment for sockaddrs.\n+#define ROUNDUP(a) \\\n+    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(uint32_t) - 1))) : sizeof(uint32_t))\n+\n+static std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // MacOS: Get default gateway from route table.\n+    // See man page for route(4) for the format.\n+\n+    // net.route.0.inet[6].flags.gateway\n+    int mib[] = {CTL_NET, PF_ROUTE, 0, family, NET_RT_FLAGS, RTF_GATEWAY};\n+    size_t l = 0;\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), 0, &l, 0, 0) < 0) {",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 185,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "89ac09777d4d60a331fe1c482d87ecdd1aeb01a0",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Could make this slightly more readable with comments and two nullptr:\r\n\r\n```cpp\r\nif (sysctl(/*name=*/mib, /*namelen=*/sizeof(mib) / sizeof(int), /*oldp=*/nullptr, /*oldlenp=*/&l, /*newp=*/nullptr, /*newlen=*/0) < 0) {\r\n```",
      "created_at": "2024-05-23T12:22:06Z",
      "updated_at": "2024-05-23T13:50:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611597515",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611597515"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 185,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611597943",
      "pull_request_review_id": 2073809550,
      "id": 1611597943,
      "node_id": "PRRC_kwDOABII585gDwh3",
      "diff_hunk": "@@ -0,0 +1,287 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1302000)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = family == AF_INET ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    // Linux IPv4 / IPv6 - this must be present, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = family;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    // Linux IPv4 / IPv6 this must be absent, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (family == AF_INET) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (family == AF_INET6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    destination_address.si_family = family;\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    Assume(best_route.NextHop.si_family == family);\n+    if (family == AF_INET) {\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(family == AF_INET6) {\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+\n+// Ensure correct alignment for sockaddrs.\n+#define ROUNDUP(a) \\\n+    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(uint32_t) - 1))) : sizeof(uint32_t))\n+\n+static std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // MacOS: Get default gateway from route table.\n+    // See man page for route(4) for the format.\n+\n+    // net.route.0.inet[6].flags.gateway\n+    int mib[] = {CTL_NET, PF_ROUTE, 0, family, NET_RT_FLAGS, RTF_GATEWAY};\n+    size_t l = 0;\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), 0, &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl length of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    std::vector<std::byte> buf(l);\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), buf.data(), &l, 0, 0) < 0) {",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 190,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "89ac09777d4d60a331fe1c482d87ecdd1aeb01a0",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```cpp\r\nif (sysctl(/*name=*/mib, /*namelen=*/sizeof(mib) / sizeof(int), /*oldp=*/buf.data(), /*oldlenp=*/&l, /*newp=*/nullptr, /*newlen=*/0) < 0) {\r\n```",
      "created_at": "2024-05-23T12:22:26Z",
      "updated_at": "2024-05-23T13:50:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611597943",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611597943"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 190,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611600021",
      "pull_request_review_id": 2073809550,
      "id": 1611600021,
      "node_id": "PRRC_kwDOABII585gDxCV",
      "diff_hunk": "@@ -0,0 +1,287 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1302000)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = family == AF_INET ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    // Linux IPv4 / IPv6 - this must be present, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = family;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    // Linux IPv4 / IPv6 this must be absent, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (family == AF_INET) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (family == AF_INET6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    destination_address.si_family = family;\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    Assume(best_route.NextHop.si_family == family);\n+    if (family == AF_INET) {\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(family == AF_INET6) {\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+\n+// Ensure correct alignment for sockaddrs.\n+#define ROUNDUP(a) \\\n+    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(uint32_t) - 1))) : sizeof(uint32_t))\n+\n+static std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // MacOS: Get default gateway from route table.\n+    // See man page for route(4) for the format.\n+\n+    // net.route.0.inet[6].flags.gateway\n+    int mib[] = {CTL_NET, PF_ROUTE, 0, family, NET_RT_FLAGS, RTF_GATEWAY};\n+    size_t l = 0;",
      "path": "src/util/netif.cpp",
      "position": 193,
      "original_position": 184,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "89ac09777d4d60a331fe1c482d87ecdd1aeb01a0",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "A useful hint to the reader what's going on here, and where it's documented:\r\n\r\n```cpp\r\n    // The size of the available data can be determined by calling sysctl() with\r\n    // the NULL argument for oldp. See sysctl(3).\r\n```",
      "created_at": "2024-05-23T12:24:04Z",
      "updated_at": "2024-05-23T13:50:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611600021",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611600021"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 193,
      "original_line": 193,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611637097",
      "pull_request_review_id": 2073809550,
      "id": 1611637097,
      "node_id": "PRRC_kwDOABII585gD6Fp",
      "diff_hunk": "@@ -0,0 +1,287 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1302000)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = family == AF_INET ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    // Linux IPv4 / IPv6 - this must be present, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = family;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    // Linux IPv4 / IPv6 this must be absent, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (family == AF_INET) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (family == AF_INET6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    destination_address.si_family = family;\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    Assume(best_route.NextHop.si_family == family);\n+    if (family == AF_INET) {\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(family == AF_INET6) {\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+\n+// Ensure correct alignment for sockaddrs.\n+#define ROUNDUP(a) \\\n+    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(uint32_t) - 1))) : sizeof(uint32_t))\n+\n+static std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // MacOS: Get default gateway from route table.\n+    // See man page for route(4) for the format.\n+\n+    // net.route.0.inet[6].flags.gateway\n+    int mib[] = {CTL_NET, PF_ROUTE, 0, family, NET_RT_FLAGS, RTF_GATEWAY};\n+    size_t l = 0;\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), 0, &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl length of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    std::vector<std::byte> buf(l);\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), buf.data(), &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl data of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    const struct rt_msghdr* rt = nullptr;\n+    for (const std::byte* p = buf.data(); p < buf.data() + buf.size(); p += rt->rtm_msglen) {",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 195,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "89ac09777d4d60a331fe1c482d87ecdd1aeb01a0",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I guess you can't do something closer to `for (const struct rt_msghdr* rt : buf)` (somehow passing in `rt->rtm_msglen`).",
      "created_at": "2024-05-23T12:49:56Z",
      "updated_at": "2024-05-23T13:53:19Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611637097",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611637097"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 195,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611661588",
      "pull_request_review_id": 2073809550,
      "id": 1611661588,
      "node_id": "PRRC_kwDOABII585gEAEU",
      "diff_hunk": "@@ -0,0 +1,287 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1302000)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = family == AF_INET ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    // Linux IPv4 / IPv6 - this must be present, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = family;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    // Linux IPv4 / IPv6 this must be absent, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (family == AF_INET) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (family == AF_INET6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    destination_address.si_family = family;\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    Assume(best_route.NextHop.si_family == family);\n+    if (family == AF_INET) {\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(family == AF_INET6) {\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+\n+// Ensure correct alignment for sockaddrs.\n+#define ROUNDUP(a) \\\n+    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(uint32_t) - 1))) : sizeof(uint32_t))\n+\n+static std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // MacOS: Get default gateway from route table.\n+    // See man page for route(4) for the format.\n+\n+    // net.route.0.inet[6].flags.gateway\n+    int mib[] = {CTL_NET, PF_ROUTE, 0, family, NET_RT_FLAGS, RTF_GATEWAY};\n+    size_t l = 0;\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), 0, &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl length of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    std::vector<std::byte> buf(l);\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), buf.data(), &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl data of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    const struct rt_msghdr* rt = nullptr;\n+    for (const std::byte* p = buf.data(); p < buf.data() + buf.size(); p += rt->rtm_msglen) {\n+        // Iterate over routing entry addresses, get destination and gateway (if present).\n+        rt = (const struct rt_msghdr*)p;",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 197,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "89ac09777d4d60a331fe1c482d87ecdd1aeb01a0",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Do we want to check `rt->rtm_errno` first?\r\n\r\n(if there's an error then probably no bit flags are set, but who knows)",
      "created_at": "2024-05-23T13:07:04Z",
      "updated_at": "2024-05-23T13:54:18Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611661588",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611661588"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 197,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611691990",
      "pull_request_review_id": 2073809550,
      "id": 1611691990,
      "node_id": "PRRC_kwDOABII585gEHfW",
      "diff_hunk": "@@ -0,0 +1,287 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1302000)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = family == AF_INET ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    // Linux IPv4 / IPv6 - this must be present, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = family;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    // Linux IPv4 / IPv6 this must be absent, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (family == AF_INET) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (family == AF_INET6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    destination_address.si_family = family;\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    Assume(best_route.NextHop.si_family == family);\n+    if (family == AF_INET) {\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(family == AF_INET6) {\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+\n+// Ensure correct alignment for sockaddrs.\n+#define ROUNDUP(a) \\\n+    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(uint32_t) - 1))) : sizeof(uint32_t))\n+\n+static std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // MacOS: Get default gateway from route table.\n+    // See man page for route(4) for the format.\n+\n+    // net.route.0.inet[6].flags.gateway\n+    int mib[] = {CTL_NET, PF_ROUTE, 0, family, NET_RT_FLAGS, RTF_GATEWAY};\n+    size_t l = 0;\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), 0, &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl length of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    std::vector<std::byte> buf(l);\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), buf.data(), &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl data of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    const struct rt_msghdr* rt = nullptr;\n+    for (const std::byte* p = buf.data(); p < buf.data() + buf.size(); p += rt->rtm_msglen) {\n+        // Iterate over routing entry addresses, get destination and gateway (if present).\n+        rt = (const struct rt_msghdr*)p;\n+        const struct sockaddr* sa = (const struct sockaddr*)(rt + 1);",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 198,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "89ac09777d4d60a331fe1c482d87ecdd1aeb01a0",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```cpp\r\n// We only read from this address if a rtm_addrs bit flag is set.\r\n```\r\n",
      "created_at": "2024-05-23T13:22:23Z",
      "updated_at": "2024-05-23T13:50:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611691990",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611691990"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 198,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611729605",
      "pull_request_review_id": 2073809550,
      "id": 1611729605,
      "node_id": "PRRC_kwDOABII585gEQrF",
      "diff_hunk": "@@ -0,0 +1,287 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1302000)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = family == AF_INET ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    // Linux IPv4 / IPv6 - this must be present, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = family;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    // Linux IPv4 / IPv6 this must be absent, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (family == AF_INET) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (family == AF_INET6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    destination_address.si_family = family;\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    Assume(best_route.NextHop.si_family == family);\n+    if (family == AF_INET) {\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(family == AF_INET6) {\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+\n+// Ensure correct alignment for sockaddrs.\n+#define ROUNDUP(a) \\\n+    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(uint32_t) - 1))) : sizeof(uint32_t))\n+\n+static std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // MacOS: Get default gateway from route table.\n+    // See man page for route(4) for the format.\n+\n+    // net.route.0.inet[6].flags.gateway\n+    int mib[] = {CTL_NET, PF_ROUTE, 0, family, NET_RT_FLAGS, RTF_GATEWAY};\n+    size_t l = 0;\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), 0, &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl length of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    std::vector<std::byte> buf(l);\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), buf.data(), &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl data of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    const struct rt_msghdr* rt = nullptr;\n+    for (const std::byte* p = buf.data(); p < buf.data() + buf.size(); p += rt->rtm_msglen) {\n+        // Iterate over routing entry addresses, get destination and gateway (if present).\n+        rt = (const struct rt_msghdr*)p;\n+        const struct sockaddr* sa = (const struct sockaddr*)(rt + 1);\n+        std::optional<CNetAddr> dst;\n+        std::optional<CNetAddr> gateway;\n+        for (int i = 0; i < RTAX_MAX; i++) {\n+            if (rt->rtm_addrs & (1 << i)) {\n+                if (i == RTAX_DST) {\n+                    dst = FromSockAddr(sa);\n+                } else if (i == RTAX_GATEWAY) {\n+                    gateway = FromSockAddr(sa);\n+                }",
      "path": "src/util/netif.cpp",
      "position": 223,
      "original_position": 207,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "89ac09777d4d60a331fe1c482d87ecdd1aeb01a0",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```cpp\r\n// Skip sockaddr entries for bit flags we're not interested in,\r\n// move cursor.\r\n```",
      "created_at": "2024-05-23T13:45:51Z",
      "updated_at": "2024-05-23T13:50:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611729605",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611729605"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 223,
      "original_line": 223,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611731634",
      "pull_request_review_id": 2073809550,
      "id": 1611731634,
      "node_id": "PRRC_kwDOABII585gERKy",
      "diff_hunk": "@@ -0,0 +1,287 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1302000)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = family == AF_INET ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    // Linux IPv4 / IPv6 - this must be present, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = family;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    // Linux IPv4 / IPv6 this must be absent, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (family == AF_INET) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (family == AF_INET6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    destination_address.si_family = family;\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    Assume(best_route.NextHop.si_family == family);\n+    if (family == AF_INET) {\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(family == AF_INET6) {\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+\n+// Ensure correct alignment for sockaddrs.\n+#define ROUNDUP(a) \\\n+    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(uint32_t) - 1))) : sizeof(uint32_t))\n+\n+static std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // MacOS: Get default gateway from route table.\n+    // See man page for route(4) for the format.\n+\n+    // net.route.0.inet[6].flags.gateway\n+    int mib[] = {CTL_NET, PF_ROUTE, 0, family, NET_RT_FLAGS, RTF_GATEWAY};\n+    size_t l = 0;\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), 0, &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl length of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    std::vector<std::byte> buf(l);\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), buf.data(), &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl data of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    const struct rt_msghdr* rt = nullptr;\n+    for (const std::byte* p = buf.data(); p < buf.data() + buf.size(); p += rt->rtm_msglen) {\n+        // Iterate over routing entry addresses, get destination and gateway (if present).\n+        rt = (const struct rt_msghdr*)p;\n+        const struct sockaddr* sa = (const struct sockaddr*)(rt + 1);\n+        std::optional<CNetAddr> dst;\n+        std::optional<CNetAddr> gateway;\n+        for (int i = 0; i < RTAX_MAX; i++) {\n+            if (rt->rtm_addrs & (1 << i)) {\n+                if (i == RTAX_DST) {\n+                    dst = FromSockAddr(sa);\n+                } else if (i == RTAX_GATEWAY) {\n+                    gateway = FromSockAddr(sa);\n+                }\n+                sa = (const struct sockaddr*)((std::byte*)sa + ROUNDUP(sa->sa_len));",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 208,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "89ac09777d4d60a331fe1c482d87ecdd1aeb01a0",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "This seems quite brittle and I don't fully understand it. I did test that it seems necessary, e.g. doing `sa++;` causes it to not map IPv6 ports. If I look at `struct sockaddr_storage` I'm seeing `_SS_ALIGNSIZE   (sizeof(__int64_t)`, but using `uint64_t` instead of `uint32_t` in your `ROUNDUP` also doesn't work.",
      "created_at": "2024-05-23T13:47:02Z",
      "updated_at": "2024-05-23T13:50:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611731634",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611731634"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 208,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611755766",
      "pull_request_review_id": 2074073556,
      "id": 1611755766,
      "node_id": "PRRC_kwDOABII585gEXD2",
      "diff_hunk": "@@ -0,0 +1,287 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1302000)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = family == AF_INET ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    // Linux IPv4 / IPv6 - this must be present, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = family;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    // Linux IPv4 / IPv6 this must be absent, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (family == AF_INET) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (family == AF_INET6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    destination_address.si_family = family;\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    Assume(best_route.NextHop.si_family == family);\n+    if (family == AF_INET) {\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(family == AF_INET6) {\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+\n+// Ensure correct alignment for sockaddrs.\n+#define ROUNDUP(a) \\\n+    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(uint32_t) - 1))) : sizeof(uint32_t))\n+\n+static std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // MacOS: Get default gateway from route table.\n+    // See man page for route(4) for the format.\n+\n+    // net.route.0.inet[6].flags.gateway\n+    int mib[] = {CTL_NET, PF_ROUTE, 0, family, NET_RT_FLAGS, RTF_GATEWAY};\n+    size_t l = 0;\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), 0, &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl length of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    std::vector<std::byte> buf(l);\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), buf.data(), &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl data of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    const struct rt_msghdr* rt = nullptr;\n+    for (const std::byte* p = buf.data(); p < buf.data() + buf.size(); p += rt->rtm_msglen) {\n+        // Iterate over routing entry addresses, get destination and gateway (if present).\n+        rt = (const struct rt_msghdr*)p;\n+        const struct sockaddr* sa = (const struct sockaddr*)(rt + 1);\n+        std::optional<CNetAddr> dst;\n+        std::optional<CNetAddr> gateway;\n+        for (int i = 0; i < RTAX_MAX; i++) {\n+            if (rt->rtm_addrs & (1 << i)) {\n+                if (i == RTAX_DST) {\n+                    dst = FromSockAddr(sa);\n+                } else if (i == RTAX_GATEWAY) {\n+                    gateway = FromSockAddr(sa);\n+                }\n+                sa = (const struct sockaddr*)((std::byte*)sa + ROUNDUP(sa->sa_len));",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 208,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "89ac09777d4d60a331fe1c482d87ecdd1aeb01a0",
      "in_reply_to_id": 1611731634,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "i'm not sure either, i see it in some other libraries, but no alignment is mentioned in the manual page for `route` at all (which implies they're just back-to-back, no matter what). Leaving out `ROUNDUP` works fine btw. Might just delete it.\r\n\r\nEdit: yes, using `long` or `uint64_t` breaks IPv6. Also they're variable-length so doing just `sa++` won't work.",
      "created_at": "2024-05-23T14:00:27Z",
      "updated_at": "2024-05-23T14:12:31Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611755766",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611755766"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 208,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611829012",
      "pull_request_review_id": 2074194160,
      "id": 1611829012,
      "node_id": "PRRC_kwDOABII585gEo8U",
      "diff_hunk": "@@ -0,0 +1,287 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1302000)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = family == AF_INET ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    // Linux IPv4 / IPv6 - this must be present, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = family;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    // Linux IPv4 / IPv6 this must be absent, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (family == AF_INET) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (family == AF_INET6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    destination_address.si_family = family;\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    Assume(best_route.NextHop.si_family == family);\n+    if (family == AF_INET) {\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(family == AF_INET6) {\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+\n+// Ensure correct alignment for sockaddrs.\n+#define ROUNDUP(a) \\\n+    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(uint32_t) - 1))) : sizeof(uint32_t))\n+\n+static std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // MacOS: Get default gateway from route table.\n+    // See man page for route(4) for the format.\n+\n+    // net.route.0.inet[6].flags.gateway\n+    int mib[] = {CTL_NET, PF_ROUTE, 0, family, NET_RT_FLAGS, RTF_GATEWAY};\n+    size_t l = 0;\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), 0, &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl length of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    std::vector<std::byte> buf(l);\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), buf.data(), &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl data of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    const struct rt_msghdr* rt = nullptr;\n+    for (const std::byte* p = buf.data(); p < buf.data() + buf.size(); p += rt->rtm_msglen) {",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 195,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "89ac09777d4d60a331fe1c482d87ecdd1aeb01a0",
      "in_reply_to_id": 1611637097,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "i don't think so, the pointer needs to advance by the size of the specific message, which is part of that message.",
      "created_at": "2024-05-23T14:42:06Z",
      "updated_at": "2024-05-23T14:42:06Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611829012",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611829012"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 195,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611831862",
      "pull_request_review_id": 2074198807,
      "id": 1611831862,
      "node_id": "PRRC_kwDOABII585gEpo2",
      "diff_hunk": "@@ -0,0 +1,287 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1302000)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = family == AF_INET ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    // Linux IPv4 / IPv6 - this must be present, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = family;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    // Linux IPv4 / IPv6 this must be absent, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (family == AF_INET) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (family == AF_INET6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    destination_address.si_family = family;\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    Assume(best_route.NextHop.si_family == family);\n+    if (family == AF_INET) {\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(family == AF_INET6) {\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+\n+// Ensure correct alignment for sockaddrs.\n+#define ROUNDUP(a) \\\n+    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(uint32_t) - 1))) : sizeof(uint32_t))\n+\n+static std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // MacOS: Get default gateway from route table.\n+    // See man page for route(4) for the format.\n+\n+    // net.route.0.inet[6].flags.gateway\n+    int mib[] = {CTL_NET, PF_ROUTE, 0, family, NET_RT_FLAGS, RTF_GATEWAY};\n+    size_t l = 0;\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), 0, &l, 0, 0) < 0) {",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 185,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "89ac09777d4d60a331fe1c482d87ecdd1aeb01a0",
      "in_reply_to_id": 1611597515,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "i'm not sure it makes sense to duplicate documentation that's already in the manual pages. Like if we're doing this here, why not for every system call we make. Do parameter names like `*newp=` `oldp=` even elucidate much?\r\n\r\nAgree re using `nullptr` where possible.",
      "created_at": "2024-05-23T14:43:53Z",
      "updated_at": "2024-05-23T14:43:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611831862",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611831862"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 185,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611834614",
      "pull_request_review_id": 2074204212,
      "id": 1611834614,
      "node_id": "PRRC_kwDOABII585gEqT2",
      "diff_hunk": "@@ -0,0 +1,287 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1302000)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = family == AF_INET ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    // Linux IPv4 / IPv6 - this must be present, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = family;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    // Linux IPv4 / IPv6 this must be absent, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (family == AF_INET) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (family == AF_INET6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    destination_address.si_family = family;\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    Assume(best_route.NextHop.si_family == family);\n+    if (family == AF_INET) {\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(family == AF_INET6) {\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+\n+// Ensure correct alignment for sockaddrs.\n+#define ROUNDUP(a) \\\n+    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(uint32_t) - 1))) : sizeof(uint32_t))\n+\n+static std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // MacOS: Get default gateway from route table.\n+    // See man page for route(4) for the format.\n+\n+    // net.route.0.inet[6].flags.gateway\n+    int mib[] = {CTL_NET, PF_ROUTE, 0, family, NET_RT_FLAGS, RTF_GATEWAY};\n+    size_t l = 0;\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), 0, &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl length of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    std::vector<std::byte> buf(l);\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), buf.data(), &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl data of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    const struct rt_msghdr* rt = nullptr;\n+    for (const std::byte* p = buf.data(); p < buf.data() + buf.size(); p += rt->rtm_msglen) {\n+        // Iterate over routing entry addresses, get destination and gateway (if present).\n+        rt = (const struct rt_msghdr*)p;\n+        const struct sockaddr* sa = (const struct sockaddr*)(rt + 1);",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 198,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "89ac09777d4d60a331fe1c482d87ecdd1aeb01a0",
      "in_reply_to_id": 1611691990,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "~~Yes, it's a minor optimization, we could always construct a CNetAddr if we wanted, but if we know we're not going to use it anyway might as well skip it.~~\r\n\r\nEdit: oh, i get what you mean. Might be better to just keep a byte pointer and only cast to an `struct sockaddr *` when we need it? all this back and forth casting doesn't make things clearer.",
      "created_at": "2024-05-23T14:45:38Z",
      "updated_at": "2024-05-23T14:55:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611834614",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611834614"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 198,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611838998",
      "pull_request_review_id": 2074212289,
      "id": 1611838998,
      "node_id": "PRRC_kwDOABII585gErYW",
      "diff_hunk": "@@ -0,0 +1,287 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1302000)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = family == AF_INET ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    // Linux IPv4 / IPv6 - this must be present, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = family;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    // Linux IPv4 / IPv6 this must be absent, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (family == AF_INET) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (family == AF_INET6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    destination_address.si_family = family;\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    Assume(best_route.NextHop.si_family == family);\n+    if (family == AF_INET) {\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(family == AF_INET6) {\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+\n+// Ensure correct alignment for sockaddrs.\n+#define ROUNDUP(a) \\\n+    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(uint32_t) - 1))) : sizeof(uint32_t))\n+\n+static std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // MacOS: Get default gateway from route table.\n+    // See man page for route(4) for the format.\n+\n+    // net.route.0.inet[6].flags.gateway\n+    int mib[] = {CTL_NET, PF_ROUTE, 0, family, NET_RT_FLAGS, RTF_GATEWAY};\n+    size_t l = 0;\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), 0, &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl length of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    std::vector<std::byte> buf(l);\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), buf.data(), &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl data of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    const struct rt_msghdr* rt = nullptr;\n+    for (const std::byte* p = buf.data(); p < buf.data() + buf.size(); p += rt->rtm_msglen) {\n+        // Iterate over routing entry addresses, get destination and gateway (if present).\n+        rt = (const struct rt_msghdr*)p;",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 197,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "89ac09777d4d60a331fe1c482d87ecdd1aeb01a0",
      "in_reply_to_id": 1611661588,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Well, i guess it wouldn't hurt checking (or adding an `Assume`), but i don't think the routing table is supposed to contain error entries (also these would generally have `rtm_addrs==0`).",
      "created_at": "2024-05-23T14:48:23Z",
      "updated_at": "2024-05-23T14:52:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611838998",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611838998"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 197,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611882820",
      "pull_request_review_id": 2074286585,
      "id": 1611882820,
      "node_id": "PRRC_kwDOABII585gE2FE",
      "diff_hunk": "@@ -0,0 +1,287 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1302000)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = family == AF_INET ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    // Linux IPv4 / IPv6 - this must be present, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = family;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    // Linux IPv4 / IPv6 this must be absent, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (family == AF_INET) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (family == AF_INET6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    destination_address.si_family = family;\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    Assume(best_route.NextHop.si_family == family);\n+    if (family == AF_INET) {\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(family == AF_INET6) {\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+\n+// Ensure correct alignment for sockaddrs.\n+#define ROUNDUP(a) \\\n+    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(uint32_t) - 1))) : sizeof(uint32_t))\n+\n+static std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // MacOS: Get default gateway from route table.\n+    // See man page for route(4) for the format.\n+\n+    // net.route.0.inet[6].flags.gateway\n+    int mib[] = {CTL_NET, PF_ROUTE, 0, family, NET_RT_FLAGS, RTF_GATEWAY};\n+    size_t l = 0;\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), 0, &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl length of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    std::vector<std::byte> buf(l);\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), buf.data(), &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl data of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    const struct rt_msghdr* rt = nullptr;\n+    for (const std::byte* p = buf.data(); p < buf.data() + buf.size(); p += rt->rtm_msglen) {\n+        // Iterate over routing entry addresses, get destination and gateway (if present).\n+        rt = (const struct rt_msghdr*)p;\n+        const struct sockaddr* sa = (const struct sockaddr*)(rt + 1);\n+        std::optional<CNetAddr> dst;\n+        std::optional<CNetAddr> gateway;\n+        for (int i = 0; i < RTAX_MAX; i++) {\n+            if (rt->rtm_addrs & (1 << i)) {\n+                if (i == RTAX_DST) {\n+                    dst = FromSockAddr(sa);\n+                } else if (i == RTAX_GATEWAY) {\n+                    gateway = FromSockAddr(sa);\n+                }\n+                sa = (const struct sockaddr*)((std::byte*)sa + ROUNDUP(sa->sa_len));",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 208,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "89ac09777d4d60a331fe1c482d87ecdd1aeb01a0",
      "in_reply_to_id": 1611731634,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> Also they're variable-length\r\n\r\nThat makes sense. Whereas `rt_msghdr` is fixed length I guess, so you're able to use `rt + 1` above (I'm still a bit terified that compilers don't care).\r\n\r\n",
      "created_at": "2024-05-23T15:14:17Z",
      "updated_at": "2024-05-23T15:14:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611882820",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611882820"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 208,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611884887",
      "pull_request_review_id": 2074290240,
      "id": 1611884887,
      "node_id": "PRRC_kwDOABII585gE2lX",
      "diff_hunk": "@@ -0,0 +1,287 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1302000)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = family == AF_INET ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    // Linux IPv4 / IPv6 - this must be present, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = family;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    // Linux IPv4 / IPv6 this must be absent, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (family == AF_INET) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (family == AF_INET6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    destination_address.si_family = family;\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    Assume(best_route.NextHop.si_family == family);\n+    if (family == AF_INET) {\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(family == AF_INET6) {\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+\n+// Ensure correct alignment for sockaddrs.\n+#define ROUNDUP(a) \\\n+    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(uint32_t) - 1))) : sizeof(uint32_t))\n+\n+static std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // MacOS: Get default gateway from route table.\n+    // See man page for route(4) for the format.\n+\n+    // net.route.0.inet[6].flags.gateway\n+    int mib[] = {CTL_NET, PF_ROUTE, 0, family, NET_RT_FLAGS, RTF_GATEWAY};\n+    size_t l = 0;\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), 0, &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl length of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    std::vector<std::byte> buf(l);\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), buf.data(), &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl data of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    const struct rt_msghdr* rt = nullptr;\n+    for (const std::byte* p = buf.data(); p < buf.data() + buf.size(); p += rt->rtm_msglen) {\n+        // Iterate over routing entry addresses, get destination and gateway (if present).\n+        rt = (const struct rt_msghdr*)p;\n+        const struct sockaddr* sa = (const struct sockaddr*)(rt + 1);",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 198,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "89ac09777d4d60a331fe1c482d87ecdd1aeb01a0",
      "in_reply_to_id": 1611691990,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I'm not sure, but the reason I wrote this comment is because initially I thought: yikes, what if this is out of bound?",
      "created_at": "2024-05-23T15:15:50Z",
      "updated_at": "2024-05-23T15:16:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611884887",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611884887"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 198,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611888217",
      "pull_request_review_id": 2074295443,
      "id": 1611888217,
      "node_id": "PRRC_kwDOABII585gE3ZZ",
      "diff_hunk": "@@ -0,0 +1,287 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1302000)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = family == AF_INET ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    // Linux IPv4 / IPv6 - this must be present, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = family;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    // Linux IPv4 / IPv6 this must be absent, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (family == AF_INET) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (family == AF_INET6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    destination_address.si_family = family;\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    Assume(best_route.NextHop.si_family == family);\n+    if (family == AF_INET) {\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(family == AF_INET6) {\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+\n+// Ensure correct alignment for sockaddrs.\n+#define ROUNDUP(a) \\\n+    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(uint32_t) - 1))) : sizeof(uint32_t))\n+\n+static std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // MacOS: Get default gateway from route table.\n+    // See man page for route(4) for the format.\n+\n+    // net.route.0.inet[6].flags.gateway\n+    int mib[] = {CTL_NET, PF_ROUTE, 0, family, NET_RT_FLAGS, RTF_GATEWAY};\n+    size_t l = 0;\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), 0, &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl length of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    std::vector<std::byte> buf(l);\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), buf.data(), &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl data of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    const struct rt_msghdr* rt = nullptr;\n+    for (const std::byte* p = buf.data(); p < buf.data() + buf.size(); p += rt->rtm_msglen) {\n+        // Iterate over routing entry addresses, get destination and gateway (if present).\n+        rt = (const struct rt_msghdr*)p;",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 197,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "89ac09777d4d60a331fe1c482d87ecdd1aeb01a0",
      "in_reply_to_id": 1611661588,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Mmm, I thought perhaps it would return a single error entry to indicate failure.",
      "created_at": "2024-05-23T15:16:53Z",
      "updated_at": "2024-05-23T15:16:54Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611888217",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611888217"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 197,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611896435",
      "pull_request_review_id": 2074310132,
      "id": 1611896435,
      "node_id": "PRRC_kwDOABII585gE5Zz",
      "diff_hunk": "@@ -0,0 +1,287 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1302000)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = family == AF_INET ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    // Linux IPv4 / IPv6 - this must be present, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = family;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    // Linux IPv4 / IPv6 this must be absent, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (family == AF_INET) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (family == AF_INET6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    destination_address.si_family = family;\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    Assume(best_route.NextHop.si_family == family);\n+    if (family == AF_INET) {\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(family == AF_INET6) {\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+\n+// Ensure correct alignment for sockaddrs.\n+#define ROUNDUP(a) \\\n+    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(uint32_t) - 1))) : sizeof(uint32_t))\n+\n+static std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // MacOS: Get default gateway from route table.\n+    // See man page for route(4) for the format.\n+\n+    // net.route.0.inet[6].flags.gateway\n+    int mib[] = {CTL_NET, PF_ROUTE, 0, family, NET_RT_FLAGS, RTF_GATEWAY};\n+    size_t l = 0;\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), 0, &l, 0, 0) < 0) {",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 185,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "89ac09777d4d60a331fe1c482d87ecdd1aeb01a0",
      "in_reply_to_id": 1611597515,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "`oldlenp=` does because it's key to the trick of how we get the length first. I find these variable name hints useful to e.g. search for them.",
      "created_at": "2024-05-23T15:19:29Z",
      "updated_at": "2024-05-23T15:19:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611896435",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611896435"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 185,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611906833",
      "pull_request_review_id": 2074328030,
      "id": 1611906833,
      "node_id": "PRRC_kwDOABII585gE78R",
      "diff_hunk": "@@ -0,0 +1,517 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/pcp.h>\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <random.h>\n+#include <span.h>\n+#include <util/check.h>\n+#include <util/netif.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+// RFC6886 NAT-PMP and RFC6887 Port Control Protocol (PCP) implementation.\n+// NAT-PMP and PCP use network byte order (big-endian).\n+\n+// NAT-PMP (v0) protocol constants.\n+//! NAT-PMP uses a fixed server port number (RPC6887 section 1.1).\n+constexpr uint16_t NATPMP_SERVER_PORT = 5351;\n+//! Version byte for NATPMP (RFC6886 1.1)\n+constexpr uint8_t NATPMP_VERSION = 0;\n+//! Request opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_REQUEST = 0x00;\n+//! Response opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_RESPONSE = 0x80;\n+//! Get external address (RFC6886 3.2)\n+constexpr uint8_t NATPMP_OP_GETEXTERNAL = 0x00;\n+//! Map TCP port (RFC6886 3.3)\n+constexpr uint8_t NATPMP_OP_MAP_TCP = 0x02;\n+//! Shared request header size in bytes.\n+constexpr size_t NATPMP_REQUEST_HDR_SIZE = 2;\n+//! Shared response header (minimum) size in bytes.\n+constexpr size_t NATPMP_RESPONSE_HDR_SIZE = 8;\n+//! GETEXTERNAL request size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 0;\n+//! GETEXTERNAL response size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 4;\n+//! MAP request size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 10;\n+//! MAP response size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 8;\n+\n+// Shared header offsets (RFC6886 3.2, 3.3), relative to start of packet.\n+//!  Offset of version field in packets.\n+constexpr size_t NATPMP_HDR_VERSION_OFS = 0;\n+//!  Offset of opcode field in packets\n+constexpr size_t NATPMP_HDR_OP_OFS = 1;\n+//!  Offset of result code in packets. Result codes are 16 bit in NAT-PMP instead of 8 bit in PCP.\n+constexpr size_t NATPMP_RESPONSE_HDR_RESULT_OFS = 2;\n+\n+// GETEXTERNAL response offsets (RFC6886 3.2), relative to start of packet.\n+//!  Returned external address\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_IP_OFS = 8;\n+\n+// MAP request offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port to be mapped.\n+constexpr size_t NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS = 4;\n+//!  Suggested external port for mapping.\n+constexpr size_t NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS = 6;\n+//!  Requested port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_REQUEST_LIFETIME_OFS = 8;\n+\n+// MAP response offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port for mapping (will match internal port of request).\n+constexpr size_t NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS = 8;\n+//!  External port for mapping.\n+constexpr size_t NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS = 10;\n+//!  Created port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_RESPONSE_LIFETIME_OFS = 12;\n+\n+// Relevant NETPMP result codes (RFC6886 3.5).\n+//! Result code representing success status.\n+constexpr uint8_t NATPMP_RESULT_SUCCESS = 0;\n+//! Result code representing unsupported version.\n+constexpr uint8_t NATPMP_RESULT_UNSUPP_VERSION = 1;\n+//! Result code representing lack of resources.\n+constexpr uint8_t NATPMP_RESULT_NO_RESOURCES = 4;\n+\n+//! Mapping of NATPMP result code to string (RPC6886 3.5). Result codes <=2 match PCP.\n+static const std::map<uint8_t, std::string> NATPMP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"NETWORK_FAILURE\"},\n+    {4,  \"NO_RESOURCES\"},\n+    {5,  \"UNSUPP_OPCODE\"},\n+};\n+\n+// PCP (v2) protocol constants.\n+//! Maximum packet size in bytes (RPC6887 section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (RPC6887 section 19.1). Shared with NAT-PMP.\n+constexpr uint16_t PCP_SERVER_PORT = NATPMP_SERVER_PORT;\n+//! Version byte. 0 is NAT-PMP (RFC6886), 1 is forbidden, 2 for PCP (RFC6887).\n+constexpr uint8_t PCP_VERSION = 2;\n+//! PCP Request Header. See RPC6887 section 7.1. Shared with NAT-PMP.\n+constexpr uint8_t PCP_REQUEST = NATPMP_REQUEST; // R = 0\n+//! PCP Response Header. See RPC6887 section 7.2. Shared with NAT-PMP.\n+constexpr uint8_t PCP_RESPONSE = NATPMP_RESPONSE; // R = 1\n+//! Map opcode. See RPC6887 section 19.2\n+constexpr uint8_t PCP_OP_MAP = 0x01;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Request and response header size in bytes (RPC6887 section 7.1).\n+constexpr size_t PCP_HDR_SIZE = 24;\n+//! Map request and response size in bytes (RPC6887 section 11.1).\n+constexpr size_t PCP_MAP_SIZE = 36;\n+\n+// Header offsets shared between request and responses (RFC6887 7.1, 7.2), relative to start of packet.\n+//!  Version field (1 byte).\n+constexpr size_t PCP_HDR_VERSION_OFS = NATPMP_HDR_VERSION_OFS;\n+//!  Opcode field (1 byte).\n+constexpr size_t PCP_HDR_OP_OFS = NATPMP_HDR_OP_OFS;\n+//!  Requested lifetime (request), granted lifetime (response) (2 bytes).\n+constexpr size_t PCP_HDR_LIFETIME_OFS = 4;\n+\n+// Request header offsets (RFC6887 7.1), relative to start of packet.\n+//!  PCP client's IP address (16 bytes).\n+constexpr size_t PCP_REQUEST_HDR_IP_OFS = 8;\n+\n+// Response header offsets (RFC6887 7.2), relative to start of packet.\n+//!  Result code (1 byte).\n+constexpr size_t PCP_RESPONSE_HDR_RESULT_OFS = 3;\n+\n+// MAP request/response offsets (RFC6887 11.1), relative to start of opcode-specific data.\n+//!  Mapping nonce (12 bytes).\n+constexpr size_t PCP_MAP_NONCE_OFS = 0;\n+//!  Protocol (1 byte).\n+constexpr size_t PCP_MAP_PROTOCOL_OFS = 12;\n+//!  Internal port for mapping (2 bytes).\n+constexpr size_t PCP_MAP_INTERNAL_PORT_OFS = 16;\n+//!  Suggested external port (request), assigned external port (response) (2 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_PORT_OFS = 18;\n+//!  Suggested external IP (request), assigned external IP (response) (16 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_IP_OFS = 20;\n+\n+//! Result code representing success (RPC6887 7.4), shared with NAT-PMP.\n+constexpr uint8_t PCP_RESULT_SUCCESS = NATPMP_RESULT_SUCCESS;\n+//! Result code representing lack of resources (RPC6887 7.4).\n+constexpr uint8_t PCP_RESULT_NO_RESOURCES = 8;\n+\n+//! Mapping of PCP result code to string (RPC6887 7.4). Result codes <=2 match NAT-PMP.\n+static const std::map<uint8_t, std::string> PCP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"MALFORMED_REQUEST\"},\n+    {4,  \"UNSUPP_OPCODE\"},\n+    {5,  \"UNSUPP_OPTION\"},\n+    {6,  \"MALFORMED_OPTION\"},\n+    {7,  \"NETWORK_FAILURE\"},\n+    {8,  \"NO_RESOURCES\"},\n+    {9,  \"UNSUPP_PROTOCOL\"},\n+    {10, \"USER_EX_QUOTA\"},\n+    {11, \"CANNOT_PROVIDE_EXTERNAL\"},\n+    {12, \"ADDRESS_MISMATCH\"},\n+    {13, \"EXCESSIVE_REMOTE_PEER\"},\n+};\n+\n+//! Return human-readable string from NATPMP result code.\n+static std::string NATPMPResultString(uint8_t result_code)\n+{\n+    auto result_i = NATPMP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == NATPMP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Return human-readable string from PCP result code.\n+static std::string PCPResultString(uint8_t result_code)\n+{\n+    auto result_i = PCP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == PCP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Wrap address in IPv6 according to RPC6887. wrapped_addr needs to be able to store 16 bytes.\n+[[nodiscard]] static bool PCPWrapAddress(Span<uint8_t> wrapped_addr, const CNetAddr &addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (addr.IsIPv4()) {\n+        struct in_addr addr4;\n+        if (!addr.GetInAddr(&addr4)) return false;\n+        // Section 5: \"When the address field holds an IPv4 address, an IPv4-mapped IPv6 address [RFC4291] is used (::ffff:0:0/96).\"\n+        std::memcpy(wrapped_addr.data(), IPV4_IN_IPV6_PREFIX.data(), IPV4_IN_IPV6_PREFIX.size());\n+        std::memcpy(wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), &addr4, ADDR_IPV4_SIZE);\n+        return true;\n+    } else if (addr.IsIPv6()) {\n+        struct in6_addr addr6;\n+        if (!addr.GetIn6Addr(&addr6)) return false;\n+        std::memcpy(wrapped_addr.data(), &addr6, ADDR_IPV6_SIZE);\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+//! Unwrap PCP-encoded address according to RPC6887.\n+static CNetAddr PCPUnwrapAddress(Span<const uint8_t> wrapped_addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (HasPrefix(wrapped_addr, IPV4_IN_IPV6_PREFIX)) {\n+        struct in_addr addr4;\n+        std::memcpy(&addr4, wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), ADDR_IPV4_SIZE);\n+        return CNetAddr(addr4);\n+    } else {\n+        struct in6_addr addr6;\n+        std::memcpy(&addr6, wrapped_addr.data(), ADDR_IPV6_SIZE);\n+        return CNetAddr(addr6);\n+    }\n+}\n+\n+//! PCP or NAT-PMP send-receive loop.\n+static std::optional<std::vector<uint8_t>> PCPSendRecv(Sock &sock, const std::string &protocol, Span<const uint8_t> request, int num_tries,\n+        std::function<bool(const Span<const uint8_t>)> check_packet)\n+{\n+    // UDP is a potentially lossy protocol, so we try to send again a few times.\n+    uint8_t response[PCP_MAX_SIZE];\n+    bool got_response = false;\n+    int recvsz = 0;\n+    for (int ntry = 0; !got_response && ntry < num_tries; ++ntry) {\n+        if (ntry > 0) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Retrying (%d)\\n\", protocol, ntry);\n+        }\n+        // Dispatch packet to gateway.\n+        if (sock.Send(request.data(), request.size(), 0) != static_cast<ssize_t>(request.size())) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not send request: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));",
      "path": "src/util/pcp.cpp",
      "position": 233,
      "original_position": 228,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "82b1c25b9ca61f5b0382a5196e0ff7016b4d1429",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Can you add \"to gateway x.x.x.x\" here? I'm getting this error on your latest commit, three times, but I can't tell if it's IPv4, IPv6 or both.\r\n\r\nStrangely I do get four successful \"Added mapping pcp\" messages (1 on IPv4, 3 on IPv6).",
      "created_at": "2024-05-23T15:25:54Z",
      "updated_at": "2024-05-23T15:27:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611906833",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611906833"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 233,
      "original_line": 233,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611917789",
      "pull_request_review_id": 2074346509,
      "id": 1611917789,
      "node_id": "PRRC_kwDOABII585gE-nd",
      "diff_hunk": "@@ -0,0 +1,517 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/pcp.h>\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <random.h>\n+#include <span.h>\n+#include <util/check.h>\n+#include <util/netif.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+// RFC6886 NAT-PMP and RFC6887 Port Control Protocol (PCP) implementation.\n+// NAT-PMP and PCP use network byte order (big-endian).\n+\n+// NAT-PMP (v0) protocol constants.\n+//! NAT-PMP uses a fixed server port number (RPC6887 section 1.1).\n+constexpr uint16_t NATPMP_SERVER_PORT = 5351;\n+//! Version byte for NATPMP (RFC6886 1.1)\n+constexpr uint8_t NATPMP_VERSION = 0;\n+//! Request opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_REQUEST = 0x00;\n+//! Response opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_RESPONSE = 0x80;\n+//! Get external address (RFC6886 3.2)\n+constexpr uint8_t NATPMP_OP_GETEXTERNAL = 0x00;\n+//! Map TCP port (RFC6886 3.3)\n+constexpr uint8_t NATPMP_OP_MAP_TCP = 0x02;\n+//! Shared request header size in bytes.\n+constexpr size_t NATPMP_REQUEST_HDR_SIZE = 2;\n+//! Shared response header (minimum) size in bytes.\n+constexpr size_t NATPMP_RESPONSE_HDR_SIZE = 8;\n+//! GETEXTERNAL request size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 0;\n+//! GETEXTERNAL response size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 4;\n+//! MAP request size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 10;\n+//! MAP response size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 8;\n+\n+// Shared header offsets (RFC6886 3.2, 3.3), relative to start of packet.\n+//!  Offset of version field in packets.\n+constexpr size_t NATPMP_HDR_VERSION_OFS = 0;\n+//!  Offset of opcode field in packets\n+constexpr size_t NATPMP_HDR_OP_OFS = 1;\n+//!  Offset of result code in packets. Result codes are 16 bit in NAT-PMP instead of 8 bit in PCP.\n+constexpr size_t NATPMP_RESPONSE_HDR_RESULT_OFS = 2;\n+\n+// GETEXTERNAL response offsets (RFC6886 3.2), relative to start of packet.\n+//!  Returned external address\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_IP_OFS = 8;\n+\n+// MAP request offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port to be mapped.\n+constexpr size_t NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS = 4;\n+//!  Suggested external port for mapping.\n+constexpr size_t NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS = 6;\n+//!  Requested port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_REQUEST_LIFETIME_OFS = 8;\n+\n+// MAP response offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port for mapping (will match internal port of request).\n+constexpr size_t NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS = 8;\n+//!  External port for mapping.\n+constexpr size_t NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS = 10;\n+//!  Created port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_RESPONSE_LIFETIME_OFS = 12;\n+\n+// Relevant NETPMP result codes (RFC6886 3.5).\n+//! Result code representing success status.\n+constexpr uint8_t NATPMP_RESULT_SUCCESS = 0;\n+//! Result code representing unsupported version.\n+constexpr uint8_t NATPMP_RESULT_UNSUPP_VERSION = 1;\n+//! Result code representing lack of resources.\n+constexpr uint8_t NATPMP_RESULT_NO_RESOURCES = 4;\n+\n+//! Mapping of NATPMP result code to string (RPC6886 3.5). Result codes <=2 match PCP.\n+static const std::map<uint8_t, std::string> NATPMP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"NETWORK_FAILURE\"},\n+    {4,  \"NO_RESOURCES\"},\n+    {5,  \"UNSUPP_OPCODE\"},\n+};\n+\n+// PCP (v2) protocol constants.\n+//! Maximum packet size in bytes (RPC6887 section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (RPC6887 section 19.1). Shared with NAT-PMP.\n+constexpr uint16_t PCP_SERVER_PORT = NATPMP_SERVER_PORT;\n+//! Version byte. 0 is NAT-PMP (RFC6886), 1 is forbidden, 2 for PCP (RFC6887).\n+constexpr uint8_t PCP_VERSION = 2;\n+//! PCP Request Header. See RPC6887 section 7.1. Shared with NAT-PMP.\n+constexpr uint8_t PCP_REQUEST = NATPMP_REQUEST; // R = 0\n+//! PCP Response Header. See RPC6887 section 7.2. Shared with NAT-PMP.\n+constexpr uint8_t PCP_RESPONSE = NATPMP_RESPONSE; // R = 1\n+//! Map opcode. See RPC6887 section 19.2\n+constexpr uint8_t PCP_OP_MAP = 0x01;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Request and response header size in bytes (RPC6887 section 7.1).\n+constexpr size_t PCP_HDR_SIZE = 24;\n+//! Map request and response size in bytes (RPC6887 section 11.1).\n+constexpr size_t PCP_MAP_SIZE = 36;\n+\n+// Header offsets shared between request and responses (RFC6887 7.1, 7.2), relative to start of packet.\n+//!  Version field (1 byte).\n+constexpr size_t PCP_HDR_VERSION_OFS = NATPMP_HDR_VERSION_OFS;\n+//!  Opcode field (1 byte).\n+constexpr size_t PCP_HDR_OP_OFS = NATPMP_HDR_OP_OFS;\n+//!  Requested lifetime (request), granted lifetime (response) (2 bytes).\n+constexpr size_t PCP_HDR_LIFETIME_OFS = 4;\n+\n+// Request header offsets (RFC6887 7.1), relative to start of packet.\n+//!  PCP client's IP address (16 bytes).\n+constexpr size_t PCP_REQUEST_HDR_IP_OFS = 8;\n+\n+// Response header offsets (RFC6887 7.2), relative to start of packet.\n+//!  Result code (1 byte).\n+constexpr size_t PCP_RESPONSE_HDR_RESULT_OFS = 3;\n+\n+// MAP request/response offsets (RFC6887 11.1), relative to start of opcode-specific data.\n+//!  Mapping nonce (12 bytes).\n+constexpr size_t PCP_MAP_NONCE_OFS = 0;\n+//!  Protocol (1 byte).\n+constexpr size_t PCP_MAP_PROTOCOL_OFS = 12;\n+//!  Internal port for mapping (2 bytes).\n+constexpr size_t PCP_MAP_INTERNAL_PORT_OFS = 16;\n+//!  Suggested external port (request), assigned external port (response) (2 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_PORT_OFS = 18;\n+//!  Suggested external IP (request), assigned external IP (response) (16 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_IP_OFS = 20;\n+\n+//! Result code representing success (RPC6887 7.4), shared with NAT-PMP.\n+constexpr uint8_t PCP_RESULT_SUCCESS = NATPMP_RESULT_SUCCESS;\n+//! Result code representing lack of resources (RPC6887 7.4).\n+constexpr uint8_t PCP_RESULT_NO_RESOURCES = 8;\n+\n+//! Mapping of PCP result code to string (RPC6887 7.4). Result codes <=2 match NAT-PMP.\n+static const std::map<uint8_t, std::string> PCP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"MALFORMED_REQUEST\"},\n+    {4,  \"UNSUPP_OPCODE\"},\n+    {5,  \"UNSUPP_OPTION\"},\n+    {6,  \"MALFORMED_OPTION\"},\n+    {7,  \"NETWORK_FAILURE\"},\n+    {8,  \"NO_RESOURCES\"},\n+    {9,  \"UNSUPP_PROTOCOL\"},\n+    {10, \"USER_EX_QUOTA\"},\n+    {11, \"CANNOT_PROVIDE_EXTERNAL\"},\n+    {12, \"ADDRESS_MISMATCH\"},\n+    {13, \"EXCESSIVE_REMOTE_PEER\"},\n+};\n+\n+//! Return human-readable string from NATPMP result code.\n+static std::string NATPMPResultString(uint8_t result_code)\n+{\n+    auto result_i = NATPMP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == NATPMP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Return human-readable string from PCP result code.\n+static std::string PCPResultString(uint8_t result_code)\n+{\n+    auto result_i = PCP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == PCP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Wrap address in IPv6 according to RPC6887. wrapped_addr needs to be able to store 16 bytes.\n+[[nodiscard]] static bool PCPWrapAddress(Span<uint8_t> wrapped_addr, const CNetAddr &addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (addr.IsIPv4()) {\n+        struct in_addr addr4;\n+        if (!addr.GetInAddr(&addr4)) return false;\n+        // Section 5: \"When the address field holds an IPv4 address, an IPv4-mapped IPv6 address [RFC4291] is used (::ffff:0:0/96).\"\n+        std::memcpy(wrapped_addr.data(), IPV4_IN_IPV6_PREFIX.data(), IPV4_IN_IPV6_PREFIX.size());\n+        std::memcpy(wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), &addr4, ADDR_IPV4_SIZE);\n+        return true;\n+    } else if (addr.IsIPv6()) {\n+        struct in6_addr addr6;\n+        if (!addr.GetIn6Addr(&addr6)) return false;\n+        std::memcpy(wrapped_addr.data(), &addr6, ADDR_IPV6_SIZE);\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+//! Unwrap PCP-encoded address according to RPC6887.\n+static CNetAddr PCPUnwrapAddress(Span<const uint8_t> wrapped_addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (HasPrefix(wrapped_addr, IPV4_IN_IPV6_PREFIX)) {\n+        struct in_addr addr4;\n+        std::memcpy(&addr4, wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), ADDR_IPV4_SIZE);\n+        return CNetAddr(addr4);\n+    } else {\n+        struct in6_addr addr6;\n+        std::memcpy(&addr6, wrapped_addr.data(), ADDR_IPV6_SIZE);\n+        return CNetAddr(addr6);\n+    }\n+}\n+\n+//! PCP or NAT-PMP send-receive loop.\n+static std::optional<std::vector<uint8_t>> PCPSendRecv(Sock &sock, const std::string &protocol, Span<const uint8_t> request, int num_tries,\n+        std::function<bool(const Span<const uint8_t>)> check_packet)\n+{\n+    // UDP is a potentially lossy protocol, so we try to send again a few times.\n+    uint8_t response[PCP_MAX_SIZE];\n+    bool got_response = false;\n+    int recvsz = 0;\n+    for (int ntry = 0; !got_response && ntry < num_tries; ++ntry) {\n+        if (ntry > 0) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Retrying (%d)\\n\", protocol, ntry);\n+        }\n+        // Dispatch packet to gateway.\n+        if (sock.Send(request.data(), request.size(), 0) != static_cast<ssize_t>(request.size())) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not send request: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));",
      "path": "src/util/pcp.cpp",
      "position": 233,
      "original_position": 228,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "82b1c25b9ca61f5b0382a5196e0ff7016b4d1429",
      "in_reply_to_id": 1611906833,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Update: this happens when I'm connected with a physical LAN cable _and_ wifi. So the warning was safe to ignore, but I'm still curious about it.",
      "created_at": "2024-05-23T15:33:27Z",
      "updated_at": "2024-05-23T15:33:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611917789",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611917789"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 233,
      "original_line": 233,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611953200",
      "pull_request_review_id": 2074405871,
      "id": 1611953200,
      "node_id": "PRRC_kwDOABII585gFHQw",
      "diff_hunk": "@@ -0,0 +1,287 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1302000)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = family == AF_INET ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    // Linux IPv4 / IPv6 - this must be present, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = family;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    // Linux IPv4 / IPv6 this must be absent, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (family == AF_INET) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (family == AF_INET6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    destination_address.si_family = family;\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    Assume(best_route.NextHop.si_family == family);\n+    if (family == AF_INET) {\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(family == AF_INET6) {\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+\n+// Ensure correct alignment for sockaddrs.\n+#define ROUNDUP(a) \\\n+    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(uint32_t) - 1))) : sizeof(uint32_t))\n+\n+static std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // MacOS: Get default gateway from route table.\n+    // See man page for route(4) for the format.\n+\n+    // net.route.0.inet[6].flags.gateway\n+    int mib[] = {CTL_NET, PF_ROUTE, 0, family, NET_RT_FLAGS, RTF_GATEWAY};\n+    size_t l = 0;\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), 0, &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl length of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    std::vector<std::byte> buf(l);\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), buf.data(), &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl data of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    const struct rt_msghdr* rt = nullptr;\n+    for (const std::byte* p = buf.data(); p < buf.data() + buf.size(); p += rt->rtm_msglen) {",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 195,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "89ac09777d4d60a331fe1c482d87ecdd1aeb01a0",
      "in_reply_to_id": 1611637097,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Possible alternative, makes it a bit more clear that we rely on `rt->rtm_msglen` to be correct. A `for` loop gives a false sense of safety. No strong feelings though.\r\n\r\n```cpp\r\n    std::byte* p = buf.data();\r\n    while (true) {\r\n        rt = (const struct rt_msghdr*)p;\r\n        // ...\r\n\r\n        p += rt->rtm_msglen;\r\n        if (p == buf.data() + buf.size()) break;\r\n        assert(p < buf.data() + buf.size());\r\n    }\r\n```",
      "created_at": "2024-05-23T15:58:15Z",
      "updated_at": "2024-05-23T15:58:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611953200",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611953200"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 195,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611968560",
      "pull_request_review_id": 2074432764,
      "id": 1611968560,
      "node_id": "PRRC_kwDOABII585gFLAw",
      "diff_hunk": "@@ -0,0 +1,287 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1302000)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = family == AF_INET ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    // Linux IPv4 / IPv6 - this must be present, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = family;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    // Linux IPv4 / IPv6 this must be absent, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (family == AF_INET) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (family == AF_INET6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    destination_address.si_family = family;\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    Assume(best_route.NextHop.si_family == family);\n+    if (family == AF_INET) {\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(family == AF_INET6) {\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+\n+// Ensure correct alignment for sockaddrs.\n+#define ROUNDUP(a) \\\n+    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(uint32_t) - 1))) : sizeof(uint32_t))\n+\n+static std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // MacOS: Get default gateway from route table.\n+    // See man page for route(4) for the format.\n+\n+    // net.route.0.inet[6].flags.gateway\n+    int mib[] = {CTL_NET, PF_ROUTE, 0, family, NET_RT_FLAGS, RTF_GATEWAY};\n+    size_t l = 0;\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), 0, &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl length of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    std::vector<std::byte> buf(l);\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), buf.data(), &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl data of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    const struct rt_msghdr* rt = nullptr;\n+    for (const std::byte* p = buf.data(); p < buf.data() + buf.size(); p += rt->rtm_msglen) {\n+        // Iterate over routing entry addresses, get destination and gateway (if present).\n+        rt = (const struct rt_msghdr*)p;\n+        const struct sockaddr* sa = (const struct sockaddr*)(rt + 1);",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 198,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "89ac09777d4d60a331fe1c482d87ecdd1aeb01a0",
      "in_reply_to_id": 1611691990,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "How about:\r\n\r\n```cpp\r\n// rt_msghdr is followed by zero or more sockaddrs, as indicated by rtm_addrs\r\nauto sa = (const struct sockaddr*)(p + sizeof(rt_msghdr));\r\n```",
      "created_at": "2024-05-23T16:10:25Z",
      "updated_at": "2024-05-23T16:10:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1611968560",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1611968560"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 198,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1612003469",
      "pull_request_review_id": 2074495742,
      "id": 1612003469,
      "node_id": "PRRC_kwDOABII585gFTiN",
      "diff_hunk": "@@ -0,0 +1,287 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1302000)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = family == AF_INET ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    // Linux IPv4 / IPv6 - this must be present, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = family;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    // Linux IPv4 / IPv6 this must be absent, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (family == AF_INET) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (family == AF_INET6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    destination_address.si_family = family;\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    Assume(best_route.NextHop.si_family == family);\n+    if (family == AF_INET) {\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(family == AF_INET6) {\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+\n+// Ensure correct alignment for sockaddrs.\n+#define ROUNDUP(a) \\\n+    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(uint32_t) - 1))) : sizeof(uint32_t))\n+\n+static std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // MacOS: Get default gateway from route table.\n+    // See man page for route(4) for the format.\n+\n+    // net.route.0.inet[6].flags.gateway\n+    int mib[] = {CTL_NET, PF_ROUTE, 0, family, NET_RT_FLAGS, RTF_GATEWAY};\n+    size_t l = 0;\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), 0, &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl length of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    std::vector<std::byte> buf(l);\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), buf.data(), &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl data of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    const struct rt_msghdr* rt = nullptr;\n+    for (const std::byte* p = buf.data(); p < buf.data() + buf.size(); p += rt->rtm_msglen) {\n+        // Iterate over routing entry addresses, get destination and gateway (if present).\n+        rt = (const struct rt_msghdr*)p;\n+        const struct sockaddr* sa = (const struct sockaddr*)(rt + 1);\n+        std::optional<CNetAddr> dst;\n+        std::optional<CNetAddr> gateway;\n+        for (int i = 0; i < RTAX_MAX; i++) {\n+            if (rt->rtm_addrs & (1 << i)) {\n+                if (i == RTAX_DST) {\n+                    dst = FromSockAddr(sa);\n+                } else if (i == RTAX_GATEWAY) {\n+                    gateway = FromSockAddr(sa);\n+                }\n+                sa = (const struct sockaddr*)((std::byte*)sa + ROUNDUP(sa->sa_len));",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 208,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "89ac09777d4d60a331fe1c482d87ecdd1aeb01a0",
      "in_reply_to_id": 1611731634,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Right, let's add `sizeof(rt_msghdr)` manually instead of doing the +1 trick.\r\n\r\n> That makes sense. Whereas rt_msghdr is fixed length I guess, so you're able to use rt + 1 above (I'm still a bit terified that compilers don't care). \r\n\r\nIf we can hardcode the assumption that `sa_len` is the first byte (which it is) then we can avoid casting and dereferencing sockaddr, anywhere. E.g. when we know the length we can memcpy it into a `sockaddr_storage` first.\r\n",
      "created_at": "2024-05-23T16:29:53Z",
      "updated_at": "2024-05-23T16:31:11Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1612003469",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1612003469"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 208,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1612015499",
      "pull_request_review_id": 2074515775,
      "id": 1612015499,
      "node_id": "PRRC_kwDOABII585gFWeL",
      "diff_hunk": "@@ -0,0 +1,287 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1302000)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = family == AF_INET ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    // Linux IPv4 / IPv6 - this must be present, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = family;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    // Linux IPv4 / IPv6 this must be absent, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (family == AF_INET) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (family == AF_INET6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    destination_address.si_family = family;\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    Assume(best_route.NextHop.si_family == family);\n+    if (family == AF_INET) {\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(family == AF_INET6) {\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+\n+// Ensure correct alignment for sockaddrs.\n+#define ROUNDUP(a) \\\n+    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(uint32_t) - 1))) : sizeof(uint32_t))\n+\n+static std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // MacOS: Get default gateway from route table.\n+    // See man page for route(4) for the format.\n+\n+    // net.route.0.inet[6].flags.gateway\n+    int mib[] = {CTL_NET, PF_ROUTE, 0, family, NET_RT_FLAGS, RTF_GATEWAY};\n+    size_t l = 0;\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), 0, &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl length of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    std::vector<std::byte> buf(l);\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), buf.data(), &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl data of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    const struct rt_msghdr* rt = nullptr;\n+    for (const std::byte* p = buf.data(); p < buf.data() + buf.size(); p += rt->rtm_msglen) {\n+        // Iterate over routing entry addresses, get destination and gateway (if present).\n+        rt = (const struct rt_msghdr*)p;\n+        const struct sockaddr* sa = (const struct sockaddr*)(rt + 1);\n+        std::optional<CNetAddr> dst;\n+        std::optional<CNetAddr> gateway;\n+        for (int i = 0; i < RTAX_MAX; i++) {\n+            if (rt->rtm_addrs & (1 << i)) {\n+                if (i == RTAX_DST) {\n+                    dst = FromSockAddr(sa);\n+                } else if (i == RTAX_GATEWAY) {\n+                    gateway = FromSockAddr(sa);\n+                }\n+                sa = (const struct sockaddr*)((std::byte*)sa + ROUNDUP(sa->sa_len));",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 208,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "89ac09777d4d60a331fe1c482d87ecdd1aeb01a0",
      "in_reply_to_id": 1611731634,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Currently i have the following, having changed the pointer arithmetic to byte offsets:\r\n```c++\r\n    // Iterate over messages (each message is a routing table entry).\r\n    for (size_t msgptr = 0; msgptr < buf.size(); ) {\r\n        Assume((msgptr + sizeof(rt_msghdr)) <= buf.size());\r\n        const struct rt_msghdr* rt = (const struct rt_msghdr*)(buf.data() + msgptr);\r\n        // Iterate over addresses within entry, get destination and gateway (if present).\r\n        // Pointer to address data within message, starts after header.\r\n        size_t saptr = msgptr + sizeof(rt_msghdr);\r\n        size_t next_msgptr = msgptr + rt->rtm_msglen;\r\n        Assume(next_msgptr <= buf.size());\r\n        std::optional<CNetAddr> dst;\r\n        std::optional<CNetAddr> gateway;\r\n        for (int i = 0; i < RTAX_MAX; i++) {\r\n            if (rt->rtm_addrs & (1 << i)) {\r\n                Assume((saptr + 1) <= next_msgptr);\r\n                const struct sockaddr* sa = (const struct sockaddr*)(buf.data() + saptr);\r\n                Assume((saptr + sa->sa_len) <= next_msgptr);\r\n                if (i == RTAX_DST) {\r\n                    dst = FromSockAddr(sa);\r\n                } else if (i == RTAX_GATEWAY) {\r\n                    gateway = FromSockAddr(sa);\r\n                }\r\n                // Skip to next address.\r\n                saptr += sa->sa_len;\r\n            }\r\n        }\r\n        // Found default gateway?\r\n        if (dst && gateway && dst->IsBindAny()) { // Route to 0.0.0.0 or :: ?\r\n            return *gateway;\r\n        }\r\n        // Skip to next message.\r\n        msgptr = next_msgptr;\r\n    }\r\n```\r\nEdit: add anti-overflow assumptions.",
      "created_at": "2024-05-23T16:39:59Z",
      "updated_at": "2024-05-23T17:02:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1612015499",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1612015499"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 208,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1612022021",
      "pull_request_review_id": 2074526400,
      "id": 1612022021,
      "node_id": "PRRC_kwDOABII585gFYEF",
      "diff_hunk": "@@ -0,0 +1,517 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/pcp.h>\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <random.h>\n+#include <span.h>\n+#include <util/check.h>\n+#include <util/netif.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+// RFC6886 NAT-PMP and RFC6887 Port Control Protocol (PCP) implementation.\n+// NAT-PMP and PCP use network byte order (big-endian).\n+\n+// NAT-PMP (v0) protocol constants.\n+//! NAT-PMP uses a fixed server port number (RPC6887 section 1.1).\n+constexpr uint16_t NATPMP_SERVER_PORT = 5351;\n+//! Version byte for NATPMP (RFC6886 1.1)\n+constexpr uint8_t NATPMP_VERSION = 0;\n+//! Request opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_REQUEST = 0x00;\n+//! Response opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_RESPONSE = 0x80;\n+//! Get external address (RFC6886 3.2)\n+constexpr uint8_t NATPMP_OP_GETEXTERNAL = 0x00;\n+//! Map TCP port (RFC6886 3.3)\n+constexpr uint8_t NATPMP_OP_MAP_TCP = 0x02;\n+//! Shared request header size in bytes.\n+constexpr size_t NATPMP_REQUEST_HDR_SIZE = 2;\n+//! Shared response header (minimum) size in bytes.\n+constexpr size_t NATPMP_RESPONSE_HDR_SIZE = 8;\n+//! GETEXTERNAL request size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 0;\n+//! GETEXTERNAL response size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 4;\n+//! MAP request size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 10;\n+//! MAP response size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 8;\n+\n+// Shared header offsets (RFC6886 3.2, 3.3), relative to start of packet.\n+//!  Offset of version field in packets.\n+constexpr size_t NATPMP_HDR_VERSION_OFS = 0;\n+//!  Offset of opcode field in packets\n+constexpr size_t NATPMP_HDR_OP_OFS = 1;\n+//!  Offset of result code in packets. Result codes are 16 bit in NAT-PMP instead of 8 bit in PCP.\n+constexpr size_t NATPMP_RESPONSE_HDR_RESULT_OFS = 2;\n+\n+// GETEXTERNAL response offsets (RFC6886 3.2), relative to start of packet.\n+//!  Returned external address\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_IP_OFS = 8;\n+\n+// MAP request offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port to be mapped.\n+constexpr size_t NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS = 4;\n+//!  Suggested external port for mapping.\n+constexpr size_t NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS = 6;\n+//!  Requested port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_REQUEST_LIFETIME_OFS = 8;\n+\n+// MAP response offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port for mapping (will match internal port of request).\n+constexpr size_t NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS = 8;\n+//!  External port for mapping.\n+constexpr size_t NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS = 10;\n+//!  Created port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_RESPONSE_LIFETIME_OFS = 12;\n+\n+// Relevant NETPMP result codes (RFC6886 3.5).\n+//! Result code representing success status.\n+constexpr uint8_t NATPMP_RESULT_SUCCESS = 0;\n+//! Result code representing unsupported version.\n+constexpr uint8_t NATPMP_RESULT_UNSUPP_VERSION = 1;\n+//! Result code representing lack of resources.\n+constexpr uint8_t NATPMP_RESULT_NO_RESOURCES = 4;\n+\n+//! Mapping of NATPMP result code to string (RPC6886 3.5). Result codes <=2 match PCP.\n+static const std::map<uint8_t, std::string> NATPMP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"NETWORK_FAILURE\"},\n+    {4,  \"NO_RESOURCES\"},\n+    {5,  \"UNSUPP_OPCODE\"},\n+};\n+\n+// PCP (v2) protocol constants.\n+//! Maximum packet size in bytes (RPC6887 section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (RPC6887 section 19.1). Shared with NAT-PMP.\n+constexpr uint16_t PCP_SERVER_PORT = NATPMP_SERVER_PORT;\n+//! Version byte. 0 is NAT-PMP (RFC6886), 1 is forbidden, 2 for PCP (RFC6887).\n+constexpr uint8_t PCP_VERSION = 2;\n+//! PCP Request Header. See RPC6887 section 7.1. Shared with NAT-PMP.\n+constexpr uint8_t PCP_REQUEST = NATPMP_REQUEST; // R = 0\n+//! PCP Response Header. See RPC6887 section 7.2. Shared with NAT-PMP.\n+constexpr uint8_t PCP_RESPONSE = NATPMP_RESPONSE; // R = 1\n+//! Map opcode. See RPC6887 section 19.2\n+constexpr uint8_t PCP_OP_MAP = 0x01;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Request and response header size in bytes (RPC6887 section 7.1).\n+constexpr size_t PCP_HDR_SIZE = 24;\n+//! Map request and response size in bytes (RPC6887 section 11.1).\n+constexpr size_t PCP_MAP_SIZE = 36;\n+\n+// Header offsets shared between request and responses (RFC6887 7.1, 7.2), relative to start of packet.\n+//!  Version field (1 byte).\n+constexpr size_t PCP_HDR_VERSION_OFS = NATPMP_HDR_VERSION_OFS;\n+//!  Opcode field (1 byte).\n+constexpr size_t PCP_HDR_OP_OFS = NATPMP_HDR_OP_OFS;\n+//!  Requested lifetime (request), granted lifetime (response) (2 bytes).\n+constexpr size_t PCP_HDR_LIFETIME_OFS = 4;\n+\n+// Request header offsets (RFC6887 7.1), relative to start of packet.\n+//!  PCP client's IP address (16 bytes).\n+constexpr size_t PCP_REQUEST_HDR_IP_OFS = 8;\n+\n+// Response header offsets (RFC6887 7.2), relative to start of packet.\n+//!  Result code (1 byte).\n+constexpr size_t PCP_RESPONSE_HDR_RESULT_OFS = 3;\n+\n+// MAP request/response offsets (RFC6887 11.1), relative to start of opcode-specific data.\n+//!  Mapping nonce (12 bytes).\n+constexpr size_t PCP_MAP_NONCE_OFS = 0;\n+//!  Protocol (1 byte).\n+constexpr size_t PCP_MAP_PROTOCOL_OFS = 12;\n+//!  Internal port for mapping (2 bytes).\n+constexpr size_t PCP_MAP_INTERNAL_PORT_OFS = 16;\n+//!  Suggested external port (request), assigned external port (response) (2 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_PORT_OFS = 18;\n+//!  Suggested external IP (request), assigned external IP (response) (16 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_IP_OFS = 20;\n+\n+//! Result code representing success (RPC6887 7.4), shared with NAT-PMP.\n+constexpr uint8_t PCP_RESULT_SUCCESS = NATPMP_RESULT_SUCCESS;\n+//! Result code representing lack of resources (RPC6887 7.4).\n+constexpr uint8_t PCP_RESULT_NO_RESOURCES = 8;\n+\n+//! Mapping of PCP result code to string (RPC6887 7.4). Result codes <=2 match NAT-PMP.\n+static const std::map<uint8_t, std::string> PCP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"MALFORMED_REQUEST\"},\n+    {4,  \"UNSUPP_OPCODE\"},\n+    {5,  \"UNSUPP_OPTION\"},\n+    {6,  \"MALFORMED_OPTION\"},\n+    {7,  \"NETWORK_FAILURE\"},\n+    {8,  \"NO_RESOURCES\"},\n+    {9,  \"UNSUPP_PROTOCOL\"},\n+    {10, \"USER_EX_QUOTA\"},\n+    {11, \"CANNOT_PROVIDE_EXTERNAL\"},\n+    {12, \"ADDRESS_MISMATCH\"},\n+    {13, \"EXCESSIVE_REMOTE_PEER\"},\n+};\n+\n+//! Return human-readable string from NATPMP result code.\n+static std::string NATPMPResultString(uint8_t result_code)\n+{\n+    auto result_i = NATPMP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == NATPMP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Return human-readable string from PCP result code.\n+static std::string PCPResultString(uint8_t result_code)\n+{\n+    auto result_i = PCP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == PCP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Wrap address in IPv6 according to RPC6887. wrapped_addr needs to be able to store 16 bytes.\n+[[nodiscard]] static bool PCPWrapAddress(Span<uint8_t> wrapped_addr, const CNetAddr &addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (addr.IsIPv4()) {\n+        struct in_addr addr4;\n+        if (!addr.GetInAddr(&addr4)) return false;\n+        // Section 5: \"When the address field holds an IPv4 address, an IPv4-mapped IPv6 address [RFC4291] is used (::ffff:0:0/96).\"\n+        std::memcpy(wrapped_addr.data(), IPV4_IN_IPV6_PREFIX.data(), IPV4_IN_IPV6_PREFIX.size());\n+        std::memcpy(wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), &addr4, ADDR_IPV4_SIZE);\n+        return true;\n+    } else if (addr.IsIPv6()) {\n+        struct in6_addr addr6;\n+        if (!addr.GetIn6Addr(&addr6)) return false;\n+        std::memcpy(wrapped_addr.data(), &addr6, ADDR_IPV6_SIZE);\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+//! Unwrap PCP-encoded address according to RPC6887.\n+static CNetAddr PCPUnwrapAddress(Span<const uint8_t> wrapped_addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (HasPrefix(wrapped_addr, IPV4_IN_IPV6_PREFIX)) {\n+        struct in_addr addr4;\n+        std::memcpy(&addr4, wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), ADDR_IPV4_SIZE);\n+        return CNetAddr(addr4);\n+    } else {\n+        struct in6_addr addr6;\n+        std::memcpy(&addr6, wrapped_addr.data(), ADDR_IPV6_SIZE);\n+        return CNetAddr(addr6);\n+    }\n+}\n+\n+//! PCP or NAT-PMP send-receive loop.\n+static std::optional<std::vector<uint8_t>> PCPSendRecv(Sock &sock, const std::string &protocol, Span<const uint8_t> request, int num_tries,\n+        std::function<bool(const Span<const uint8_t>)> check_packet)\n+{\n+    // UDP is a potentially lossy protocol, so we try to send again a few times.\n+    uint8_t response[PCP_MAX_SIZE];\n+    bool got_response = false;\n+    int recvsz = 0;\n+    for (int ntry = 0; !got_response && ntry < num_tries; ++ntry) {\n+        if (ntry > 0) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Retrying (%d)\\n\", protocol, ntry);\n+        }\n+        // Dispatch packet to gateway.\n+        if (sock.Send(request.data(), request.size(), 0) != static_cast<ssize_t>(request.size())) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not send request: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));",
      "path": "src/util/pcp.cpp",
      "position": 233,
      "original_position": 228,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "82b1c25b9ca61f5b0382a5196e0ff7016b4d1429",
      "in_reply_to_id": 1611906833,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "If it appears after the IPv4 gateway log message it's for the IPv4 gateway, if it's after the IPv6 one it's for the IPv6 gateway. No more than two gateways are ever used. i don't think adding it to every log message is worth it.\r\n\r\n> Update: this happens when I'm connected with a physical LAN cable and wifi. So the warning was safe to ignore, but I'm still curious about it.\r\n\r\nRight i think that's the reason-if you have multiple internet connections, then mapping the IPv6 addresses connected to the other one (that's not the default gateway) will fail. This is a scenario too complex for automatic mapping to handle, anyhow. Glad to hear some addresses were still mapped correctly.\r\n\r\n(fairly sure this issue does not arise with IPv4, because it maps one port on the internal address toward the default gateway)",
      "created_at": "2024-05-23T16:45:35Z",
      "updated_at": "2024-05-23T17:50:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1612022021",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1612022021"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 233,
      "original_line": 233,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1612025592",
      "pull_request_review_id": 2074533276,
      "id": 1612025592,
      "node_id": "PRRC_kwDOABII585gFY74",
      "diff_hunk": "@@ -0,0 +1,287 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1302000)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = family == AF_INET ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    // Linux IPv4 / IPv6 - this must be present, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = family;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    // Linux IPv4 / IPv6 this must be absent, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (family == AF_INET) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (family == AF_INET6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    destination_address.si_family = family;\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    Assume(best_route.NextHop.si_family == family);\n+    if (family == AF_INET) {\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(family == AF_INET6) {\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+\n+// Ensure correct alignment for sockaddrs.\n+#define ROUNDUP(a) \\\n+    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(uint32_t) - 1))) : sizeof(uint32_t))\n+\n+static std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // MacOS: Get default gateway from route table.\n+    // See man page for route(4) for the format.\n+\n+    // net.route.0.inet[6].flags.gateway\n+    int mib[] = {CTL_NET, PF_ROUTE, 0, family, NET_RT_FLAGS, RTF_GATEWAY};\n+    size_t l = 0;\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), 0, &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl length of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    std::vector<std::byte> buf(l);\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), buf.data(), &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl data of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    const struct rt_msghdr* rt = nullptr;\n+    for (const std::byte* p = buf.data(); p < buf.data() + buf.size(); p += rt->rtm_msglen) {\n+        // Iterate over routing entry addresses, get destination and gateway (if present).\n+        rt = (const struct rt_msghdr*)p;\n+        const struct sockaddr* sa = (const struct sockaddr*)(rt + 1);",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 198,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "89ac09777d4d60a331fe1c482d87ecdd1aeb01a0",
      "in_reply_to_id": 1611691990,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "i moved the cast to the if() inside the inner loop.",
      "created_at": "2024-05-23T16:48:22Z",
      "updated_at": "2024-05-23T16:48:23Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1612025592",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1612025592"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 198,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1612076306",
      "pull_request_review_id": 2074627014,
      "id": 1612076306,
      "node_id": "PRRC_kwDOABII585gFlUS",
      "diff_hunk": "@@ -0,0 +1,287 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1302000)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = family == AF_INET ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    // Linux IPv4 / IPv6 - this must be present, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = family;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    // Linux IPv4 / IPv6 this must be absent, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (family == AF_INET) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (family == AF_INET6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    destination_address.si_family = family;\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    Assume(best_route.NextHop.si_family == family);\n+    if (family == AF_INET) {\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(family == AF_INET6) {\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+\n+// Ensure correct alignment for sockaddrs.\n+#define ROUNDUP(a) \\\n+    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(uint32_t) - 1))) : sizeof(uint32_t))\n+\n+static std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // MacOS: Get default gateway from route table.\n+    // See man page for route(4) for the format.\n+\n+    // net.route.0.inet[6].flags.gateway\n+    int mib[] = {CTL_NET, PF_ROUTE, 0, family, NET_RT_FLAGS, RTF_GATEWAY};\n+    size_t l = 0;\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), 0, &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl length of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    std::vector<std::byte> buf(l);\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), buf.data(), &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl data of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    const struct rt_msghdr* rt = nullptr;\n+    for (const std::byte* p = buf.data(); p < buf.data() + buf.size(); p += rt->rtm_msglen) {\n+        // Iterate over routing entry addresses, get destination and gateway (if present).\n+        rt = (const struct rt_msghdr*)p;\n+        const struct sockaddr* sa = (const struct sockaddr*)(rt + 1);\n+        std::optional<CNetAddr> dst;\n+        std::optional<CNetAddr> gateway;\n+        for (int i = 0; i < RTAX_MAX; i++) {\n+            if (rt->rtm_addrs & (1 << i)) {\n+                if (i == RTAX_DST) {\n+                    dst = FromSockAddr(sa);\n+                } else if (i == RTAX_GATEWAY) {\n+                    gateway = FromSockAddr(sa);\n+                }\n+                sa = (const struct sockaddr*)((std::byte*)sa + ROUNDUP(sa->sa_len));",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 208,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "89ac09777d4d60a331fe1c482d87ecdd1aeb01a0",
      "in_reply_to_id": 1611731634,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "That indeed looks better.\r\n\r\nThe *ptr variables are no longer actually pointers, so I suggest renaming them:\r\n\r\nmsgptr -> msg_pos\r\nwithin entry - within message\r\nsaptr -> sa_pos\r\nnext_msgptr -> next_msg_pos\r\n\r\nLet's set and check next_msgptr _before_ saptr and make it const.\r\n\r\n",
      "created_at": "2024-05-23T17:32:37Z",
      "updated_at": "2024-05-23T17:32:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1612076306",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1612076306"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 208,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1612195743",
      "pull_request_review_id": 2074820375,
      "id": 1612195743,
      "node_id": "PRRC_kwDOABII585gGCef",
      "diff_hunk": "@@ -0,0 +1,287 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1302000)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = family == AF_INET ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    // Linux IPv4 / IPv6 - this must be present, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = family;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    // Linux IPv4 / IPv6 this must be absent, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    ssize_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    size_t response_len = static_cast<size_t>(recv_result);\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (family == AF_INET) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (family == AF_INET6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    destination_address.si_family = family;\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    Assume(best_route.NextHop.si_family == family);\n+    if (family == AF_INET) {\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(family == AF_INET6) {\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+\n+// Ensure correct alignment for sockaddrs.\n+#define ROUNDUP(a) \\\n+    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(uint32_t) - 1))) : sizeof(uint32_t))\n+\n+static std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // MacOS: Get default gateway from route table.\n+    // See man page for route(4) for the format.\n+\n+    // net.route.0.inet[6].flags.gateway\n+    int mib[] = {CTL_NET, PF_ROUTE, 0, family, NET_RT_FLAGS, RTF_GATEWAY};\n+    size_t l = 0;\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), 0, &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl length of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    std::vector<std::byte> buf(l);\n+    if (sysctl(mib, sizeof(mib) / sizeof(int), buf.data(), &l, 0, 0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl data of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    const struct rt_msghdr* rt = nullptr;\n+    for (const std::byte* p = buf.data(); p < buf.data() + buf.size(); p += rt->rtm_msglen) {\n+        // Iterate over routing entry addresses, get destination and gateway (if present).\n+        rt = (const struct rt_msghdr*)p;",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 197,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "89ac09777d4d60a331fe1c482d87ecdd1aeb01a0",
      "in_reply_to_id": 1611661588,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "From what i understand, the error signalling and many of the flags and operations in the `rt_msghdr` are used with `PF_ROUTE` sockets, interactively. `sysctl` stores a read-only copy of the routing table data so that non-root users can access it.\r\nGranted, it's kind of a weird API.",
      "created_at": "2024-05-23T19:20:19Z",
      "updated_at": "2024-05-23T19:22:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1612195743",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1612195743"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 197,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613016087",
      "pull_request_review_id": 2076113676,
      "id": 1613016087,
      "node_id": "PRRC_kwDOABII585gJKwX",
      "diff_hunk": "@@ -0,0 +1,517 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/pcp.h>\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <random.h>\n+#include <span.h>\n+#include <util/check.h>\n+#include <util/netif.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+// RFC6886 NAT-PMP and RFC6887 Port Control Protocol (PCP) implementation.\n+// NAT-PMP and PCP use network byte order (big-endian).\n+\n+// NAT-PMP (v0) protocol constants.\n+//! NAT-PMP uses a fixed server port number (RPC6887 section 1.1).\n+constexpr uint16_t NATPMP_SERVER_PORT = 5351;\n+//! Version byte for NATPMP (RFC6886 1.1)\n+constexpr uint8_t NATPMP_VERSION = 0;\n+//! Request opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_REQUEST = 0x00;\n+//! Response opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_RESPONSE = 0x80;\n+//! Get external address (RFC6886 3.2)\n+constexpr uint8_t NATPMP_OP_GETEXTERNAL = 0x00;\n+//! Map TCP port (RFC6886 3.3)\n+constexpr uint8_t NATPMP_OP_MAP_TCP = 0x02;\n+//! Shared request header size in bytes.\n+constexpr size_t NATPMP_REQUEST_HDR_SIZE = 2;\n+//! Shared response header (minimum) size in bytes.\n+constexpr size_t NATPMP_RESPONSE_HDR_SIZE = 8;\n+//! GETEXTERNAL request size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 0;\n+//! GETEXTERNAL response size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 4;\n+//! MAP request size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 10;\n+//! MAP response size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 8;\n+\n+// Shared header offsets (RFC6886 3.2, 3.3), relative to start of packet.\n+//!  Offset of version field in packets.\n+constexpr size_t NATPMP_HDR_VERSION_OFS = 0;\n+//!  Offset of opcode field in packets\n+constexpr size_t NATPMP_HDR_OP_OFS = 1;\n+//!  Offset of result code in packets. Result codes are 16 bit in NAT-PMP instead of 8 bit in PCP.\n+constexpr size_t NATPMP_RESPONSE_HDR_RESULT_OFS = 2;\n+\n+// GETEXTERNAL response offsets (RFC6886 3.2), relative to start of packet.\n+//!  Returned external address\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_IP_OFS = 8;\n+\n+// MAP request offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port to be mapped.\n+constexpr size_t NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS = 4;\n+//!  Suggested external port for mapping.\n+constexpr size_t NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS = 6;\n+//!  Requested port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_REQUEST_LIFETIME_OFS = 8;\n+\n+// MAP response offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port for mapping (will match internal port of request).\n+constexpr size_t NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS = 8;\n+//!  External port for mapping.\n+constexpr size_t NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS = 10;\n+//!  Created port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_RESPONSE_LIFETIME_OFS = 12;\n+\n+// Relevant NETPMP result codes (RFC6886 3.5).\n+//! Result code representing success status.\n+constexpr uint8_t NATPMP_RESULT_SUCCESS = 0;\n+//! Result code representing unsupported version.\n+constexpr uint8_t NATPMP_RESULT_UNSUPP_VERSION = 1;\n+//! Result code representing lack of resources.\n+constexpr uint8_t NATPMP_RESULT_NO_RESOURCES = 4;\n+\n+//! Mapping of NATPMP result code to string (RPC6886 3.5). Result codes <=2 match PCP.\n+static const std::map<uint8_t, std::string> NATPMP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"NETWORK_FAILURE\"},\n+    {4,  \"NO_RESOURCES\"},\n+    {5,  \"UNSUPP_OPCODE\"},\n+};\n+\n+// PCP (v2) protocol constants.\n+//! Maximum packet size in bytes (RPC6887 section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (RPC6887 section 19.1). Shared with NAT-PMP.\n+constexpr uint16_t PCP_SERVER_PORT = NATPMP_SERVER_PORT;\n+//! Version byte. 0 is NAT-PMP (RFC6886), 1 is forbidden, 2 for PCP (RFC6887).\n+constexpr uint8_t PCP_VERSION = 2;\n+//! PCP Request Header. See RPC6887 section 7.1. Shared with NAT-PMP.\n+constexpr uint8_t PCP_REQUEST = NATPMP_REQUEST; // R = 0\n+//! PCP Response Header. See RPC6887 section 7.2. Shared with NAT-PMP.\n+constexpr uint8_t PCP_RESPONSE = NATPMP_RESPONSE; // R = 1\n+//! Map opcode. See RPC6887 section 19.2\n+constexpr uint8_t PCP_OP_MAP = 0x01;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Request and response header size in bytes (RPC6887 section 7.1).\n+constexpr size_t PCP_HDR_SIZE = 24;\n+//! Map request and response size in bytes (RPC6887 section 11.1).\n+constexpr size_t PCP_MAP_SIZE = 36;\n+\n+// Header offsets shared between request and responses (RFC6887 7.1, 7.2), relative to start of packet.\n+//!  Version field (1 byte).\n+constexpr size_t PCP_HDR_VERSION_OFS = NATPMP_HDR_VERSION_OFS;\n+//!  Opcode field (1 byte).\n+constexpr size_t PCP_HDR_OP_OFS = NATPMP_HDR_OP_OFS;\n+//!  Requested lifetime (request), granted lifetime (response) (2 bytes).\n+constexpr size_t PCP_HDR_LIFETIME_OFS = 4;\n+\n+// Request header offsets (RFC6887 7.1), relative to start of packet.\n+//!  PCP client's IP address (16 bytes).\n+constexpr size_t PCP_REQUEST_HDR_IP_OFS = 8;\n+\n+// Response header offsets (RFC6887 7.2), relative to start of packet.\n+//!  Result code (1 byte).\n+constexpr size_t PCP_RESPONSE_HDR_RESULT_OFS = 3;\n+\n+// MAP request/response offsets (RFC6887 11.1), relative to start of opcode-specific data.\n+//!  Mapping nonce (12 bytes).\n+constexpr size_t PCP_MAP_NONCE_OFS = 0;\n+//!  Protocol (1 byte).\n+constexpr size_t PCP_MAP_PROTOCOL_OFS = 12;\n+//!  Internal port for mapping (2 bytes).\n+constexpr size_t PCP_MAP_INTERNAL_PORT_OFS = 16;\n+//!  Suggested external port (request), assigned external port (response) (2 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_PORT_OFS = 18;\n+//!  Suggested external IP (request), assigned external IP (response) (16 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_IP_OFS = 20;\n+\n+//! Result code representing success (RPC6887 7.4), shared with NAT-PMP.\n+constexpr uint8_t PCP_RESULT_SUCCESS = NATPMP_RESULT_SUCCESS;\n+//! Result code representing lack of resources (RPC6887 7.4).\n+constexpr uint8_t PCP_RESULT_NO_RESOURCES = 8;\n+\n+//! Mapping of PCP result code to string (RPC6887 7.4). Result codes <=2 match NAT-PMP.\n+static const std::map<uint8_t, std::string> PCP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"MALFORMED_REQUEST\"},\n+    {4,  \"UNSUPP_OPCODE\"},\n+    {5,  \"UNSUPP_OPTION\"},\n+    {6,  \"MALFORMED_OPTION\"},\n+    {7,  \"NETWORK_FAILURE\"},\n+    {8,  \"NO_RESOURCES\"},\n+    {9,  \"UNSUPP_PROTOCOL\"},\n+    {10, \"USER_EX_QUOTA\"},\n+    {11, \"CANNOT_PROVIDE_EXTERNAL\"},\n+    {12, \"ADDRESS_MISMATCH\"},\n+    {13, \"EXCESSIVE_REMOTE_PEER\"},\n+};\n+\n+//! Return human-readable string from NATPMP result code.\n+static std::string NATPMPResultString(uint8_t result_code)\n+{\n+    auto result_i = NATPMP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == NATPMP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Return human-readable string from PCP result code.\n+static std::string PCPResultString(uint8_t result_code)\n+{\n+    auto result_i = PCP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == PCP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Wrap address in IPv6 according to RPC6887. wrapped_addr needs to be able to store 16 bytes.\n+[[nodiscard]] static bool PCPWrapAddress(Span<uint8_t> wrapped_addr, const CNetAddr &addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (addr.IsIPv4()) {\n+        struct in_addr addr4;\n+        if (!addr.GetInAddr(&addr4)) return false;\n+        // Section 5: \"When the address field holds an IPv4 address, an IPv4-mapped IPv6 address [RFC4291] is used (::ffff:0:0/96).\"\n+        std::memcpy(wrapped_addr.data(), IPV4_IN_IPV6_PREFIX.data(), IPV4_IN_IPV6_PREFIX.size());\n+        std::memcpy(wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), &addr4, ADDR_IPV4_SIZE);\n+        return true;\n+    } else if (addr.IsIPv6()) {\n+        struct in6_addr addr6;\n+        if (!addr.GetIn6Addr(&addr6)) return false;\n+        std::memcpy(wrapped_addr.data(), &addr6, ADDR_IPV6_SIZE);\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+//! Unwrap PCP-encoded address according to RPC6887.\n+static CNetAddr PCPUnwrapAddress(Span<const uint8_t> wrapped_addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (HasPrefix(wrapped_addr, IPV4_IN_IPV6_PREFIX)) {\n+        struct in_addr addr4;\n+        std::memcpy(&addr4, wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), ADDR_IPV4_SIZE);\n+        return CNetAddr(addr4);\n+    } else {\n+        struct in6_addr addr6;\n+        std::memcpy(&addr6, wrapped_addr.data(), ADDR_IPV6_SIZE);\n+        return CNetAddr(addr6);\n+    }\n+}\n+\n+//! PCP or NAT-PMP send-receive loop.\n+static std::optional<std::vector<uint8_t>> PCPSendRecv(Sock &sock, const std::string &protocol, Span<const uint8_t> request, int num_tries,\n+        std::function<bool(const Span<const uint8_t>)> check_packet)\n+{\n+    // UDP is a potentially lossy protocol, so we try to send again a few times.\n+    uint8_t response[PCP_MAX_SIZE];\n+    bool got_response = false;\n+    int recvsz = 0;\n+    for (int ntry = 0; !got_response && ntry < num_tries; ++ntry) {\n+        if (ntry > 0) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Retrying (%d)\\n\", protocol, ntry);\n+        }\n+        // Dispatch packet to gateway.\n+        if (sock.Send(request.data(), request.size(), 0) != static_cast<ssize_t>(request.size())) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not send request: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));",
      "path": "src/util/pcp.cpp",
      "position": 233,
      "original_position": 228,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "82b1c25b9ca61f5b0382a5196e0ff7016b4d1429",
      "in_reply_to_id": 1611906833,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I'm a bit surprised that when we ask for the default gateway, we get results for both network connections. But I guess we're not asking for the _default_ gateway on macOS, but rather all of them?",
      "created_at": "2024-05-24T07:46:40Z",
      "updated_at": "2024-05-24T07:46:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1613016087",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613016087"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 233,
      "original_line": 233,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613185703",
      "pull_request_review_id": 2076391051,
      "id": 1613185703,
      "node_id": "PRRC_kwDOABII585gJ0Kn",
      "diff_hunk": "@@ -0,0 +1,517 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/pcp.h>\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <random.h>\n+#include <span.h>\n+#include <util/check.h>\n+#include <util/netif.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+// RFC6886 NAT-PMP and RFC6887 Port Control Protocol (PCP) implementation.\n+// NAT-PMP and PCP use network byte order (big-endian).\n+\n+// NAT-PMP (v0) protocol constants.\n+//! NAT-PMP uses a fixed server port number (RPC6887 section 1.1).\n+constexpr uint16_t NATPMP_SERVER_PORT = 5351;\n+//! Version byte for NATPMP (RFC6886 1.1)\n+constexpr uint8_t NATPMP_VERSION = 0;\n+//! Request opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_REQUEST = 0x00;\n+//! Response opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_RESPONSE = 0x80;\n+//! Get external address (RFC6886 3.2)\n+constexpr uint8_t NATPMP_OP_GETEXTERNAL = 0x00;\n+//! Map TCP port (RFC6886 3.3)\n+constexpr uint8_t NATPMP_OP_MAP_TCP = 0x02;\n+//! Shared request header size in bytes.\n+constexpr size_t NATPMP_REQUEST_HDR_SIZE = 2;\n+//! Shared response header (minimum) size in bytes.\n+constexpr size_t NATPMP_RESPONSE_HDR_SIZE = 8;\n+//! GETEXTERNAL request size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 0;\n+//! GETEXTERNAL response size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 4;\n+//! MAP request size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 10;\n+//! MAP response size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 8;\n+\n+// Shared header offsets (RFC6886 3.2, 3.3), relative to start of packet.\n+//!  Offset of version field in packets.\n+constexpr size_t NATPMP_HDR_VERSION_OFS = 0;\n+//!  Offset of opcode field in packets\n+constexpr size_t NATPMP_HDR_OP_OFS = 1;\n+//!  Offset of result code in packets. Result codes are 16 bit in NAT-PMP instead of 8 bit in PCP.\n+constexpr size_t NATPMP_RESPONSE_HDR_RESULT_OFS = 2;\n+\n+// GETEXTERNAL response offsets (RFC6886 3.2), relative to start of packet.\n+//!  Returned external address\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_IP_OFS = 8;\n+\n+// MAP request offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port to be mapped.\n+constexpr size_t NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS = 4;\n+//!  Suggested external port for mapping.\n+constexpr size_t NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS = 6;\n+//!  Requested port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_REQUEST_LIFETIME_OFS = 8;\n+\n+// MAP response offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port for mapping (will match internal port of request).\n+constexpr size_t NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS = 8;\n+//!  External port for mapping.\n+constexpr size_t NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS = 10;\n+//!  Created port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_RESPONSE_LIFETIME_OFS = 12;\n+\n+// Relevant NETPMP result codes (RFC6886 3.5).\n+//! Result code representing success status.\n+constexpr uint8_t NATPMP_RESULT_SUCCESS = 0;\n+//! Result code representing unsupported version.\n+constexpr uint8_t NATPMP_RESULT_UNSUPP_VERSION = 1;\n+//! Result code representing lack of resources.\n+constexpr uint8_t NATPMP_RESULT_NO_RESOURCES = 4;\n+\n+//! Mapping of NATPMP result code to string (RPC6886 3.5). Result codes <=2 match PCP.\n+static const std::map<uint8_t, std::string> NATPMP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"NETWORK_FAILURE\"},\n+    {4,  \"NO_RESOURCES\"},\n+    {5,  \"UNSUPP_OPCODE\"},\n+};\n+\n+// PCP (v2) protocol constants.\n+//! Maximum packet size in bytes (RPC6887 section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (RPC6887 section 19.1). Shared with NAT-PMP.\n+constexpr uint16_t PCP_SERVER_PORT = NATPMP_SERVER_PORT;\n+//! Version byte. 0 is NAT-PMP (RFC6886), 1 is forbidden, 2 for PCP (RFC6887).\n+constexpr uint8_t PCP_VERSION = 2;\n+//! PCP Request Header. See RPC6887 section 7.1. Shared with NAT-PMP.\n+constexpr uint8_t PCP_REQUEST = NATPMP_REQUEST; // R = 0\n+//! PCP Response Header. See RPC6887 section 7.2. Shared with NAT-PMP.\n+constexpr uint8_t PCP_RESPONSE = NATPMP_RESPONSE; // R = 1\n+//! Map opcode. See RPC6887 section 19.2\n+constexpr uint8_t PCP_OP_MAP = 0x01;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Request and response header size in bytes (RPC6887 section 7.1).\n+constexpr size_t PCP_HDR_SIZE = 24;\n+//! Map request and response size in bytes (RPC6887 section 11.1).\n+constexpr size_t PCP_MAP_SIZE = 36;\n+\n+// Header offsets shared between request and responses (RFC6887 7.1, 7.2), relative to start of packet.\n+//!  Version field (1 byte).\n+constexpr size_t PCP_HDR_VERSION_OFS = NATPMP_HDR_VERSION_OFS;\n+//!  Opcode field (1 byte).\n+constexpr size_t PCP_HDR_OP_OFS = NATPMP_HDR_OP_OFS;\n+//!  Requested lifetime (request), granted lifetime (response) (2 bytes).\n+constexpr size_t PCP_HDR_LIFETIME_OFS = 4;\n+\n+// Request header offsets (RFC6887 7.1), relative to start of packet.\n+//!  PCP client's IP address (16 bytes).\n+constexpr size_t PCP_REQUEST_HDR_IP_OFS = 8;\n+\n+// Response header offsets (RFC6887 7.2), relative to start of packet.\n+//!  Result code (1 byte).\n+constexpr size_t PCP_RESPONSE_HDR_RESULT_OFS = 3;\n+\n+// MAP request/response offsets (RFC6887 11.1), relative to start of opcode-specific data.\n+//!  Mapping nonce (12 bytes).\n+constexpr size_t PCP_MAP_NONCE_OFS = 0;\n+//!  Protocol (1 byte).\n+constexpr size_t PCP_MAP_PROTOCOL_OFS = 12;\n+//!  Internal port for mapping (2 bytes).\n+constexpr size_t PCP_MAP_INTERNAL_PORT_OFS = 16;\n+//!  Suggested external port (request), assigned external port (response) (2 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_PORT_OFS = 18;\n+//!  Suggested external IP (request), assigned external IP (response) (16 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_IP_OFS = 20;\n+\n+//! Result code representing success (RPC6887 7.4), shared with NAT-PMP.\n+constexpr uint8_t PCP_RESULT_SUCCESS = NATPMP_RESULT_SUCCESS;\n+//! Result code representing lack of resources (RPC6887 7.4).\n+constexpr uint8_t PCP_RESULT_NO_RESOURCES = 8;\n+\n+//! Mapping of PCP result code to string (RPC6887 7.4). Result codes <=2 match NAT-PMP.\n+static const std::map<uint8_t, std::string> PCP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"MALFORMED_REQUEST\"},\n+    {4,  \"UNSUPP_OPCODE\"},\n+    {5,  \"UNSUPP_OPTION\"},\n+    {6,  \"MALFORMED_OPTION\"},\n+    {7,  \"NETWORK_FAILURE\"},\n+    {8,  \"NO_RESOURCES\"},\n+    {9,  \"UNSUPP_PROTOCOL\"},\n+    {10, \"USER_EX_QUOTA\"},\n+    {11, \"CANNOT_PROVIDE_EXTERNAL\"},\n+    {12, \"ADDRESS_MISMATCH\"},\n+    {13, \"EXCESSIVE_REMOTE_PEER\"},\n+};\n+\n+//! Return human-readable string from NATPMP result code.\n+static std::string NATPMPResultString(uint8_t result_code)\n+{\n+    auto result_i = NATPMP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == NATPMP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Return human-readable string from PCP result code.\n+static std::string PCPResultString(uint8_t result_code)\n+{\n+    auto result_i = PCP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == PCP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Wrap address in IPv6 according to RPC6887. wrapped_addr needs to be able to store 16 bytes.\n+[[nodiscard]] static bool PCPWrapAddress(Span<uint8_t> wrapped_addr, const CNetAddr &addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (addr.IsIPv4()) {\n+        struct in_addr addr4;\n+        if (!addr.GetInAddr(&addr4)) return false;\n+        // Section 5: \"When the address field holds an IPv4 address, an IPv4-mapped IPv6 address [RFC4291] is used (::ffff:0:0/96).\"\n+        std::memcpy(wrapped_addr.data(), IPV4_IN_IPV6_PREFIX.data(), IPV4_IN_IPV6_PREFIX.size());\n+        std::memcpy(wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), &addr4, ADDR_IPV4_SIZE);\n+        return true;\n+    } else if (addr.IsIPv6()) {\n+        struct in6_addr addr6;\n+        if (!addr.GetIn6Addr(&addr6)) return false;\n+        std::memcpy(wrapped_addr.data(), &addr6, ADDR_IPV6_SIZE);\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+//! Unwrap PCP-encoded address according to RPC6887.\n+static CNetAddr PCPUnwrapAddress(Span<const uint8_t> wrapped_addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (HasPrefix(wrapped_addr, IPV4_IN_IPV6_PREFIX)) {\n+        struct in_addr addr4;\n+        std::memcpy(&addr4, wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), ADDR_IPV4_SIZE);\n+        return CNetAddr(addr4);\n+    } else {\n+        struct in6_addr addr6;\n+        std::memcpy(&addr6, wrapped_addr.data(), ADDR_IPV6_SIZE);\n+        return CNetAddr(addr6);\n+    }\n+}\n+\n+//! PCP or NAT-PMP send-receive loop.\n+static std::optional<std::vector<uint8_t>> PCPSendRecv(Sock &sock, const std::string &protocol, Span<const uint8_t> request, int num_tries,\n+        std::function<bool(const Span<const uint8_t>)> check_packet)\n+{\n+    // UDP is a potentially lossy protocol, so we try to send again a few times.\n+    uint8_t response[PCP_MAX_SIZE];\n+    bool got_response = false;\n+    int recvsz = 0;\n+    for (int ntry = 0; !got_response && ntry < num_tries; ++ntry) {\n+        if (ntry > 0) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Retrying (%d)\\n\", protocol, ntry);\n+        }\n+        // Dispatch packet to gateway.\n+        if (sock.Send(request.data(), request.size(), 0) != static_cast<ssize_t>(request.size())) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not send request: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));",
      "path": "src/util/pcp.cpp",
      "position": 233,
      "original_position": 228,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "82b1c25b9ca61f5b0382a5196e0ff7016b4d1429",
      "in_reply_to_id": 1611906833,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Oh I think I get it. In `ProcessPCP` (`mapport.cpp`) we call `PCPRequestPortMap` for every IPv6 address we have, as determined by `GetLocalAddresses()`.\r\n\r\nEach port map request is made to the default gateway. This is (usually) a scope-local addresses, see https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1610568498 \r\nSo unlike with IPv4, where a gateway like 192.168.1.1 is reachable through both network connections, the IPv6 default gateway is only reachable through _one_ connection.\r\n\r\nIn `PCPRequestPortMap` we create a socket and bind it to the intended destination address. I'm still a bit puzzled why `sock.Connect` doesn't fail and instead `sock.Send` is where the error is triggered. I suppose that's because that's where the OS realizes there's no route and gives up? That's indeed what the error `No route to host (65)` implies.\r\n\r\nAnd indeed we don't have to \"fix\" this. Section 2.3 says:\r\n\r\n> for a given IP address of a host, only one default route exists to reach other hosts on the Internet from that source IP address\r\n\r\nPCP itself doesn't support this kind of setup either.\r\n\r\nThe only thing that matters is that nodes in the outside world can connect to us, we don't care which of the two network connections ends up getting used.\r\n\r\nI guess if I were to turn off the wifi, and that happened to have been the default gateway, I won't get new inbound connections until 20 minutes have passed and we request a new mapping via the LAN default gateway. Haven't tested this.",
      "created_at": "2024-05-24T09:36:42Z",
      "updated_at": "2024-05-24T09:47:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1613185703",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613185703"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 233,
      "original_line": 233,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613246935",
      "pull_request_review_id": 2076503238,
      "id": 1613246935,
      "node_id": "PRRC_kwDOABII585gKDHX",
      "diff_hunk": "@@ -46,104 +43,95 @@ using namespace std::chrono_literals;\n static constexpr auto PORT_MAPPING_REANNOUNCE_PERIOD{20min};\n static constexpr auto PORT_MAPPING_RETRY_PERIOD{5min};\n \n-#ifdef USE_NATPMP\n-static uint16_t g_mapport_external_port = 0;\n-static bool NatpmpInit(natpmp_t* natpmp)\n+static bool ProcessPCP()\n {\n-    const int r_init = initnatpmp(natpmp, /* detect gateway automatically */ 0, /* forced gateway - NOT APPLIED*/ 0);\n-    if (r_init == 0) return true;\n-    LogPrintf(\"natpmp: initnatpmp() failed with %d error.\\n\", r_init);\n-    return false;\n-}\n+    // The same nonce is used for all mappings, this is allowed by the spec, and simplifies keeping track of them.\n+    PCPMappingNonce pcp_nonce;\n+    GetRandBytes(pcp_nonce);\n \n-static bool NatpmpDiscover(natpmp_t* natpmp, struct in_addr& external_ipv4_addr)\n-{\n-    const int r_send = sendpublicaddressrequest(natpmp);\n-    if (r_send == 2 /* OK */) {\n-        int r_read;\n-        natpmpresp_t response;\n-        do {\n-            r_read = readnatpmpresponseorretry(natpmp, &response);\n-        } while (r_read == NATPMP_TRYAGAIN);\n-\n-        if (r_read == 0) {\n-            external_ipv4_addr = response.pnu.publicaddress.addr;\n-            return true;\n-        } else if (r_read == NATPMP_ERR_NOGATEWAYSUPPORT) {\n-            LogPrintf(\"natpmp: The gateway does not support NAT-PMP.\\n\");\n+    bool ret = false;\n+    bool no_resources = false;\n+    const uint16_t private_port = GetListenPort();\n+    const uint32_t requested_lifetime = std::chrono::seconds(PORT_MAPPING_REANNOUNCE_PERIOD).count();\n+    uint32_t actual_lifetime = 0;\n+    std::chrono::milliseconds sleep_time;\n+\n+    // Local functor to handle result from PCP/NATPMP mapping.\n+    auto handle_mapping = [&](std::variant<MappingResult, MappingError> &res) -> void {\n+        if (MappingResult* mapping = std::get_if<MappingResult>(&res)) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Info, \"portmap: Added mapping %s\\n\", mapping->ToString());\n+            AddLocal(mapping->external, LOCAL_MAPPED);\n+            ret = true;\n+            actual_lifetime = std::min(actual_lifetime, mapping->lifetime);\n+        } else if (MappingError *err = std::get_if<MappingError>(&res)) {\n+            // Detailed error will already have been logged internally in respective Pormap function.",
      "path": "src/mapport.cpp",
      "position": null,
      "original_position": 74,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "9a265c6d75136991125730b8a6a901e95cfeb8f6",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "typo: portmap",
      "created_at": "2024-05-24T10:23:06Z",
      "updated_at": "2024-05-24T12:10:06Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1613246935",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613246935"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 67,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613266348",
      "pull_request_review_id": 2076503238,
      "id": 1613266348,
      "node_id": "PRRC_kwDOABII585gKH2s",
      "diff_hunk": "@@ -46,104 +43,95 @@ using namespace std::chrono_literals;\n static constexpr auto PORT_MAPPING_REANNOUNCE_PERIOD{20min};\n static constexpr auto PORT_MAPPING_RETRY_PERIOD{5min};\n \n-#ifdef USE_NATPMP\n-static uint16_t g_mapport_external_port = 0;\n-static bool NatpmpInit(natpmp_t* natpmp)\n+static bool ProcessPCP()\n {\n-    const int r_init = initnatpmp(natpmp, /* detect gateway automatically */ 0, /* forced gateway - NOT APPLIED*/ 0);\n-    if (r_init == 0) return true;\n-    LogPrintf(\"natpmp: initnatpmp() failed with %d error.\\n\", r_init);\n-    return false;\n-}\n+    // The same nonce is used for all mappings, this is allowed by the spec, and simplifies keeping track of them.\n+    PCPMappingNonce pcp_nonce;\n+    GetRandBytes(pcp_nonce);\n \n-static bool NatpmpDiscover(natpmp_t* natpmp, struct in_addr& external_ipv4_addr)\n-{\n-    const int r_send = sendpublicaddressrequest(natpmp);\n-    if (r_send == 2 /* OK */) {\n-        int r_read;\n-        natpmpresp_t response;\n-        do {\n-            r_read = readnatpmpresponseorretry(natpmp, &response);\n-        } while (r_read == NATPMP_TRYAGAIN);\n-\n-        if (r_read == 0) {\n-            external_ipv4_addr = response.pnu.publicaddress.addr;\n-            return true;\n-        } else if (r_read == NATPMP_ERR_NOGATEWAYSUPPORT) {\n-            LogPrintf(\"natpmp: The gateway does not support NAT-PMP.\\n\");\n+    bool ret = false;\n+    bool no_resources = false;\n+    const uint16_t private_port = GetListenPort();\n+    const uint32_t requested_lifetime = std::chrono::seconds(PORT_MAPPING_REANNOUNCE_PERIOD).count();\n+    uint32_t actual_lifetime = 0;\n+    std::chrono::milliseconds sleep_time;\n+\n+    // Local functor to handle result from PCP/NATPMP mapping.\n+    auto handle_mapping = [&](std::variant<MappingResult, MappingError> &res) -> void {\n+        if (MappingResult* mapping = std::get_if<MappingResult>(&res)) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Info, \"portmap: Added mapping %s\\n\", mapping->ToString());\n+            AddLocal(mapping->external, LOCAL_MAPPED);\n+            ret = true;\n+            actual_lifetime = std::min(actual_lifetime, mapping->lifetime);\n+        } else if (MappingError *err = std::get_if<MappingError>(&res)) {\n+            // Detailed error will already have been logged internally in respective Pormap function.\n+            if (*err == MappingError::NO_RESOURCES) {\n+                no_resources = true;\n+            }\n+        }\n+    };\n+\n+    do {\n+        actual_lifetime = requested_lifetime;\n+        no_resources = false; // Set to true if there was any \"no resources\" error.\n+        ret = false; // Set to true if any mapping succeeds.\n+\n+        // IPv4\n+        std::optional<CNetAddr> gateway4 = QueryDefaultGateway(NET_IPV4);\n+        if (!gateway4) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: Could not determine IPv4 default gateway\\n\");\n         } else {\n-            LogPrintf(\"natpmp: readnatpmpresponseorretry() for public address failed with %d error.\\n\", r_read);\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: gateway [IPv4]: %s\\n\", gateway4->ToStringAddr());\n+\n+            // Open a port mapping on whatever local address we have toward the gateway.\n+            struct in_addr inaddr_any;\n+            inaddr_any.s_addr = htonl(INADDR_ANY);\n+            auto res = PCPRequestPortMap(pcp_nonce, *gateway4, CNetAddr(inaddr_any), private_port, requested_lifetime);\n+            MappingError* pcp_err = std::get_if<MappingError>(&res);\n+            if (pcp_err && *pcp_err == MappingError::UNSUPP_VERSION) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: Got unsupported PCP version response, falling back to NAT-PMP\\n\");\n+                res = NATPMPRequestPortMap(*gateway4, private_port, requested_lifetime);\n+            }\n+            handle_mapping(res);\n         }\n-    } else {\n-        LogPrintf(\"natpmp: sendpublicaddressrequest() failed with %d error.\\n\", r_send);\n-    }\n \n-    return false;\n-}\n+        // IPv6\n+        std::optional<CNetAddr> gateway6 = QueryDefaultGateway(NET_IPV6);\n+        if (!gateway6) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: Could not determine IPv6 default gateway\\n\");\n+        } else {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: gateway [IPv6]: %s\\n\", gateway6->ToStringAddr());\n \n-static bool NatpmpMapping(natpmp_t* natpmp, const struct in_addr& external_ipv4_addr, uint16_t private_port, bool& external_ip_discovered)\n-{\n-    const uint16_t suggested_external_port = g_mapport_external_port ? g_mapport_external_port : private_port;\n-    const int r_send = sendnewportmappingrequest(natpmp, NATPMP_PROTOCOL_TCP, private_port, suggested_external_port, 3600 /*seconds*/);\n-    if (r_send == 12 /* OK */) {\n-        int r_read;\n-        natpmpresp_t response;\n-        do {\n-            r_read = readnatpmpresponseorretry(natpmp, &response);\n-        } while (r_read == NATPMP_TRYAGAIN);\n-\n-        if (r_read == 0) {\n-            auto pm = response.pnu.newportmapping;\n-            if (private_port == pm.privateport && pm.lifetime > 0) {\n-                g_mapport_external_port = pm.mappedpublicport;\n-                const CService external{external_ipv4_addr, pm.mappedpublicport};\n-                if (!external_ip_discovered && fDiscover) {\n-                    AddLocal(external, LOCAL_MAPPED);\n-                    external_ip_discovered = true;\n-                }\n-                LogPrintf(\"natpmp: Port mapping successful. External address = %s\\n\", external.ToStringAddrPort());\n-                return true;\n-            } else {\n-                LogPrintf(\"natpmp: Port mapping failed.\\n\");\n+            // Try to open pinholes for all routable local IPv6 addresses.\n+            for (const auto &addr: GetLocalAddresses()) {\n+                if (!addr.IsRoutable() || !addr.IsIPv6()) continue;\n+                auto res = PCPRequestPortMap(pcp_nonce, *gateway6, addr, private_port, requested_lifetime);\n+                handle_mapping(res);\n             }\n-        } else if (r_read == NATPMP_ERR_NOGATEWAYSUPPORT) {\n-            LogPrintf(\"natpmp: The gateway does not support NAT-PMP.\\n\");\n-        } else {\n-            LogPrintf(\"natpmp: readnatpmpresponseorretry() for port mapping failed with %d error.\\n\", r_read);\n         }\n-    } else {\n-        LogPrintf(\"natpmp: sendnewportmappingrequest() failed with %d error.\\n\", r_send);\n-    }\n-\n-    return false;\n-}\n \n-static bool ProcessNatpmp()\n-{\n-    bool ret = false;\n-    natpmp_t natpmp;\n-    struct in_addr external_ipv4_addr;\n-    if (NatpmpInit(&natpmp) && NatpmpDiscover(&natpmp, external_ipv4_addr)) {\n-        bool external_ip_discovered = false;\n-        const uint16_t private_port = GetListenPort();\n-        do {\n-            ret = NatpmpMapping(&natpmp, external_ipv4_addr, private_port, external_ip_discovered);\n-        } while (ret && g_mapport_interrupt.sleep_for(PORT_MAPPING_REANNOUNCE_PERIOD));\n-        g_mapport_interrupt.reset();\n+        // Log message if we got NO_RESOURCES.\n+        if (no_resources) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"portmap: At least one mapping failed because of a NO_RESOURCES error. This usually indicates that the port is already used on the router. If this is the only instance of bitcoin running on the network, this will resolve itself automatically. Otherwise, you might want to choose a different P2P port to prevent this conflict.\\n\");\n+        }\n \n-        const int r_send = sendnewportmappingrequest(&natpmp, NATPMP_PROTOCOL_TCP, private_port, g_mapport_external_port, /* remove a port mapping */ 0);\n-        g_mapport_external_port = 0;\n-        if (r_send == 12 /* OK */) {\n-            LogPrintf(\"natpmp: Port mapping removed successfully.\\n\");\n-        } else {\n-            LogPrintf(\"natpmp: sendnewportmappingrequest(0) failed with %d error.\\n\", r_send);\n+        // Sanity-check returned lifetime.\n+        if (actual_lifetime < 30) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"portmap: Got impossibly short mapping lifetime of %d seconds\\n\", actual_lifetime);\n+            return false;\n         }\n-    }\n+        // RFC6887 11.2.1 recommends that clients send their first renewal packet at a time chosen with uniform random\n+        // distribution in the range 1/2 to 5/8 of expiration time.",
      "path": "src/mapport.cpp",
      "position": 191,
      "original_position": 190,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "9a265c6d75136991125730b8a6a901e95cfeb8f6",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```cpp\r\n// We only attempt renewal once.\r\n```\r\n\r\nThe spec recommend trying again with ever shorter intervals, but no less than 4 seconds, as the deadline approached. But it seems fine to not bother.\r\n\r\nIf renewal fails we fall out of the loop, `ProcessPCP` returns. At that point we fall back to UPNP (if enabled) and/or try again 5 minutes later.\r\n\r\nRenewal for NAT-PMP works the same it seems, see towards the end of https://datatracker.ietf.org/doc/html/rfc6886#section-3.3",
      "created_at": "2024-05-24T10:38:30Z",
      "updated_at": "2024-05-24T12:10:06Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1613266348",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613266348"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 125,
      "original_line": 125,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613380035",
      "pull_request_review_id": 2076503238,
      "id": 1613380035,
      "node_id": "PRRC_kwDOABII585gKjnD",
      "diff_hunk": "@@ -0,0 +1,517 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/pcp.h>\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <random.h>\n+#include <span.h>\n+#include <util/check.h>\n+#include <util/netif.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+// RFC6886 NAT-PMP and RFC6887 Port Control Protocol (PCP) implementation.\n+// NAT-PMP and PCP use network byte order (big-endian).\n+\n+// NAT-PMP (v0) protocol constants.\n+//! NAT-PMP uses a fixed server port number (RPC6887 section 1.1).\n+constexpr uint16_t NATPMP_SERVER_PORT = 5351;\n+//! Version byte for NATPMP (RFC6886 1.1)\n+constexpr uint8_t NATPMP_VERSION = 0;\n+//! Request opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_REQUEST = 0x00;\n+//! Response opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_RESPONSE = 0x80;\n+//! Get external address (RFC6886 3.2)\n+constexpr uint8_t NATPMP_OP_GETEXTERNAL = 0x00;\n+//! Map TCP port (RFC6886 3.3)\n+constexpr uint8_t NATPMP_OP_MAP_TCP = 0x02;\n+//! Shared request header size in bytes.\n+constexpr size_t NATPMP_REQUEST_HDR_SIZE = 2;\n+//! Shared response header (minimum) size in bytes.\n+constexpr size_t NATPMP_RESPONSE_HDR_SIZE = 8;\n+//! GETEXTERNAL request size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 0;\n+//! GETEXTERNAL response size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 4;\n+//! MAP request size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 10;\n+//! MAP response size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 8;\n+\n+// Shared header offsets (RFC6886 3.2, 3.3), relative to start of packet.\n+//!  Offset of version field in packets.\n+constexpr size_t NATPMP_HDR_VERSION_OFS = 0;\n+//!  Offset of opcode field in packets\n+constexpr size_t NATPMP_HDR_OP_OFS = 1;\n+//!  Offset of result code in packets. Result codes are 16 bit in NAT-PMP instead of 8 bit in PCP.\n+constexpr size_t NATPMP_RESPONSE_HDR_RESULT_OFS = 2;\n+\n+// GETEXTERNAL response offsets (RFC6886 3.2), relative to start of packet.\n+//!  Returned external address\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_IP_OFS = 8;\n+\n+// MAP request offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port to be mapped.\n+constexpr size_t NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS = 4;\n+//!  Suggested external port for mapping.\n+constexpr size_t NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS = 6;\n+//!  Requested port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_REQUEST_LIFETIME_OFS = 8;\n+\n+// MAP response offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port for mapping (will match internal port of request).\n+constexpr size_t NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS = 8;\n+//!  External port for mapping.\n+constexpr size_t NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS = 10;\n+//!  Created port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_RESPONSE_LIFETIME_OFS = 12;\n+\n+// Relevant NETPMP result codes (RFC6886 3.5).\n+//! Result code representing success status.\n+constexpr uint8_t NATPMP_RESULT_SUCCESS = 0;\n+//! Result code representing unsupported version.\n+constexpr uint8_t NATPMP_RESULT_UNSUPP_VERSION = 1;\n+//! Result code representing lack of resources.\n+constexpr uint8_t NATPMP_RESULT_NO_RESOURCES = 4;\n+\n+//! Mapping of NATPMP result code to string (RPC6886 3.5). Result codes <=2 match PCP.\n+static const std::map<uint8_t, std::string> NATPMP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"NETWORK_FAILURE\"},\n+    {4,  \"NO_RESOURCES\"},\n+    {5,  \"UNSUPP_OPCODE\"},\n+};\n+\n+// PCP (v2) protocol constants.\n+//! Maximum packet size in bytes (RPC6887 section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (RPC6887 section 19.1). Shared with NAT-PMP.\n+constexpr uint16_t PCP_SERVER_PORT = NATPMP_SERVER_PORT;\n+//! Version byte. 0 is NAT-PMP (RFC6886), 1 is forbidden, 2 for PCP (RFC6887).\n+constexpr uint8_t PCP_VERSION = 2;\n+//! PCP Request Header. See RPC6887 section 7.1. Shared with NAT-PMP.\n+constexpr uint8_t PCP_REQUEST = NATPMP_REQUEST; // R = 0\n+//! PCP Response Header. See RPC6887 section 7.2. Shared with NAT-PMP.\n+constexpr uint8_t PCP_RESPONSE = NATPMP_RESPONSE; // R = 1\n+//! Map opcode. See RPC6887 section 19.2\n+constexpr uint8_t PCP_OP_MAP = 0x01;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Request and response header size in bytes (RPC6887 section 7.1).\n+constexpr size_t PCP_HDR_SIZE = 24;\n+//! Map request and response size in bytes (RPC6887 section 11.1).\n+constexpr size_t PCP_MAP_SIZE = 36;\n+\n+// Header offsets shared between request and responses (RFC6887 7.1, 7.2), relative to start of packet.\n+//!  Version field (1 byte).\n+constexpr size_t PCP_HDR_VERSION_OFS = NATPMP_HDR_VERSION_OFS;\n+//!  Opcode field (1 byte).\n+constexpr size_t PCP_HDR_OP_OFS = NATPMP_HDR_OP_OFS;\n+//!  Requested lifetime (request), granted lifetime (response) (2 bytes).\n+constexpr size_t PCP_HDR_LIFETIME_OFS = 4;\n+\n+// Request header offsets (RFC6887 7.1), relative to start of packet.\n+//!  PCP client's IP address (16 bytes).\n+constexpr size_t PCP_REQUEST_HDR_IP_OFS = 8;\n+\n+// Response header offsets (RFC6887 7.2), relative to start of packet.\n+//!  Result code (1 byte).\n+constexpr size_t PCP_RESPONSE_HDR_RESULT_OFS = 3;\n+\n+// MAP request/response offsets (RFC6887 11.1), relative to start of opcode-specific data.\n+//!  Mapping nonce (12 bytes).\n+constexpr size_t PCP_MAP_NONCE_OFS = 0;\n+//!  Protocol (1 byte).\n+constexpr size_t PCP_MAP_PROTOCOL_OFS = 12;\n+//!  Internal port for mapping (2 bytes).\n+constexpr size_t PCP_MAP_INTERNAL_PORT_OFS = 16;\n+//!  Suggested external port (request), assigned external port (response) (2 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_PORT_OFS = 18;\n+//!  Suggested external IP (request), assigned external IP (response) (16 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_IP_OFS = 20;\n+\n+//! Result code representing success (RPC6887 7.4), shared with NAT-PMP.\n+constexpr uint8_t PCP_RESULT_SUCCESS = NATPMP_RESULT_SUCCESS;\n+//! Result code representing lack of resources (RPC6887 7.4).\n+constexpr uint8_t PCP_RESULT_NO_RESOURCES = 8;\n+\n+//! Mapping of PCP result code to string (RPC6887 7.4). Result codes <=2 match NAT-PMP.\n+static const std::map<uint8_t, std::string> PCP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"MALFORMED_REQUEST\"},\n+    {4,  \"UNSUPP_OPCODE\"},\n+    {5,  \"UNSUPP_OPTION\"},\n+    {6,  \"MALFORMED_OPTION\"},\n+    {7,  \"NETWORK_FAILURE\"},\n+    {8,  \"NO_RESOURCES\"},\n+    {9,  \"UNSUPP_PROTOCOL\"},\n+    {10, \"USER_EX_QUOTA\"},\n+    {11, \"CANNOT_PROVIDE_EXTERNAL\"},\n+    {12, \"ADDRESS_MISMATCH\"},\n+    {13, \"EXCESSIVE_REMOTE_PEER\"},\n+};\n+\n+//! Return human-readable string from NATPMP result code.\n+static std::string NATPMPResultString(uint8_t result_code)\n+{\n+    auto result_i = NATPMP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == NATPMP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Return human-readable string from PCP result code.\n+static std::string PCPResultString(uint8_t result_code)\n+{\n+    auto result_i = PCP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == PCP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Wrap address in IPv6 according to RPC6887. wrapped_addr needs to be able to store 16 bytes.\n+[[nodiscard]] static bool PCPWrapAddress(Span<uint8_t> wrapped_addr, const CNetAddr &addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (addr.IsIPv4()) {\n+        struct in_addr addr4;\n+        if (!addr.GetInAddr(&addr4)) return false;\n+        // Section 5: \"When the address field holds an IPv4 address, an IPv4-mapped IPv6 address [RFC4291] is used (::ffff:0:0/96).\"\n+        std::memcpy(wrapped_addr.data(), IPV4_IN_IPV6_PREFIX.data(), IPV4_IN_IPV6_PREFIX.size());\n+        std::memcpy(wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), &addr4, ADDR_IPV4_SIZE);\n+        return true;\n+    } else if (addr.IsIPv6()) {\n+        struct in6_addr addr6;\n+        if (!addr.GetIn6Addr(&addr6)) return false;\n+        std::memcpy(wrapped_addr.data(), &addr6, ADDR_IPV6_SIZE);\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+//! Unwrap PCP-encoded address according to RPC6887.\n+static CNetAddr PCPUnwrapAddress(Span<const uint8_t> wrapped_addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (HasPrefix(wrapped_addr, IPV4_IN_IPV6_PREFIX)) {\n+        struct in_addr addr4;\n+        std::memcpy(&addr4, wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), ADDR_IPV4_SIZE);\n+        return CNetAddr(addr4);\n+    } else {\n+        struct in6_addr addr6;\n+        std::memcpy(&addr6, wrapped_addr.data(), ADDR_IPV6_SIZE);\n+        return CNetAddr(addr6);\n+    }\n+}\n+\n+//! PCP or NAT-PMP send-receive loop.\n+static std::optional<std::vector<uint8_t>> PCPSendRecv(Sock &sock, const std::string &protocol, Span<const uint8_t> request, int num_tries,\n+        std::function<bool(const Span<const uint8_t>)> check_packet)\n+{\n+    // UDP is a potentially lossy protocol, so we try to send again a few times.\n+    uint8_t response[PCP_MAX_SIZE];\n+    bool got_response = false;\n+    int recvsz = 0;\n+    for (int ntry = 0; !got_response && ntry < num_tries; ++ntry) {\n+        if (ntry > 0) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Retrying (%d)\\n\", protocol, ntry);\n+        }\n+        // Dispatch packet to gateway.\n+        if (sock.Send(request.data(), request.size(), 0) != static_cast<ssize_t>(request.size())) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not send request: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+            return std::nullopt; // Network-level error, probably no use retrying.\n+        }\n+\n+        // Wait for response(s) until we get a valid response, a network error, or time out.\n+        while (true) {\n+            Sock::Event occurred = 0;\n+            if (!sock.Wait(std::chrono::milliseconds(1000), Sock::RECV, &occurred)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not wait on socket: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            if (!occurred) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Timeout\\n\", protocol);\n+                break; // Retry.\n+            }\n+\n+            // Receive response.\n+            recvsz = sock.Recv(response, sizeof(response), MSG_DONTWAIT);\n+            if (recvsz < 0) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not receive response: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Received response of %d bytes: %s\\n\", protocol, recvsz, HexStr(Span(response, recvsz)));\n+\n+            if (check_packet(Span<uint8_t>(response, recvsz))) {",
      "path": "src/util/pcp.cpp",
      "position": 259,
      "original_position": 252,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "9a265c6d75136991125730b8a6a901e95cfeb8f6",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "It seems like the gateway can keep us waiting forever by sending an invalid response at least once per second. Should we give up at some point?",
      "created_at": "2024-05-24T12:10:02Z",
      "updated_at": "2024-05-24T12:11:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1613380035",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613380035"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 259,
      "original_line": 259,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613775486",
      "pull_request_review_id": 2077437627,
      "id": 1613775486,
      "node_id": "PRRC_kwDOABII585gMEJ-",
      "diff_hunk": "@@ -0,0 +1,517 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/pcp.h>\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <random.h>\n+#include <span.h>\n+#include <util/check.h>\n+#include <util/netif.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+// RFC6886 NAT-PMP and RFC6887 Port Control Protocol (PCP) implementation.\n+// NAT-PMP and PCP use network byte order (big-endian).\n+\n+// NAT-PMP (v0) protocol constants.\n+//! NAT-PMP uses a fixed server port number (RPC6887 section 1.1).\n+constexpr uint16_t NATPMP_SERVER_PORT = 5351;\n+//! Version byte for NATPMP (RFC6886 1.1)\n+constexpr uint8_t NATPMP_VERSION = 0;\n+//! Request opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_REQUEST = 0x00;\n+//! Response opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_RESPONSE = 0x80;\n+//! Get external address (RFC6886 3.2)\n+constexpr uint8_t NATPMP_OP_GETEXTERNAL = 0x00;\n+//! Map TCP port (RFC6886 3.3)\n+constexpr uint8_t NATPMP_OP_MAP_TCP = 0x02;\n+//! Shared request header size in bytes.\n+constexpr size_t NATPMP_REQUEST_HDR_SIZE = 2;\n+//! Shared response header (minimum) size in bytes.\n+constexpr size_t NATPMP_RESPONSE_HDR_SIZE = 8;\n+//! GETEXTERNAL request size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 0;\n+//! GETEXTERNAL response size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 4;\n+//! MAP request size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 10;\n+//! MAP response size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 8;\n+\n+// Shared header offsets (RFC6886 3.2, 3.3), relative to start of packet.\n+//!  Offset of version field in packets.\n+constexpr size_t NATPMP_HDR_VERSION_OFS = 0;\n+//!  Offset of opcode field in packets\n+constexpr size_t NATPMP_HDR_OP_OFS = 1;\n+//!  Offset of result code in packets. Result codes are 16 bit in NAT-PMP instead of 8 bit in PCP.\n+constexpr size_t NATPMP_RESPONSE_HDR_RESULT_OFS = 2;\n+\n+// GETEXTERNAL response offsets (RFC6886 3.2), relative to start of packet.\n+//!  Returned external address\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_IP_OFS = 8;\n+\n+// MAP request offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port to be mapped.\n+constexpr size_t NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS = 4;\n+//!  Suggested external port for mapping.\n+constexpr size_t NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS = 6;\n+//!  Requested port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_REQUEST_LIFETIME_OFS = 8;\n+\n+// MAP response offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port for mapping (will match internal port of request).\n+constexpr size_t NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS = 8;\n+//!  External port for mapping.\n+constexpr size_t NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS = 10;\n+//!  Created port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_RESPONSE_LIFETIME_OFS = 12;\n+\n+// Relevant NETPMP result codes (RFC6886 3.5).\n+//! Result code representing success status.\n+constexpr uint8_t NATPMP_RESULT_SUCCESS = 0;\n+//! Result code representing unsupported version.\n+constexpr uint8_t NATPMP_RESULT_UNSUPP_VERSION = 1;\n+//! Result code representing lack of resources.\n+constexpr uint8_t NATPMP_RESULT_NO_RESOURCES = 4;\n+\n+//! Mapping of NATPMP result code to string (RPC6886 3.5). Result codes <=2 match PCP.\n+static const std::map<uint8_t, std::string> NATPMP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"NETWORK_FAILURE\"},\n+    {4,  \"NO_RESOURCES\"},\n+    {5,  \"UNSUPP_OPCODE\"},\n+};\n+\n+// PCP (v2) protocol constants.\n+//! Maximum packet size in bytes (RPC6887 section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (RPC6887 section 19.1). Shared with NAT-PMP.\n+constexpr uint16_t PCP_SERVER_PORT = NATPMP_SERVER_PORT;\n+//! Version byte. 0 is NAT-PMP (RFC6886), 1 is forbidden, 2 for PCP (RFC6887).\n+constexpr uint8_t PCP_VERSION = 2;\n+//! PCP Request Header. See RPC6887 section 7.1. Shared with NAT-PMP.\n+constexpr uint8_t PCP_REQUEST = NATPMP_REQUEST; // R = 0\n+//! PCP Response Header. See RPC6887 section 7.2. Shared with NAT-PMP.\n+constexpr uint8_t PCP_RESPONSE = NATPMP_RESPONSE; // R = 1\n+//! Map opcode. See RPC6887 section 19.2\n+constexpr uint8_t PCP_OP_MAP = 0x01;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Request and response header size in bytes (RPC6887 section 7.1).\n+constexpr size_t PCP_HDR_SIZE = 24;\n+//! Map request and response size in bytes (RPC6887 section 11.1).\n+constexpr size_t PCP_MAP_SIZE = 36;\n+\n+// Header offsets shared between request and responses (RFC6887 7.1, 7.2), relative to start of packet.\n+//!  Version field (1 byte).\n+constexpr size_t PCP_HDR_VERSION_OFS = NATPMP_HDR_VERSION_OFS;\n+//!  Opcode field (1 byte).\n+constexpr size_t PCP_HDR_OP_OFS = NATPMP_HDR_OP_OFS;\n+//!  Requested lifetime (request), granted lifetime (response) (2 bytes).\n+constexpr size_t PCP_HDR_LIFETIME_OFS = 4;\n+\n+// Request header offsets (RFC6887 7.1), relative to start of packet.\n+//!  PCP client's IP address (16 bytes).\n+constexpr size_t PCP_REQUEST_HDR_IP_OFS = 8;\n+\n+// Response header offsets (RFC6887 7.2), relative to start of packet.\n+//!  Result code (1 byte).\n+constexpr size_t PCP_RESPONSE_HDR_RESULT_OFS = 3;\n+\n+// MAP request/response offsets (RFC6887 11.1), relative to start of opcode-specific data.\n+//!  Mapping nonce (12 bytes).\n+constexpr size_t PCP_MAP_NONCE_OFS = 0;\n+//!  Protocol (1 byte).\n+constexpr size_t PCP_MAP_PROTOCOL_OFS = 12;\n+//!  Internal port for mapping (2 bytes).\n+constexpr size_t PCP_MAP_INTERNAL_PORT_OFS = 16;\n+//!  Suggested external port (request), assigned external port (response) (2 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_PORT_OFS = 18;\n+//!  Suggested external IP (request), assigned external IP (response) (16 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_IP_OFS = 20;\n+\n+//! Result code representing success (RPC6887 7.4), shared with NAT-PMP.\n+constexpr uint8_t PCP_RESULT_SUCCESS = NATPMP_RESULT_SUCCESS;\n+//! Result code representing lack of resources (RPC6887 7.4).\n+constexpr uint8_t PCP_RESULT_NO_RESOURCES = 8;\n+\n+//! Mapping of PCP result code to string (RPC6887 7.4). Result codes <=2 match NAT-PMP.\n+static const std::map<uint8_t, std::string> PCP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"MALFORMED_REQUEST\"},\n+    {4,  \"UNSUPP_OPCODE\"},\n+    {5,  \"UNSUPP_OPTION\"},\n+    {6,  \"MALFORMED_OPTION\"},\n+    {7,  \"NETWORK_FAILURE\"},\n+    {8,  \"NO_RESOURCES\"},\n+    {9,  \"UNSUPP_PROTOCOL\"},\n+    {10, \"USER_EX_QUOTA\"},\n+    {11, \"CANNOT_PROVIDE_EXTERNAL\"},\n+    {12, \"ADDRESS_MISMATCH\"},\n+    {13, \"EXCESSIVE_REMOTE_PEER\"},\n+};\n+\n+//! Return human-readable string from NATPMP result code.\n+static std::string NATPMPResultString(uint8_t result_code)\n+{\n+    auto result_i = NATPMP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == NATPMP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Return human-readable string from PCP result code.\n+static std::string PCPResultString(uint8_t result_code)\n+{\n+    auto result_i = PCP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == PCP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Wrap address in IPv6 according to RPC6887. wrapped_addr needs to be able to store 16 bytes.\n+[[nodiscard]] static bool PCPWrapAddress(Span<uint8_t> wrapped_addr, const CNetAddr &addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (addr.IsIPv4()) {\n+        struct in_addr addr4;\n+        if (!addr.GetInAddr(&addr4)) return false;\n+        // Section 5: \"When the address field holds an IPv4 address, an IPv4-mapped IPv6 address [RFC4291] is used (::ffff:0:0/96).\"\n+        std::memcpy(wrapped_addr.data(), IPV4_IN_IPV6_PREFIX.data(), IPV4_IN_IPV6_PREFIX.size());\n+        std::memcpy(wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), &addr4, ADDR_IPV4_SIZE);\n+        return true;\n+    } else if (addr.IsIPv6()) {\n+        struct in6_addr addr6;\n+        if (!addr.GetIn6Addr(&addr6)) return false;\n+        std::memcpy(wrapped_addr.data(), &addr6, ADDR_IPV6_SIZE);\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+//! Unwrap PCP-encoded address according to RPC6887.\n+static CNetAddr PCPUnwrapAddress(Span<const uint8_t> wrapped_addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (HasPrefix(wrapped_addr, IPV4_IN_IPV6_PREFIX)) {\n+        struct in_addr addr4;\n+        std::memcpy(&addr4, wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), ADDR_IPV4_SIZE);\n+        return CNetAddr(addr4);\n+    } else {\n+        struct in6_addr addr6;\n+        std::memcpy(&addr6, wrapped_addr.data(), ADDR_IPV6_SIZE);\n+        return CNetAddr(addr6);\n+    }\n+}\n+\n+//! PCP or NAT-PMP send-receive loop.\n+static std::optional<std::vector<uint8_t>> PCPSendRecv(Sock &sock, const std::string &protocol, Span<const uint8_t> request, int num_tries,\n+        std::function<bool(const Span<const uint8_t>)> check_packet)\n+{\n+    // UDP is a potentially lossy protocol, so we try to send again a few times.\n+    uint8_t response[PCP_MAX_SIZE];\n+    bool got_response = false;\n+    int recvsz = 0;\n+    for (int ntry = 0; !got_response && ntry < num_tries; ++ntry) {\n+        if (ntry > 0) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Retrying (%d)\\n\", protocol, ntry);\n+        }\n+        // Dispatch packet to gateway.\n+        if (sock.Send(request.data(), request.size(), 0) != static_cast<ssize_t>(request.size())) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not send request: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+            return std::nullopt; // Network-level error, probably no use retrying.\n+        }\n+\n+        // Wait for response(s) until we get a valid response, a network error, or time out.\n+        while (true) {\n+            Sock::Event occurred = 0;\n+            if (!sock.Wait(std::chrono::milliseconds(1000), Sock::RECV, &occurred)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not wait on socket: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            if (!occurred) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Timeout\\n\", protocol);\n+                break; // Retry.\n+            }\n+\n+            // Receive response.\n+            recvsz = sock.Recv(response, sizeof(response), MSG_DONTWAIT);\n+            if (recvsz < 0) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not receive response: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Received response of %d bytes: %s\\n\", protocol, recvsz, HexStr(Span(response, recvsz)));\n+\n+            if (check_packet(Span<uint8_t>(response, recvsz))) {",
      "path": "src/util/pcp.cpp",
      "position": 259,
      "original_position": 252,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "9a265c6d75136991125730b8a6a901e95cfeb8f6",
      "in_reply_to_id": 1613380035,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "yes, the proper way would be to set a deadline with a monotonic clock, instead of using the same timeout every time\r\nthough, everything considered, the gateway can only hold up this thread; it's not like the rest of bitcoind is waiting on it, and if the gateway is not to be trusted then it's not like we're going to get any useful mappings anyway",
      "created_at": "2024-05-24T16:57:35Z",
      "updated_at": "2024-05-24T16:57:36Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1613775486",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613775486"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 259,
      "original_line": 259,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613785831",
      "pull_request_review_id": 2077455116,
      "id": 1613785831,
      "node_id": "PRRC_kwDOABII585gMGrn",
      "diff_hunk": "@@ -46,104 +43,95 @@ using namespace std::chrono_literals;\n static constexpr auto PORT_MAPPING_REANNOUNCE_PERIOD{20min};\n static constexpr auto PORT_MAPPING_RETRY_PERIOD{5min};\n \n-#ifdef USE_NATPMP\n-static uint16_t g_mapport_external_port = 0;\n-static bool NatpmpInit(natpmp_t* natpmp)\n+static bool ProcessPCP()\n {\n-    const int r_init = initnatpmp(natpmp, /* detect gateway automatically */ 0, /* forced gateway - NOT APPLIED*/ 0);\n-    if (r_init == 0) return true;\n-    LogPrintf(\"natpmp: initnatpmp() failed with %d error.\\n\", r_init);\n-    return false;\n-}\n+    // The same nonce is used for all mappings, this is allowed by the spec, and simplifies keeping track of them.\n+    PCPMappingNonce pcp_nonce;\n+    GetRandBytes(pcp_nonce);\n \n-static bool NatpmpDiscover(natpmp_t* natpmp, struct in_addr& external_ipv4_addr)\n-{\n-    const int r_send = sendpublicaddressrequest(natpmp);\n-    if (r_send == 2 /* OK */) {\n-        int r_read;\n-        natpmpresp_t response;\n-        do {\n-            r_read = readnatpmpresponseorretry(natpmp, &response);\n-        } while (r_read == NATPMP_TRYAGAIN);\n-\n-        if (r_read == 0) {\n-            external_ipv4_addr = response.pnu.publicaddress.addr;\n-            return true;\n-        } else if (r_read == NATPMP_ERR_NOGATEWAYSUPPORT) {\n-            LogPrintf(\"natpmp: The gateway does not support NAT-PMP.\\n\");\n+    bool ret = false;\n+    bool no_resources = false;\n+    const uint16_t private_port = GetListenPort();\n+    const uint32_t requested_lifetime = std::chrono::seconds(PORT_MAPPING_REANNOUNCE_PERIOD).count();\n+    uint32_t actual_lifetime = 0;\n+    std::chrono::milliseconds sleep_time;\n+\n+    // Local functor to handle result from PCP/NATPMP mapping.\n+    auto handle_mapping = [&](std::variant<MappingResult, MappingError> &res) -> void {\n+        if (MappingResult* mapping = std::get_if<MappingResult>(&res)) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Info, \"portmap: Added mapping %s\\n\", mapping->ToString());\n+            AddLocal(mapping->external, LOCAL_MAPPED);\n+            ret = true;\n+            actual_lifetime = std::min(actual_lifetime, mapping->lifetime);\n+        } else if (MappingError *err = std::get_if<MappingError>(&res)) {\n+            // Detailed error will already have been logged internally in respective Pormap function.\n+            if (*err == MappingError::NO_RESOURCES) {\n+                no_resources = true;\n+            }\n+        }\n+    };\n+\n+    do {\n+        actual_lifetime = requested_lifetime;\n+        no_resources = false; // Set to true if there was any \"no resources\" error.\n+        ret = false; // Set to true if any mapping succeeds.\n+\n+        // IPv4\n+        std::optional<CNetAddr> gateway4 = QueryDefaultGateway(NET_IPV4);\n+        if (!gateway4) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: Could not determine IPv4 default gateway\\n\");\n         } else {\n-            LogPrintf(\"natpmp: readnatpmpresponseorretry() for public address failed with %d error.\\n\", r_read);\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: gateway [IPv4]: %s\\n\", gateway4->ToStringAddr());\n+\n+            // Open a port mapping on whatever local address we have toward the gateway.\n+            struct in_addr inaddr_any;\n+            inaddr_any.s_addr = htonl(INADDR_ANY);\n+            auto res = PCPRequestPortMap(pcp_nonce, *gateway4, CNetAddr(inaddr_any), private_port, requested_lifetime);\n+            MappingError* pcp_err = std::get_if<MappingError>(&res);\n+            if (pcp_err && *pcp_err == MappingError::UNSUPP_VERSION) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: Got unsupported PCP version response, falling back to NAT-PMP\\n\");\n+                res = NATPMPRequestPortMap(*gateway4, private_port, requested_lifetime);\n+            }\n+            handle_mapping(res);\n         }\n-    } else {\n-        LogPrintf(\"natpmp: sendpublicaddressrequest() failed with %d error.\\n\", r_send);\n-    }\n \n-    return false;\n-}\n+        // IPv6\n+        std::optional<CNetAddr> gateway6 = QueryDefaultGateway(NET_IPV6);\n+        if (!gateway6) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: Could not determine IPv6 default gateway\\n\");\n+        } else {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: gateway [IPv6]: %s\\n\", gateway6->ToStringAddr());\n \n-static bool NatpmpMapping(natpmp_t* natpmp, const struct in_addr& external_ipv4_addr, uint16_t private_port, bool& external_ip_discovered)\n-{\n-    const uint16_t suggested_external_port = g_mapport_external_port ? g_mapport_external_port : private_port;\n-    const int r_send = sendnewportmappingrequest(natpmp, NATPMP_PROTOCOL_TCP, private_port, suggested_external_port, 3600 /*seconds*/);\n-    if (r_send == 12 /* OK */) {\n-        int r_read;\n-        natpmpresp_t response;\n-        do {\n-            r_read = readnatpmpresponseorretry(natpmp, &response);\n-        } while (r_read == NATPMP_TRYAGAIN);\n-\n-        if (r_read == 0) {\n-            auto pm = response.pnu.newportmapping;\n-            if (private_port == pm.privateport && pm.lifetime > 0) {\n-                g_mapport_external_port = pm.mappedpublicport;\n-                const CService external{external_ipv4_addr, pm.mappedpublicport};\n-                if (!external_ip_discovered && fDiscover) {\n-                    AddLocal(external, LOCAL_MAPPED);\n-                    external_ip_discovered = true;\n-                }\n-                LogPrintf(\"natpmp: Port mapping successful. External address = %s\\n\", external.ToStringAddrPort());\n-                return true;\n-            } else {\n-                LogPrintf(\"natpmp: Port mapping failed.\\n\");\n+            // Try to open pinholes for all routable local IPv6 addresses.\n+            for (const auto &addr: GetLocalAddresses()) {\n+                if (!addr.IsRoutable() || !addr.IsIPv6()) continue;\n+                auto res = PCPRequestPortMap(pcp_nonce, *gateway6, addr, private_port, requested_lifetime);\n+                handle_mapping(res);\n             }\n-        } else if (r_read == NATPMP_ERR_NOGATEWAYSUPPORT) {\n-            LogPrintf(\"natpmp: The gateway does not support NAT-PMP.\\n\");\n-        } else {\n-            LogPrintf(\"natpmp: readnatpmpresponseorretry() for port mapping failed with %d error.\\n\", r_read);\n         }\n-    } else {\n-        LogPrintf(\"natpmp: sendnewportmappingrequest() failed with %d error.\\n\", r_send);\n-    }\n-\n-    return false;\n-}\n \n-static bool ProcessNatpmp()\n-{\n-    bool ret = false;\n-    natpmp_t natpmp;\n-    struct in_addr external_ipv4_addr;\n-    if (NatpmpInit(&natpmp) && NatpmpDiscover(&natpmp, external_ipv4_addr)) {\n-        bool external_ip_discovered = false;\n-        const uint16_t private_port = GetListenPort();\n-        do {\n-            ret = NatpmpMapping(&natpmp, external_ipv4_addr, private_port, external_ip_discovered);\n-        } while (ret && g_mapport_interrupt.sleep_for(PORT_MAPPING_REANNOUNCE_PERIOD));\n-        g_mapport_interrupt.reset();\n+        // Log message if we got NO_RESOURCES.\n+        if (no_resources) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"portmap: At least one mapping failed because of a NO_RESOURCES error. This usually indicates that the port is already used on the router. If this is the only instance of bitcoin running on the network, this will resolve itself automatically. Otherwise, you might want to choose a different P2P port to prevent this conflict.\\n\");\n+        }\n \n-        const int r_send = sendnewportmappingrequest(&natpmp, NATPMP_PROTOCOL_TCP, private_port, g_mapport_external_port, /* remove a port mapping */ 0);\n-        g_mapport_external_port = 0;\n-        if (r_send == 12 /* OK */) {\n-            LogPrintf(\"natpmp: Port mapping removed successfully.\\n\");\n-        } else {\n-            LogPrintf(\"natpmp: sendnewportmappingrequest(0) failed with %d error.\\n\", r_send);\n+        // Sanity-check returned lifetime.\n+        if (actual_lifetime < 30) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"portmap: Got impossibly short mapping lifetime of %d seconds\\n\", actual_lifetime);\n+            return false;\n         }\n-    }\n+        // RFC6887 11.2.1 recommends that clients send their first renewal packet at a time chosen with uniform random\n+        // distribution in the range 1/2 to 5/8 of expiration time.",
      "path": "src/mapport.cpp",
      "position": 191,
      "original_position": 190,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "9a265c6d75136991125730b8a6a901e95cfeb8f6",
      "in_reply_to_id": 1613266348,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> The spec recommend trying again with ever shorter intervals, but no less than 4 seconds, as the deadline approached. But it seems fine to not bother.\r\n\r\nRight, the retrying is not according to spec-because i had the same thought. It seems overkill to adaptive timing for something that's meant to interact with the local router. If it doesn't have enough capacity to handle a PCP/NAT-PMP packet it sure won't be routing a lot of traffic. i was more afraid that bitcoind (or the system it's running on) itself is blocked (due to heavy verification i/o load) that i implemented the \"start about halfway with renewal\" instead of having a margin of a minute :smile: \r\n\r\n> If renewal fails we fall out of the loop, ProcessPCP returns. At that point we fall back to UPNP (if enabled) and/or try again 5 minutes later.\r\n\r\nIndeed, that's my intent. Network configuration can always change, either by the user logging into another network or installing a different router/firmware update, so i think it's a feature that it keeps trying and it's otherwise stateless.",
      "created_at": "2024-05-24T17:08:42Z",
      "updated_at": "2024-05-24T17:08:42Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1613785831",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613785831"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 125,
      "original_line": 125,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613903504",
      "pull_request_review_id": 2077658541,
      "id": 1613903504,
      "node_id": "PRRC_kwDOABII585gMjaQ",
      "diff_hunk": "@@ -0,0 +1,517 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/pcp.h>\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <random.h>\n+#include <span.h>\n+#include <util/check.h>\n+#include <util/netif.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+// RFC6886 NAT-PMP and RFC6887 Port Control Protocol (PCP) implementation.\n+// NAT-PMP and PCP use network byte order (big-endian).\n+\n+// NAT-PMP (v0) protocol constants.\n+//! NAT-PMP uses a fixed server port number (RPC6887 section 1.1).\n+constexpr uint16_t NATPMP_SERVER_PORT = 5351;\n+//! Version byte for NATPMP (RFC6886 1.1)\n+constexpr uint8_t NATPMP_VERSION = 0;\n+//! Request opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_REQUEST = 0x00;\n+//! Response opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_RESPONSE = 0x80;\n+//! Get external address (RFC6886 3.2)\n+constexpr uint8_t NATPMP_OP_GETEXTERNAL = 0x00;\n+//! Map TCP port (RFC6886 3.3)\n+constexpr uint8_t NATPMP_OP_MAP_TCP = 0x02;\n+//! Shared request header size in bytes.\n+constexpr size_t NATPMP_REQUEST_HDR_SIZE = 2;\n+//! Shared response header (minimum) size in bytes.\n+constexpr size_t NATPMP_RESPONSE_HDR_SIZE = 8;\n+//! GETEXTERNAL request size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 0;\n+//! GETEXTERNAL response size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 4;\n+//! MAP request size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 10;\n+//! MAP response size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 8;\n+\n+// Shared header offsets (RFC6886 3.2, 3.3), relative to start of packet.\n+//!  Offset of version field in packets.\n+constexpr size_t NATPMP_HDR_VERSION_OFS = 0;\n+//!  Offset of opcode field in packets\n+constexpr size_t NATPMP_HDR_OP_OFS = 1;\n+//!  Offset of result code in packets. Result codes are 16 bit in NAT-PMP instead of 8 bit in PCP.\n+constexpr size_t NATPMP_RESPONSE_HDR_RESULT_OFS = 2;\n+\n+// GETEXTERNAL response offsets (RFC6886 3.2), relative to start of packet.\n+//!  Returned external address\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_IP_OFS = 8;\n+\n+// MAP request offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port to be mapped.\n+constexpr size_t NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS = 4;\n+//!  Suggested external port for mapping.\n+constexpr size_t NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS = 6;\n+//!  Requested port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_REQUEST_LIFETIME_OFS = 8;\n+\n+// MAP response offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port for mapping (will match internal port of request).\n+constexpr size_t NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS = 8;\n+//!  External port for mapping.\n+constexpr size_t NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS = 10;\n+//!  Created port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_RESPONSE_LIFETIME_OFS = 12;\n+\n+// Relevant NETPMP result codes (RFC6886 3.5).\n+//! Result code representing success status.\n+constexpr uint8_t NATPMP_RESULT_SUCCESS = 0;\n+//! Result code representing unsupported version.\n+constexpr uint8_t NATPMP_RESULT_UNSUPP_VERSION = 1;\n+//! Result code representing lack of resources.\n+constexpr uint8_t NATPMP_RESULT_NO_RESOURCES = 4;\n+\n+//! Mapping of NATPMP result code to string (RPC6886 3.5). Result codes <=2 match PCP.\n+static const std::map<uint8_t, std::string> NATPMP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"NETWORK_FAILURE\"},\n+    {4,  \"NO_RESOURCES\"},\n+    {5,  \"UNSUPP_OPCODE\"},\n+};\n+\n+// PCP (v2) protocol constants.\n+//! Maximum packet size in bytes (RPC6887 section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (RPC6887 section 19.1). Shared with NAT-PMP.\n+constexpr uint16_t PCP_SERVER_PORT = NATPMP_SERVER_PORT;\n+//! Version byte. 0 is NAT-PMP (RFC6886), 1 is forbidden, 2 for PCP (RFC6887).\n+constexpr uint8_t PCP_VERSION = 2;\n+//! PCP Request Header. See RPC6887 section 7.1. Shared with NAT-PMP.\n+constexpr uint8_t PCP_REQUEST = NATPMP_REQUEST; // R = 0\n+//! PCP Response Header. See RPC6887 section 7.2. Shared with NAT-PMP.\n+constexpr uint8_t PCP_RESPONSE = NATPMP_RESPONSE; // R = 1\n+//! Map opcode. See RPC6887 section 19.2\n+constexpr uint8_t PCP_OP_MAP = 0x01;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Request and response header size in bytes (RPC6887 section 7.1).\n+constexpr size_t PCP_HDR_SIZE = 24;\n+//! Map request and response size in bytes (RPC6887 section 11.1).\n+constexpr size_t PCP_MAP_SIZE = 36;\n+\n+// Header offsets shared between request and responses (RFC6887 7.1, 7.2), relative to start of packet.\n+//!  Version field (1 byte).\n+constexpr size_t PCP_HDR_VERSION_OFS = NATPMP_HDR_VERSION_OFS;\n+//!  Opcode field (1 byte).\n+constexpr size_t PCP_HDR_OP_OFS = NATPMP_HDR_OP_OFS;\n+//!  Requested lifetime (request), granted lifetime (response) (2 bytes).\n+constexpr size_t PCP_HDR_LIFETIME_OFS = 4;\n+\n+// Request header offsets (RFC6887 7.1), relative to start of packet.\n+//!  PCP client's IP address (16 bytes).\n+constexpr size_t PCP_REQUEST_HDR_IP_OFS = 8;\n+\n+// Response header offsets (RFC6887 7.2), relative to start of packet.\n+//!  Result code (1 byte).\n+constexpr size_t PCP_RESPONSE_HDR_RESULT_OFS = 3;\n+\n+// MAP request/response offsets (RFC6887 11.1), relative to start of opcode-specific data.\n+//!  Mapping nonce (12 bytes).\n+constexpr size_t PCP_MAP_NONCE_OFS = 0;\n+//!  Protocol (1 byte).\n+constexpr size_t PCP_MAP_PROTOCOL_OFS = 12;\n+//!  Internal port for mapping (2 bytes).\n+constexpr size_t PCP_MAP_INTERNAL_PORT_OFS = 16;\n+//!  Suggested external port (request), assigned external port (response) (2 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_PORT_OFS = 18;\n+//!  Suggested external IP (request), assigned external IP (response) (16 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_IP_OFS = 20;\n+\n+//! Result code representing success (RPC6887 7.4), shared with NAT-PMP.\n+constexpr uint8_t PCP_RESULT_SUCCESS = NATPMP_RESULT_SUCCESS;\n+//! Result code representing lack of resources (RPC6887 7.4).\n+constexpr uint8_t PCP_RESULT_NO_RESOURCES = 8;\n+\n+//! Mapping of PCP result code to string (RPC6887 7.4). Result codes <=2 match NAT-PMP.\n+static const std::map<uint8_t, std::string> PCP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"MALFORMED_REQUEST\"},\n+    {4,  \"UNSUPP_OPCODE\"},\n+    {5,  \"UNSUPP_OPTION\"},\n+    {6,  \"MALFORMED_OPTION\"},\n+    {7,  \"NETWORK_FAILURE\"},\n+    {8,  \"NO_RESOURCES\"},\n+    {9,  \"UNSUPP_PROTOCOL\"},\n+    {10, \"USER_EX_QUOTA\"},\n+    {11, \"CANNOT_PROVIDE_EXTERNAL\"},\n+    {12, \"ADDRESS_MISMATCH\"},\n+    {13, \"EXCESSIVE_REMOTE_PEER\"},\n+};\n+\n+//! Return human-readable string from NATPMP result code.\n+static std::string NATPMPResultString(uint8_t result_code)\n+{\n+    auto result_i = NATPMP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == NATPMP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Return human-readable string from PCP result code.\n+static std::string PCPResultString(uint8_t result_code)\n+{\n+    auto result_i = PCP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == PCP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Wrap address in IPv6 according to RPC6887. wrapped_addr needs to be able to store 16 bytes.\n+[[nodiscard]] static bool PCPWrapAddress(Span<uint8_t> wrapped_addr, const CNetAddr &addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (addr.IsIPv4()) {\n+        struct in_addr addr4;\n+        if (!addr.GetInAddr(&addr4)) return false;\n+        // Section 5: \"When the address field holds an IPv4 address, an IPv4-mapped IPv6 address [RFC4291] is used (::ffff:0:0/96).\"\n+        std::memcpy(wrapped_addr.data(), IPV4_IN_IPV6_PREFIX.data(), IPV4_IN_IPV6_PREFIX.size());\n+        std::memcpy(wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), &addr4, ADDR_IPV4_SIZE);\n+        return true;\n+    } else if (addr.IsIPv6()) {\n+        struct in6_addr addr6;\n+        if (!addr.GetIn6Addr(&addr6)) return false;\n+        std::memcpy(wrapped_addr.data(), &addr6, ADDR_IPV6_SIZE);\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+//! Unwrap PCP-encoded address according to RPC6887.\n+static CNetAddr PCPUnwrapAddress(Span<const uint8_t> wrapped_addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (HasPrefix(wrapped_addr, IPV4_IN_IPV6_PREFIX)) {\n+        struct in_addr addr4;\n+        std::memcpy(&addr4, wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), ADDR_IPV4_SIZE);\n+        return CNetAddr(addr4);\n+    } else {\n+        struct in6_addr addr6;\n+        std::memcpy(&addr6, wrapped_addr.data(), ADDR_IPV6_SIZE);\n+        return CNetAddr(addr6);\n+    }\n+}\n+\n+//! PCP or NAT-PMP send-receive loop.\n+static std::optional<std::vector<uint8_t>> PCPSendRecv(Sock &sock, const std::string &protocol, Span<const uint8_t> request, int num_tries,\n+        std::function<bool(const Span<const uint8_t>)> check_packet)\n+{\n+    // UDP is a potentially lossy protocol, so we try to send again a few times.\n+    uint8_t response[PCP_MAX_SIZE];\n+    bool got_response = false;\n+    int recvsz = 0;\n+    for (int ntry = 0; !got_response && ntry < num_tries; ++ntry) {\n+        if (ntry > 0) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Retrying (%d)\\n\", protocol, ntry);\n+        }\n+        // Dispatch packet to gateway.\n+        if (sock.Send(request.data(), request.size(), 0) != static_cast<ssize_t>(request.size())) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not send request: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+            return std::nullopt; // Network-level error, probably no use retrying.\n+        }\n+\n+        // Wait for response(s) until we get a valid response, a network error, or time out.\n+        while (true) {\n+            Sock::Event occurred = 0;\n+            if (!sock.Wait(std::chrono::milliseconds(1000), Sock::RECV, &occurred)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not wait on socket: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            if (!occurred) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Timeout\\n\", protocol);\n+                break; // Retry.\n+            }\n+\n+            // Receive response.\n+            recvsz = sock.Recv(response, sizeof(response), MSG_DONTWAIT);\n+            if (recvsz < 0) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not receive response: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Received response of %d bytes: %s\\n\", protocol, recvsz, HexStr(Span(response, recvsz)));\n+\n+            if (check_packet(Span<uint8_t>(response, recvsz))) {",
      "path": "src/util/pcp.cpp",
      "position": 259,
      "original_position": 252,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "9a265c6d75136991125730b8a6a901e95cfeb8f6",
      "in_reply_to_id": 1613380035,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "The chrono timepoint/duration stuff kind of confuses me. Would this be the idea? (assuming `timeout` is  per retry). `sock.Wait` takes milliseconds while the steady clock returns microseconds, so the cast seems unavoidable.\r\n```diff\r\n         }\r\n \r\n         // Wait for response(s) until we get a valid response, a network error, or time out.\r\n-        while (true) {\r\n+        auto cur_time = std::chrono::time_point_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now());\r\n+        auto deadline = cur_time + timeout;\r\n+        while ((cur_time = std::chrono::time_point_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now())) < deadline) {\r\n             Sock::Event occurred = 0;\r\n-            if (!sock.Wait(std::chrono::milliseconds(1000), Sock::RECV, &occurred)) {\r\n+            if (!sock.Wait(deadline - cur_time, Sock::RECV, &occurred)) {\r\n                 LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not wait on socket: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\r\n                 return std::nullopt; // Network-level error, probably no use retrying.\r\n             }\r\n```",
      "created_at": "2024-05-24T19:07:02Z",
      "updated_at": "2024-05-24T19:33:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1613903504",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1613903504"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 259,
      "original_line": 259,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1615586509",
      "pull_request_review_id": 2080168933,
      "id": 1615586509,
      "node_id": "PRRC_kwDOABII585gS-TN",
      "diff_hunk": "@@ -0,0 +1,517 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/pcp.h>\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <random.h>\n+#include <span.h>\n+#include <util/check.h>\n+#include <util/netif.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+// RFC6886 NAT-PMP and RFC6887 Port Control Protocol (PCP) implementation.\n+// NAT-PMP and PCP use network byte order (big-endian).\n+\n+// NAT-PMP (v0) protocol constants.\n+//! NAT-PMP uses a fixed server port number (RPC6887 section 1.1).\n+constexpr uint16_t NATPMP_SERVER_PORT = 5351;\n+//! Version byte for NATPMP (RFC6886 1.1)\n+constexpr uint8_t NATPMP_VERSION = 0;\n+//! Request opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_REQUEST = 0x00;\n+//! Response opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_RESPONSE = 0x80;\n+//! Get external address (RFC6886 3.2)\n+constexpr uint8_t NATPMP_OP_GETEXTERNAL = 0x00;\n+//! Map TCP port (RFC6886 3.3)\n+constexpr uint8_t NATPMP_OP_MAP_TCP = 0x02;\n+//! Shared request header size in bytes.\n+constexpr size_t NATPMP_REQUEST_HDR_SIZE = 2;\n+//! Shared response header (minimum) size in bytes.\n+constexpr size_t NATPMP_RESPONSE_HDR_SIZE = 8;\n+//! GETEXTERNAL request size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 0;\n+//! GETEXTERNAL response size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 4;\n+//! MAP request size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 10;\n+//! MAP response size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 8;\n+\n+// Shared header offsets (RFC6886 3.2, 3.3), relative to start of packet.\n+//!  Offset of version field in packets.\n+constexpr size_t NATPMP_HDR_VERSION_OFS = 0;\n+//!  Offset of opcode field in packets\n+constexpr size_t NATPMP_HDR_OP_OFS = 1;\n+//!  Offset of result code in packets. Result codes are 16 bit in NAT-PMP instead of 8 bit in PCP.\n+constexpr size_t NATPMP_RESPONSE_HDR_RESULT_OFS = 2;\n+\n+// GETEXTERNAL response offsets (RFC6886 3.2), relative to start of packet.\n+//!  Returned external address\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_IP_OFS = 8;\n+\n+// MAP request offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port to be mapped.\n+constexpr size_t NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS = 4;\n+//!  Suggested external port for mapping.\n+constexpr size_t NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS = 6;\n+//!  Requested port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_REQUEST_LIFETIME_OFS = 8;\n+\n+// MAP response offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port for mapping (will match internal port of request).\n+constexpr size_t NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS = 8;\n+//!  External port for mapping.\n+constexpr size_t NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS = 10;\n+//!  Created port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_RESPONSE_LIFETIME_OFS = 12;\n+\n+// Relevant NETPMP result codes (RFC6886 3.5).\n+//! Result code representing success status.\n+constexpr uint8_t NATPMP_RESULT_SUCCESS = 0;\n+//! Result code representing unsupported version.\n+constexpr uint8_t NATPMP_RESULT_UNSUPP_VERSION = 1;\n+//! Result code representing lack of resources.\n+constexpr uint8_t NATPMP_RESULT_NO_RESOURCES = 4;\n+\n+//! Mapping of NATPMP result code to string (RPC6886 3.5). Result codes <=2 match PCP.\n+static const std::map<uint8_t, std::string> NATPMP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"NETWORK_FAILURE\"},\n+    {4,  \"NO_RESOURCES\"},\n+    {5,  \"UNSUPP_OPCODE\"},\n+};\n+\n+// PCP (v2) protocol constants.\n+//! Maximum packet size in bytes (RPC6887 section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (RPC6887 section 19.1). Shared with NAT-PMP.\n+constexpr uint16_t PCP_SERVER_PORT = NATPMP_SERVER_PORT;\n+//! Version byte. 0 is NAT-PMP (RFC6886), 1 is forbidden, 2 for PCP (RFC6887).\n+constexpr uint8_t PCP_VERSION = 2;\n+//! PCP Request Header. See RPC6887 section 7.1. Shared with NAT-PMP.\n+constexpr uint8_t PCP_REQUEST = NATPMP_REQUEST; // R = 0\n+//! PCP Response Header. See RPC6887 section 7.2. Shared with NAT-PMP.\n+constexpr uint8_t PCP_RESPONSE = NATPMP_RESPONSE; // R = 1\n+//! Map opcode. See RPC6887 section 19.2\n+constexpr uint8_t PCP_OP_MAP = 0x01;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Request and response header size in bytes (RPC6887 section 7.1).\n+constexpr size_t PCP_HDR_SIZE = 24;\n+//! Map request and response size in bytes (RPC6887 section 11.1).\n+constexpr size_t PCP_MAP_SIZE = 36;\n+\n+// Header offsets shared between request and responses (RFC6887 7.1, 7.2), relative to start of packet.\n+//!  Version field (1 byte).\n+constexpr size_t PCP_HDR_VERSION_OFS = NATPMP_HDR_VERSION_OFS;\n+//!  Opcode field (1 byte).\n+constexpr size_t PCP_HDR_OP_OFS = NATPMP_HDR_OP_OFS;\n+//!  Requested lifetime (request), granted lifetime (response) (2 bytes).\n+constexpr size_t PCP_HDR_LIFETIME_OFS = 4;\n+\n+// Request header offsets (RFC6887 7.1), relative to start of packet.\n+//!  PCP client's IP address (16 bytes).\n+constexpr size_t PCP_REQUEST_HDR_IP_OFS = 8;\n+\n+// Response header offsets (RFC6887 7.2), relative to start of packet.\n+//!  Result code (1 byte).\n+constexpr size_t PCP_RESPONSE_HDR_RESULT_OFS = 3;\n+\n+// MAP request/response offsets (RFC6887 11.1), relative to start of opcode-specific data.\n+//!  Mapping nonce (12 bytes).\n+constexpr size_t PCP_MAP_NONCE_OFS = 0;\n+//!  Protocol (1 byte).\n+constexpr size_t PCP_MAP_PROTOCOL_OFS = 12;\n+//!  Internal port for mapping (2 bytes).\n+constexpr size_t PCP_MAP_INTERNAL_PORT_OFS = 16;\n+//!  Suggested external port (request), assigned external port (response) (2 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_PORT_OFS = 18;\n+//!  Suggested external IP (request), assigned external IP (response) (16 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_IP_OFS = 20;\n+\n+//! Result code representing success (RPC6887 7.4), shared with NAT-PMP.\n+constexpr uint8_t PCP_RESULT_SUCCESS = NATPMP_RESULT_SUCCESS;\n+//! Result code representing lack of resources (RPC6887 7.4).\n+constexpr uint8_t PCP_RESULT_NO_RESOURCES = 8;\n+\n+//! Mapping of PCP result code to string (RPC6887 7.4). Result codes <=2 match NAT-PMP.\n+static const std::map<uint8_t, std::string> PCP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"MALFORMED_REQUEST\"},\n+    {4,  \"UNSUPP_OPCODE\"},\n+    {5,  \"UNSUPP_OPTION\"},\n+    {6,  \"MALFORMED_OPTION\"},\n+    {7,  \"NETWORK_FAILURE\"},\n+    {8,  \"NO_RESOURCES\"},\n+    {9,  \"UNSUPP_PROTOCOL\"},\n+    {10, \"USER_EX_QUOTA\"},\n+    {11, \"CANNOT_PROVIDE_EXTERNAL\"},\n+    {12, \"ADDRESS_MISMATCH\"},\n+    {13, \"EXCESSIVE_REMOTE_PEER\"},\n+};\n+\n+//! Return human-readable string from NATPMP result code.\n+static std::string NATPMPResultString(uint8_t result_code)\n+{\n+    auto result_i = NATPMP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == NATPMP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Return human-readable string from PCP result code.\n+static std::string PCPResultString(uint8_t result_code)\n+{\n+    auto result_i = PCP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == PCP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Wrap address in IPv6 according to RPC6887. wrapped_addr needs to be able to store 16 bytes.\n+[[nodiscard]] static bool PCPWrapAddress(Span<uint8_t> wrapped_addr, const CNetAddr &addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (addr.IsIPv4()) {\n+        struct in_addr addr4;\n+        if (!addr.GetInAddr(&addr4)) return false;\n+        // Section 5: \"When the address field holds an IPv4 address, an IPv4-mapped IPv6 address [RFC4291] is used (::ffff:0:0/96).\"\n+        std::memcpy(wrapped_addr.data(), IPV4_IN_IPV6_PREFIX.data(), IPV4_IN_IPV6_PREFIX.size());\n+        std::memcpy(wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), &addr4, ADDR_IPV4_SIZE);\n+        return true;\n+    } else if (addr.IsIPv6()) {\n+        struct in6_addr addr6;\n+        if (!addr.GetIn6Addr(&addr6)) return false;\n+        std::memcpy(wrapped_addr.data(), &addr6, ADDR_IPV6_SIZE);\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+//! Unwrap PCP-encoded address according to RPC6887.\n+static CNetAddr PCPUnwrapAddress(Span<const uint8_t> wrapped_addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (HasPrefix(wrapped_addr, IPV4_IN_IPV6_PREFIX)) {\n+        struct in_addr addr4;\n+        std::memcpy(&addr4, wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), ADDR_IPV4_SIZE);\n+        return CNetAddr(addr4);\n+    } else {\n+        struct in6_addr addr6;\n+        std::memcpy(&addr6, wrapped_addr.data(), ADDR_IPV6_SIZE);\n+        return CNetAddr(addr6);\n+    }\n+}\n+\n+//! PCP or NAT-PMP send-receive loop.\n+static std::optional<std::vector<uint8_t>> PCPSendRecv(Sock &sock, const std::string &protocol, Span<const uint8_t> request, int num_tries,\n+        std::function<bool(const Span<const uint8_t>)> check_packet)\n+{\n+    // UDP is a potentially lossy protocol, so we try to send again a few times.\n+    uint8_t response[PCP_MAX_SIZE];\n+    bool got_response = false;\n+    int recvsz = 0;\n+    for (int ntry = 0; !got_response && ntry < num_tries; ++ntry) {\n+        if (ntry > 0) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Retrying (%d)\\n\", protocol, ntry);\n+        }\n+        // Dispatch packet to gateway.\n+        if (sock.Send(request.data(), request.size(), 0) != static_cast<ssize_t>(request.size())) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not send request: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+            return std::nullopt; // Network-level error, probably no use retrying.\n+        }\n+\n+        // Wait for response(s) until we get a valid response, a network error, or time out.\n+        while (true) {\n+            Sock::Event occurred = 0;\n+            if (!sock.Wait(std::chrono::milliseconds(1000), Sock::RECV, &occurred)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not wait on socket: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            if (!occurred) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Timeout\\n\", protocol);\n+                break; // Retry.\n+            }\n+\n+            // Receive response.\n+            recvsz = sock.Recv(response, sizeof(response), MSG_DONTWAIT);\n+            if (recvsz < 0) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not receive response: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Received response of %d bytes: %s\\n\", protocol, recvsz, HexStr(Span(response, recvsz)));\n+\n+            if (check_packet(Span<uint8_t>(response, recvsz))) {",
      "path": "src/util/pcp.cpp",
      "position": 259,
      "original_position": 252,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "9a265c6d75136991125730b8a6a901e95cfeb8f6",
      "in_reply_to_id": 1613380035,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I guess this could work if `timeout` isn't too long. Since if the router doens't support NAT-PMP / PCP it's not going to reply, it delays when we fall back to UPNP. But a few seconds seems fine.",
      "created_at": "2024-05-27T07:20:04Z",
      "updated_at": "2024-05-27T07:20:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1615586509",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1615586509"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 259,
      "original_line": 259,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1615628209",
      "pull_request_review_id": 2080239658,
      "id": 1615628209,
      "node_id": "PRRC_kwDOABII585gTIex",
      "diff_hunk": "@@ -0,0 +1,517 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/pcp.h>\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <random.h>\n+#include <span.h>\n+#include <util/check.h>\n+#include <util/netif.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+// RFC6886 NAT-PMP and RFC6887 Port Control Protocol (PCP) implementation.\n+// NAT-PMP and PCP use network byte order (big-endian).\n+\n+// NAT-PMP (v0) protocol constants.\n+//! NAT-PMP uses a fixed server port number (RPC6887 section 1.1).\n+constexpr uint16_t NATPMP_SERVER_PORT = 5351;\n+//! Version byte for NATPMP (RFC6886 1.1)\n+constexpr uint8_t NATPMP_VERSION = 0;\n+//! Request opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_REQUEST = 0x00;\n+//! Response opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_RESPONSE = 0x80;\n+//! Get external address (RFC6886 3.2)\n+constexpr uint8_t NATPMP_OP_GETEXTERNAL = 0x00;\n+//! Map TCP port (RFC6886 3.3)\n+constexpr uint8_t NATPMP_OP_MAP_TCP = 0x02;\n+//! Shared request header size in bytes.\n+constexpr size_t NATPMP_REQUEST_HDR_SIZE = 2;\n+//! Shared response header (minimum) size in bytes.\n+constexpr size_t NATPMP_RESPONSE_HDR_SIZE = 8;\n+//! GETEXTERNAL request size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 0;\n+//! GETEXTERNAL response size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 4;\n+//! MAP request size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 10;\n+//! MAP response size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 8;\n+\n+// Shared header offsets (RFC6886 3.2, 3.3), relative to start of packet.\n+//!  Offset of version field in packets.\n+constexpr size_t NATPMP_HDR_VERSION_OFS = 0;\n+//!  Offset of opcode field in packets\n+constexpr size_t NATPMP_HDR_OP_OFS = 1;\n+//!  Offset of result code in packets. Result codes are 16 bit in NAT-PMP instead of 8 bit in PCP.\n+constexpr size_t NATPMP_RESPONSE_HDR_RESULT_OFS = 2;\n+\n+// GETEXTERNAL response offsets (RFC6886 3.2), relative to start of packet.\n+//!  Returned external address\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_IP_OFS = 8;\n+\n+// MAP request offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port to be mapped.\n+constexpr size_t NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS = 4;\n+//!  Suggested external port for mapping.\n+constexpr size_t NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS = 6;\n+//!  Requested port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_REQUEST_LIFETIME_OFS = 8;\n+\n+// MAP response offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port for mapping (will match internal port of request).\n+constexpr size_t NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS = 8;\n+//!  External port for mapping.\n+constexpr size_t NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS = 10;\n+//!  Created port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_RESPONSE_LIFETIME_OFS = 12;\n+\n+// Relevant NETPMP result codes (RFC6886 3.5).\n+//! Result code representing success status.\n+constexpr uint8_t NATPMP_RESULT_SUCCESS = 0;\n+//! Result code representing unsupported version.\n+constexpr uint8_t NATPMP_RESULT_UNSUPP_VERSION = 1;\n+//! Result code representing lack of resources.\n+constexpr uint8_t NATPMP_RESULT_NO_RESOURCES = 4;\n+\n+//! Mapping of NATPMP result code to string (RPC6886 3.5). Result codes <=2 match PCP.\n+static const std::map<uint8_t, std::string> NATPMP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"NETWORK_FAILURE\"},\n+    {4,  \"NO_RESOURCES\"},\n+    {5,  \"UNSUPP_OPCODE\"},\n+};\n+\n+// PCP (v2) protocol constants.\n+//! Maximum packet size in bytes (RPC6887 section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (RPC6887 section 19.1). Shared with NAT-PMP.\n+constexpr uint16_t PCP_SERVER_PORT = NATPMP_SERVER_PORT;\n+//! Version byte. 0 is NAT-PMP (RFC6886), 1 is forbidden, 2 for PCP (RFC6887).\n+constexpr uint8_t PCP_VERSION = 2;\n+//! PCP Request Header. See RPC6887 section 7.1. Shared with NAT-PMP.\n+constexpr uint8_t PCP_REQUEST = NATPMP_REQUEST; // R = 0\n+//! PCP Response Header. See RPC6887 section 7.2. Shared with NAT-PMP.\n+constexpr uint8_t PCP_RESPONSE = NATPMP_RESPONSE; // R = 1\n+//! Map opcode. See RPC6887 section 19.2\n+constexpr uint8_t PCP_OP_MAP = 0x01;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Request and response header size in bytes (RPC6887 section 7.1).\n+constexpr size_t PCP_HDR_SIZE = 24;\n+//! Map request and response size in bytes (RPC6887 section 11.1).\n+constexpr size_t PCP_MAP_SIZE = 36;\n+\n+// Header offsets shared between request and responses (RFC6887 7.1, 7.2), relative to start of packet.\n+//!  Version field (1 byte).\n+constexpr size_t PCP_HDR_VERSION_OFS = NATPMP_HDR_VERSION_OFS;\n+//!  Opcode field (1 byte).\n+constexpr size_t PCP_HDR_OP_OFS = NATPMP_HDR_OP_OFS;\n+//!  Requested lifetime (request), granted lifetime (response) (2 bytes).\n+constexpr size_t PCP_HDR_LIFETIME_OFS = 4;\n+\n+// Request header offsets (RFC6887 7.1), relative to start of packet.\n+//!  PCP client's IP address (16 bytes).\n+constexpr size_t PCP_REQUEST_HDR_IP_OFS = 8;\n+\n+// Response header offsets (RFC6887 7.2), relative to start of packet.\n+//!  Result code (1 byte).\n+constexpr size_t PCP_RESPONSE_HDR_RESULT_OFS = 3;\n+\n+// MAP request/response offsets (RFC6887 11.1), relative to start of opcode-specific data.\n+//!  Mapping nonce (12 bytes).\n+constexpr size_t PCP_MAP_NONCE_OFS = 0;\n+//!  Protocol (1 byte).\n+constexpr size_t PCP_MAP_PROTOCOL_OFS = 12;\n+//!  Internal port for mapping (2 bytes).\n+constexpr size_t PCP_MAP_INTERNAL_PORT_OFS = 16;\n+//!  Suggested external port (request), assigned external port (response) (2 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_PORT_OFS = 18;\n+//!  Suggested external IP (request), assigned external IP (response) (16 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_IP_OFS = 20;\n+\n+//! Result code representing success (RPC6887 7.4), shared with NAT-PMP.\n+constexpr uint8_t PCP_RESULT_SUCCESS = NATPMP_RESULT_SUCCESS;\n+//! Result code representing lack of resources (RPC6887 7.4).\n+constexpr uint8_t PCP_RESULT_NO_RESOURCES = 8;\n+\n+//! Mapping of PCP result code to string (RPC6887 7.4). Result codes <=2 match NAT-PMP.\n+static const std::map<uint8_t, std::string> PCP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"MALFORMED_REQUEST\"},\n+    {4,  \"UNSUPP_OPCODE\"},\n+    {5,  \"UNSUPP_OPTION\"},\n+    {6,  \"MALFORMED_OPTION\"},\n+    {7,  \"NETWORK_FAILURE\"},\n+    {8,  \"NO_RESOURCES\"},\n+    {9,  \"UNSUPP_PROTOCOL\"},\n+    {10, \"USER_EX_QUOTA\"},\n+    {11, \"CANNOT_PROVIDE_EXTERNAL\"},\n+    {12, \"ADDRESS_MISMATCH\"},\n+    {13, \"EXCESSIVE_REMOTE_PEER\"},\n+};\n+\n+//! Return human-readable string from NATPMP result code.\n+static std::string NATPMPResultString(uint8_t result_code)\n+{\n+    auto result_i = NATPMP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == NATPMP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Return human-readable string from PCP result code.\n+static std::string PCPResultString(uint8_t result_code)\n+{\n+    auto result_i = PCP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == PCP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Wrap address in IPv6 according to RPC6887. wrapped_addr needs to be able to store 16 bytes.\n+[[nodiscard]] static bool PCPWrapAddress(Span<uint8_t> wrapped_addr, const CNetAddr &addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (addr.IsIPv4()) {\n+        struct in_addr addr4;\n+        if (!addr.GetInAddr(&addr4)) return false;\n+        // Section 5: \"When the address field holds an IPv4 address, an IPv4-mapped IPv6 address [RFC4291] is used (::ffff:0:0/96).\"\n+        std::memcpy(wrapped_addr.data(), IPV4_IN_IPV6_PREFIX.data(), IPV4_IN_IPV6_PREFIX.size());\n+        std::memcpy(wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), &addr4, ADDR_IPV4_SIZE);\n+        return true;\n+    } else if (addr.IsIPv6()) {\n+        struct in6_addr addr6;\n+        if (!addr.GetIn6Addr(&addr6)) return false;\n+        std::memcpy(wrapped_addr.data(), &addr6, ADDR_IPV6_SIZE);\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+//! Unwrap PCP-encoded address according to RPC6887.\n+static CNetAddr PCPUnwrapAddress(Span<const uint8_t> wrapped_addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (HasPrefix(wrapped_addr, IPV4_IN_IPV6_PREFIX)) {\n+        struct in_addr addr4;\n+        std::memcpy(&addr4, wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), ADDR_IPV4_SIZE);\n+        return CNetAddr(addr4);\n+    } else {\n+        struct in6_addr addr6;\n+        std::memcpy(&addr6, wrapped_addr.data(), ADDR_IPV6_SIZE);\n+        return CNetAddr(addr6);\n+    }\n+}\n+\n+//! PCP or NAT-PMP send-receive loop.\n+static std::optional<std::vector<uint8_t>> PCPSendRecv(Sock &sock, const std::string &protocol, Span<const uint8_t> request, int num_tries,\n+        std::function<bool(const Span<const uint8_t>)> check_packet)\n+{\n+    // UDP is a potentially lossy protocol, so we try to send again a few times.\n+    uint8_t response[PCP_MAX_SIZE];\n+    bool got_response = false;\n+    int recvsz = 0;\n+    for (int ntry = 0; !got_response && ntry < num_tries; ++ntry) {\n+        if (ntry > 0) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Retrying (%d)\\n\", protocol, ntry);\n+        }\n+        // Dispatch packet to gateway.\n+        if (sock.Send(request.data(), request.size(), 0) != static_cast<ssize_t>(request.size())) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not send request: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+            return std::nullopt; // Network-level error, probably no use retrying.\n+        }\n+\n+        // Wait for response(s) until we get a valid response, a network error, or time out.\n+        while (true) {\n+            Sock::Event occurred = 0;\n+            if (!sock.Wait(std::chrono::milliseconds(1000), Sock::RECV, &occurred)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not wait on socket: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            if (!occurred) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Timeout\\n\", protocol);\n+                break; // Retry.\n+            }\n+\n+            // Receive response.\n+            recvsz = sock.Recv(response, sizeof(response), MSG_DONTWAIT);\n+            if (recvsz < 0) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not receive response: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Received response of %d bytes: %s\\n\", protocol, recvsz, HexStr(Span(response, recvsz)));\n+\n+            if (check_packet(Span<uint8_t>(response, recvsz))) {",
      "path": "src/util/pcp.cpp",
      "position": 259,
      "original_position": 252,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "9a265c6d75136991125730b8a6a901e95cfeb8f6",
      "in_reply_to_id": 1613380035,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "The timeout is still one second per try (so three seconds in total maximum, given current retries), it's just not possible to extend it indefinitely anymore by sending rejected packets.",
      "created_at": "2024-05-27T07:52:58Z",
      "updated_at": "2024-05-27T07:52:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1615628209",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1615628209"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 259,
      "original_line": 259,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1615728471",
      "pull_request_review_id": 2080398804,
      "id": 1615728471,
      "node_id": "PRRC_kwDOABII585gTg9X",
      "diff_hunk": "@@ -148,7 +148,7 @@ enum\n     LOCAL_NONE,   // unknown\n     LOCAL_IF,     // address a local interface listens on\n     LOCAL_BIND,   // address explicit bound to\n-    LOCAL_MAPPED, // address reported by UPnP or NAT-PMP\n+    LOCAL_MAPPED, // address reported by UPnP or PCP",
      "path": "src/net.h",
      "position": 5,
      "original_position": 5,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "bfde83050ece1f617efdb4098b5efeeb1a08b65e",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "bfde83050ece1f617efdb4098b5efeeb1a08b65e nit: `UPnP, PCP or NAT-PMP`",
      "created_at": "2024-05-27T08:54:29Z",
      "updated_at": "2024-05-27T10:14:08Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1615728471",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1615728471"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 151,
      "original_line": 151,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1615868425",
      "pull_request_review_id": 2080624352,
      "id": 1615868425,
      "node_id": "PRRC_kwDOABII585gUDIJ",
      "diff_hunk": "@@ -148,7 +148,7 @@ enum\n     LOCAL_NONE,   // unknown\n     LOCAL_IF,     // address a local interface listens on\n     LOCAL_BIND,   // address explicit bound to\n-    LOCAL_MAPPED, // address reported by UPnP or NAT-PMP\n+    LOCAL_MAPPED, // address reported by UPnP or PCP",
      "path": "src/net.h",
      "position": 5,
      "original_position": 5,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "bfde83050ece1f617efdb4098b5efeeb1a08b65e",
      "in_reply_to_id": 1615728471,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Sure, ok, really i'm just considering NAT-PMP to be PCPv0.",
      "created_at": "2024-05-27T10:41:36Z",
      "updated_at": "2024-05-27T10:41:36Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1615868425",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1615868425"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 151,
      "original_line": 151,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1615998227",
      "pull_request_review_id": 2080835616,
      "id": 1615998227,
      "node_id": "PRRC_kwDOABII585gUi0T",
      "diff_hunk": "@@ -0,0 +1,520 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/pcp.h>\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <random.h>\n+#include <span.h>\n+#include <util/check.h>\n+#include <util/netif.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+// RFC6886 NAT-PMP and RFC6887 Port Control Protocol (PCP) implementation.\n+// NAT-PMP and PCP use network byte order (big-endian).\n+\n+// NAT-PMP (v0) protocol constants.\n+//! NAT-PMP uses a fixed server port number (RPC6887 section 1.1).",
      "path": "src/util/pcp.cpp",
      "position": null,
      "original_position": 22,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "97ae5d4eefe4a1f17c0742407875661c17654296",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "RPC -> RFC (in a few other places too)",
      "created_at": "2024-05-27T12:38:16Z",
      "updated_at": "2024-05-27T12:38:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1615998227",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1615998227"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 22,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617509629",
      "pull_request_review_id": 2083221831,
      "id": 1617509629,
      "node_id": "PRRC_kwDOABII585gaTz9",
      "diff_hunk": "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)",
      "path": "src/util/netif.cpp",
      "position": 17,
      "original_position": 19,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "bebfafcf98d8ed1432407b7603991d54f7cc26c2",
      "in_reply_to_id": 1610151853,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "13.2 is from April 2023: https://www.freebsd.org/releases/13.2R/announce/\r\nOn FreeBSD it is easy and smooth to upgrade the OS (at least my experience since FreeBSD 4.x) even across major versions (e.g. 13 -> 14). Seems fine to only support >= 13.2.",
      "created_at": "2024-05-28T15:26:32Z",
      "updated_at": "2024-05-28T15:26:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1617509629",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617509629"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 17,
      "original_line": 17,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617665519",
      "pull_request_review_id": 2083475660,
      "id": 1617665519,
      "node_id": "PRRC_kwDOABII585ga53v",
      "diff_hunk": "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)",
      "path": "src/util/netif.cpp",
      "position": 17,
      "original_position": 19,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "bebfafcf98d8ed1432407b7603991d54f7cc26c2",
      "in_reply_to_id": 1610151853,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Right, that's good to know. However the current problem is that we can't compile this for *any* FreeBSD version. Looks like the  `MLMSG` etc macros don't work in C++, because `typeof` is used.",
      "created_at": "2024-05-28T17:28:21Z",
      "updated_at": "2024-05-28T17:28:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1617665519",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617665519"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 17,
      "original_line": 17,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617773662",
      "pull_request_review_id": 2083657037,
      "id": 1617773662,
      "node_id": "PRRC_kwDOABII585gbURe",
      "diff_hunk": "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)",
      "path": "src/util/netif.cpp",
      "position": 17,
      "original_position": 19,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "bebfafcf98d8ed1432407b7603991d54f7cc26c2",
      "in_reply_to_id": 1610151853,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "@laanwj One possibility is moving the code to a separate .c file, perhaps?",
      "created_at": "2024-05-28T19:08:34Z",
      "updated_at": "2024-05-28T19:08:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1617773662",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617773662"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 17,
      "original_line": 17,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617802306",
      "pull_request_review_id": 2083703206,
      "id": 1617802306,
      "node_id": "PRRC_kwDOABII585gbbRC",
      "diff_hunk": "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)",
      "path": "src/util/netif.cpp",
      "position": 17,
      "original_position": 19,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "bebfafcf98d8ed1432407b7603991d54f7cc26c2",
      "in_reply_to_id": 1610151853,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "That would probably work, but that'd be a really invasive workaround build system wise.",
      "created_at": "2024-05-28T19:34:35Z",
      "updated_at": "2024-05-28T19:34:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1617802306",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617802306"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 17,
      "original_line": 17,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617859650",
      "pull_request_review_id": 2083798615,
      "id": 1617859650,
      "node_id": "PRRC_kwDOABII585gbpRC",
      "diff_hunk": "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)",
      "path": "src/util/netif.cpp",
      "position": 17,
      "original_position": 19,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "bebfafcf98d8ed1432407b7603991d54f7cc26c2",
      "in_reply_to_id": 1610151853,
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Yes, please don't do that :)",
      "created_at": "2024-05-28T20:32:14Z",
      "updated_at": "2024-05-28T20:32:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1617859650",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617859650"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 17,
      "original_line": 17,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617913125",
      "pull_request_review_id": 2083884218,
      "id": 1617913125,
      "node_id": "PRRC_kwDOABII585gb2Ul",
      "diff_hunk": "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)",
      "path": "src/util/netif.cpp",
      "position": 17,
      "original_position": 19,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "bebfafcf98d8ed1432407b7603991d54f7cc26c2",
      "in_reply_to_id": 1610151853,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "My expectation is that a `#define typeof __typeof__` around just the use of that macro on FreeBSD could fix it. Just haven't been able to try it out (and still hope someone who has a clue about FreeBSD has some kind of obvious solution).",
      "created_at": "2024-05-28T21:31:24Z",
      "updated_at": "2024-05-28T21:41:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1617913125",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1617913125"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 17,
      "original_line": 17,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1618645388",
      "pull_request_review_id": 2085005661,
      "id": 1618645388,
      "node_id": "PRRC_kwDOABII585gepGM",
      "diff_hunk": "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)",
      "path": "src/util/netif.cpp",
      "position": 17,
      "original_position": 19,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "bebfafcf98d8ed1432407b7603991d54f7cc26c2",
      "in_reply_to_id": 1610151853,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "This is the upstream fix: https://github.com/freebsd/freebsd-src/pull/1070.\r\n\r\nThe suggested workaround to define `typeof` is ok:\r\n\r\n```diff\r\ndiff --git i/src/util/netif.cpp w/src/util/netif.cpp\r\nindex 845b8aed1d..1840974a83 100644\r\n--- i/src/util/netif.cpp\r\n+++ w/src/util/netif.cpp\r\n@@ -9,18 +9,24 @@\r\n #include <logging.h>\r\n #include <netbase.h>\r\n #include <util/check.h>\r\n #include <util/sock.h>\r\n #include <util/syserror.h>\r\n \r\n+#ifdef __FreeBSD__\r\n+#include <osreldate.h>\r\n+#endif\r\n+\r\n // Linux and FreeBSD 13.2+\r\n-#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1302000)\r\n+#if defined(__linux__) || __FreeBSD_version >= 1302000\r\n \r\n #if defined(__linux__)\r\n #include <linux/rtnetlink.h>\r\n #elif defined(__FreeBSD__)\r\n+// Workaround https://github.com/freebsd/freebsd-src/pull/1070.\r\n+#define typeof __typeof\r\n #include <netlink/netlink.h>\r\n #include <netlink/netlink_route.h>\r\n #endif\r\n \r\n static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\r\n {\r\n@@ -77,14 +83,13 @@ static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\r\n     } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\r\n     if (recv_result < 0) {\r\n         LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", NetworkErrorString(errno));\r\n         return std::nullopt;\r\n     }\r\n \r\n-    size_t response_len = static_cast<size_t>(recv_result);\r\n-    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\r\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, recv_result); hdr = NLMSG_NEXT(hdr, recv_result)) {\r\n         rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\r\n         int remaining_len = RTM_PAYLOAD(hdr);\r\n \r\n         // Iterate over the attributes.\r\n         rtattr *rta_gateway = nullptr;\r\n         int scope_id = 0;\r\n```\r\n\r\nThe above patch does two more things:\r\n* `__FreeBSD_version` was not defined at the time it was checked, so `__FreeBSD_version >= 1302000` was always false. Include the header that defines it.\r\n* Silence a warning about signed vs unsigned integer comparison.\r\n\r\nI tested this by reverting the upstream fix - `s/__typeof/typeof` in my `/usr/include/netlink/netlink.h`. Confirming that it gives the typeof error, then applying to above workaround and confirming that it compiles.",
      "created_at": "2024-05-29T10:26:38Z",
      "updated_at": "2024-05-29T10:26:39Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1618645388",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1618645388"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 17,
      "original_line": 17,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1618653598",
      "pull_request_review_id": 2085019168,
      "id": 1618653598,
      "node_id": "PRRC_kwDOABII585gerGe",
      "diff_hunk": "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)",
      "path": "src/util/netif.cpp",
      "position": 17,
      "original_position": 19,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "bebfafcf98d8ed1432407b7603991d54f7cc26c2",
      "in_reply_to_id": 1610151853,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Thanks!\r\n\r\n> Silence a warning about signed vs unsigned integer comparison.\r\n\r\nOh no. Pretty sure i had to do the `response_len` thing to work around another error about signed-unsigned integer comparison in the i686 CI run.\r\n\r\nEdit: pushed this change as-is, let's see.",
      "created_at": "2024-05-29T10:33:44Z",
      "updated_at": "2024-05-29T12:46:19Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1618653598",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1618653598"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 17,
      "original_line": 17,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1618807661",
      "pull_request_review_id": 2085277767,
      "id": 1618807661,
      "node_id": "PRRC_kwDOABII585gfQtt",
      "diff_hunk": "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)",
      "path": "src/util/netif.cpp",
      "position": 17,
      "original_position": 19,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "bebfafcf98d8ed1432407b7603991d54f7cc26c2",
      "in_reply_to_id": 1610151853,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "On my Linux distro I have:\r\n\r\n```cpp\r\nstruct nlmsghdr {          \r\n        __u32           nlmsg_len;\r\n...\r\n#define NLMSG_OK(nlh,len) ((len) >= (int)sizeof(struct nlmsghdr) && \\\r\n                           (nlh)->nlmsg_len >= sizeof(struct nlmsghdr) && \\\r\n                           (nlh)->nlmsg_len <= (len))\r\n```\r\nSo, the second argument of `NLMSG_OK()` - `len` is compared against 1. `(int)sizeof...` and 2. `...->nlmsg_len` (which is `__u32`). The only difference on FreeBSD is that in 2. it is compared against `(int)(_hdr)->nlmsg_len` - an explicitly cast `nlmsg_len` to `int` (`nlmsg_len` is `uint32_t` on FreeBSD).\r\n\r\nI do not get a warning when compiling that code on Linux:\r\n```cpp\r\n    ssize_t response_len;\r\n...\r\n    for (nlmsghdr *hdr = (nlmsghdr*)response; NLMSG_OK(hdr, response_len); hdr = NLMSG_NEXT(hdr, response_len)) {\r\n```\r\nI am not sure why. I should get a warning about `__u32 <= ssize_t`, right?",
      "created_at": "2024-05-29T12:36:38Z",
      "updated_at": "2024-05-29T12:36:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1618807661",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1618807661"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 17,
      "original_line": 17,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1618837102",
      "pull_request_review_id": 2085328315,
      "id": 1618837102,
      "node_id": "PRRC_kwDOABII585gfX5u",
      "diff_hunk": "@@ -0,0 +1,300 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1302000)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 33,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "357ab7179d95635a86cb86bc2f498a62230b2b24",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "_Continuing the discussion from https://github.com/bitcoin/bitcoin/pull/30043#issuecomment-2131092539, so that messages are grouped together, not scattered in the main PR thread._\r\n\r\n>> The first two commits of https://github.com/bitcoin/bitcoin/pull/26812 would make it possible to test and fuzz how this code interacts with a router.\r\n\r\n> So ive been thinking about this, do we have a mockable way to do std::optional<Sock> socket(int domain, int type, int protocol)? ...\r\n\r\nAlmost. Right now we have the \"pointer\"\r\n```cpp\r\nstd::function<std::unique_ptr<Sock>(const sa_family_t&)> CreateSock;\r\n```\r\nwhich in the real code points to the function\r\n```cpp\r\nstd::unique_ptr<Sock> CreateSockOS(sa_family_t address_family);\r\n```\r\n\r\nTests that wish to mock the sockets redirect the pointer to another one `CreateSockWhateverMockedStuff()`.\r\n\r\nThat `address_family` is the first argument to the `socket(2)` syscall. What's needed is to extend `CreateSock*()` with the other two arguments - `type` and `protocol`. I can do that.\r\n\r\n@Sjors, are you ACK on the first 2 commits of https://github.com/bitcoin/bitcoin/pull/26812? If yes, should I create a separate PR with those 2 commits?",
      "created_at": "2024-05-29T12:54:28Z",
      "updated_at": "2024-05-29T12:56:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1618837102",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1618837102"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": 28,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 39,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1618860594",
      "pull_request_review_id": 2085368162,
      "id": 1618860594,
      "node_id": "PRRC_kwDOABII585gfdoy",
      "diff_hunk": "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)",
      "path": "src/util/netif.cpp",
      "position": 17,
      "original_position": 19,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "bebfafcf98d8ed1432407b7603991d54f7cc26c2",
      "in_reply_to_id": 1610151853,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> I am not sure why. I should get a warning about __u32 <= ssize_t, right?\r\n\r\nComparing an unsigned type against a larger signed type does what one would expect: it gets casted to the larger signed type before comparison.\r\nThis is why on 64-bit platforms this is fine.\r\nHowever on 32-bit platforms, `ssize_t` is 32 bit. So there it warns.\r\n",
      "created_at": "2024-05-29T13:10:46Z",
      "updated_at": "2024-05-29T13:10:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1618860594",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1618860594"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 17,
      "original_line": 17,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1619127144",
      "pull_request_review_id": 2085807134,
      "id": 1619127144,
      "node_id": "PRRC_kwDOABII585ggeto",
      "diff_hunk": "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)",
      "path": "src/util/netif.cpp",
      "position": 17,
      "original_position": 19,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "bebfafcf98d8ed1432407b7603991d54f7cc26c2",
      "in_reply_to_id": 1610151853,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I see, then defining `recv_result` as `int64_t` instead of `ssize_t` should be ok on all platforms?",
      "created_at": "2024-05-29T15:51:33Z",
      "updated_at": "2024-05-29T15:51:33Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1619127144",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1619127144"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 17,
      "original_line": 17,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1619152037",
      "pull_request_review_id": 2085849227,
      "id": 1619152037,
      "node_id": "PRRC_kwDOABII585ggkyl",
      "diff_hunk": "@@ -0,0 +1,300 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1302000)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 33,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "357ab7179d95635a86cb86bc2f498a62230b2b24",
      "in_reply_to_id": 1618837102,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "@vasild I haven't had a chance to thoroughly review the second commit. Making a separate PR could help.",
      "created_at": "2024-05-29T16:09:29Z",
      "updated_at": "2024-05-29T16:09:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1619152037",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1619152037"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": 28,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 39,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1620134827",
      "pull_request_review_id": 2087453965,
      "id": 1620134827,
      "node_id": "PRRC_kwDOABII585gkUur",
      "diff_hunk": "@@ -0,0 +1,275 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__) || defined(__FreeBSD__)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)",
      "path": "src/util/netif.cpp",
      "position": 17,
      "original_position": 19,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "bebfafcf98d8ed1432407b7603991d54f7cc26c2",
      "in_reply_to_id": 1610151853,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Will try. Introducing a platform depenendent typedef just for this would be a bit silly.",
      "created_at": "2024-05-30T07:28:09Z",
      "updated_at": "2024-05-30T07:30:23Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1620134827",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1620134827"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 17,
      "original_line": 17,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1620295387",
      "pull_request_review_id": 2087694580,
      "id": 1620295387,
      "node_id": "PRRC_kwDOABII585gk77b",
      "diff_hunk": "@@ -0,0 +1,300 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1302000)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 33,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "357ab7179d95635a86cb86bc2f498a62230b2b24",
      "in_reply_to_id": 1618837102,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "SGTM.\r\n\r\n> That address_family is the first argument to the socket(2) syscall. What's needed is to extend CreateSock*() with the other two arguments - type and protocol. I can do that.\r\n\r\nYes, for specifying UDP (and NETLINK, but i do not intend to make a test framework for that) it would need all three arguments. ",
      "created_at": "2024-05-30T09:00:58Z",
      "updated_at": "2024-05-30T09:00:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1620295387",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1620295387"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": 28,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 39,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1620553530",
      "pull_request_review_id": 2088046698,
      "id": 1620553530,
      "node_id": "PRRC_kwDOABII585gl686",
      "diff_hunk": "@@ -0,0 +1,300 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1302000)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 33,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "357ab7179d95635a86cb86bc2f498a62230b2b24",
      "in_reply_to_id": 1618837102,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Extended `CreateSock()` in the topmost commit in https://github.com/vasild/bitcoin/commits/extend_CreateSock/.\r\nSeparate PR or include in this PR?",
      "created_at": "2024-05-30T11:46:08Z",
      "updated_at": "2024-05-30T11:46:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1620553530",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1620553530"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": 28,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 39,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1620636660",
      "pull_request_review_id": 2088164689,
      "id": 1620636660,
      "node_id": "PRRC_kwDOABII585gmPP0",
      "diff_hunk": "@@ -0,0 +1,300 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1302000)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 33,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "357ab7179d95635a86cb86bc2f498a62230b2b24",
      "in_reply_to_id": 1618837102,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "This PR is already quite large, so let's make a fresh one that this can rebase on if needed.",
      "created_at": "2024-05-30T12:37:50Z",
      "updated_at": "2024-05-30T12:37:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1620636660",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1620636660"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": 28,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 39,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1620683143",
      "pull_request_review_id": 2088228535,
      "id": 1620683143,
      "node_id": "PRRC_kwDOABII585gmamH",
      "diff_hunk": "@@ -0,0 +1,300 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1302000)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 33,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "357ab7179d95635a86cb86bc2f498a62230b2b24",
      "in_reply_to_id": 1618837102,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Agree adding fuzzing/testing makes sense as a follow-up PR. It's already big enough, and also i don't want to interfere with review by doing more active development here than address review comments.",
      "created_at": "2024-05-30T13:07:18Z",
      "updated_at": "2024-05-30T13:07:18Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1620683143",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1620683143"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": 28,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 39,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1620744428",
      "pull_request_review_id": 2088325381,
      "id": 1620744428,
      "node_id": "PRRC_kwDOABII585gmpjs",
      "diff_hunk": "@@ -0,0 +1,300 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1302000)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 33,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "357ab7179d95635a86cb86bc2f498a62230b2b24",
      "in_reply_to_id": 1618837102,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Opened https://github.com/bitcoin/bitcoin/pull/30202 \"netbase: extend CreateSock() to support creating arbitrary sockets\"",
      "created_at": "2024-05-30T13:41:32Z",
      "updated_at": "2024-05-30T13:41:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1620744428",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1620744428"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": 28,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 39,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1620997477",
      "pull_request_review_id": 2088712955,
      "id": 1620997477,
      "node_id": "PRRC_kwDOABII585gnnVl",
      "diff_hunk": "@@ -0,0 +1,300 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1302000)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 33,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "357ab7179d95635a86cb86bc2f498a62230b2b24",
      "in_reply_to_id": 1618837102,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> Making a separate PR could help\r\n\r\nDone, the first two commits from https://github.com/bitcoin/bitcoin/pull/26812 extracted into a separate PR: https://github.com/bitcoin/bitcoin/pull/30205",
      "created_at": "2024-05-30T15:51:13Z",
      "updated_at": "2024-05-30T15:51:13Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1620997477",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1620997477"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": 28,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 39,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1621060075",
      "pull_request_review_id": 2088811131,
      "id": 1621060075,
      "node_id": "PRRC_kwDOABII585gn2nr",
      "diff_hunk": "@@ -0,0 +1,300 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1302000)\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 33,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "357ab7179d95635a86cb86bc2f498a62230b2b24",
      "in_reply_to_id": 1618837102,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I got a bit confused about these two new PRs, but I guess they are orthogonal.",
      "created_at": "2024-05-30T16:32:27Z",
      "updated_at": "2024-05-30T16:32:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1621060075",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1621060075"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": 28,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 39,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1642751240",
      "pull_request_review_id": 2122801091,
      "id": 1642751240,
      "node_id": "PRRC_kwDOABII585h6mUI",
      "diff_hunk": "@@ -0,0 +1,305 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#ifdef __FreeBSD__\n+#include <osreldate.h>\n+#endif\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || __FreeBSD_version >= 1400000",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 20,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "a8818568a44e02c0346ef37cde9155191f8b3df1",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "a8818568a44e02c0346ef37cde9155191f8b3df1: `__FreeBSD_version` can be lowered to `1302000` as per the comment (or `1302001` which I tested on). Although you need `kldload /boot/kernel/netlink.ko`.",
      "created_at": "2024-06-17T12:39:52Z",
      "updated_at": "2024-06-17T14:18:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1642751240",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1642751240"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 22,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1642879959",
      "pull_request_review_id": 2122801091,
      "id": 1642879959,
      "node_id": "PRRC_kwDOABII585h7FvX",
      "diff_hunk": "@@ -134,20 +134,6 @@ Skip if you do not need this functionality.\n brew install miniupnpc\n ```\n \n-###### libnatpmp\n-\n-libnatpmp may be used for NAT-PMP port mapping.\n-Skip if you do not need this functionality.\n-\n-``` bash\n-brew install libnatpmp\n-```\n-\n-Note: UPnP and NAT-PMP support will be compiled in and disabled by default.",
      "path": "doc/build-osx.md",
      "position": null,
      "original_position": 13,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "3fdc97a2bf7d1ec774d2ffa00502188158c64724",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "3fdc97a2bf7d1ec774d2ffa00502188158c64724: this line could be moved to the `miniupnpc` section above:\r\n\r\n```\r\nNote: UPnP support will be compiled in, but disabled by default.\r\n```",
      "created_at": "2024-06-17T14:07:36Z",
      "updated_at": "2024-06-17T14:18:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1642879959",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1642879959"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 146,
      "side": "LEFT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1642882599",
      "pull_request_review_id": 2122801091,
      "id": 1642882599,
      "node_id": "PRRC_kwDOABII585h7GYn",
      "diff_hunk": "@@ -134,20 +134,6 @@ Skip if you do not need this functionality.\n brew install miniupnpc\n ```\n \n-###### libnatpmp\n-\n-libnatpmp may be used for NAT-PMP port mapping.\n-Skip if you do not need this functionality.\n-\n-``` bash\n-brew install libnatpmp\n-```\n-\n-Note: UPnP and NAT-PMP support will be compiled in and disabled by default.\n-Check out the [further configuration](#further-configuration) section for more information.",
      "path": "doc/build-osx.md",
      "position": 13,
      "original_position": 14,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "3fdc97a2bf7d1ec774d2ffa00502188158c64724",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "3fdc97a2bf7d1ec774d2ffa00502188158c64724: I don't know why this was here in the first place, seems fine to drop.",
      "created_at": "2024-06-17T14:09:13Z",
      "updated_at": "2024-06-17T14:18:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1642882599",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1642882599"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 147,
      "original_line": 147,
      "side": "LEFT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1642892799",
      "pull_request_review_id": 2122801091,
      "id": 1642892799,
      "node_id": "PRRC_kwDOABII585h7I3_",
      "diff_hunk": "@@ -1808,7 +1804,6 @@ bool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)\n     LogPrintf(\"nBestHeight = %d\\n\", chain_active_height);\n     if (node.peerman) node.peerman->SetBestBlock(chain_active_height, std::chrono::seconds{best_block_time});\n \n-    // Map ports with UPnP or NAT-PMP.",
      "path": "src/init.cpp",
      "position": 17,
      "original_position": 17,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "57e23f3b4d9cc5bdba421e47def9f3b2335d4cfb",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "57e23f3b4d9cc5bdba421e47def9f3b2335d4cfb: nit, no need to drop this",
      "created_at": "2024-06-17T14:15:59Z",
      "updated_at": "2024-06-17T14:18:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1642892799",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1642892799"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1861,
      "original_line": 1861,
      "side": "LEFT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1644926540",
      "pull_request_review_id": 2126279596,
      "id": 1644926540,
      "node_id": "PRRC_kwDOABII585iC5ZM",
      "diff_hunk": "@@ -0,0 +1,520 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/pcp.h>\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <random.h>\n+#include <span.h>\n+#include <util/check.h>\n+#include <util/netif.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+// RFC6886 NAT-PMP and RFC6887 Port Control Protocol (PCP) implementation.\n+// NAT-PMP and PCP use network byte order (big-endian).\n+\n+// NAT-PMP (v0) protocol constants.\n+//! NAT-PMP uses a fixed server port number (RFC6887 section 1.1).\n+constexpr uint16_t NATPMP_SERVER_PORT = 5351;",
      "path": "src/util/pcp.cpp",
      "position": 26,
      "original_position": 23,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "44316c39006a4ea906e9ae41a3fdbdf28f318ce5",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In commit \"net: Add PCP and NATPMP implementation\"\r\n\r\nPut a `namespace {` ... `} // namespace` around all of the functions/definitions/constants that are not in the .h file, and drop the `static` (just a nit, but anonymous namespaces are considered more modern).",
      "created_at": "2024-06-18T19:07:05Z",
      "updated_at": "2024-06-18T19:49:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1644926540",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1644926540"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 26,
      "original_line": 26,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1644928807",
      "pull_request_review_id": 2126279596,
      "id": 1644928807,
      "node_id": "PRRC_kwDOABII585iC58n",
      "diff_hunk": "@@ -0,0 +1,520 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/pcp.h>\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <random.h>\n+#include <span.h>\n+#include <util/check.h>\n+#include <util/netif.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+// RFC6886 NAT-PMP and RFC6887 Port Control Protocol (PCP) implementation.\n+// NAT-PMP and PCP use network byte order (big-endian).\n+\n+// NAT-PMP (v0) protocol constants.\n+//! NAT-PMP uses a fixed server port number (RFC6887 section 1.1).\n+constexpr uint16_t NATPMP_SERVER_PORT = 5351;\n+//! Version byte for NATPMP (RFC6886 1.1)\n+constexpr uint8_t NATPMP_VERSION = 0;\n+//! Request opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_REQUEST = 0x00;\n+//! Response opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_RESPONSE = 0x80;\n+//! Get external address (RFC6886 3.2)\n+constexpr uint8_t NATPMP_OP_GETEXTERNAL = 0x00;\n+//! Map TCP port (RFC6886 3.3)\n+constexpr uint8_t NATPMP_OP_MAP_TCP = 0x02;\n+//! Shared request header size in bytes.\n+constexpr size_t NATPMP_REQUEST_HDR_SIZE = 2;\n+//! Shared response header (minimum) size in bytes.\n+constexpr size_t NATPMP_RESPONSE_HDR_SIZE = 8;\n+//! GETEXTERNAL request size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 0;\n+//! GETEXTERNAL response size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 4;\n+//! MAP request size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 10;\n+//! MAP response size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 8;\n+\n+// Shared header offsets (RFC6886 3.2, 3.3), relative to start of packet.\n+//!  Offset of version field in packets.\n+constexpr size_t NATPMP_HDR_VERSION_OFS = 0;\n+//!  Offset of opcode field in packets\n+constexpr size_t NATPMP_HDR_OP_OFS = 1;\n+//!  Offset of result code in packets. Result codes are 16 bit in NAT-PMP instead of 8 bit in PCP.\n+constexpr size_t NATPMP_RESPONSE_HDR_RESULT_OFS = 2;\n+\n+// GETEXTERNAL response offsets (RFC6886 3.2), relative to start of packet.\n+//!  Returned external address\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_IP_OFS = 8;\n+\n+// MAP request offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port to be mapped.\n+constexpr size_t NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS = 4;\n+//!  Suggested external port for mapping.\n+constexpr size_t NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS = 6;\n+//!  Requested port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_REQUEST_LIFETIME_OFS = 8;\n+\n+// MAP response offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port for mapping (will match internal port of request).\n+constexpr size_t NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS = 8;\n+//!  External port for mapping.\n+constexpr size_t NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS = 10;\n+//!  Created port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_RESPONSE_LIFETIME_OFS = 12;\n+\n+// Relevant NETPMP result codes (RFC6886 3.5).\n+//! Result code representing success status.\n+constexpr uint8_t NATPMP_RESULT_SUCCESS = 0;\n+//! Result code representing unsupported version.\n+constexpr uint8_t NATPMP_RESULT_UNSUPP_VERSION = 1;\n+//! Result code representing lack of resources.\n+constexpr uint8_t NATPMP_RESULT_NO_RESOURCES = 4;\n+\n+//! Mapping of NATPMP result code to string (RFC6886 3.5). Result codes <=2 match PCP.\n+static const std::map<uint8_t, std::string> NATPMP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"NETWORK_FAILURE\"},\n+    {4,  \"NO_RESOURCES\"},\n+    {5,  \"UNSUPP_OPCODE\"},\n+};\n+\n+// PCP (v2) protocol constants.\n+//! Maximum packet size in bytes (RFC6887 section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (RFC6887 section 19.1). Shared with NAT-PMP.\n+constexpr uint16_t PCP_SERVER_PORT = NATPMP_SERVER_PORT;\n+//! Version byte. 0 is NAT-PMP (RFC6886), 1 is forbidden, 2 for PCP (RFC6887).\n+constexpr uint8_t PCP_VERSION = 2;\n+//! PCP Request Header. See RFC6887 section 7.1. Shared with NAT-PMP.\n+constexpr uint8_t PCP_REQUEST = NATPMP_REQUEST; // R = 0\n+//! PCP Response Header. See RFC6887 section 7.2. Shared with NAT-PMP.\n+constexpr uint8_t PCP_RESPONSE = NATPMP_RESPONSE; // R = 1\n+//! Map opcode. See RFC6887 section 19.2\n+constexpr uint8_t PCP_OP_MAP = 0x01;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Request and response header size in bytes (RFC6887 section 7.1).\n+constexpr size_t PCP_HDR_SIZE = 24;\n+//! Map request and response size in bytes (RFC6887 section 11.1).\n+constexpr size_t PCP_MAP_SIZE = 36;\n+\n+// Header offsets shared between request and responses (RFC6887 7.1, 7.2), relative to start of packet.\n+//!  Version field (1 byte).\n+constexpr size_t PCP_HDR_VERSION_OFS = NATPMP_HDR_VERSION_OFS;\n+//!  Opcode field (1 byte).\n+constexpr size_t PCP_HDR_OP_OFS = NATPMP_HDR_OP_OFS;\n+//!  Requested lifetime (request), granted lifetime (response) (2 bytes).\n+constexpr size_t PCP_HDR_LIFETIME_OFS = 4;\n+\n+// Request header offsets (RFC6887 7.1), relative to start of packet.\n+//!  PCP client's IP address (16 bytes).\n+constexpr size_t PCP_REQUEST_HDR_IP_OFS = 8;\n+\n+// Response header offsets (RFC6887 7.2), relative to start of packet.\n+//!  Result code (1 byte).\n+constexpr size_t PCP_RESPONSE_HDR_RESULT_OFS = 3;\n+\n+// MAP request/response offsets (RFC6887 11.1), relative to start of opcode-specific data.\n+//!  Mapping nonce (12 bytes).\n+constexpr size_t PCP_MAP_NONCE_OFS = 0;\n+//!  Protocol (1 byte).\n+constexpr size_t PCP_MAP_PROTOCOL_OFS = 12;\n+//!  Internal port for mapping (2 bytes).\n+constexpr size_t PCP_MAP_INTERNAL_PORT_OFS = 16;\n+//!  Suggested external port (request), assigned external port (response) (2 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_PORT_OFS = 18;\n+//!  Suggested external IP (request), assigned external IP (response) (16 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_IP_OFS = 20;\n+\n+//! Result code representing success (RFC6887 7.4), shared with NAT-PMP.\n+constexpr uint8_t PCP_RESULT_SUCCESS = NATPMP_RESULT_SUCCESS;\n+//! Result code representing lack of resources (RFC6887 7.4).\n+constexpr uint8_t PCP_RESULT_NO_RESOURCES = 8;\n+\n+//! Mapping of PCP result code to string (RFC6887 7.4). Result codes <=2 match NAT-PMP.\n+static const std::map<uint8_t, std::string> PCP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"MALFORMED_REQUEST\"},\n+    {4,  \"UNSUPP_OPCODE\"},\n+    {5,  \"UNSUPP_OPTION\"},\n+    {6,  \"MALFORMED_OPTION\"},\n+    {7,  \"NETWORK_FAILURE\"},\n+    {8,  \"NO_RESOURCES\"},\n+    {9,  \"UNSUPP_PROTOCOL\"},\n+    {10, \"USER_EX_QUOTA\"},\n+    {11, \"CANNOT_PROVIDE_EXTERNAL\"},\n+    {12, \"ADDRESS_MISMATCH\"},\n+    {13, \"EXCESSIVE_REMOTE_PEER\"},\n+};\n+\n+//! Return human-readable string from NATPMP result code.\n+static std::string NATPMPResultString(uint8_t result_code)\n+{\n+    auto result_i = NATPMP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == NATPMP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Return human-readable string from PCP result code.\n+static std::string PCPResultString(uint8_t result_code)\n+{\n+    auto result_i = PCP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == PCP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Wrap address in IPv6 according to RFC6887. wrapped_addr needs to be able to store 16 bytes.\n+[[nodiscard]] static bool PCPWrapAddress(Span<uint8_t> wrapped_addr, const CNetAddr &addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (addr.IsIPv4()) {\n+        struct in_addr addr4;\n+        if (!addr.GetInAddr(&addr4)) return false;\n+        // Section 5: \"When the address field holds an IPv4 address, an IPv4-mapped IPv6 address [RFC4291] is used (::ffff:0:0/96).\"\n+        std::memcpy(wrapped_addr.data(), IPV4_IN_IPV6_PREFIX.data(), IPV4_IN_IPV6_PREFIX.size());\n+        std::memcpy(wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), &addr4, ADDR_IPV4_SIZE);\n+        return true;\n+    } else if (addr.IsIPv6()) {\n+        struct in6_addr addr6;\n+        if (!addr.GetIn6Addr(&addr6)) return false;\n+        std::memcpy(wrapped_addr.data(), &addr6, ADDR_IPV6_SIZE);\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+//! Unwrap PCP-encoded address according to RFC6887.\n+static CNetAddr PCPUnwrapAddress(Span<const uint8_t> wrapped_addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (util::HasPrefix(wrapped_addr, IPV4_IN_IPV6_PREFIX)) {\n+        struct in_addr addr4;\n+        std::memcpy(&addr4, wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), ADDR_IPV4_SIZE);\n+        return CNetAddr(addr4);\n+    } else {\n+        struct in6_addr addr6;\n+        std::memcpy(&addr6, wrapped_addr.data(), ADDR_IPV6_SIZE);\n+        return CNetAddr(addr6);\n+    }\n+}\n+\n+//! PCP or NAT-PMP send-receive loop.\n+static std::optional<std::vector<uint8_t>> PCPSendRecv(Sock &sock, const std::string &protocol, Span<const uint8_t> request, int num_tries,\n+        std::chrono::milliseconds timeout_per_try,\n+        std::function<bool(const Span<const uint8_t>)> check_packet)\n+{\n+    // UDP is a potentially lossy protocol, so we try to send again a few times.\n+    uint8_t response[PCP_MAX_SIZE];\n+    bool got_response = false;\n+    int recvsz = 0;\n+    for (int ntry = 0; !got_response && ntry < num_tries; ++ntry) {\n+        if (ntry > 0) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Retrying (%d)\\n\", protocol, ntry);\n+        }\n+        // Dispatch packet to gateway.\n+        if (sock.Send(request.data(), request.size(), 0) != static_cast<ssize_t>(request.size())) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not send request: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+            return std::nullopt; // Network-level error, probably no use retrying.\n+        }\n+\n+        // Wait for response(s) until we get a valid response, a network error, or time out.\n+        auto cur_time = std::chrono::time_point_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now());\n+        auto deadline = cur_time + timeout_per_try;\n+        while ((cur_time = std::chrono::time_point_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now())) < deadline) {\n+            Sock::Event occurred = 0;\n+            if (!sock.Wait(deadline - cur_time, Sock::RECV, &occurred)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not wait on socket: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            if (!occurred) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Timeout\\n\", protocol);\n+                break; // Retry.\n+            }\n+\n+            // Receive response.\n+            recvsz = sock.Recv(response, sizeof(response), MSG_DONTWAIT);\n+            if (recvsz < 0) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not receive response: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Received response of %d bytes: %s\\n\", protocol, recvsz, HexStr(Span(response, recvsz)));\n+\n+            if (check_packet(Span<uint8_t>(response, recvsz))) {",
      "path": "src/util/pcp.cpp",
      "position": 259,
      "original_position": 255,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "44316c39006a4ea906e9ae41a3fdbdf28f318ce5",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In commit \"net: Add PCP and NATPMP implementation\":\r\n\r\nNit: `check_packet({response, recvsz})` should work too (if no type is listed, the corresponding constructor of the declared type is used).",
      "created_at": "2024-06-18T19:09:16Z",
      "updated_at": "2024-06-18T19:49:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1644928807",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1644928807"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 259,
      "original_line": 259,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1644929901",
      "pull_request_review_id": 2126279596,
      "id": 1644929901,
      "node_id": "PRRC_kwDOABII585iC6Nt",
      "diff_hunk": "@@ -0,0 +1,520 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/pcp.h>\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <random.h>\n+#include <span.h>\n+#include <util/check.h>\n+#include <util/netif.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+// RFC6886 NAT-PMP and RFC6887 Port Control Protocol (PCP) implementation.\n+// NAT-PMP and PCP use network byte order (big-endian).\n+\n+// NAT-PMP (v0) protocol constants.\n+//! NAT-PMP uses a fixed server port number (RFC6887 section 1.1).\n+constexpr uint16_t NATPMP_SERVER_PORT = 5351;\n+//! Version byte for NATPMP (RFC6886 1.1)\n+constexpr uint8_t NATPMP_VERSION = 0;\n+//! Request opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_REQUEST = 0x00;\n+//! Response opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_RESPONSE = 0x80;\n+//! Get external address (RFC6886 3.2)\n+constexpr uint8_t NATPMP_OP_GETEXTERNAL = 0x00;\n+//! Map TCP port (RFC6886 3.3)\n+constexpr uint8_t NATPMP_OP_MAP_TCP = 0x02;\n+//! Shared request header size in bytes.\n+constexpr size_t NATPMP_REQUEST_HDR_SIZE = 2;\n+//! Shared response header (minimum) size in bytes.\n+constexpr size_t NATPMP_RESPONSE_HDR_SIZE = 8;\n+//! GETEXTERNAL request size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 0;\n+//! GETEXTERNAL response size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 4;\n+//! MAP request size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 10;\n+//! MAP response size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 8;\n+\n+// Shared header offsets (RFC6886 3.2, 3.3), relative to start of packet.\n+//!  Offset of version field in packets.\n+constexpr size_t NATPMP_HDR_VERSION_OFS = 0;\n+//!  Offset of opcode field in packets\n+constexpr size_t NATPMP_HDR_OP_OFS = 1;\n+//!  Offset of result code in packets. Result codes are 16 bit in NAT-PMP instead of 8 bit in PCP.\n+constexpr size_t NATPMP_RESPONSE_HDR_RESULT_OFS = 2;\n+\n+// GETEXTERNAL response offsets (RFC6886 3.2), relative to start of packet.\n+//!  Returned external address\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_IP_OFS = 8;\n+\n+// MAP request offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port to be mapped.\n+constexpr size_t NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS = 4;\n+//!  Suggested external port for mapping.\n+constexpr size_t NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS = 6;\n+//!  Requested port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_REQUEST_LIFETIME_OFS = 8;\n+\n+// MAP response offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port for mapping (will match internal port of request).\n+constexpr size_t NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS = 8;\n+//!  External port for mapping.\n+constexpr size_t NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS = 10;\n+//!  Created port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_RESPONSE_LIFETIME_OFS = 12;\n+\n+// Relevant NETPMP result codes (RFC6886 3.5).\n+//! Result code representing success status.\n+constexpr uint8_t NATPMP_RESULT_SUCCESS = 0;\n+//! Result code representing unsupported version.\n+constexpr uint8_t NATPMP_RESULT_UNSUPP_VERSION = 1;\n+//! Result code representing lack of resources.\n+constexpr uint8_t NATPMP_RESULT_NO_RESOURCES = 4;\n+\n+//! Mapping of NATPMP result code to string (RFC6886 3.5). Result codes <=2 match PCP.\n+static const std::map<uint8_t, std::string> NATPMP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"NETWORK_FAILURE\"},\n+    {4,  \"NO_RESOURCES\"},\n+    {5,  \"UNSUPP_OPCODE\"},\n+};\n+\n+// PCP (v2) protocol constants.\n+//! Maximum packet size in bytes (RFC6887 section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (RFC6887 section 19.1). Shared with NAT-PMP.\n+constexpr uint16_t PCP_SERVER_PORT = NATPMP_SERVER_PORT;\n+//! Version byte. 0 is NAT-PMP (RFC6886), 1 is forbidden, 2 for PCP (RFC6887).\n+constexpr uint8_t PCP_VERSION = 2;\n+//! PCP Request Header. See RFC6887 section 7.1. Shared with NAT-PMP.\n+constexpr uint8_t PCP_REQUEST = NATPMP_REQUEST; // R = 0\n+//! PCP Response Header. See RFC6887 section 7.2. Shared with NAT-PMP.\n+constexpr uint8_t PCP_RESPONSE = NATPMP_RESPONSE; // R = 1\n+//! Map opcode. See RFC6887 section 19.2\n+constexpr uint8_t PCP_OP_MAP = 0x01;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Request and response header size in bytes (RFC6887 section 7.1).\n+constexpr size_t PCP_HDR_SIZE = 24;\n+//! Map request and response size in bytes (RFC6887 section 11.1).\n+constexpr size_t PCP_MAP_SIZE = 36;\n+\n+// Header offsets shared between request and responses (RFC6887 7.1, 7.2), relative to start of packet.\n+//!  Version field (1 byte).\n+constexpr size_t PCP_HDR_VERSION_OFS = NATPMP_HDR_VERSION_OFS;\n+//!  Opcode field (1 byte).\n+constexpr size_t PCP_HDR_OP_OFS = NATPMP_HDR_OP_OFS;\n+//!  Requested lifetime (request), granted lifetime (response) (2 bytes).\n+constexpr size_t PCP_HDR_LIFETIME_OFS = 4;\n+\n+// Request header offsets (RFC6887 7.1), relative to start of packet.\n+//!  PCP client's IP address (16 bytes).\n+constexpr size_t PCP_REQUEST_HDR_IP_OFS = 8;\n+\n+// Response header offsets (RFC6887 7.2), relative to start of packet.\n+//!  Result code (1 byte).\n+constexpr size_t PCP_RESPONSE_HDR_RESULT_OFS = 3;\n+\n+// MAP request/response offsets (RFC6887 11.1), relative to start of opcode-specific data.\n+//!  Mapping nonce (12 bytes).\n+constexpr size_t PCP_MAP_NONCE_OFS = 0;\n+//!  Protocol (1 byte).\n+constexpr size_t PCP_MAP_PROTOCOL_OFS = 12;\n+//!  Internal port for mapping (2 bytes).\n+constexpr size_t PCP_MAP_INTERNAL_PORT_OFS = 16;\n+//!  Suggested external port (request), assigned external port (response) (2 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_PORT_OFS = 18;\n+//!  Suggested external IP (request), assigned external IP (response) (16 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_IP_OFS = 20;\n+\n+//! Result code representing success (RFC6887 7.4), shared with NAT-PMP.\n+constexpr uint8_t PCP_RESULT_SUCCESS = NATPMP_RESULT_SUCCESS;\n+//! Result code representing lack of resources (RFC6887 7.4).\n+constexpr uint8_t PCP_RESULT_NO_RESOURCES = 8;\n+\n+//! Mapping of PCP result code to string (RFC6887 7.4). Result codes <=2 match NAT-PMP.\n+static const std::map<uint8_t, std::string> PCP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"MALFORMED_REQUEST\"},\n+    {4,  \"UNSUPP_OPCODE\"},\n+    {5,  \"UNSUPP_OPTION\"},\n+    {6,  \"MALFORMED_OPTION\"},\n+    {7,  \"NETWORK_FAILURE\"},\n+    {8,  \"NO_RESOURCES\"},\n+    {9,  \"UNSUPP_PROTOCOL\"},\n+    {10, \"USER_EX_QUOTA\"},\n+    {11, \"CANNOT_PROVIDE_EXTERNAL\"},\n+    {12, \"ADDRESS_MISMATCH\"},\n+    {13, \"EXCESSIVE_REMOTE_PEER\"},\n+};\n+\n+//! Return human-readable string from NATPMP result code.\n+static std::string NATPMPResultString(uint8_t result_code)\n+{\n+    auto result_i = NATPMP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == NATPMP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Return human-readable string from PCP result code.\n+static std::string PCPResultString(uint8_t result_code)\n+{\n+    auto result_i = PCP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == PCP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Wrap address in IPv6 according to RFC6887. wrapped_addr needs to be able to store 16 bytes.\n+[[nodiscard]] static bool PCPWrapAddress(Span<uint8_t> wrapped_addr, const CNetAddr &addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (addr.IsIPv4()) {\n+        struct in_addr addr4;\n+        if (!addr.GetInAddr(&addr4)) return false;\n+        // Section 5: \"When the address field holds an IPv4 address, an IPv4-mapped IPv6 address [RFC4291] is used (::ffff:0:0/96).\"\n+        std::memcpy(wrapped_addr.data(), IPV4_IN_IPV6_PREFIX.data(), IPV4_IN_IPV6_PREFIX.size());\n+        std::memcpy(wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), &addr4, ADDR_IPV4_SIZE);\n+        return true;\n+    } else if (addr.IsIPv6()) {\n+        struct in6_addr addr6;\n+        if (!addr.GetIn6Addr(&addr6)) return false;\n+        std::memcpy(wrapped_addr.data(), &addr6, ADDR_IPV6_SIZE);\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+//! Unwrap PCP-encoded address according to RFC6887.\n+static CNetAddr PCPUnwrapAddress(Span<const uint8_t> wrapped_addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (util::HasPrefix(wrapped_addr, IPV4_IN_IPV6_PREFIX)) {\n+        struct in_addr addr4;\n+        std::memcpy(&addr4, wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), ADDR_IPV4_SIZE);\n+        return CNetAddr(addr4);\n+    } else {\n+        struct in6_addr addr6;\n+        std::memcpy(&addr6, wrapped_addr.data(), ADDR_IPV6_SIZE);\n+        return CNetAddr(addr6);\n+    }\n+}\n+\n+//! PCP or NAT-PMP send-receive loop.\n+static std::optional<std::vector<uint8_t>> PCPSendRecv(Sock &sock, const std::string &protocol, Span<const uint8_t> request, int num_tries,\n+        std::chrono::milliseconds timeout_per_try,\n+        std::function<bool(const Span<const uint8_t>)> check_packet)",
      "path": "src/util/pcp.cpp",
      "position": null,
      "original_position": 217,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "44316c39006a4ea906e9ae41a3fdbdf28f318ce5",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In commit \"net: Add PCP and NATPMP implementation\"\r\n\r\nThe `const` before `Span<const uint8_t>` has no effect (it's an argument that's passed by value). You can drop it while still keeping the one in the actual lambdas passed to this function (if you want to prevent the body of those lambdas from modifying the copy of the Span they receive).",
      "created_at": "2024-06-18T19:10:12Z",
      "updated_at": "2024-06-18T19:49:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1644929901",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1644929901"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 217,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1644941149",
      "pull_request_review_id": 2126279596,
      "id": 1644941149,
      "node_id": "PRRC_kwDOABII585iC89d",
      "diff_hunk": "@@ -0,0 +1,520 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/pcp.h>\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <random.h>\n+#include <span.h>\n+#include <util/check.h>\n+#include <util/netif.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+// RFC6886 NAT-PMP and RFC6887 Port Control Protocol (PCP) implementation.\n+// NAT-PMP and PCP use network byte order (big-endian).\n+\n+// NAT-PMP (v0) protocol constants.\n+//! NAT-PMP uses a fixed server port number (RFC6887 section 1.1).\n+constexpr uint16_t NATPMP_SERVER_PORT = 5351;\n+//! Version byte for NATPMP (RFC6886 1.1)\n+constexpr uint8_t NATPMP_VERSION = 0;\n+//! Request opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_REQUEST = 0x00;\n+//! Response opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_RESPONSE = 0x80;\n+//! Get external address (RFC6886 3.2)\n+constexpr uint8_t NATPMP_OP_GETEXTERNAL = 0x00;\n+//! Map TCP port (RFC6886 3.3)\n+constexpr uint8_t NATPMP_OP_MAP_TCP = 0x02;\n+//! Shared request header size in bytes.\n+constexpr size_t NATPMP_REQUEST_HDR_SIZE = 2;\n+//! Shared response header (minimum) size in bytes.\n+constexpr size_t NATPMP_RESPONSE_HDR_SIZE = 8;\n+//! GETEXTERNAL request size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 0;\n+//! GETEXTERNAL response size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 4;\n+//! MAP request size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 10;\n+//! MAP response size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 8;\n+\n+// Shared header offsets (RFC6886 3.2, 3.3), relative to start of packet.\n+//!  Offset of version field in packets.\n+constexpr size_t NATPMP_HDR_VERSION_OFS = 0;\n+//!  Offset of opcode field in packets\n+constexpr size_t NATPMP_HDR_OP_OFS = 1;\n+//!  Offset of result code in packets. Result codes are 16 bit in NAT-PMP instead of 8 bit in PCP.\n+constexpr size_t NATPMP_RESPONSE_HDR_RESULT_OFS = 2;\n+\n+// GETEXTERNAL response offsets (RFC6886 3.2), relative to start of packet.\n+//!  Returned external address\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_IP_OFS = 8;\n+\n+// MAP request offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port to be mapped.\n+constexpr size_t NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS = 4;\n+//!  Suggested external port for mapping.\n+constexpr size_t NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS = 6;\n+//!  Requested port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_REQUEST_LIFETIME_OFS = 8;\n+\n+// MAP response offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port for mapping (will match internal port of request).\n+constexpr size_t NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS = 8;\n+//!  External port for mapping.\n+constexpr size_t NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS = 10;\n+//!  Created port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_RESPONSE_LIFETIME_OFS = 12;\n+\n+// Relevant NETPMP result codes (RFC6886 3.5).\n+//! Result code representing success status.\n+constexpr uint8_t NATPMP_RESULT_SUCCESS = 0;\n+//! Result code representing unsupported version.\n+constexpr uint8_t NATPMP_RESULT_UNSUPP_VERSION = 1;\n+//! Result code representing lack of resources.\n+constexpr uint8_t NATPMP_RESULT_NO_RESOURCES = 4;\n+\n+//! Mapping of NATPMP result code to string (RFC6886 3.5). Result codes <=2 match PCP.\n+static const std::map<uint8_t, std::string> NATPMP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"NETWORK_FAILURE\"},\n+    {4,  \"NO_RESOURCES\"},\n+    {5,  \"UNSUPP_OPCODE\"},\n+};\n+\n+// PCP (v2) protocol constants.\n+//! Maximum packet size in bytes (RFC6887 section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (RFC6887 section 19.1). Shared with NAT-PMP.\n+constexpr uint16_t PCP_SERVER_PORT = NATPMP_SERVER_PORT;\n+//! Version byte. 0 is NAT-PMP (RFC6886), 1 is forbidden, 2 for PCP (RFC6887).\n+constexpr uint8_t PCP_VERSION = 2;\n+//! PCP Request Header. See RFC6887 section 7.1. Shared with NAT-PMP.\n+constexpr uint8_t PCP_REQUEST = NATPMP_REQUEST; // R = 0\n+//! PCP Response Header. See RFC6887 section 7.2. Shared with NAT-PMP.\n+constexpr uint8_t PCP_RESPONSE = NATPMP_RESPONSE; // R = 1\n+//! Map opcode. See RFC6887 section 19.2\n+constexpr uint8_t PCP_OP_MAP = 0x01;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Request and response header size in bytes (RFC6887 section 7.1).\n+constexpr size_t PCP_HDR_SIZE = 24;\n+//! Map request and response size in bytes (RFC6887 section 11.1).\n+constexpr size_t PCP_MAP_SIZE = 36;\n+\n+// Header offsets shared between request and responses (RFC6887 7.1, 7.2), relative to start of packet.\n+//!  Version field (1 byte).\n+constexpr size_t PCP_HDR_VERSION_OFS = NATPMP_HDR_VERSION_OFS;\n+//!  Opcode field (1 byte).\n+constexpr size_t PCP_HDR_OP_OFS = NATPMP_HDR_OP_OFS;\n+//!  Requested lifetime (request), granted lifetime (response) (2 bytes).\n+constexpr size_t PCP_HDR_LIFETIME_OFS = 4;\n+\n+// Request header offsets (RFC6887 7.1), relative to start of packet.\n+//!  PCP client's IP address (16 bytes).\n+constexpr size_t PCP_REQUEST_HDR_IP_OFS = 8;\n+\n+// Response header offsets (RFC6887 7.2), relative to start of packet.\n+//!  Result code (1 byte).\n+constexpr size_t PCP_RESPONSE_HDR_RESULT_OFS = 3;\n+\n+// MAP request/response offsets (RFC6887 11.1), relative to start of opcode-specific data.\n+//!  Mapping nonce (12 bytes).\n+constexpr size_t PCP_MAP_NONCE_OFS = 0;\n+//!  Protocol (1 byte).\n+constexpr size_t PCP_MAP_PROTOCOL_OFS = 12;\n+//!  Internal port for mapping (2 bytes).\n+constexpr size_t PCP_MAP_INTERNAL_PORT_OFS = 16;\n+//!  Suggested external port (request), assigned external port (response) (2 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_PORT_OFS = 18;\n+//!  Suggested external IP (request), assigned external IP (response) (16 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_IP_OFS = 20;\n+\n+//! Result code representing success (RFC6887 7.4), shared with NAT-PMP.\n+constexpr uint8_t PCP_RESULT_SUCCESS = NATPMP_RESULT_SUCCESS;\n+//! Result code representing lack of resources (RFC6887 7.4).\n+constexpr uint8_t PCP_RESULT_NO_RESOURCES = 8;\n+\n+//! Mapping of PCP result code to string (RFC6887 7.4). Result codes <=2 match NAT-PMP.\n+static const std::map<uint8_t, std::string> PCP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"MALFORMED_REQUEST\"},\n+    {4,  \"UNSUPP_OPCODE\"},\n+    {5,  \"UNSUPP_OPTION\"},\n+    {6,  \"MALFORMED_OPTION\"},\n+    {7,  \"NETWORK_FAILURE\"},\n+    {8,  \"NO_RESOURCES\"},\n+    {9,  \"UNSUPP_PROTOCOL\"},\n+    {10, \"USER_EX_QUOTA\"},\n+    {11, \"CANNOT_PROVIDE_EXTERNAL\"},\n+    {12, \"ADDRESS_MISMATCH\"},\n+    {13, \"EXCESSIVE_REMOTE_PEER\"},\n+};\n+\n+//! Return human-readable string from NATPMP result code.\n+static std::string NATPMPResultString(uint8_t result_code)\n+{\n+    auto result_i = NATPMP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == NATPMP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Return human-readable string from PCP result code.\n+static std::string PCPResultString(uint8_t result_code)\n+{\n+    auto result_i = PCP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == PCP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Wrap address in IPv6 according to RFC6887. wrapped_addr needs to be able to store 16 bytes.\n+[[nodiscard]] static bool PCPWrapAddress(Span<uint8_t> wrapped_addr, const CNetAddr &addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (addr.IsIPv4()) {\n+        struct in_addr addr4;\n+        if (!addr.GetInAddr(&addr4)) return false;\n+        // Section 5: \"When the address field holds an IPv4 address, an IPv4-mapped IPv6 address [RFC4291] is used (::ffff:0:0/96).\"\n+        std::memcpy(wrapped_addr.data(), IPV4_IN_IPV6_PREFIX.data(), IPV4_IN_IPV6_PREFIX.size());\n+        std::memcpy(wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), &addr4, ADDR_IPV4_SIZE);\n+        return true;\n+    } else if (addr.IsIPv6()) {\n+        struct in6_addr addr6;\n+        if (!addr.GetIn6Addr(&addr6)) return false;\n+        std::memcpy(wrapped_addr.data(), &addr6, ADDR_IPV6_SIZE);\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+//! Unwrap PCP-encoded address according to RFC6887.\n+static CNetAddr PCPUnwrapAddress(Span<const uint8_t> wrapped_addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (util::HasPrefix(wrapped_addr, IPV4_IN_IPV6_PREFIX)) {\n+        struct in_addr addr4;\n+        std::memcpy(&addr4, wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), ADDR_IPV4_SIZE);\n+        return CNetAddr(addr4);\n+    } else {\n+        struct in6_addr addr6;\n+        std::memcpy(&addr6, wrapped_addr.data(), ADDR_IPV6_SIZE);\n+        return CNetAddr(addr6);\n+    }\n+}\n+\n+//! PCP or NAT-PMP send-receive loop.\n+static std::optional<std::vector<uint8_t>> PCPSendRecv(Sock &sock, const std::string &protocol, Span<const uint8_t> request, int num_tries,\n+        std::chrono::milliseconds timeout_per_try,\n+        std::function<bool(const Span<const uint8_t>)> check_packet)\n+{\n+    // UDP is a potentially lossy protocol, so we try to send again a few times.\n+    uint8_t response[PCP_MAX_SIZE];\n+    bool got_response = false;\n+    int recvsz = 0;\n+    for (int ntry = 0; !got_response && ntry < num_tries; ++ntry) {\n+        if (ntry > 0) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Retrying (%d)\\n\", protocol, ntry);\n+        }\n+        // Dispatch packet to gateway.\n+        if (sock.Send(request.data(), request.size(), 0) != static_cast<ssize_t>(request.size())) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not send request: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+            return std::nullopt; // Network-level error, probably no use retrying.\n+        }\n+\n+        // Wait for response(s) until we get a valid response, a network error, or time out.\n+        auto cur_time = std::chrono::time_point_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now());\n+        auto deadline = cur_time + timeout_per_try;\n+        while ((cur_time = std::chrono::time_point_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now())) < deadline) {\n+            Sock::Event occurred = 0;\n+            if (!sock.Wait(deadline - cur_time, Sock::RECV, &occurred)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not wait on socket: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            if (!occurred) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Timeout\\n\", protocol);\n+                break; // Retry.\n+            }\n+\n+            // Receive response.\n+            recvsz = sock.Recv(response, sizeof(response), MSG_DONTWAIT);\n+            if (recvsz < 0) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not receive response: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Received response of %d bytes: %s\\n\", protocol, recvsz, HexStr(Span(response, recvsz)));\n+\n+            if (check_packet(Span<uint8_t>(response, recvsz))) {\n+                got_response = true; // Got expected response, break from receive loop as well as from retry loop.\n+                break;\n+            }\n+        }\n+    }\n+    if (!got_response) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Giving up after %d tries\\n\", protocol, num_tries);\n+        return std::nullopt;\n+    }\n+    return std::vector<uint8_t>(response, response + recvsz);\n+}\n+\n+std::variant<MappingResult, MappingError> NATPMPRequestPortMap(const CNetAddr &gateway, uint16_t port, uint32_t lifetime, int num_tries, std::chrono::milliseconds timeout_per_try)\n+{\n+    struct sockaddr_storage dest_addr;\n+    socklen_t dest_addrlen = sizeof(struct sockaddr_storage);\n+\n+    LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"natpmp: Requesting port mapping port %d from gateway %s\\n\", port, gateway.ToStringAddr());\n+\n+    // Validate gateway, make sure it's IPv4. NAT-PMP does not support IPv6.\n+    if (!CService(gateway, PCP_SERVER_PORT).GetSockAddr((struct sockaddr*)&dest_addr, &dest_addrlen)) return MappingError::NETWORK_ERROR;\n+    if (dest_addr.ss_family != AF_INET) return MappingError::NETWORK_ERROR;\n+\n+    // Create IPv4 UDP socket\n+    SOCKET sock_fd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);\n+    if (sock_fd == INVALID_SOCKET) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Could not create UDP socket: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+    Sock sock(sock_fd);\n+\n+    // Associate UDP socket to gateway.\n+    if (sock.Connect((struct sockaddr*)&dest_addr, dest_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Could not connect to gateway: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Use getsockname to get the address toward the default gateway (the internal address).",
      "path": "src/util/pcp.cpp",
      "position": 298,
      "original_position": 293,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "44316c39006a4ea906e9ae41a3fdbdf28f318ce5",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In commit \"net: Add PCP and NATPMP implementation\"\r\n\r\nIs this `internal` address expected to be different than the `gateway` variable that's passed in? It seems this `internal` address is only used to convert to a `CService` at return time from this function, so if it's equal to `gateway`, this seems like a very roundabout way of getting there.",
      "created_at": "2024-06-18T19:22:10Z",
      "updated_at": "2024-06-18T19:49:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1644941149",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1644941149"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 298,
      "original_line": 298,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1644962602",
      "pull_request_review_id": 2126279596,
      "id": 1644962602,
      "node_id": "PRRC_kwDOABII585iDCMq",
      "diff_hunk": "@@ -0,0 +1,68 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_PCP_H\n+#define BITCOIN_UTIL_PCP_H\n+\n+#include <netaddress.h>\n+\n+#include <variant>\n+\n+// RFC6886 NAT-PMP and RFC6887 Port Control Protocol (PCP) implementation.\n+// NAT-PMP and PCP use network byte order (big-endian).\n+\n+//! Mapping nonce size in bytes (see RFC6887 section 11.1).\n+constexpr size_t PCP_MAP_NONCE_SIZE = 12;\n+\n+//! PCP mapping nonce. Arbitrary data chosen by the client to identify a mapping.\n+typedef std::array<uint8_t, PCP_MAP_NONCE_SIZE> PCPMappingNonce;\n+\n+//! Unsuccessful response to a port mapping.\n+enum class MappingError {\n+    NETWORK_ERROR,  ///< Any kind of network-level error.\n+    PROTOCOL_ERROR, ///< Any kind of protocol-level error, except unsupported version or no resources.\n+    UNSUPP_VERSION, ///< Unsupported protocol version.\n+    NO_RESOURCES,   ///< No resources available (port probably already mapped).\n+};\n+\n+//! Successful response to a port mapping.\n+struct MappingResult {\n+    MappingResult(uint8_t version, const CService &internal_in, const CService &external_in, uint32_t lifetime_in):\n+        version(version), internal(internal_in), external(external_in), lifetime(lifetime_in) {}\n+    //! Protocol version, one of NATPMP_VERSION or PCP_VERSION.\n+    uint8_t version;\n+    //! Internal host:port.\n+    CService internal;\n+    //! External host:port.\n+    CService external;\n+    //! Granted lifetime of binding (seconds).\n+    uint32_t lifetime;\n+\n+    //! Format mapping as string for logging.\n+    std::string ToString();\n+};\n+\n+//! Try to open a port using RFC 6886 NAT-PMP. IPv4 only.\n+//!\n+//! * gateway: Destination address for PCP requests (usually the default gateway).\n+//! * port: Internal port, and desired external port.\n+//! * lifetime: Requested lifetime in seconds for mapping. The server may assign as shorter or longer lifetime. A lifetime of 0 deletes the mapping.\n+//! * num_tries: Number of tries in case of no response.\n+//!\n+//! Returns the external_ip:external_port of the mapping if successful, otherwise a MappingError.\n+std::variant<MappingResult, MappingError> NATPMPRequestPortMap(const CNetAddr &gateway, uint16_t port, uint32_t lifetime, int num_tries = 3, std::chrono::milliseconds timeout_per_try = std::chrono::milliseconds(1000));",
      "path": "src/util/pcp.h",
      "position": 54,
      "original_position": 54,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "44316c39006a4ea906e9ae41a3fdbdf28f318ce5",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In commit \"net: Add PCP and NATPMP implementation\"\r\n\r\nNit, if you want somewhat more brevity:\r\n\r\n```c++\r\nusing namespace std::chrono_literals;\r\n\r\n... NATPMPRequestPortMap(..., std::chrono::milliseconds timeout_per_try = 1s);\r\n```\r\n\r\n(and below)",
      "created_at": "2024-06-18T19:44:32Z",
      "updated_at": "2024-06-18T19:52:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1644962602",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1644962602"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 54,
      "original_line": 54,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1644965614",
      "pull_request_review_id": 2126279596,
      "id": 1644965614,
      "node_id": "PRRC_kwDOABII585iDC7u",
      "diff_hunk": "@@ -0,0 +1,520 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/pcp.h>\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <random.h>\n+#include <span.h>\n+#include <util/check.h>\n+#include <util/netif.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+// RFC6886 NAT-PMP and RFC6887 Port Control Protocol (PCP) implementation.\n+// NAT-PMP and PCP use network byte order (big-endian).\n+\n+// NAT-PMP (v0) protocol constants.\n+//! NAT-PMP uses a fixed server port number (RFC6887 section 1.1).\n+constexpr uint16_t NATPMP_SERVER_PORT = 5351;\n+//! Version byte for NATPMP (RFC6886 1.1)\n+constexpr uint8_t NATPMP_VERSION = 0;\n+//! Request opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_REQUEST = 0x00;\n+//! Response opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_RESPONSE = 0x80;\n+//! Get external address (RFC6886 3.2)\n+constexpr uint8_t NATPMP_OP_GETEXTERNAL = 0x00;\n+//! Map TCP port (RFC6886 3.3)\n+constexpr uint8_t NATPMP_OP_MAP_TCP = 0x02;\n+//! Shared request header size in bytes.\n+constexpr size_t NATPMP_REQUEST_HDR_SIZE = 2;\n+//! Shared response header (minimum) size in bytes.\n+constexpr size_t NATPMP_RESPONSE_HDR_SIZE = 8;\n+//! GETEXTERNAL request size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 0;\n+//! GETEXTERNAL response size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 4;\n+//! MAP request size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 10;\n+//! MAP response size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 8;\n+\n+// Shared header offsets (RFC6886 3.2, 3.3), relative to start of packet.\n+//!  Offset of version field in packets.\n+constexpr size_t NATPMP_HDR_VERSION_OFS = 0;\n+//!  Offset of opcode field in packets\n+constexpr size_t NATPMP_HDR_OP_OFS = 1;\n+//!  Offset of result code in packets. Result codes are 16 bit in NAT-PMP instead of 8 bit in PCP.\n+constexpr size_t NATPMP_RESPONSE_HDR_RESULT_OFS = 2;\n+\n+// GETEXTERNAL response offsets (RFC6886 3.2), relative to start of packet.\n+//!  Returned external address\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_IP_OFS = 8;\n+\n+// MAP request offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port to be mapped.\n+constexpr size_t NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS = 4;\n+//!  Suggested external port for mapping.\n+constexpr size_t NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS = 6;\n+//!  Requested port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_REQUEST_LIFETIME_OFS = 8;\n+\n+// MAP response offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port for mapping (will match internal port of request).\n+constexpr size_t NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS = 8;\n+//!  External port for mapping.\n+constexpr size_t NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS = 10;\n+//!  Created port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_RESPONSE_LIFETIME_OFS = 12;\n+\n+// Relevant NETPMP result codes (RFC6886 3.5).\n+//! Result code representing success status.\n+constexpr uint8_t NATPMP_RESULT_SUCCESS = 0;\n+//! Result code representing unsupported version.\n+constexpr uint8_t NATPMP_RESULT_UNSUPP_VERSION = 1;\n+//! Result code representing lack of resources.\n+constexpr uint8_t NATPMP_RESULT_NO_RESOURCES = 4;\n+\n+//! Mapping of NATPMP result code to string (RFC6886 3.5). Result codes <=2 match PCP.\n+static const std::map<uint8_t, std::string> NATPMP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"NETWORK_FAILURE\"},\n+    {4,  \"NO_RESOURCES\"},\n+    {5,  \"UNSUPP_OPCODE\"},\n+};\n+\n+// PCP (v2) protocol constants.\n+//! Maximum packet size in bytes (RFC6887 section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (RFC6887 section 19.1). Shared with NAT-PMP.\n+constexpr uint16_t PCP_SERVER_PORT = NATPMP_SERVER_PORT;\n+//! Version byte. 0 is NAT-PMP (RFC6886), 1 is forbidden, 2 for PCP (RFC6887).\n+constexpr uint8_t PCP_VERSION = 2;\n+//! PCP Request Header. See RFC6887 section 7.1. Shared with NAT-PMP.\n+constexpr uint8_t PCP_REQUEST = NATPMP_REQUEST; // R = 0\n+//! PCP Response Header. See RFC6887 section 7.2. Shared with NAT-PMP.\n+constexpr uint8_t PCP_RESPONSE = NATPMP_RESPONSE; // R = 1\n+//! Map opcode. See RFC6887 section 19.2\n+constexpr uint8_t PCP_OP_MAP = 0x01;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Request and response header size in bytes (RFC6887 section 7.1).\n+constexpr size_t PCP_HDR_SIZE = 24;\n+//! Map request and response size in bytes (RFC6887 section 11.1).\n+constexpr size_t PCP_MAP_SIZE = 36;\n+\n+// Header offsets shared between request and responses (RFC6887 7.1, 7.2), relative to start of packet.\n+//!  Version field (1 byte).\n+constexpr size_t PCP_HDR_VERSION_OFS = NATPMP_HDR_VERSION_OFS;\n+//!  Opcode field (1 byte).\n+constexpr size_t PCP_HDR_OP_OFS = NATPMP_HDR_OP_OFS;\n+//!  Requested lifetime (request), granted lifetime (response) (2 bytes).\n+constexpr size_t PCP_HDR_LIFETIME_OFS = 4;\n+\n+// Request header offsets (RFC6887 7.1), relative to start of packet.\n+//!  PCP client's IP address (16 bytes).\n+constexpr size_t PCP_REQUEST_HDR_IP_OFS = 8;\n+\n+// Response header offsets (RFC6887 7.2), relative to start of packet.\n+//!  Result code (1 byte).\n+constexpr size_t PCP_RESPONSE_HDR_RESULT_OFS = 3;\n+\n+// MAP request/response offsets (RFC6887 11.1), relative to start of opcode-specific data.\n+//!  Mapping nonce (12 bytes).\n+constexpr size_t PCP_MAP_NONCE_OFS = 0;\n+//!  Protocol (1 byte).\n+constexpr size_t PCP_MAP_PROTOCOL_OFS = 12;\n+//!  Internal port for mapping (2 bytes).\n+constexpr size_t PCP_MAP_INTERNAL_PORT_OFS = 16;\n+//!  Suggested external port (request), assigned external port (response) (2 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_PORT_OFS = 18;\n+//!  Suggested external IP (request), assigned external IP (response) (16 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_IP_OFS = 20;\n+\n+//! Result code representing success (RFC6887 7.4), shared with NAT-PMP.\n+constexpr uint8_t PCP_RESULT_SUCCESS = NATPMP_RESULT_SUCCESS;\n+//! Result code representing lack of resources (RFC6887 7.4).\n+constexpr uint8_t PCP_RESULT_NO_RESOURCES = 8;\n+\n+//! Mapping of PCP result code to string (RFC6887 7.4). Result codes <=2 match NAT-PMP.\n+static const std::map<uint8_t, std::string> PCP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"MALFORMED_REQUEST\"},\n+    {4,  \"UNSUPP_OPCODE\"},\n+    {5,  \"UNSUPP_OPTION\"},\n+    {6,  \"MALFORMED_OPTION\"},\n+    {7,  \"NETWORK_FAILURE\"},\n+    {8,  \"NO_RESOURCES\"},\n+    {9,  \"UNSUPP_PROTOCOL\"},\n+    {10, \"USER_EX_QUOTA\"},\n+    {11, \"CANNOT_PROVIDE_EXTERNAL\"},\n+    {12, \"ADDRESS_MISMATCH\"},\n+    {13, \"EXCESSIVE_REMOTE_PEER\"},\n+};\n+\n+//! Return human-readable string from NATPMP result code.\n+static std::string NATPMPResultString(uint8_t result_code)\n+{\n+    auto result_i = NATPMP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == NATPMP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Return human-readable string from PCP result code.\n+static std::string PCPResultString(uint8_t result_code)\n+{\n+    auto result_i = PCP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == PCP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Wrap address in IPv6 according to RFC6887. wrapped_addr needs to be able to store 16 bytes.\n+[[nodiscard]] static bool PCPWrapAddress(Span<uint8_t> wrapped_addr, const CNetAddr &addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (addr.IsIPv4()) {\n+        struct in_addr addr4;\n+        if (!addr.GetInAddr(&addr4)) return false;\n+        // Section 5: \"When the address field holds an IPv4 address, an IPv4-mapped IPv6 address [RFC4291] is used (::ffff:0:0/96).\"\n+        std::memcpy(wrapped_addr.data(), IPV4_IN_IPV6_PREFIX.data(), IPV4_IN_IPV6_PREFIX.size());\n+        std::memcpy(wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), &addr4, ADDR_IPV4_SIZE);\n+        return true;\n+    } else if (addr.IsIPv6()) {\n+        struct in6_addr addr6;\n+        if (!addr.GetIn6Addr(&addr6)) return false;\n+        std::memcpy(wrapped_addr.data(), &addr6, ADDR_IPV6_SIZE);\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+//! Unwrap PCP-encoded address according to RFC6887.\n+static CNetAddr PCPUnwrapAddress(Span<const uint8_t> wrapped_addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (util::HasPrefix(wrapped_addr, IPV4_IN_IPV6_PREFIX)) {\n+        struct in_addr addr4;\n+        std::memcpy(&addr4, wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), ADDR_IPV4_SIZE);\n+        return CNetAddr(addr4);\n+    } else {\n+        struct in6_addr addr6;\n+        std::memcpy(&addr6, wrapped_addr.data(), ADDR_IPV6_SIZE);\n+        return CNetAddr(addr6);\n+    }\n+}\n+\n+//! PCP or NAT-PMP send-receive loop.\n+static std::optional<std::vector<uint8_t>> PCPSendRecv(Sock &sock, const std::string &protocol, Span<const uint8_t> request, int num_tries,\n+        std::chrono::milliseconds timeout_per_try,\n+        std::function<bool(const Span<const uint8_t>)> check_packet)\n+{\n+    // UDP is a potentially lossy protocol, so we try to send again a few times.\n+    uint8_t response[PCP_MAX_SIZE];\n+    bool got_response = false;\n+    int recvsz = 0;\n+    for (int ntry = 0; !got_response && ntry < num_tries; ++ntry) {\n+        if (ntry > 0) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Retrying (%d)\\n\", protocol, ntry);\n+        }\n+        // Dispatch packet to gateway.\n+        if (sock.Send(request.data(), request.size(), 0) != static_cast<ssize_t>(request.size())) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not send request: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+            return std::nullopt; // Network-level error, probably no use retrying.\n+        }\n+\n+        // Wait for response(s) until we get a valid response, a network error, or time out.\n+        auto cur_time = std::chrono::time_point_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now());\n+        auto deadline = cur_time + timeout_per_try;\n+        while ((cur_time = std::chrono::time_point_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now())) < deadline) {\n+            Sock::Event occurred = 0;\n+            if (!sock.Wait(deadline - cur_time, Sock::RECV, &occurred)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not wait on socket: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            if (!occurred) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Timeout\\n\", protocol);\n+                break; // Retry.\n+            }\n+\n+            // Receive response.\n+            recvsz = sock.Recv(response, sizeof(response), MSG_DONTWAIT);\n+            if (recvsz < 0) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not receive response: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Received response of %d bytes: %s\\n\", protocol, recvsz, HexStr(Span(response, recvsz)));\n+\n+            if (check_packet(Span<uint8_t>(response, recvsz))) {\n+                got_response = true; // Got expected response, break from receive loop as well as from retry loop.\n+                break;\n+            }\n+        }\n+    }\n+    if (!got_response) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Giving up after %d tries\\n\", protocol, num_tries);\n+        return std::nullopt;\n+    }\n+    return std::vector<uint8_t>(response, response + recvsz);\n+}\n+\n+std::variant<MappingResult, MappingError> NATPMPRequestPortMap(const CNetAddr &gateway, uint16_t port, uint32_t lifetime, int num_tries, std::chrono::milliseconds timeout_per_try)\n+{\n+    struct sockaddr_storage dest_addr;\n+    socklen_t dest_addrlen = sizeof(struct sockaddr_storage);\n+\n+    LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"natpmp: Requesting port mapping port %d from gateway %s\\n\", port, gateway.ToStringAddr());\n+\n+    // Validate gateway, make sure it's IPv4. NAT-PMP does not support IPv6.\n+    if (!CService(gateway, PCP_SERVER_PORT).GetSockAddr((struct sockaddr*)&dest_addr, &dest_addrlen)) return MappingError::NETWORK_ERROR;\n+    if (dest_addr.ss_family != AF_INET) return MappingError::NETWORK_ERROR;\n+\n+    // Create IPv4 UDP socket\n+    SOCKET sock_fd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);\n+    if (sock_fd == INVALID_SOCKET) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Could not create UDP socket: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+    Sock sock(sock_fd);\n+\n+    // Associate UDP socket to gateway.\n+    if (sock.Connect((struct sockaddr*)&dest_addr, dest_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Could not connect to gateway: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Use getsockname to get the address toward the default gateway (the internal address).\n+    struct sockaddr_in internal;\n+    socklen_t internal_addrlen = sizeof(struct sockaddr_in);\n+    if (sock.GetSockName((struct sockaddr*)&internal, &internal_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Could not get sock name: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Request external IP address (RFC6886 section 3.2).\n+    std::vector<uint8_t> request(NATPMP_GETEXTERNAL_REQUEST_SIZE);\n+    request[NATPMP_HDR_VERSION_OFS] = NATPMP_VERSION;\n+    request[NATPMP_HDR_OP_OFS] = NATPMP_REQUEST | NATPMP_OP_GETEXTERNAL;\n+\n+    auto recv_res = PCPSendRecv(sock, \"natpmp\", request, num_tries, timeout_per_try,\n+        [&](const Span<const uint8_t> response) -> bool {\n+            if (response.size() < NATPMP_GETEXTERNAL_RESPONSE_SIZE) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response too small\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            if (response[NATPMP_HDR_VERSION_OFS] != NATPMP_VERSION || response[NATPMP_HDR_OP_OFS] != (NATPMP_RESPONSE | NATPMP_OP_GETEXTERNAL)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response to wrong command\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            return true;\n+        });\n+\n+    struct in_addr external_addr;\n+    if (recv_res) {\n+        const std::span<const uint8_t> response = *recv_res;\n+\n+        Assume(response.size() >= NATPMP_GETEXTERNAL_RESPONSE_SIZE);\n+        uint16_t result_code = ReadBE16(response.data() + NATPMP_RESPONSE_HDR_RESULT_OFS);\n+        if (result_code != NATPMP_RESULT_SUCCESS) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Getting external address failed with result %s\\n\", NATPMPResultString(result_code));\n+            return MappingError::PROTOCOL_ERROR;\n+        }\n+\n+        std::memcpy(&external_addr, response.data() + NATPMP_GETEXTERNAL_RESPONSE_IP_OFS, ADDR_IPV4_SIZE);\n+    } else {\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Create TCP mapping request (RFC6886 section 3.3).\n+    request = std::vector<uint8_t>(NATPMP_MAP_REQUEST_SIZE);\n+    request[NATPMP_HDR_VERSION_OFS] = NATPMP_VERSION;\n+    request[NATPMP_HDR_OP_OFS] = NATPMP_REQUEST | NATPMP_OP_MAP_TCP;\n+    WriteBE16(request.data() + NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS, port);\n+    WriteBE16(request.data() + NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS, port);\n+    WriteBE32(request.data() + NATPMP_MAP_REQUEST_LIFETIME_OFS, lifetime);\n+\n+    recv_res = PCPSendRecv(sock, \"natpmp\", request, num_tries, timeout_per_try,\n+        [&](const Span<const uint8_t> response) -> bool {\n+            if (response.size() < NATPMP_MAP_RESPONSE_SIZE) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response too small\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            if (response[0] != NATPMP_VERSION || response[1] != (NATPMP_RESPONSE | NATPMP_OP_MAP_TCP)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response to wrong command\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            uint16_t internal_port = ReadBE16(response.data() + NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS);\n+            if (internal_port != port) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response port doesn't match request\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            return true;\n+        });\n+\n+    if (recv_res) {\n+        const std::span<uint8_t> response = *recv_res;\n+\n+        Assume(response.size() >= NATPMP_MAP_RESPONSE_SIZE);\n+        uint16_t result_code = ReadBE16(response.data() + NATPMP_RESPONSE_HDR_RESULT_OFS);\n+        if (result_code != NATPMP_RESULT_SUCCESS) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Port mapping failed with result %s\\n\", NATPMPResultString(result_code));\n+            if (result_code == NATPMP_RESULT_NO_RESOURCES) {\n+                return MappingError::NO_RESOURCES;\n+            }\n+            return MappingError::PROTOCOL_ERROR;\n+        }\n+\n+        uint32_t lifetime_ret = ReadBE32(response.data() + NATPMP_MAP_RESPONSE_LIFETIME_OFS);\n+        uint16_t external_port = ReadBE16(response.data() + NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS);\n+        return MappingResult(NATPMP_VERSION, CService(internal.sin_addr, port), CService(external_addr, external_port), lifetime_ret);\n+    } else {\n+        return MappingError::NETWORK_ERROR;\n+    }\n+}\n+\n+std::variant<MappingResult, MappingError> PCPRequestPortMap(const PCPMappingNonce &nonce, const CNetAddr &gateway, const CNetAddr &bind, uint16_t port, uint32_t lifetime, int num_tries, std::chrono::milliseconds timeout_per_try)\n+{\n+    struct sockaddr_storage dest_addr, bind_addr;\n+    socklen_t dest_addrlen = sizeof(struct sockaddr_storage), bind_addrlen = sizeof(struct sockaddr_storage);\n+\n+    LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"pcp: Requesting port mapping for addr %s port %d from gateway %s\\n\", bind.ToStringAddr(), port, gateway.ToStringAddr());\n+\n+    // Validate addresses, make sure they're the same network family.\n+    if (!CService(gateway, PCP_SERVER_PORT).GetSockAddr((struct sockaddr*)&dest_addr, &dest_addrlen)) return MappingError::NETWORK_ERROR;\n+    if (!CService(bind, 0).GetSockAddr((struct sockaddr*)&bind_addr, &bind_addrlen)) return MappingError::NETWORK_ERROR;\n+    if (dest_addr.ss_family != bind_addr.ss_family) return MappingError::NETWORK_ERROR;\n+\n+    // Create UDP socket (IPv4 or IPv6 based on provided gateway).\n+    SOCKET sock_fd = socket(dest_addr.ss_family, SOCK_DGRAM, IPPROTO_UDP);\n+    if (sock_fd == INVALID_SOCKET) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp: Could not create UDP socket: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+    Sock sock(sock_fd);\n+\n+    // Make sure that we send from requested destination address, anything else will be\n+    // rejected by a security-conscious router.\n+    if (sock.Bind((struct sockaddr*)&bind_addr, bind_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp: Could not bind to address: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Associate UDP socket to gateway.\n+    if (sock.Connect((struct sockaddr*)&dest_addr, dest_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp: Could not connect to gateway: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Use getsockname to get the address toward the default gateway (the internal address),\n+    // in case we don't know what address to map\n+    // (this is only needed if bind is INADDR_ANY, but it doesn't hurt as an extra check).\n+    struct sockaddr_storage internal_addr;\n+    socklen_t internal_addrlen = sizeof(struct sockaddr_storage);\n+    if (sock.GetSockName((struct sockaddr*)&internal_addr, &internal_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp: Could not get sock name: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+    CService internal;\n+    if (!internal.SetSockAddr((struct sockaddr*)&internal_addr)) return MappingError::NETWORK_ERROR;\n+    LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"pcp: Internal address after connect: %s\\n\", internal.ToStringAddr());\n+\n+    // Build request packet. Make sure the packet is zeroed so that reserved fields are zero\n+    // as required by the spec (and not potentially leak data).\n+    // Make sure there's space for the request header and MAP specific request data.\n+    std::vector<uint8_t>request(PCP_HDR_SIZE + PCP_MAP_SIZE);",
      "path": "src/util/pcp.cpp",
      "position": null,
      "original_position": 431,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "44316c39006a4ea906e9ae41a3fdbdf28f318ce5",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In commit \"net: Add PCP and NATPMP implementation\"\r\n\r\nNit: space after type",
      "created_at": "2024-06-18T19:47:29Z",
      "updated_at": "2024-06-18T19:49:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1644965614",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1644965614"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 431,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1645841553",
      "pull_request_review_id": 2127740694,
      "id": 1645841553,
      "node_id": "PRRC_kwDOABII585iGYyR",
      "diff_hunk": "@@ -0,0 +1,305 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#ifdef __FreeBSD__\n+#include <osreldate.h>\n+#endif\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || __FreeBSD_version >= 1400000",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 20,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "a8818568a44e02c0346ef37cde9155191f8b3df1",
      "in_reply_to_id": 1642751240,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "sure, we could do that again, but i don't want people to have to bother with weird error messages and having to load kernel modules, probably this should work out of the box or not at all",
      "created_at": "2024-06-19T09:58:41Z",
      "updated_at": "2024-06-19T09:58:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1645841553",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1645841553"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 22,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1645849656",
      "pull_request_review_id": 2127753795,
      "id": 1645849656,
      "node_id": "PRRC_kwDOABII585iGaw4",
      "diff_hunk": "@@ -0,0 +1,520 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/pcp.h>\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <random.h>\n+#include <span.h>\n+#include <util/check.h>\n+#include <util/netif.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+// RFC6886 NAT-PMP and RFC6887 Port Control Protocol (PCP) implementation.\n+// NAT-PMP and PCP use network byte order (big-endian).\n+\n+// NAT-PMP (v0) protocol constants.\n+//! NAT-PMP uses a fixed server port number (RFC6887 section 1.1).\n+constexpr uint16_t NATPMP_SERVER_PORT = 5351;\n+//! Version byte for NATPMP (RFC6886 1.1)\n+constexpr uint8_t NATPMP_VERSION = 0;\n+//! Request opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_REQUEST = 0x00;\n+//! Response opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_RESPONSE = 0x80;\n+//! Get external address (RFC6886 3.2)\n+constexpr uint8_t NATPMP_OP_GETEXTERNAL = 0x00;\n+//! Map TCP port (RFC6886 3.3)\n+constexpr uint8_t NATPMP_OP_MAP_TCP = 0x02;\n+//! Shared request header size in bytes.\n+constexpr size_t NATPMP_REQUEST_HDR_SIZE = 2;\n+//! Shared response header (minimum) size in bytes.\n+constexpr size_t NATPMP_RESPONSE_HDR_SIZE = 8;\n+//! GETEXTERNAL request size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 0;\n+//! GETEXTERNAL response size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 4;\n+//! MAP request size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 10;\n+//! MAP response size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 8;\n+\n+// Shared header offsets (RFC6886 3.2, 3.3), relative to start of packet.\n+//!  Offset of version field in packets.\n+constexpr size_t NATPMP_HDR_VERSION_OFS = 0;\n+//!  Offset of opcode field in packets\n+constexpr size_t NATPMP_HDR_OP_OFS = 1;\n+//!  Offset of result code in packets. Result codes are 16 bit in NAT-PMP instead of 8 bit in PCP.\n+constexpr size_t NATPMP_RESPONSE_HDR_RESULT_OFS = 2;\n+\n+// GETEXTERNAL response offsets (RFC6886 3.2), relative to start of packet.\n+//!  Returned external address\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_IP_OFS = 8;\n+\n+// MAP request offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port to be mapped.\n+constexpr size_t NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS = 4;\n+//!  Suggested external port for mapping.\n+constexpr size_t NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS = 6;\n+//!  Requested port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_REQUEST_LIFETIME_OFS = 8;\n+\n+// MAP response offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port for mapping (will match internal port of request).\n+constexpr size_t NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS = 8;\n+//!  External port for mapping.\n+constexpr size_t NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS = 10;\n+//!  Created port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_RESPONSE_LIFETIME_OFS = 12;\n+\n+// Relevant NETPMP result codes (RFC6886 3.5).\n+//! Result code representing success status.\n+constexpr uint8_t NATPMP_RESULT_SUCCESS = 0;\n+//! Result code representing unsupported version.\n+constexpr uint8_t NATPMP_RESULT_UNSUPP_VERSION = 1;\n+//! Result code representing lack of resources.\n+constexpr uint8_t NATPMP_RESULT_NO_RESOURCES = 4;\n+\n+//! Mapping of NATPMP result code to string (RFC6886 3.5). Result codes <=2 match PCP.\n+static const std::map<uint8_t, std::string> NATPMP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"NETWORK_FAILURE\"},\n+    {4,  \"NO_RESOURCES\"},\n+    {5,  \"UNSUPP_OPCODE\"},\n+};\n+\n+// PCP (v2) protocol constants.\n+//! Maximum packet size in bytes (RFC6887 section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (RFC6887 section 19.1). Shared with NAT-PMP.\n+constexpr uint16_t PCP_SERVER_PORT = NATPMP_SERVER_PORT;\n+//! Version byte. 0 is NAT-PMP (RFC6886), 1 is forbidden, 2 for PCP (RFC6887).\n+constexpr uint8_t PCP_VERSION = 2;\n+//! PCP Request Header. See RFC6887 section 7.1. Shared with NAT-PMP.\n+constexpr uint8_t PCP_REQUEST = NATPMP_REQUEST; // R = 0\n+//! PCP Response Header. See RFC6887 section 7.2. Shared with NAT-PMP.\n+constexpr uint8_t PCP_RESPONSE = NATPMP_RESPONSE; // R = 1\n+//! Map opcode. See RFC6887 section 19.2\n+constexpr uint8_t PCP_OP_MAP = 0x01;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Request and response header size in bytes (RFC6887 section 7.1).\n+constexpr size_t PCP_HDR_SIZE = 24;\n+//! Map request and response size in bytes (RFC6887 section 11.1).\n+constexpr size_t PCP_MAP_SIZE = 36;\n+\n+// Header offsets shared between request and responses (RFC6887 7.1, 7.2), relative to start of packet.\n+//!  Version field (1 byte).\n+constexpr size_t PCP_HDR_VERSION_OFS = NATPMP_HDR_VERSION_OFS;\n+//!  Opcode field (1 byte).\n+constexpr size_t PCP_HDR_OP_OFS = NATPMP_HDR_OP_OFS;\n+//!  Requested lifetime (request), granted lifetime (response) (2 bytes).\n+constexpr size_t PCP_HDR_LIFETIME_OFS = 4;\n+\n+// Request header offsets (RFC6887 7.1), relative to start of packet.\n+//!  PCP client's IP address (16 bytes).\n+constexpr size_t PCP_REQUEST_HDR_IP_OFS = 8;\n+\n+// Response header offsets (RFC6887 7.2), relative to start of packet.\n+//!  Result code (1 byte).\n+constexpr size_t PCP_RESPONSE_HDR_RESULT_OFS = 3;\n+\n+// MAP request/response offsets (RFC6887 11.1), relative to start of opcode-specific data.\n+//!  Mapping nonce (12 bytes).\n+constexpr size_t PCP_MAP_NONCE_OFS = 0;\n+//!  Protocol (1 byte).\n+constexpr size_t PCP_MAP_PROTOCOL_OFS = 12;\n+//!  Internal port for mapping (2 bytes).\n+constexpr size_t PCP_MAP_INTERNAL_PORT_OFS = 16;\n+//!  Suggested external port (request), assigned external port (response) (2 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_PORT_OFS = 18;\n+//!  Suggested external IP (request), assigned external IP (response) (16 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_IP_OFS = 20;\n+\n+//! Result code representing success (RFC6887 7.4), shared with NAT-PMP.\n+constexpr uint8_t PCP_RESULT_SUCCESS = NATPMP_RESULT_SUCCESS;\n+//! Result code representing lack of resources (RFC6887 7.4).\n+constexpr uint8_t PCP_RESULT_NO_RESOURCES = 8;\n+\n+//! Mapping of PCP result code to string (RFC6887 7.4). Result codes <=2 match NAT-PMP.\n+static const std::map<uint8_t, std::string> PCP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"MALFORMED_REQUEST\"},\n+    {4,  \"UNSUPP_OPCODE\"},\n+    {5,  \"UNSUPP_OPTION\"},\n+    {6,  \"MALFORMED_OPTION\"},\n+    {7,  \"NETWORK_FAILURE\"},\n+    {8,  \"NO_RESOURCES\"},\n+    {9,  \"UNSUPP_PROTOCOL\"},\n+    {10, \"USER_EX_QUOTA\"},\n+    {11, \"CANNOT_PROVIDE_EXTERNAL\"},\n+    {12, \"ADDRESS_MISMATCH\"},\n+    {13, \"EXCESSIVE_REMOTE_PEER\"},\n+};\n+\n+//! Return human-readable string from NATPMP result code.\n+static std::string NATPMPResultString(uint8_t result_code)\n+{\n+    auto result_i = NATPMP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == NATPMP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Return human-readable string from PCP result code.\n+static std::string PCPResultString(uint8_t result_code)\n+{\n+    auto result_i = PCP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == PCP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Wrap address in IPv6 according to RFC6887. wrapped_addr needs to be able to store 16 bytes.\n+[[nodiscard]] static bool PCPWrapAddress(Span<uint8_t> wrapped_addr, const CNetAddr &addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (addr.IsIPv4()) {\n+        struct in_addr addr4;\n+        if (!addr.GetInAddr(&addr4)) return false;\n+        // Section 5: \"When the address field holds an IPv4 address, an IPv4-mapped IPv6 address [RFC4291] is used (::ffff:0:0/96).\"\n+        std::memcpy(wrapped_addr.data(), IPV4_IN_IPV6_PREFIX.data(), IPV4_IN_IPV6_PREFIX.size());\n+        std::memcpy(wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), &addr4, ADDR_IPV4_SIZE);\n+        return true;\n+    } else if (addr.IsIPv6()) {\n+        struct in6_addr addr6;\n+        if (!addr.GetIn6Addr(&addr6)) return false;\n+        std::memcpy(wrapped_addr.data(), &addr6, ADDR_IPV6_SIZE);\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+//! Unwrap PCP-encoded address according to RFC6887.\n+static CNetAddr PCPUnwrapAddress(Span<const uint8_t> wrapped_addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (util::HasPrefix(wrapped_addr, IPV4_IN_IPV6_PREFIX)) {\n+        struct in_addr addr4;\n+        std::memcpy(&addr4, wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), ADDR_IPV4_SIZE);\n+        return CNetAddr(addr4);\n+    } else {\n+        struct in6_addr addr6;\n+        std::memcpy(&addr6, wrapped_addr.data(), ADDR_IPV6_SIZE);\n+        return CNetAddr(addr6);\n+    }\n+}\n+\n+//! PCP or NAT-PMP send-receive loop.\n+static std::optional<std::vector<uint8_t>> PCPSendRecv(Sock &sock, const std::string &protocol, Span<const uint8_t> request, int num_tries,\n+        std::chrono::milliseconds timeout_per_try,\n+        std::function<bool(const Span<const uint8_t>)> check_packet)\n+{\n+    // UDP is a potentially lossy protocol, so we try to send again a few times.\n+    uint8_t response[PCP_MAX_SIZE];\n+    bool got_response = false;\n+    int recvsz = 0;\n+    for (int ntry = 0; !got_response && ntry < num_tries; ++ntry) {\n+        if (ntry > 0) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Retrying (%d)\\n\", protocol, ntry);\n+        }\n+        // Dispatch packet to gateway.\n+        if (sock.Send(request.data(), request.size(), 0) != static_cast<ssize_t>(request.size())) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not send request: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+            return std::nullopt; // Network-level error, probably no use retrying.\n+        }\n+\n+        // Wait for response(s) until we get a valid response, a network error, or time out.\n+        auto cur_time = std::chrono::time_point_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now());\n+        auto deadline = cur_time + timeout_per_try;\n+        while ((cur_time = std::chrono::time_point_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now())) < deadline) {\n+            Sock::Event occurred = 0;\n+            if (!sock.Wait(deadline - cur_time, Sock::RECV, &occurred)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not wait on socket: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            if (!occurred) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Timeout\\n\", protocol);\n+                break; // Retry.\n+            }\n+\n+            // Receive response.\n+            recvsz = sock.Recv(response, sizeof(response), MSG_DONTWAIT);\n+            if (recvsz < 0) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not receive response: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Received response of %d bytes: %s\\n\", protocol, recvsz, HexStr(Span(response, recvsz)));\n+\n+            if (check_packet(Span<uint8_t>(response, recvsz))) {\n+                got_response = true; // Got expected response, break from receive loop as well as from retry loop.\n+                break;\n+            }\n+        }\n+    }\n+    if (!got_response) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Giving up after %d tries\\n\", protocol, num_tries);\n+        return std::nullopt;\n+    }\n+    return std::vector<uint8_t>(response, response + recvsz);\n+}\n+\n+std::variant<MappingResult, MappingError> NATPMPRequestPortMap(const CNetAddr &gateway, uint16_t port, uint32_t lifetime, int num_tries, std::chrono::milliseconds timeout_per_try)\n+{\n+    struct sockaddr_storage dest_addr;\n+    socklen_t dest_addrlen = sizeof(struct sockaddr_storage);\n+\n+    LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"natpmp: Requesting port mapping port %d from gateway %s\\n\", port, gateway.ToStringAddr());\n+\n+    // Validate gateway, make sure it's IPv4. NAT-PMP does not support IPv6.\n+    if (!CService(gateway, PCP_SERVER_PORT).GetSockAddr((struct sockaddr*)&dest_addr, &dest_addrlen)) return MappingError::NETWORK_ERROR;\n+    if (dest_addr.ss_family != AF_INET) return MappingError::NETWORK_ERROR;\n+\n+    // Create IPv4 UDP socket\n+    SOCKET sock_fd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);\n+    if (sock_fd == INVALID_SOCKET) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Could not create UDP socket: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+    Sock sock(sock_fd);\n+\n+    // Associate UDP socket to gateway.\n+    if (sock.Connect((struct sockaddr*)&dest_addr, dest_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Could not connect to gateway: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Use getsockname to get the address toward the default gateway (the internal address).",
      "path": "src/util/pcp.cpp",
      "position": 298,
      "original_position": 293,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "44316c39006a4ea906e9ae41a3fdbdf28f318ce5",
      "in_reply_to_id": 1644941149,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "The internal address is *our* internal address toward the gateway, not the gateway's address (so the address that the port is to be forwarded to from the external address). For IPv6 this is the same as the public address, and we explicitly bind to it before communicating (`getsockname` will just get it back, you're right). For IPv4 it could be anything in the router's private subnet, so we bind to INADDR_ANY and need to get it with `getsockname`.",
      "created_at": "2024-06-19T10:05:07Z",
      "updated_at": "2024-06-19T10:12:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1645849656",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1645849656"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 298,
      "original_line": 298,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1645852506",
      "pull_request_review_id": 2127758463,
      "id": 1645852506,
      "node_id": "PRRC_kwDOABII585iGbda",
      "diff_hunk": "@@ -0,0 +1,68 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_PCP_H\n+#define BITCOIN_UTIL_PCP_H\n+\n+#include <netaddress.h>\n+\n+#include <variant>\n+\n+// RFC6886 NAT-PMP and RFC6887 Port Control Protocol (PCP) implementation.\n+// NAT-PMP and PCP use network byte order (big-endian).\n+\n+//! Mapping nonce size in bytes (see RFC6887 section 11.1).\n+constexpr size_t PCP_MAP_NONCE_SIZE = 12;\n+\n+//! PCP mapping nonce. Arbitrary data chosen by the client to identify a mapping.\n+typedef std::array<uint8_t, PCP_MAP_NONCE_SIZE> PCPMappingNonce;\n+\n+//! Unsuccessful response to a port mapping.\n+enum class MappingError {\n+    NETWORK_ERROR,  ///< Any kind of network-level error.\n+    PROTOCOL_ERROR, ///< Any kind of protocol-level error, except unsupported version or no resources.\n+    UNSUPP_VERSION, ///< Unsupported protocol version.\n+    NO_RESOURCES,   ///< No resources available (port probably already mapped).\n+};\n+\n+//! Successful response to a port mapping.\n+struct MappingResult {\n+    MappingResult(uint8_t version, const CService &internal_in, const CService &external_in, uint32_t lifetime_in):\n+        version(version), internal(internal_in), external(external_in), lifetime(lifetime_in) {}\n+    //! Protocol version, one of NATPMP_VERSION or PCP_VERSION.\n+    uint8_t version;\n+    //! Internal host:port.\n+    CService internal;\n+    //! External host:port.\n+    CService external;\n+    //! Granted lifetime of binding (seconds).\n+    uint32_t lifetime;\n+\n+    //! Format mapping as string for logging.\n+    std::string ToString();\n+};\n+\n+//! Try to open a port using RFC 6886 NAT-PMP. IPv4 only.\n+//!\n+//! * gateway: Destination address for PCP requests (usually the default gateway).\n+//! * port: Internal port, and desired external port.\n+//! * lifetime: Requested lifetime in seconds for mapping. The server may assign as shorter or longer lifetime. A lifetime of 0 deletes the mapping.\n+//! * num_tries: Number of tries in case of no response.\n+//!\n+//! Returns the external_ip:external_port of the mapping if successful, otherwise a MappingError.\n+std::variant<MappingResult, MappingError> NATPMPRequestPortMap(const CNetAddr &gateway, uint16_t port, uint32_t lifetime, int num_tries = 3, std::chrono::milliseconds timeout_per_try = std::chrono::milliseconds(1000));",
      "path": "src/util/pcp.h",
      "position": 54,
      "original_position": 54,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "44316c39006a4ea906e9ae41a3fdbdf28f318ce5",
      "in_reply_to_id": 1644962602,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "It would be great to cut down on the verbosity here, but as this is a header, i don't think we want to use `using` there because that will leak into anything that includes it? Or am i misunderstanding?",
      "created_at": "2024-06-19T10:07:30Z",
      "updated_at": "2024-06-19T10:07:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1645852506",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1645852506"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 54,
      "original_line": 54,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1646397855",
      "pull_request_review_id": 2128615077,
      "id": 1646397855,
      "node_id": "PRRC_kwDOABII585iIgmf",
      "diff_hunk": "@@ -0,0 +1,68 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_PCP_H\n+#define BITCOIN_UTIL_PCP_H\n+\n+#include <netaddress.h>\n+\n+#include <variant>\n+\n+// RFC6886 NAT-PMP and RFC6887 Port Control Protocol (PCP) implementation.\n+// NAT-PMP and PCP use network byte order (big-endian).\n+\n+//! Mapping nonce size in bytes (see RFC6887 section 11.1).\n+constexpr size_t PCP_MAP_NONCE_SIZE = 12;\n+\n+//! PCP mapping nonce. Arbitrary data chosen by the client to identify a mapping.\n+typedef std::array<uint8_t, PCP_MAP_NONCE_SIZE> PCPMappingNonce;\n+\n+//! Unsuccessful response to a port mapping.\n+enum class MappingError {\n+    NETWORK_ERROR,  ///< Any kind of network-level error.\n+    PROTOCOL_ERROR, ///< Any kind of protocol-level error, except unsupported version or no resources.\n+    UNSUPP_VERSION, ///< Unsupported protocol version.\n+    NO_RESOURCES,   ///< No resources available (port probably already mapped).\n+};\n+\n+//! Successful response to a port mapping.\n+struct MappingResult {\n+    MappingResult(uint8_t version, const CService &internal_in, const CService &external_in, uint32_t lifetime_in):\n+        version(version), internal(internal_in), external(external_in), lifetime(lifetime_in) {}\n+    //! Protocol version, one of NATPMP_VERSION or PCP_VERSION.\n+    uint8_t version;\n+    //! Internal host:port.\n+    CService internal;\n+    //! External host:port.\n+    CService external;\n+    //! Granted lifetime of binding (seconds).\n+    uint32_t lifetime;\n+\n+    //! Format mapping as string for logging.\n+    std::string ToString();\n+};\n+\n+//! Try to open a port using RFC 6886 NAT-PMP. IPv4 only.\n+//!\n+//! * gateway: Destination address for PCP requests (usually the default gateway).\n+//! * port: Internal port, and desired external port.\n+//! * lifetime: Requested lifetime in seconds for mapping. The server may assign as shorter or longer lifetime. A lifetime of 0 deletes the mapping.\n+//! * num_tries: Number of tries in case of no response.\n+//!\n+//! Returns the external_ip:external_port of the mapping if successful, otherwise a MappingError.\n+std::variant<MappingResult, MappingError> NATPMPRequestPortMap(const CNetAddr &gateway, uint16_t port, uint32_t lifetime, int num_tries = 3, std::chrono::milliseconds timeout_per_try = std::chrono::milliseconds(1000));",
      "path": "src/util/pcp.h",
      "position": 54,
      "original_position": 54,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "44316c39006a4ea906e9ae41a3fdbdf28f318ce5",
      "in_reply_to_id": 1644962602,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "@laanwj It's true that you generally shouldn't use `using namespace std;` in headers, but the C++ Core Guidelines actually have an [exception](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#sf7-dont-write-using-namespace-at-global-scope-in-a-header-file) for the standard literals. The reason being that literals without underscore are reserved for the standard library, so there is no risk of namespace pollution.",
      "created_at": "2024-06-19T15:29:49Z",
      "updated_at": "2024-06-19T15:29:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1646397855",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1646397855"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 54,
      "original_line": 54,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1647158425",
      "pull_request_review_id": 2129739185,
      "id": 1647158425,
      "node_id": "PRRC_kwDOABII585iLaSZ",
      "diff_hunk": "@@ -0,0 +1,305 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#ifdef __FreeBSD__\n+#include <osreldate.h>\n+#endif\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || __FreeBSD_version >= 1400000",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 20,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "a8818568a44e02c0346ef37cde9155191f8b3df1",
      "in_reply_to_id": 1642751240,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Good point, maybe just add a comment about this. FreeBSD 13 won't be EOL for another two years, so someone else might wonder.",
      "created_at": "2024-06-20T08:12:35Z",
      "updated_at": "2024-06-20T08:12:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1647158425",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1647158425"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 22,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1648841695",
      "pull_request_review_id": 2132453192,
      "id": 1648841695,
      "node_id": "PRRC_kwDOABII585iR1Pf",
      "diff_hunk": "@@ -0,0 +1,305 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#ifdef __FreeBSD__\n+#include <osreldate.h>\n+#endif\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || __FreeBSD_version >= 1400000",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 20,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "a8818568a44e02c0346ef37cde9155191f8b3df1",
      "in_reply_to_id": 1642751240,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "The comment says 13.2+ but the code says 1400000",
      "created_at": "2024-06-21T11:30:35Z",
      "updated_at": "2024-06-21T11:30:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1648841695",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1648841695"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 22,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649094052",
      "pull_request_review_id": 2132874534,
      "id": 1649094052,
      "node_id": "PRRC_kwDOABII585iSy2k",
      "diff_hunk": "@@ -0,0 +1,305 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#ifdef __FreeBSD__\n+#include <osreldate.h>\n+#endif\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || __FreeBSD_version >= 1400000\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+// Workaround https://github.com/freebsd/freebsd-src/pull/1070.\n+#define typeof __typeof\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 39,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "faacd264417bd7f3f08c5ff497458030b3a54fbc",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Now that #30202 has been merged this can be:\r\n\r\n```diff\r\n     // Create a netlink socket.\r\n-    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\r\n-    if (s < 0) {\r\n+    auto sock{CreateSock(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\r\n+    if (!sock) {\r\n         LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\r\n         return std::nullopt;\r\n     }\r\n-    Sock sock{static_cast<SOCKET>(s)};\r\n\r\n     // Send request.\r\n```\r\nand replace `sock.Send()` with `sock->Send()` below (same for `Recv()`).\r\n\r\nThis would allow mocking of the socket creation.",
      "created_at": "2024-06-21T15:09:12Z",
      "updated_at": "2024-06-21T16:39:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1649094052",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649094052"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": 33,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 39,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649097270",
      "pull_request_review_id": 2132874534,
      "id": 1649097270,
      "node_id": "PRRC_kwDOABII585iSzo2",
      "diff_hunk": "@@ -0,0 +1,305 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#ifdef __FreeBSD__\n+#include <osreldate.h>\n+#endif\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || __FreeBSD_version >= 1400000\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+// Workaround https://github.com/freebsd/freebsd-src/pull/1070.\n+#define typeof __typeof\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 49,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "faacd264417bd7f3f08c5ff497458030b3a54fbc",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n    // Whether to use the first 4 or 16 bytes from request.dst_data.\r\n```",
      "created_at": "2024-06-21T15:11:52Z",
      "updated_at": "2024-06-21T16:39:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1649097270",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649097270"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 49,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649113447",
      "pull_request_review_id": 2132874534,
      "id": 1649113447,
      "node_id": "PRRC_kwDOABII585iS3ln",
      "diff_hunk": "@@ -0,0 +1,305 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#ifdef __FreeBSD__\n+#include <osreldate.h>\n+#endif\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || __FreeBSD_version >= 1400000\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+// Workaround https://github.com/freebsd/freebsd-src/pull/1070.\n+#define typeof __typeof\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = family == AF_INET ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    // Linux IPv4 / IPv6 - this must be present, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = family;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    // Linux IPv4 / IPv6 this must be absent, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    int64_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, recv_result); hdr = NLMSG_NEXT(hdr, recv_result)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (family == AF_INET) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 110,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "faacd264417bd7f3f08c5ff497458030b3a54fbc",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "If it happens that `sizeof(in_addr)` is not equal to `RTA_PAYLOAD(rta_gateway)` then I think it is better to not allow this to continue to the `memcpy()` because it could read past the end of the buffer. If we don't want to stop a release/production program for this with an `assert()`, then log + `return std::nullopt;` is maybe better than copying random undefined bytes around and interpreting them as an IP address.\r\n\r\n(same for some `Assume()`s in the Apple implementation)",
      "created_at": "2024-06-21T15:25:18Z",
      "updated_at": "2024-06-21T16:40:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1649113447",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649113447"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": 108,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 115,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649167543",
      "pull_request_review_id": 2132874534,
      "id": 1649167543,
      "node_id": "PRRC_kwDOABII585iTEy3",
      "diff_hunk": "@@ -0,0 +1,305 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#ifdef __FreeBSD__\n+#include <osreldate.h>\n+#endif\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || __FreeBSD_version >= 1400000\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+// Workaround https://github.com/freebsd/freebsd-src/pull/1070.\n+#define typeof __typeof\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = family == AF_INET ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    // Linux IPv4 / IPv6 - this must be present, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = family;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    // Linux IPv4 / IPv6 this must be absent, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    int64_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, recv_result); hdr = NLMSG_NEXT(hdr, recv_result)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (family == AF_INET) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (family == AF_INET6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    destination_address.si_family = family;\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    Assume(best_route.NextHop.si_family == family);\n+    if (family == AF_INET) {\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(family == AF_INET6) {\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+\n+static std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Check valid length. Note that sa_len is not part of POSIX, and exists on MacOS and some BSDs only, so we can't\n+    // do this check in SetSockAddr.\n+    if (!(addr->sa_family == AF_INET && addr->sa_len == sizeof(struct sockaddr_in)) &&\n+        !(addr->sa_family == AF_INET6 && addr->sa_len == sizeof(struct sockaddr_in6))) {\n+        return std::nullopt;\n+    }\n+\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+//! MacOS: Get default gateway from route table. See route(4) for the format.\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // net.route.0.inet[6].flags.gateway\n+    int mib[] = {CTL_NET, PF_ROUTE, 0, family, NET_RT_FLAGS, RTF_GATEWAY};\n+    // The size of the available data is determined by calling sysctl() with oldp=nullptr. See sysctl(3).\n+    size_t l = 0;\n+    if (sysctl(/*name=*/mib, /*namelen=*/sizeof(mib) / sizeof(int), /*oldp=*/nullptr, /*oldlenp=*/&l, /*newp=*/nullptr, /*newlen=*/0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl length of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    std::vector<std::byte> buf(l);\n+    if (sysctl(/*name=*/mib, /*namelen=*/sizeof(mib) / sizeof(int), /*oldp=*/buf.data(), /*oldlenp=*/&l, /*newp=*/nullptr, /*newlen=*/0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl data of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    // Iterate over messages (each message is a routing table entry).\n+    for (size_t msg_pos = 0; msg_pos < buf.size(); ) {\n+        Assume((msg_pos + sizeof(rt_msghdr)) <= buf.size());\n+        const struct rt_msghdr* rt = (const struct rt_msghdr*)(buf.data() + msg_pos);\n+        const size_t next_msg_pos = msg_pos + rt->rtm_msglen;\n+        Assume(rt->rtm_msglen >= sizeof(rt_msghdr) && next_msg_pos <= buf.size());\n+        // Iterate over addresses within message, get destination and gateway (if present).\n+        // Address data starts after header.\n+        size_t sa_pos = msg_pos + sizeof(struct rt_msghdr);\n+        std::optional<CNetAddr> dst, gateway;\n+        for (int i = 0; i < RTAX_MAX; i++) {\n+            if (rt->rtm_addrs & (1 << i)) {\n+                // 2 is just sa_len + sa_family, the theoretical minimum size of a socket address.\n+                Assume((sa_pos + 2) <= next_msg_pos);\n+                const struct sockaddr* sa = (const struct sockaddr*)(buf.data() + sa_pos);\n+                Assume(sa->sa_len >= 2 && (sa_pos + sa->sa_len) <= next_msg_pos);\n+                if (i == RTAX_DST) {\n+                    dst = FromSockAddr(sa);\n+                } else if (i == RTAX_GATEWAY) {\n+                    gateway = FromSockAddr(sa);\n+                }\n+                // Skip to next address.\n+                sa_pos += sa->sa_len;\n+            }\n+        }\n+        // Found default gateway?\n+        if (dst && gateway && dst->IsBindAny()) { // Route to 0.0.0.0 or :: ?\n+            return *gateway;\n+        }\n+        // Skip to next message.\n+        msg_pos = next_msg_pos;\n+    }\n+    return std::nullopt;\n+}\n+\n+#else\n+\n+// Dummy implementation.\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    (void)family;\n+    return std::nullopt;",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 242,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "faacd264417bd7f3f08c5ff497458030b3a54fbc",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit, can drop the parameter name for an unused parameter and the `void` cast:\r\n```suggestion\r\nstatic std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t)\r\n{\r\n    return std::nullopt;\r\n```",
      "created_at": "2024-06-21T16:11:41Z",
      "updated_at": "2024-06-21T16:39:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1649167543",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649167543"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": 239,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 244,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649171297",
      "pull_request_review_id": 2132874534,
      "id": 1649171297,
      "node_id": "PRRC_kwDOABII585iTFth",
      "diff_hunk": "@@ -0,0 +1,305 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#ifdef __FreeBSD__\n+#include <osreldate.h>\n+#endif\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || __FreeBSD_version >= 1400000\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+// Workaround https://github.com/freebsd/freebsd-src/pull/1070.\n+#define typeof __typeof\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = family == AF_INET ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    // Linux IPv4 / IPv6 - this must be present, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = family;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    // Linux IPv4 / IPv6 this must be absent, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    int64_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, recv_result); hdr = NLMSG_NEXT(hdr, recv_result)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (family == AF_INET) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (family == AF_INET6) {\n+                Assume(sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway));\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+#include <iphlpapi.h>\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    destination_address.si_family = family;\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    Assume(best_route.NextHop.si_family == family);\n+    if (family == AF_INET) {\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(family == AF_INET6) {\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+\n+static std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Check valid length. Note that sa_len is not part of POSIX, and exists on MacOS and some BSDs only, so we can't\n+    // do this check in SetSockAddr.\n+    if (!(addr->sa_family == AF_INET && addr->sa_len == sizeof(struct sockaddr_in)) &&\n+        !(addr->sa_family == AF_INET6 && addr->sa_len == sizeof(struct sockaddr_in6))) {\n+        return std::nullopt;\n+    }\n+\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+//! MacOS: Get default gateway from route table. See route(4) for the format.\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // net.route.0.inet[6].flags.gateway\n+    int mib[] = {CTL_NET, PF_ROUTE, 0, family, NET_RT_FLAGS, RTF_GATEWAY};\n+    // The size of the available data is determined by calling sysctl() with oldp=nullptr. See sysctl(3).\n+    size_t l = 0;\n+    if (sysctl(/*name=*/mib, /*namelen=*/sizeof(mib) / sizeof(int), /*oldp=*/nullptr, /*oldlenp=*/&l, /*newp=*/nullptr, /*newlen=*/0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl length of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    std::vector<std::byte> buf(l);\n+    if (sysctl(/*name=*/mib, /*namelen=*/sizeof(mib) / sizeof(int), /*oldp=*/buf.data(), /*oldlenp=*/&l, /*newp=*/nullptr, /*newlen=*/0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl data of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    // Iterate over messages (each message is a routing table entry).\n+    for (size_t msg_pos = 0; msg_pos < buf.size(); ) {\n+        Assume((msg_pos + sizeof(rt_msghdr)) <= buf.size());\n+        const struct rt_msghdr* rt = (const struct rt_msghdr*)(buf.data() + msg_pos);\n+        const size_t next_msg_pos = msg_pos + rt->rtm_msglen;\n+        Assume(rt->rtm_msglen >= sizeof(rt_msghdr) && next_msg_pos <= buf.size());\n+        // Iterate over addresses within message, get destination and gateway (if present).\n+        // Address data starts after header.\n+        size_t sa_pos = msg_pos + sizeof(struct rt_msghdr);\n+        std::optional<CNetAddr> dst, gateway;\n+        for (int i = 0; i < RTAX_MAX; i++) {\n+            if (rt->rtm_addrs & (1 << i)) {\n+                // 2 is just sa_len + sa_family, the theoretical minimum size of a socket address.\n+                Assume((sa_pos + 2) <= next_msg_pos);\n+                const struct sockaddr* sa = (const struct sockaddr*)(buf.data() + sa_pos);\n+                Assume(sa->sa_len >= 2 && (sa_pos + sa->sa_len) <= next_msg_pos);\n+                if (i == RTAX_DST) {\n+                    dst = FromSockAddr(sa);\n+                } else if (i == RTAX_GATEWAY) {\n+                    gateway = FromSockAddr(sa);\n+                }\n+                // Skip to next address.\n+                sa_pos += sa->sa_len;\n+            }\n+        }\n+        // Found default gateway?\n+        if (dst && gateway && dst->IsBindAny()) { // Route to 0.0.0.0 or :: ?\n+            return *gateway;\n+        }\n+        // Skip to next message.\n+        msg_pos = next_msg_pos;\n+    }\n+    return std::nullopt;\n+}\n+\n+#else\n+\n+// Dummy implementation.\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    (void)family;\n+    return std::nullopt;\n+}\n+\n+#endif\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+\n+    sa_family_t family;\n+    if (network == NET_IPV4) {\n+        family = AF_INET;\n+    } else if(network == NET_IPV6) {\n+        family = AF_INET6;\n+    } else {\n+        return std::nullopt;\n+    }\n+\n+    std::optional<CNetAddr> ret = QueryDefaultGatewayImpl(family);\n+\n+    // It's possible for the default gateway to be 0.0.0.0 or ::0 on at least Windows\n+    // for some routing strategies. If so, return as if no default gateway was found.\n+    if (ret && !ret->IsBindAny()) {\n+        return ret;\n+    } else {\n+        return std::nullopt;\n+    }\n+}\n+\n+std::vector<CNetAddr> GetLocalAddresses()\n+{\n+    std::vector<CNetAddr> addresses;\n+#ifdef WIN32\n+    char pszHostName[256] = \"\";\n+    if (gethostname(pszHostName, sizeof(pszHostName)) != SOCKET_ERROR)\n+    {",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 277,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "faacd264417bd7f3f08c5ff497458030b3a54fbc",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "style: `{` should be on the same line as `if` or `for` (also in a few places below).",
      "created_at": "2024-06-21T16:15:34Z",
      "updated_at": "2024-06-21T16:39:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1649171297",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1649171297"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": 276,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 277,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1651314694",
      "pull_request_review_id": 2136271379,
      "id": 1651314694,
      "node_id": "PRRC_kwDOABII585ibRAG",
      "diff_hunk": "@@ -0,0 +1,305 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#ifdef __FreeBSD__\n+#include <osreldate.h>\n+#endif\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || __FreeBSD_version >= 1400000\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+// Workaround https://github.com/freebsd/freebsd-src/pull/1070.\n+#define typeof __typeof\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 39,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "faacd264417bd7f3f08c5ff497458030b3a54fbc",
      "in_reply_to_id": 1649094052,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "sure, though i don't intend to add mocking for netlink sockets (that's just too OS specific), but for the UDP socket creation it'd be useful",
      "created_at": "2024-06-24T16:27:20Z",
      "updated_at": "2024-06-24T16:27:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1651314694",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1651314694"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": 33,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 39,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1651381337",
      "pull_request_review_id": 2136380323,
      "id": 1651381337,
      "node_id": "PRRC_kwDOABII585ibhRZ",
      "diff_hunk": "@@ -0,0 +1,520 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/pcp.h>\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <random.h>\n+#include <span.h>\n+#include <util/check.h>\n+#include <util/netif.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+// RFC6886 NAT-PMP and RFC6887 Port Control Protocol (PCP) implementation.\n+// NAT-PMP and PCP use network byte order (big-endian).\n+\n+// NAT-PMP (v0) protocol constants.\n+//! NAT-PMP uses a fixed server port number (RFC6887 section 1.1).\n+constexpr uint16_t NATPMP_SERVER_PORT = 5351;\n+//! Version byte for NATPMP (RFC6886 1.1)\n+constexpr uint8_t NATPMP_VERSION = 0;\n+//! Request opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_REQUEST = 0x00;\n+//! Response opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_RESPONSE = 0x80;\n+//! Get external address (RFC6886 3.2)\n+constexpr uint8_t NATPMP_OP_GETEXTERNAL = 0x00;\n+//! Map TCP port (RFC6886 3.3)\n+constexpr uint8_t NATPMP_OP_MAP_TCP = 0x02;\n+//! Shared request header size in bytes.\n+constexpr size_t NATPMP_REQUEST_HDR_SIZE = 2;\n+//! Shared response header (minimum) size in bytes.\n+constexpr size_t NATPMP_RESPONSE_HDR_SIZE = 8;\n+//! GETEXTERNAL request size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 0;\n+//! GETEXTERNAL response size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 4;\n+//! MAP request size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 10;\n+//! MAP response size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 8;\n+\n+// Shared header offsets (RFC6886 3.2, 3.3), relative to start of packet.\n+//!  Offset of version field in packets.\n+constexpr size_t NATPMP_HDR_VERSION_OFS = 0;\n+//!  Offset of opcode field in packets\n+constexpr size_t NATPMP_HDR_OP_OFS = 1;\n+//!  Offset of result code in packets. Result codes are 16 bit in NAT-PMP instead of 8 bit in PCP.\n+constexpr size_t NATPMP_RESPONSE_HDR_RESULT_OFS = 2;\n+\n+// GETEXTERNAL response offsets (RFC6886 3.2), relative to start of packet.\n+//!  Returned external address\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_IP_OFS = 8;\n+\n+// MAP request offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port to be mapped.\n+constexpr size_t NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS = 4;\n+//!  Suggested external port for mapping.\n+constexpr size_t NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS = 6;\n+//!  Requested port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_REQUEST_LIFETIME_OFS = 8;\n+\n+// MAP response offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port for mapping (will match internal port of request).\n+constexpr size_t NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS = 8;\n+//!  External port for mapping.\n+constexpr size_t NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS = 10;\n+//!  Created port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_RESPONSE_LIFETIME_OFS = 12;\n+\n+// Relevant NETPMP result codes (RFC6886 3.5).\n+//! Result code representing success status.\n+constexpr uint8_t NATPMP_RESULT_SUCCESS = 0;\n+//! Result code representing unsupported version.\n+constexpr uint8_t NATPMP_RESULT_UNSUPP_VERSION = 1;\n+//! Result code representing lack of resources.\n+constexpr uint8_t NATPMP_RESULT_NO_RESOURCES = 4;\n+\n+//! Mapping of NATPMP result code to string (RFC6886 3.5). Result codes <=2 match PCP.\n+static const std::map<uint8_t, std::string> NATPMP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"NETWORK_FAILURE\"},\n+    {4,  \"NO_RESOURCES\"},\n+    {5,  \"UNSUPP_OPCODE\"},\n+};\n+\n+// PCP (v2) protocol constants.\n+//! Maximum packet size in bytes (RFC6887 section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (RFC6887 section 19.1). Shared with NAT-PMP.\n+constexpr uint16_t PCP_SERVER_PORT = NATPMP_SERVER_PORT;\n+//! Version byte. 0 is NAT-PMP (RFC6886), 1 is forbidden, 2 for PCP (RFC6887).\n+constexpr uint8_t PCP_VERSION = 2;\n+//! PCP Request Header. See RFC6887 section 7.1. Shared with NAT-PMP.\n+constexpr uint8_t PCP_REQUEST = NATPMP_REQUEST; // R = 0\n+//! PCP Response Header. See RFC6887 section 7.2. Shared with NAT-PMP.\n+constexpr uint8_t PCP_RESPONSE = NATPMP_RESPONSE; // R = 1\n+//! Map opcode. See RFC6887 section 19.2\n+constexpr uint8_t PCP_OP_MAP = 0x01;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Request and response header size in bytes (RFC6887 section 7.1).\n+constexpr size_t PCP_HDR_SIZE = 24;\n+//! Map request and response size in bytes (RFC6887 section 11.1).\n+constexpr size_t PCP_MAP_SIZE = 36;\n+\n+// Header offsets shared between request and responses (RFC6887 7.1, 7.2), relative to start of packet.\n+//!  Version field (1 byte).\n+constexpr size_t PCP_HDR_VERSION_OFS = NATPMP_HDR_VERSION_OFS;\n+//!  Opcode field (1 byte).\n+constexpr size_t PCP_HDR_OP_OFS = NATPMP_HDR_OP_OFS;\n+//!  Requested lifetime (request), granted lifetime (response) (2 bytes).\n+constexpr size_t PCP_HDR_LIFETIME_OFS = 4;\n+\n+// Request header offsets (RFC6887 7.1), relative to start of packet.\n+//!  PCP client's IP address (16 bytes).\n+constexpr size_t PCP_REQUEST_HDR_IP_OFS = 8;\n+\n+// Response header offsets (RFC6887 7.2), relative to start of packet.\n+//!  Result code (1 byte).\n+constexpr size_t PCP_RESPONSE_HDR_RESULT_OFS = 3;\n+\n+// MAP request/response offsets (RFC6887 11.1), relative to start of opcode-specific data.\n+//!  Mapping nonce (12 bytes).\n+constexpr size_t PCP_MAP_NONCE_OFS = 0;\n+//!  Protocol (1 byte).\n+constexpr size_t PCP_MAP_PROTOCOL_OFS = 12;\n+//!  Internal port for mapping (2 bytes).\n+constexpr size_t PCP_MAP_INTERNAL_PORT_OFS = 16;\n+//!  Suggested external port (request), assigned external port (response) (2 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_PORT_OFS = 18;\n+//!  Suggested external IP (request), assigned external IP (response) (16 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_IP_OFS = 20;\n+\n+//! Result code representing success (RFC6887 7.4), shared with NAT-PMP.\n+constexpr uint8_t PCP_RESULT_SUCCESS = NATPMP_RESULT_SUCCESS;\n+//! Result code representing lack of resources (RFC6887 7.4).\n+constexpr uint8_t PCP_RESULT_NO_RESOURCES = 8;\n+\n+//! Mapping of PCP result code to string (RFC6887 7.4). Result codes <=2 match NAT-PMP.\n+static const std::map<uint8_t, std::string> PCP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"MALFORMED_REQUEST\"},\n+    {4,  \"UNSUPP_OPCODE\"},\n+    {5,  \"UNSUPP_OPTION\"},\n+    {6,  \"MALFORMED_OPTION\"},\n+    {7,  \"NETWORK_FAILURE\"},\n+    {8,  \"NO_RESOURCES\"},\n+    {9,  \"UNSUPP_PROTOCOL\"},\n+    {10, \"USER_EX_QUOTA\"},\n+    {11, \"CANNOT_PROVIDE_EXTERNAL\"},\n+    {12, \"ADDRESS_MISMATCH\"},\n+    {13, \"EXCESSIVE_REMOTE_PEER\"},\n+};\n+\n+//! Return human-readable string from NATPMP result code.\n+static std::string NATPMPResultString(uint8_t result_code)\n+{\n+    auto result_i = NATPMP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == NATPMP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Return human-readable string from PCP result code.\n+static std::string PCPResultString(uint8_t result_code)\n+{\n+    auto result_i = PCP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == PCP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Wrap address in IPv6 according to RFC6887. wrapped_addr needs to be able to store 16 bytes.\n+[[nodiscard]] static bool PCPWrapAddress(Span<uint8_t> wrapped_addr, const CNetAddr &addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (addr.IsIPv4()) {\n+        struct in_addr addr4;\n+        if (!addr.GetInAddr(&addr4)) return false;\n+        // Section 5: \"When the address field holds an IPv4 address, an IPv4-mapped IPv6 address [RFC4291] is used (::ffff:0:0/96).\"\n+        std::memcpy(wrapped_addr.data(), IPV4_IN_IPV6_PREFIX.data(), IPV4_IN_IPV6_PREFIX.size());\n+        std::memcpy(wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), &addr4, ADDR_IPV4_SIZE);\n+        return true;\n+    } else if (addr.IsIPv6()) {\n+        struct in6_addr addr6;\n+        if (!addr.GetIn6Addr(&addr6)) return false;\n+        std::memcpy(wrapped_addr.data(), &addr6, ADDR_IPV6_SIZE);\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+//! Unwrap PCP-encoded address according to RFC6887.\n+static CNetAddr PCPUnwrapAddress(Span<const uint8_t> wrapped_addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (util::HasPrefix(wrapped_addr, IPV4_IN_IPV6_PREFIX)) {\n+        struct in_addr addr4;\n+        std::memcpy(&addr4, wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), ADDR_IPV4_SIZE);\n+        return CNetAddr(addr4);\n+    } else {\n+        struct in6_addr addr6;\n+        std::memcpy(&addr6, wrapped_addr.data(), ADDR_IPV6_SIZE);\n+        return CNetAddr(addr6);\n+    }\n+}\n+\n+//! PCP or NAT-PMP send-receive loop.\n+static std::optional<std::vector<uint8_t>> PCPSendRecv(Sock &sock, const std::string &protocol, Span<const uint8_t> request, int num_tries,\n+        std::chrono::milliseconds timeout_per_try,\n+        std::function<bool(const Span<const uint8_t>)> check_packet)\n+{\n+    // UDP is a potentially lossy protocol, so we try to send again a few times.\n+    uint8_t response[PCP_MAX_SIZE];\n+    bool got_response = false;\n+    int recvsz = 0;\n+    for (int ntry = 0; !got_response && ntry < num_tries; ++ntry) {\n+        if (ntry > 0) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Retrying (%d)\\n\", protocol, ntry);\n+        }\n+        // Dispatch packet to gateway.\n+        if (sock.Send(request.data(), request.size(), 0) != static_cast<ssize_t>(request.size())) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not send request: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+            return std::nullopt; // Network-level error, probably no use retrying.\n+        }\n+\n+        // Wait for response(s) until we get a valid response, a network error, or time out.\n+        auto cur_time = std::chrono::time_point_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now());\n+        auto deadline = cur_time + timeout_per_try;\n+        while ((cur_time = std::chrono::time_point_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now())) < deadline) {\n+            Sock::Event occurred = 0;\n+            if (!sock.Wait(deadline - cur_time, Sock::RECV, &occurred)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not wait on socket: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            if (!occurred) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Timeout\\n\", protocol);\n+                break; // Retry.\n+            }\n+\n+            // Receive response.\n+            recvsz = sock.Recv(response, sizeof(response), MSG_DONTWAIT);\n+            if (recvsz < 0) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not receive response: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Received response of %d bytes: %s\\n\", protocol, recvsz, HexStr(Span(response, recvsz)));\n+\n+            if (check_packet(Span<uint8_t>(response, recvsz))) {",
      "path": "src/util/pcp.cpp",
      "position": 259,
      "original_position": 255,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "44316c39006a4ea906e9ae41a3fdbdf28f318ce5",
      "in_reply_to_id": 1644928807,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Unfortunately, that gives a new warning, because the `int` isn't the exact type:\r\n```\r\n../../src/util/pcp.cpp:258:41: warning: narrowing conversion of ‘recvsz’ from ‘int’ to ‘std::size_t’ {aka ‘long unsigned int’} [-Wnarrowing]\r\n  258 |             if (check_packet({response, recvsz})) {\r\n```\r\nCould add a `static_cast` but i don't think it's much of an improvement in that case?",
      "created_at": "2024-06-24T17:26:39Z",
      "updated_at": "2024-06-24T17:26:39Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1651381337",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1651381337"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 259,
      "original_line": 259,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1651401511",
      "pull_request_review_id": 2136416298,
      "id": 1651401511,
      "node_id": "PRRC_kwDOABII585ibmMn",
      "diff_hunk": "@@ -0,0 +1,305 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#ifdef __FreeBSD__\n+#include <osreldate.h>\n+#endif\n+\n+// Linux and FreeBSD 13.2+\n+#if defined(__linux__) || __FreeBSD_version >= 1400000\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+// Workaround https://github.com/freebsd/freebsd-src/pull/1070.\n+#define typeof __typeof\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+\n+static std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    const int s{socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (s < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+    Sock sock{static_cast<SOCKET>(s)};\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.attr_dst_data.\n+    const size_t dst_data_len = family == AF_INET ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    // Linux IPv4 / IPv6 - this must be present, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = family;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    // Linux IPv4 / IPv6 this must be absent, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock.Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    int64_t recv_result;\n+    do {\n+        recv_result = sock.Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, recv_result); hdr = NLMSG_NEXT(hdr, recv_result)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF) {\n+                Assume(sizeof(int) == RTA_PAYLOAD(attr));\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (family == AF_INET) {\n+                Assume(sizeof(in_addr) == RTA_PAYLOAD(rta_gateway));\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 110,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "faacd264417bd7f3f08c5ff497458030b3a54fbc",
      "in_reply_to_id": 1649113447,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "It's an OS API, it's very unlikely to fail (or at least, in a way that returns corrupted data), so i don't want to add a specific log message for it. i'm fine with it just returning nullptr.\r\nWill just merge these checks into the `if()` above them.",
      "created_at": "2024-06-24T17:43:41Z",
      "updated_at": "2024-06-24T17:48:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1651401511",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1651401511"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": 108,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 115,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1651420690",
      "pull_request_review_id": 2136445447,
      "id": 1651420690,
      "node_id": "PRRC_kwDOABII585ibq4S",
      "diff_hunk": "@@ -0,0 +1,520 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/pcp.h>\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <random.h>\n+#include <span.h>\n+#include <util/check.h>\n+#include <util/netif.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+// RFC6886 NAT-PMP and RFC6887 Port Control Protocol (PCP) implementation.\n+// NAT-PMP and PCP use network byte order (big-endian).\n+\n+// NAT-PMP (v0) protocol constants.\n+//! NAT-PMP uses a fixed server port number (RFC6887 section 1.1).\n+constexpr uint16_t NATPMP_SERVER_PORT = 5351;\n+//! Version byte for NATPMP (RFC6886 1.1)\n+constexpr uint8_t NATPMP_VERSION = 0;\n+//! Request opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_REQUEST = 0x00;\n+//! Response opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_RESPONSE = 0x80;\n+//! Get external address (RFC6886 3.2)\n+constexpr uint8_t NATPMP_OP_GETEXTERNAL = 0x00;\n+//! Map TCP port (RFC6886 3.3)\n+constexpr uint8_t NATPMP_OP_MAP_TCP = 0x02;\n+//! Shared request header size in bytes.\n+constexpr size_t NATPMP_REQUEST_HDR_SIZE = 2;\n+//! Shared response header (minimum) size in bytes.\n+constexpr size_t NATPMP_RESPONSE_HDR_SIZE = 8;\n+//! GETEXTERNAL request size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 0;\n+//! GETEXTERNAL response size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 4;\n+//! MAP request size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 10;\n+//! MAP response size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 8;\n+\n+// Shared header offsets (RFC6886 3.2, 3.3), relative to start of packet.\n+//!  Offset of version field in packets.\n+constexpr size_t NATPMP_HDR_VERSION_OFS = 0;\n+//!  Offset of opcode field in packets\n+constexpr size_t NATPMP_HDR_OP_OFS = 1;\n+//!  Offset of result code in packets. Result codes are 16 bit in NAT-PMP instead of 8 bit in PCP.\n+constexpr size_t NATPMP_RESPONSE_HDR_RESULT_OFS = 2;\n+\n+// GETEXTERNAL response offsets (RFC6886 3.2), relative to start of packet.\n+//!  Returned external address\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_IP_OFS = 8;\n+\n+// MAP request offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port to be mapped.\n+constexpr size_t NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS = 4;\n+//!  Suggested external port for mapping.\n+constexpr size_t NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS = 6;\n+//!  Requested port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_REQUEST_LIFETIME_OFS = 8;\n+\n+// MAP response offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port for mapping (will match internal port of request).\n+constexpr size_t NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS = 8;\n+//!  External port for mapping.\n+constexpr size_t NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS = 10;\n+//!  Created port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_RESPONSE_LIFETIME_OFS = 12;\n+\n+// Relevant NETPMP result codes (RFC6886 3.5).\n+//! Result code representing success status.\n+constexpr uint8_t NATPMP_RESULT_SUCCESS = 0;\n+//! Result code representing unsupported version.\n+constexpr uint8_t NATPMP_RESULT_UNSUPP_VERSION = 1;\n+//! Result code representing lack of resources.\n+constexpr uint8_t NATPMP_RESULT_NO_RESOURCES = 4;\n+\n+//! Mapping of NATPMP result code to string (RFC6886 3.5). Result codes <=2 match PCP.\n+static const std::map<uint8_t, std::string> NATPMP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"NETWORK_FAILURE\"},\n+    {4,  \"NO_RESOURCES\"},\n+    {5,  \"UNSUPP_OPCODE\"},\n+};\n+\n+// PCP (v2) protocol constants.\n+//! Maximum packet size in bytes (RFC6887 section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (RFC6887 section 19.1). Shared with NAT-PMP.\n+constexpr uint16_t PCP_SERVER_PORT = NATPMP_SERVER_PORT;\n+//! Version byte. 0 is NAT-PMP (RFC6886), 1 is forbidden, 2 for PCP (RFC6887).\n+constexpr uint8_t PCP_VERSION = 2;\n+//! PCP Request Header. See RFC6887 section 7.1. Shared with NAT-PMP.\n+constexpr uint8_t PCP_REQUEST = NATPMP_REQUEST; // R = 0\n+//! PCP Response Header. See RFC6887 section 7.2. Shared with NAT-PMP.\n+constexpr uint8_t PCP_RESPONSE = NATPMP_RESPONSE; // R = 1\n+//! Map opcode. See RFC6887 section 19.2\n+constexpr uint8_t PCP_OP_MAP = 0x01;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Request and response header size in bytes (RFC6887 section 7.1).\n+constexpr size_t PCP_HDR_SIZE = 24;\n+//! Map request and response size in bytes (RFC6887 section 11.1).\n+constexpr size_t PCP_MAP_SIZE = 36;\n+\n+// Header offsets shared between request and responses (RFC6887 7.1, 7.2), relative to start of packet.\n+//!  Version field (1 byte).\n+constexpr size_t PCP_HDR_VERSION_OFS = NATPMP_HDR_VERSION_OFS;\n+//!  Opcode field (1 byte).\n+constexpr size_t PCP_HDR_OP_OFS = NATPMP_HDR_OP_OFS;\n+//!  Requested lifetime (request), granted lifetime (response) (2 bytes).\n+constexpr size_t PCP_HDR_LIFETIME_OFS = 4;\n+\n+// Request header offsets (RFC6887 7.1), relative to start of packet.\n+//!  PCP client's IP address (16 bytes).\n+constexpr size_t PCP_REQUEST_HDR_IP_OFS = 8;\n+\n+// Response header offsets (RFC6887 7.2), relative to start of packet.\n+//!  Result code (1 byte).\n+constexpr size_t PCP_RESPONSE_HDR_RESULT_OFS = 3;\n+\n+// MAP request/response offsets (RFC6887 11.1), relative to start of opcode-specific data.\n+//!  Mapping nonce (12 bytes).\n+constexpr size_t PCP_MAP_NONCE_OFS = 0;\n+//!  Protocol (1 byte).\n+constexpr size_t PCP_MAP_PROTOCOL_OFS = 12;\n+//!  Internal port for mapping (2 bytes).\n+constexpr size_t PCP_MAP_INTERNAL_PORT_OFS = 16;\n+//!  Suggested external port (request), assigned external port (response) (2 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_PORT_OFS = 18;\n+//!  Suggested external IP (request), assigned external IP (response) (16 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_IP_OFS = 20;\n+\n+//! Result code representing success (RFC6887 7.4), shared with NAT-PMP.\n+constexpr uint8_t PCP_RESULT_SUCCESS = NATPMP_RESULT_SUCCESS;\n+//! Result code representing lack of resources (RFC6887 7.4).\n+constexpr uint8_t PCP_RESULT_NO_RESOURCES = 8;\n+\n+//! Mapping of PCP result code to string (RFC6887 7.4). Result codes <=2 match NAT-PMP.\n+static const std::map<uint8_t, std::string> PCP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"MALFORMED_REQUEST\"},\n+    {4,  \"UNSUPP_OPCODE\"},\n+    {5,  \"UNSUPP_OPTION\"},\n+    {6,  \"MALFORMED_OPTION\"},\n+    {7,  \"NETWORK_FAILURE\"},\n+    {8,  \"NO_RESOURCES\"},\n+    {9,  \"UNSUPP_PROTOCOL\"},\n+    {10, \"USER_EX_QUOTA\"},\n+    {11, \"CANNOT_PROVIDE_EXTERNAL\"},\n+    {12, \"ADDRESS_MISMATCH\"},\n+    {13, \"EXCESSIVE_REMOTE_PEER\"},\n+};\n+\n+//! Return human-readable string from NATPMP result code.\n+static std::string NATPMPResultString(uint8_t result_code)\n+{\n+    auto result_i = NATPMP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == NATPMP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Return human-readable string from PCP result code.\n+static std::string PCPResultString(uint8_t result_code)\n+{\n+    auto result_i = PCP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == PCP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Wrap address in IPv6 according to RFC6887. wrapped_addr needs to be able to store 16 bytes.\n+[[nodiscard]] static bool PCPWrapAddress(Span<uint8_t> wrapped_addr, const CNetAddr &addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (addr.IsIPv4()) {\n+        struct in_addr addr4;\n+        if (!addr.GetInAddr(&addr4)) return false;\n+        // Section 5: \"When the address field holds an IPv4 address, an IPv4-mapped IPv6 address [RFC4291] is used (::ffff:0:0/96).\"\n+        std::memcpy(wrapped_addr.data(), IPV4_IN_IPV6_PREFIX.data(), IPV4_IN_IPV6_PREFIX.size());\n+        std::memcpy(wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), &addr4, ADDR_IPV4_SIZE);\n+        return true;\n+    } else if (addr.IsIPv6()) {\n+        struct in6_addr addr6;\n+        if (!addr.GetIn6Addr(&addr6)) return false;\n+        std::memcpy(wrapped_addr.data(), &addr6, ADDR_IPV6_SIZE);\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+//! Unwrap PCP-encoded address according to RFC6887.\n+static CNetAddr PCPUnwrapAddress(Span<const uint8_t> wrapped_addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (util::HasPrefix(wrapped_addr, IPV4_IN_IPV6_PREFIX)) {\n+        struct in_addr addr4;\n+        std::memcpy(&addr4, wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), ADDR_IPV4_SIZE);\n+        return CNetAddr(addr4);\n+    } else {\n+        struct in6_addr addr6;\n+        std::memcpy(&addr6, wrapped_addr.data(), ADDR_IPV6_SIZE);\n+        return CNetAddr(addr6);\n+    }\n+}\n+\n+//! PCP or NAT-PMP send-receive loop.\n+static std::optional<std::vector<uint8_t>> PCPSendRecv(Sock &sock, const std::string &protocol, Span<const uint8_t> request, int num_tries,\n+        std::chrono::milliseconds timeout_per_try,\n+        std::function<bool(const Span<const uint8_t>)> check_packet)\n+{\n+    // UDP is a potentially lossy protocol, so we try to send again a few times.\n+    uint8_t response[PCP_MAX_SIZE];\n+    bool got_response = false;\n+    int recvsz = 0;\n+    for (int ntry = 0; !got_response && ntry < num_tries; ++ntry) {\n+        if (ntry > 0) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Retrying (%d)\\n\", protocol, ntry);\n+        }\n+        // Dispatch packet to gateway.\n+        if (sock.Send(request.data(), request.size(), 0) != static_cast<ssize_t>(request.size())) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not send request: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+            return std::nullopt; // Network-level error, probably no use retrying.\n+        }\n+\n+        // Wait for response(s) until we get a valid response, a network error, or time out.\n+        auto cur_time = std::chrono::time_point_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now());\n+        auto deadline = cur_time + timeout_per_try;\n+        while ((cur_time = std::chrono::time_point_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now())) < deadline) {\n+            Sock::Event occurred = 0;\n+            if (!sock.Wait(deadline - cur_time, Sock::RECV, &occurred)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not wait on socket: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            if (!occurred) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Timeout\\n\", protocol);\n+                break; // Retry.\n+            }\n+\n+            // Receive response.\n+            recvsz = sock.Recv(response, sizeof(response), MSG_DONTWAIT);\n+            if (recvsz < 0) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not receive response: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Received response of %d bytes: %s\\n\", protocol, recvsz, HexStr(Span(response, recvsz)));\n+\n+            if (check_packet(Span<uint8_t>(response, recvsz))) {",
      "path": "src/util/pcp.cpp",
      "position": 259,
      "original_position": 255,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "44316c39006a4ea906e9ae41a3fdbdf28f318ce5",
      "in_reply_to_id": 1644928807,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In that case you could use `check_packet(Span(response, recvsz))` (the `<uint8_t>` can be automatically deducted).",
      "created_at": "2024-06-24T17:59:49Z",
      "updated_at": "2024-06-24T17:59:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1651420690",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1651420690"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 259,
      "original_line": 259,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1654827053",
      "pull_request_review_id": 2141814858,
      "id": 1654827053,
      "node_id": "PRRC_kwDOABII585ioqgt",
      "diff_hunk": "@@ -0,0 +1,68 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_PCP_H\n+#define BITCOIN_UTIL_PCP_H\n+\n+#include <netaddress.h>\n+\n+#include <variant>\n+\n+// RFC6886 NAT-PMP and RFC6887 Port Control Protocol (PCP) implementation.\n+// NAT-PMP and PCP use network byte order (big-endian).\n+\n+//! Mapping nonce size in bytes (see RFC6887 section 11.1).\n+constexpr size_t PCP_MAP_NONCE_SIZE = 12;\n+\n+//! PCP mapping nonce. Arbitrary data chosen by the client to identify a mapping.\n+typedef std::array<uint8_t, PCP_MAP_NONCE_SIZE> PCPMappingNonce;\n+\n+//! Unsuccessful response to a port mapping.\n+enum class MappingError {\n+    NETWORK_ERROR,  ///< Any kind of network-level error.\n+    PROTOCOL_ERROR, ///< Any kind of protocol-level error, except unsupported version or no resources.\n+    UNSUPP_VERSION, ///< Unsupported protocol version.\n+    NO_RESOURCES,   ///< No resources available (port probably already mapped).\n+};\n+\n+//! Successful response to a port mapping.\n+struct MappingResult {\n+    MappingResult(uint8_t version, const CService &internal_in, const CService &external_in, uint32_t lifetime_in):\n+        version(version), internal(internal_in), external(external_in), lifetime(lifetime_in) {}\n+    //! Protocol version, one of NATPMP_VERSION or PCP_VERSION.\n+    uint8_t version;\n+    //! Internal host:port.\n+    CService internal;\n+    //! External host:port.\n+    CService external;\n+    //! Granted lifetime of binding (seconds).\n+    uint32_t lifetime;\n+\n+    //! Format mapping as string for logging.\n+    std::string ToString();\n+};\n+\n+//! Try to open a port using RFC 6886 NAT-PMP. IPv4 only.\n+//!\n+//! * gateway: Destination address for PCP requests (usually the default gateway).\n+//! * port: Internal port, and desired external port.\n+//! * lifetime: Requested lifetime in seconds for mapping. The server may assign as shorter or longer lifetime. A lifetime of 0 deletes the mapping.\n+//! * num_tries: Number of tries in case of no response.\n+//!\n+//! Returns the external_ip:external_port of the mapping if successful, otherwise a MappingError.",
      "path": "src/util/pcp.h",
      "position": 53,
      "original_position": 53,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "23916f2a7717b463799207b4b81b5795f2e9d7e3",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "style: make more doxygen friendly:\r\n\r\n```diff\r\n //! Try to open a port using RFC 6886 NAT-PMP. IPv4 only.\r\n //!\r\n-//! * gateway: Destination address for PCP requests (usually the default gateway).\r\n-//! * port: Internal port, and desired external port.\r\n-//! * lifetime: Requested lifetime in seconds for mapping. The server may assign as shorter or longer lifetime. A lifetime of 0 deletes the mapping.\r\n-//! * num_tries: Number of tries in case of no response.\r\n+//! @param[in] gateway Destination address for PCP requests (usually the default gateway).\r\n+//! @param[in] port Internal port, and desired external port.\r\n+//! @param[in] lifetime Requested lifetime in seconds for mapping. The server may assign as shorter or longer lifetime. A lifetime of 0 deletes the mapping.\r\n+//! @param[in] num_tries Number of tries in case of no response.\r\n //!\r\n-//! Returns the external_ip:external_port of the mapping if successful, otherwise a MappingError.\r\n+//! @return The external_ip:external_port of the mapping if successful, otherwise a MappingError.\r\n```\r\n\r\nbefore:\r\n\r\n![without_doxy](https://github.com/bitcoin/bitcoin/assets/266751/d16826b0-38cc-4f2c-912c-904ecb4606cb)\r\n\r\nafter:\r\n\r\n![with_doxy](https://github.com/bitcoin/bitcoin/assets/266751/1c1c36ce-849b-408f-a4db-91ea364cb120)\r\n",
      "created_at": "2024-06-26T13:20:08Z",
      "updated_at": "2024-06-28T15:24:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1654827053",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1654827053"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": 46,
      "original_start_line": 46,
      "start_side": "RIGHT",
      "line": 53,
      "original_line": 53,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1654859721",
      "pull_request_review_id": 2141814858,
      "id": 1654859721,
      "node_id": "PRRC_kwDOABII585ioyfJ",
      "diff_hunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/pcp.h>\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <span.h>\n+#include <util/check.h>\n+#include <util/netif.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+namespace {\n+\n+// RFC6886 NAT-PMP and RFC6887 Port Control Protocol (PCP) implementation.\n+// NAT-PMP and PCP use network byte order (big-endian).\n+\n+// NAT-PMP (v0) protocol constants.\n+//! NAT-PMP uses a fixed server port number (RFC6887 section 1.1).\n+constexpr uint16_t NATPMP_SERVER_PORT = 5351;",
      "path": "src/util/pcp.cpp",
      "position": 26,
      "original_position": 26,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "23916f2a7717b463799207b4b81b5795f2e9d7e3",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "\"RFC6887 section 1.1\" should be \"RFC6886 section 1.1\"?\r\n\r\nhttps://www.rfc-editor.org/rfc/rfc6886#section-1.1",
      "created_at": "2024-06-26T13:37:39Z",
      "updated_at": "2024-06-28T15:24:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1654859721",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1654859721"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": 25,
      "original_start_line": 25,
      "start_side": "RIGHT",
      "line": 26,
      "original_line": 26,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1655068312",
      "pull_request_review_id": 2141814858,
      "id": 1655068312,
      "node_id": "PRRC_kwDOABII585iplaY",
      "diff_hunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/pcp.h>\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <span.h>\n+#include <util/check.h>\n+#include <util/netif.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+namespace {\n+\n+// RFC6886 NAT-PMP and RFC6887 Port Control Protocol (PCP) implementation.\n+// NAT-PMP and PCP use network byte order (big-endian).\n+\n+// NAT-PMP (v0) protocol constants.\n+//! NAT-PMP uses a fixed server port number (RFC6887 section 1.1).\n+constexpr uint16_t NATPMP_SERVER_PORT = 5351;\n+//! Version byte for NATPMP (RFC6886 1.1)\n+constexpr uint8_t NATPMP_VERSION = 0;\n+//! Request opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_REQUEST = 0x00;\n+//! Response opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_RESPONSE = 0x80;\n+//! Get external address (RFC6886 3.2)\n+constexpr uint8_t NATPMP_OP_GETEXTERNAL = 0x00;\n+//! Map TCP port (RFC6886 3.3)\n+constexpr uint8_t NATPMP_OP_MAP_TCP = 0x02;\n+//! Shared request header size in bytes.\n+constexpr size_t NATPMP_REQUEST_HDR_SIZE = 2;\n+//! Shared response header (minimum) size in bytes.\n+constexpr size_t NATPMP_RESPONSE_HDR_SIZE = 8;\n+//! GETEXTERNAL request size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 0;\n+//! GETEXTERNAL response size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 4;\n+//! MAP request size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 10;\n+//! MAP response size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 8;\n+\n+// Shared header offsets (RFC6886 3.2, 3.3), relative to start of packet.\n+//!  Offset of version field in packets.\n+constexpr size_t NATPMP_HDR_VERSION_OFS = 0;\n+//!  Offset of opcode field in packets\n+constexpr size_t NATPMP_HDR_OP_OFS = 1;\n+//!  Offset of result code in packets. Result codes are 16 bit in NAT-PMP instead of 8 bit in PCP.\n+constexpr size_t NATPMP_RESPONSE_HDR_RESULT_OFS = 2;\n+\n+// GETEXTERNAL response offsets (RFC6886 3.2), relative to start of packet.\n+//!  Returned external address\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_IP_OFS = 8;\n+\n+// MAP request offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port to be mapped.\n+constexpr size_t NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS = 4;\n+//!  Suggested external port for mapping.\n+constexpr size_t NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS = 6;\n+//!  Requested port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_REQUEST_LIFETIME_OFS = 8;\n+\n+// MAP response offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port for mapping (will match internal port of request).\n+constexpr size_t NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS = 8;\n+//!  External port for mapping.\n+constexpr size_t NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS = 10;\n+//!  Created port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_RESPONSE_LIFETIME_OFS = 12;\n+\n+// Relevant NETPMP result codes (RFC6886 3.5).\n+//! Result code representing success status.\n+constexpr uint8_t NATPMP_RESULT_SUCCESS = 0;\n+//! Result code representing unsupported version.\n+constexpr uint8_t NATPMP_RESULT_UNSUPP_VERSION = 1;\n+//! Result code representing lack of resources.\n+constexpr uint8_t NATPMP_RESULT_NO_RESOURCES = 4;\n+\n+//! Mapping of NATPMP result code to string (RFC6886 3.5). Result codes <=2 match PCP.\n+const std::map<uint8_t, std::string> NATPMP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"NETWORK_FAILURE\"},\n+    {4,  \"NO_RESOURCES\"},\n+    {5,  \"UNSUPP_OPCODE\"},\n+};\n+\n+// PCP (v2) protocol constants.\n+//! Maximum packet size in bytes (RFC6887 section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (RFC6887 section 19.1). Shared with NAT-PMP.\n+constexpr uint16_t PCP_SERVER_PORT = NATPMP_SERVER_PORT;\n+//! Version byte. 0 is NAT-PMP (RFC6886), 1 is forbidden, 2 for PCP (RFC6887).\n+constexpr uint8_t PCP_VERSION = 2;\n+//! PCP Request Header. See RFC6887 section 7.1. Shared with NAT-PMP.\n+constexpr uint8_t PCP_REQUEST = NATPMP_REQUEST; // R = 0\n+//! PCP Response Header. See RFC6887 section 7.2. Shared with NAT-PMP.\n+constexpr uint8_t PCP_RESPONSE = NATPMP_RESPONSE; // R = 1\n+//! Map opcode. See RFC6887 section 19.2\n+constexpr uint8_t PCP_OP_MAP = 0x01;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Request and response header size in bytes (RFC6887 section 7.1).\n+constexpr size_t PCP_HDR_SIZE = 24;\n+//! Map request and response size in bytes (RFC6887 section 11.1).\n+constexpr size_t PCP_MAP_SIZE = 36;\n+\n+// Header offsets shared between request and responses (RFC6887 7.1, 7.2), relative to start of packet.\n+//!  Version field (1 byte).\n+constexpr size_t PCP_HDR_VERSION_OFS = NATPMP_HDR_VERSION_OFS;\n+//!  Opcode field (1 byte).\n+constexpr size_t PCP_HDR_OP_OFS = NATPMP_HDR_OP_OFS;\n+//!  Requested lifetime (request), granted lifetime (response) (2 bytes).\n+constexpr size_t PCP_HDR_LIFETIME_OFS = 4;\n+\n+// Request header offsets (RFC6887 7.1), relative to start of packet.\n+//!  PCP client's IP address (16 bytes).\n+constexpr size_t PCP_REQUEST_HDR_IP_OFS = 8;\n+\n+// Response header offsets (RFC6887 7.2), relative to start of packet.\n+//!  Result code (1 byte).\n+constexpr size_t PCP_RESPONSE_HDR_RESULT_OFS = 3;\n+\n+// MAP request/response offsets (RFC6887 11.1), relative to start of opcode-specific data.\n+//!  Mapping nonce (12 bytes).\n+constexpr size_t PCP_MAP_NONCE_OFS = 0;\n+//!  Protocol (1 byte).\n+constexpr size_t PCP_MAP_PROTOCOL_OFS = 12;\n+//!  Internal port for mapping (2 bytes).\n+constexpr size_t PCP_MAP_INTERNAL_PORT_OFS = 16;\n+//!  Suggested external port (request), assigned external port (response) (2 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_PORT_OFS = 18;\n+//!  Suggested external IP (request), assigned external IP (response) (16 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_IP_OFS = 20;\n+\n+//! Result code representing success (RFC6887 7.4), shared with NAT-PMP.\n+constexpr uint8_t PCP_RESULT_SUCCESS = NATPMP_RESULT_SUCCESS;\n+//! Result code representing lack of resources (RFC6887 7.4).\n+constexpr uint8_t PCP_RESULT_NO_RESOURCES = 8;\n+\n+//! Mapping of PCP result code to string (RFC6887 7.4). Result codes <=2 match NAT-PMP.\n+const std::map<uint8_t, std::string> PCP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"MALFORMED_REQUEST\"},\n+    {4,  \"UNSUPP_OPCODE\"},\n+    {5,  \"UNSUPP_OPTION\"},\n+    {6,  \"MALFORMED_OPTION\"},\n+    {7,  \"NETWORK_FAILURE\"},\n+    {8,  \"NO_RESOURCES\"},\n+    {9,  \"UNSUPP_PROTOCOL\"},\n+    {10, \"USER_EX_QUOTA\"},\n+    {11, \"CANNOT_PROVIDE_EXTERNAL\"},\n+    {12, \"ADDRESS_MISMATCH\"},\n+    {13, \"EXCESSIVE_REMOTE_PEER\"},\n+};\n+\n+//! Return human-readable string from NATPMP result code.\n+std::string NATPMPResultString(uint8_t result_code)\n+{\n+    auto result_i = NATPMP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == NATPMP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Return human-readable string from PCP result code.\n+std::string PCPResultString(uint8_t result_code)\n+{\n+    auto result_i = PCP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == PCP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Wrap address in IPv6 according to RFC6887. wrapped_addr needs to be able to store 16 bytes.\n+[[nodiscard]] bool PCPWrapAddress(Span<uint8_t> wrapped_addr, const CNetAddr &addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (addr.IsIPv4()) {\n+        struct in_addr addr4;\n+        if (!addr.GetInAddr(&addr4)) return false;\n+        // Section 5: \"When the address field holds an IPv4 address, an IPv4-mapped IPv6 address [RFC4291] is used (::ffff:0:0/96).\"\n+        std::memcpy(wrapped_addr.data(), IPV4_IN_IPV6_PREFIX.data(), IPV4_IN_IPV6_PREFIX.size());\n+        std::memcpy(wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), &addr4, ADDR_IPV4_SIZE);\n+        return true;\n+    } else if (addr.IsIPv6()) {\n+        struct in6_addr addr6;\n+        if (!addr.GetIn6Addr(&addr6)) return false;\n+        std::memcpy(wrapped_addr.data(), &addr6, ADDR_IPV6_SIZE);\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+//! Unwrap PCP-encoded address according to RFC6887.\n+CNetAddr PCPUnwrapAddress(Span<const uint8_t> wrapped_addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (util::HasPrefix(wrapped_addr, IPV4_IN_IPV6_PREFIX)) {\n+        struct in_addr addr4;\n+        std::memcpy(&addr4, wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), ADDR_IPV4_SIZE);\n+        return CNetAddr(addr4);\n+    } else {\n+        struct in6_addr addr6;\n+        std::memcpy(&addr6, wrapped_addr.data(), ADDR_IPV6_SIZE);\n+        return CNetAddr(addr6);\n+    }\n+}\n+\n+//! PCP or NAT-PMP send-receive loop.\n+std::optional<std::vector<uint8_t>> PCPSendRecv(Sock &sock, const std::string &protocol, Span<const uint8_t> request, int num_tries,\n+        std::chrono::milliseconds timeout_per_try,\n+        std::function<bool(Span<const uint8_t>)> check_packet)\n+{\n+    using namespace std::chrono;\n+    // UDP is a potentially lossy protocol, so we try to send again a few times.\n+    uint8_t response[PCP_MAX_SIZE];\n+    bool got_response = false;\n+    int recvsz = 0;\n+    for (int ntry = 0; !got_response && ntry < num_tries; ++ntry) {\n+        if (ntry > 0) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Retrying (%d)\\n\", protocol, ntry);",
      "path": "src/util/pcp.cpp",
      "position": 229,
      "original_position": 229,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "23916f2a7717b463799207b4b81b5795f2e9d7e3",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: maybe worth logging also `num_tries`, e.g. \"retrying 1/5\", \"retrying 2/5\", ...",
      "created_at": "2024-06-26T15:10:44Z",
      "updated_at": "2024-06-28T15:24:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1655068312",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1655068312"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 229,
      "original_line": 229,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1655069402",
      "pull_request_review_id": 2141814858,
      "id": 1655069402,
      "node_id": "PRRC_kwDOABII585iplra",
      "diff_hunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/pcp.h>\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <span.h>\n+#include <util/check.h>\n+#include <util/netif.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+namespace {\n+\n+// RFC6886 NAT-PMP and RFC6887 Port Control Protocol (PCP) implementation.\n+// NAT-PMP and PCP use network byte order (big-endian).\n+\n+// NAT-PMP (v0) protocol constants.\n+//! NAT-PMP uses a fixed server port number (RFC6887 section 1.1).\n+constexpr uint16_t NATPMP_SERVER_PORT = 5351;\n+//! Version byte for NATPMP (RFC6886 1.1)\n+constexpr uint8_t NATPMP_VERSION = 0;\n+//! Request opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_REQUEST = 0x00;\n+//! Response opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_RESPONSE = 0x80;\n+//! Get external address (RFC6886 3.2)\n+constexpr uint8_t NATPMP_OP_GETEXTERNAL = 0x00;\n+//! Map TCP port (RFC6886 3.3)\n+constexpr uint8_t NATPMP_OP_MAP_TCP = 0x02;\n+//! Shared request header size in bytes.\n+constexpr size_t NATPMP_REQUEST_HDR_SIZE = 2;\n+//! Shared response header (minimum) size in bytes.\n+constexpr size_t NATPMP_RESPONSE_HDR_SIZE = 8;\n+//! GETEXTERNAL request size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 0;\n+//! GETEXTERNAL response size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 4;\n+//! MAP request size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 10;\n+//! MAP response size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 8;\n+\n+// Shared header offsets (RFC6886 3.2, 3.3), relative to start of packet.\n+//!  Offset of version field in packets.\n+constexpr size_t NATPMP_HDR_VERSION_OFS = 0;\n+//!  Offset of opcode field in packets\n+constexpr size_t NATPMP_HDR_OP_OFS = 1;\n+//!  Offset of result code in packets. Result codes are 16 bit in NAT-PMP instead of 8 bit in PCP.\n+constexpr size_t NATPMP_RESPONSE_HDR_RESULT_OFS = 2;\n+\n+// GETEXTERNAL response offsets (RFC6886 3.2), relative to start of packet.\n+//!  Returned external address\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_IP_OFS = 8;\n+\n+// MAP request offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port to be mapped.\n+constexpr size_t NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS = 4;\n+//!  Suggested external port for mapping.\n+constexpr size_t NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS = 6;\n+//!  Requested port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_REQUEST_LIFETIME_OFS = 8;\n+\n+// MAP response offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port for mapping (will match internal port of request).\n+constexpr size_t NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS = 8;\n+//!  External port for mapping.\n+constexpr size_t NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS = 10;\n+//!  Created port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_RESPONSE_LIFETIME_OFS = 12;\n+\n+// Relevant NETPMP result codes (RFC6886 3.5).\n+//! Result code representing success status.\n+constexpr uint8_t NATPMP_RESULT_SUCCESS = 0;\n+//! Result code representing unsupported version.\n+constexpr uint8_t NATPMP_RESULT_UNSUPP_VERSION = 1;\n+//! Result code representing lack of resources.\n+constexpr uint8_t NATPMP_RESULT_NO_RESOURCES = 4;\n+\n+//! Mapping of NATPMP result code to string (RFC6886 3.5). Result codes <=2 match PCP.\n+const std::map<uint8_t, std::string> NATPMP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"NETWORK_FAILURE\"},\n+    {4,  \"NO_RESOURCES\"},\n+    {5,  \"UNSUPP_OPCODE\"},\n+};\n+\n+// PCP (v2) protocol constants.\n+//! Maximum packet size in bytes (RFC6887 section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (RFC6887 section 19.1). Shared with NAT-PMP.\n+constexpr uint16_t PCP_SERVER_PORT = NATPMP_SERVER_PORT;\n+//! Version byte. 0 is NAT-PMP (RFC6886), 1 is forbidden, 2 for PCP (RFC6887).\n+constexpr uint8_t PCP_VERSION = 2;\n+//! PCP Request Header. See RFC6887 section 7.1. Shared with NAT-PMP.\n+constexpr uint8_t PCP_REQUEST = NATPMP_REQUEST; // R = 0\n+//! PCP Response Header. See RFC6887 section 7.2. Shared with NAT-PMP.\n+constexpr uint8_t PCP_RESPONSE = NATPMP_RESPONSE; // R = 1\n+//! Map opcode. See RFC6887 section 19.2\n+constexpr uint8_t PCP_OP_MAP = 0x01;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Request and response header size in bytes (RFC6887 section 7.1).\n+constexpr size_t PCP_HDR_SIZE = 24;\n+//! Map request and response size in bytes (RFC6887 section 11.1).\n+constexpr size_t PCP_MAP_SIZE = 36;\n+\n+// Header offsets shared between request and responses (RFC6887 7.1, 7.2), relative to start of packet.\n+//!  Version field (1 byte).\n+constexpr size_t PCP_HDR_VERSION_OFS = NATPMP_HDR_VERSION_OFS;\n+//!  Opcode field (1 byte).\n+constexpr size_t PCP_HDR_OP_OFS = NATPMP_HDR_OP_OFS;\n+//!  Requested lifetime (request), granted lifetime (response) (2 bytes).\n+constexpr size_t PCP_HDR_LIFETIME_OFS = 4;\n+\n+// Request header offsets (RFC6887 7.1), relative to start of packet.\n+//!  PCP client's IP address (16 bytes).\n+constexpr size_t PCP_REQUEST_HDR_IP_OFS = 8;\n+\n+// Response header offsets (RFC6887 7.2), relative to start of packet.\n+//!  Result code (1 byte).\n+constexpr size_t PCP_RESPONSE_HDR_RESULT_OFS = 3;\n+\n+// MAP request/response offsets (RFC6887 11.1), relative to start of opcode-specific data.\n+//!  Mapping nonce (12 bytes).\n+constexpr size_t PCP_MAP_NONCE_OFS = 0;\n+//!  Protocol (1 byte).\n+constexpr size_t PCP_MAP_PROTOCOL_OFS = 12;\n+//!  Internal port for mapping (2 bytes).\n+constexpr size_t PCP_MAP_INTERNAL_PORT_OFS = 16;\n+//!  Suggested external port (request), assigned external port (response) (2 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_PORT_OFS = 18;\n+//!  Suggested external IP (request), assigned external IP (response) (16 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_IP_OFS = 20;\n+\n+//! Result code representing success (RFC6887 7.4), shared with NAT-PMP.\n+constexpr uint8_t PCP_RESULT_SUCCESS = NATPMP_RESULT_SUCCESS;\n+//! Result code representing lack of resources (RFC6887 7.4).\n+constexpr uint8_t PCP_RESULT_NO_RESOURCES = 8;\n+\n+//! Mapping of PCP result code to string (RFC6887 7.4). Result codes <=2 match NAT-PMP.\n+const std::map<uint8_t, std::string> PCP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"MALFORMED_REQUEST\"},\n+    {4,  \"UNSUPP_OPCODE\"},\n+    {5,  \"UNSUPP_OPTION\"},\n+    {6,  \"MALFORMED_OPTION\"},\n+    {7,  \"NETWORK_FAILURE\"},\n+    {8,  \"NO_RESOURCES\"},\n+    {9,  \"UNSUPP_PROTOCOL\"},\n+    {10, \"USER_EX_QUOTA\"},\n+    {11, \"CANNOT_PROVIDE_EXTERNAL\"},\n+    {12, \"ADDRESS_MISMATCH\"},\n+    {13, \"EXCESSIVE_REMOTE_PEER\"},\n+};\n+\n+//! Return human-readable string from NATPMP result code.\n+std::string NATPMPResultString(uint8_t result_code)\n+{\n+    auto result_i = NATPMP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == NATPMP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Return human-readable string from PCP result code.\n+std::string PCPResultString(uint8_t result_code)\n+{\n+    auto result_i = PCP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == PCP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Wrap address in IPv6 according to RFC6887. wrapped_addr needs to be able to store 16 bytes.\n+[[nodiscard]] bool PCPWrapAddress(Span<uint8_t> wrapped_addr, const CNetAddr &addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (addr.IsIPv4()) {\n+        struct in_addr addr4;\n+        if (!addr.GetInAddr(&addr4)) return false;\n+        // Section 5: \"When the address field holds an IPv4 address, an IPv4-mapped IPv6 address [RFC4291] is used (::ffff:0:0/96).\"\n+        std::memcpy(wrapped_addr.data(), IPV4_IN_IPV6_PREFIX.data(), IPV4_IN_IPV6_PREFIX.size());\n+        std::memcpy(wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), &addr4, ADDR_IPV4_SIZE);\n+        return true;\n+    } else if (addr.IsIPv6()) {\n+        struct in6_addr addr6;\n+        if (!addr.GetIn6Addr(&addr6)) return false;\n+        std::memcpy(wrapped_addr.data(), &addr6, ADDR_IPV6_SIZE);\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+//! Unwrap PCP-encoded address according to RFC6887.\n+CNetAddr PCPUnwrapAddress(Span<const uint8_t> wrapped_addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (util::HasPrefix(wrapped_addr, IPV4_IN_IPV6_PREFIX)) {\n+        struct in_addr addr4;\n+        std::memcpy(&addr4, wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), ADDR_IPV4_SIZE);\n+        return CNetAddr(addr4);\n+    } else {\n+        struct in6_addr addr6;\n+        std::memcpy(&addr6, wrapped_addr.data(), ADDR_IPV6_SIZE);\n+        return CNetAddr(addr6);\n+    }\n+}\n+\n+//! PCP or NAT-PMP send-receive loop.\n+std::optional<std::vector<uint8_t>> PCPSendRecv(Sock &sock, const std::string &protocol, Span<const uint8_t> request, int num_tries,\n+        std::chrono::milliseconds timeout_per_try,\n+        std::function<bool(Span<const uint8_t>)> check_packet)\n+{\n+    using namespace std::chrono;\n+    // UDP is a potentially lossy protocol, so we try to send again a few times.\n+    uint8_t response[PCP_MAX_SIZE];\n+    bool got_response = false;\n+    int recvsz = 0;\n+    for (int ntry = 0; !got_response && ntry < num_tries; ++ntry) {\n+        if (ntry > 0) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Retrying (%d)\\n\", protocol, ntry);\n+        }\n+        // Dispatch packet to gateway.\n+        if (sock.Send(request.data(), request.size(), 0) != static_cast<ssize_t>(request.size())) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not send request: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+            return std::nullopt; // Network-level error, probably no use retrying.\n+        }\n+\n+        // Wait for response(s) until we get a valid response, a network error, or time out.\n+        auto cur_time = time_point_cast<milliseconds>(steady_clock::now());\n+        auto deadline = cur_time + timeout_per_try;\n+        while ((cur_time = time_point_cast<milliseconds>(steady_clock::now())) < deadline) {\n+            Sock::Event occurred = 0;\n+            if (!sock.Wait(deadline - cur_time, Sock::RECV, &occurred)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not wait on socket: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            if (!occurred) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Timeout\\n\", protocol);",
      "path": "src/util/pcp.cpp",
      "position": 247,
      "original_position": 247,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "23916f2a7717b463799207b4b81b5795f2e9d7e3",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: maybe worth logging `ntry` and `num_tries`, e.g. \"timeout 1/5\", \"timeout 2/5\", ...",
      "created_at": "2024-06-26T15:11:32Z",
      "updated_at": "2024-06-28T15:24:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1655069402",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1655069402"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 247,
      "original_line": 247,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1655081131",
      "pull_request_review_id": 2142210219,
      "id": 1655081131,
      "node_id": "PRRC_kwDOABII585ipoir",
      "diff_hunk": "@@ -0,0 +1,68 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_PCP_H\n+#define BITCOIN_UTIL_PCP_H\n+\n+#include <netaddress.h>\n+\n+#include <variant>",
      "path": "src/util/pcp.h",
      "position": 10,
      "original_position": 10,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "bc41b2f8984241c6d7241401b26fab5e96b54932",
      "in_reply_to_id": null,
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Missing:\r\n```c++\r\n#include <cstdint>\r\n#include <chrono>\r\n#include <array>\r\n```\r\n\r\n(Noticed while trying to forward-declare `netaddress.h`, which didn't work because of the `CService`s stored in `MappingResult`)",
      "created_at": "2024-06-26T15:19:25Z",
      "updated_at": "2024-06-26T15:31:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1655081131",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1655081131"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 10,
      "original_line": 10,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1655098222",
      "pull_request_review_id": 2142210219,
      "id": 1655098222,
      "node_id": "PRRC_kwDOABII585ipstu",
      "diff_hunk": "@@ -0,0 +1,20 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_NETIF_H\n+#define BITCOIN_UTIL_NETIF_H\n+\n+#include <netaddress.h>",
      "path": "src/util/netif.h",
      "position": 8,
      "original_position": 8,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "9a067b5ac154154ec9008a0e8f2d8f03e994a589",
      "in_reply_to_id": null,
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "This header can be made dependency-free (while making `netaddress.h` a little more forward-declare-friendly) with:\r\n```diff\r\ndiff --git a/src/netaddress.h b/src/netaddress.h\r\nindex 52fecada1c9..75d172ab334 100644\r\n--- a/src/netaddress.h\r\n+++ b/src/netaddress.h\r\n@@ -31,3 +31,3 @@\r\n  */\r\n-enum Network {\r\n+enum Network : int {\r\n     /// Addresses from these networks are not publicly routable on the global Internet.\r\ndiff --git a/src/util/netif.cpp b/src/util/netif.cpp\r\nindex ad3f93b379a..c4d4c3a31c8 100644\r\n--- a/src/util/netif.cpp\r\n+++ b/src/util/netif.cpp\r\n@@ -9,2 +9,3 @@\r\n #include <logging.h>\r\n+#include <netaddress.h>\r\n #include <netbase.h>\r\ndiff --git a/src/util/netif.h b/src/util/netif.h\r\nindex 5ff473fd4f2..ab31115f0ff 100644\r\n--- a/src/util/netif.h\r\n+++ b/src/util/netif.h\r\n@@ -7,5 +7,7 @@\r\n\r\n-#include <netaddress.h>\r\n-\r\n #include <optional>\r\n+#include <vector>\r\n+\r\n+enum Network : int;\r\n+class CNetAddr;\r\n```\r\n\r\nI tested to see what would happen if the forward-declare went out of sync and was met with (as I'd hoped) an error:\r\n```\r\n./netaddress.h:32:6: error: enumeration redeclared with different underlying type 'int' (was 'short')\r\n   32 | enum Network : int {\r\n      |      ^\r\n./util/netif.h:11:6: note: previous declaration is here\r\n   11 | enum Network : short;\r\n```",
      "created_at": "2024-06-26T15:31:03Z",
      "updated_at": "2024-06-26T15:31:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1655098222",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1655098222"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 8,
      "original_line": 8,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1655104852",
      "pull_request_review_id": 2141814858,
      "id": 1655104852,
      "node_id": "PRRC_kwDOABII585ipuVU",
      "diff_hunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/pcp.h>\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <span.h>\n+#include <util/check.h>\n+#include <util/netif.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+namespace {\n+\n+// RFC6886 NAT-PMP and RFC6887 Port Control Protocol (PCP) implementation.\n+// NAT-PMP and PCP use network byte order (big-endian).\n+\n+// NAT-PMP (v0) protocol constants.\n+//! NAT-PMP uses a fixed server port number (RFC6887 section 1.1).\n+constexpr uint16_t NATPMP_SERVER_PORT = 5351;\n+//! Version byte for NATPMP (RFC6886 1.1)\n+constexpr uint8_t NATPMP_VERSION = 0;\n+//! Request opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_REQUEST = 0x00;\n+//! Response opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_RESPONSE = 0x80;\n+//! Get external address (RFC6886 3.2)\n+constexpr uint8_t NATPMP_OP_GETEXTERNAL = 0x00;\n+//! Map TCP port (RFC6886 3.3)\n+constexpr uint8_t NATPMP_OP_MAP_TCP = 0x02;\n+//! Shared request header size in bytes.\n+constexpr size_t NATPMP_REQUEST_HDR_SIZE = 2;\n+//! Shared response header (minimum) size in bytes.\n+constexpr size_t NATPMP_RESPONSE_HDR_SIZE = 8;\n+//! GETEXTERNAL request size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 0;\n+//! GETEXTERNAL response size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 4;\n+//! MAP request size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 10;\n+//! MAP response size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 8;\n+\n+// Shared header offsets (RFC6886 3.2, 3.3), relative to start of packet.\n+//!  Offset of version field in packets.\n+constexpr size_t NATPMP_HDR_VERSION_OFS = 0;\n+//!  Offset of opcode field in packets\n+constexpr size_t NATPMP_HDR_OP_OFS = 1;\n+//!  Offset of result code in packets. Result codes are 16 bit in NAT-PMP instead of 8 bit in PCP.\n+constexpr size_t NATPMP_RESPONSE_HDR_RESULT_OFS = 2;\n+\n+// GETEXTERNAL response offsets (RFC6886 3.2), relative to start of packet.\n+//!  Returned external address\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_IP_OFS = 8;\n+\n+// MAP request offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port to be mapped.\n+constexpr size_t NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS = 4;\n+//!  Suggested external port for mapping.\n+constexpr size_t NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS = 6;\n+//!  Requested port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_REQUEST_LIFETIME_OFS = 8;\n+\n+// MAP response offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port for mapping (will match internal port of request).\n+constexpr size_t NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS = 8;\n+//!  External port for mapping.\n+constexpr size_t NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS = 10;\n+//!  Created port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_RESPONSE_LIFETIME_OFS = 12;\n+\n+// Relevant NETPMP result codes (RFC6886 3.5).\n+//! Result code representing success status.\n+constexpr uint8_t NATPMP_RESULT_SUCCESS = 0;\n+//! Result code representing unsupported version.\n+constexpr uint8_t NATPMP_RESULT_UNSUPP_VERSION = 1;\n+//! Result code representing lack of resources.\n+constexpr uint8_t NATPMP_RESULT_NO_RESOURCES = 4;\n+\n+//! Mapping of NATPMP result code to string (RFC6886 3.5). Result codes <=2 match PCP.\n+const std::map<uint8_t, std::string> NATPMP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"NETWORK_FAILURE\"},\n+    {4,  \"NO_RESOURCES\"},\n+    {5,  \"UNSUPP_OPCODE\"},\n+};\n+\n+// PCP (v2) protocol constants.\n+//! Maximum packet size in bytes (RFC6887 section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (RFC6887 section 19.1). Shared with NAT-PMP.\n+constexpr uint16_t PCP_SERVER_PORT = NATPMP_SERVER_PORT;\n+//! Version byte. 0 is NAT-PMP (RFC6886), 1 is forbidden, 2 for PCP (RFC6887).\n+constexpr uint8_t PCP_VERSION = 2;\n+//! PCP Request Header. See RFC6887 section 7.1. Shared with NAT-PMP.\n+constexpr uint8_t PCP_REQUEST = NATPMP_REQUEST; // R = 0\n+//! PCP Response Header. See RFC6887 section 7.2. Shared with NAT-PMP.\n+constexpr uint8_t PCP_RESPONSE = NATPMP_RESPONSE; // R = 1\n+//! Map opcode. See RFC6887 section 19.2\n+constexpr uint8_t PCP_OP_MAP = 0x01;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Request and response header size in bytes (RFC6887 section 7.1).\n+constexpr size_t PCP_HDR_SIZE = 24;\n+//! Map request and response size in bytes (RFC6887 section 11.1).\n+constexpr size_t PCP_MAP_SIZE = 36;\n+\n+// Header offsets shared between request and responses (RFC6887 7.1, 7.2), relative to start of packet.\n+//!  Version field (1 byte).\n+constexpr size_t PCP_HDR_VERSION_OFS = NATPMP_HDR_VERSION_OFS;\n+//!  Opcode field (1 byte).\n+constexpr size_t PCP_HDR_OP_OFS = NATPMP_HDR_OP_OFS;\n+//!  Requested lifetime (request), granted lifetime (response) (2 bytes).\n+constexpr size_t PCP_HDR_LIFETIME_OFS = 4;\n+\n+// Request header offsets (RFC6887 7.1), relative to start of packet.\n+//!  PCP client's IP address (16 bytes).\n+constexpr size_t PCP_REQUEST_HDR_IP_OFS = 8;\n+\n+// Response header offsets (RFC6887 7.2), relative to start of packet.\n+//!  Result code (1 byte).\n+constexpr size_t PCP_RESPONSE_HDR_RESULT_OFS = 3;\n+\n+// MAP request/response offsets (RFC6887 11.1), relative to start of opcode-specific data.\n+//!  Mapping nonce (12 bytes).\n+constexpr size_t PCP_MAP_NONCE_OFS = 0;\n+//!  Protocol (1 byte).\n+constexpr size_t PCP_MAP_PROTOCOL_OFS = 12;\n+//!  Internal port for mapping (2 bytes).\n+constexpr size_t PCP_MAP_INTERNAL_PORT_OFS = 16;\n+//!  Suggested external port (request), assigned external port (response) (2 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_PORT_OFS = 18;\n+//!  Suggested external IP (request), assigned external IP (response) (16 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_IP_OFS = 20;\n+\n+//! Result code representing success (RFC6887 7.4), shared with NAT-PMP.\n+constexpr uint8_t PCP_RESULT_SUCCESS = NATPMP_RESULT_SUCCESS;\n+//! Result code representing lack of resources (RFC6887 7.4).\n+constexpr uint8_t PCP_RESULT_NO_RESOURCES = 8;\n+\n+//! Mapping of PCP result code to string (RFC6887 7.4). Result codes <=2 match NAT-PMP.\n+const std::map<uint8_t, std::string> PCP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"MALFORMED_REQUEST\"},\n+    {4,  \"UNSUPP_OPCODE\"},\n+    {5,  \"UNSUPP_OPTION\"},\n+    {6,  \"MALFORMED_OPTION\"},\n+    {7,  \"NETWORK_FAILURE\"},\n+    {8,  \"NO_RESOURCES\"},\n+    {9,  \"UNSUPP_PROTOCOL\"},\n+    {10, \"USER_EX_QUOTA\"},\n+    {11, \"CANNOT_PROVIDE_EXTERNAL\"},\n+    {12, \"ADDRESS_MISMATCH\"},\n+    {13, \"EXCESSIVE_REMOTE_PEER\"},\n+};\n+\n+//! Return human-readable string from NATPMP result code.\n+std::string NATPMPResultString(uint8_t result_code)\n+{\n+    auto result_i = NATPMP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == NATPMP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Return human-readable string from PCP result code.\n+std::string PCPResultString(uint8_t result_code)\n+{\n+    auto result_i = PCP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == PCP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Wrap address in IPv6 according to RFC6887. wrapped_addr needs to be able to store 16 bytes.\n+[[nodiscard]] bool PCPWrapAddress(Span<uint8_t> wrapped_addr, const CNetAddr &addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (addr.IsIPv4()) {\n+        struct in_addr addr4;\n+        if (!addr.GetInAddr(&addr4)) return false;\n+        // Section 5: \"When the address field holds an IPv4 address, an IPv4-mapped IPv6 address [RFC4291] is used (::ffff:0:0/96).\"\n+        std::memcpy(wrapped_addr.data(), IPV4_IN_IPV6_PREFIX.data(), IPV4_IN_IPV6_PREFIX.size());\n+        std::memcpy(wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), &addr4, ADDR_IPV4_SIZE);\n+        return true;\n+    } else if (addr.IsIPv6()) {\n+        struct in6_addr addr6;\n+        if (!addr.GetIn6Addr(&addr6)) return false;\n+        std::memcpy(wrapped_addr.data(), &addr6, ADDR_IPV6_SIZE);\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+//! Unwrap PCP-encoded address according to RFC6887.\n+CNetAddr PCPUnwrapAddress(Span<const uint8_t> wrapped_addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (util::HasPrefix(wrapped_addr, IPV4_IN_IPV6_PREFIX)) {\n+        struct in_addr addr4;\n+        std::memcpy(&addr4, wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), ADDR_IPV4_SIZE);\n+        return CNetAddr(addr4);\n+    } else {\n+        struct in6_addr addr6;\n+        std::memcpy(&addr6, wrapped_addr.data(), ADDR_IPV6_SIZE);\n+        return CNetAddr(addr6);\n+    }\n+}\n+\n+//! PCP or NAT-PMP send-receive loop.\n+std::optional<std::vector<uint8_t>> PCPSendRecv(Sock &sock, const std::string &protocol, Span<const uint8_t> request, int num_tries,\n+        std::chrono::milliseconds timeout_per_try,\n+        std::function<bool(Span<const uint8_t>)> check_packet)\n+{\n+    using namespace std::chrono;\n+    // UDP is a potentially lossy protocol, so we try to send again a few times.\n+    uint8_t response[PCP_MAX_SIZE];\n+    bool got_response = false;\n+    int recvsz = 0;\n+    for (int ntry = 0; !got_response && ntry < num_tries; ++ntry) {\n+        if (ntry > 0) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Retrying (%d)\\n\", protocol, ntry);\n+        }\n+        // Dispatch packet to gateway.\n+        if (sock.Send(request.data(), request.size(), 0) != static_cast<ssize_t>(request.size())) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not send request: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+            return std::nullopt; // Network-level error, probably no use retrying.\n+        }\n+\n+        // Wait for response(s) until we get a valid response, a network error, or time out.\n+        auto cur_time = time_point_cast<milliseconds>(steady_clock::now());\n+        auto deadline = cur_time + timeout_per_try;\n+        while ((cur_time = time_point_cast<milliseconds>(steady_clock::now())) < deadline) {\n+            Sock::Event occurred = 0;\n+            if (!sock.Wait(deadline - cur_time, Sock::RECV, &occurred)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not wait on socket: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            if (!occurred) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Timeout\\n\", protocol);\n+                break; // Retry.\n+            }\n+\n+            // Receive response.\n+            recvsz = sock.Recv(response, sizeof(response), MSG_DONTWAIT);\n+            if (recvsz < 0) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not receive response: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Received response of %d bytes: %s\\n\", protocol, recvsz, HexStr(Span(response, recvsz)));\n+\n+            if (check_packet(Span<uint8_t>(response, recvsz))) {\n+                got_response = true; // Got expected response, break from receive loop as well as from retry loop.\n+                break;\n+            }\n+        }\n+    }\n+    if (!got_response) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Giving up after %d tries\\n\", protocol, num_tries);\n+        return std::nullopt;\n+    }\n+    return std::vector<uint8_t>(response, response + recvsz);\n+}\n+\n+}\n+\n+std::variant<MappingResult, MappingError> NATPMPRequestPortMap(const CNetAddr &gateway, uint16_t port, uint32_t lifetime, int num_tries, std::chrono::milliseconds timeout_per_try)\n+{\n+    struct sockaddr_storage dest_addr;\n+    socklen_t dest_addrlen = sizeof(struct sockaddr_storage);\n+\n+    LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"natpmp: Requesting port mapping port %d from gateway %s\\n\", port, gateway.ToStringAddr());\n+\n+    // Validate gateway, make sure it's IPv4. NAT-PMP does not support IPv6.\n+    if (!CService(gateway, PCP_SERVER_PORT).GetSockAddr((struct sockaddr*)&dest_addr, &dest_addrlen)) return MappingError::NETWORK_ERROR;\n+    if (dest_addr.ss_family != AF_INET) return MappingError::NETWORK_ERROR;\n+\n+    // Create IPv4 UDP socket\n+    auto sock{CreateSock(AF_INET, SOCK_DGRAM, IPPROTO_UDP)};\n+    if (!sock) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Could not create UDP socket: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Associate UDP socket to gateway.\n+    if (sock->Connect((struct sockaddr*)&dest_addr, dest_addrlen) != 0) {",
      "path": "src/util/pcp.cpp",
      "position": 293,
      "original_position": 293,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "23916f2a7717b463799207b4b81b5795f2e9d7e3",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "From [RFC 6886 3.2](https://www.rfc-editor.org/rfc/rfc6886#section-3.2):\r\n\r\n> Upon receiving a response packet, the client MUST check the source IP address, and silently discard the packet if the address is not the address of the gateway to which the request was sent.\r\n\r\nUsing `connect(2)` on UDP socket nicely ensures that we only receive packets from that address (`dest_addr`), so that we don't have to check explicitly. Maybe expand the comment to show this purpose too and to avoid this `Connect()` being removed by a future refactor:\r\n\r\n```cpp\r\n// Associate UDP socket to gateway. This used to get our local address toward the gateway and\r\n// to ensure that we only process packets from the gateway, which is mandated by RFC 6886 3.2.",
      "created_at": "2024-06-26T15:35:31Z",
      "updated_at": "2024-06-28T15:24:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1655104852",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1655104852"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": 292,
      "original_start_line": 292,
      "start_side": "RIGHT",
      "line": 293,
      "original_line": 293,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1655128453",
      "pull_request_review_id": 2141814858,
      "id": 1655128453,
      "node_id": "PRRC_kwDOABII585ip0GF",
      "diff_hunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/pcp.h>\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <span.h>\n+#include <util/check.h>\n+#include <util/netif.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+namespace {\n+\n+// RFC6886 NAT-PMP and RFC6887 Port Control Protocol (PCP) implementation.\n+// NAT-PMP and PCP use network byte order (big-endian).\n+\n+// NAT-PMP (v0) protocol constants.\n+//! NAT-PMP uses a fixed server port number (RFC6887 section 1.1).\n+constexpr uint16_t NATPMP_SERVER_PORT = 5351;\n+//! Version byte for NATPMP (RFC6886 1.1)\n+constexpr uint8_t NATPMP_VERSION = 0;\n+//! Request opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_REQUEST = 0x00;\n+//! Response opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_RESPONSE = 0x80;\n+//! Get external address (RFC6886 3.2)\n+constexpr uint8_t NATPMP_OP_GETEXTERNAL = 0x00;\n+//! Map TCP port (RFC6886 3.3)\n+constexpr uint8_t NATPMP_OP_MAP_TCP = 0x02;\n+//! Shared request header size in bytes.\n+constexpr size_t NATPMP_REQUEST_HDR_SIZE = 2;\n+//! Shared response header (minimum) size in bytes.\n+constexpr size_t NATPMP_RESPONSE_HDR_SIZE = 8;\n+//! GETEXTERNAL request size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 0;\n+//! GETEXTERNAL response size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 4;\n+//! MAP request size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 10;\n+//! MAP response size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 8;\n+\n+// Shared header offsets (RFC6886 3.2, 3.3), relative to start of packet.\n+//!  Offset of version field in packets.\n+constexpr size_t NATPMP_HDR_VERSION_OFS = 0;\n+//!  Offset of opcode field in packets\n+constexpr size_t NATPMP_HDR_OP_OFS = 1;\n+//!  Offset of result code in packets. Result codes are 16 bit in NAT-PMP instead of 8 bit in PCP.\n+constexpr size_t NATPMP_RESPONSE_HDR_RESULT_OFS = 2;\n+\n+// GETEXTERNAL response offsets (RFC6886 3.2), relative to start of packet.\n+//!  Returned external address\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_IP_OFS = 8;\n+\n+// MAP request offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port to be mapped.\n+constexpr size_t NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS = 4;\n+//!  Suggested external port for mapping.\n+constexpr size_t NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS = 6;\n+//!  Requested port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_REQUEST_LIFETIME_OFS = 8;\n+\n+// MAP response offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port for mapping (will match internal port of request).\n+constexpr size_t NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS = 8;\n+//!  External port for mapping.\n+constexpr size_t NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS = 10;\n+//!  Created port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_RESPONSE_LIFETIME_OFS = 12;\n+\n+// Relevant NETPMP result codes (RFC6886 3.5).\n+//! Result code representing success status.\n+constexpr uint8_t NATPMP_RESULT_SUCCESS = 0;\n+//! Result code representing unsupported version.\n+constexpr uint8_t NATPMP_RESULT_UNSUPP_VERSION = 1;\n+//! Result code representing lack of resources.\n+constexpr uint8_t NATPMP_RESULT_NO_RESOURCES = 4;\n+\n+//! Mapping of NATPMP result code to string (RFC6886 3.5). Result codes <=2 match PCP.\n+const std::map<uint8_t, std::string> NATPMP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"NETWORK_FAILURE\"},\n+    {4,  \"NO_RESOURCES\"},\n+    {5,  \"UNSUPP_OPCODE\"},\n+};\n+\n+// PCP (v2) protocol constants.\n+//! Maximum packet size in bytes (RFC6887 section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (RFC6887 section 19.1). Shared with NAT-PMP.\n+constexpr uint16_t PCP_SERVER_PORT = NATPMP_SERVER_PORT;\n+//! Version byte. 0 is NAT-PMP (RFC6886), 1 is forbidden, 2 for PCP (RFC6887).\n+constexpr uint8_t PCP_VERSION = 2;\n+//! PCP Request Header. See RFC6887 section 7.1. Shared with NAT-PMP.\n+constexpr uint8_t PCP_REQUEST = NATPMP_REQUEST; // R = 0\n+//! PCP Response Header. See RFC6887 section 7.2. Shared with NAT-PMP.\n+constexpr uint8_t PCP_RESPONSE = NATPMP_RESPONSE; // R = 1\n+//! Map opcode. See RFC6887 section 19.2\n+constexpr uint8_t PCP_OP_MAP = 0x01;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Request and response header size in bytes (RFC6887 section 7.1).\n+constexpr size_t PCP_HDR_SIZE = 24;\n+//! Map request and response size in bytes (RFC6887 section 11.1).\n+constexpr size_t PCP_MAP_SIZE = 36;\n+\n+// Header offsets shared between request and responses (RFC6887 7.1, 7.2), relative to start of packet.\n+//!  Version field (1 byte).\n+constexpr size_t PCP_HDR_VERSION_OFS = NATPMP_HDR_VERSION_OFS;\n+//!  Opcode field (1 byte).\n+constexpr size_t PCP_HDR_OP_OFS = NATPMP_HDR_OP_OFS;\n+//!  Requested lifetime (request), granted lifetime (response) (2 bytes).\n+constexpr size_t PCP_HDR_LIFETIME_OFS = 4;\n+\n+// Request header offsets (RFC6887 7.1), relative to start of packet.\n+//!  PCP client's IP address (16 bytes).\n+constexpr size_t PCP_REQUEST_HDR_IP_OFS = 8;\n+\n+// Response header offsets (RFC6887 7.2), relative to start of packet.\n+//!  Result code (1 byte).\n+constexpr size_t PCP_RESPONSE_HDR_RESULT_OFS = 3;\n+\n+// MAP request/response offsets (RFC6887 11.1), relative to start of opcode-specific data.\n+//!  Mapping nonce (12 bytes).\n+constexpr size_t PCP_MAP_NONCE_OFS = 0;\n+//!  Protocol (1 byte).\n+constexpr size_t PCP_MAP_PROTOCOL_OFS = 12;\n+//!  Internal port for mapping (2 bytes).\n+constexpr size_t PCP_MAP_INTERNAL_PORT_OFS = 16;\n+//!  Suggested external port (request), assigned external port (response) (2 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_PORT_OFS = 18;\n+//!  Suggested external IP (request), assigned external IP (response) (16 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_IP_OFS = 20;\n+\n+//! Result code representing success (RFC6887 7.4), shared with NAT-PMP.\n+constexpr uint8_t PCP_RESULT_SUCCESS = NATPMP_RESULT_SUCCESS;\n+//! Result code representing lack of resources (RFC6887 7.4).\n+constexpr uint8_t PCP_RESULT_NO_RESOURCES = 8;\n+\n+//! Mapping of PCP result code to string (RFC6887 7.4). Result codes <=2 match NAT-PMP.\n+const std::map<uint8_t, std::string> PCP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"MALFORMED_REQUEST\"},\n+    {4,  \"UNSUPP_OPCODE\"},\n+    {5,  \"UNSUPP_OPTION\"},\n+    {6,  \"MALFORMED_OPTION\"},\n+    {7,  \"NETWORK_FAILURE\"},\n+    {8,  \"NO_RESOURCES\"},\n+    {9,  \"UNSUPP_PROTOCOL\"},\n+    {10, \"USER_EX_QUOTA\"},\n+    {11, \"CANNOT_PROVIDE_EXTERNAL\"},\n+    {12, \"ADDRESS_MISMATCH\"},\n+    {13, \"EXCESSIVE_REMOTE_PEER\"},\n+};\n+\n+//! Return human-readable string from NATPMP result code.\n+std::string NATPMPResultString(uint8_t result_code)\n+{\n+    auto result_i = NATPMP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == NATPMP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Return human-readable string from PCP result code.\n+std::string PCPResultString(uint8_t result_code)\n+{\n+    auto result_i = PCP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == PCP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Wrap address in IPv6 according to RFC6887. wrapped_addr needs to be able to store 16 bytes.\n+[[nodiscard]] bool PCPWrapAddress(Span<uint8_t> wrapped_addr, const CNetAddr &addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (addr.IsIPv4()) {\n+        struct in_addr addr4;\n+        if (!addr.GetInAddr(&addr4)) return false;\n+        // Section 5: \"When the address field holds an IPv4 address, an IPv4-mapped IPv6 address [RFC4291] is used (::ffff:0:0/96).\"\n+        std::memcpy(wrapped_addr.data(), IPV4_IN_IPV6_PREFIX.data(), IPV4_IN_IPV6_PREFIX.size());\n+        std::memcpy(wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), &addr4, ADDR_IPV4_SIZE);\n+        return true;\n+    } else if (addr.IsIPv6()) {\n+        struct in6_addr addr6;\n+        if (!addr.GetIn6Addr(&addr6)) return false;\n+        std::memcpy(wrapped_addr.data(), &addr6, ADDR_IPV6_SIZE);\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+//! Unwrap PCP-encoded address according to RFC6887.\n+CNetAddr PCPUnwrapAddress(Span<const uint8_t> wrapped_addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (util::HasPrefix(wrapped_addr, IPV4_IN_IPV6_PREFIX)) {\n+        struct in_addr addr4;\n+        std::memcpy(&addr4, wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), ADDR_IPV4_SIZE);\n+        return CNetAddr(addr4);\n+    } else {\n+        struct in6_addr addr6;\n+        std::memcpy(&addr6, wrapped_addr.data(), ADDR_IPV6_SIZE);\n+        return CNetAddr(addr6);\n+    }\n+}\n+\n+//! PCP or NAT-PMP send-receive loop.\n+std::optional<std::vector<uint8_t>> PCPSendRecv(Sock &sock, const std::string &protocol, Span<const uint8_t> request, int num_tries,\n+        std::chrono::milliseconds timeout_per_try,\n+        std::function<bool(Span<const uint8_t>)> check_packet)\n+{\n+    using namespace std::chrono;\n+    // UDP is a potentially lossy protocol, so we try to send again a few times.\n+    uint8_t response[PCP_MAX_SIZE];\n+    bool got_response = false;\n+    int recvsz = 0;\n+    for (int ntry = 0; !got_response && ntry < num_tries; ++ntry) {\n+        if (ntry > 0) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Retrying (%d)\\n\", protocol, ntry);\n+        }\n+        // Dispatch packet to gateway.\n+        if (sock.Send(request.data(), request.size(), 0) != static_cast<ssize_t>(request.size())) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not send request: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+            return std::nullopt; // Network-level error, probably no use retrying.\n+        }\n+\n+        // Wait for response(s) until we get a valid response, a network error, or time out.\n+        auto cur_time = time_point_cast<milliseconds>(steady_clock::now());\n+        auto deadline = cur_time + timeout_per_try;\n+        while ((cur_time = time_point_cast<milliseconds>(steady_clock::now())) < deadline) {\n+            Sock::Event occurred = 0;\n+            if (!sock.Wait(deadline - cur_time, Sock::RECV, &occurred)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not wait on socket: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            if (!occurred) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Timeout\\n\", protocol);\n+                break; // Retry.\n+            }\n+\n+            // Receive response.\n+            recvsz = sock.Recv(response, sizeof(response), MSG_DONTWAIT);\n+            if (recvsz < 0) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not receive response: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Received response of %d bytes: %s\\n\", protocol, recvsz, HexStr(Span(response, recvsz)));\n+\n+            if (check_packet(Span<uint8_t>(response, recvsz))) {\n+                got_response = true; // Got expected response, break from receive loop as well as from retry loop.\n+                break;\n+            }\n+        }\n+    }\n+    if (!got_response) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Giving up after %d tries\\n\", protocol, num_tries);\n+        return std::nullopt;\n+    }\n+    return std::vector<uint8_t>(response, response + recvsz);\n+}\n+\n+}\n+\n+std::variant<MappingResult, MappingError> NATPMPRequestPortMap(const CNetAddr &gateway, uint16_t port, uint32_t lifetime, int num_tries, std::chrono::milliseconds timeout_per_try)\n+{\n+    struct sockaddr_storage dest_addr;\n+    socklen_t dest_addrlen = sizeof(struct sockaddr_storage);\n+\n+    LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"natpmp: Requesting port mapping port %d from gateway %s\\n\", port, gateway.ToStringAddr());\n+\n+    // Validate gateway, make sure it's IPv4. NAT-PMP does not support IPv6.\n+    if (!CService(gateway, PCP_SERVER_PORT).GetSockAddr((struct sockaddr*)&dest_addr, &dest_addrlen)) return MappingError::NETWORK_ERROR;\n+    if (dest_addr.ss_family != AF_INET) return MappingError::NETWORK_ERROR;\n+\n+    // Create IPv4 UDP socket\n+    auto sock{CreateSock(AF_INET, SOCK_DGRAM, IPPROTO_UDP)};\n+    if (!sock) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Could not create UDP socket: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Associate UDP socket to gateway.\n+    if (sock->Connect((struct sockaddr*)&dest_addr, dest_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Could not connect to gateway: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Use getsockname to get the address toward the default gateway (the internal address).\n+    struct sockaddr_in internal;\n+    socklen_t internal_addrlen = sizeof(struct sockaddr_in);\n+    if (sock->GetSockName((struct sockaddr*)&internal, &internal_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Could not get sock name: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Request external IP address (RFC6886 section 3.2).\n+    std::vector<uint8_t> request(NATPMP_GETEXTERNAL_REQUEST_SIZE);\n+    request[NATPMP_HDR_VERSION_OFS] = NATPMP_VERSION;\n+    request[NATPMP_HDR_OP_OFS] = NATPMP_REQUEST | NATPMP_OP_GETEXTERNAL;\n+\n+    auto recv_res = PCPSendRecv(*sock, \"natpmp\", request, num_tries, timeout_per_try,\n+        [&](const Span<const uint8_t> response) -> bool {\n+            if (response.size() < NATPMP_GETEXTERNAL_RESPONSE_SIZE) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response too small\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            if (response[NATPMP_HDR_VERSION_OFS] != NATPMP_VERSION || response[NATPMP_HDR_OP_OFS] != (NATPMP_RESPONSE | NATPMP_OP_GETEXTERNAL)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response to wrong command\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            return true;\n+        });\n+\n+    struct in_addr external_addr;\n+    if (recv_res) {\n+        const std::span<const uint8_t> response = *recv_res;\n+\n+        Assume(response.size() >= NATPMP_GETEXTERNAL_RESPONSE_SIZE);\n+        uint16_t result_code = ReadBE16(response.data() + NATPMP_RESPONSE_HDR_RESULT_OFS);\n+        if (result_code != NATPMP_RESULT_SUCCESS) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Getting external address failed with result %s\\n\", NATPMPResultString(result_code));\n+            return MappingError::PROTOCOL_ERROR;\n+        }\n+\n+        std::memcpy(&external_addr, response.data() + NATPMP_GETEXTERNAL_RESPONSE_IP_OFS, ADDR_IPV4_SIZE);\n+    } else {\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Create TCP mapping request (RFC6886 section 3.3).\n+    request = std::vector<uint8_t>(NATPMP_MAP_REQUEST_SIZE);\n+    request[NATPMP_HDR_VERSION_OFS] = NATPMP_VERSION;\n+    request[NATPMP_HDR_OP_OFS] = NATPMP_REQUEST | NATPMP_OP_MAP_TCP;\n+    WriteBE16(request.data() + NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS, port);\n+    WriteBE16(request.data() + NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS, port);\n+    WriteBE32(request.data() + NATPMP_MAP_REQUEST_LIFETIME_OFS, lifetime);\n+\n+    recv_res = PCPSendRecv(*sock, \"natpmp\", request, num_tries, timeout_per_try,\n+        [&](const Span<const uint8_t> response) -> bool {\n+            if (response.size() < NATPMP_MAP_RESPONSE_SIZE) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response too small\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            if (response[0] != NATPMP_VERSION || response[1] != (NATPMP_RESPONSE | NATPMP_OP_MAP_TCP)) {",
      "path": "src/util/pcp.cpp",
      "position": 354,
      "original_position": 354,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "23916f2a7717b463799207b4b81b5795f2e9d7e3",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Could use the constants instead of magic numbers:\r\n\r\n```suggestion\r\n            if (response[NATPMP_HDR_VERSION_OFS] != NATPMP_VERSION || response[NATPMP_HDR_OP_OFS] != (NATPMP_RESPONSE | NATPMP_OP_MAP_TCP)) {\r\n```",
      "created_at": "2024-06-26T15:50:37Z",
      "updated_at": "2024-06-28T15:24:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1655128453",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1655128453"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 354,
      "original_line": 354,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1655169229",
      "pull_request_review_id": 2141814858,
      "id": 1655169229,
      "node_id": "PRRC_kwDOABII585ip-DN",
      "diff_hunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/pcp.h>\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <span.h>\n+#include <util/check.h>\n+#include <util/netif.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+namespace {\n+\n+// RFC6886 NAT-PMP and RFC6887 Port Control Protocol (PCP) implementation.\n+// NAT-PMP and PCP use network byte order (big-endian).\n+\n+// NAT-PMP (v0) protocol constants.\n+//! NAT-PMP uses a fixed server port number (RFC6887 section 1.1).\n+constexpr uint16_t NATPMP_SERVER_PORT = 5351;\n+//! Version byte for NATPMP (RFC6886 1.1)\n+constexpr uint8_t NATPMP_VERSION = 0;\n+//! Request opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_REQUEST = 0x00;\n+//! Response opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_RESPONSE = 0x80;\n+//! Get external address (RFC6886 3.2)\n+constexpr uint8_t NATPMP_OP_GETEXTERNAL = 0x00;\n+//! Map TCP port (RFC6886 3.3)\n+constexpr uint8_t NATPMP_OP_MAP_TCP = 0x02;\n+//! Shared request header size in bytes.\n+constexpr size_t NATPMP_REQUEST_HDR_SIZE = 2;\n+//! Shared response header (minimum) size in bytes.\n+constexpr size_t NATPMP_RESPONSE_HDR_SIZE = 8;\n+//! GETEXTERNAL request size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 0;\n+//! GETEXTERNAL response size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 4;\n+//! MAP request size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 10;\n+//! MAP response size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 8;\n+\n+// Shared header offsets (RFC6886 3.2, 3.3), relative to start of packet.\n+//!  Offset of version field in packets.\n+constexpr size_t NATPMP_HDR_VERSION_OFS = 0;\n+//!  Offset of opcode field in packets\n+constexpr size_t NATPMP_HDR_OP_OFS = 1;\n+//!  Offset of result code in packets. Result codes are 16 bit in NAT-PMP instead of 8 bit in PCP.\n+constexpr size_t NATPMP_RESPONSE_HDR_RESULT_OFS = 2;\n+\n+// GETEXTERNAL response offsets (RFC6886 3.2), relative to start of packet.\n+//!  Returned external address\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_IP_OFS = 8;\n+\n+// MAP request offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port to be mapped.\n+constexpr size_t NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS = 4;\n+//!  Suggested external port for mapping.\n+constexpr size_t NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS = 6;\n+//!  Requested port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_REQUEST_LIFETIME_OFS = 8;\n+\n+// MAP response offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port for mapping (will match internal port of request).\n+constexpr size_t NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS = 8;\n+//!  External port for mapping.\n+constexpr size_t NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS = 10;\n+//!  Created port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_RESPONSE_LIFETIME_OFS = 12;\n+\n+// Relevant NETPMP result codes (RFC6886 3.5).\n+//! Result code representing success status.\n+constexpr uint8_t NATPMP_RESULT_SUCCESS = 0;\n+//! Result code representing unsupported version.\n+constexpr uint8_t NATPMP_RESULT_UNSUPP_VERSION = 1;\n+//! Result code representing lack of resources.\n+constexpr uint8_t NATPMP_RESULT_NO_RESOURCES = 4;\n+\n+//! Mapping of NATPMP result code to string (RFC6886 3.5). Result codes <=2 match PCP.\n+const std::map<uint8_t, std::string> NATPMP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"NETWORK_FAILURE\"},\n+    {4,  \"NO_RESOURCES\"},\n+    {5,  \"UNSUPP_OPCODE\"},\n+};\n+\n+// PCP (v2) protocol constants.\n+//! Maximum packet size in bytes (RFC6887 section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (RFC6887 section 19.1). Shared with NAT-PMP.\n+constexpr uint16_t PCP_SERVER_PORT = NATPMP_SERVER_PORT;\n+//! Version byte. 0 is NAT-PMP (RFC6886), 1 is forbidden, 2 for PCP (RFC6887).\n+constexpr uint8_t PCP_VERSION = 2;\n+//! PCP Request Header. See RFC6887 section 7.1. Shared with NAT-PMP.\n+constexpr uint8_t PCP_REQUEST = NATPMP_REQUEST; // R = 0\n+//! PCP Response Header. See RFC6887 section 7.2. Shared with NAT-PMP.\n+constexpr uint8_t PCP_RESPONSE = NATPMP_RESPONSE; // R = 1\n+//! Map opcode. See RFC6887 section 19.2\n+constexpr uint8_t PCP_OP_MAP = 0x01;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Request and response header size in bytes (RFC6887 section 7.1).\n+constexpr size_t PCP_HDR_SIZE = 24;\n+//! Map request and response size in bytes (RFC6887 section 11.1).\n+constexpr size_t PCP_MAP_SIZE = 36;\n+\n+// Header offsets shared between request and responses (RFC6887 7.1, 7.2), relative to start of packet.\n+//!  Version field (1 byte).\n+constexpr size_t PCP_HDR_VERSION_OFS = NATPMP_HDR_VERSION_OFS;\n+//!  Opcode field (1 byte).\n+constexpr size_t PCP_HDR_OP_OFS = NATPMP_HDR_OP_OFS;\n+//!  Requested lifetime (request), granted lifetime (response) (2 bytes).\n+constexpr size_t PCP_HDR_LIFETIME_OFS = 4;\n+\n+// Request header offsets (RFC6887 7.1), relative to start of packet.\n+//!  PCP client's IP address (16 bytes).\n+constexpr size_t PCP_REQUEST_HDR_IP_OFS = 8;\n+\n+// Response header offsets (RFC6887 7.2), relative to start of packet.\n+//!  Result code (1 byte).\n+constexpr size_t PCP_RESPONSE_HDR_RESULT_OFS = 3;\n+\n+// MAP request/response offsets (RFC6887 11.1), relative to start of opcode-specific data.\n+//!  Mapping nonce (12 bytes).\n+constexpr size_t PCP_MAP_NONCE_OFS = 0;\n+//!  Protocol (1 byte).\n+constexpr size_t PCP_MAP_PROTOCOL_OFS = 12;\n+//!  Internal port for mapping (2 bytes).\n+constexpr size_t PCP_MAP_INTERNAL_PORT_OFS = 16;\n+//!  Suggested external port (request), assigned external port (response) (2 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_PORT_OFS = 18;\n+//!  Suggested external IP (request), assigned external IP (response) (16 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_IP_OFS = 20;\n+\n+//! Result code representing success (RFC6887 7.4), shared with NAT-PMP.\n+constexpr uint8_t PCP_RESULT_SUCCESS = NATPMP_RESULT_SUCCESS;\n+//! Result code representing lack of resources (RFC6887 7.4).\n+constexpr uint8_t PCP_RESULT_NO_RESOURCES = 8;\n+\n+//! Mapping of PCP result code to string (RFC6887 7.4). Result codes <=2 match NAT-PMP.\n+const std::map<uint8_t, std::string> PCP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"MALFORMED_REQUEST\"},\n+    {4,  \"UNSUPP_OPCODE\"},\n+    {5,  \"UNSUPP_OPTION\"},\n+    {6,  \"MALFORMED_OPTION\"},\n+    {7,  \"NETWORK_FAILURE\"},\n+    {8,  \"NO_RESOURCES\"},\n+    {9,  \"UNSUPP_PROTOCOL\"},\n+    {10, \"USER_EX_QUOTA\"},\n+    {11, \"CANNOT_PROVIDE_EXTERNAL\"},\n+    {12, \"ADDRESS_MISMATCH\"},\n+    {13, \"EXCESSIVE_REMOTE_PEER\"},\n+};\n+\n+//! Return human-readable string from NATPMP result code.\n+std::string NATPMPResultString(uint8_t result_code)\n+{\n+    auto result_i = NATPMP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == NATPMP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Return human-readable string from PCP result code.\n+std::string PCPResultString(uint8_t result_code)\n+{\n+    auto result_i = PCP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == PCP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Wrap address in IPv6 according to RFC6887. wrapped_addr needs to be able to store 16 bytes.\n+[[nodiscard]] bool PCPWrapAddress(Span<uint8_t> wrapped_addr, const CNetAddr &addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (addr.IsIPv4()) {\n+        struct in_addr addr4;\n+        if (!addr.GetInAddr(&addr4)) return false;\n+        // Section 5: \"When the address field holds an IPv4 address, an IPv4-mapped IPv6 address [RFC4291] is used (::ffff:0:0/96).\"\n+        std::memcpy(wrapped_addr.data(), IPV4_IN_IPV6_PREFIX.data(), IPV4_IN_IPV6_PREFIX.size());\n+        std::memcpy(wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), &addr4, ADDR_IPV4_SIZE);\n+        return true;\n+    } else if (addr.IsIPv6()) {\n+        struct in6_addr addr6;\n+        if (!addr.GetIn6Addr(&addr6)) return false;\n+        std::memcpy(wrapped_addr.data(), &addr6, ADDR_IPV6_SIZE);\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+//! Unwrap PCP-encoded address according to RFC6887.\n+CNetAddr PCPUnwrapAddress(Span<const uint8_t> wrapped_addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (util::HasPrefix(wrapped_addr, IPV4_IN_IPV6_PREFIX)) {\n+        struct in_addr addr4;\n+        std::memcpy(&addr4, wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), ADDR_IPV4_SIZE);\n+        return CNetAddr(addr4);\n+    } else {\n+        struct in6_addr addr6;\n+        std::memcpy(&addr6, wrapped_addr.data(), ADDR_IPV6_SIZE);\n+        return CNetAddr(addr6);\n+    }\n+}\n+\n+//! PCP or NAT-PMP send-receive loop.\n+std::optional<std::vector<uint8_t>> PCPSendRecv(Sock &sock, const std::string &protocol, Span<const uint8_t> request, int num_tries,\n+        std::chrono::milliseconds timeout_per_try,\n+        std::function<bool(Span<const uint8_t>)> check_packet)\n+{\n+    using namespace std::chrono;\n+    // UDP is a potentially lossy protocol, so we try to send again a few times.\n+    uint8_t response[PCP_MAX_SIZE];\n+    bool got_response = false;\n+    int recvsz = 0;\n+    for (int ntry = 0; !got_response && ntry < num_tries; ++ntry) {",
      "path": "src/util/pcp.cpp",
      "position": 227,
      "original_position": 227,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "23916f2a7717b463799207b4b81b5795f2e9d7e3",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "From https://www.rfc-editor.org/rfc/rfc6886#section-3.1:\r\n\r\n> ... client sends its request packet to port 5351 of its\r\n   configured gateway address, and waits 250 ms for a response.  If no\r\n   NAT-PMP response is received from the gateway after 250 ms, the\r\n   client retransmits its request and waits 500 ms.  The client SHOULD\r\n   repeat this process with the interval between attempts doubling each\r\n   time.  If, after sending its ninth attempt (and then waiting for 64\r\n   seconds), the client has still received no response, then it SHOULD\r\n   conclude that this gateway does not support NAT Port Mapping Protocol\r\n\r\nThe code is not doing as prescribed - it will wait equal amount of time after each send. I guess this is fine as well, but I wonder if there is a specific reason not to implement it as prescribed?\r\n\r\nEdit: PCP describes a different retransmission logic: https://www.rfc-editor.org/rfc/rfc6887#section-8.1.1 (a bit convoluted IMO).",
      "created_at": "2024-06-26T16:21:47Z",
      "updated_at": "2024-06-28T15:24:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1655169229",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1655169229"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 227,
      "original_line": 227,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1655273411",
      "pull_request_review_id": 2142545329,
      "id": 1655273411,
      "node_id": "PRRC_kwDOABII585iqXfD",
      "diff_hunk": "@@ -0,0 +1,68 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_PCP_H\n+#define BITCOIN_UTIL_PCP_H\n+\n+#include <netaddress.h>\n+\n+#include <variant>",
      "path": "src/util/pcp.h",
      "position": 10,
      "original_position": 10,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "bc41b2f8984241c6d7241401b26fab5e96b54932",
      "in_reply_to_id": 1655081131,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Will add, thanks!",
      "created_at": "2024-06-26T17:29:59Z",
      "updated_at": "2024-06-26T17:29:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1655273411",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1655273411"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 10,
      "original_line": 10,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1655277307",
      "pull_request_review_id": 2142551783,
      "id": 1655277307,
      "node_id": "PRRC_kwDOABII585iqYb7",
      "diff_hunk": "@@ -0,0 +1,20 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_NETIF_H\n+#define BITCOIN_UTIL_NETIF_H\n+\n+#include <netaddress.h>",
      "path": "src/util/netif.h",
      "position": 8,
      "original_position": 8,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "9a067b5ac154154ec9008a0e8f2d8f03e994a589",
      "in_reply_to_id": 1655098222,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "i don't disagree with doing this, but `netif.h` is only included in two places: `net.cpp` and `pcp.cpp`, both of which use `netaddress.h` anyway. Not sure it's worth adding a change in `netaddress.h` in this PR for.",
      "created_at": "2024-06-26T17:33:43Z",
      "updated_at": "2024-06-26T17:33:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1655277307",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1655277307"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 8,
      "original_line": 8,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1657164986",
      "pull_request_review_id": 2141814858,
      "id": 1657164986,
      "node_id": "PRRC_kwDOABII585ixlS6",
      "diff_hunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/pcp.h>\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <span.h>\n+#include <util/check.h>\n+#include <util/netif.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+namespace {\n+\n+// RFC6886 NAT-PMP and RFC6887 Port Control Protocol (PCP) implementation.\n+// NAT-PMP and PCP use network byte order (big-endian).\n+\n+// NAT-PMP (v0) protocol constants.\n+//! NAT-PMP uses a fixed server port number (RFC6887 section 1.1).\n+constexpr uint16_t NATPMP_SERVER_PORT = 5351;\n+//! Version byte for NATPMP (RFC6886 1.1)\n+constexpr uint8_t NATPMP_VERSION = 0;\n+//! Request opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_REQUEST = 0x00;\n+//! Response opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_RESPONSE = 0x80;\n+//! Get external address (RFC6886 3.2)\n+constexpr uint8_t NATPMP_OP_GETEXTERNAL = 0x00;\n+//! Map TCP port (RFC6886 3.3)\n+constexpr uint8_t NATPMP_OP_MAP_TCP = 0x02;\n+//! Shared request header size in bytes.\n+constexpr size_t NATPMP_REQUEST_HDR_SIZE = 2;\n+//! Shared response header (minimum) size in bytes.\n+constexpr size_t NATPMP_RESPONSE_HDR_SIZE = 8;\n+//! GETEXTERNAL request size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 0;\n+//! GETEXTERNAL response size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 4;\n+//! MAP request size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 10;\n+//! MAP response size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 8;\n+\n+// Shared header offsets (RFC6886 3.2, 3.3), relative to start of packet.\n+//!  Offset of version field in packets.\n+constexpr size_t NATPMP_HDR_VERSION_OFS = 0;\n+//!  Offset of opcode field in packets\n+constexpr size_t NATPMP_HDR_OP_OFS = 1;\n+//!  Offset of result code in packets. Result codes are 16 bit in NAT-PMP instead of 8 bit in PCP.\n+constexpr size_t NATPMP_RESPONSE_HDR_RESULT_OFS = 2;\n+\n+// GETEXTERNAL response offsets (RFC6886 3.2), relative to start of packet.\n+//!  Returned external address\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_IP_OFS = 8;\n+\n+// MAP request offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port to be mapped.\n+constexpr size_t NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS = 4;\n+//!  Suggested external port for mapping.\n+constexpr size_t NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS = 6;\n+//!  Requested port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_REQUEST_LIFETIME_OFS = 8;\n+\n+// MAP response offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port for mapping (will match internal port of request).\n+constexpr size_t NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS = 8;\n+//!  External port for mapping.\n+constexpr size_t NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS = 10;\n+//!  Created port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_RESPONSE_LIFETIME_OFS = 12;\n+\n+// Relevant NETPMP result codes (RFC6886 3.5).\n+//! Result code representing success status.\n+constexpr uint8_t NATPMP_RESULT_SUCCESS = 0;\n+//! Result code representing unsupported version.\n+constexpr uint8_t NATPMP_RESULT_UNSUPP_VERSION = 1;\n+//! Result code representing lack of resources.\n+constexpr uint8_t NATPMP_RESULT_NO_RESOURCES = 4;\n+\n+//! Mapping of NATPMP result code to string (RFC6886 3.5). Result codes <=2 match PCP.\n+const std::map<uint8_t, std::string> NATPMP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"NETWORK_FAILURE\"},\n+    {4,  \"NO_RESOURCES\"},\n+    {5,  \"UNSUPP_OPCODE\"},\n+};\n+\n+// PCP (v2) protocol constants.\n+//! Maximum packet size in bytes (RFC6887 section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (RFC6887 section 19.1). Shared with NAT-PMP.\n+constexpr uint16_t PCP_SERVER_PORT = NATPMP_SERVER_PORT;\n+//! Version byte. 0 is NAT-PMP (RFC6886), 1 is forbidden, 2 for PCP (RFC6887).\n+constexpr uint8_t PCP_VERSION = 2;\n+//! PCP Request Header. See RFC6887 section 7.1. Shared with NAT-PMP.\n+constexpr uint8_t PCP_REQUEST = NATPMP_REQUEST; // R = 0\n+//! PCP Response Header. See RFC6887 section 7.2. Shared with NAT-PMP.\n+constexpr uint8_t PCP_RESPONSE = NATPMP_RESPONSE; // R = 1\n+//! Map opcode. See RFC6887 section 19.2\n+constexpr uint8_t PCP_OP_MAP = 0x01;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Request and response header size in bytes (RFC6887 section 7.1).\n+constexpr size_t PCP_HDR_SIZE = 24;\n+//! Map request and response size in bytes (RFC6887 section 11.1).\n+constexpr size_t PCP_MAP_SIZE = 36;\n+\n+// Header offsets shared between request and responses (RFC6887 7.1, 7.2), relative to start of packet.\n+//!  Version field (1 byte).\n+constexpr size_t PCP_HDR_VERSION_OFS = NATPMP_HDR_VERSION_OFS;\n+//!  Opcode field (1 byte).\n+constexpr size_t PCP_HDR_OP_OFS = NATPMP_HDR_OP_OFS;\n+//!  Requested lifetime (request), granted lifetime (response) (2 bytes).\n+constexpr size_t PCP_HDR_LIFETIME_OFS = 4;\n+\n+// Request header offsets (RFC6887 7.1), relative to start of packet.\n+//!  PCP client's IP address (16 bytes).\n+constexpr size_t PCP_REQUEST_HDR_IP_OFS = 8;\n+\n+// Response header offsets (RFC6887 7.2), relative to start of packet.\n+//!  Result code (1 byte).\n+constexpr size_t PCP_RESPONSE_HDR_RESULT_OFS = 3;\n+\n+// MAP request/response offsets (RFC6887 11.1), relative to start of opcode-specific data.\n+//!  Mapping nonce (12 bytes).\n+constexpr size_t PCP_MAP_NONCE_OFS = 0;\n+//!  Protocol (1 byte).\n+constexpr size_t PCP_MAP_PROTOCOL_OFS = 12;\n+//!  Internal port for mapping (2 bytes).\n+constexpr size_t PCP_MAP_INTERNAL_PORT_OFS = 16;\n+//!  Suggested external port (request), assigned external port (response) (2 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_PORT_OFS = 18;\n+//!  Suggested external IP (request), assigned external IP (response) (16 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_IP_OFS = 20;\n+\n+//! Result code representing success (RFC6887 7.4), shared with NAT-PMP.\n+constexpr uint8_t PCP_RESULT_SUCCESS = NATPMP_RESULT_SUCCESS;\n+//! Result code representing lack of resources (RFC6887 7.4).\n+constexpr uint8_t PCP_RESULT_NO_RESOURCES = 8;\n+\n+//! Mapping of PCP result code to string (RFC6887 7.4). Result codes <=2 match NAT-PMP.\n+const std::map<uint8_t, std::string> PCP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"MALFORMED_REQUEST\"},\n+    {4,  \"UNSUPP_OPCODE\"},\n+    {5,  \"UNSUPP_OPTION\"},\n+    {6,  \"MALFORMED_OPTION\"},\n+    {7,  \"NETWORK_FAILURE\"},\n+    {8,  \"NO_RESOURCES\"},\n+    {9,  \"UNSUPP_PROTOCOL\"},\n+    {10, \"USER_EX_QUOTA\"},\n+    {11, \"CANNOT_PROVIDE_EXTERNAL\"},\n+    {12, \"ADDRESS_MISMATCH\"},\n+    {13, \"EXCESSIVE_REMOTE_PEER\"},\n+};\n+\n+//! Return human-readable string from NATPMP result code.\n+std::string NATPMPResultString(uint8_t result_code)\n+{\n+    auto result_i = NATPMP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == NATPMP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Return human-readable string from PCP result code.\n+std::string PCPResultString(uint8_t result_code)\n+{\n+    auto result_i = PCP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == PCP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Wrap address in IPv6 according to RFC6887. wrapped_addr needs to be able to store 16 bytes.\n+[[nodiscard]] bool PCPWrapAddress(Span<uint8_t> wrapped_addr, const CNetAddr &addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (addr.IsIPv4()) {\n+        struct in_addr addr4;\n+        if (!addr.GetInAddr(&addr4)) return false;\n+        // Section 5: \"When the address field holds an IPv4 address, an IPv4-mapped IPv6 address [RFC4291] is used (::ffff:0:0/96).\"\n+        std::memcpy(wrapped_addr.data(), IPV4_IN_IPV6_PREFIX.data(), IPV4_IN_IPV6_PREFIX.size());\n+        std::memcpy(wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), &addr4, ADDR_IPV4_SIZE);\n+        return true;\n+    } else if (addr.IsIPv6()) {\n+        struct in6_addr addr6;\n+        if (!addr.GetIn6Addr(&addr6)) return false;\n+        std::memcpy(wrapped_addr.data(), &addr6, ADDR_IPV6_SIZE);\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+//! Unwrap PCP-encoded address according to RFC6887.\n+CNetAddr PCPUnwrapAddress(Span<const uint8_t> wrapped_addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (util::HasPrefix(wrapped_addr, IPV4_IN_IPV6_PREFIX)) {\n+        struct in_addr addr4;\n+        std::memcpy(&addr4, wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), ADDR_IPV4_SIZE);\n+        return CNetAddr(addr4);\n+    } else {\n+        struct in6_addr addr6;\n+        std::memcpy(&addr6, wrapped_addr.data(), ADDR_IPV6_SIZE);\n+        return CNetAddr(addr6);\n+    }\n+}\n+\n+//! PCP or NAT-PMP send-receive loop.\n+std::optional<std::vector<uint8_t>> PCPSendRecv(Sock &sock, const std::string &protocol, Span<const uint8_t> request, int num_tries,\n+        std::chrono::milliseconds timeout_per_try,\n+        std::function<bool(Span<const uint8_t>)> check_packet)\n+{\n+    using namespace std::chrono;\n+    // UDP is a potentially lossy protocol, so we try to send again a few times.\n+    uint8_t response[PCP_MAX_SIZE];\n+    bool got_response = false;\n+    int recvsz = 0;\n+    for (int ntry = 0; !got_response && ntry < num_tries; ++ntry) {\n+        if (ntry > 0) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Retrying (%d)\\n\", protocol, ntry);\n+        }\n+        // Dispatch packet to gateway.\n+        if (sock.Send(request.data(), request.size(), 0) != static_cast<ssize_t>(request.size())) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not send request: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+            return std::nullopt; // Network-level error, probably no use retrying.\n+        }\n+\n+        // Wait for response(s) until we get a valid response, a network error, or time out.\n+        auto cur_time = time_point_cast<milliseconds>(steady_clock::now());\n+        auto deadline = cur_time + timeout_per_try;\n+        while ((cur_time = time_point_cast<milliseconds>(steady_clock::now())) < deadline) {\n+            Sock::Event occurred = 0;\n+            if (!sock.Wait(deadline - cur_time, Sock::RECV, &occurred)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not wait on socket: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            if (!occurred) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Timeout\\n\", protocol);\n+                break; // Retry.\n+            }\n+\n+            // Receive response.\n+            recvsz = sock.Recv(response, sizeof(response), MSG_DONTWAIT);\n+            if (recvsz < 0) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not receive response: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Received response of %d bytes: %s\\n\", protocol, recvsz, HexStr(Span(response, recvsz)));\n+\n+            if (check_packet(Span<uint8_t>(response, recvsz))) {\n+                got_response = true; // Got expected response, break from receive loop as well as from retry loop.\n+                break;\n+            }\n+        }\n+    }\n+    if (!got_response) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Giving up after %d tries\\n\", protocol, num_tries);\n+        return std::nullopt;\n+    }\n+    return std::vector<uint8_t>(response, response + recvsz);\n+}\n+\n+}\n+\n+std::variant<MappingResult, MappingError> NATPMPRequestPortMap(const CNetAddr &gateway, uint16_t port, uint32_t lifetime, int num_tries, std::chrono::milliseconds timeout_per_try)\n+{\n+    struct sockaddr_storage dest_addr;\n+    socklen_t dest_addrlen = sizeof(struct sockaddr_storage);\n+\n+    LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"natpmp: Requesting port mapping port %d from gateway %s\\n\", port, gateway.ToStringAddr());\n+\n+    // Validate gateway, make sure it's IPv4. NAT-PMP does not support IPv6.\n+    if (!CService(gateway, PCP_SERVER_PORT).GetSockAddr((struct sockaddr*)&dest_addr, &dest_addrlen)) return MappingError::NETWORK_ERROR;\n+    if (dest_addr.ss_family != AF_INET) return MappingError::NETWORK_ERROR;\n+\n+    // Create IPv4 UDP socket\n+    auto sock{CreateSock(AF_INET, SOCK_DGRAM, IPPROTO_UDP)};\n+    if (!sock) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Could not create UDP socket: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Associate UDP socket to gateway.\n+    if (sock->Connect((struct sockaddr*)&dest_addr, dest_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Could not connect to gateway: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Use getsockname to get the address toward the default gateway (the internal address).\n+    struct sockaddr_in internal;\n+    socklen_t internal_addrlen = sizeof(struct sockaddr_in);\n+    if (sock->GetSockName((struct sockaddr*)&internal, &internal_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Could not get sock name: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Request external IP address (RFC6886 section 3.2).\n+    std::vector<uint8_t> request(NATPMP_GETEXTERNAL_REQUEST_SIZE);\n+    request[NATPMP_HDR_VERSION_OFS] = NATPMP_VERSION;\n+    request[NATPMP_HDR_OP_OFS] = NATPMP_REQUEST | NATPMP_OP_GETEXTERNAL;\n+\n+    auto recv_res = PCPSendRecv(*sock, \"natpmp\", request, num_tries, timeout_per_try,\n+        [&](const Span<const uint8_t> response) -> bool {\n+            if (response.size() < NATPMP_GETEXTERNAL_RESPONSE_SIZE) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response too small\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            if (response[NATPMP_HDR_VERSION_OFS] != NATPMP_VERSION || response[NATPMP_HDR_OP_OFS] != (NATPMP_RESPONSE | NATPMP_OP_GETEXTERNAL)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response to wrong command\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            return true;\n+        });\n+\n+    struct in_addr external_addr;\n+    if (recv_res) {\n+        const std::span<const uint8_t> response = *recv_res;\n+\n+        Assume(response.size() >= NATPMP_GETEXTERNAL_RESPONSE_SIZE);\n+        uint16_t result_code = ReadBE16(response.data() + NATPMP_RESPONSE_HDR_RESULT_OFS);\n+        if (result_code != NATPMP_RESULT_SUCCESS) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Getting external address failed with result %s\\n\", NATPMPResultString(result_code));\n+            return MappingError::PROTOCOL_ERROR;\n+        }\n+\n+        std::memcpy(&external_addr, response.data() + NATPMP_GETEXTERNAL_RESPONSE_IP_OFS, ADDR_IPV4_SIZE);\n+    } else {\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Create TCP mapping request (RFC6886 section 3.3).\n+    request = std::vector<uint8_t>(NATPMP_MAP_REQUEST_SIZE);\n+    request[NATPMP_HDR_VERSION_OFS] = NATPMP_VERSION;\n+    request[NATPMP_HDR_OP_OFS] = NATPMP_REQUEST | NATPMP_OP_MAP_TCP;\n+    WriteBE16(request.data() + NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS, port);\n+    WriteBE16(request.data() + NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS, port);\n+    WriteBE32(request.data() + NATPMP_MAP_REQUEST_LIFETIME_OFS, lifetime);\n+\n+    recv_res = PCPSendRecv(*sock, \"natpmp\", request, num_tries, timeout_per_try,\n+        [&](const Span<const uint8_t> response) -> bool {\n+            if (response.size() < NATPMP_MAP_RESPONSE_SIZE) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response too small\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            if (response[0] != NATPMP_VERSION || response[1] != (NATPMP_RESPONSE | NATPMP_OP_MAP_TCP)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response to wrong command\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            uint16_t internal_port = ReadBE16(response.data() + NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS);\n+            if (internal_port != port) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response port doesn't match request\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            return true;\n+        });\n+\n+    if (recv_res) {\n+        const std::span<uint8_t> response = *recv_res;\n+\n+        Assume(response.size() >= NATPMP_MAP_RESPONSE_SIZE);\n+        uint16_t result_code = ReadBE16(response.data() + NATPMP_RESPONSE_HDR_RESULT_OFS);\n+        if (result_code != NATPMP_RESULT_SUCCESS) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Port mapping failed with result %s\\n\", NATPMPResultString(result_code));\n+            if (result_code == NATPMP_RESULT_NO_RESOURCES) {\n+                return MappingError::NO_RESOURCES;\n+            }\n+            return MappingError::PROTOCOL_ERROR;\n+        }\n+\n+        uint32_t lifetime_ret = ReadBE32(response.data() + NATPMP_MAP_RESPONSE_LIFETIME_OFS);\n+        uint16_t external_port = ReadBE16(response.data() + NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS);\n+        return MappingResult(NATPMP_VERSION, CService(internal.sin_addr, port), CService(external_addr, external_port), lifetime_ret);\n+    } else {\n+        return MappingError::NETWORK_ERROR;\n+    }\n+}\n+\n+std::variant<MappingResult, MappingError> PCPRequestPortMap(const PCPMappingNonce &nonce, const CNetAddr &gateway, const CNetAddr &bind, uint16_t port, uint32_t lifetime, int num_tries, std::chrono::milliseconds timeout_per_try)\n+{\n+    struct sockaddr_storage dest_addr, bind_addr;\n+    socklen_t dest_addrlen = sizeof(struct sockaddr_storage), bind_addrlen = sizeof(struct sockaddr_storage);\n+\n+    LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"pcp: Requesting port mapping for addr %s port %d from gateway %s\\n\", bind.ToStringAddr(), port, gateway.ToStringAddr());\n+\n+    // Validate addresses, make sure they're the same network family.\n+    if (!CService(gateway, PCP_SERVER_PORT).GetSockAddr((struct sockaddr*)&dest_addr, &dest_addrlen)) return MappingError::NETWORK_ERROR;\n+    if (!CService(bind, 0).GetSockAddr((struct sockaddr*)&bind_addr, &bind_addrlen)) return MappingError::NETWORK_ERROR;\n+    if (dest_addr.ss_family != bind_addr.ss_family) return MappingError::NETWORK_ERROR;\n+\n+    // Create UDP socket (IPv4 or IPv6 based on provided gateway).\n+    auto sock{CreateSock(dest_addr.ss_family, SOCK_DGRAM, IPPROTO_UDP)};\n+    if (!sock) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp: Could not create UDP socket: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Make sure that we send from requested destination address, anything else will be\n+    // rejected by a security-conscious router.\n+    if (sock->Bind((struct sockaddr*)&bind_addr, bind_addrlen) != 0) {",
      "path": "src/util/pcp.cpp",
      "position": 408,
      "original_position": 408,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "23916f2a7717b463799207b4b81b5795f2e9d7e3",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I wonder why the difference with `NATPMPRequestPortMap()` where we `Connect()` (without `Bind()`) and retrieve the local address from the socket.\r\n\r\nMy understanding is that both NAT-PMP and PCP servers will reject mapping requests for one address coming from another address.",
      "created_at": "2024-06-27T13:42:13Z",
      "updated_at": "2024-06-28T15:24:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1657164986",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1657164986"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": 406,
      "original_start_line": 406,
      "start_side": "RIGHT",
      "line": 408,
      "original_line": 408,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1657261790",
      "pull_request_review_id": 2141814858,
      "id": 1657261790,
      "node_id": "PRRC_kwDOABII585ix87e",
      "diff_hunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/pcp.h>\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <span.h>\n+#include <util/check.h>\n+#include <util/netif.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+namespace {\n+\n+// RFC6886 NAT-PMP and RFC6887 Port Control Protocol (PCP) implementation.\n+// NAT-PMP and PCP use network byte order (big-endian).\n+\n+// NAT-PMP (v0) protocol constants.\n+//! NAT-PMP uses a fixed server port number (RFC6887 section 1.1).\n+constexpr uint16_t NATPMP_SERVER_PORT = 5351;\n+//! Version byte for NATPMP (RFC6886 1.1)\n+constexpr uint8_t NATPMP_VERSION = 0;\n+//! Request opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_REQUEST = 0x00;\n+//! Response opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_RESPONSE = 0x80;\n+//! Get external address (RFC6886 3.2)\n+constexpr uint8_t NATPMP_OP_GETEXTERNAL = 0x00;\n+//! Map TCP port (RFC6886 3.3)\n+constexpr uint8_t NATPMP_OP_MAP_TCP = 0x02;\n+//! Shared request header size in bytes.\n+constexpr size_t NATPMP_REQUEST_HDR_SIZE = 2;\n+//! Shared response header (minimum) size in bytes.\n+constexpr size_t NATPMP_RESPONSE_HDR_SIZE = 8;\n+//! GETEXTERNAL request size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 0;\n+//! GETEXTERNAL response size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 4;\n+//! MAP request size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 10;\n+//! MAP response size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 8;\n+\n+// Shared header offsets (RFC6886 3.2, 3.3), relative to start of packet.\n+//!  Offset of version field in packets.\n+constexpr size_t NATPMP_HDR_VERSION_OFS = 0;\n+//!  Offset of opcode field in packets\n+constexpr size_t NATPMP_HDR_OP_OFS = 1;\n+//!  Offset of result code in packets. Result codes are 16 bit in NAT-PMP instead of 8 bit in PCP.\n+constexpr size_t NATPMP_RESPONSE_HDR_RESULT_OFS = 2;\n+\n+// GETEXTERNAL response offsets (RFC6886 3.2), relative to start of packet.\n+//!  Returned external address\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_IP_OFS = 8;\n+\n+// MAP request offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port to be mapped.\n+constexpr size_t NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS = 4;\n+//!  Suggested external port for mapping.\n+constexpr size_t NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS = 6;\n+//!  Requested port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_REQUEST_LIFETIME_OFS = 8;\n+\n+// MAP response offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port for mapping (will match internal port of request).\n+constexpr size_t NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS = 8;\n+//!  External port for mapping.\n+constexpr size_t NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS = 10;\n+//!  Created port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_RESPONSE_LIFETIME_OFS = 12;\n+\n+// Relevant NETPMP result codes (RFC6886 3.5).\n+//! Result code representing success status.\n+constexpr uint8_t NATPMP_RESULT_SUCCESS = 0;\n+//! Result code representing unsupported version.\n+constexpr uint8_t NATPMP_RESULT_UNSUPP_VERSION = 1;\n+//! Result code representing lack of resources.\n+constexpr uint8_t NATPMP_RESULT_NO_RESOURCES = 4;\n+\n+//! Mapping of NATPMP result code to string (RFC6886 3.5). Result codes <=2 match PCP.\n+const std::map<uint8_t, std::string> NATPMP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"NETWORK_FAILURE\"},\n+    {4,  \"NO_RESOURCES\"},\n+    {5,  \"UNSUPP_OPCODE\"},\n+};\n+\n+// PCP (v2) protocol constants.\n+//! Maximum packet size in bytes (RFC6887 section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (RFC6887 section 19.1). Shared with NAT-PMP.\n+constexpr uint16_t PCP_SERVER_PORT = NATPMP_SERVER_PORT;\n+//! Version byte. 0 is NAT-PMP (RFC6886), 1 is forbidden, 2 for PCP (RFC6887).\n+constexpr uint8_t PCP_VERSION = 2;\n+//! PCP Request Header. See RFC6887 section 7.1. Shared with NAT-PMP.\n+constexpr uint8_t PCP_REQUEST = NATPMP_REQUEST; // R = 0\n+//! PCP Response Header. See RFC6887 section 7.2. Shared with NAT-PMP.\n+constexpr uint8_t PCP_RESPONSE = NATPMP_RESPONSE; // R = 1\n+//! Map opcode. See RFC6887 section 19.2\n+constexpr uint8_t PCP_OP_MAP = 0x01;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Request and response header size in bytes (RFC6887 section 7.1).\n+constexpr size_t PCP_HDR_SIZE = 24;\n+//! Map request and response size in bytes (RFC6887 section 11.1).\n+constexpr size_t PCP_MAP_SIZE = 36;\n+\n+// Header offsets shared between request and responses (RFC6887 7.1, 7.2), relative to start of packet.\n+//!  Version field (1 byte).\n+constexpr size_t PCP_HDR_VERSION_OFS = NATPMP_HDR_VERSION_OFS;\n+//!  Opcode field (1 byte).\n+constexpr size_t PCP_HDR_OP_OFS = NATPMP_HDR_OP_OFS;\n+//!  Requested lifetime (request), granted lifetime (response) (2 bytes).\n+constexpr size_t PCP_HDR_LIFETIME_OFS = 4;\n+\n+// Request header offsets (RFC6887 7.1), relative to start of packet.\n+//!  PCP client's IP address (16 bytes).\n+constexpr size_t PCP_REQUEST_HDR_IP_OFS = 8;\n+\n+// Response header offsets (RFC6887 7.2), relative to start of packet.\n+//!  Result code (1 byte).\n+constexpr size_t PCP_RESPONSE_HDR_RESULT_OFS = 3;\n+\n+// MAP request/response offsets (RFC6887 11.1), relative to start of opcode-specific data.\n+//!  Mapping nonce (12 bytes).\n+constexpr size_t PCP_MAP_NONCE_OFS = 0;\n+//!  Protocol (1 byte).\n+constexpr size_t PCP_MAP_PROTOCOL_OFS = 12;\n+//!  Internal port for mapping (2 bytes).\n+constexpr size_t PCP_MAP_INTERNAL_PORT_OFS = 16;\n+//!  Suggested external port (request), assigned external port (response) (2 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_PORT_OFS = 18;\n+//!  Suggested external IP (request), assigned external IP (response) (16 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_IP_OFS = 20;\n+\n+//! Result code representing success (RFC6887 7.4), shared with NAT-PMP.\n+constexpr uint8_t PCP_RESULT_SUCCESS = NATPMP_RESULT_SUCCESS;\n+//! Result code representing lack of resources (RFC6887 7.4).\n+constexpr uint8_t PCP_RESULT_NO_RESOURCES = 8;\n+\n+//! Mapping of PCP result code to string (RFC6887 7.4). Result codes <=2 match NAT-PMP.\n+const std::map<uint8_t, std::string> PCP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"MALFORMED_REQUEST\"},\n+    {4,  \"UNSUPP_OPCODE\"},\n+    {5,  \"UNSUPP_OPTION\"},\n+    {6,  \"MALFORMED_OPTION\"},\n+    {7,  \"NETWORK_FAILURE\"},\n+    {8,  \"NO_RESOURCES\"},\n+    {9,  \"UNSUPP_PROTOCOL\"},\n+    {10, \"USER_EX_QUOTA\"},\n+    {11, \"CANNOT_PROVIDE_EXTERNAL\"},\n+    {12, \"ADDRESS_MISMATCH\"},\n+    {13, \"EXCESSIVE_REMOTE_PEER\"},\n+};\n+\n+//! Return human-readable string from NATPMP result code.\n+std::string NATPMPResultString(uint8_t result_code)\n+{\n+    auto result_i = NATPMP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == NATPMP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Return human-readable string from PCP result code.\n+std::string PCPResultString(uint8_t result_code)\n+{\n+    auto result_i = PCP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == PCP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Wrap address in IPv6 according to RFC6887. wrapped_addr needs to be able to store 16 bytes.\n+[[nodiscard]] bool PCPWrapAddress(Span<uint8_t> wrapped_addr, const CNetAddr &addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (addr.IsIPv4()) {\n+        struct in_addr addr4;\n+        if (!addr.GetInAddr(&addr4)) return false;\n+        // Section 5: \"When the address field holds an IPv4 address, an IPv4-mapped IPv6 address [RFC4291] is used (::ffff:0:0/96).\"\n+        std::memcpy(wrapped_addr.data(), IPV4_IN_IPV6_PREFIX.data(), IPV4_IN_IPV6_PREFIX.size());\n+        std::memcpy(wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), &addr4, ADDR_IPV4_SIZE);\n+        return true;\n+    } else if (addr.IsIPv6()) {\n+        struct in6_addr addr6;\n+        if (!addr.GetIn6Addr(&addr6)) return false;\n+        std::memcpy(wrapped_addr.data(), &addr6, ADDR_IPV6_SIZE);\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+//! Unwrap PCP-encoded address according to RFC6887.\n+CNetAddr PCPUnwrapAddress(Span<const uint8_t> wrapped_addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (util::HasPrefix(wrapped_addr, IPV4_IN_IPV6_PREFIX)) {\n+        struct in_addr addr4;\n+        std::memcpy(&addr4, wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), ADDR_IPV4_SIZE);\n+        return CNetAddr(addr4);\n+    } else {\n+        struct in6_addr addr6;\n+        std::memcpy(&addr6, wrapped_addr.data(), ADDR_IPV6_SIZE);\n+        return CNetAddr(addr6);\n+    }\n+}\n+\n+//! PCP or NAT-PMP send-receive loop.\n+std::optional<std::vector<uint8_t>> PCPSendRecv(Sock &sock, const std::string &protocol, Span<const uint8_t> request, int num_tries,\n+        std::chrono::milliseconds timeout_per_try,\n+        std::function<bool(Span<const uint8_t>)> check_packet)\n+{\n+    using namespace std::chrono;\n+    // UDP is a potentially lossy protocol, so we try to send again a few times.\n+    uint8_t response[PCP_MAX_SIZE];\n+    bool got_response = false;\n+    int recvsz = 0;\n+    for (int ntry = 0; !got_response && ntry < num_tries; ++ntry) {\n+        if (ntry > 0) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Retrying (%d)\\n\", protocol, ntry);\n+        }\n+        // Dispatch packet to gateway.\n+        if (sock.Send(request.data(), request.size(), 0) != static_cast<ssize_t>(request.size())) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not send request: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+            return std::nullopt; // Network-level error, probably no use retrying.\n+        }\n+\n+        // Wait for response(s) until we get a valid response, a network error, or time out.\n+        auto cur_time = time_point_cast<milliseconds>(steady_clock::now());\n+        auto deadline = cur_time + timeout_per_try;\n+        while ((cur_time = time_point_cast<milliseconds>(steady_clock::now())) < deadline) {\n+            Sock::Event occurred = 0;\n+            if (!sock.Wait(deadline - cur_time, Sock::RECV, &occurred)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not wait on socket: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            if (!occurred) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Timeout\\n\", protocol);\n+                break; // Retry.\n+            }\n+\n+            // Receive response.\n+            recvsz = sock.Recv(response, sizeof(response), MSG_DONTWAIT);\n+            if (recvsz < 0) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not receive response: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Received response of %d bytes: %s\\n\", protocol, recvsz, HexStr(Span(response, recvsz)));\n+\n+            if (check_packet(Span<uint8_t>(response, recvsz))) {\n+                got_response = true; // Got expected response, break from receive loop as well as from retry loop.\n+                break;\n+            }\n+        }\n+    }\n+    if (!got_response) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Giving up after %d tries\\n\", protocol, num_tries);\n+        return std::nullopt;\n+    }\n+    return std::vector<uint8_t>(response, response + recvsz);\n+}\n+\n+}\n+\n+std::variant<MappingResult, MappingError> NATPMPRequestPortMap(const CNetAddr &gateway, uint16_t port, uint32_t lifetime, int num_tries, std::chrono::milliseconds timeout_per_try)\n+{\n+    struct sockaddr_storage dest_addr;\n+    socklen_t dest_addrlen = sizeof(struct sockaddr_storage);\n+\n+    LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"natpmp: Requesting port mapping port %d from gateway %s\\n\", port, gateway.ToStringAddr());\n+\n+    // Validate gateway, make sure it's IPv4. NAT-PMP does not support IPv6.\n+    if (!CService(gateway, PCP_SERVER_PORT).GetSockAddr((struct sockaddr*)&dest_addr, &dest_addrlen)) return MappingError::NETWORK_ERROR;\n+    if (dest_addr.ss_family != AF_INET) return MappingError::NETWORK_ERROR;\n+\n+    // Create IPv4 UDP socket\n+    auto sock{CreateSock(AF_INET, SOCK_DGRAM, IPPROTO_UDP)};\n+    if (!sock) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Could not create UDP socket: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Associate UDP socket to gateway.\n+    if (sock->Connect((struct sockaddr*)&dest_addr, dest_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Could not connect to gateway: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Use getsockname to get the address toward the default gateway (the internal address).\n+    struct sockaddr_in internal;\n+    socklen_t internal_addrlen = sizeof(struct sockaddr_in);\n+    if (sock->GetSockName((struct sockaddr*)&internal, &internal_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Could not get sock name: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Request external IP address (RFC6886 section 3.2).\n+    std::vector<uint8_t> request(NATPMP_GETEXTERNAL_REQUEST_SIZE);\n+    request[NATPMP_HDR_VERSION_OFS] = NATPMP_VERSION;\n+    request[NATPMP_HDR_OP_OFS] = NATPMP_REQUEST | NATPMP_OP_GETEXTERNAL;\n+\n+    auto recv_res = PCPSendRecv(*sock, \"natpmp\", request, num_tries, timeout_per_try,\n+        [&](const Span<const uint8_t> response) -> bool {\n+            if (response.size() < NATPMP_GETEXTERNAL_RESPONSE_SIZE) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response too small\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            if (response[NATPMP_HDR_VERSION_OFS] != NATPMP_VERSION || response[NATPMP_HDR_OP_OFS] != (NATPMP_RESPONSE | NATPMP_OP_GETEXTERNAL)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response to wrong command\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            return true;\n+        });\n+\n+    struct in_addr external_addr;\n+    if (recv_res) {\n+        const std::span<const uint8_t> response = *recv_res;\n+\n+        Assume(response.size() >= NATPMP_GETEXTERNAL_RESPONSE_SIZE);\n+        uint16_t result_code = ReadBE16(response.data() + NATPMP_RESPONSE_HDR_RESULT_OFS);\n+        if (result_code != NATPMP_RESULT_SUCCESS) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Getting external address failed with result %s\\n\", NATPMPResultString(result_code));\n+            return MappingError::PROTOCOL_ERROR;\n+        }\n+\n+        std::memcpy(&external_addr, response.data() + NATPMP_GETEXTERNAL_RESPONSE_IP_OFS, ADDR_IPV4_SIZE);\n+    } else {\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Create TCP mapping request (RFC6886 section 3.3).\n+    request = std::vector<uint8_t>(NATPMP_MAP_REQUEST_SIZE);\n+    request[NATPMP_HDR_VERSION_OFS] = NATPMP_VERSION;\n+    request[NATPMP_HDR_OP_OFS] = NATPMP_REQUEST | NATPMP_OP_MAP_TCP;\n+    WriteBE16(request.data() + NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS, port);\n+    WriteBE16(request.data() + NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS, port);\n+    WriteBE32(request.data() + NATPMP_MAP_REQUEST_LIFETIME_OFS, lifetime);\n+\n+    recv_res = PCPSendRecv(*sock, \"natpmp\", request, num_tries, timeout_per_try,\n+        [&](const Span<const uint8_t> response) -> bool {\n+            if (response.size() < NATPMP_MAP_RESPONSE_SIZE) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response too small\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            if (response[0] != NATPMP_VERSION || response[1] != (NATPMP_RESPONSE | NATPMP_OP_MAP_TCP)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response to wrong command\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            uint16_t internal_port = ReadBE16(response.data() + NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS);\n+            if (internal_port != port) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response port doesn't match request\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            return true;\n+        });\n+\n+    if (recv_res) {\n+        const std::span<uint8_t> response = *recv_res;\n+\n+        Assume(response.size() >= NATPMP_MAP_RESPONSE_SIZE);\n+        uint16_t result_code = ReadBE16(response.data() + NATPMP_RESPONSE_HDR_RESULT_OFS);\n+        if (result_code != NATPMP_RESULT_SUCCESS) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Port mapping failed with result %s\\n\", NATPMPResultString(result_code));\n+            if (result_code == NATPMP_RESULT_NO_RESOURCES) {\n+                return MappingError::NO_RESOURCES;\n+            }\n+            return MappingError::PROTOCOL_ERROR;\n+        }\n+\n+        uint32_t lifetime_ret = ReadBE32(response.data() + NATPMP_MAP_RESPONSE_LIFETIME_OFS);\n+        uint16_t external_port = ReadBE16(response.data() + NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS);\n+        return MappingResult(NATPMP_VERSION, CService(internal.sin_addr, port), CService(external_addr, external_port), lifetime_ret);\n+    } else {\n+        return MappingError::NETWORK_ERROR;\n+    }\n+}\n+\n+std::variant<MappingResult, MappingError> PCPRequestPortMap(const PCPMappingNonce &nonce, const CNetAddr &gateway, const CNetAddr &bind, uint16_t port, uint32_t lifetime, int num_tries, std::chrono::milliseconds timeout_per_try)\n+{\n+    struct sockaddr_storage dest_addr, bind_addr;\n+    socklen_t dest_addrlen = sizeof(struct sockaddr_storage), bind_addrlen = sizeof(struct sockaddr_storage);\n+\n+    LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"pcp: Requesting port mapping for addr %s port %d from gateway %s\\n\", bind.ToStringAddr(), port, gateway.ToStringAddr());\n+\n+    // Validate addresses, make sure they're the same network family.\n+    if (!CService(gateway, PCP_SERVER_PORT).GetSockAddr((struct sockaddr*)&dest_addr, &dest_addrlen)) return MappingError::NETWORK_ERROR;\n+    if (!CService(bind, 0).GetSockAddr((struct sockaddr*)&bind_addr, &bind_addrlen)) return MappingError::NETWORK_ERROR;\n+    if (dest_addr.ss_family != bind_addr.ss_family) return MappingError::NETWORK_ERROR;\n+\n+    // Create UDP socket (IPv4 or IPv6 based on provided gateway).\n+    auto sock{CreateSock(dest_addr.ss_family, SOCK_DGRAM, IPPROTO_UDP)};\n+    if (!sock) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp: Could not create UDP socket: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Make sure that we send from requested destination address, anything else will be\n+    // rejected by a security-conscious router.\n+    if (sock->Bind((struct sockaddr*)&bind_addr, bind_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp: Could not bind to address: %s\\n\", NetworkErrorString(WSAGetLastError()));",
      "path": "src/util/pcp.cpp",
      "position": 409,
      "original_position": 409,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "23916f2a7717b463799207b4b81b5795f2e9d7e3",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Maybe worth logging `bind.ToStringAddr()` here and `gateway.ToStringAddr()` below if `Connect()` fails.",
      "created_at": "2024-06-27T14:38:00Z",
      "updated_at": "2024-06-28T15:24:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1657261790",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1657261790"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 409,
      "original_line": 409,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1657447061",
      "pull_request_review_id": 2141814858,
      "id": 1657447061,
      "node_id": "PRRC_kwDOABII585iyqKV",
      "diff_hunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/pcp.h>\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <span.h>\n+#include <util/check.h>\n+#include <util/netif.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+namespace {\n+\n+// RFC6886 NAT-PMP and RFC6887 Port Control Protocol (PCP) implementation.\n+// NAT-PMP and PCP use network byte order (big-endian).\n+\n+// NAT-PMP (v0) protocol constants.\n+//! NAT-PMP uses a fixed server port number (RFC6887 section 1.1).\n+constexpr uint16_t NATPMP_SERVER_PORT = 5351;\n+//! Version byte for NATPMP (RFC6886 1.1)\n+constexpr uint8_t NATPMP_VERSION = 0;\n+//! Request opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_REQUEST = 0x00;\n+//! Response opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_RESPONSE = 0x80;\n+//! Get external address (RFC6886 3.2)\n+constexpr uint8_t NATPMP_OP_GETEXTERNAL = 0x00;\n+//! Map TCP port (RFC6886 3.3)\n+constexpr uint8_t NATPMP_OP_MAP_TCP = 0x02;\n+//! Shared request header size in bytes.\n+constexpr size_t NATPMP_REQUEST_HDR_SIZE = 2;\n+//! Shared response header (minimum) size in bytes.\n+constexpr size_t NATPMP_RESPONSE_HDR_SIZE = 8;\n+//! GETEXTERNAL request size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 0;\n+//! GETEXTERNAL response size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 4;\n+//! MAP request size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 10;\n+//! MAP response size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 8;\n+\n+// Shared header offsets (RFC6886 3.2, 3.3), relative to start of packet.\n+//!  Offset of version field in packets.\n+constexpr size_t NATPMP_HDR_VERSION_OFS = 0;\n+//!  Offset of opcode field in packets\n+constexpr size_t NATPMP_HDR_OP_OFS = 1;\n+//!  Offset of result code in packets. Result codes are 16 bit in NAT-PMP instead of 8 bit in PCP.\n+constexpr size_t NATPMP_RESPONSE_HDR_RESULT_OFS = 2;\n+\n+// GETEXTERNAL response offsets (RFC6886 3.2), relative to start of packet.\n+//!  Returned external address\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_IP_OFS = 8;\n+\n+// MAP request offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port to be mapped.\n+constexpr size_t NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS = 4;\n+//!  Suggested external port for mapping.\n+constexpr size_t NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS = 6;\n+//!  Requested port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_REQUEST_LIFETIME_OFS = 8;\n+\n+// MAP response offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port for mapping (will match internal port of request).\n+constexpr size_t NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS = 8;\n+//!  External port for mapping.\n+constexpr size_t NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS = 10;\n+//!  Created port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_RESPONSE_LIFETIME_OFS = 12;\n+\n+// Relevant NETPMP result codes (RFC6886 3.5).\n+//! Result code representing success status.\n+constexpr uint8_t NATPMP_RESULT_SUCCESS = 0;\n+//! Result code representing unsupported version.\n+constexpr uint8_t NATPMP_RESULT_UNSUPP_VERSION = 1;\n+//! Result code representing lack of resources.\n+constexpr uint8_t NATPMP_RESULT_NO_RESOURCES = 4;\n+\n+//! Mapping of NATPMP result code to string (RFC6886 3.5). Result codes <=2 match PCP.\n+const std::map<uint8_t, std::string> NATPMP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"NETWORK_FAILURE\"},\n+    {4,  \"NO_RESOURCES\"},\n+    {5,  \"UNSUPP_OPCODE\"},\n+};\n+\n+// PCP (v2) protocol constants.\n+//! Maximum packet size in bytes (RFC6887 section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (RFC6887 section 19.1). Shared with NAT-PMP.\n+constexpr uint16_t PCP_SERVER_PORT = NATPMP_SERVER_PORT;\n+//! Version byte. 0 is NAT-PMP (RFC6886), 1 is forbidden, 2 for PCP (RFC6887).\n+constexpr uint8_t PCP_VERSION = 2;\n+//! PCP Request Header. See RFC6887 section 7.1. Shared with NAT-PMP.\n+constexpr uint8_t PCP_REQUEST = NATPMP_REQUEST; // R = 0\n+//! PCP Response Header. See RFC6887 section 7.2. Shared with NAT-PMP.\n+constexpr uint8_t PCP_RESPONSE = NATPMP_RESPONSE; // R = 1\n+//! Map opcode. See RFC6887 section 19.2\n+constexpr uint8_t PCP_OP_MAP = 0x01;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Request and response header size in bytes (RFC6887 section 7.1).\n+constexpr size_t PCP_HDR_SIZE = 24;\n+//! Map request and response size in bytes (RFC6887 section 11.1).\n+constexpr size_t PCP_MAP_SIZE = 36;\n+\n+// Header offsets shared between request and responses (RFC6887 7.1, 7.2), relative to start of packet.\n+//!  Version field (1 byte).\n+constexpr size_t PCP_HDR_VERSION_OFS = NATPMP_HDR_VERSION_OFS;\n+//!  Opcode field (1 byte).\n+constexpr size_t PCP_HDR_OP_OFS = NATPMP_HDR_OP_OFS;\n+//!  Requested lifetime (request), granted lifetime (response) (2 bytes).\n+constexpr size_t PCP_HDR_LIFETIME_OFS = 4;\n+\n+// Request header offsets (RFC6887 7.1), relative to start of packet.\n+//!  PCP client's IP address (16 bytes).\n+constexpr size_t PCP_REQUEST_HDR_IP_OFS = 8;\n+\n+// Response header offsets (RFC6887 7.2), relative to start of packet.\n+//!  Result code (1 byte).\n+constexpr size_t PCP_RESPONSE_HDR_RESULT_OFS = 3;\n+\n+// MAP request/response offsets (RFC6887 11.1), relative to start of opcode-specific data.\n+//!  Mapping nonce (12 bytes).\n+constexpr size_t PCP_MAP_NONCE_OFS = 0;\n+//!  Protocol (1 byte).\n+constexpr size_t PCP_MAP_PROTOCOL_OFS = 12;\n+//!  Internal port for mapping (2 bytes).\n+constexpr size_t PCP_MAP_INTERNAL_PORT_OFS = 16;\n+//!  Suggested external port (request), assigned external port (response) (2 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_PORT_OFS = 18;\n+//!  Suggested external IP (request), assigned external IP (response) (16 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_IP_OFS = 20;\n+\n+//! Result code representing success (RFC6887 7.4), shared with NAT-PMP.\n+constexpr uint8_t PCP_RESULT_SUCCESS = NATPMP_RESULT_SUCCESS;\n+//! Result code representing lack of resources (RFC6887 7.4).\n+constexpr uint8_t PCP_RESULT_NO_RESOURCES = 8;\n+\n+//! Mapping of PCP result code to string (RFC6887 7.4). Result codes <=2 match NAT-PMP.\n+const std::map<uint8_t, std::string> PCP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"MALFORMED_REQUEST\"},\n+    {4,  \"UNSUPP_OPCODE\"},\n+    {5,  \"UNSUPP_OPTION\"},\n+    {6,  \"MALFORMED_OPTION\"},\n+    {7,  \"NETWORK_FAILURE\"},\n+    {8,  \"NO_RESOURCES\"},\n+    {9,  \"UNSUPP_PROTOCOL\"},\n+    {10, \"USER_EX_QUOTA\"},\n+    {11, \"CANNOT_PROVIDE_EXTERNAL\"},\n+    {12, \"ADDRESS_MISMATCH\"},\n+    {13, \"EXCESSIVE_REMOTE_PEER\"},\n+};\n+\n+//! Return human-readable string from NATPMP result code.\n+std::string NATPMPResultString(uint8_t result_code)\n+{\n+    auto result_i = NATPMP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == NATPMP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Return human-readable string from PCP result code.\n+std::string PCPResultString(uint8_t result_code)\n+{\n+    auto result_i = PCP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == PCP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Wrap address in IPv6 according to RFC6887. wrapped_addr needs to be able to store 16 bytes.\n+[[nodiscard]] bool PCPWrapAddress(Span<uint8_t> wrapped_addr, const CNetAddr &addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (addr.IsIPv4()) {\n+        struct in_addr addr4;\n+        if (!addr.GetInAddr(&addr4)) return false;\n+        // Section 5: \"When the address field holds an IPv4 address, an IPv4-mapped IPv6 address [RFC4291] is used (::ffff:0:0/96).\"\n+        std::memcpy(wrapped_addr.data(), IPV4_IN_IPV6_PREFIX.data(), IPV4_IN_IPV6_PREFIX.size());\n+        std::memcpy(wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), &addr4, ADDR_IPV4_SIZE);\n+        return true;\n+    } else if (addr.IsIPv6()) {\n+        struct in6_addr addr6;\n+        if (!addr.GetIn6Addr(&addr6)) return false;\n+        std::memcpy(wrapped_addr.data(), &addr6, ADDR_IPV6_SIZE);\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+//! Unwrap PCP-encoded address according to RFC6887.\n+CNetAddr PCPUnwrapAddress(Span<const uint8_t> wrapped_addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (util::HasPrefix(wrapped_addr, IPV4_IN_IPV6_PREFIX)) {\n+        struct in_addr addr4;\n+        std::memcpy(&addr4, wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), ADDR_IPV4_SIZE);\n+        return CNetAddr(addr4);\n+    } else {\n+        struct in6_addr addr6;\n+        std::memcpy(&addr6, wrapped_addr.data(), ADDR_IPV6_SIZE);\n+        return CNetAddr(addr6);\n+    }\n+}\n+\n+//! PCP or NAT-PMP send-receive loop.\n+std::optional<std::vector<uint8_t>> PCPSendRecv(Sock &sock, const std::string &protocol, Span<const uint8_t> request, int num_tries,\n+        std::chrono::milliseconds timeout_per_try,\n+        std::function<bool(Span<const uint8_t>)> check_packet)\n+{\n+    using namespace std::chrono;\n+    // UDP is a potentially lossy protocol, so we try to send again a few times.\n+    uint8_t response[PCP_MAX_SIZE];\n+    bool got_response = false;\n+    int recvsz = 0;\n+    for (int ntry = 0; !got_response && ntry < num_tries; ++ntry) {\n+        if (ntry > 0) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Retrying (%d)\\n\", protocol, ntry);\n+        }\n+        // Dispatch packet to gateway.\n+        if (sock.Send(request.data(), request.size(), 0) != static_cast<ssize_t>(request.size())) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not send request: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+            return std::nullopt; // Network-level error, probably no use retrying.\n+        }\n+\n+        // Wait for response(s) until we get a valid response, a network error, or time out.\n+        auto cur_time = time_point_cast<milliseconds>(steady_clock::now());\n+        auto deadline = cur_time + timeout_per_try;\n+        while ((cur_time = time_point_cast<milliseconds>(steady_clock::now())) < deadline) {\n+            Sock::Event occurred = 0;\n+            if (!sock.Wait(deadline - cur_time, Sock::RECV, &occurred)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not wait on socket: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            if (!occurred) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Timeout\\n\", protocol);\n+                break; // Retry.\n+            }\n+\n+            // Receive response.\n+            recvsz = sock.Recv(response, sizeof(response), MSG_DONTWAIT);\n+            if (recvsz < 0) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not receive response: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Received response of %d bytes: %s\\n\", protocol, recvsz, HexStr(Span(response, recvsz)));\n+\n+            if (check_packet(Span<uint8_t>(response, recvsz))) {\n+                got_response = true; // Got expected response, break from receive loop as well as from retry loop.\n+                break;\n+            }\n+        }\n+    }\n+    if (!got_response) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Giving up after %d tries\\n\", protocol, num_tries);\n+        return std::nullopt;\n+    }\n+    return std::vector<uint8_t>(response, response + recvsz);\n+}\n+\n+}\n+\n+std::variant<MappingResult, MappingError> NATPMPRequestPortMap(const CNetAddr &gateway, uint16_t port, uint32_t lifetime, int num_tries, std::chrono::milliseconds timeout_per_try)\n+{\n+    struct sockaddr_storage dest_addr;\n+    socklen_t dest_addrlen = sizeof(struct sockaddr_storage);\n+\n+    LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"natpmp: Requesting port mapping port %d from gateway %s\\n\", port, gateway.ToStringAddr());\n+\n+    // Validate gateway, make sure it's IPv4. NAT-PMP does not support IPv6.\n+    if (!CService(gateway, PCP_SERVER_PORT).GetSockAddr((struct sockaddr*)&dest_addr, &dest_addrlen)) return MappingError::NETWORK_ERROR;\n+    if (dest_addr.ss_family != AF_INET) return MappingError::NETWORK_ERROR;\n+\n+    // Create IPv4 UDP socket\n+    auto sock{CreateSock(AF_INET, SOCK_DGRAM, IPPROTO_UDP)};\n+    if (!sock) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Could not create UDP socket: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Associate UDP socket to gateway.\n+    if (sock->Connect((struct sockaddr*)&dest_addr, dest_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Could not connect to gateway: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Use getsockname to get the address toward the default gateway (the internal address).\n+    struct sockaddr_in internal;\n+    socklen_t internal_addrlen = sizeof(struct sockaddr_in);\n+    if (sock->GetSockName((struct sockaddr*)&internal, &internal_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Could not get sock name: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Request external IP address (RFC6886 section 3.2).\n+    std::vector<uint8_t> request(NATPMP_GETEXTERNAL_REQUEST_SIZE);\n+    request[NATPMP_HDR_VERSION_OFS] = NATPMP_VERSION;\n+    request[NATPMP_HDR_OP_OFS] = NATPMP_REQUEST | NATPMP_OP_GETEXTERNAL;\n+\n+    auto recv_res = PCPSendRecv(*sock, \"natpmp\", request, num_tries, timeout_per_try,\n+        [&](const Span<const uint8_t> response) -> bool {\n+            if (response.size() < NATPMP_GETEXTERNAL_RESPONSE_SIZE) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response too small\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            if (response[NATPMP_HDR_VERSION_OFS] != NATPMP_VERSION || response[NATPMP_HDR_OP_OFS] != (NATPMP_RESPONSE | NATPMP_OP_GETEXTERNAL)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response to wrong command\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            return true;\n+        });\n+\n+    struct in_addr external_addr;\n+    if (recv_res) {\n+        const std::span<const uint8_t> response = *recv_res;\n+\n+        Assume(response.size() >= NATPMP_GETEXTERNAL_RESPONSE_SIZE);\n+        uint16_t result_code = ReadBE16(response.data() + NATPMP_RESPONSE_HDR_RESULT_OFS);\n+        if (result_code != NATPMP_RESULT_SUCCESS) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Getting external address failed with result %s\\n\", NATPMPResultString(result_code));\n+            return MappingError::PROTOCOL_ERROR;\n+        }\n+\n+        std::memcpy(&external_addr, response.data() + NATPMP_GETEXTERNAL_RESPONSE_IP_OFS, ADDR_IPV4_SIZE);\n+    } else {\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Create TCP mapping request (RFC6886 section 3.3).\n+    request = std::vector<uint8_t>(NATPMP_MAP_REQUEST_SIZE);\n+    request[NATPMP_HDR_VERSION_OFS] = NATPMP_VERSION;\n+    request[NATPMP_HDR_OP_OFS] = NATPMP_REQUEST | NATPMP_OP_MAP_TCP;\n+    WriteBE16(request.data() + NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS, port);\n+    WriteBE16(request.data() + NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS, port);\n+    WriteBE32(request.data() + NATPMP_MAP_REQUEST_LIFETIME_OFS, lifetime);\n+\n+    recv_res = PCPSendRecv(*sock, \"natpmp\", request, num_tries, timeout_per_try,\n+        [&](const Span<const uint8_t> response) -> bool {\n+            if (response.size() < NATPMP_MAP_RESPONSE_SIZE) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response too small\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            if (response[0] != NATPMP_VERSION || response[1] != (NATPMP_RESPONSE | NATPMP_OP_MAP_TCP)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response to wrong command\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            uint16_t internal_port = ReadBE16(response.data() + NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS);\n+            if (internal_port != port) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response port doesn't match request\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            return true;\n+        });\n+\n+    if (recv_res) {\n+        const std::span<uint8_t> response = *recv_res;\n+\n+        Assume(response.size() >= NATPMP_MAP_RESPONSE_SIZE);\n+        uint16_t result_code = ReadBE16(response.data() + NATPMP_RESPONSE_HDR_RESULT_OFS);\n+        if (result_code != NATPMP_RESULT_SUCCESS) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Port mapping failed with result %s\\n\", NATPMPResultString(result_code));\n+            if (result_code == NATPMP_RESULT_NO_RESOURCES) {\n+                return MappingError::NO_RESOURCES;\n+            }\n+            return MappingError::PROTOCOL_ERROR;\n+        }\n+\n+        uint32_t lifetime_ret = ReadBE32(response.data() + NATPMP_MAP_RESPONSE_LIFETIME_OFS);\n+        uint16_t external_port = ReadBE16(response.data() + NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS);\n+        return MappingResult(NATPMP_VERSION, CService(internal.sin_addr, port), CService(external_addr, external_port), lifetime_ret);\n+    } else {\n+        return MappingError::NETWORK_ERROR;\n+    }\n+}\n+\n+std::variant<MappingResult, MappingError> PCPRequestPortMap(const PCPMappingNonce &nonce, const CNetAddr &gateway, const CNetAddr &bind, uint16_t port, uint32_t lifetime, int num_tries, std::chrono::milliseconds timeout_per_try)\n+{\n+    struct sockaddr_storage dest_addr, bind_addr;\n+    socklen_t dest_addrlen = sizeof(struct sockaddr_storage), bind_addrlen = sizeof(struct sockaddr_storage);\n+\n+    LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"pcp: Requesting port mapping for addr %s port %d from gateway %s\\n\", bind.ToStringAddr(), port, gateway.ToStringAddr());\n+\n+    // Validate addresses, make sure they're the same network family.\n+    if (!CService(gateway, PCP_SERVER_PORT).GetSockAddr((struct sockaddr*)&dest_addr, &dest_addrlen)) return MappingError::NETWORK_ERROR;\n+    if (!CService(bind, 0).GetSockAddr((struct sockaddr*)&bind_addr, &bind_addrlen)) return MappingError::NETWORK_ERROR;\n+    if (dest_addr.ss_family != bind_addr.ss_family) return MappingError::NETWORK_ERROR;\n+\n+    // Create UDP socket (IPv4 or IPv6 based on provided gateway).\n+    auto sock{CreateSock(dest_addr.ss_family, SOCK_DGRAM, IPPROTO_UDP)};\n+    if (!sock) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp: Could not create UDP socket: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Make sure that we send from requested destination address, anything else will be\n+    // rejected by a security-conscious router.\n+    if (sock->Bind((struct sockaddr*)&bind_addr, bind_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp: Could not bind to address: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Associate UDP socket to gateway.\n+    if (sock->Connect((struct sockaddr*)&dest_addr, dest_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp: Could not connect to gateway: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Use getsockname to get the address toward the default gateway (the internal address),\n+    // in case we don't know what address to map\n+    // (this is only needed if bind is INADDR_ANY, but it doesn't hurt as an extra check).\n+    struct sockaddr_storage internal_addr;\n+    socklen_t internal_addrlen = sizeof(struct sockaddr_storage);\n+    if (sock->GetSockName((struct sockaddr*)&internal_addr, &internal_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp: Could not get sock name: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+    CService internal;\n+    if (!internal.SetSockAddr((struct sockaddr*)&internal_addr)) return MappingError::NETWORK_ERROR;\n+    LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"pcp: Internal address after connect: %s\\n\", internal.ToStringAddr());\n+\n+    // Build request packet. Make sure the packet is zeroed so that reserved fields are zero\n+    // as required by the spec (and not potentially leak data).\n+    // Make sure there's space for the request header and MAP specific request data.\n+    std::vector<uint8_t> request(PCP_HDR_SIZE + PCP_MAP_SIZE);\n+    // Fill in request header, See RFC6887 Figure 2.\n+    size_t ofs = 0;\n+    request[ofs + PCP_HDR_VERSION_OFS] = PCP_VERSION;\n+    request[ofs + PCP_HDR_OP_OFS] = PCP_REQUEST | PCP_OP_MAP;\n+    WriteBE32(request.data() + ofs + PCP_HDR_LIFETIME_OFS, lifetime);\n+    if (!PCPWrapAddress(Span(request).subspan(ofs + PCP_REQUEST_HDR_IP_OFS, ADDR_IPV6_SIZE), internal)) return MappingError::NETWORK_ERROR;\n+\n+    ofs += PCP_HDR_SIZE;\n+\n+    // Fill in MAP request packet, See RFC6887 Figure 9.\n+    // Randomize mapping nonce (this is repeated in the response, to be able to\n+    // correlate requests and responses, and used to authenticate changes to the mapping).",
      "path": "src/util/pcp.cpp",
      "position": 447,
      "original_position": 447,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "23916f2a7717b463799207b4b81b5795f2e9d7e3",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Correlating responses to requests is at odds with the description in [section 6](https://www.rfc-editor.org/rfc/rfc6887#section-6):\r\n\r\n> ... the message flows can be viewed as two somewhat independent streams ... These two message flows are loosely correlated ... The PCP server can send unsolicited responses to clients ... This design goal helps explain why PCP request and response messages have no transaction ID ...\r\n\r\nAccording to the last paragraph in [section 11.2](https://www.rfc-editor.org/rfc/rfc6887#section-11.2) the nonce is used to distinguish different servers and to do some lame form of authentication :disappointed:. We use the same nonce for all requests to the same server.\r\n\r\nI guess just update the comment to omit \"to be able to correlate requests and responses\".",
      "created_at": "2024-06-27T16:29:37Z",
      "updated_at": "2024-06-28T15:24:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1657447061",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1657447061"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": 446,
      "original_start_line": 446,
      "start_side": "RIGHT",
      "line": 447,
      "original_line": 447,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1658485708",
      "pull_request_review_id": 2141814858,
      "id": 1658485708,
      "node_id": "PRRC_kwDOABII585i2nvM",
      "diff_hunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/pcp.h>\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <span.h>\n+#include <util/check.h>\n+#include <util/netif.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+namespace {\n+\n+// RFC6886 NAT-PMP and RFC6887 Port Control Protocol (PCP) implementation.\n+// NAT-PMP and PCP use network byte order (big-endian).\n+\n+// NAT-PMP (v0) protocol constants.\n+//! NAT-PMP uses a fixed server port number (RFC6887 section 1.1).\n+constexpr uint16_t NATPMP_SERVER_PORT = 5351;\n+//! Version byte for NATPMP (RFC6886 1.1)\n+constexpr uint8_t NATPMP_VERSION = 0;\n+//! Request opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_REQUEST = 0x00;\n+//! Response opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_RESPONSE = 0x80;\n+//! Get external address (RFC6886 3.2)\n+constexpr uint8_t NATPMP_OP_GETEXTERNAL = 0x00;\n+//! Map TCP port (RFC6886 3.3)\n+constexpr uint8_t NATPMP_OP_MAP_TCP = 0x02;\n+//! Shared request header size in bytes.\n+constexpr size_t NATPMP_REQUEST_HDR_SIZE = 2;\n+//! Shared response header (minimum) size in bytes.\n+constexpr size_t NATPMP_RESPONSE_HDR_SIZE = 8;\n+//! GETEXTERNAL request size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 0;\n+//! GETEXTERNAL response size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 4;\n+//! MAP request size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 10;\n+//! MAP response size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 8;\n+\n+// Shared header offsets (RFC6886 3.2, 3.3), relative to start of packet.\n+//!  Offset of version field in packets.\n+constexpr size_t NATPMP_HDR_VERSION_OFS = 0;\n+//!  Offset of opcode field in packets\n+constexpr size_t NATPMP_HDR_OP_OFS = 1;\n+//!  Offset of result code in packets. Result codes are 16 bit in NAT-PMP instead of 8 bit in PCP.\n+constexpr size_t NATPMP_RESPONSE_HDR_RESULT_OFS = 2;\n+\n+// GETEXTERNAL response offsets (RFC6886 3.2), relative to start of packet.\n+//!  Returned external address\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_IP_OFS = 8;\n+\n+// MAP request offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port to be mapped.\n+constexpr size_t NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS = 4;\n+//!  Suggested external port for mapping.\n+constexpr size_t NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS = 6;\n+//!  Requested port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_REQUEST_LIFETIME_OFS = 8;\n+\n+// MAP response offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port for mapping (will match internal port of request).\n+constexpr size_t NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS = 8;\n+//!  External port for mapping.\n+constexpr size_t NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS = 10;\n+//!  Created port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_RESPONSE_LIFETIME_OFS = 12;\n+\n+// Relevant NETPMP result codes (RFC6886 3.5).\n+//! Result code representing success status.\n+constexpr uint8_t NATPMP_RESULT_SUCCESS = 0;\n+//! Result code representing unsupported version.\n+constexpr uint8_t NATPMP_RESULT_UNSUPP_VERSION = 1;\n+//! Result code representing lack of resources.\n+constexpr uint8_t NATPMP_RESULT_NO_RESOURCES = 4;\n+\n+//! Mapping of NATPMP result code to string (RFC6886 3.5). Result codes <=2 match PCP.\n+const std::map<uint8_t, std::string> NATPMP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"NETWORK_FAILURE\"},\n+    {4,  \"NO_RESOURCES\"},\n+    {5,  \"UNSUPP_OPCODE\"},\n+};\n+\n+// PCP (v2) protocol constants.\n+//! Maximum packet size in bytes (RFC6887 section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (RFC6887 section 19.1). Shared with NAT-PMP.\n+constexpr uint16_t PCP_SERVER_PORT = NATPMP_SERVER_PORT;\n+//! Version byte. 0 is NAT-PMP (RFC6886), 1 is forbidden, 2 for PCP (RFC6887).\n+constexpr uint8_t PCP_VERSION = 2;\n+//! PCP Request Header. See RFC6887 section 7.1. Shared with NAT-PMP.\n+constexpr uint8_t PCP_REQUEST = NATPMP_REQUEST; // R = 0\n+//! PCP Response Header. See RFC6887 section 7.2. Shared with NAT-PMP.\n+constexpr uint8_t PCP_RESPONSE = NATPMP_RESPONSE; // R = 1\n+//! Map opcode. See RFC6887 section 19.2\n+constexpr uint8_t PCP_OP_MAP = 0x01;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Request and response header size in bytes (RFC6887 section 7.1).\n+constexpr size_t PCP_HDR_SIZE = 24;\n+//! Map request and response size in bytes (RFC6887 section 11.1).\n+constexpr size_t PCP_MAP_SIZE = 36;\n+\n+// Header offsets shared between request and responses (RFC6887 7.1, 7.2), relative to start of packet.\n+//!  Version field (1 byte).\n+constexpr size_t PCP_HDR_VERSION_OFS = NATPMP_HDR_VERSION_OFS;\n+//!  Opcode field (1 byte).\n+constexpr size_t PCP_HDR_OP_OFS = NATPMP_HDR_OP_OFS;\n+//!  Requested lifetime (request), granted lifetime (response) (2 bytes).\n+constexpr size_t PCP_HDR_LIFETIME_OFS = 4;\n+\n+// Request header offsets (RFC6887 7.1), relative to start of packet.\n+//!  PCP client's IP address (16 bytes).\n+constexpr size_t PCP_REQUEST_HDR_IP_OFS = 8;\n+\n+// Response header offsets (RFC6887 7.2), relative to start of packet.\n+//!  Result code (1 byte).\n+constexpr size_t PCP_RESPONSE_HDR_RESULT_OFS = 3;\n+\n+// MAP request/response offsets (RFC6887 11.1), relative to start of opcode-specific data.\n+//!  Mapping nonce (12 bytes).\n+constexpr size_t PCP_MAP_NONCE_OFS = 0;\n+//!  Protocol (1 byte).\n+constexpr size_t PCP_MAP_PROTOCOL_OFS = 12;\n+//!  Internal port for mapping (2 bytes).\n+constexpr size_t PCP_MAP_INTERNAL_PORT_OFS = 16;\n+//!  Suggested external port (request), assigned external port (response) (2 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_PORT_OFS = 18;\n+//!  Suggested external IP (request), assigned external IP (response) (16 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_IP_OFS = 20;\n+\n+//! Result code representing success (RFC6887 7.4), shared with NAT-PMP.\n+constexpr uint8_t PCP_RESULT_SUCCESS = NATPMP_RESULT_SUCCESS;\n+//! Result code representing lack of resources (RFC6887 7.4).\n+constexpr uint8_t PCP_RESULT_NO_RESOURCES = 8;\n+\n+//! Mapping of PCP result code to string (RFC6887 7.4). Result codes <=2 match NAT-PMP.\n+const std::map<uint8_t, std::string> PCP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"MALFORMED_REQUEST\"},\n+    {4,  \"UNSUPP_OPCODE\"},\n+    {5,  \"UNSUPP_OPTION\"},\n+    {6,  \"MALFORMED_OPTION\"},\n+    {7,  \"NETWORK_FAILURE\"},\n+    {8,  \"NO_RESOURCES\"},\n+    {9,  \"UNSUPP_PROTOCOL\"},\n+    {10, \"USER_EX_QUOTA\"},\n+    {11, \"CANNOT_PROVIDE_EXTERNAL\"},\n+    {12, \"ADDRESS_MISMATCH\"},\n+    {13, \"EXCESSIVE_REMOTE_PEER\"},\n+};\n+\n+//! Return human-readable string from NATPMP result code.\n+std::string NATPMPResultString(uint8_t result_code)\n+{\n+    auto result_i = NATPMP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == NATPMP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Return human-readable string from PCP result code.\n+std::string PCPResultString(uint8_t result_code)\n+{\n+    auto result_i = PCP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == PCP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Wrap address in IPv6 according to RFC6887. wrapped_addr needs to be able to store 16 bytes.\n+[[nodiscard]] bool PCPWrapAddress(Span<uint8_t> wrapped_addr, const CNetAddr &addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (addr.IsIPv4()) {\n+        struct in_addr addr4;\n+        if (!addr.GetInAddr(&addr4)) return false;\n+        // Section 5: \"When the address field holds an IPv4 address, an IPv4-mapped IPv6 address [RFC4291] is used (::ffff:0:0/96).\"\n+        std::memcpy(wrapped_addr.data(), IPV4_IN_IPV6_PREFIX.data(), IPV4_IN_IPV6_PREFIX.size());\n+        std::memcpy(wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), &addr4, ADDR_IPV4_SIZE);\n+        return true;\n+    } else if (addr.IsIPv6()) {\n+        struct in6_addr addr6;\n+        if (!addr.GetIn6Addr(&addr6)) return false;\n+        std::memcpy(wrapped_addr.data(), &addr6, ADDR_IPV6_SIZE);\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+//! Unwrap PCP-encoded address according to RFC6887.\n+CNetAddr PCPUnwrapAddress(Span<const uint8_t> wrapped_addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (util::HasPrefix(wrapped_addr, IPV4_IN_IPV6_PREFIX)) {\n+        struct in_addr addr4;\n+        std::memcpy(&addr4, wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), ADDR_IPV4_SIZE);\n+        return CNetAddr(addr4);\n+    } else {\n+        struct in6_addr addr6;\n+        std::memcpy(&addr6, wrapped_addr.data(), ADDR_IPV6_SIZE);\n+        return CNetAddr(addr6);\n+    }\n+}\n+\n+//! PCP or NAT-PMP send-receive loop.\n+std::optional<std::vector<uint8_t>> PCPSendRecv(Sock &sock, const std::string &protocol, Span<const uint8_t> request, int num_tries,\n+        std::chrono::milliseconds timeout_per_try,\n+        std::function<bool(Span<const uint8_t>)> check_packet)\n+{\n+    using namespace std::chrono;\n+    // UDP is a potentially lossy protocol, so we try to send again a few times.\n+    uint8_t response[PCP_MAX_SIZE];\n+    bool got_response = false;\n+    int recvsz = 0;\n+    for (int ntry = 0; !got_response && ntry < num_tries; ++ntry) {\n+        if (ntry > 0) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Retrying (%d)\\n\", protocol, ntry);\n+        }\n+        // Dispatch packet to gateway.\n+        if (sock.Send(request.data(), request.size(), 0) != static_cast<ssize_t>(request.size())) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not send request: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+            return std::nullopt; // Network-level error, probably no use retrying.\n+        }\n+\n+        // Wait for response(s) until we get a valid response, a network error, or time out.\n+        auto cur_time = time_point_cast<milliseconds>(steady_clock::now());\n+        auto deadline = cur_time + timeout_per_try;\n+        while ((cur_time = time_point_cast<milliseconds>(steady_clock::now())) < deadline) {\n+            Sock::Event occurred = 0;\n+            if (!sock.Wait(deadline - cur_time, Sock::RECV, &occurred)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not wait on socket: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            if (!occurred) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Timeout\\n\", protocol);\n+                break; // Retry.\n+            }\n+\n+            // Receive response.\n+            recvsz = sock.Recv(response, sizeof(response), MSG_DONTWAIT);\n+            if (recvsz < 0) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not receive response: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Received response of %d bytes: %s\\n\", protocol, recvsz, HexStr(Span(response, recvsz)));\n+\n+            if (check_packet(Span<uint8_t>(response, recvsz))) {\n+                got_response = true; // Got expected response, break from receive loop as well as from retry loop.\n+                break;\n+            }\n+        }\n+    }\n+    if (!got_response) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Giving up after %d tries\\n\", protocol, num_tries);\n+        return std::nullopt;\n+    }\n+    return std::vector<uint8_t>(response, response + recvsz);\n+}\n+\n+}\n+\n+std::variant<MappingResult, MappingError> NATPMPRequestPortMap(const CNetAddr &gateway, uint16_t port, uint32_t lifetime, int num_tries, std::chrono::milliseconds timeout_per_try)\n+{\n+    struct sockaddr_storage dest_addr;\n+    socklen_t dest_addrlen = sizeof(struct sockaddr_storage);\n+\n+    LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"natpmp: Requesting port mapping port %d from gateway %s\\n\", port, gateway.ToStringAddr());\n+\n+    // Validate gateway, make sure it's IPv4. NAT-PMP does not support IPv6.\n+    if (!CService(gateway, PCP_SERVER_PORT).GetSockAddr((struct sockaddr*)&dest_addr, &dest_addrlen)) return MappingError::NETWORK_ERROR;\n+    if (dest_addr.ss_family != AF_INET) return MappingError::NETWORK_ERROR;\n+\n+    // Create IPv4 UDP socket\n+    auto sock{CreateSock(AF_INET, SOCK_DGRAM, IPPROTO_UDP)};\n+    if (!sock) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Could not create UDP socket: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Associate UDP socket to gateway.\n+    if (sock->Connect((struct sockaddr*)&dest_addr, dest_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Could not connect to gateway: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Use getsockname to get the address toward the default gateway (the internal address).\n+    struct sockaddr_in internal;\n+    socklen_t internal_addrlen = sizeof(struct sockaddr_in);\n+    if (sock->GetSockName((struct sockaddr*)&internal, &internal_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Could not get sock name: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Request external IP address (RFC6886 section 3.2).\n+    std::vector<uint8_t> request(NATPMP_GETEXTERNAL_REQUEST_SIZE);\n+    request[NATPMP_HDR_VERSION_OFS] = NATPMP_VERSION;\n+    request[NATPMP_HDR_OP_OFS] = NATPMP_REQUEST | NATPMP_OP_GETEXTERNAL;\n+\n+    auto recv_res = PCPSendRecv(*sock, \"natpmp\", request, num_tries, timeout_per_try,\n+        [&](const Span<const uint8_t> response) -> bool {\n+            if (response.size() < NATPMP_GETEXTERNAL_RESPONSE_SIZE) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response too small\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            if (response[NATPMP_HDR_VERSION_OFS] != NATPMP_VERSION || response[NATPMP_HDR_OP_OFS] != (NATPMP_RESPONSE | NATPMP_OP_GETEXTERNAL)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response to wrong command\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            return true;\n+        });\n+\n+    struct in_addr external_addr;\n+    if (recv_res) {\n+        const std::span<const uint8_t> response = *recv_res;\n+\n+        Assume(response.size() >= NATPMP_GETEXTERNAL_RESPONSE_SIZE);\n+        uint16_t result_code = ReadBE16(response.data() + NATPMP_RESPONSE_HDR_RESULT_OFS);\n+        if (result_code != NATPMP_RESULT_SUCCESS) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Getting external address failed with result %s\\n\", NATPMPResultString(result_code));\n+            return MappingError::PROTOCOL_ERROR;\n+        }\n+\n+        std::memcpy(&external_addr, response.data() + NATPMP_GETEXTERNAL_RESPONSE_IP_OFS, ADDR_IPV4_SIZE);\n+    } else {\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Create TCP mapping request (RFC6886 section 3.3).\n+    request = std::vector<uint8_t>(NATPMP_MAP_REQUEST_SIZE);\n+    request[NATPMP_HDR_VERSION_OFS] = NATPMP_VERSION;\n+    request[NATPMP_HDR_OP_OFS] = NATPMP_REQUEST | NATPMP_OP_MAP_TCP;\n+    WriteBE16(request.data() + NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS, port);\n+    WriteBE16(request.data() + NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS, port);\n+    WriteBE32(request.data() + NATPMP_MAP_REQUEST_LIFETIME_OFS, lifetime);\n+\n+    recv_res = PCPSendRecv(*sock, \"natpmp\", request, num_tries, timeout_per_try,\n+        [&](const Span<const uint8_t> response) -> bool {\n+            if (response.size() < NATPMP_MAP_RESPONSE_SIZE) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response too small\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            if (response[0] != NATPMP_VERSION || response[1] != (NATPMP_RESPONSE | NATPMP_OP_MAP_TCP)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response to wrong command\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            uint16_t internal_port = ReadBE16(response.data() + NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS);\n+            if (internal_port != port) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response port doesn't match request\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            return true;\n+        });\n+\n+    if (recv_res) {\n+        const std::span<uint8_t> response = *recv_res;\n+\n+        Assume(response.size() >= NATPMP_MAP_RESPONSE_SIZE);\n+        uint16_t result_code = ReadBE16(response.data() + NATPMP_RESPONSE_HDR_RESULT_OFS);\n+        if (result_code != NATPMP_RESULT_SUCCESS) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Port mapping failed with result %s\\n\", NATPMPResultString(result_code));\n+            if (result_code == NATPMP_RESULT_NO_RESOURCES) {\n+                return MappingError::NO_RESOURCES;\n+            }\n+            return MappingError::PROTOCOL_ERROR;\n+        }\n+\n+        uint32_t lifetime_ret = ReadBE32(response.data() + NATPMP_MAP_RESPONSE_LIFETIME_OFS);\n+        uint16_t external_port = ReadBE16(response.data() + NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS);\n+        return MappingResult(NATPMP_VERSION, CService(internal.sin_addr, port), CService(external_addr, external_port), lifetime_ret);\n+    } else {\n+        return MappingError::NETWORK_ERROR;\n+    }\n+}\n+\n+std::variant<MappingResult, MappingError> PCPRequestPortMap(const PCPMappingNonce &nonce, const CNetAddr &gateway, const CNetAddr &bind, uint16_t port, uint32_t lifetime, int num_tries, std::chrono::milliseconds timeout_per_try)\n+{\n+    struct sockaddr_storage dest_addr, bind_addr;\n+    socklen_t dest_addrlen = sizeof(struct sockaddr_storage), bind_addrlen = sizeof(struct sockaddr_storage);\n+\n+    LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"pcp: Requesting port mapping for addr %s port %d from gateway %s\\n\", bind.ToStringAddr(), port, gateway.ToStringAddr());\n+\n+    // Validate addresses, make sure they're the same network family.\n+    if (!CService(gateway, PCP_SERVER_PORT).GetSockAddr((struct sockaddr*)&dest_addr, &dest_addrlen)) return MappingError::NETWORK_ERROR;\n+    if (!CService(bind, 0).GetSockAddr((struct sockaddr*)&bind_addr, &bind_addrlen)) return MappingError::NETWORK_ERROR;\n+    if (dest_addr.ss_family != bind_addr.ss_family) return MappingError::NETWORK_ERROR;\n+\n+    // Create UDP socket (IPv4 or IPv6 based on provided gateway).\n+    auto sock{CreateSock(dest_addr.ss_family, SOCK_DGRAM, IPPROTO_UDP)};\n+    if (!sock) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp: Could not create UDP socket: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Make sure that we send from requested destination address, anything else will be\n+    // rejected by a security-conscious router.\n+    if (sock->Bind((struct sockaddr*)&bind_addr, bind_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp: Could not bind to address: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Associate UDP socket to gateway.\n+    if (sock->Connect((struct sockaddr*)&dest_addr, dest_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp: Could not connect to gateway: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Use getsockname to get the address toward the default gateway (the internal address),\n+    // in case we don't know what address to map\n+    // (this is only needed if bind is INADDR_ANY, but it doesn't hurt as an extra check).\n+    struct sockaddr_storage internal_addr;\n+    socklen_t internal_addrlen = sizeof(struct sockaddr_storage);\n+    if (sock->GetSockName((struct sockaddr*)&internal_addr, &internal_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp: Could not get sock name: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+    CService internal;\n+    if (!internal.SetSockAddr((struct sockaddr*)&internal_addr)) return MappingError::NETWORK_ERROR;\n+    LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"pcp: Internal address after connect: %s\\n\", internal.ToStringAddr());\n+\n+    // Build request packet. Make sure the packet is zeroed so that reserved fields are zero\n+    // as required by the spec (and not potentially leak data).\n+    // Make sure there's space for the request header and MAP specific request data.\n+    std::vector<uint8_t> request(PCP_HDR_SIZE + PCP_MAP_SIZE);\n+    // Fill in request header, See RFC6887 Figure 2.\n+    size_t ofs = 0;\n+    request[ofs + PCP_HDR_VERSION_OFS] = PCP_VERSION;\n+    request[ofs + PCP_HDR_OP_OFS] = PCP_REQUEST | PCP_OP_MAP;\n+    WriteBE32(request.data() + ofs + PCP_HDR_LIFETIME_OFS, lifetime);\n+    if (!PCPWrapAddress(Span(request).subspan(ofs + PCP_REQUEST_HDR_IP_OFS, ADDR_IPV6_SIZE), internal)) return MappingError::NETWORK_ERROR;\n+\n+    ofs += PCP_HDR_SIZE;\n+\n+    // Fill in MAP request packet, See RFC6887 Figure 9.\n+    // Randomize mapping nonce (this is repeated in the response, to be able to\n+    // correlate requests and responses, and used to authenticate changes to the mapping).\n+    std::memcpy(request.data() + ofs + PCP_MAP_NONCE_OFS, nonce.data(), PCP_MAP_NONCE_SIZE);\n+    request[ofs + PCP_MAP_PROTOCOL_OFS] = PCP_PROTOCOL_TCP;\n+    WriteBE16(request.data() + ofs + PCP_MAP_INTERNAL_PORT_OFS, port);\n+    WriteBE16(request.data() + ofs + PCP_MAP_EXTERNAL_PORT_OFS, port);\n+    if (!PCPWrapAddress(Span(request).subspan(ofs + PCP_MAP_EXTERNAL_IP_OFS, ADDR_IPV6_SIZE), bind)) return MappingError::NETWORK_ERROR;",
      "path": "src/util/pcp.cpp",
      "position": 452,
      "original_position": 452,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "23916f2a7717b463799207b4b81b5795f2e9d7e3",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "https://www.rfc-editor.org/rfc/rfc6887#section-11.1\r\n\r\n>    Suggested External IP Address:  Suggested external IPv4 or IPv6\r\n      address.  This is useful for refreshing a mapping, especially\r\n      after the PCP server loses state.  If the PCP client does not know\r\n      the external address, or does not have a preference, it MUST use\r\n      the address-family-specific all-zeros address\r\n\r\nI think that we should not use `bind` for this. `bind` is a local address that we `bind(2)` to. Can't be the external address. I guess all-zeros is good enough.",
      "created_at": "2024-06-28T10:29:10Z",
      "updated_at": "2024-06-28T15:24:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1658485708",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1658485708"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 452,
      "original_line": 452,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1658498124",
      "pull_request_review_id": 2141814858,
      "id": 1658498124,
      "node_id": "PRRC_kwDOABII585i2qxM",
      "diff_hunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/pcp.h>\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <span.h>\n+#include <util/check.h>\n+#include <util/netif.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+namespace {\n+\n+// RFC6886 NAT-PMP and RFC6887 Port Control Protocol (PCP) implementation.\n+// NAT-PMP and PCP use network byte order (big-endian).\n+\n+// NAT-PMP (v0) protocol constants.\n+//! NAT-PMP uses a fixed server port number (RFC6887 section 1.1).\n+constexpr uint16_t NATPMP_SERVER_PORT = 5351;\n+//! Version byte for NATPMP (RFC6886 1.1)\n+constexpr uint8_t NATPMP_VERSION = 0;\n+//! Request opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_REQUEST = 0x00;\n+//! Response opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_RESPONSE = 0x80;\n+//! Get external address (RFC6886 3.2)\n+constexpr uint8_t NATPMP_OP_GETEXTERNAL = 0x00;\n+//! Map TCP port (RFC6886 3.3)\n+constexpr uint8_t NATPMP_OP_MAP_TCP = 0x02;\n+//! Shared request header size in bytes.\n+constexpr size_t NATPMP_REQUEST_HDR_SIZE = 2;\n+//! Shared response header (minimum) size in bytes.\n+constexpr size_t NATPMP_RESPONSE_HDR_SIZE = 8;\n+//! GETEXTERNAL request size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 0;\n+//! GETEXTERNAL response size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 4;\n+//! MAP request size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 10;\n+//! MAP response size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 8;\n+\n+// Shared header offsets (RFC6886 3.2, 3.3), relative to start of packet.\n+//!  Offset of version field in packets.\n+constexpr size_t NATPMP_HDR_VERSION_OFS = 0;\n+//!  Offset of opcode field in packets\n+constexpr size_t NATPMP_HDR_OP_OFS = 1;\n+//!  Offset of result code in packets. Result codes are 16 bit in NAT-PMP instead of 8 bit in PCP.\n+constexpr size_t NATPMP_RESPONSE_HDR_RESULT_OFS = 2;\n+\n+// GETEXTERNAL response offsets (RFC6886 3.2), relative to start of packet.\n+//!  Returned external address\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_IP_OFS = 8;\n+\n+// MAP request offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port to be mapped.\n+constexpr size_t NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS = 4;\n+//!  Suggested external port for mapping.\n+constexpr size_t NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS = 6;\n+//!  Requested port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_REQUEST_LIFETIME_OFS = 8;\n+\n+// MAP response offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port for mapping (will match internal port of request).\n+constexpr size_t NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS = 8;\n+//!  External port for mapping.\n+constexpr size_t NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS = 10;\n+//!  Created port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_RESPONSE_LIFETIME_OFS = 12;\n+\n+// Relevant NETPMP result codes (RFC6886 3.5).\n+//! Result code representing success status.\n+constexpr uint8_t NATPMP_RESULT_SUCCESS = 0;\n+//! Result code representing unsupported version.\n+constexpr uint8_t NATPMP_RESULT_UNSUPP_VERSION = 1;\n+//! Result code representing lack of resources.\n+constexpr uint8_t NATPMP_RESULT_NO_RESOURCES = 4;\n+\n+//! Mapping of NATPMP result code to string (RFC6886 3.5). Result codes <=2 match PCP.\n+const std::map<uint8_t, std::string> NATPMP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"NETWORK_FAILURE\"},\n+    {4,  \"NO_RESOURCES\"},\n+    {5,  \"UNSUPP_OPCODE\"},\n+};\n+\n+// PCP (v2) protocol constants.\n+//! Maximum packet size in bytes (RFC6887 section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (RFC6887 section 19.1). Shared with NAT-PMP.\n+constexpr uint16_t PCP_SERVER_PORT = NATPMP_SERVER_PORT;\n+//! Version byte. 0 is NAT-PMP (RFC6886), 1 is forbidden, 2 for PCP (RFC6887).\n+constexpr uint8_t PCP_VERSION = 2;\n+//! PCP Request Header. See RFC6887 section 7.1. Shared with NAT-PMP.\n+constexpr uint8_t PCP_REQUEST = NATPMP_REQUEST; // R = 0\n+//! PCP Response Header. See RFC6887 section 7.2. Shared with NAT-PMP.\n+constexpr uint8_t PCP_RESPONSE = NATPMP_RESPONSE; // R = 1\n+//! Map opcode. See RFC6887 section 19.2\n+constexpr uint8_t PCP_OP_MAP = 0x01;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Request and response header size in bytes (RFC6887 section 7.1).\n+constexpr size_t PCP_HDR_SIZE = 24;\n+//! Map request and response size in bytes (RFC6887 section 11.1).\n+constexpr size_t PCP_MAP_SIZE = 36;\n+\n+// Header offsets shared between request and responses (RFC6887 7.1, 7.2), relative to start of packet.\n+//!  Version field (1 byte).\n+constexpr size_t PCP_HDR_VERSION_OFS = NATPMP_HDR_VERSION_OFS;\n+//!  Opcode field (1 byte).\n+constexpr size_t PCP_HDR_OP_OFS = NATPMP_HDR_OP_OFS;\n+//!  Requested lifetime (request), granted lifetime (response) (2 bytes).\n+constexpr size_t PCP_HDR_LIFETIME_OFS = 4;\n+\n+// Request header offsets (RFC6887 7.1), relative to start of packet.\n+//!  PCP client's IP address (16 bytes).\n+constexpr size_t PCP_REQUEST_HDR_IP_OFS = 8;\n+\n+// Response header offsets (RFC6887 7.2), relative to start of packet.\n+//!  Result code (1 byte).\n+constexpr size_t PCP_RESPONSE_HDR_RESULT_OFS = 3;\n+\n+// MAP request/response offsets (RFC6887 11.1), relative to start of opcode-specific data.\n+//!  Mapping nonce (12 bytes).\n+constexpr size_t PCP_MAP_NONCE_OFS = 0;\n+//!  Protocol (1 byte).\n+constexpr size_t PCP_MAP_PROTOCOL_OFS = 12;\n+//!  Internal port for mapping (2 bytes).\n+constexpr size_t PCP_MAP_INTERNAL_PORT_OFS = 16;\n+//!  Suggested external port (request), assigned external port (response) (2 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_PORT_OFS = 18;\n+//!  Suggested external IP (request), assigned external IP (response) (16 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_IP_OFS = 20;\n+\n+//! Result code representing success (RFC6887 7.4), shared with NAT-PMP.\n+constexpr uint8_t PCP_RESULT_SUCCESS = NATPMP_RESULT_SUCCESS;\n+//! Result code representing lack of resources (RFC6887 7.4).\n+constexpr uint8_t PCP_RESULT_NO_RESOURCES = 8;\n+\n+//! Mapping of PCP result code to string (RFC6887 7.4). Result codes <=2 match NAT-PMP.\n+const std::map<uint8_t, std::string> PCP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"MALFORMED_REQUEST\"},\n+    {4,  \"UNSUPP_OPCODE\"},\n+    {5,  \"UNSUPP_OPTION\"},\n+    {6,  \"MALFORMED_OPTION\"},\n+    {7,  \"NETWORK_FAILURE\"},\n+    {8,  \"NO_RESOURCES\"},\n+    {9,  \"UNSUPP_PROTOCOL\"},\n+    {10, \"USER_EX_QUOTA\"},\n+    {11, \"CANNOT_PROVIDE_EXTERNAL\"},\n+    {12, \"ADDRESS_MISMATCH\"},\n+    {13, \"EXCESSIVE_REMOTE_PEER\"},\n+};\n+\n+//! Return human-readable string from NATPMP result code.\n+std::string NATPMPResultString(uint8_t result_code)\n+{\n+    auto result_i = NATPMP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == NATPMP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Return human-readable string from PCP result code.\n+std::string PCPResultString(uint8_t result_code)\n+{\n+    auto result_i = PCP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == PCP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Wrap address in IPv6 according to RFC6887. wrapped_addr needs to be able to store 16 bytes.\n+[[nodiscard]] bool PCPWrapAddress(Span<uint8_t> wrapped_addr, const CNetAddr &addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (addr.IsIPv4()) {\n+        struct in_addr addr4;\n+        if (!addr.GetInAddr(&addr4)) return false;\n+        // Section 5: \"When the address field holds an IPv4 address, an IPv4-mapped IPv6 address [RFC4291] is used (::ffff:0:0/96).\"\n+        std::memcpy(wrapped_addr.data(), IPV4_IN_IPV6_PREFIX.data(), IPV4_IN_IPV6_PREFIX.size());\n+        std::memcpy(wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), &addr4, ADDR_IPV4_SIZE);\n+        return true;\n+    } else if (addr.IsIPv6()) {\n+        struct in6_addr addr6;\n+        if (!addr.GetIn6Addr(&addr6)) return false;\n+        std::memcpy(wrapped_addr.data(), &addr6, ADDR_IPV6_SIZE);\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+//! Unwrap PCP-encoded address according to RFC6887.\n+CNetAddr PCPUnwrapAddress(Span<const uint8_t> wrapped_addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (util::HasPrefix(wrapped_addr, IPV4_IN_IPV6_PREFIX)) {\n+        struct in_addr addr4;\n+        std::memcpy(&addr4, wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), ADDR_IPV4_SIZE);\n+        return CNetAddr(addr4);\n+    } else {\n+        struct in6_addr addr6;\n+        std::memcpy(&addr6, wrapped_addr.data(), ADDR_IPV6_SIZE);\n+        return CNetAddr(addr6);\n+    }\n+}\n+\n+//! PCP or NAT-PMP send-receive loop.\n+std::optional<std::vector<uint8_t>> PCPSendRecv(Sock &sock, const std::string &protocol, Span<const uint8_t> request, int num_tries,\n+        std::chrono::milliseconds timeout_per_try,\n+        std::function<bool(Span<const uint8_t>)> check_packet)\n+{\n+    using namespace std::chrono;\n+    // UDP is a potentially lossy protocol, so we try to send again a few times.\n+    uint8_t response[PCP_MAX_SIZE];\n+    bool got_response = false;\n+    int recvsz = 0;\n+    for (int ntry = 0; !got_response && ntry < num_tries; ++ntry) {\n+        if (ntry > 0) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Retrying (%d)\\n\", protocol, ntry);\n+        }\n+        // Dispatch packet to gateway.\n+        if (sock.Send(request.data(), request.size(), 0) != static_cast<ssize_t>(request.size())) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not send request: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+            return std::nullopt; // Network-level error, probably no use retrying.\n+        }\n+\n+        // Wait for response(s) until we get a valid response, a network error, or time out.\n+        auto cur_time = time_point_cast<milliseconds>(steady_clock::now());\n+        auto deadline = cur_time + timeout_per_try;\n+        while ((cur_time = time_point_cast<milliseconds>(steady_clock::now())) < deadline) {\n+            Sock::Event occurred = 0;\n+            if (!sock.Wait(deadline - cur_time, Sock::RECV, &occurred)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not wait on socket: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            if (!occurred) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Timeout\\n\", protocol);\n+                break; // Retry.\n+            }\n+\n+            // Receive response.\n+            recvsz = sock.Recv(response, sizeof(response), MSG_DONTWAIT);\n+            if (recvsz < 0) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not receive response: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Received response of %d bytes: %s\\n\", protocol, recvsz, HexStr(Span(response, recvsz)));\n+\n+            if (check_packet(Span<uint8_t>(response, recvsz))) {\n+                got_response = true; // Got expected response, break from receive loop as well as from retry loop.\n+                break;\n+            }\n+        }\n+    }\n+    if (!got_response) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Giving up after %d tries\\n\", protocol, num_tries);\n+        return std::nullopt;\n+    }\n+    return std::vector<uint8_t>(response, response + recvsz);\n+}\n+\n+}\n+\n+std::variant<MappingResult, MappingError> NATPMPRequestPortMap(const CNetAddr &gateway, uint16_t port, uint32_t lifetime, int num_tries, std::chrono::milliseconds timeout_per_try)\n+{\n+    struct sockaddr_storage dest_addr;\n+    socklen_t dest_addrlen = sizeof(struct sockaddr_storage);\n+\n+    LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"natpmp: Requesting port mapping port %d from gateway %s\\n\", port, gateway.ToStringAddr());\n+\n+    // Validate gateway, make sure it's IPv4. NAT-PMP does not support IPv6.\n+    if (!CService(gateway, PCP_SERVER_PORT).GetSockAddr((struct sockaddr*)&dest_addr, &dest_addrlen)) return MappingError::NETWORK_ERROR;\n+    if (dest_addr.ss_family != AF_INET) return MappingError::NETWORK_ERROR;\n+\n+    // Create IPv4 UDP socket\n+    auto sock{CreateSock(AF_INET, SOCK_DGRAM, IPPROTO_UDP)};\n+    if (!sock) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Could not create UDP socket: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Associate UDP socket to gateway.\n+    if (sock->Connect((struct sockaddr*)&dest_addr, dest_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Could not connect to gateway: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Use getsockname to get the address toward the default gateway (the internal address).\n+    struct sockaddr_in internal;\n+    socklen_t internal_addrlen = sizeof(struct sockaddr_in);\n+    if (sock->GetSockName((struct sockaddr*)&internal, &internal_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Could not get sock name: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Request external IP address (RFC6886 section 3.2).\n+    std::vector<uint8_t> request(NATPMP_GETEXTERNAL_REQUEST_SIZE);\n+    request[NATPMP_HDR_VERSION_OFS] = NATPMP_VERSION;\n+    request[NATPMP_HDR_OP_OFS] = NATPMP_REQUEST | NATPMP_OP_GETEXTERNAL;\n+\n+    auto recv_res = PCPSendRecv(*sock, \"natpmp\", request, num_tries, timeout_per_try,\n+        [&](const Span<const uint8_t> response) -> bool {\n+            if (response.size() < NATPMP_GETEXTERNAL_RESPONSE_SIZE) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response too small\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            if (response[NATPMP_HDR_VERSION_OFS] != NATPMP_VERSION || response[NATPMP_HDR_OP_OFS] != (NATPMP_RESPONSE | NATPMP_OP_GETEXTERNAL)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response to wrong command\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            return true;\n+        });\n+\n+    struct in_addr external_addr;\n+    if (recv_res) {\n+        const std::span<const uint8_t> response = *recv_res;\n+\n+        Assume(response.size() >= NATPMP_GETEXTERNAL_RESPONSE_SIZE);\n+        uint16_t result_code = ReadBE16(response.data() + NATPMP_RESPONSE_HDR_RESULT_OFS);\n+        if (result_code != NATPMP_RESULT_SUCCESS) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Getting external address failed with result %s\\n\", NATPMPResultString(result_code));\n+            return MappingError::PROTOCOL_ERROR;\n+        }\n+\n+        std::memcpy(&external_addr, response.data() + NATPMP_GETEXTERNAL_RESPONSE_IP_OFS, ADDR_IPV4_SIZE);\n+    } else {\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Create TCP mapping request (RFC6886 section 3.3).\n+    request = std::vector<uint8_t>(NATPMP_MAP_REQUEST_SIZE);\n+    request[NATPMP_HDR_VERSION_OFS] = NATPMP_VERSION;\n+    request[NATPMP_HDR_OP_OFS] = NATPMP_REQUEST | NATPMP_OP_MAP_TCP;\n+    WriteBE16(request.data() + NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS, port);\n+    WriteBE16(request.data() + NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS, port);\n+    WriteBE32(request.data() + NATPMP_MAP_REQUEST_LIFETIME_OFS, lifetime);\n+\n+    recv_res = PCPSendRecv(*sock, \"natpmp\", request, num_tries, timeout_per_try,\n+        [&](const Span<const uint8_t> response) -> bool {\n+            if (response.size() < NATPMP_MAP_RESPONSE_SIZE) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response too small\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            if (response[0] != NATPMP_VERSION || response[1] != (NATPMP_RESPONSE | NATPMP_OP_MAP_TCP)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response to wrong command\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            uint16_t internal_port = ReadBE16(response.data() + NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS);\n+            if (internal_port != port) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response port doesn't match request\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            return true;\n+        });\n+\n+    if (recv_res) {\n+        const std::span<uint8_t> response = *recv_res;\n+\n+        Assume(response.size() >= NATPMP_MAP_RESPONSE_SIZE);\n+        uint16_t result_code = ReadBE16(response.data() + NATPMP_RESPONSE_HDR_RESULT_OFS);\n+        if (result_code != NATPMP_RESULT_SUCCESS) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Port mapping failed with result %s\\n\", NATPMPResultString(result_code));\n+            if (result_code == NATPMP_RESULT_NO_RESOURCES) {\n+                return MappingError::NO_RESOURCES;\n+            }\n+            return MappingError::PROTOCOL_ERROR;\n+        }\n+\n+        uint32_t lifetime_ret = ReadBE32(response.data() + NATPMP_MAP_RESPONSE_LIFETIME_OFS);\n+        uint16_t external_port = ReadBE16(response.data() + NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS);\n+        return MappingResult(NATPMP_VERSION, CService(internal.sin_addr, port), CService(external_addr, external_port), lifetime_ret);\n+    } else {\n+        return MappingError::NETWORK_ERROR;\n+    }\n+}\n+\n+std::variant<MappingResult, MappingError> PCPRequestPortMap(const PCPMappingNonce &nonce, const CNetAddr &gateway, const CNetAddr &bind, uint16_t port, uint32_t lifetime, int num_tries, std::chrono::milliseconds timeout_per_try)\n+{\n+    struct sockaddr_storage dest_addr, bind_addr;\n+    socklen_t dest_addrlen = sizeof(struct sockaddr_storage), bind_addrlen = sizeof(struct sockaddr_storage);\n+\n+    LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"pcp: Requesting port mapping for addr %s port %d from gateway %s\\n\", bind.ToStringAddr(), port, gateway.ToStringAddr());\n+\n+    // Validate addresses, make sure they're the same network family.\n+    if (!CService(gateway, PCP_SERVER_PORT).GetSockAddr((struct sockaddr*)&dest_addr, &dest_addrlen)) return MappingError::NETWORK_ERROR;\n+    if (!CService(bind, 0).GetSockAddr((struct sockaddr*)&bind_addr, &bind_addrlen)) return MappingError::NETWORK_ERROR;\n+    if (dest_addr.ss_family != bind_addr.ss_family) return MappingError::NETWORK_ERROR;\n+\n+    // Create UDP socket (IPv4 or IPv6 based on provided gateway).\n+    auto sock{CreateSock(dest_addr.ss_family, SOCK_DGRAM, IPPROTO_UDP)};\n+    if (!sock) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp: Could not create UDP socket: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Make sure that we send from requested destination address, anything else will be\n+    // rejected by a security-conscious router.\n+    if (sock->Bind((struct sockaddr*)&bind_addr, bind_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp: Could not bind to address: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Associate UDP socket to gateway.\n+    if (sock->Connect((struct sockaddr*)&dest_addr, dest_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp: Could not connect to gateway: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Use getsockname to get the address toward the default gateway (the internal address),\n+    // in case we don't know what address to map\n+    // (this is only needed if bind is INADDR_ANY, but it doesn't hurt as an extra check).\n+    struct sockaddr_storage internal_addr;\n+    socklen_t internal_addrlen = sizeof(struct sockaddr_storage);\n+    if (sock->GetSockName((struct sockaddr*)&internal_addr, &internal_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp: Could not get sock name: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+    CService internal;\n+    if (!internal.SetSockAddr((struct sockaddr*)&internal_addr)) return MappingError::NETWORK_ERROR;\n+    LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"pcp: Internal address after connect: %s\\n\", internal.ToStringAddr());\n+\n+    // Build request packet. Make sure the packet is zeroed so that reserved fields are zero\n+    // as required by the spec (and not potentially leak data).\n+    // Make sure there's space for the request header and MAP specific request data.\n+    std::vector<uint8_t> request(PCP_HDR_SIZE + PCP_MAP_SIZE);\n+    // Fill in request header, See RFC6887 Figure 2.\n+    size_t ofs = 0;\n+    request[ofs + PCP_HDR_VERSION_OFS] = PCP_VERSION;\n+    request[ofs + PCP_HDR_OP_OFS] = PCP_REQUEST | PCP_OP_MAP;\n+    WriteBE32(request.data() + ofs + PCP_HDR_LIFETIME_OFS, lifetime);\n+    if (!PCPWrapAddress(Span(request).subspan(ofs + PCP_REQUEST_HDR_IP_OFS, ADDR_IPV6_SIZE), internal)) return MappingError::NETWORK_ERROR;\n+\n+    ofs += PCP_HDR_SIZE;\n+\n+    // Fill in MAP request packet, See RFC6887 Figure 9.\n+    // Randomize mapping nonce (this is repeated in the response, to be able to\n+    // correlate requests and responses, and used to authenticate changes to the mapping).\n+    std::memcpy(request.data() + ofs + PCP_MAP_NONCE_OFS, nonce.data(), PCP_MAP_NONCE_SIZE);\n+    request[ofs + PCP_MAP_PROTOCOL_OFS] = PCP_PROTOCOL_TCP;\n+    WriteBE16(request.data() + ofs + PCP_MAP_INTERNAL_PORT_OFS, port);\n+    WriteBE16(request.data() + ofs + PCP_MAP_EXTERNAL_PORT_OFS, port);\n+    if (!PCPWrapAddress(Span(request).subspan(ofs + PCP_MAP_EXTERNAL_IP_OFS, ADDR_IPV6_SIZE), bind)) return MappingError::NETWORK_ERROR;\n+\n+    ofs += PCP_MAP_SIZE;\n+    Assume(ofs == request.size());\n+\n+    // Receive loop.\n+    bool is_natpmp = false;\n+    auto recv_res = PCPSendRecv(*sock, \"pcp\", request, num_tries, timeout_per_try,\n+        [&](const Span<const uint8_t> response) -> bool {\n+            // Unsupported version according to RFC6887 appendix A and RFC6886 section 3.5, can fall back to NAT-PMP.\n+            if (response.size() == NATPMP_RESPONSE_HDR_SIZE && response[PCP_HDR_VERSION_OFS] == NATPMP_VERSION && response[PCP_RESPONSE_HDR_RESULT_OFS] == NATPMP_RESULT_UNSUPP_VERSION) {",
      "path": "src/util/pcp.cpp",
      "position": 462,
      "original_position": 462,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "23916f2a7717b463799207b4b81b5795f2e9d7e3",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "According to https://www.rfc-editor.org/rfc/rfc6886#section-3.5 the result code is 2 bytes (which happen to be `[2]` and `[3]` in our array). Here we check the second byte `response[3] == 1`. Even that all result codes are less than 256, I think it is warranted to check that the preceding byte is `0`. Either by `ReadBE16() == 1` or by `response[2] == 0 && response[3] == 1`.",
      "created_at": "2024-06-28T10:42:20Z",
      "updated_at": "2024-06-28T15:31:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1658498124",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1658498124"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 462,
      "original_line": 462,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1658641733",
      "pull_request_review_id": 2141814858,
      "id": 1658641733,
      "node_id": "PRRC_kwDOABII585i3N1F",
      "diff_hunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/pcp.h>\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <span.h>\n+#include <util/check.h>\n+#include <util/netif.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+namespace {\n+\n+// RFC6886 NAT-PMP and RFC6887 Port Control Protocol (PCP) implementation.\n+// NAT-PMP and PCP use network byte order (big-endian).\n+\n+// NAT-PMP (v0) protocol constants.\n+//! NAT-PMP uses a fixed server port number (RFC6887 section 1.1).\n+constexpr uint16_t NATPMP_SERVER_PORT = 5351;\n+//! Version byte for NATPMP (RFC6886 1.1)\n+constexpr uint8_t NATPMP_VERSION = 0;\n+//! Request opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_REQUEST = 0x00;\n+//! Response opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_RESPONSE = 0x80;\n+//! Get external address (RFC6886 3.2)\n+constexpr uint8_t NATPMP_OP_GETEXTERNAL = 0x00;\n+//! Map TCP port (RFC6886 3.3)\n+constexpr uint8_t NATPMP_OP_MAP_TCP = 0x02;\n+//! Shared request header size in bytes.\n+constexpr size_t NATPMP_REQUEST_HDR_SIZE = 2;\n+//! Shared response header (minimum) size in bytes.\n+constexpr size_t NATPMP_RESPONSE_HDR_SIZE = 8;\n+//! GETEXTERNAL request size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 0;\n+//! GETEXTERNAL response size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 4;\n+//! MAP request size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 10;\n+//! MAP response size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 8;\n+\n+// Shared header offsets (RFC6886 3.2, 3.3), relative to start of packet.\n+//!  Offset of version field in packets.\n+constexpr size_t NATPMP_HDR_VERSION_OFS = 0;\n+//!  Offset of opcode field in packets\n+constexpr size_t NATPMP_HDR_OP_OFS = 1;\n+//!  Offset of result code in packets. Result codes are 16 bit in NAT-PMP instead of 8 bit in PCP.\n+constexpr size_t NATPMP_RESPONSE_HDR_RESULT_OFS = 2;\n+\n+// GETEXTERNAL response offsets (RFC6886 3.2), relative to start of packet.\n+//!  Returned external address\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_IP_OFS = 8;\n+\n+// MAP request offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port to be mapped.\n+constexpr size_t NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS = 4;\n+//!  Suggested external port for mapping.\n+constexpr size_t NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS = 6;\n+//!  Requested port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_REQUEST_LIFETIME_OFS = 8;\n+\n+// MAP response offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port for mapping (will match internal port of request).\n+constexpr size_t NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS = 8;\n+//!  External port for mapping.\n+constexpr size_t NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS = 10;\n+//!  Created port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_RESPONSE_LIFETIME_OFS = 12;\n+\n+// Relevant NETPMP result codes (RFC6886 3.5).\n+//! Result code representing success status.\n+constexpr uint8_t NATPMP_RESULT_SUCCESS = 0;\n+//! Result code representing unsupported version.\n+constexpr uint8_t NATPMP_RESULT_UNSUPP_VERSION = 1;\n+//! Result code representing lack of resources.\n+constexpr uint8_t NATPMP_RESULT_NO_RESOURCES = 4;\n+\n+//! Mapping of NATPMP result code to string (RFC6886 3.5). Result codes <=2 match PCP.\n+const std::map<uint8_t, std::string> NATPMP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"NETWORK_FAILURE\"},\n+    {4,  \"NO_RESOURCES\"},\n+    {5,  \"UNSUPP_OPCODE\"},\n+};\n+\n+// PCP (v2) protocol constants.\n+//! Maximum packet size in bytes (RFC6887 section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (RFC6887 section 19.1). Shared with NAT-PMP.\n+constexpr uint16_t PCP_SERVER_PORT = NATPMP_SERVER_PORT;\n+//! Version byte. 0 is NAT-PMP (RFC6886), 1 is forbidden, 2 for PCP (RFC6887).\n+constexpr uint8_t PCP_VERSION = 2;\n+//! PCP Request Header. See RFC6887 section 7.1. Shared with NAT-PMP.\n+constexpr uint8_t PCP_REQUEST = NATPMP_REQUEST; // R = 0\n+//! PCP Response Header. See RFC6887 section 7.2. Shared with NAT-PMP.\n+constexpr uint8_t PCP_RESPONSE = NATPMP_RESPONSE; // R = 1\n+//! Map opcode. See RFC6887 section 19.2\n+constexpr uint8_t PCP_OP_MAP = 0x01;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Request and response header size in bytes (RFC6887 section 7.1).\n+constexpr size_t PCP_HDR_SIZE = 24;\n+//! Map request and response size in bytes (RFC6887 section 11.1).\n+constexpr size_t PCP_MAP_SIZE = 36;\n+\n+// Header offsets shared between request and responses (RFC6887 7.1, 7.2), relative to start of packet.\n+//!  Version field (1 byte).\n+constexpr size_t PCP_HDR_VERSION_OFS = NATPMP_HDR_VERSION_OFS;\n+//!  Opcode field (1 byte).\n+constexpr size_t PCP_HDR_OP_OFS = NATPMP_HDR_OP_OFS;\n+//!  Requested lifetime (request), granted lifetime (response) (2 bytes).\n+constexpr size_t PCP_HDR_LIFETIME_OFS = 4;\n+\n+// Request header offsets (RFC6887 7.1), relative to start of packet.\n+//!  PCP client's IP address (16 bytes).\n+constexpr size_t PCP_REQUEST_HDR_IP_OFS = 8;\n+\n+// Response header offsets (RFC6887 7.2), relative to start of packet.\n+//!  Result code (1 byte).\n+constexpr size_t PCP_RESPONSE_HDR_RESULT_OFS = 3;\n+\n+// MAP request/response offsets (RFC6887 11.1), relative to start of opcode-specific data.\n+//!  Mapping nonce (12 bytes).\n+constexpr size_t PCP_MAP_NONCE_OFS = 0;\n+//!  Protocol (1 byte).\n+constexpr size_t PCP_MAP_PROTOCOL_OFS = 12;\n+//!  Internal port for mapping (2 bytes).\n+constexpr size_t PCP_MAP_INTERNAL_PORT_OFS = 16;\n+//!  Suggested external port (request), assigned external port (response) (2 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_PORT_OFS = 18;\n+//!  Suggested external IP (request), assigned external IP (response) (16 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_IP_OFS = 20;\n+\n+//! Result code representing success (RFC6887 7.4), shared with NAT-PMP.\n+constexpr uint8_t PCP_RESULT_SUCCESS = NATPMP_RESULT_SUCCESS;\n+//! Result code representing lack of resources (RFC6887 7.4).\n+constexpr uint8_t PCP_RESULT_NO_RESOURCES = 8;\n+\n+//! Mapping of PCP result code to string (RFC6887 7.4). Result codes <=2 match NAT-PMP.\n+const std::map<uint8_t, std::string> PCP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"MALFORMED_REQUEST\"},\n+    {4,  \"UNSUPP_OPCODE\"},\n+    {5,  \"UNSUPP_OPTION\"},\n+    {6,  \"MALFORMED_OPTION\"},\n+    {7,  \"NETWORK_FAILURE\"},\n+    {8,  \"NO_RESOURCES\"},\n+    {9,  \"UNSUPP_PROTOCOL\"},\n+    {10, \"USER_EX_QUOTA\"},\n+    {11, \"CANNOT_PROVIDE_EXTERNAL\"},\n+    {12, \"ADDRESS_MISMATCH\"},\n+    {13, \"EXCESSIVE_REMOTE_PEER\"},\n+};\n+\n+//! Return human-readable string from NATPMP result code.\n+std::string NATPMPResultString(uint8_t result_code)\n+{\n+    auto result_i = NATPMP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == NATPMP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Return human-readable string from PCP result code.\n+std::string PCPResultString(uint8_t result_code)\n+{\n+    auto result_i = PCP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == PCP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Wrap address in IPv6 according to RFC6887. wrapped_addr needs to be able to store 16 bytes.\n+[[nodiscard]] bool PCPWrapAddress(Span<uint8_t> wrapped_addr, const CNetAddr &addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (addr.IsIPv4()) {\n+        struct in_addr addr4;\n+        if (!addr.GetInAddr(&addr4)) return false;\n+        // Section 5: \"When the address field holds an IPv4 address, an IPv4-mapped IPv6 address [RFC4291] is used (::ffff:0:0/96).\"\n+        std::memcpy(wrapped_addr.data(), IPV4_IN_IPV6_PREFIX.data(), IPV4_IN_IPV6_PREFIX.size());\n+        std::memcpy(wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), &addr4, ADDR_IPV4_SIZE);\n+        return true;\n+    } else if (addr.IsIPv6()) {\n+        struct in6_addr addr6;\n+        if (!addr.GetIn6Addr(&addr6)) return false;\n+        std::memcpy(wrapped_addr.data(), &addr6, ADDR_IPV6_SIZE);\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+//! Unwrap PCP-encoded address according to RFC6887.\n+CNetAddr PCPUnwrapAddress(Span<const uint8_t> wrapped_addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (util::HasPrefix(wrapped_addr, IPV4_IN_IPV6_PREFIX)) {\n+        struct in_addr addr4;\n+        std::memcpy(&addr4, wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), ADDR_IPV4_SIZE);\n+        return CNetAddr(addr4);\n+    } else {\n+        struct in6_addr addr6;\n+        std::memcpy(&addr6, wrapped_addr.data(), ADDR_IPV6_SIZE);\n+        return CNetAddr(addr6);\n+    }\n+}\n+\n+//! PCP or NAT-PMP send-receive loop.\n+std::optional<std::vector<uint8_t>> PCPSendRecv(Sock &sock, const std::string &protocol, Span<const uint8_t> request, int num_tries,\n+        std::chrono::milliseconds timeout_per_try,\n+        std::function<bool(Span<const uint8_t>)> check_packet)\n+{\n+    using namespace std::chrono;\n+    // UDP is a potentially lossy protocol, so we try to send again a few times.\n+    uint8_t response[PCP_MAX_SIZE];\n+    bool got_response = false;\n+    int recvsz = 0;\n+    for (int ntry = 0; !got_response && ntry < num_tries; ++ntry) {\n+        if (ntry > 0) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Retrying (%d)\\n\", protocol, ntry);\n+        }\n+        // Dispatch packet to gateway.\n+        if (sock.Send(request.data(), request.size(), 0) != static_cast<ssize_t>(request.size())) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not send request: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+            return std::nullopt; // Network-level error, probably no use retrying.\n+        }\n+\n+        // Wait for response(s) until we get a valid response, a network error, or time out.\n+        auto cur_time = time_point_cast<milliseconds>(steady_clock::now());\n+        auto deadline = cur_time + timeout_per_try;\n+        while ((cur_time = time_point_cast<milliseconds>(steady_clock::now())) < deadline) {\n+            Sock::Event occurred = 0;\n+            if (!sock.Wait(deadline - cur_time, Sock::RECV, &occurred)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not wait on socket: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            if (!occurred) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Timeout\\n\", protocol);\n+                break; // Retry.\n+            }\n+\n+            // Receive response.\n+            recvsz = sock.Recv(response, sizeof(response), MSG_DONTWAIT);\n+            if (recvsz < 0) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not receive response: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Received response of %d bytes: %s\\n\", protocol, recvsz, HexStr(Span(response, recvsz)));\n+\n+            if (check_packet(Span<uint8_t>(response, recvsz))) {\n+                got_response = true; // Got expected response, break from receive loop as well as from retry loop.\n+                break;\n+            }\n+        }\n+    }\n+    if (!got_response) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Giving up after %d tries\\n\", protocol, num_tries);\n+        return std::nullopt;\n+    }\n+    return std::vector<uint8_t>(response, response + recvsz);\n+}\n+\n+}\n+\n+std::variant<MappingResult, MappingError> NATPMPRequestPortMap(const CNetAddr &gateway, uint16_t port, uint32_t lifetime, int num_tries, std::chrono::milliseconds timeout_per_try)\n+{\n+    struct sockaddr_storage dest_addr;\n+    socklen_t dest_addrlen = sizeof(struct sockaddr_storage);\n+\n+    LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"natpmp: Requesting port mapping port %d from gateway %s\\n\", port, gateway.ToStringAddr());\n+\n+    // Validate gateway, make sure it's IPv4. NAT-PMP does not support IPv6.\n+    if (!CService(gateway, PCP_SERVER_PORT).GetSockAddr((struct sockaddr*)&dest_addr, &dest_addrlen)) return MappingError::NETWORK_ERROR;\n+    if (dest_addr.ss_family != AF_INET) return MappingError::NETWORK_ERROR;\n+\n+    // Create IPv4 UDP socket\n+    auto sock{CreateSock(AF_INET, SOCK_DGRAM, IPPROTO_UDP)};\n+    if (!sock) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Could not create UDP socket: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Associate UDP socket to gateway.\n+    if (sock->Connect((struct sockaddr*)&dest_addr, dest_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Could not connect to gateway: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Use getsockname to get the address toward the default gateway (the internal address).\n+    struct sockaddr_in internal;\n+    socklen_t internal_addrlen = sizeof(struct sockaddr_in);\n+    if (sock->GetSockName((struct sockaddr*)&internal, &internal_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Could not get sock name: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Request external IP address (RFC6886 section 3.2).\n+    std::vector<uint8_t> request(NATPMP_GETEXTERNAL_REQUEST_SIZE);\n+    request[NATPMP_HDR_VERSION_OFS] = NATPMP_VERSION;\n+    request[NATPMP_HDR_OP_OFS] = NATPMP_REQUEST | NATPMP_OP_GETEXTERNAL;\n+\n+    auto recv_res = PCPSendRecv(*sock, \"natpmp\", request, num_tries, timeout_per_try,\n+        [&](const Span<const uint8_t> response) -> bool {\n+            if (response.size() < NATPMP_GETEXTERNAL_RESPONSE_SIZE) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response too small\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            if (response[NATPMP_HDR_VERSION_OFS] != NATPMP_VERSION || response[NATPMP_HDR_OP_OFS] != (NATPMP_RESPONSE | NATPMP_OP_GETEXTERNAL)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response to wrong command\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            return true;\n+        });\n+\n+    struct in_addr external_addr;\n+    if (recv_res) {\n+        const std::span<const uint8_t> response = *recv_res;\n+\n+        Assume(response.size() >= NATPMP_GETEXTERNAL_RESPONSE_SIZE);\n+        uint16_t result_code = ReadBE16(response.data() + NATPMP_RESPONSE_HDR_RESULT_OFS);\n+        if (result_code != NATPMP_RESULT_SUCCESS) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Getting external address failed with result %s\\n\", NATPMPResultString(result_code));\n+            return MappingError::PROTOCOL_ERROR;\n+        }\n+\n+        std::memcpy(&external_addr, response.data() + NATPMP_GETEXTERNAL_RESPONSE_IP_OFS, ADDR_IPV4_SIZE);\n+    } else {\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Create TCP mapping request (RFC6886 section 3.3).\n+    request = std::vector<uint8_t>(NATPMP_MAP_REQUEST_SIZE);\n+    request[NATPMP_HDR_VERSION_OFS] = NATPMP_VERSION;\n+    request[NATPMP_HDR_OP_OFS] = NATPMP_REQUEST | NATPMP_OP_MAP_TCP;\n+    WriteBE16(request.data() + NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS, port);\n+    WriteBE16(request.data() + NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS, port);\n+    WriteBE32(request.data() + NATPMP_MAP_REQUEST_LIFETIME_OFS, lifetime);\n+\n+    recv_res = PCPSendRecv(*sock, \"natpmp\", request, num_tries, timeout_per_try,\n+        [&](const Span<const uint8_t> response) -> bool {\n+            if (response.size() < NATPMP_MAP_RESPONSE_SIZE) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response too small\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            if (response[0] != NATPMP_VERSION || response[1] != (NATPMP_RESPONSE | NATPMP_OP_MAP_TCP)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response to wrong command\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            uint16_t internal_port = ReadBE16(response.data() + NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS);\n+            if (internal_port != port) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response port doesn't match request\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            return true;\n+        });\n+\n+    if (recv_res) {\n+        const std::span<uint8_t> response = *recv_res;\n+\n+        Assume(response.size() >= NATPMP_MAP_RESPONSE_SIZE);\n+        uint16_t result_code = ReadBE16(response.data() + NATPMP_RESPONSE_HDR_RESULT_OFS);\n+        if (result_code != NATPMP_RESULT_SUCCESS) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Port mapping failed with result %s\\n\", NATPMPResultString(result_code));\n+            if (result_code == NATPMP_RESULT_NO_RESOURCES) {\n+                return MappingError::NO_RESOURCES;\n+            }\n+            return MappingError::PROTOCOL_ERROR;\n+        }\n+\n+        uint32_t lifetime_ret = ReadBE32(response.data() + NATPMP_MAP_RESPONSE_LIFETIME_OFS);\n+        uint16_t external_port = ReadBE16(response.data() + NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS);\n+        return MappingResult(NATPMP_VERSION, CService(internal.sin_addr, port), CService(external_addr, external_port), lifetime_ret);\n+    } else {\n+        return MappingError::NETWORK_ERROR;\n+    }\n+}\n+\n+std::variant<MappingResult, MappingError> PCPRequestPortMap(const PCPMappingNonce &nonce, const CNetAddr &gateway, const CNetAddr &bind, uint16_t port, uint32_t lifetime, int num_tries, std::chrono::milliseconds timeout_per_try)\n+{\n+    struct sockaddr_storage dest_addr, bind_addr;\n+    socklen_t dest_addrlen = sizeof(struct sockaddr_storage), bind_addrlen = sizeof(struct sockaddr_storage);\n+\n+    LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"pcp: Requesting port mapping for addr %s port %d from gateway %s\\n\", bind.ToStringAddr(), port, gateway.ToStringAddr());\n+\n+    // Validate addresses, make sure they're the same network family.\n+    if (!CService(gateway, PCP_SERVER_PORT).GetSockAddr((struct sockaddr*)&dest_addr, &dest_addrlen)) return MappingError::NETWORK_ERROR;\n+    if (!CService(bind, 0).GetSockAddr((struct sockaddr*)&bind_addr, &bind_addrlen)) return MappingError::NETWORK_ERROR;\n+    if (dest_addr.ss_family != bind_addr.ss_family) return MappingError::NETWORK_ERROR;\n+\n+    // Create UDP socket (IPv4 or IPv6 based on provided gateway).\n+    auto sock{CreateSock(dest_addr.ss_family, SOCK_DGRAM, IPPROTO_UDP)};\n+    if (!sock) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp: Could not create UDP socket: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Make sure that we send from requested destination address, anything else will be\n+    // rejected by a security-conscious router.\n+    if (sock->Bind((struct sockaddr*)&bind_addr, bind_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp: Could not bind to address: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Associate UDP socket to gateway.\n+    if (sock->Connect((struct sockaddr*)&dest_addr, dest_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp: Could not connect to gateway: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Use getsockname to get the address toward the default gateway (the internal address),\n+    // in case we don't know what address to map\n+    // (this is only needed if bind is INADDR_ANY, but it doesn't hurt as an extra check).\n+    struct sockaddr_storage internal_addr;\n+    socklen_t internal_addrlen = sizeof(struct sockaddr_storage);\n+    if (sock->GetSockName((struct sockaddr*)&internal_addr, &internal_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp: Could not get sock name: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+    CService internal;\n+    if (!internal.SetSockAddr((struct sockaddr*)&internal_addr)) return MappingError::NETWORK_ERROR;\n+    LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"pcp: Internal address after connect: %s\\n\", internal.ToStringAddr());\n+\n+    // Build request packet. Make sure the packet is zeroed so that reserved fields are zero\n+    // as required by the spec (and not potentially leak data).\n+    // Make sure there's space for the request header and MAP specific request data.\n+    std::vector<uint8_t> request(PCP_HDR_SIZE + PCP_MAP_SIZE);\n+    // Fill in request header, See RFC6887 Figure 2.\n+    size_t ofs = 0;\n+    request[ofs + PCP_HDR_VERSION_OFS] = PCP_VERSION;\n+    request[ofs + PCP_HDR_OP_OFS] = PCP_REQUEST | PCP_OP_MAP;\n+    WriteBE32(request.data() + ofs + PCP_HDR_LIFETIME_OFS, lifetime);\n+    if (!PCPWrapAddress(Span(request).subspan(ofs + PCP_REQUEST_HDR_IP_OFS, ADDR_IPV6_SIZE), internal)) return MappingError::NETWORK_ERROR;\n+\n+    ofs += PCP_HDR_SIZE;\n+\n+    // Fill in MAP request packet, See RFC6887 Figure 9.\n+    // Randomize mapping nonce (this is repeated in the response, to be able to\n+    // correlate requests and responses, and used to authenticate changes to the mapping).\n+    std::memcpy(request.data() + ofs + PCP_MAP_NONCE_OFS, nonce.data(), PCP_MAP_NONCE_SIZE);\n+    request[ofs + PCP_MAP_PROTOCOL_OFS] = PCP_PROTOCOL_TCP;\n+    WriteBE16(request.data() + ofs + PCP_MAP_INTERNAL_PORT_OFS, port);\n+    WriteBE16(request.data() + ofs + PCP_MAP_EXTERNAL_PORT_OFS, port);\n+    if (!PCPWrapAddress(Span(request).subspan(ofs + PCP_MAP_EXTERNAL_IP_OFS, ADDR_IPV6_SIZE), bind)) return MappingError::NETWORK_ERROR;\n+\n+    ofs += PCP_MAP_SIZE;\n+    Assume(ofs == request.size());\n+\n+    // Receive loop.\n+    bool is_natpmp = false;\n+    auto recv_res = PCPSendRecv(*sock, \"pcp\", request, num_tries, timeout_per_try,\n+        [&](const Span<const uint8_t> response) -> bool {\n+            // Unsupported version according to RFC6887 appendix A and RFC6886 section 3.5, can fall back to NAT-PMP.\n+            if (response.size() == NATPMP_RESPONSE_HDR_SIZE && response[PCP_HDR_VERSION_OFS] == NATPMP_VERSION && response[PCP_RESPONSE_HDR_RESULT_OFS] == NATPMP_RESULT_UNSUPP_VERSION) {\n+                is_natpmp = true;\n+                return true; // Let it through to caller.\n+            }\n+            if (response.size() < (PCP_HDR_SIZE + PCP_MAP_SIZE)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp: Response too small\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            if (response[PCP_HDR_VERSION_OFS] != PCP_VERSION || response[PCP_HDR_OP_OFS] != (PCP_RESPONSE | PCP_OP_MAP)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp: Response to wrong command\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            // Handle MAP opcode response. See RFC6887 Figure 10.\n+            // Check that returned mapping nonce matches our request.\n+            if (response.subspan(PCP_HDR_SIZE + PCP_MAP_NONCE_OFS, PCP_MAP_NONCE_SIZE) != Span(nonce)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp: Mapping nonce mismatch\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            uint8_t protocol = response[PCP_HDR_SIZE + 12];\n+            uint16_t internal_port = ReadBE16(response.data() + PCP_HDR_SIZE + 16);\n+            if (protocol != PCP_PROTOCOL_TCP || internal_port != port) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp: Response protocol or port doesn't match request\\n\");",
      "path": "src/util/pcp.cpp",
      "position": 483,
      "original_position": 483,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "23916f2a7717b463799207b4b81b5795f2e9d7e3",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Here we check the nonce, protocol and port. https://www.rfc-editor.org/rfc/rfc6887#section-11.4 says to check \"internal IP address (the destination IP address of the PCP response...\" as well.",
      "created_at": "2024-06-28T12:00:50Z",
      "updated_at": "2024-06-28T15:24:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1658641733",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1658641733"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 483,
      "original_line": 483,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1658654045",
      "pull_request_review_id": 2141814858,
      "id": 1658654045,
      "node_id": "PRRC_kwDOABII585i3Q1d",
      "diff_hunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/pcp.h>\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <span.h>\n+#include <util/check.h>\n+#include <util/netif.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+namespace {\n+\n+// RFC6886 NAT-PMP and RFC6887 Port Control Protocol (PCP) implementation.\n+// NAT-PMP and PCP use network byte order (big-endian).\n+\n+// NAT-PMP (v0) protocol constants.\n+//! NAT-PMP uses a fixed server port number (RFC6887 section 1.1).\n+constexpr uint16_t NATPMP_SERVER_PORT = 5351;\n+//! Version byte for NATPMP (RFC6886 1.1)\n+constexpr uint8_t NATPMP_VERSION = 0;\n+//! Request opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_REQUEST = 0x00;\n+//! Response opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_RESPONSE = 0x80;\n+//! Get external address (RFC6886 3.2)\n+constexpr uint8_t NATPMP_OP_GETEXTERNAL = 0x00;\n+//! Map TCP port (RFC6886 3.3)\n+constexpr uint8_t NATPMP_OP_MAP_TCP = 0x02;\n+//! Shared request header size in bytes.\n+constexpr size_t NATPMP_REQUEST_HDR_SIZE = 2;\n+//! Shared response header (minimum) size in bytes.\n+constexpr size_t NATPMP_RESPONSE_HDR_SIZE = 8;\n+//! GETEXTERNAL request size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 0;\n+//! GETEXTERNAL response size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 4;\n+//! MAP request size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 10;\n+//! MAP response size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 8;\n+\n+// Shared header offsets (RFC6886 3.2, 3.3), relative to start of packet.\n+//!  Offset of version field in packets.\n+constexpr size_t NATPMP_HDR_VERSION_OFS = 0;\n+//!  Offset of opcode field in packets\n+constexpr size_t NATPMP_HDR_OP_OFS = 1;\n+//!  Offset of result code in packets. Result codes are 16 bit in NAT-PMP instead of 8 bit in PCP.\n+constexpr size_t NATPMP_RESPONSE_HDR_RESULT_OFS = 2;\n+\n+// GETEXTERNAL response offsets (RFC6886 3.2), relative to start of packet.\n+//!  Returned external address\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_IP_OFS = 8;\n+\n+// MAP request offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port to be mapped.\n+constexpr size_t NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS = 4;\n+//!  Suggested external port for mapping.\n+constexpr size_t NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS = 6;\n+//!  Requested port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_REQUEST_LIFETIME_OFS = 8;\n+\n+// MAP response offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port for mapping (will match internal port of request).\n+constexpr size_t NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS = 8;\n+//!  External port for mapping.\n+constexpr size_t NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS = 10;\n+//!  Created port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_RESPONSE_LIFETIME_OFS = 12;\n+\n+// Relevant NETPMP result codes (RFC6886 3.5).\n+//! Result code representing success status.\n+constexpr uint8_t NATPMP_RESULT_SUCCESS = 0;\n+//! Result code representing unsupported version.\n+constexpr uint8_t NATPMP_RESULT_UNSUPP_VERSION = 1;\n+//! Result code representing lack of resources.\n+constexpr uint8_t NATPMP_RESULT_NO_RESOURCES = 4;\n+\n+//! Mapping of NATPMP result code to string (RFC6886 3.5). Result codes <=2 match PCP.\n+const std::map<uint8_t, std::string> NATPMP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"NETWORK_FAILURE\"},\n+    {4,  \"NO_RESOURCES\"},\n+    {5,  \"UNSUPP_OPCODE\"},\n+};\n+\n+// PCP (v2) protocol constants.\n+//! Maximum packet size in bytes (RFC6887 section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (RFC6887 section 19.1). Shared with NAT-PMP.\n+constexpr uint16_t PCP_SERVER_PORT = NATPMP_SERVER_PORT;\n+//! Version byte. 0 is NAT-PMP (RFC6886), 1 is forbidden, 2 for PCP (RFC6887).\n+constexpr uint8_t PCP_VERSION = 2;\n+//! PCP Request Header. See RFC6887 section 7.1. Shared with NAT-PMP.\n+constexpr uint8_t PCP_REQUEST = NATPMP_REQUEST; // R = 0\n+//! PCP Response Header. See RFC6887 section 7.2. Shared with NAT-PMP.\n+constexpr uint8_t PCP_RESPONSE = NATPMP_RESPONSE; // R = 1\n+//! Map opcode. See RFC6887 section 19.2\n+constexpr uint8_t PCP_OP_MAP = 0x01;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Request and response header size in bytes (RFC6887 section 7.1).\n+constexpr size_t PCP_HDR_SIZE = 24;\n+//! Map request and response size in bytes (RFC6887 section 11.1).\n+constexpr size_t PCP_MAP_SIZE = 36;\n+\n+// Header offsets shared between request and responses (RFC6887 7.1, 7.2), relative to start of packet.\n+//!  Version field (1 byte).\n+constexpr size_t PCP_HDR_VERSION_OFS = NATPMP_HDR_VERSION_OFS;\n+//!  Opcode field (1 byte).\n+constexpr size_t PCP_HDR_OP_OFS = NATPMP_HDR_OP_OFS;\n+//!  Requested lifetime (request), granted lifetime (response) (2 bytes).\n+constexpr size_t PCP_HDR_LIFETIME_OFS = 4;\n+\n+// Request header offsets (RFC6887 7.1), relative to start of packet.\n+//!  PCP client's IP address (16 bytes).\n+constexpr size_t PCP_REQUEST_HDR_IP_OFS = 8;\n+\n+// Response header offsets (RFC6887 7.2), relative to start of packet.\n+//!  Result code (1 byte).\n+constexpr size_t PCP_RESPONSE_HDR_RESULT_OFS = 3;\n+\n+// MAP request/response offsets (RFC6887 11.1), relative to start of opcode-specific data.\n+//!  Mapping nonce (12 bytes).\n+constexpr size_t PCP_MAP_NONCE_OFS = 0;\n+//!  Protocol (1 byte).\n+constexpr size_t PCP_MAP_PROTOCOL_OFS = 12;\n+//!  Internal port for mapping (2 bytes).\n+constexpr size_t PCP_MAP_INTERNAL_PORT_OFS = 16;\n+//!  Suggested external port (request), assigned external port (response) (2 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_PORT_OFS = 18;\n+//!  Suggested external IP (request), assigned external IP (response) (16 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_IP_OFS = 20;\n+\n+//! Result code representing success (RFC6887 7.4), shared with NAT-PMP.\n+constexpr uint8_t PCP_RESULT_SUCCESS = NATPMP_RESULT_SUCCESS;\n+//! Result code representing lack of resources (RFC6887 7.4).\n+constexpr uint8_t PCP_RESULT_NO_RESOURCES = 8;\n+\n+//! Mapping of PCP result code to string (RFC6887 7.4). Result codes <=2 match NAT-PMP.\n+const std::map<uint8_t, std::string> PCP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"MALFORMED_REQUEST\"},\n+    {4,  \"UNSUPP_OPCODE\"},\n+    {5,  \"UNSUPP_OPTION\"},\n+    {6,  \"MALFORMED_OPTION\"},\n+    {7,  \"NETWORK_FAILURE\"},\n+    {8,  \"NO_RESOURCES\"},\n+    {9,  \"UNSUPP_PROTOCOL\"},\n+    {10, \"USER_EX_QUOTA\"},\n+    {11, \"CANNOT_PROVIDE_EXTERNAL\"},\n+    {12, \"ADDRESS_MISMATCH\"},\n+    {13, \"EXCESSIVE_REMOTE_PEER\"},\n+};\n+\n+//! Return human-readable string from NATPMP result code.\n+std::string NATPMPResultString(uint8_t result_code)\n+{\n+    auto result_i = NATPMP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == NATPMP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Return human-readable string from PCP result code.\n+std::string PCPResultString(uint8_t result_code)\n+{\n+    auto result_i = PCP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == PCP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Wrap address in IPv6 according to RFC6887. wrapped_addr needs to be able to store 16 bytes.\n+[[nodiscard]] bool PCPWrapAddress(Span<uint8_t> wrapped_addr, const CNetAddr &addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (addr.IsIPv4()) {\n+        struct in_addr addr4;\n+        if (!addr.GetInAddr(&addr4)) return false;\n+        // Section 5: \"When the address field holds an IPv4 address, an IPv4-mapped IPv6 address [RFC4291] is used (::ffff:0:0/96).\"\n+        std::memcpy(wrapped_addr.data(), IPV4_IN_IPV6_PREFIX.data(), IPV4_IN_IPV6_PREFIX.size());\n+        std::memcpy(wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), &addr4, ADDR_IPV4_SIZE);\n+        return true;\n+    } else if (addr.IsIPv6()) {\n+        struct in6_addr addr6;\n+        if (!addr.GetIn6Addr(&addr6)) return false;\n+        std::memcpy(wrapped_addr.data(), &addr6, ADDR_IPV6_SIZE);\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+//! Unwrap PCP-encoded address according to RFC6887.\n+CNetAddr PCPUnwrapAddress(Span<const uint8_t> wrapped_addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (util::HasPrefix(wrapped_addr, IPV4_IN_IPV6_PREFIX)) {\n+        struct in_addr addr4;\n+        std::memcpy(&addr4, wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), ADDR_IPV4_SIZE);\n+        return CNetAddr(addr4);\n+    } else {\n+        struct in6_addr addr6;\n+        std::memcpy(&addr6, wrapped_addr.data(), ADDR_IPV6_SIZE);\n+        return CNetAddr(addr6);\n+    }\n+}\n+\n+//! PCP or NAT-PMP send-receive loop.\n+std::optional<std::vector<uint8_t>> PCPSendRecv(Sock &sock, const std::string &protocol, Span<const uint8_t> request, int num_tries,\n+        std::chrono::milliseconds timeout_per_try,\n+        std::function<bool(Span<const uint8_t>)> check_packet)\n+{\n+    using namespace std::chrono;\n+    // UDP is a potentially lossy protocol, so we try to send again a few times.\n+    uint8_t response[PCP_MAX_SIZE];\n+    bool got_response = false;\n+    int recvsz = 0;\n+    for (int ntry = 0; !got_response && ntry < num_tries; ++ntry) {\n+        if (ntry > 0) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Retrying (%d)\\n\", protocol, ntry);\n+        }\n+        // Dispatch packet to gateway.\n+        if (sock.Send(request.data(), request.size(), 0) != static_cast<ssize_t>(request.size())) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not send request: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+            return std::nullopt; // Network-level error, probably no use retrying.\n+        }\n+\n+        // Wait for response(s) until we get a valid response, a network error, or time out.\n+        auto cur_time = time_point_cast<milliseconds>(steady_clock::now());\n+        auto deadline = cur_time + timeout_per_try;\n+        while ((cur_time = time_point_cast<milliseconds>(steady_clock::now())) < deadline) {\n+            Sock::Event occurred = 0;\n+            if (!sock.Wait(deadline - cur_time, Sock::RECV, &occurred)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not wait on socket: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            if (!occurred) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Timeout\\n\", protocol);\n+                break; // Retry.\n+            }\n+\n+            // Receive response.\n+            recvsz = sock.Recv(response, sizeof(response), MSG_DONTWAIT);\n+            if (recvsz < 0) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not receive response: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Received response of %d bytes: %s\\n\", protocol, recvsz, HexStr(Span(response, recvsz)));\n+\n+            if (check_packet(Span<uint8_t>(response, recvsz))) {\n+                got_response = true; // Got expected response, break from receive loop as well as from retry loop.\n+                break;\n+            }\n+        }\n+    }\n+    if (!got_response) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Giving up after %d tries\\n\", protocol, num_tries);\n+        return std::nullopt;\n+    }\n+    return std::vector<uint8_t>(response, response + recvsz);\n+}\n+\n+}\n+\n+std::variant<MappingResult, MappingError> NATPMPRequestPortMap(const CNetAddr &gateway, uint16_t port, uint32_t lifetime, int num_tries, std::chrono::milliseconds timeout_per_try)\n+{\n+    struct sockaddr_storage dest_addr;\n+    socklen_t dest_addrlen = sizeof(struct sockaddr_storage);\n+\n+    LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"natpmp: Requesting port mapping port %d from gateway %s\\n\", port, gateway.ToStringAddr());\n+\n+    // Validate gateway, make sure it's IPv4. NAT-PMP does not support IPv6.\n+    if (!CService(gateway, PCP_SERVER_PORT).GetSockAddr((struct sockaddr*)&dest_addr, &dest_addrlen)) return MappingError::NETWORK_ERROR;\n+    if (dest_addr.ss_family != AF_INET) return MappingError::NETWORK_ERROR;\n+\n+    // Create IPv4 UDP socket\n+    auto sock{CreateSock(AF_INET, SOCK_DGRAM, IPPROTO_UDP)};\n+    if (!sock) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Could not create UDP socket: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Associate UDP socket to gateway.\n+    if (sock->Connect((struct sockaddr*)&dest_addr, dest_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Could not connect to gateway: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Use getsockname to get the address toward the default gateway (the internal address).\n+    struct sockaddr_in internal;\n+    socklen_t internal_addrlen = sizeof(struct sockaddr_in);\n+    if (sock->GetSockName((struct sockaddr*)&internal, &internal_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Could not get sock name: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Request external IP address (RFC6886 section 3.2).\n+    std::vector<uint8_t> request(NATPMP_GETEXTERNAL_REQUEST_SIZE);\n+    request[NATPMP_HDR_VERSION_OFS] = NATPMP_VERSION;\n+    request[NATPMP_HDR_OP_OFS] = NATPMP_REQUEST | NATPMP_OP_GETEXTERNAL;\n+\n+    auto recv_res = PCPSendRecv(*sock, \"natpmp\", request, num_tries, timeout_per_try,\n+        [&](const Span<const uint8_t> response) -> bool {\n+            if (response.size() < NATPMP_GETEXTERNAL_RESPONSE_SIZE) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response too small\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            if (response[NATPMP_HDR_VERSION_OFS] != NATPMP_VERSION || response[NATPMP_HDR_OP_OFS] != (NATPMP_RESPONSE | NATPMP_OP_GETEXTERNAL)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response to wrong command\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            return true;\n+        });\n+\n+    struct in_addr external_addr;\n+    if (recv_res) {\n+        const std::span<const uint8_t> response = *recv_res;\n+\n+        Assume(response.size() >= NATPMP_GETEXTERNAL_RESPONSE_SIZE);\n+        uint16_t result_code = ReadBE16(response.data() + NATPMP_RESPONSE_HDR_RESULT_OFS);\n+        if (result_code != NATPMP_RESULT_SUCCESS) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Getting external address failed with result %s\\n\", NATPMPResultString(result_code));\n+            return MappingError::PROTOCOL_ERROR;\n+        }\n+\n+        std::memcpy(&external_addr, response.data() + NATPMP_GETEXTERNAL_RESPONSE_IP_OFS, ADDR_IPV4_SIZE);\n+    } else {\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Create TCP mapping request (RFC6886 section 3.3).\n+    request = std::vector<uint8_t>(NATPMP_MAP_REQUEST_SIZE);\n+    request[NATPMP_HDR_VERSION_OFS] = NATPMP_VERSION;\n+    request[NATPMP_HDR_OP_OFS] = NATPMP_REQUEST | NATPMP_OP_MAP_TCP;\n+    WriteBE16(request.data() + NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS, port);\n+    WriteBE16(request.data() + NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS, port);\n+    WriteBE32(request.data() + NATPMP_MAP_REQUEST_LIFETIME_OFS, lifetime);\n+\n+    recv_res = PCPSendRecv(*sock, \"natpmp\", request, num_tries, timeout_per_try,\n+        [&](const Span<const uint8_t> response) -> bool {\n+            if (response.size() < NATPMP_MAP_RESPONSE_SIZE) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response too small\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            if (response[0] != NATPMP_VERSION || response[1] != (NATPMP_RESPONSE | NATPMP_OP_MAP_TCP)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response to wrong command\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            uint16_t internal_port = ReadBE16(response.data() + NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS);\n+            if (internal_port != port) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response port doesn't match request\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            return true;\n+        });\n+\n+    if (recv_res) {\n+        const std::span<uint8_t> response = *recv_res;\n+\n+        Assume(response.size() >= NATPMP_MAP_RESPONSE_SIZE);\n+        uint16_t result_code = ReadBE16(response.data() + NATPMP_RESPONSE_HDR_RESULT_OFS);\n+        if (result_code != NATPMP_RESULT_SUCCESS) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Port mapping failed with result %s\\n\", NATPMPResultString(result_code));\n+            if (result_code == NATPMP_RESULT_NO_RESOURCES) {\n+                return MappingError::NO_RESOURCES;\n+            }\n+            return MappingError::PROTOCOL_ERROR;\n+        }\n+\n+        uint32_t lifetime_ret = ReadBE32(response.data() + NATPMP_MAP_RESPONSE_LIFETIME_OFS);\n+        uint16_t external_port = ReadBE16(response.data() + NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS);\n+        return MappingResult(NATPMP_VERSION, CService(internal.sin_addr, port), CService(external_addr, external_port), lifetime_ret);\n+    } else {\n+        return MappingError::NETWORK_ERROR;\n+    }\n+}\n+\n+std::variant<MappingResult, MappingError> PCPRequestPortMap(const PCPMappingNonce &nonce, const CNetAddr &gateway, const CNetAddr &bind, uint16_t port, uint32_t lifetime, int num_tries, std::chrono::milliseconds timeout_per_try)\n+{\n+    struct sockaddr_storage dest_addr, bind_addr;\n+    socklen_t dest_addrlen = sizeof(struct sockaddr_storage), bind_addrlen = sizeof(struct sockaddr_storage);\n+\n+    LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"pcp: Requesting port mapping for addr %s port %d from gateway %s\\n\", bind.ToStringAddr(), port, gateway.ToStringAddr());\n+\n+    // Validate addresses, make sure they're the same network family.\n+    if (!CService(gateway, PCP_SERVER_PORT).GetSockAddr((struct sockaddr*)&dest_addr, &dest_addrlen)) return MappingError::NETWORK_ERROR;\n+    if (!CService(bind, 0).GetSockAddr((struct sockaddr*)&bind_addr, &bind_addrlen)) return MappingError::NETWORK_ERROR;\n+    if (dest_addr.ss_family != bind_addr.ss_family) return MappingError::NETWORK_ERROR;\n+\n+    // Create UDP socket (IPv4 or IPv6 based on provided gateway).\n+    auto sock{CreateSock(dest_addr.ss_family, SOCK_DGRAM, IPPROTO_UDP)};\n+    if (!sock) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp: Could not create UDP socket: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Make sure that we send from requested destination address, anything else will be\n+    // rejected by a security-conscious router.\n+    if (sock->Bind((struct sockaddr*)&bind_addr, bind_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp: Could not bind to address: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Associate UDP socket to gateway.\n+    if (sock->Connect((struct sockaddr*)&dest_addr, dest_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp: Could not connect to gateway: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Use getsockname to get the address toward the default gateway (the internal address),\n+    // in case we don't know what address to map\n+    // (this is only needed if bind is INADDR_ANY, but it doesn't hurt as an extra check).\n+    struct sockaddr_storage internal_addr;\n+    socklen_t internal_addrlen = sizeof(struct sockaddr_storage);\n+    if (sock->GetSockName((struct sockaddr*)&internal_addr, &internal_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp: Could not get sock name: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+    CService internal;\n+    if (!internal.SetSockAddr((struct sockaddr*)&internal_addr)) return MappingError::NETWORK_ERROR;\n+    LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"pcp: Internal address after connect: %s\\n\", internal.ToStringAddr());\n+\n+    // Build request packet. Make sure the packet is zeroed so that reserved fields are zero\n+    // as required by the spec (and not potentially leak data).\n+    // Make sure there's space for the request header and MAP specific request data.\n+    std::vector<uint8_t> request(PCP_HDR_SIZE + PCP_MAP_SIZE);\n+    // Fill in request header, See RFC6887 Figure 2.\n+    size_t ofs = 0;\n+    request[ofs + PCP_HDR_VERSION_OFS] = PCP_VERSION;\n+    request[ofs + PCP_HDR_OP_OFS] = PCP_REQUEST | PCP_OP_MAP;\n+    WriteBE32(request.data() + ofs + PCP_HDR_LIFETIME_OFS, lifetime);\n+    if (!PCPWrapAddress(Span(request).subspan(ofs + PCP_REQUEST_HDR_IP_OFS, ADDR_IPV6_SIZE), internal)) return MappingError::NETWORK_ERROR;\n+\n+    ofs += PCP_HDR_SIZE;\n+\n+    // Fill in MAP request packet, See RFC6887 Figure 9.\n+    // Randomize mapping nonce (this is repeated in the response, to be able to\n+    // correlate requests and responses, and used to authenticate changes to the mapping).\n+    std::memcpy(request.data() + ofs + PCP_MAP_NONCE_OFS, nonce.data(), PCP_MAP_NONCE_SIZE);\n+    request[ofs + PCP_MAP_PROTOCOL_OFS] = PCP_PROTOCOL_TCP;\n+    WriteBE16(request.data() + ofs + PCP_MAP_INTERNAL_PORT_OFS, port);\n+    WriteBE16(request.data() + ofs + PCP_MAP_EXTERNAL_PORT_OFS, port);\n+    if (!PCPWrapAddress(Span(request).subspan(ofs + PCP_MAP_EXTERNAL_IP_OFS, ADDR_IPV6_SIZE), bind)) return MappingError::NETWORK_ERROR;\n+\n+    ofs += PCP_MAP_SIZE;\n+    Assume(ofs == request.size());\n+\n+    // Receive loop.\n+    bool is_natpmp = false;\n+    auto recv_res = PCPSendRecv(*sock, \"pcp\", request, num_tries, timeout_per_try,\n+        [&](const Span<const uint8_t> response) -> bool {\n+            // Unsupported version according to RFC6887 appendix A and RFC6886 section 3.5, can fall back to NAT-PMP.\n+            if (response.size() == NATPMP_RESPONSE_HDR_SIZE && response[PCP_HDR_VERSION_OFS] == NATPMP_VERSION && response[PCP_RESPONSE_HDR_RESULT_OFS] == NATPMP_RESULT_UNSUPP_VERSION) {\n+                is_natpmp = true;\n+                return true; // Let it through to caller.\n+            }\n+            if (response.size() < (PCP_HDR_SIZE + PCP_MAP_SIZE)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp: Response too small\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            if (response[PCP_HDR_VERSION_OFS] != PCP_VERSION || response[PCP_HDR_OP_OFS] != (PCP_RESPONSE | PCP_OP_MAP)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp: Response to wrong command\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            // Handle MAP opcode response. See RFC6887 Figure 10.\n+            // Check that returned mapping nonce matches our request.\n+            if (response.subspan(PCP_HDR_SIZE + PCP_MAP_NONCE_OFS, PCP_MAP_NONCE_SIZE) != Span(nonce)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp: Mapping nonce mismatch\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            uint8_t protocol = response[PCP_HDR_SIZE + 12];\n+            uint16_t internal_port = ReadBE16(response.data() + PCP_HDR_SIZE + 16);",
      "path": "src/util/pcp.cpp",
      "position": 481,
      "original_position": 481,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "23916f2a7717b463799207b4b81b5795f2e9d7e3",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Replace magic numbers with the constants:\r\n\r\n```suggestion\r\n            uint8_t protocol = response[PCP_HDR_SIZE + PCP_MAP_PROTOCOL_OFS];\r\n            uint16_t internal_port = ReadBE16(response.data() + PCP_HDR_SIZE + PCP_MAP_INTERNAL_PORT_OFS);\r\n```",
      "created_at": "2024-06-28T12:13:23Z",
      "updated_at": "2024-06-28T15:24:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1658654045",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1658654045"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": 480,
      "original_start_line": 480,
      "start_side": "RIGHT",
      "line": 481,
      "original_line": 481,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1658751623",
      "pull_request_review_id": 2141814858,
      "id": 1658751623,
      "node_id": "PRRC_kwDOABII585i3oqH",
      "diff_hunk": "@@ -46,104 +43,96 @@ using namespace std::chrono_literals;\n static constexpr auto PORT_MAPPING_REANNOUNCE_PERIOD{20min};\n static constexpr auto PORT_MAPPING_RETRY_PERIOD{5min};\n \n-#ifdef USE_NATPMP\n-static uint16_t g_mapport_external_port = 0;\n-static bool NatpmpInit(natpmp_t* natpmp)\n+static bool ProcessPCP()\n {\n-    const int r_init = initnatpmp(natpmp, /* detect gateway automatically */ 0, /* forced gateway - NOT APPLIED*/ 0);\n-    if (r_init == 0) return true;\n-    LogPrintf(\"natpmp: initnatpmp() failed with %d error.\\n\", r_init);\n-    return false;\n-}\n+    // The same nonce is used for all mappings, this is allowed by the spec, and simplifies keeping track of them.\n+    PCPMappingNonce pcp_nonce;\n+    GetRandBytes(pcp_nonce);\n \n-static bool NatpmpDiscover(natpmp_t* natpmp, struct in_addr& external_ipv4_addr)\n-{\n-    const int r_send = sendpublicaddressrequest(natpmp);\n-    if (r_send == 2 /* OK */) {\n-        int r_read;\n-        natpmpresp_t response;\n-        do {\n-            r_read = readnatpmpresponseorretry(natpmp, &response);\n-        } while (r_read == NATPMP_TRYAGAIN);\n-\n-        if (r_read == 0) {\n-            external_ipv4_addr = response.pnu.publicaddress.addr;\n-            return true;\n-        } else if (r_read == NATPMP_ERR_NOGATEWAYSUPPORT) {\n-            LogPrintf(\"natpmp: The gateway does not support NAT-PMP.\\n\");\n+    bool ret = false;\n+    bool no_resources = false;\n+    const uint16_t private_port = GetListenPort();\n+    // Multiply the reannounce period by two, as we'll try to renew approximately halfway.\n+    const uint32_t requested_lifetime = std::chrono::seconds(PORT_MAPPING_REANNOUNCE_PERIOD * 2).count();\n+    uint32_t actual_lifetime = 0;\n+    std::chrono::milliseconds sleep_time;\n+\n+    // Local functor to handle result from PCP/NATPMP mapping.\n+    auto handle_mapping = [&](std::variant<MappingResult, MappingError> &res) -> void {\n+        if (MappingResult* mapping = std::get_if<MappingResult>(&res)) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Info, \"portmap: Added mapping %s\\n\", mapping->ToString());\n+            AddLocal(mapping->external, LOCAL_MAPPED);\n+            ret = true;\n+            actual_lifetime = std::min(actual_lifetime, mapping->lifetime);",
      "path": "src/mapport.cpp",
      "position": 73,
      "original_position": 73,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "23916f2a7717b463799207b4b81b5795f2e9d7e3",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Why choose the minimum? To me this looks like it should be:\r\n\r\n```cpp\r\nactual_lifetime = mapping->lifetime;\r\n```\r\n\r\nIs it because there is just one `actual_lifetime` for all mappings? What about storing each (successful) map? Then we would have individual actual lifetimes and the assigned port, to be used for renewals.",
      "created_at": "2024-06-28T13:32:11Z",
      "updated_at": "2024-06-28T15:24:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1658751623",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1658751623"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 66,
      "original_line": 66,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1658764974",
      "pull_request_review_id": 2141814858,
      "id": 1658764974,
      "node_id": "PRRC_kwDOABII585i3r6u",
      "diff_hunk": "@@ -46,104 +43,96 @@ using namespace std::chrono_literals;\n static constexpr auto PORT_MAPPING_REANNOUNCE_PERIOD{20min};\n static constexpr auto PORT_MAPPING_RETRY_PERIOD{5min};\n \n-#ifdef USE_NATPMP\n-static uint16_t g_mapport_external_port = 0;\n-static bool NatpmpInit(natpmp_t* natpmp)\n+static bool ProcessPCP()\n {\n-    const int r_init = initnatpmp(natpmp, /* detect gateway automatically */ 0, /* forced gateway - NOT APPLIED*/ 0);\n-    if (r_init == 0) return true;\n-    LogPrintf(\"natpmp: initnatpmp() failed with %d error.\\n\", r_init);\n-    return false;\n-}\n+    // The same nonce is used for all mappings, this is allowed by the spec, and simplifies keeping track of them.\n+    PCPMappingNonce pcp_nonce;\n+    GetRandBytes(pcp_nonce);\n \n-static bool NatpmpDiscover(natpmp_t* natpmp, struct in_addr& external_ipv4_addr)\n-{\n-    const int r_send = sendpublicaddressrequest(natpmp);\n-    if (r_send == 2 /* OK */) {\n-        int r_read;\n-        natpmpresp_t response;\n-        do {\n-            r_read = readnatpmpresponseorretry(natpmp, &response);\n-        } while (r_read == NATPMP_TRYAGAIN);\n-\n-        if (r_read == 0) {\n-            external_ipv4_addr = response.pnu.publicaddress.addr;\n-            return true;\n-        } else if (r_read == NATPMP_ERR_NOGATEWAYSUPPORT) {\n-            LogPrintf(\"natpmp: The gateway does not support NAT-PMP.\\n\");\n+    bool ret = false;\n+    bool no_resources = false;\n+    const uint16_t private_port = GetListenPort();\n+    // Multiply the reannounce period by two, as we'll try to renew approximately halfway.\n+    const uint32_t requested_lifetime = std::chrono::seconds(PORT_MAPPING_REANNOUNCE_PERIOD * 2).count();\n+    uint32_t actual_lifetime = 0;\n+    std::chrono::milliseconds sleep_time;\n+\n+    // Local functor to handle result from PCP/NATPMP mapping.\n+    auto handle_mapping = [&](std::variant<MappingResult, MappingError> &res) -> void {\n+        if (MappingResult* mapping = std::get_if<MappingResult>(&res)) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Info, \"portmap: Added mapping %s\\n\", mapping->ToString());\n+            AddLocal(mapping->external, LOCAL_MAPPED);\n+            ret = true;\n+            actual_lifetime = std::min(actual_lifetime, mapping->lifetime);\n+        } else if (MappingError *err = std::get_if<MappingError>(&res)) {\n+            // Detailed error will already have been logged internally in respective Portmap function.\n+            if (*err == MappingError::NO_RESOURCES) {\n+                no_resources = true;\n+            }\n+        }\n+    };\n+\n+    do {\n+        actual_lifetime = requested_lifetime;\n+        no_resources = false; // Set to true if there was any \"no resources\" error.\n+        ret = false; // Set to true if any mapping succeeds.\n+\n+        // IPv4\n+        std::optional<CNetAddr> gateway4 = QueryDefaultGateway(NET_IPV4);\n+        if (!gateway4) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: Could not determine IPv4 default gateway\\n\");\n         } else {\n-            LogPrintf(\"natpmp: readnatpmpresponseorretry() for public address failed with %d error.\\n\", r_read);\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: gateway [IPv4]: %s\\n\", gateway4->ToStringAddr());\n+\n+            // Open a port mapping on whatever local address we have toward the gateway.\n+            struct in_addr inaddr_any;\n+            inaddr_any.s_addr = htonl(INADDR_ANY);\n+            auto res = PCPRequestPortMap(pcp_nonce, *gateway4, CNetAddr(inaddr_any), private_port, requested_lifetime);\n+            MappingError* pcp_err = std::get_if<MappingError>(&res);\n+            if (pcp_err && *pcp_err == MappingError::UNSUPP_VERSION) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: Got unsupported PCP version response, falling back to NAT-PMP\\n\");\n+                res = NATPMPRequestPortMap(*gateway4, private_port, requested_lifetime);\n+            }\n+            handle_mapping(res);\n         }\n-    } else {\n-        LogPrintf(\"natpmp: sendpublicaddressrequest() failed with %d error.\\n\", r_send);\n-    }\n \n-    return false;\n-}\n+        // IPv6\n+        std::optional<CNetAddr> gateway6 = QueryDefaultGateway(NET_IPV6);\n+        if (!gateway6) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: Could not determine IPv6 default gateway\\n\");",
      "path": "src/mapport.cpp",
      "position": 115,
      "original_position": 115,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "23916f2a7717b463799207b4b81b5795f2e9d7e3",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Should the attempts to do IPv6 only be done if `g_reachable_nets.Contains(NET_IPV6)` is true? Same for IPv4.",
      "created_at": "2024-06-28T13:38:09Z",
      "updated_at": "2024-06-28T15:24:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1658764974",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1658764974"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 102,
      "original_line": 102,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1658779455",
      "pull_request_review_id": 2141814858,
      "id": 1658779455,
      "node_id": "PRRC_kwDOABII585i3vc_",
      "diff_hunk": "@@ -46,104 +43,96 @@ using namespace std::chrono_literals;\n static constexpr auto PORT_MAPPING_REANNOUNCE_PERIOD{20min};\n static constexpr auto PORT_MAPPING_RETRY_PERIOD{5min};\n \n-#ifdef USE_NATPMP\n-static uint16_t g_mapport_external_port = 0;\n-static bool NatpmpInit(natpmp_t* natpmp)\n+static bool ProcessPCP()\n {\n-    const int r_init = initnatpmp(natpmp, /* detect gateway automatically */ 0, /* forced gateway - NOT APPLIED*/ 0);\n-    if (r_init == 0) return true;\n-    LogPrintf(\"natpmp: initnatpmp() failed with %d error.\\n\", r_init);\n-    return false;\n-}\n+    // The same nonce is used for all mappings, this is allowed by the spec, and simplifies keeping track of them.\n+    PCPMappingNonce pcp_nonce;\n+    GetRandBytes(pcp_nonce);\n \n-static bool NatpmpDiscover(natpmp_t* natpmp, struct in_addr& external_ipv4_addr)\n-{\n-    const int r_send = sendpublicaddressrequest(natpmp);\n-    if (r_send == 2 /* OK */) {\n-        int r_read;\n-        natpmpresp_t response;\n-        do {\n-            r_read = readnatpmpresponseorretry(natpmp, &response);\n-        } while (r_read == NATPMP_TRYAGAIN);\n-\n-        if (r_read == 0) {\n-            external_ipv4_addr = response.pnu.publicaddress.addr;\n-            return true;\n-        } else if (r_read == NATPMP_ERR_NOGATEWAYSUPPORT) {\n-            LogPrintf(\"natpmp: The gateway does not support NAT-PMP.\\n\");\n+    bool ret = false;\n+    bool no_resources = false;\n+    const uint16_t private_port = GetListenPort();\n+    // Multiply the reannounce period by two, as we'll try to renew approximately halfway.\n+    const uint32_t requested_lifetime = std::chrono::seconds(PORT_MAPPING_REANNOUNCE_PERIOD * 2).count();\n+    uint32_t actual_lifetime = 0;\n+    std::chrono::milliseconds sleep_time;\n+\n+    // Local functor to handle result from PCP/NATPMP mapping.\n+    auto handle_mapping = [&](std::variant<MappingResult, MappingError> &res) -> void {\n+        if (MappingResult* mapping = std::get_if<MappingResult>(&res)) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Info, \"portmap: Added mapping %s\\n\", mapping->ToString());\n+            AddLocal(mapping->external, LOCAL_MAPPED);\n+            ret = true;\n+            actual_lifetime = std::min(actual_lifetime, mapping->lifetime);\n+        } else if (MappingError *err = std::get_if<MappingError>(&res)) {\n+            // Detailed error will already have been logged internally in respective Portmap function.\n+            if (*err == MappingError::NO_RESOURCES) {\n+                no_resources = true;\n+            }\n+        }\n+    };\n+\n+    do {\n+        actual_lifetime = requested_lifetime;\n+        no_resources = false; // Set to true if there was any \"no resources\" error.\n+        ret = false; // Set to true if any mapping succeeds.\n+\n+        // IPv4\n+        std::optional<CNetAddr> gateway4 = QueryDefaultGateway(NET_IPV4);\n+        if (!gateway4) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: Could not determine IPv4 default gateway\\n\");\n         } else {\n-            LogPrintf(\"natpmp: readnatpmpresponseorretry() for public address failed with %d error.\\n\", r_read);\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: gateway [IPv4]: %s\\n\", gateway4->ToStringAddr());\n+\n+            // Open a port mapping on whatever local address we have toward the gateway.\n+            struct in_addr inaddr_any;\n+            inaddr_any.s_addr = htonl(INADDR_ANY);\n+            auto res = PCPRequestPortMap(pcp_nonce, *gateway4, CNetAddr(inaddr_any), private_port, requested_lifetime);",
      "path": "src/mapport.cpp",
      "position": 98,
      "original_position": 98,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "23916f2a7717b463799207b4b81b5795f2e9d7e3",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "This would use the same port for renewals as well, but https://www.rfc-editor.org/rfc/rfc6886#section-3.3 says:\r\n\r\n> The renewal packet should look exactly the same as\r\n   a request packet, except that the client SHOULD set the Suggested\r\n   External Port to what the NAT gateway previously mapped, not what the\r\n   client originally suggested.",
      "created_at": "2024-06-28T13:45:27Z",
      "updated_at": "2024-06-28T15:24:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1658779455",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1658779455"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 90,
      "original_line": 90,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1658879358",
      "pull_request_review_id": 2141814858,
      "id": 1658879358,
      "node_id": "PRRC_kwDOABII585i4H1-",
      "diff_hunk": "@@ -46,104 +43,96 @@ using namespace std::chrono_literals;\n static constexpr auto PORT_MAPPING_REANNOUNCE_PERIOD{20min};\n static constexpr auto PORT_MAPPING_RETRY_PERIOD{5min};\n \n-#ifdef USE_NATPMP\n-static uint16_t g_mapport_external_port = 0;\n-static bool NatpmpInit(natpmp_t* natpmp)\n+static bool ProcessPCP()\n {\n-    const int r_init = initnatpmp(natpmp, /* detect gateway automatically */ 0, /* forced gateway - NOT APPLIED*/ 0);\n-    if (r_init == 0) return true;\n-    LogPrintf(\"natpmp: initnatpmp() failed with %d error.\\n\", r_init);\n-    return false;\n-}\n+    // The same nonce is used for all mappings, this is allowed by the spec, and simplifies keeping track of them.\n+    PCPMappingNonce pcp_nonce;\n+    GetRandBytes(pcp_nonce);\n \n-static bool NatpmpDiscover(natpmp_t* natpmp, struct in_addr& external_ipv4_addr)\n-{\n-    const int r_send = sendpublicaddressrequest(natpmp);\n-    if (r_send == 2 /* OK */) {\n-        int r_read;\n-        natpmpresp_t response;\n-        do {\n-            r_read = readnatpmpresponseorretry(natpmp, &response);\n-        } while (r_read == NATPMP_TRYAGAIN);\n-\n-        if (r_read == 0) {\n-            external_ipv4_addr = response.pnu.publicaddress.addr;\n-            return true;\n-        } else if (r_read == NATPMP_ERR_NOGATEWAYSUPPORT) {\n-            LogPrintf(\"natpmp: The gateway does not support NAT-PMP.\\n\");\n+    bool ret = false;\n+    bool no_resources = false;\n+    const uint16_t private_port = GetListenPort();\n+    // Multiply the reannounce period by two, as we'll try to renew approximately halfway.\n+    const uint32_t requested_lifetime = std::chrono::seconds(PORT_MAPPING_REANNOUNCE_PERIOD * 2).count();\n+    uint32_t actual_lifetime = 0;\n+    std::chrono::milliseconds sleep_time;\n+\n+    // Local functor to handle result from PCP/NATPMP mapping.\n+    auto handle_mapping = [&](std::variant<MappingResult, MappingError> &res) -> void {\n+        if (MappingResult* mapping = std::get_if<MappingResult>(&res)) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Info, \"portmap: Added mapping %s\\n\", mapping->ToString());\n+            AddLocal(mapping->external, LOCAL_MAPPED);\n+            ret = true;\n+            actual_lifetime = std::min(actual_lifetime, mapping->lifetime);\n+        } else if (MappingError *err = std::get_if<MappingError>(&res)) {\n+            // Detailed error will already have been logged internally in respective Portmap function.\n+            if (*err == MappingError::NO_RESOURCES) {\n+                no_resources = true;\n+            }\n+        }\n+    };\n+\n+    do {\n+        actual_lifetime = requested_lifetime;\n+        no_resources = false; // Set to true if there was any \"no resources\" error.\n+        ret = false; // Set to true if any mapping succeeds.\n+\n+        // IPv4\n+        std::optional<CNetAddr> gateway4 = QueryDefaultGateway(NET_IPV4);\n+        if (!gateway4) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: Could not determine IPv4 default gateway\\n\");\n         } else {\n-            LogPrintf(\"natpmp: readnatpmpresponseorretry() for public address failed with %d error.\\n\", r_read);\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: gateway [IPv4]: %s\\n\", gateway4->ToStringAddr());\n+\n+            // Open a port mapping on whatever local address we have toward the gateway.\n+            struct in_addr inaddr_any;\n+            inaddr_any.s_addr = htonl(INADDR_ANY);\n+            auto res = PCPRequestPortMap(pcp_nonce, *gateway4, CNetAddr(inaddr_any), private_port, requested_lifetime);\n+            MappingError* pcp_err = std::get_if<MappingError>(&res);\n+            if (pcp_err && *pcp_err == MappingError::UNSUPP_VERSION) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: Got unsupported PCP version response, falling back to NAT-PMP\\n\");\n+                res = NATPMPRequestPortMap(*gateway4, private_port, requested_lifetime);\n+            }\n+            handle_mapping(res);\n         }\n-    } else {\n-        LogPrintf(\"natpmp: sendpublicaddressrequest() failed with %d error.\\n\", r_send);\n-    }\n \n-    return false;\n-}\n+        // IPv6\n+        std::optional<CNetAddr> gateway6 = QueryDefaultGateway(NET_IPV6);\n+        if (!gateway6) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: Could not determine IPv6 default gateway\\n\");\n+        } else {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: gateway [IPv6]: %s\\n\", gateway6->ToStringAddr());\n \n-static bool NatpmpMapping(natpmp_t* natpmp, const struct in_addr& external_ipv4_addr, uint16_t private_port, bool& external_ip_discovered)\n-{\n-    const uint16_t suggested_external_port = g_mapport_external_port ? g_mapport_external_port : private_port;\n-    const int r_send = sendnewportmappingrequest(natpmp, NATPMP_PROTOCOL_TCP, private_port, suggested_external_port, 3600 /*seconds*/);\n-    if (r_send == 12 /* OK */) {\n-        int r_read;\n-        natpmpresp_t response;\n-        do {\n-            r_read = readnatpmpresponseorretry(natpmp, &response);\n-        } while (r_read == NATPMP_TRYAGAIN);\n-\n-        if (r_read == 0) {\n-            auto pm = response.pnu.newportmapping;\n-            if (private_port == pm.privateport && pm.lifetime > 0) {\n-                g_mapport_external_port = pm.mappedpublicport;\n-                const CService external{external_ipv4_addr, pm.mappedpublicport};\n-                if (!external_ip_discovered && fDiscover) {\n-                    AddLocal(external, LOCAL_MAPPED);\n-                    external_ip_discovered = true;\n-                }\n-                LogPrintf(\"natpmp: Port mapping successful. External address = %s\\n\", external.ToStringAddrPort());\n-                return true;\n-            } else {\n-                LogPrintf(\"natpmp: Port mapping failed.\\n\");\n+            // Try to open pinholes for all routable local IPv6 addresses.\n+            for (const auto &addr: GetLocalAddresses()) {\n+                if (!addr.IsRoutable() || !addr.IsIPv6()) continue;\n+                auto res = PCPRequestPortMap(pcp_nonce, *gateway6, addr, private_port, requested_lifetime);",
      "path": "src/mapport.cpp",
      "position": 146,
      "original_position": 146,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "23916f2a7717b463799207b4b81b5795f2e9d7e3",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Why make mappings for all local IPv6 addresses? Given that this is the same gateway, I think it is going to result in multiple mappings on the same external IPv6 address but on different ports.",
      "created_at": "2024-06-28T14:54:27Z",
      "updated_at": "2024-06-28T15:24:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1658879358",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1658879358"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": 106,
      "original_start_line": 106,
      "start_side": "RIGHT",
      "line": 109,
      "original_line": 109,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1658892377",
      "pull_request_review_id": 2141814858,
      "id": 1658892377,
      "node_id": "PRRC_kwDOABII585i4LBZ",
      "diff_hunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/pcp.h>\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <span.h>\n+#include <util/check.h>\n+#include <util/netif.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+namespace {\n+\n+// RFC6886 NAT-PMP and RFC6887 Port Control Protocol (PCP) implementation.\n+// NAT-PMP and PCP use network byte order (big-endian).\n+\n+// NAT-PMP (v0) protocol constants.\n+//! NAT-PMP uses a fixed server port number (RFC6887 section 1.1).\n+constexpr uint16_t NATPMP_SERVER_PORT = 5351;\n+//! Version byte for NATPMP (RFC6886 1.1)\n+constexpr uint8_t NATPMP_VERSION = 0;\n+//! Request opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_REQUEST = 0x00;\n+//! Response opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_RESPONSE = 0x80;\n+//! Get external address (RFC6886 3.2)\n+constexpr uint8_t NATPMP_OP_GETEXTERNAL = 0x00;\n+//! Map TCP port (RFC6886 3.3)\n+constexpr uint8_t NATPMP_OP_MAP_TCP = 0x02;\n+//! Shared request header size in bytes.\n+constexpr size_t NATPMP_REQUEST_HDR_SIZE = 2;\n+//! Shared response header (minimum) size in bytes.\n+constexpr size_t NATPMP_RESPONSE_HDR_SIZE = 8;\n+//! GETEXTERNAL request size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 0;\n+//! GETEXTERNAL response size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 4;\n+//! MAP request size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 10;\n+//! MAP response size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 8;\n+\n+// Shared header offsets (RFC6886 3.2, 3.3), relative to start of packet.\n+//!  Offset of version field in packets.\n+constexpr size_t NATPMP_HDR_VERSION_OFS = 0;\n+//!  Offset of opcode field in packets\n+constexpr size_t NATPMP_HDR_OP_OFS = 1;\n+//!  Offset of result code in packets. Result codes are 16 bit in NAT-PMP instead of 8 bit in PCP.\n+constexpr size_t NATPMP_RESPONSE_HDR_RESULT_OFS = 2;\n+\n+// GETEXTERNAL response offsets (RFC6886 3.2), relative to start of packet.\n+//!  Returned external address\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_IP_OFS = 8;\n+\n+// MAP request offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port to be mapped.\n+constexpr size_t NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS = 4;\n+//!  Suggested external port for mapping.\n+constexpr size_t NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS = 6;\n+//!  Requested port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_REQUEST_LIFETIME_OFS = 8;\n+\n+// MAP response offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port for mapping (will match internal port of request).\n+constexpr size_t NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS = 8;\n+//!  External port for mapping.\n+constexpr size_t NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS = 10;\n+//!  Created port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_RESPONSE_LIFETIME_OFS = 12;\n+\n+// Relevant NETPMP result codes (RFC6886 3.5).\n+//! Result code representing success status.\n+constexpr uint8_t NATPMP_RESULT_SUCCESS = 0;\n+//! Result code representing unsupported version.\n+constexpr uint8_t NATPMP_RESULT_UNSUPP_VERSION = 1;\n+//! Result code representing lack of resources.\n+constexpr uint8_t NATPMP_RESULT_NO_RESOURCES = 4;\n+\n+//! Mapping of NATPMP result code to string (RFC6886 3.5). Result codes <=2 match PCP.\n+const std::map<uint8_t, std::string> NATPMP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"NETWORK_FAILURE\"},\n+    {4,  \"NO_RESOURCES\"},\n+    {5,  \"UNSUPP_OPCODE\"},\n+};\n+\n+// PCP (v2) protocol constants.\n+//! Maximum packet size in bytes (RFC6887 section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (RFC6887 section 19.1). Shared with NAT-PMP.\n+constexpr uint16_t PCP_SERVER_PORT = NATPMP_SERVER_PORT;\n+//! Version byte. 0 is NAT-PMP (RFC6886), 1 is forbidden, 2 for PCP (RFC6887).\n+constexpr uint8_t PCP_VERSION = 2;\n+//! PCP Request Header. See RFC6887 section 7.1. Shared with NAT-PMP.\n+constexpr uint8_t PCP_REQUEST = NATPMP_REQUEST; // R = 0\n+//! PCP Response Header. See RFC6887 section 7.2. Shared with NAT-PMP.\n+constexpr uint8_t PCP_RESPONSE = NATPMP_RESPONSE; // R = 1\n+//! Map opcode. See RFC6887 section 19.2\n+constexpr uint8_t PCP_OP_MAP = 0x01;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Request and response header size in bytes (RFC6887 section 7.1).\n+constexpr size_t PCP_HDR_SIZE = 24;\n+//! Map request and response size in bytes (RFC6887 section 11.1).\n+constexpr size_t PCP_MAP_SIZE = 36;\n+\n+// Header offsets shared between request and responses (RFC6887 7.1, 7.2), relative to start of packet.\n+//!  Version field (1 byte).\n+constexpr size_t PCP_HDR_VERSION_OFS = NATPMP_HDR_VERSION_OFS;\n+//!  Opcode field (1 byte).\n+constexpr size_t PCP_HDR_OP_OFS = NATPMP_HDR_OP_OFS;\n+//!  Requested lifetime (request), granted lifetime (response) (2 bytes).\n+constexpr size_t PCP_HDR_LIFETIME_OFS = 4;\n+\n+// Request header offsets (RFC6887 7.1), relative to start of packet.\n+//!  PCP client's IP address (16 bytes).\n+constexpr size_t PCP_REQUEST_HDR_IP_OFS = 8;\n+\n+// Response header offsets (RFC6887 7.2), relative to start of packet.\n+//!  Result code (1 byte).\n+constexpr size_t PCP_RESPONSE_HDR_RESULT_OFS = 3;\n+\n+// MAP request/response offsets (RFC6887 11.1), relative to start of opcode-specific data.\n+//!  Mapping nonce (12 bytes).\n+constexpr size_t PCP_MAP_NONCE_OFS = 0;\n+//!  Protocol (1 byte).\n+constexpr size_t PCP_MAP_PROTOCOL_OFS = 12;\n+//!  Internal port for mapping (2 bytes).\n+constexpr size_t PCP_MAP_INTERNAL_PORT_OFS = 16;\n+//!  Suggested external port (request), assigned external port (response) (2 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_PORT_OFS = 18;\n+//!  Suggested external IP (request), assigned external IP (response) (16 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_IP_OFS = 20;\n+\n+//! Result code representing success (RFC6887 7.4), shared with NAT-PMP.\n+constexpr uint8_t PCP_RESULT_SUCCESS = NATPMP_RESULT_SUCCESS;\n+//! Result code representing lack of resources (RFC6887 7.4).\n+constexpr uint8_t PCP_RESULT_NO_RESOURCES = 8;\n+\n+//! Mapping of PCP result code to string (RFC6887 7.4). Result codes <=2 match NAT-PMP.\n+const std::map<uint8_t, std::string> PCP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"MALFORMED_REQUEST\"},\n+    {4,  \"UNSUPP_OPCODE\"},\n+    {5,  \"UNSUPP_OPTION\"},\n+    {6,  \"MALFORMED_OPTION\"},\n+    {7,  \"NETWORK_FAILURE\"},\n+    {8,  \"NO_RESOURCES\"},\n+    {9,  \"UNSUPP_PROTOCOL\"},\n+    {10, \"USER_EX_QUOTA\"},\n+    {11, \"CANNOT_PROVIDE_EXTERNAL\"},\n+    {12, \"ADDRESS_MISMATCH\"},\n+    {13, \"EXCESSIVE_REMOTE_PEER\"},\n+};\n+\n+//! Return human-readable string from NATPMP result code.\n+std::string NATPMPResultString(uint8_t result_code)\n+{\n+    auto result_i = NATPMP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == NATPMP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Return human-readable string from PCP result code.\n+std::string PCPResultString(uint8_t result_code)\n+{\n+    auto result_i = PCP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == PCP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Wrap address in IPv6 according to RFC6887. wrapped_addr needs to be able to store 16 bytes.\n+[[nodiscard]] bool PCPWrapAddress(Span<uint8_t> wrapped_addr, const CNetAddr &addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (addr.IsIPv4()) {\n+        struct in_addr addr4;\n+        if (!addr.GetInAddr(&addr4)) return false;\n+        // Section 5: \"When the address field holds an IPv4 address, an IPv4-mapped IPv6 address [RFC4291] is used (::ffff:0:0/96).\"\n+        std::memcpy(wrapped_addr.data(), IPV4_IN_IPV6_PREFIX.data(), IPV4_IN_IPV6_PREFIX.size());\n+        std::memcpy(wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), &addr4, ADDR_IPV4_SIZE);\n+        return true;\n+    } else if (addr.IsIPv6()) {\n+        struct in6_addr addr6;\n+        if (!addr.GetIn6Addr(&addr6)) return false;\n+        std::memcpy(wrapped_addr.data(), &addr6, ADDR_IPV6_SIZE);\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+//! Unwrap PCP-encoded address according to RFC6887.\n+CNetAddr PCPUnwrapAddress(Span<const uint8_t> wrapped_addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (util::HasPrefix(wrapped_addr, IPV4_IN_IPV6_PREFIX)) {\n+        struct in_addr addr4;\n+        std::memcpy(&addr4, wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), ADDR_IPV4_SIZE);\n+        return CNetAddr(addr4);\n+    } else {\n+        struct in6_addr addr6;\n+        std::memcpy(&addr6, wrapped_addr.data(), ADDR_IPV6_SIZE);\n+        return CNetAddr(addr6);\n+    }\n+}\n+\n+//! PCP or NAT-PMP send-receive loop.\n+std::optional<std::vector<uint8_t>> PCPSendRecv(Sock &sock, const std::string &protocol, Span<const uint8_t> request, int num_tries,\n+        std::chrono::milliseconds timeout_per_try,\n+        std::function<bool(Span<const uint8_t>)> check_packet)\n+{\n+    using namespace std::chrono;\n+    // UDP is a potentially lossy protocol, so we try to send again a few times.\n+    uint8_t response[PCP_MAX_SIZE];\n+    bool got_response = false;\n+    int recvsz = 0;\n+    for (int ntry = 0; !got_response && ntry < num_tries; ++ntry) {\n+        if (ntry > 0) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Retrying (%d)\\n\", protocol, ntry);\n+        }\n+        // Dispatch packet to gateway.\n+        if (sock.Send(request.data(), request.size(), 0) != static_cast<ssize_t>(request.size())) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not send request: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+            return std::nullopt; // Network-level error, probably no use retrying.\n+        }\n+\n+        // Wait for response(s) until we get a valid response, a network error, or time out.\n+        auto cur_time = time_point_cast<milliseconds>(steady_clock::now());\n+        auto deadline = cur_time + timeout_per_try;\n+        while ((cur_time = time_point_cast<milliseconds>(steady_clock::now())) < deadline) {\n+            Sock::Event occurred = 0;\n+            if (!sock.Wait(deadline - cur_time, Sock::RECV, &occurred)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not wait on socket: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            if (!occurred) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Timeout\\n\", protocol);\n+                break; // Retry.\n+            }\n+\n+            // Receive response.\n+            recvsz = sock.Recv(response, sizeof(response), MSG_DONTWAIT);\n+            if (recvsz < 0) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not receive response: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Received response of %d bytes: %s\\n\", protocol, recvsz, HexStr(Span(response, recvsz)));\n+\n+            if (check_packet(Span<uint8_t>(response, recvsz))) {\n+                got_response = true; // Got expected response, break from receive loop as well as from retry loop.\n+                break;\n+            }\n+        }\n+    }\n+    if (!got_response) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Giving up after %d tries\\n\", protocol, num_tries);\n+        return std::nullopt;\n+    }\n+    return std::vector<uint8_t>(response, response + recvsz);\n+}\n+\n+}\n+\n+std::variant<MappingResult, MappingError> NATPMPRequestPortMap(const CNetAddr &gateway, uint16_t port, uint32_t lifetime, int num_tries, std::chrono::milliseconds timeout_per_try)\n+{\n+    struct sockaddr_storage dest_addr;\n+    socklen_t dest_addrlen = sizeof(struct sockaddr_storage);\n+\n+    LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"natpmp: Requesting port mapping port %d from gateway %s\\n\", port, gateway.ToStringAddr());\n+\n+    // Validate gateway, make sure it's IPv4. NAT-PMP does not support IPv6.\n+    if (!CService(gateway, PCP_SERVER_PORT).GetSockAddr((struct sockaddr*)&dest_addr, &dest_addrlen)) return MappingError::NETWORK_ERROR;\n+    if (dest_addr.ss_family != AF_INET) return MappingError::NETWORK_ERROR;\n+\n+    // Create IPv4 UDP socket\n+    auto sock{CreateSock(AF_INET, SOCK_DGRAM, IPPROTO_UDP)};\n+    if (!sock) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Could not create UDP socket: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Associate UDP socket to gateway.\n+    if (sock->Connect((struct sockaddr*)&dest_addr, dest_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Could not connect to gateway: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Use getsockname to get the address toward the default gateway (the internal address).\n+    struct sockaddr_in internal;\n+    socklen_t internal_addrlen = sizeof(struct sockaddr_in);\n+    if (sock->GetSockName((struct sockaddr*)&internal, &internal_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Could not get sock name: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Request external IP address (RFC6886 section 3.2).\n+    std::vector<uint8_t> request(NATPMP_GETEXTERNAL_REQUEST_SIZE);\n+    request[NATPMP_HDR_VERSION_OFS] = NATPMP_VERSION;\n+    request[NATPMP_HDR_OP_OFS] = NATPMP_REQUEST | NATPMP_OP_GETEXTERNAL;\n+\n+    auto recv_res = PCPSendRecv(*sock, \"natpmp\", request, num_tries, timeout_per_try,\n+        [&](const Span<const uint8_t> response) -> bool {\n+            if (response.size() < NATPMP_GETEXTERNAL_RESPONSE_SIZE) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response too small\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            if (response[NATPMP_HDR_VERSION_OFS] != NATPMP_VERSION || response[NATPMP_HDR_OP_OFS] != (NATPMP_RESPONSE | NATPMP_OP_GETEXTERNAL)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response to wrong command\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            return true;\n+        });\n+\n+    struct in_addr external_addr;\n+    if (recv_res) {\n+        const std::span<const uint8_t> response = *recv_res;\n+\n+        Assume(response.size() >= NATPMP_GETEXTERNAL_RESPONSE_SIZE);\n+        uint16_t result_code = ReadBE16(response.data() + NATPMP_RESPONSE_HDR_RESULT_OFS);\n+        if (result_code != NATPMP_RESULT_SUCCESS) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Getting external address failed with result %s\\n\", NATPMPResultString(result_code));\n+            return MappingError::PROTOCOL_ERROR;\n+        }\n+\n+        std::memcpy(&external_addr, response.data() + NATPMP_GETEXTERNAL_RESPONSE_IP_OFS, ADDR_IPV4_SIZE);\n+    } else {\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Create TCP mapping request (RFC6886 section 3.3).\n+    request = std::vector<uint8_t>(NATPMP_MAP_REQUEST_SIZE);\n+    request[NATPMP_HDR_VERSION_OFS] = NATPMP_VERSION;\n+    request[NATPMP_HDR_OP_OFS] = NATPMP_REQUEST | NATPMP_OP_MAP_TCP;\n+    WriteBE16(request.data() + NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS, port);\n+    WriteBE16(request.data() + NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS, port);\n+    WriteBE32(request.data() + NATPMP_MAP_REQUEST_LIFETIME_OFS, lifetime);\n+\n+    recv_res = PCPSendRecv(*sock, \"natpmp\", request, num_tries, timeout_per_try,\n+        [&](const Span<const uint8_t> response) -> bool {\n+            if (response.size() < NATPMP_MAP_RESPONSE_SIZE) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response too small\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            if (response[0] != NATPMP_VERSION || response[1] != (NATPMP_RESPONSE | NATPMP_OP_MAP_TCP)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response to wrong command\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            uint16_t internal_port = ReadBE16(response.data() + NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS);\n+            if (internal_port != port) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response port doesn't match request\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            return true;\n+        });\n+\n+    if (recv_res) {\n+        const std::span<uint8_t> response = *recv_res;\n+\n+        Assume(response.size() >= NATPMP_MAP_RESPONSE_SIZE);\n+        uint16_t result_code = ReadBE16(response.data() + NATPMP_RESPONSE_HDR_RESULT_OFS);\n+        if (result_code != NATPMP_RESULT_SUCCESS) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Port mapping failed with result %s\\n\", NATPMPResultString(result_code));\n+            if (result_code == NATPMP_RESULT_NO_RESOURCES) {\n+                return MappingError::NO_RESOURCES;\n+            }\n+            return MappingError::PROTOCOL_ERROR;\n+        }\n+\n+        uint32_t lifetime_ret = ReadBE32(response.data() + NATPMP_MAP_RESPONSE_LIFETIME_OFS);\n+        uint16_t external_port = ReadBE16(response.data() + NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS);\n+        return MappingResult(NATPMP_VERSION, CService(internal.sin_addr, port), CService(external_addr, external_port), lifetime_ret);\n+    } else {\n+        return MappingError::NETWORK_ERROR;\n+    }\n+}\n+\n+std::variant<MappingResult, MappingError> PCPRequestPortMap(const PCPMappingNonce &nonce, const CNetAddr &gateway, const CNetAddr &bind, uint16_t port, uint32_t lifetime, int num_tries, std::chrono::milliseconds timeout_per_try)\n+{\n+    struct sockaddr_storage dest_addr, bind_addr;\n+    socklen_t dest_addrlen = sizeof(struct sockaddr_storage), bind_addrlen = sizeof(struct sockaddr_storage);\n+\n+    LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"pcp: Requesting port mapping for addr %s port %d from gateway %s\\n\", bind.ToStringAddr(), port, gateway.ToStringAddr());\n+\n+    // Validate addresses, make sure they're the same network family.\n+    if (!CService(gateway, PCP_SERVER_PORT).GetSockAddr((struct sockaddr*)&dest_addr, &dest_addrlen)) return MappingError::NETWORK_ERROR;\n+    if (!CService(bind, 0).GetSockAddr((struct sockaddr*)&bind_addr, &bind_addrlen)) return MappingError::NETWORK_ERROR;\n+    if (dest_addr.ss_family != bind_addr.ss_family) return MappingError::NETWORK_ERROR;\n+\n+    // Create UDP socket (IPv4 or IPv6 based on provided gateway).\n+    auto sock{CreateSock(dest_addr.ss_family, SOCK_DGRAM, IPPROTO_UDP)};",
      "path": "src/util/pcp.cpp",
      "position": 400,
      "original_position": 400,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "23916f2a7717b463799207b4b81b5795f2e9d7e3",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I guess this is acceptable, but just mentioning: my understanding of RFC 6887 is that the server can send unsolicited messages with updates at any time, in case of address changes. When `PCPRequestPortMap()` ends, then this `sock` will go out of scope, will be closed and we will miss such replies.",
      "created_at": "2024-06-28T15:05:03Z",
      "updated_at": "2024-06-28T15:24:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1658892377",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1658892377"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 400,
      "original_line": 400,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1658909927",
      "pull_request_review_id": 2141814858,
      "id": 1658909927,
      "node_id": "PRRC_kwDOABII585i4PTn",
      "diff_hunk": "@@ -160,12 +160,6 @@ AC_ARG_WITH([miniupnpc],\n   [use_upnp=$withval],\n   [use_upnp=auto])\n \n-AC_ARG_WITH([natpmp],",
      "path": "configure.ac",
      "position": null,
      "original_position": 4,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "23916f2a7717b463799207b4b81b5795f2e9d7e3",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Commit a749ab8cfe `build: Drop libnatpmp from build system` leaves some mentions of \"natpmp\" in `configure.ac` which are later removed by 6f4bc73e39 `depends: Drop natpmp and associated option from depends`. I think all removals of \"natpmp\" from `configure.ac` belong to one commit.",
      "created_at": "2024-06-28T15:19:55Z",
      "updated_at": "2024-06-28T15:24:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1658909927",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1658909927"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 163,
      "side": "LEFT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1658912601",
      "pull_request_review_id": 2141814858,
      "id": 1658912601,
      "node_id": "PRRC_kwDOABII585i4P9Z",
      "diff_hunk": "@@ -11,7 +11,7 @@ export HOST=x86_64-apple-darwin\n # Therefore, `--break-system-packages` is needed.\n export PIP_PACKAGES=\"--break-system-packages zmq\"\n export GOAL=\"install\"\n-export BITCOIN_CONFIG=\"--with-gui --with-miniupnpc --with-natpmp --enable-reduce-exports\"",
      "path": "ci/test/00_setup_env_mac_native.sh",
      "position": null,
      "original_position": 4,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "23916f2a7717b463799207b4b81b5795f2e9d7e3",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "When usages of `--with-natpmp` are removed from the CI in commit 23916f2a7717b463799207b4b81b5795f2e9d7e3 `ci: Remove natpmp build option` then this option is already nonexistent, meaning that in the intermediate commits the CI is broken. Maybe reorder the commits so the CI one is before the `--with-natpmp` removal (a749ab8cfe `build: Drop libnatpmp from build system`) or squash them into one commit.",
      "created_at": "2024-06-28T15:22:09Z",
      "updated_at": "2024-06-28T15:33:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1658912601",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1658912601"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 14,
      "side": "LEFT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1658949236",
      "pull_request_review_id": 2148366418,
      "id": 1658949236,
      "node_id": "PRRC_kwDOABII585i4Y50",
      "diff_hunk": "@@ -46,104 +43,96 @@ using namespace std::chrono_literals;\n static constexpr auto PORT_MAPPING_REANNOUNCE_PERIOD{20min};\n static constexpr auto PORT_MAPPING_RETRY_PERIOD{5min};\n \n-#ifdef USE_NATPMP\n-static uint16_t g_mapport_external_port = 0;\n-static bool NatpmpInit(natpmp_t* natpmp)\n+static bool ProcessPCP()\n {\n-    const int r_init = initnatpmp(natpmp, /* detect gateway automatically */ 0, /* forced gateway - NOT APPLIED*/ 0);\n-    if (r_init == 0) return true;\n-    LogPrintf(\"natpmp: initnatpmp() failed with %d error.\\n\", r_init);\n-    return false;\n-}\n+    // The same nonce is used for all mappings, this is allowed by the spec, and simplifies keeping track of them.\n+    PCPMappingNonce pcp_nonce;\n+    GetRandBytes(pcp_nonce);\n \n-static bool NatpmpDiscover(natpmp_t* natpmp, struct in_addr& external_ipv4_addr)\n-{\n-    const int r_send = sendpublicaddressrequest(natpmp);\n-    if (r_send == 2 /* OK */) {\n-        int r_read;\n-        natpmpresp_t response;\n-        do {\n-            r_read = readnatpmpresponseorretry(natpmp, &response);\n-        } while (r_read == NATPMP_TRYAGAIN);\n-\n-        if (r_read == 0) {\n-            external_ipv4_addr = response.pnu.publicaddress.addr;\n-            return true;\n-        } else if (r_read == NATPMP_ERR_NOGATEWAYSUPPORT) {\n-            LogPrintf(\"natpmp: The gateway does not support NAT-PMP.\\n\");\n+    bool ret = false;\n+    bool no_resources = false;\n+    const uint16_t private_port = GetListenPort();\n+    // Multiply the reannounce period by two, as we'll try to renew approximately halfway.\n+    const uint32_t requested_lifetime = std::chrono::seconds(PORT_MAPPING_REANNOUNCE_PERIOD * 2).count();\n+    uint32_t actual_lifetime = 0;\n+    std::chrono::milliseconds sleep_time;\n+\n+    // Local functor to handle result from PCP/NATPMP mapping.\n+    auto handle_mapping = [&](std::variant<MappingResult, MappingError> &res) -> void {\n+        if (MappingResult* mapping = std::get_if<MappingResult>(&res)) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Info, \"portmap: Added mapping %s\\n\", mapping->ToString());\n+            AddLocal(mapping->external, LOCAL_MAPPED);\n+            ret = true;\n+            actual_lifetime = std::min(actual_lifetime, mapping->lifetime);\n+        } else if (MappingError *err = std::get_if<MappingError>(&res)) {\n+            // Detailed error will already have been logged internally in respective Portmap function.\n+            if (*err == MappingError::NO_RESOURCES) {\n+                no_resources = true;\n+            }\n+        }\n+    };\n+\n+    do {\n+        actual_lifetime = requested_lifetime;\n+        no_resources = false; // Set to true if there was any \"no resources\" error.\n+        ret = false; // Set to true if any mapping succeeds.\n+\n+        // IPv4\n+        std::optional<CNetAddr> gateway4 = QueryDefaultGateway(NET_IPV4);\n+        if (!gateway4) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: Could not determine IPv4 default gateway\\n\");\n         } else {\n-            LogPrintf(\"natpmp: readnatpmpresponseorretry() for public address failed with %d error.\\n\", r_read);\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: gateway [IPv4]: %s\\n\", gateway4->ToStringAddr());\n+\n+            // Open a port mapping on whatever local address we have toward the gateway.\n+            struct in_addr inaddr_any;\n+            inaddr_any.s_addr = htonl(INADDR_ANY);\n+            auto res = PCPRequestPortMap(pcp_nonce, *gateway4, CNetAddr(inaddr_any), private_port, requested_lifetime);\n+            MappingError* pcp_err = std::get_if<MappingError>(&res);\n+            if (pcp_err && *pcp_err == MappingError::UNSUPP_VERSION) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: Got unsupported PCP version response, falling back to NAT-PMP\\n\");\n+                res = NATPMPRequestPortMap(*gateway4, private_port, requested_lifetime);\n+            }\n+            handle_mapping(res);\n         }\n-    } else {\n-        LogPrintf(\"natpmp: sendpublicaddressrequest() failed with %d error.\\n\", r_send);\n-    }\n \n-    return false;\n-}\n+        // IPv6\n+        std::optional<CNetAddr> gateway6 = QueryDefaultGateway(NET_IPV6);\n+        if (!gateway6) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: Could not determine IPv6 default gateway\\n\");\n+        } else {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: gateway [IPv6]: %s\\n\", gateway6->ToStringAddr());\n \n-static bool NatpmpMapping(natpmp_t* natpmp, const struct in_addr& external_ipv4_addr, uint16_t private_port, bool& external_ip_discovered)\n-{\n-    const uint16_t suggested_external_port = g_mapport_external_port ? g_mapport_external_port : private_port;\n-    const int r_send = sendnewportmappingrequest(natpmp, NATPMP_PROTOCOL_TCP, private_port, suggested_external_port, 3600 /*seconds*/);\n-    if (r_send == 12 /* OK */) {\n-        int r_read;\n-        natpmpresp_t response;\n-        do {\n-            r_read = readnatpmpresponseorretry(natpmp, &response);\n-        } while (r_read == NATPMP_TRYAGAIN);\n-\n-        if (r_read == 0) {\n-            auto pm = response.pnu.newportmapping;\n-            if (private_port == pm.privateport && pm.lifetime > 0) {\n-                g_mapport_external_port = pm.mappedpublicport;\n-                const CService external{external_ipv4_addr, pm.mappedpublicport};\n-                if (!external_ip_discovered && fDiscover) {\n-                    AddLocal(external, LOCAL_MAPPED);\n-                    external_ip_discovered = true;\n-                }\n-                LogPrintf(\"natpmp: Port mapping successful. External address = %s\\n\", external.ToStringAddrPort());\n-                return true;\n-            } else {\n-                LogPrintf(\"natpmp: Port mapping failed.\\n\");\n+            // Try to open pinholes for all routable local IPv6 addresses.\n+            for (const auto &addr: GetLocalAddresses()) {\n+                if (!addr.IsRoutable() || !addr.IsIPv6()) continue;\n+                auto res = PCPRequestPortMap(pcp_nonce, *gateway6, addr, private_port, requested_lifetime);",
      "path": "src/mapport.cpp",
      "position": 146,
      "original_position": 146,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "23916f2a7717b463799207b4b81b5795f2e9d7e3",
      "in_reply_to_id": 1658879358,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Also, it just occurred to me, `GetLocalAddresses()` operates regardless of `-bind=` options. If the machine has two IPv6 addresses but `-bind=` has been used and only one of them specified, then we shouldn't do mapping for the other one (where nobody is listening).",
      "created_at": "2024-06-28T15:52:43Z",
      "updated_at": "2024-06-28T15:52:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1658949236",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1658949236"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": 106,
      "original_start_line": 106,
      "start_side": "RIGHT",
      "line": 109,
      "original_line": 109,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1664020423",
      "pull_request_review_id": 2156165990,
      "id": 1664020423,
      "node_id": "PRRC_kwDOABII585jLu_H",
      "diff_hunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/pcp.h>\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <span.h>\n+#include <util/check.h>\n+#include <util/netif.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+namespace {\n+\n+// RFC6886 NAT-PMP and RFC6887 Port Control Protocol (PCP) implementation.\n+// NAT-PMP and PCP use network byte order (big-endian).\n+\n+// NAT-PMP (v0) protocol constants.\n+//! NAT-PMP uses a fixed server port number (RFC6887 section 1.1).\n+constexpr uint16_t NATPMP_SERVER_PORT = 5351;\n+//! Version byte for NATPMP (RFC6886 1.1)\n+constexpr uint8_t NATPMP_VERSION = 0;\n+//! Request opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_REQUEST = 0x00;\n+//! Response opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_RESPONSE = 0x80;\n+//! Get external address (RFC6886 3.2)\n+constexpr uint8_t NATPMP_OP_GETEXTERNAL = 0x00;\n+//! Map TCP port (RFC6886 3.3)\n+constexpr uint8_t NATPMP_OP_MAP_TCP = 0x02;\n+//! Shared request header size in bytes.\n+constexpr size_t NATPMP_REQUEST_HDR_SIZE = 2;\n+//! Shared response header (minimum) size in bytes.\n+constexpr size_t NATPMP_RESPONSE_HDR_SIZE = 8;\n+//! GETEXTERNAL request size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 0;\n+//! GETEXTERNAL response size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 4;\n+//! MAP request size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 10;\n+//! MAP response size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 8;\n+\n+// Shared header offsets (RFC6886 3.2, 3.3), relative to start of packet.\n+//!  Offset of version field in packets.\n+constexpr size_t NATPMP_HDR_VERSION_OFS = 0;\n+//!  Offset of opcode field in packets\n+constexpr size_t NATPMP_HDR_OP_OFS = 1;\n+//!  Offset of result code in packets. Result codes are 16 bit in NAT-PMP instead of 8 bit in PCP.\n+constexpr size_t NATPMP_RESPONSE_HDR_RESULT_OFS = 2;\n+\n+// GETEXTERNAL response offsets (RFC6886 3.2), relative to start of packet.\n+//!  Returned external address\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_IP_OFS = 8;\n+\n+// MAP request offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port to be mapped.\n+constexpr size_t NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS = 4;\n+//!  Suggested external port for mapping.\n+constexpr size_t NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS = 6;\n+//!  Requested port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_REQUEST_LIFETIME_OFS = 8;\n+\n+// MAP response offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port for mapping (will match internal port of request).\n+constexpr size_t NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS = 8;\n+//!  External port for mapping.\n+constexpr size_t NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS = 10;\n+//!  Created port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_RESPONSE_LIFETIME_OFS = 12;\n+\n+// Relevant NETPMP result codes (RFC6886 3.5).\n+//! Result code representing success status.\n+constexpr uint8_t NATPMP_RESULT_SUCCESS = 0;\n+//! Result code representing unsupported version.\n+constexpr uint8_t NATPMP_RESULT_UNSUPP_VERSION = 1;\n+//! Result code representing lack of resources.\n+constexpr uint8_t NATPMP_RESULT_NO_RESOURCES = 4;\n+\n+//! Mapping of NATPMP result code to string (RFC6886 3.5). Result codes <=2 match PCP.\n+const std::map<uint8_t, std::string> NATPMP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"NETWORK_FAILURE\"},\n+    {4,  \"NO_RESOURCES\"},\n+    {5,  \"UNSUPP_OPCODE\"},\n+};\n+\n+// PCP (v2) protocol constants.\n+//! Maximum packet size in bytes (RFC6887 section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (RFC6887 section 19.1). Shared with NAT-PMP.\n+constexpr uint16_t PCP_SERVER_PORT = NATPMP_SERVER_PORT;\n+//! Version byte. 0 is NAT-PMP (RFC6886), 1 is forbidden, 2 for PCP (RFC6887).\n+constexpr uint8_t PCP_VERSION = 2;\n+//! PCP Request Header. See RFC6887 section 7.1. Shared with NAT-PMP.\n+constexpr uint8_t PCP_REQUEST = NATPMP_REQUEST; // R = 0\n+//! PCP Response Header. See RFC6887 section 7.2. Shared with NAT-PMP.\n+constexpr uint8_t PCP_RESPONSE = NATPMP_RESPONSE; // R = 1\n+//! Map opcode. See RFC6887 section 19.2\n+constexpr uint8_t PCP_OP_MAP = 0x01;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Request and response header size in bytes (RFC6887 section 7.1).\n+constexpr size_t PCP_HDR_SIZE = 24;\n+//! Map request and response size in bytes (RFC6887 section 11.1).\n+constexpr size_t PCP_MAP_SIZE = 36;\n+\n+// Header offsets shared between request and responses (RFC6887 7.1, 7.2), relative to start of packet.\n+//!  Version field (1 byte).\n+constexpr size_t PCP_HDR_VERSION_OFS = NATPMP_HDR_VERSION_OFS;\n+//!  Opcode field (1 byte).\n+constexpr size_t PCP_HDR_OP_OFS = NATPMP_HDR_OP_OFS;\n+//!  Requested lifetime (request), granted lifetime (response) (2 bytes).\n+constexpr size_t PCP_HDR_LIFETIME_OFS = 4;\n+\n+// Request header offsets (RFC6887 7.1), relative to start of packet.\n+//!  PCP client's IP address (16 bytes).\n+constexpr size_t PCP_REQUEST_HDR_IP_OFS = 8;\n+\n+// Response header offsets (RFC6887 7.2), relative to start of packet.\n+//!  Result code (1 byte).\n+constexpr size_t PCP_RESPONSE_HDR_RESULT_OFS = 3;\n+\n+// MAP request/response offsets (RFC6887 11.1), relative to start of opcode-specific data.\n+//!  Mapping nonce (12 bytes).\n+constexpr size_t PCP_MAP_NONCE_OFS = 0;\n+//!  Protocol (1 byte).\n+constexpr size_t PCP_MAP_PROTOCOL_OFS = 12;\n+//!  Internal port for mapping (2 bytes).\n+constexpr size_t PCP_MAP_INTERNAL_PORT_OFS = 16;\n+//!  Suggested external port (request), assigned external port (response) (2 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_PORT_OFS = 18;\n+//!  Suggested external IP (request), assigned external IP (response) (16 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_IP_OFS = 20;\n+\n+//! Result code representing success (RFC6887 7.4), shared with NAT-PMP.\n+constexpr uint8_t PCP_RESULT_SUCCESS = NATPMP_RESULT_SUCCESS;\n+//! Result code representing lack of resources (RFC6887 7.4).\n+constexpr uint8_t PCP_RESULT_NO_RESOURCES = 8;\n+\n+//! Mapping of PCP result code to string (RFC6887 7.4). Result codes <=2 match NAT-PMP.\n+const std::map<uint8_t, std::string> PCP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"MALFORMED_REQUEST\"},\n+    {4,  \"UNSUPP_OPCODE\"},\n+    {5,  \"UNSUPP_OPTION\"},\n+    {6,  \"MALFORMED_OPTION\"},\n+    {7,  \"NETWORK_FAILURE\"},\n+    {8,  \"NO_RESOURCES\"},\n+    {9,  \"UNSUPP_PROTOCOL\"},\n+    {10, \"USER_EX_QUOTA\"},\n+    {11, \"CANNOT_PROVIDE_EXTERNAL\"},\n+    {12, \"ADDRESS_MISMATCH\"},\n+    {13, \"EXCESSIVE_REMOTE_PEER\"},\n+};\n+\n+//! Return human-readable string from NATPMP result code.\n+std::string NATPMPResultString(uint8_t result_code)\n+{\n+    auto result_i = NATPMP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == NATPMP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Return human-readable string from PCP result code.\n+std::string PCPResultString(uint8_t result_code)\n+{\n+    auto result_i = PCP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == PCP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Wrap address in IPv6 according to RFC6887. wrapped_addr needs to be able to store 16 bytes.\n+[[nodiscard]] bool PCPWrapAddress(Span<uint8_t> wrapped_addr, const CNetAddr &addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (addr.IsIPv4()) {\n+        struct in_addr addr4;\n+        if (!addr.GetInAddr(&addr4)) return false;\n+        // Section 5: \"When the address field holds an IPv4 address, an IPv4-mapped IPv6 address [RFC4291] is used (::ffff:0:0/96).\"\n+        std::memcpy(wrapped_addr.data(), IPV4_IN_IPV6_PREFIX.data(), IPV4_IN_IPV6_PREFIX.size());\n+        std::memcpy(wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), &addr4, ADDR_IPV4_SIZE);\n+        return true;\n+    } else if (addr.IsIPv6()) {\n+        struct in6_addr addr6;\n+        if (!addr.GetIn6Addr(&addr6)) return false;\n+        std::memcpy(wrapped_addr.data(), &addr6, ADDR_IPV6_SIZE);\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+//! Unwrap PCP-encoded address according to RFC6887.\n+CNetAddr PCPUnwrapAddress(Span<const uint8_t> wrapped_addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (util::HasPrefix(wrapped_addr, IPV4_IN_IPV6_PREFIX)) {\n+        struct in_addr addr4;\n+        std::memcpy(&addr4, wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), ADDR_IPV4_SIZE);\n+        return CNetAddr(addr4);\n+    } else {\n+        struct in6_addr addr6;\n+        std::memcpy(&addr6, wrapped_addr.data(), ADDR_IPV6_SIZE);\n+        return CNetAddr(addr6);\n+    }\n+}\n+\n+//! PCP or NAT-PMP send-receive loop.\n+std::optional<std::vector<uint8_t>> PCPSendRecv(Sock &sock, const std::string &protocol, Span<const uint8_t> request, int num_tries,\n+        std::chrono::milliseconds timeout_per_try,\n+        std::function<bool(Span<const uint8_t>)> check_packet)\n+{\n+    using namespace std::chrono;\n+    // UDP is a potentially lossy protocol, so we try to send again a few times.\n+    uint8_t response[PCP_MAX_SIZE];\n+    bool got_response = false;\n+    int recvsz = 0;\n+    for (int ntry = 0; !got_response && ntry < num_tries; ++ntry) {\n+        if (ntry > 0) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Retrying (%d)\\n\", protocol, ntry);\n+        }\n+        // Dispatch packet to gateway.\n+        if (sock.Send(request.data(), request.size(), 0) != static_cast<ssize_t>(request.size())) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not send request: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+            return std::nullopt; // Network-level error, probably no use retrying.\n+        }\n+\n+        // Wait for response(s) until we get a valid response, a network error, or time out.\n+        auto cur_time = time_point_cast<milliseconds>(steady_clock::now());\n+        auto deadline = cur_time + timeout_per_try;\n+        while ((cur_time = time_point_cast<milliseconds>(steady_clock::now())) < deadline) {\n+            Sock::Event occurred = 0;\n+            if (!sock.Wait(deadline - cur_time, Sock::RECV, &occurred)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not wait on socket: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            if (!occurred) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Timeout\\n\", protocol);\n+                break; // Retry.\n+            }\n+\n+            // Receive response.\n+            recvsz = sock.Recv(response, sizeof(response), MSG_DONTWAIT);\n+            if (recvsz < 0) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not receive response: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Received response of %d bytes: %s\\n\", protocol, recvsz, HexStr(Span(response, recvsz)));\n+\n+            if (check_packet(Span<uint8_t>(response, recvsz))) {\n+                got_response = true; // Got expected response, break from receive loop as well as from retry loop.\n+                break;\n+            }\n+        }\n+    }\n+    if (!got_response) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Giving up after %d tries\\n\", protocol, num_tries);\n+        return std::nullopt;\n+    }\n+    return std::vector<uint8_t>(response, response + recvsz);\n+}\n+\n+}\n+\n+std::variant<MappingResult, MappingError> NATPMPRequestPortMap(const CNetAddr &gateway, uint16_t port, uint32_t lifetime, int num_tries, std::chrono::milliseconds timeout_per_try)\n+{\n+    struct sockaddr_storage dest_addr;\n+    socklen_t dest_addrlen = sizeof(struct sockaddr_storage);\n+\n+    LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"natpmp: Requesting port mapping port %d from gateway %s\\n\", port, gateway.ToStringAddr());\n+\n+    // Validate gateway, make sure it's IPv4. NAT-PMP does not support IPv6.\n+    if (!CService(gateway, PCP_SERVER_PORT).GetSockAddr((struct sockaddr*)&dest_addr, &dest_addrlen)) return MappingError::NETWORK_ERROR;\n+    if (dest_addr.ss_family != AF_INET) return MappingError::NETWORK_ERROR;\n+\n+    // Create IPv4 UDP socket\n+    auto sock{CreateSock(AF_INET, SOCK_DGRAM, IPPROTO_UDP)};\n+    if (!sock) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Could not create UDP socket: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Associate UDP socket to gateway.\n+    if (sock->Connect((struct sockaddr*)&dest_addr, dest_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Could not connect to gateway: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Use getsockname to get the address toward the default gateway (the internal address).\n+    struct sockaddr_in internal;\n+    socklen_t internal_addrlen = sizeof(struct sockaddr_in);\n+    if (sock->GetSockName((struct sockaddr*)&internal, &internal_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Could not get sock name: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Request external IP address (RFC6886 section 3.2).\n+    std::vector<uint8_t> request(NATPMP_GETEXTERNAL_REQUEST_SIZE);\n+    request[NATPMP_HDR_VERSION_OFS] = NATPMP_VERSION;\n+    request[NATPMP_HDR_OP_OFS] = NATPMP_REQUEST | NATPMP_OP_GETEXTERNAL;\n+\n+    auto recv_res = PCPSendRecv(*sock, \"natpmp\", request, num_tries, timeout_per_try,\n+        [&](const Span<const uint8_t> response) -> bool {\n+            if (response.size() < NATPMP_GETEXTERNAL_RESPONSE_SIZE) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response too small\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            if (response[NATPMP_HDR_VERSION_OFS] != NATPMP_VERSION || response[NATPMP_HDR_OP_OFS] != (NATPMP_RESPONSE | NATPMP_OP_GETEXTERNAL)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response to wrong command\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            return true;\n+        });\n+\n+    struct in_addr external_addr;\n+    if (recv_res) {\n+        const std::span<const uint8_t> response = *recv_res;\n+\n+        Assume(response.size() >= NATPMP_GETEXTERNAL_RESPONSE_SIZE);\n+        uint16_t result_code = ReadBE16(response.data() + NATPMP_RESPONSE_HDR_RESULT_OFS);\n+        if (result_code != NATPMP_RESULT_SUCCESS) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Getting external address failed with result %s\\n\", NATPMPResultString(result_code));\n+            return MappingError::PROTOCOL_ERROR;\n+        }\n+\n+        std::memcpy(&external_addr, response.data() + NATPMP_GETEXTERNAL_RESPONSE_IP_OFS, ADDR_IPV4_SIZE);\n+    } else {\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Create TCP mapping request (RFC6886 section 3.3).\n+    request = std::vector<uint8_t>(NATPMP_MAP_REQUEST_SIZE);\n+    request[NATPMP_HDR_VERSION_OFS] = NATPMP_VERSION;\n+    request[NATPMP_HDR_OP_OFS] = NATPMP_REQUEST | NATPMP_OP_MAP_TCP;\n+    WriteBE16(request.data() + NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS, port);\n+    WriteBE16(request.data() + NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS, port);\n+    WriteBE32(request.data() + NATPMP_MAP_REQUEST_LIFETIME_OFS, lifetime);\n+\n+    recv_res = PCPSendRecv(*sock, \"natpmp\", request, num_tries, timeout_per_try,\n+        [&](const Span<const uint8_t> response) -> bool {\n+            if (response.size() < NATPMP_MAP_RESPONSE_SIZE) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response too small\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            if (response[0] != NATPMP_VERSION || response[1] != (NATPMP_RESPONSE | NATPMP_OP_MAP_TCP)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response to wrong command\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            uint16_t internal_port = ReadBE16(response.data() + NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS);\n+            if (internal_port != port) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response port doesn't match request\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            return true;\n+        });\n+\n+    if (recv_res) {\n+        const std::span<uint8_t> response = *recv_res;\n+\n+        Assume(response.size() >= NATPMP_MAP_RESPONSE_SIZE);\n+        uint16_t result_code = ReadBE16(response.data() + NATPMP_RESPONSE_HDR_RESULT_OFS);\n+        if (result_code != NATPMP_RESULT_SUCCESS) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Port mapping failed with result %s\\n\", NATPMPResultString(result_code));\n+            if (result_code == NATPMP_RESULT_NO_RESOURCES) {\n+                return MappingError::NO_RESOURCES;\n+            }\n+            return MappingError::PROTOCOL_ERROR;\n+        }\n+\n+        uint32_t lifetime_ret = ReadBE32(response.data() + NATPMP_MAP_RESPONSE_LIFETIME_OFS);\n+        uint16_t external_port = ReadBE16(response.data() + NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS);\n+        return MappingResult(NATPMP_VERSION, CService(internal.sin_addr, port), CService(external_addr, external_port), lifetime_ret);\n+    } else {\n+        return MappingError::NETWORK_ERROR;\n+    }\n+}\n+\n+std::variant<MappingResult, MappingError> PCPRequestPortMap(const PCPMappingNonce &nonce, const CNetAddr &gateway, const CNetAddr &bind, uint16_t port, uint32_t lifetime, int num_tries, std::chrono::milliseconds timeout_per_try)\n+{\n+    struct sockaddr_storage dest_addr, bind_addr;\n+    socklen_t dest_addrlen = sizeof(struct sockaddr_storage), bind_addrlen = sizeof(struct sockaddr_storage);\n+\n+    LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"pcp: Requesting port mapping for addr %s port %d from gateway %s\\n\", bind.ToStringAddr(), port, gateway.ToStringAddr());\n+\n+    // Validate addresses, make sure they're the same network family.\n+    if (!CService(gateway, PCP_SERVER_PORT).GetSockAddr((struct sockaddr*)&dest_addr, &dest_addrlen)) return MappingError::NETWORK_ERROR;\n+    if (!CService(bind, 0).GetSockAddr((struct sockaddr*)&bind_addr, &bind_addrlen)) return MappingError::NETWORK_ERROR;\n+    if (dest_addr.ss_family != bind_addr.ss_family) return MappingError::NETWORK_ERROR;\n+\n+    // Create UDP socket (IPv4 or IPv6 based on provided gateway).\n+    auto sock{CreateSock(dest_addr.ss_family, SOCK_DGRAM, IPPROTO_UDP)};",
      "path": "src/util/pcp.cpp",
      "position": 400,
      "original_position": 400,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "23916f2a7717b463799207b4b81b5795f2e9d7e3",
      "in_reply_to_id": 1658892377,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "i don't think that's the case in practice? but even so, doing this differently would really complicate things too much, changes in network configuration would be noticed the next update interval anyway?",
      "created_at": "2024-07-03T11:12:42Z",
      "updated_at": "2024-07-03T11:12:42Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1664020423",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1664020423"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 400,
      "original_line": 400,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1664026678",
      "pull_request_review_id": 2156176206,
      "id": 1664026678,
      "node_id": "PRRC_kwDOABII585jLwg2",
      "diff_hunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/pcp.h>\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <span.h>\n+#include <util/check.h>\n+#include <util/netif.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+namespace {\n+\n+// RFC6886 NAT-PMP and RFC6887 Port Control Protocol (PCP) implementation.\n+// NAT-PMP and PCP use network byte order (big-endian).\n+\n+// NAT-PMP (v0) protocol constants.\n+//! NAT-PMP uses a fixed server port number (RFC6887 section 1.1).\n+constexpr uint16_t NATPMP_SERVER_PORT = 5351;\n+//! Version byte for NATPMP (RFC6886 1.1)\n+constexpr uint8_t NATPMP_VERSION = 0;\n+//! Request opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_REQUEST = 0x00;\n+//! Response opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_RESPONSE = 0x80;\n+//! Get external address (RFC6886 3.2)\n+constexpr uint8_t NATPMP_OP_GETEXTERNAL = 0x00;\n+//! Map TCP port (RFC6886 3.3)\n+constexpr uint8_t NATPMP_OP_MAP_TCP = 0x02;\n+//! Shared request header size in bytes.\n+constexpr size_t NATPMP_REQUEST_HDR_SIZE = 2;\n+//! Shared response header (minimum) size in bytes.\n+constexpr size_t NATPMP_RESPONSE_HDR_SIZE = 8;\n+//! GETEXTERNAL request size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 0;\n+//! GETEXTERNAL response size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 4;\n+//! MAP request size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 10;\n+//! MAP response size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 8;\n+\n+// Shared header offsets (RFC6886 3.2, 3.3), relative to start of packet.\n+//!  Offset of version field in packets.\n+constexpr size_t NATPMP_HDR_VERSION_OFS = 0;\n+//!  Offset of opcode field in packets\n+constexpr size_t NATPMP_HDR_OP_OFS = 1;\n+//!  Offset of result code in packets. Result codes are 16 bit in NAT-PMP instead of 8 bit in PCP.\n+constexpr size_t NATPMP_RESPONSE_HDR_RESULT_OFS = 2;\n+\n+// GETEXTERNAL response offsets (RFC6886 3.2), relative to start of packet.\n+//!  Returned external address\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_IP_OFS = 8;\n+\n+// MAP request offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port to be mapped.\n+constexpr size_t NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS = 4;\n+//!  Suggested external port for mapping.\n+constexpr size_t NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS = 6;\n+//!  Requested port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_REQUEST_LIFETIME_OFS = 8;\n+\n+// MAP response offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port for mapping (will match internal port of request).\n+constexpr size_t NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS = 8;\n+//!  External port for mapping.\n+constexpr size_t NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS = 10;\n+//!  Created port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_RESPONSE_LIFETIME_OFS = 12;\n+\n+// Relevant NETPMP result codes (RFC6886 3.5).\n+//! Result code representing success status.\n+constexpr uint8_t NATPMP_RESULT_SUCCESS = 0;\n+//! Result code representing unsupported version.\n+constexpr uint8_t NATPMP_RESULT_UNSUPP_VERSION = 1;\n+//! Result code representing lack of resources.\n+constexpr uint8_t NATPMP_RESULT_NO_RESOURCES = 4;\n+\n+//! Mapping of NATPMP result code to string (RFC6886 3.5). Result codes <=2 match PCP.\n+const std::map<uint8_t, std::string> NATPMP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"NETWORK_FAILURE\"},\n+    {4,  \"NO_RESOURCES\"},\n+    {5,  \"UNSUPP_OPCODE\"},\n+};\n+\n+// PCP (v2) protocol constants.\n+//! Maximum packet size in bytes (RFC6887 section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (RFC6887 section 19.1). Shared with NAT-PMP.\n+constexpr uint16_t PCP_SERVER_PORT = NATPMP_SERVER_PORT;\n+//! Version byte. 0 is NAT-PMP (RFC6886), 1 is forbidden, 2 for PCP (RFC6887).\n+constexpr uint8_t PCP_VERSION = 2;\n+//! PCP Request Header. See RFC6887 section 7.1. Shared with NAT-PMP.\n+constexpr uint8_t PCP_REQUEST = NATPMP_REQUEST; // R = 0\n+//! PCP Response Header. See RFC6887 section 7.2. Shared with NAT-PMP.\n+constexpr uint8_t PCP_RESPONSE = NATPMP_RESPONSE; // R = 1\n+//! Map opcode. See RFC6887 section 19.2\n+constexpr uint8_t PCP_OP_MAP = 0x01;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Request and response header size in bytes (RFC6887 section 7.1).\n+constexpr size_t PCP_HDR_SIZE = 24;\n+//! Map request and response size in bytes (RFC6887 section 11.1).\n+constexpr size_t PCP_MAP_SIZE = 36;\n+\n+// Header offsets shared between request and responses (RFC6887 7.1, 7.2), relative to start of packet.\n+//!  Version field (1 byte).\n+constexpr size_t PCP_HDR_VERSION_OFS = NATPMP_HDR_VERSION_OFS;\n+//!  Opcode field (1 byte).\n+constexpr size_t PCP_HDR_OP_OFS = NATPMP_HDR_OP_OFS;\n+//!  Requested lifetime (request), granted lifetime (response) (2 bytes).\n+constexpr size_t PCP_HDR_LIFETIME_OFS = 4;\n+\n+// Request header offsets (RFC6887 7.1), relative to start of packet.\n+//!  PCP client's IP address (16 bytes).\n+constexpr size_t PCP_REQUEST_HDR_IP_OFS = 8;\n+\n+// Response header offsets (RFC6887 7.2), relative to start of packet.\n+//!  Result code (1 byte).\n+constexpr size_t PCP_RESPONSE_HDR_RESULT_OFS = 3;\n+\n+// MAP request/response offsets (RFC6887 11.1), relative to start of opcode-specific data.\n+//!  Mapping nonce (12 bytes).\n+constexpr size_t PCP_MAP_NONCE_OFS = 0;\n+//!  Protocol (1 byte).\n+constexpr size_t PCP_MAP_PROTOCOL_OFS = 12;\n+//!  Internal port for mapping (2 bytes).\n+constexpr size_t PCP_MAP_INTERNAL_PORT_OFS = 16;\n+//!  Suggested external port (request), assigned external port (response) (2 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_PORT_OFS = 18;\n+//!  Suggested external IP (request), assigned external IP (response) (16 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_IP_OFS = 20;\n+\n+//! Result code representing success (RFC6887 7.4), shared with NAT-PMP.\n+constexpr uint8_t PCP_RESULT_SUCCESS = NATPMP_RESULT_SUCCESS;\n+//! Result code representing lack of resources (RFC6887 7.4).\n+constexpr uint8_t PCP_RESULT_NO_RESOURCES = 8;\n+\n+//! Mapping of PCP result code to string (RFC6887 7.4). Result codes <=2 match NAT-PMP.\n+const std::map<uint8_t, std::string> PCP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"MALFORMED_REQUEST\"},\n+    {4,  \"UNSUPP_OPCODE\"},\n+    {5,  \"UNSUPP_OPTION\"},\n+    {6,  \"MALFORMED_OPTION\"},\n+    {7,  \"NETWORK_FAILURE\"},\n+    {8,  \"NO_RESOURCES\"},\n+    {9,  \"UNSUPP_PROTOCOL\"},\n+    {10, \"USER_EX_QUOTA\"},\n+    {11, \"CANNOT_PROVIDE_EXTERNAL\"},\n+    {12, \"ADDRESS_MISMATCH\"},\n+    {13, \"EXCESSIVE_REMOTE_PEER\"},\n+};\n+\n+//! Return human-readable string from NATPMP result code.\n+std::string NATPMPResultString(uint8_t result_code)\n+{\n+    auto result_i = NATPMP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == NATPMP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Return human-readable string from PCP result code.\n+std::string PCPResultString(uint8_t result_code)\n+{\n+    auto result_i = PCP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == PCP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Wrap address in IPv6 according to RFC6887. wrapped_addr needs to be able to store 16 bytes.\n+[[nodiscard]] bool PCPWrapAddress(Span<uint8_t> wrapped_addr, const CNetAddr &addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (addr.IsIPv4()) {\n+        struct in_addr addr4;\n+        if (!addr.GetInAddr(&addr4)) return false;\n+        // Section 5: \"When the address field holds an IPv4 address, an IPv4-mapped IPv6 address [RFC4291] is used (::ffff:0:0/96).\"\n+        std::memcpy(wrapped_addr.data(), IPV4_IN_IPV6_PREFIX.data(), IPV4_IN_IPV6_PREFIX.size());\n+        std::memcpy(wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), &addr4, ADDR_IPV4_SIZE);\n+        return true;\n+    } else if (addr.IsIPv6()) {\n+        struct in6_addr addr6;\n+        if (!addr.GetIn6Addr(&addr6)) return false;\n+        std::memcpy(wrapped_addr.data(), &addr6, ADDR_IPV6_SIZE);\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+//! Unwrap PCP-encoded address according to RFC6887.\n+CNetAddr PCPUnwrapAddress(Span<const uint8_t> wrapped_addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (util::HasPrefix(wrapped_addr, IPV4_IN_IPV6_PREFIX)) {\n+        struct in_addr addr4;\n+        std::memcpy(&addr4, wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), ADDR_IPV4_SIZE);\n+        return CNetAddr(addr4);\n+    } else {\n+        struct in6_addr addr6;\n+        std::memcpy(&addr6, wrapped_addr.data(), ADDR_IPV6_SIZE);\n+        return CNetAddr(addr6);\n+    }\n+}\n+\n+//! PCP or NAT-PMP send-receive loop.\n+std::optional<std::vector<uint8_t>> PCPSendRecv(Sock &sock, const std::string &protocol, Span<const uint8_t> request, int num_tries,\n+        std::chrono::milliseconds timeout_per_try,\n+        std::function<bool(Span<const uint8_t>)> check_packet)\n+{\n+    using namespace std::chrono;\n+    // UDP is a potentially lossy protocol, so we try to send again a few times.\n+    uint8_t response[PCP_MAX_SIZE];\n+    bool got_response = false;\n+    int recvsz = 0;\n+    for (int ntry = 0; !got_response && ntry < num_tries; ++ntry) {",
      "path": "src/util/pcp.cpp",
      "position": 227,
      "original_position": 227,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "23916f2a7717b463799207b4b81b5795f2e9d7e3",
      "in_reply_to_id": 1655169229,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "No, this doesn't implement the exact retry logic, it seems excessively complicated for communicating with a local router, and re-using the same code for NAT-PMP and PCP keeps the code straighforward.",
      "created_at": "2024-07-03T11:18:23Z",
      "updated_at": "2024-07-03T11:18:23Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1664026678",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1664026678"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 227,
      "original_line": 227,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1664031826",
      "pull_request_review_id": 2156184531,
      "id": 1664031826,
      "node_id": "PRRC_kwDOABII585jLxxS",
      "diff_hunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/pcp.h>\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <span.h>\n+#include <util/check.h>\n+#include <util/netif.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+namespace {\n+\n+// RFC6886 NAT-PMP and RFC6887 Port Control Protocol (PCP) implementation.\n+// NAT-PMP and PCP use network byte order (big-endian).\n+\n+// NAT-PMP (v0) protocol constants.\n+//! NAT-PMP uses a fixed server port number (RFC6887 section 1.1).\n+constexpr uint16_t NATPMP_SERVER_PORT = 5351;\n+//! Version byte for NATPMP (RFC6886 1.1)\n+constexpr uint8_t NATPMP_VERSION = 0;\n+//! Request opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_REQUEST = 0x00;\n+//! Response opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_RESPONSE = 0x80;\n+//! Get external address (RFC6886 3.2)\n+constexpr uint8_t NATPMP_OP_GETEXTERNAL = 0x00;\n+//! Map TCP port (RFC6886 3.3)\n+constexpr uint8_t NATPMP_OP_MAP_TCP = 0x02;\n+//! Shared request header size in bytes.\n+constexpr size_t NATPMP_REQUEST_HDR_SIZE = 2;\n+//! Shared response header (minimum) size in bytes.\n+constexpr size_t NATPMP_RESPONSE_HDR_SIZE = 8;\n+//! GETEXTERNAL request size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 0;\n+//! GETEXTERNAL response size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 4;\n+//! MAP request size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 10;\n+//! MAP response size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 8;\n+\n+// Shared header offsets (RFC6886 3.2, 3.3), relative to start of packet.\n+//!  Offset of version field in packets.\n+constexpr size_t NATPMP_HDR_VERSION_OFS = 0;\n+//!  Offset of opcode field in packets\n+constexpr size_t NATPMP_HDR_OP_OFS = 1;\n+//!  Offset of result code in packets. Result codes are 16 bit in NAT-PMP instead of 8 bit in PCP.\n+constexpr size_t NATPMP_RESPONSE_HDR_RESULT_OFS = 2;\n+\n+// GETEXTERNAL response offsets (RFC6886 3.2), relative to start of packet.\n+//!  Returned external address\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_IP_OFS = 8;\n+\n+// MAP request offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port to be mapped.\n+constexpr size_t NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS = 4;\n+//!  Suggested external port for mapping.\n+constexpr size_t NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS = 6;\n+//!  Requested port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_REQUEST_LIFETIME_OFS = 8;\n+\n+// MAP response offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port for mapping (will match internal port of request).\n+constexpr size_t NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS = 8;\n+//!  External port for mapping.\n+constexpr size_t NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS = 10;\n+//!  Created port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_RESPONSE_LIFETIME_OFS = 12;\n+\n+// Relevant NETPMP result codes (RFC6886 3.5).\n+//! Result code representing success status.\n+constexpr uint8_t NATPMP_RESULT_SUCCESS = 0;\n+//! Result code representing unsupported version.\n+constexpr uint8_t NATPMP_RESULT_UNSUPP_VERSION = 1;\n+//! Result code representing lack of resources.\n+constexpr uint8_t NATPMP_RESULT_NO_RESOURCES = 4;\n+\n+//! Mapping of NATPMP result code to string (RFC6886 3.5). Result codes <=2 match PCP.\n+const std::map<uint8_t, std::string> NATPMP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"NETWORK_FAILURE\"},\n+    {4,  \"NO_RESOURCES\"},\n+    {5,  \"UNSUPP_OPCODE\"},\n+};\n+\n+// PCP (v2) protocol constants.\n+//! Maximum packet size in bytes (RFC6887 section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (RFC6887 section 19.1). Shared with NAT-PMP.\n+constexpr uint16_t PCP_SERVER_PORT = NATPMP_SERVER_PORT;\n+//! Version byte. 0 is NAT-PMP (RFC6886), 1 is forbidden, 2 for PCP (RFC6887).\n+constexpr uint8_t PCP_VERSION = 2;\n+//! PCP Request Header. See RFC6887 section 7.1. Shared with NAT-PMP.\n+constexpr uint8_t PCP_REQUEST = NATPMP_REQUEST; // R = 0\n+//! PCP Response Header. See RFC6887 section 7.2. Shared with NAT-PMP.\n+constexpr uint8_t PCP_RESPONSE = NATPMP_RESPONSE; // R = 1\n+//! Map opcode. See RFC6887 section 19.2\n+constexpr uint8_t PCP_OP_MAP = 0x01;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Request and response header size in bytes (RFC6887 section 7.1).\n+constexpr size_t PCP_HDR_SIZE = 24;\n+//! Map request and response size in bytes (RFC6887 section 11.1).\n+constexpr size_t PCP_MAP_SIZE = 36;\n+\n+// Header offsets shared between request and responses (RFC6887 7.1, 7.2), relative to start of packet.\n+//!  Version field (1 byte).\n+constexpr size_t PCP_HDR_VERSION_OFS = NATPMP_HDR_VERSION_OFS;\n+//!  Opcode field (1 byte).\n+constexpr size_t PCP_HDR_OP_OFS = NATPMP_HDR_OP_OFS;\n+//!  Requested lifetime (request), granted lifetime (response) (2 bytes).\n+constexpr size_t PCP_HDR_LIFETIME_OFS = 4;\n+\n+// Request header offsets (RFC6887 7.1), relative to start of packet.\n+//!  PCP client's IP address (16 bytes).\n+constexpr size_t PCP_REQUEST_HDR_IP_OFS = 8;\n+\n+// Response header offsets (RFC6887 7.2), relative to start of packet.\n+//!  Result code (1 byte).\n+constexpr size_t PCP_RESPONSE_HDR_RESULT_OFS = 3;\n+\n+// MAP request/response offsets (RFC6887 11.1), relative to start of opcode-specific data.\n+//!  Mapping nonce (12 bytes).\n+constexpr size_t PCP_MAP_NONCE_OFS = 0;\n+//!  Protocol (1 byte).\n+constexpr size_t PCP_MAP_PROTOCOL_OFS = 12;\n+//!  Internal port for mapping (2 bytes).\n+constexpr size_t PCP_MAP_INTERNAL_PORT_OFS = 16;\n+//!  Suggested external port (request), assigned external port (response) (2 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_PORT_OFS = 18;\n+//!  Suggested external IP (request), assigned external IP (response) (16 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_IP_OFS = 20;\n+\n+//! Result code representing success (RFC6887 7.4), shared with NAT-PMP.\n+constexpr uint8_t PCP_RESULT_SUCCESS = NATPMP_RESULT_SUCCESS;\n+//! Result code representing lack of resources (RFC6887 7.4).\n+constexpr uint8_t PCP_RESULT_NO_RESOURCES = 8;\n+\n+//! Mapping of PCP result code to string (RFC6887 7.4). Result codes <=2 match NAT-PMP.\n+const std::map<uint8_t, std::string> PCP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"MALFORMED_REQUEST\"},\n+    {4,  \"UNSUPP_OPCODE\"},\n+    {5,  \"UNSUPP_OPTION\"},\n+    {6,  \"MALFORMED_OPTION\"},\n+    {7,  \"NETWORK_FAILURE\"},\n+    {8,  \"NO_RESOURCES\"},\n+    {9,  \"UNSUPP_PROTOCOL\"},\n+    {10, \"USER_EX_QUOTA\"},\n+    {11, \"CANNOT_PROVIDE_EXTERNAL\"},\n+    {12, \"ADDRESS_MISMATCH\"},\n+    {13, \"EXCESSIVE_REMOTE_PEER\"},\n+};\n+\n+//! Return human-readable string from NATPMP result code.\n+std::string NATPMPResultString(uint8_t result_code)\n+{\n+    auto result_i = NATPMP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == NATPMP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Return human-readable string from PCP result code.\n+std::string PCPResultString(uint8_t result_code)\n+{\n+    auto result_i = PCP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == PCP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Wrap address in IPv6 according to RFC6887. wrapped_addr needs to be able to store 16 bytes.\n+[[nodiscard]] bool PCPWrapAddress(Span<uint8_t> wrapped_addr, const CNetAddr &addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (addr.IsIPv4()) {\n+        struct in_addr addr4;\n+        if (!addr.GetInAddr(&addr4)) return false;\n+        // Section 5: \"When the address field holds an IPv4 address, an IPv4-mapped IPv6 address [RFC4291] is used (::ffff:0:0/96).\"\n+        std::memcpy(wrapped_addr.data(), IPV4_IN_IPV6_PREFIX.data(), IPV4_IN_IPV6_PREFIX.size());\n+        std::memcpy(wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), &addr4, ADDR_IPV4_SIZE);\n+        return true;\n+    } else if (addr.IsIPv6()) {\n+        struct in6_addr addr6;\n+        if (!addr.GetIn6Addr(&addr6)) return false;\n+        std::memcpy(wrapped_addr.data(), &addr6, ADDR_IPV6_SIZE);\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+//! Unwrap PCP-encoded address according to RFC6887.\n+CNetAddr PCPUnwrapAddress(Span<const uint8_t> wrapped_addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (util::HasPrefix(wrapped_addr, IPV4_IN_IPV6_PREFIX)) {\n+        struct in_addr addr4;\n+        std::memcpy(&addr4, wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), ADDR_IPV4_SIZE);\n+        return CNetAddr(addr4);\n+    } else {\n+        struct in6_addr addr6;\n+        std::memcpy(&addr6, wrapped_addr.data(), ADDR_IPV6_SIZE);\n+        return CNetAddr(addr6);\n+    }\n+}\n+\n+//! PCP or NAT-PMP send-receive loop.\n+std::optional<std::vector<uint8_t>> PCPSendRecv(Sock &sock, const std::string &protocol, Span<const uint8_t> request, int num_tries,\n+        std::chrono::milliseconds timeout_per_try,\n+        std::function<bool(Span<const uint8_t>)> check_packet)\n+{\n+    using namespace std::chrono;\n+    // UDP is a potentially lossy protocol, so we try to send again a few times.\n+    uint8_t response[PCP_MAX_SIZE];\n+    bool got_response = false;\n+    int recvsz = 0;\n+    for (int ntry = 0; !got_response && ntry < num_tries; ++ntry) {\n+        if (ntry > 0) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Retrying (%d)\\n\", protocol, ntry);\n+        }\n+        // Dispatch packet to gateway.\n+        if (sock.Send(request.data(), request.size(), 0) != static_cast<ssize_t>(request.size())) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not send request: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+            return std::nullopt; // Network-level error, probably no use retrying.\n+        }\n+\n+        // Wait for response(s) until we get a valid response, a network error, or time out.\n+        auto cur_time = time_point_cast<milliseconds>(steady_clock::now());\n+        auto deadline = cur_time + timeout_per_try;\n+        while ((cur_time = time_point_cast<milliseconds>(steady_clock::now())) < deadline) {\n+            Sock::Event occurred = 0;\n+            if (!sock.Wait(deadline - cur_time, Sock::RECV, &occurred)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not wait on socket: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            if (!occurred) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Timeout\\n\", protocol);\n+                break; // Retry.\n+            }\n+\n+            // Receive response.\n+            recvsz = sock.Recv(response, sizeof(response), MSG_DONTWAIT);\n+            if (recvsz < 0) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not receive response: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Received response of %d bytes: %s\\n\", protocol, recvsz, HexStr(Span(response, recvsz)));\n+\n+            if (check_packet(Span<uint8_t>(response, recvsz))) {\n+                got_response = true; // Got expected response, break from receive loop as well as from retry loop.\n+                break;\n+            }\n+        }\n+    }\n+    if (!got_response) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Giving up after %d tries\\n\", protocol, num_tries);\n+        return std::nullopt;\n+    }\n+    return std::vector<uint8_t>(response, response + recvsz);\n+}\n+\n+}\n+\n+std::variant<MappingResult, MappingError> NATPMPRequestPortMap(const CNetAddr &gateway, uint16_t port, uint32_t lifetime, int num_tries, std::chrono::milliseconds timeout_per_try)\n+{\n+    struct sockaddr_storage dest_addr;\n+    socklen_t dest_addrlen = sizeof(struct sockaddr_storage);\n+\n+    LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"natpmp: Requesting port mapping port %d from gateway %s\\n\", port, gateway.ToStringAddr());\n+\n+    // Validate gateway, make sure it's IPv4. NAT-PMP does not support IPv6.\n+    if (!CService(gateway, PCP_SERVER_PORT).GetSockAddr((struct sockaddr*)&dest_addr, &dest_addrlen)) return MappingError::NETWORK_ERROR;\n+    if (dest_addr.ss_family != AF_INET) return MappingError::NETWORK_ERROR;\n+\n+    // Create IPv4 UDP socket\n+    auto sock{CreateSock(AF_INET, SOCK_DGRAM, IPPROTO_UDP)};\n+    if (!sock) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Could not create UDP socket: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Associate UDP socket to gateway.\n+    if (sock->Connect((struct sockaddr*)&dest_addr, dest_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Could not connect to gateway: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Use getsockname to get the address toward the default gateway (the internal address).\n+    struct sockaddr_in internal;\n+    socklen_t internal_addrlen = sizeof(struct sockaddr_in);\n+    if (sock->GetSockName((struct sockaddr*)&internal, &internal_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Could not get sock name: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Request external IP address (RFC6886 section 3.2).\n+    std::vector<uint8_t> request(NATPMP_GETEXTERNAL_REQUEST_SIZE);\n+    request[NATPMP_HDR_VERSION_OFS] = NATPMP_VERSION;\n+    request[NATPMP_HDR_OP_OFS] = NATPMP_REQUEST | NATPMP_OP_GETEXTERNAL;\n+\n+    auto recv_res = PCPSendRecv(*sock, \"natpmp\", request, num_tries, timeout_per_try,\n+        [&](const Span<const uint8_t> response) -> bool {\n+            if (response.size() < NATPMP_GETEXTERNAL_RESPONSE_SIZE) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response too small\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            if (response[NATPMP_HDR_VERSION_OFS] != NATPMP_VERSION || response[NATPMP_HDR_OP_OFS] != (NATPMP_RESPONSE | NATPMP_OP_GETEXTERNAL)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response to wrong command\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            return true;\n+        });\n+\n+    struct in_addr external_addr;\n+    if (recv_res) {\n+        const std::span<const uint8_t> response = *recv_res;\n+\n+        Assume(response.size() >= NATPMP_GETEXTERNAL_RESPONSE_SIZE);\n+        uint16_t result_code = ReadBE16(response.data() + NATPMP_RESPONSE_HDR_RESULT_OFS);\n+        if (result_code != NATPMP_RESULT_SUCCESS) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Getting external address failed with result %s\\n\", NATPMPResultString(result_code));\n+            return MappingError::PROTOCOL_ERROR;\n+        }\n+\n+        std::memcpy(&external_addr, response.data() + NATPMP_GETEXTERNAL_RESPONSE_IP_OFS, ADDR_IPV4_SIZE);\n+    } else {\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Create TCP mapping request (RFC6886 section 3.3).\n+    request = std::vector<uint8_t>(NATPMP_MAP_REQUEST_SIZE);\n+    request[NATPMP_HDR_VERSION_OFS] = NATPMP_VERSION;\n+    request[NATPMP_HDR_OP_OFS] = NATPMP_REQUEST | NATPMP_OP_MAP_TCP;\n+    WriteBE16(request.data() + NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS, port);\n+    WriteBE16(request.data() + NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS, port);\n+    WriteBE32(request.data() + NATPMP_MAP_REQUEST_LIFETIME_OFS, lifetime);\n+\n+    recv_res = PCPSendRecv(*sock, \"natpmp\", request, num_tries, timeout_per_try,\n+        [&](const Span<const uint8_t> response) -> bool {\n+            if (response.size() < NATPMP_MAP_RESPONSE_SIZE) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response too small\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            if (response[0] != NATPMP_VERSION || response[1] != (NATPMP_RESPONSE | NATPMP_OP_MAP_TCP)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response to wrong command\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            uint16_t internal_port = ReadBE16(response.data() + NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS);\n+            if (internal_port != port) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response port doesn't match request\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            return true;\n+        });\n+\n+    if (recv_res) {\n+        const std::span<uint8_t> response = *recv_res;\n+\n+        Assume(response.size() >= NATPMP_MAP_RESPONSE_SIZE);\n+        uint16_t result_code = ReadBE16(response.data() + NATPMP_RESPONSE_HDR_RESULT_OFS);\n+        if (result_code != NATPMP_RESULT_SUCCESS) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Port mapping failed with result %s\\n\", NATPMPResultString(result_code));\n+            if (result_code == NATPMP_RESULT_NO_RESOURCES) {\n+                return MappingError::NO_RESOURCES;\n+            }\n+            return MappingError::PROTOCOL_ERROR;\n+        }\n+\n+        uint32_t lifetime_ret = ReadBE32(response.data() + NATPMP_MAP_RESPONSE_LIFETIME_OFS);\n+        uint16_t external_port = ReadBE16(response.data() + NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS);\n+        return MappingResult(NATPMP_VERSION, CService(internal.sin_addr, port), CService(external_addr, external_port), lifetime_ret);\n+    } else {\n+        return MappingError::NETWORK_ERROR;\n+    }\n+}\n+\n+std::variant<MappingResult, MappingError> PCPRequestPortMap(const PCPMappingNonce &nonce, const CNetAddr &gateway, const CNetAddr &bind, uint16_t port, uint32_t lifetime, int num_tries, std::chrono::milliseconds timeout_per_try)\n+{\n+    struct sockaddr_storage dest_addr, bind_addr;\n+    socklen_t dest_addrlen = sizeof(struct sockaddr_storage), bind_addrlen = sizeof(struct sockaddr_storage);\n+\n+    LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"pcp: Requesting port mapping for addr %s port %d from gateway %s\\n\", bind.ToStringAddr(), port, gateway.ToStringAddr());\n+\n+    // Validate addresses, make sure they're the same network family.\n+    if (!CService(gateway, PCP_SERVER_PORT).GetSockAddr((struct sockaddr*)&dest_addr, &dest_addrlen)) return MappingError::NETWORK_ERROR;\n+    if (!CService(bind, 0).GetSockAddr((struct sockaddr*)&bind_addr, &bind_addrlen)) return MappingError::NETWORK_ERROR;\n+    if (dest_addr.ss_family != bind_addr.ss_family) return MappingError::NETWORK_ERROR;\n+\n+    // Create UDP socket (IPv4 or IPv6 based on provided gateway).\n+    auto sock{CreateSock(dest_addr.ss_family, SOCK_DGRAM, IPPROTO_UDP)};\n+    if (!sock) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp: Could not create UDP socket: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Make sure that we send from requested destination address, anything else will be\n+    // rejected by a security-conscious router.\n+    if (sock->Bind((struct sockaddr*)&bind_addr, bind_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp: Could not bind to address: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Associate UDP socket to gateway.\n+    if (sock->Connect((struct sockaddr*)&dest_addr, dest_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp: Could not connect to gateway: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Use getsockname to get the address toward the default gateway (the internal address),\n+    // in case we don't know what address to map\n+    // (this is only needed if bind is INADDR_ANY, but it doesn't hurt as an extra check).\n+    struct sockaddr_storage internal_addr;\n+    socklen_t internal_addrlen = sizeof(struct sockaddr_storage);\n+    if (sock->GetSockName((struct sockaddr*)&internal_addr, &internal_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp: Could not get sock name: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+    CService internal;\n+    if (!internal.SetSockAddr((struct sockaddr*)&internal_addr)) return MappingError::NETWORK_ERROR;\n+    LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"pcp: Internal address after connect: %s\\n\", internal.ToStringAddr());\n+\n+    // Build request packet. Make sure the packet is zeroed so that reserved fields are zero\n+    // as required by the spec (and not potentially leak data).\n+    // Make sure there's space for the request header and MAP specific request data.\n+    std::vector<uint8_t> request(PCP_HDR_SIZE + PCP_MAP_SIZE);\n+    // Fill in request header, See RFC6887 Figure 2.\n+    size_t ofs = 0;\n+    request[ofs + PCP_HDR_VERSION_OFS] = PCP_VERSION;\n+    request[ofs + PCP_HDR_OP_OFS] = PCP_REQUEST | PCP_OP_MAP;\n+    WriteBE32(request.data() + ofs + PCP_HDR_LIFETIME_OFS, lifetime);\n+    if (!PCPWrapAddress(Span(request).subspan(ofs + PCP_REQUEST_HDR_IP_OFS, ADDR_IPV6_SIZE), internal)) return MappingError::NETWORK_ERROR;\n+\n+    ofs += PCP_HDR_SIZE;\n+\n+    // Fill in MAP request packet, See RFC6887 Figure 9.\n+    // Randomize mapping nonce (this is repeated in the response, to be able to\n+    // correlate requests and responses, and used to authenticate changes to the mapping).\n+    std::memcpy(request.data() + ofs + PCP_MAP_NONCE_OFS, nonce.data(), PCP_MAP_NONCE_SIZE);\n+    request[ofs + PCP_MAP_PROTOCOL_OFS] = PCP_PROTOCOL_TCP;\n+    WriteBE16(request.data() + ofs + PCP_MAP_INTERNAL_PORT_OFS, port);\n+    WriteBE16(request.data() + ofs + PCP_MAP_EXTERNAL_PORT_OFS, port);\n+    if (!PCPWrapAddress(Span(request).subspan(ofs + PCP_MAP_EXTERNAL_IP_OFS, ADDR_IPV6_SIZE), bind)) return MappingError::NETWORK_ERROR;",
      "path": "src/util/pcp.cpp",
      "position": 452,
      "original_position": 452,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "23916f2a7717b463799207b4b81b5795f2e9d7e3",
      "in_reply_to_id": 1658485708,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "This is intentional. For IPv4 we provide the all-zeroes address, because the router will use its own (NAT), for IPv6 we *want* the external address to be the same as the local address (NAT is not a thing, we want pinholing).",
      "created_at": "2024-07-03T11:23:02Z",
      "updated_at": "2024-07-03T11:23:02Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1664031826",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1664031826"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 452,
      "original_line": 452,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1664034915",
      "pull_request_review_id": 2156189271,
      "id": 1664034915,
      "node_id": "PRRC_kwDOABII585jLyhj",
      "diff_hunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/pcp.h>\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <span.h>\n+#include <util/check.h>\n+#include <util/netif.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+namespace {\n+\n+// RFC6886 NAT-PMP and RFC6887 Port Control Protocol (PCP) implementation.\n+// NAT-PMP and PCP use network byte order (big-endian).\n+\n+// NAT-PMP (v0) protocol constants.\n+//! NAT-PMP uses a fixed server port number (RFC6887 section 1.1).\n+constexpr uint16_t NATPMP_SERVER_PORT = 5351;\n+//! Version byte for NATPMP (RFC6886 1.1)\n+constexpr uint8_t NATPMP_VERSION = 0;\n+//! Request opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_REQUEST = 0x00;\n+//! Response opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_RESPONSE = 0x80;\n+//! Get external address (RFC6886 3.2)\n+constexpr uint8_t NATPMP_OP_GETEXTERNAL = 0x00;\n+//! Map TCP port (RFC6886 3.3)\n+constexpr uint8_t NATPMP_OP_MAP_TCP = 0x02;\n+//! Shared request header size in bytes.\n+constexpr size_t NATPMP_REQUEST_HDR_SIZE = 2;\n+//! Shared response header (minimum) size in bytes.\n+constexpr size_t NATPMP_RESPONSE_HDR_SIZE = 8;\n+//! GETEXTERNAL request size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 0;\n+//! GETEXTERNAL response size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 4;\n+//! MAP request size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 10;\n+//! MAP response size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 8;\n+\n+// Shared header offsets (RFC6886 3.2, 3.3), relative to start of packet.\n+//!  Offset of version field in packets.\n+constexpr size_t NATPMP_HDR_VERSION_OFS = 0;\n+//!  Offset of opcode field in packets\n+constexpr size_t NATPMP_HDR_OP_OFS = 1;\n+//!  Offset of result code in packets. Result codes are 16 bit in NAT-PMP instead of 8 bit in PCP.\n+constexpr size_t NATPMP_RESPONSE_HDR_RESULT_OFS = 2;\n+\n+// GETEXTERNAL response offsets (RFC6886 3.2), relative to start of packet.\n+//!  Returned external address\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_IP_OFS = 8;\n+\n+// MAP request offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port to be mapped.\n+constexpr size_t NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS = 4;\n+//!  Suggested external port for mapping.\n+constexpr size_t NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS = 6;\n+//!  Requested port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_REQUEST_LIFETIME_OFS = 8;\n+\n+// MAP response offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port for mapping (will match internal port of request).\n+constexpr size_t NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS = 8;\n+//!  External port for mapping.\n+constexpr size_t NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS = 10;\n+//!  Created port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_RESPONSE_LIFETIME_OFS = 12;\n+\n+// Relevant NETPMP result codes (RFC6886 3.5).\n+//! Result code representing success status.\n+constexpr uint8_t NATPMP_RESULT_SUCCESS = 0;\n+//! Result code representing unsupported version.\n+constexpr uint8_t NATPMP_RESULT_UNSUPP_VERSION = 1;\n+//! Result code representing lack of resources.\n+constexpr uint8_t NATPMP_RESULT_NO_RESOURCES = 4;\n+\n+//! Mapping of NATPMP result code to string (RFC6886 3.5). Result codes <=2 match PCP.\n+const std::map<uint8_t, std::string> NATPMP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"NETWORK_FAILURE\"},\n+    {4,  \"NO_RESOURCES\"},\n+    {5,  \"UNSUPP_OPCODE\"},\n+};\n+\n+// PCP (v2) protocol constants.\n+//! Maximum packet size in bytes (RFC6887 section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (RFC6887 section 19.1). Shared with NAT-PMP.\n+constexpr uint16_t PCP_SERVER_PORT = NATPMP_SERVER_PORT;\n+//! Version byte. 0 is NAT-PMP (RFC6886), 1 is forbidden, 2 for PCP (RFC6887).\n+constexpr uint8_t PCP_VERSION = 2;\n+//! PCP Request Header. See RFC6887 section 7.1. Shared with NAT-PMP.\n+constexpr uint8_t PCP_REQUEST = NATPMP_REQUEST; // R = 0\n+//! PCP Response Header. See RFC6887 section 7.2. Shared with NAT-PMP.\n+constexpr uint8_t PCP_RESPONSE = NATPMP_RESPONSE; // R = 1\n+//! Map opcode. See RFC6887 section 19.2\n+constexpr uint8_t PCP_OP_MAP = 0x01;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Request and response header size in bytes (RFC6887 section 7.1).\n+constexpr size_t PCP_HDR_SIZE = 24;\n+//! Map request and response size in bytes (RFC6887 section 11.1).\n+constexpr size_t PCP_MAP_SIZE = 36;\n+\n+// Header offsets shared between request and responses (RFC6887 7.1, 7.2), relative to start of packet.\n+//!  Version field (1 byte).\n+constexpr size_t PCP_HDR_VERSION_OFS = NATPMP_HDR_VERSION_OFS;\n+//!  Opcode field (1 byte).\n+constexpr size_t PCP_HDR_OP_OFS = NATPMP_HDR_OP_OFS;\n+//!  Requested lifetime (request), granted lifetime (response) (2 bytes).\n+constexpr size_t PCP_HDR_LIFETIME_OFS = 4;\n+\n+// Request header offsets (RFC6887 7.1), relative to start of packet.\n+//!  PCP client's IP address (16 bytes).\n+constexpr size_t PCP_REQUEST_HDR_IP_OFS = 8;\n+\n+// Response header offsets (RFC6887 7.2), relative to start of packet.\n+//!  Result code (1 byte).\n+constexpr size_t PCP_RESPONSE_HDR_RESULT_OFS = 3;\n+\n+// MAP request/response offsets (RFC6887 11.1), relative to start of opcode-specific data.\n+//!  Mapping nonce (12 bytes).\n+constexpr size_t PCP_MAP_NONCE_OFS = 0;\n+//!  Protocol (1 byte).\n+constexpr size_t PCP_MAP_PROTOCOL_OFS = 12;\n+//!  Internal port for mapping (2 bytes).\n+constexpr size_t PCP_MAP_INTERNAL_PORT_OFS = 16;\n+//!  Suggested external port (request), assigned external port (response) (2 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_PORT_OFS = 18;\n+//!  Suggested external IP (request), assigned external IP (response) (16 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_IP_OFS = 20;\n+\n+//! Result code representing success (RFC6887 7.4), shared with NAT-PMP.\n+constexpr uint8_t PCP_RESULT_SUCCESS = NATPMP_RESULT_SUCCESS;\n+//! Result code representing lack of resources (RFC6887 7.4).\n+constexpr uint8_t PCP_RESULT_NO_RESOURCES = 8;\n+\n+//! Mapping of PCP result code to string (RFC6887 7.4). Result codes <=2 match NAT-PMP.\n+const std::map<uint8_t, std::string> PCP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"MALFORMED_REQUEST\"},\n+    {4,  \"UNSUPP_OPCODE\"},\n+    {5,  \"UNSUPP_OPTION\"},\n+    {6,  \"MALFORMED_OPTION\"},\n+    {7,  \"NETWORK_FAILURE\"},\n+    {8,  \"NO_RESOURCES\"},\n+    {9,  \"UNSUPP_PROTOCOL\"},\n+    {10, \"USER_EX_QUOTA\"},\n+    {11, \"CANNOT_PROVIDE_EXTERNAL\"},\n+    {12, \"ADDRESS_MISMATCH\"},\n+    {13, \"EXCESSIVE_REMOTE_PEER\"},\n+};\n+\n+//! Return human-readable string from NATPMP result code.\n+std::string NATPMPResultString(uint8_t result_code)\n+{\n+    auto result_i = NATPMP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == NATPMP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Return human-readable string from PCP result code.\n+std::string PCPResultString(uint8_t result_code)\n+{\n+    auto result_i = PCP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == PCP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Wrap address in IPv6 according to RFC6887. wrapped_addr needs to be able to store 16 bytes.\n+[[nodiscard]] bool PCPWrapAddress(Span<uint8_t> wrapped_addr, const CNetAddr &addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (addr.IsIPv4()) {\n+        struct in_addr addr4;\n+        if (!addr.GetInAddr(&addr4)) return false;\n+        // Section 5: \"When the address field holds an IPv4 address, an IPv4-mapped IPv6 address [RFC4291] is used (::ffff:0:0/96).\"\n+        std::memcpy(wrapped_addr.data(), IPV4_IN_IPV6_PREFIX.data(), IPV4_IN_IPV6_PREFIX.size());\n+        std::memcpy(wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), &addr4, ADDR_IPV4_SIZE);\n+        return true;\n+    } else if (addr.IsIPv6()) {\n+        struct in6_addr addr6;\n+        if (!addr.GetIn6Addr(&addr6)) return false;\n+        std::memcpy(wrapped_addr.data(), &addr6, ADDR_IPV6_SIZE);\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+//! Unwrap PCP-encoded address according to RFC6887.\n+CNetAddr PCPUnwrapAddress(Span<const uint8_t> wrapped_addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (util::HasPrefix(wrapped_addr, IPV4_IN_IPV6_PREFIX)) {\n+        struct in_addr addr4;\n+        std::memcpy(&addr4, wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), ADDR_IPV4_SIZE);\n+        return CNetAddr(addr4);\n+    } else {\n+        struct in6_addr addr6;\n+        std::memcpy(&addr6, wrapped_addr.data(), ADDR_IPV6_SIZE);\n+        return CNetAddr(addr6);\n+    }\n+}\n+\n+//! PCP or NAT-PMP send-receive loop.\n+std::optional<std::vector<uint8_t>> PCPSendRecv(Sock &sock, const std::string &protocol, Span<const uint8_t> request, int num_tries,\n+        std::chrono::milliseconds timeout_per_try,\n+        std::function<bool(Span<const uint8_t>)> check_packet)\n+{\n+    using namespace std::chrono;\n+    // UDP is a potentially lossy protocol, so we try to send again a few times.\n+    uint8_t response[PCP_MAX_SIZE];\n+    bool got_response = false;\n+    int recvsz = 0;\n+    for (int ntry = 0; !got_response && ntry < num_tries; ++ntry) {\n+        if (ntry > 0) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Retrying (%d)\\n\", protocol, ntry);\n+        }\n+        // Dispatch packet to gateway.\n+        if (sock.Send(request.data(), request.size(), 0) != static_cast<ssize_t>(request.size())) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not send request: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+            return std::nullopt; // Network-level error, probably no use retrying.\n+        }\n+\n+        // Wait for response(s) until we get a valid response, a network error, or time out.\n+        auto cur_time = time_point_cast<milliseconds>(steady_clock::now());\n+        auto deadline = cur_time + timeout_per_try;\n+        while ((cur_time = time_point_cast<milliseconds>(steady_clock::now())) < deadline) {\n+            Sock::Event occurred = 0;\n+            if (!sock.Wait(deadline - cur_time, Sock::RECV, &occurred)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not wait on socket: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            if (!occurred) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Timeout\\n\", protocol);\n+                break; // Retry.\n+            }\n+\n+            // Receive response.\n+            recvsz = sock.Recv(response, sizeof(response), MSG_DONTWAIT);\n+            if (recvsz < 0) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not receive response: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Received response of %d bytes: %s\\n\", protocol, recvsz, HexStr(Span(response, recvsz)));\n+\n+            if (check_packet(Span<uint8_t>(response, recvsz))) {\n+                got_response = true; // Got expected response, break from receive loop as well as from retry loop.\n+                break;\n+            }\n+        }\n+    }\n+    if (!got_response) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Giving up after %d tries\\n\", protocol, num_tries);\n+        return std::nullopt;\n+    }\n+    return std::vector<uint8_t>(response, response + recvsz);\n+}\n+\n+}\n+\n+std::variant<MappingResult, MappingError> NATPMPRequestPortMap(const CNetAddr &gateway, uint16_t port, uint32_t lifetime, int num_tries, std::chrono::milliseconds timeout_per_try)\n+{\n+    struct sockaddr_storage dest_addr;\n+    socklen_t dest_addrlen = sizeof(struct sockaddr_storage);\n+\n+    LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"natpmp: Requesting port mapping port %d from gateway %s\\n\", port, gateway.ToStringAddr());\n+\n+    // Validate gateway, make sure it's IPv4. NAT-PMP does not support IPv6.\n+    if (!CService(gateway, PCP_SERVER_PORT).GetSockAddr((struct sockaddr*)&dest_addr, &dest_addrlen)) return MappingError::NETWORK_ERROR;\n+    if (dest_addr.ss_family != AF_INET) return MappingError::NETWORK_ERROR;\n+\n+    // Create IPv4 UDP socket\n+    auto sock{CreateSock(AF_INET, SOCK_DGRAM, IPPROTO_UDP)};\n+    if (!sock) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Could not create UDP socket: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Associate UDP socket to gateway.\n+    if (sock->Connect((struct sockaddr*)&dest_addr, dest_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Could not connect to gateway: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Use getsockname to get the address toward the default gateway (the internal address).\n+    struct sockaddr_in internal;\n+    socklen_t internal_addrlen = sizeof(struct sockaddr_in);\n+    if (sock->GetSockName((struct sockaddr*)&internal, &internal_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Could not get sock name: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Request external IP address (RFC6886 section 3.2).\n+    std::vector<uint8_t> request(NATPMP_GETEXTERNAL_REQUEST_SIZE);\n+    request[NATPMP_HDR_VERSION_OFS] = NATPMP_VERSION;\n+    request[NATPMP_HDR_OP_OFS] = NATPMP_REQUEST | NATPMP_OP_GETEXTERNAL;\n+\n+    auto recv_res = PCPSendRecv(*sock, \"natpmp\", request, num_tries, timeout_per_try,\n+        [&](const Span<const uint8_t> response) -> bool {\n+            if (response.size() < NATPMP_GETEXTERNAL_RESPONSE_SIZE) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response too small\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            if (response[NATPMP_HDR_VERSION_OFS] != NATPMP_VERSION || response[NATPMP_HDR_OP_OFS] != (NATPMP_RESPONSE | NATPMP_OP_GETEXTERNAL)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response to wrong command\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            return true;\n+        });\n+\n+    struct in_addr external_addr;\n+    if (recv_res) {\n+        const std::span<const uint8_t> response = *recv_res;\n+\n+        Assume(response.size() >= NATPMP_GETEXTERNAL_RESPONSE_SIZE);\n+        uint16_t result_code = ReadBE16(response.data() + NATPMP_RESPONSE_HDR_RESULT_OFS);\n+        if (result_code != NATPMP_RESULT_SUCCESS) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Getting external address failed with result %s\\n\", NATPMPResultString(result_code));\n+            return MappingError::PROTOCOL_ERROR;\n+        }\n+\n+        std::memcpy(&external_addr, response.data() + NATPMP_GETEXTERNAL_RESPONSE_IP_OFS, ADDR_IPV4_SIZE);\n+    } else {\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Create TCP mapping request (RFC6886 section 3.3).\n+    request = std::vector<uint8_t>(NATPMP_MAP_REQUEST_SIZE);\n+    request[NATPMP_HDR_VERSION_OFS] = NATPMP_VERSION;\n+    request[NATPMP_HDR_OP_OFS] = NATPMP_REQUEST | NATPMP_OP_MAP_TCP;\n+    WriteBE16(request.data() + NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS, port);\n+    WriteBE16(request.data() + NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS, port);\n+    WriteBE32(request.data() + NATPMP_MAP_REQUEST_LIFETIME_OFS, lifetime);\n+\n+    recv_res = PCPSendRecv(*sock, \"natpmp\", request, num_tries, timeout_per_try,\n+        [&](const Span<const uint8_t> response) -> bool {\n+            if (response.size() < NATPMP_MAP_RESPONSE_SIZE) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response too small\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            if (response[0] != NATPMP_VERSION || response[1] != (NATPMP_RESPONSE | NATPMP_OP_MAP_TCP)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response to wrong command\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            uint16_t internal_port = ReadBE16(response.data() + NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS);\n+            if (internal_port != port) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response port doesn't match request\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            return true;\n+        });\n+\n+    if (recv_res) {\n+        const std::span<uint8_t> response = *recv_res;\n+\n+        Assume(response.size() >= NATPMP_MAP_RESPONSE_SIZE);\n+        uint16_t result_code = ReadBE16(response.data() + NATPMP_RESPONSE_HDR_RESULT_OFS);\n+        if (result_code != NATPMP_RESULT_SUCCESS) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Port mapping failed with result %s\\n\", NATPMPResultString(result_code));\n+            if (result_code == NATPMP_RESULT_NO_RESOURCES) {\n+                return MappingError::NO_RESOURCES;\n+            }\n+            return MappingError::PROTOCOL_ERROR;\n+        }\n+\n+        uint32_t lifetime_ret = ReadBE32(response.data() + NATPMP_MAP_RESPONSE_LIFETIME_OFS);\n+        uint16_t external_port = ReadBE16(response.data() + NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS);\n+        return MappingResult(NATPMP_VERSION, CService(internal.sin_addr, port), CService(external_addr, external_port), lifetime_ret);\n+    } else {\n+        return MappingError::NETWORK_ERROR;\n+    }\n+}\n+\n+std::variant<MappingResult, MappingError> PCPRequestPortMap(const PCPMappingNonce &nonce, const CNetAddr &gateway, const CNetAddr &bind, uint16_t port, uint32_t lifetime, int num_tries, std::chrono::milliseconds timeout_per_try)\n+{\n+    struct sockaddr_storage dest_addr, bind_addr;\n+    socklen_t dest_addrlen = sizeof(struct sockaddr_storage), bind_addrlen = sizeof(struct sockaddr_storage);\n+\n+    LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"pcp: Requesting port mapping for addr %s port %d from gateway %s\\n\", bind.ToStringAddr(), port, gateway.ToStringAddr());\n+\n+    // Validate addresses, make sure they're the same network family.\n+    if (!CService(gateway, PCP_SERVER_PORT).GetSockAddr((struct sockaddr*)&dest_addr, &dest_addrlen)) return MappingError::NETWORK_ERROR;\n+    if (!CService(bind, 0).GetSockAddr((struct sockaddr*)&bind_addr, &bind_addrlen)) return MappingError::NETWORK_ERROR;\n+    if (dest_addr.ss_family != bind_addr.ss_family) return MappingError::NETWORK_ERROR;\n+\n+    // Create UDP socket (IPv4 or IPv6 based on provided gateway).\n+    auto sock{CreateSock(dest_addr.ss_family, SOCK_DGRAM, IPPROTO_UDP)};\n+    if (!sock) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp: Could not create UDP socket: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Make sure that we send from requested destination address, anything else will be\n+    // rejected by a security-conscious router.\n+    if (sock->Bind((struct sockaddr*)&bind_addr, bind_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp: Could not bind to address: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Associate UDP socket to gateway.\n+    if (sock->Connect((struct sockaddr*)&dest_addr, dest_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp: Could not connect to gateway: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Use getsockname to get the address toward the default gateway (the internal address),\n+    // in case we don't know what address to map\n+    // (this is only needed if bind is INADDR_ANY, but it doesn't hurt as an extra check).\n+    struct sockaddr_storage internal_addr;\n+    socklen_t internal_addrlen = sizeof(struct sockaddr_storage);\n+    if (sock->GetSockName((struct sockaddr*)&internal_addr, &internal_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp: Could not get sock name: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+    CService internal;\n+    if (!internal.SetSockAddr((struct sockaddr*)&internal_addr)) return MappingError::NETWORK_ERROR;\n+    LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"pcp: Internal address after connect: %s\\n\", internal.ToStringAddr());\n+\n+    // Build request packet. Make sure the packet is zeroed so that reserved fields are zero\n+    // as required by the spec (and not potentially leak data).\n+    // Make sure there's space for the request header and MAP specific request data.\n+    std::vector<uint8_t> request(PCP_HDR_SIZE + PCP_MAP_SIZE);\n+    // Fill in request header, See RFC6887 Figure 2.\n+    size_t ofs = 0;\n+    request[ofs + PCP_HDR_VERSION_OFS] = PCP_VERSION;\n+    request[ofs + PCP_HDR_OP_OFS] = PCP_REQUEST | PCP_OP_MAP;\n+    WriteBE32(request.data() + ofs + PCP_HDR_LIFETIME_OFS, lifetime);\n+    if (!PCPWrapAddress(Span(request).subspan(ofs + PCP_REQUEST_HDR_IP_OFS, ADDR_IPV6_SIZE), internal)) return MappingError::NETWORK_ERROR;\n+\n+    ofs += PCP_HDR_SIZE;\n+\n+    // Fill in MAP request packet, See RFC6887 Figure 9.\n+    // Randomize mapping nonce (this is repeated in the response, to be able to\n+    // correlate requests and responses, and used to authenticate changes to the mapping).\n+    std::memcpy(request.data() + ofs + PCP_MAP_NONCE_OFS, nonce.data(), PCP_MAP_NONCE_SIZE);\n+    request[ofs + PCP_MAP_PROTOCOL_OFS] = PCP_PROTOCOL_TCP;\n+    WriteBE16(request.data() + ofs + PCP_MAP_INTERNAL_PORT_OFS, port);\n+    WriteBE16(request.data() + ofs + PCP_MAP_EXTERNAL_PORT_OFS, port);\n+    if (!PCPWrapAddress(Span(request).subspan(ofs + PCP_MAP_EXTERNAL_IP_OFS, ADDR_IPV6_SIZE), bind)) return MappingError::NETWORK_ERROR;\n+\n+    ofs += PCP_MAP_SIZE;\n+    Assume(ofs == request.size());\n+\n+    // Receive loop.\n+    bool is_natpmp = false;\n+    auto recv_res = PCPSendRecv(*sock, \"pcp\", request, num_tries, timeout_per_try,\n+        [&](const Span<const uint8_t> response) -> bool {\n+            // Unsupported version according to RFC6887 appendix A and RFC6886 section 3.5, can fall back to NAT-PMP.\n+            if (response.size() == NATPMP_RESPONSE_HDR_SIZE && response[PCP_HDR_VERSION_OFS] == NATPMP_VERSION && response[PCP_RESPONSE_HDR_RESULT_OFS] == NATPMP_RESULT_UNSUPP_VERSION) {\n+                is_natpmp = true;\n+                return true; // Let it through to caller.\n+            }\n+            if (response.size() < (PCP_HDR_SIZE + PCP_MAP_SIZE)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp: Response too small\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            if (response[PCP_HDR_VERSION_OFS] != PCP_VERSION || response[PCP_HDR_OP_OFS] != (PCP_RESPONSE | PCP_OP_MAP)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp: Response to wrong command\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            // Handle MAP opcode response. See RFC6887 Figure 10.\n+            // Check that returned mapping nonce matches our request.\n+            if (response.subspan(PCP_HDR_SIZE + PCP_MAP_NONCE_OFS, PCP_MAP_NONCE_SIZE) != Span(nonce)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp: Mapping nonce mismatch\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            uint8_t protocol = response[PCP_HDR_SIZE + 12];\n+            uint16_t internal_port = ReadBE16(response.data() + PCP_HDR_SIZE + 16);\n+            if (protocol != PCP_PROTOCOL_TCP || internal_port != port) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp: Response protocol or port doesn't match request\\n\");",
      "path": "src/util/pcp.cpp",
      "position": 483,
      "original_position": 483,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "23916f2a7717b463799207b4b81b5795f2e9d7e3",
      "in_reply_to_id": 1658641733,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "As we receive the UDP packet at all, i think that should be correct. But sure...",
      "created_at": "2024-07-03T11:25:26Z",
      "updated_at": "2024-07-03T11:25:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1664034915",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1664034915"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 483,
      "original_line": 483,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1664036768",
      "pull_request_review_id": 2156192261,
      "id": 1664036768,
      "node_id": "PRRC_kwDOABII585jLy-g",
      "diff_hunk": "@@ -46,104 +43,96 @@ using namespace std::chrono_literals;\n static constexpr auto PORT_MAPPING_REANNOUNCE_PERIOD{20min};\n static constexpr auto PORT_MAPPING_RETRY_PERIOD{5min};\n \n-#ifdef USE_NATPMP\n-static uint16_t g_mapport_external_port = 0;\n-static bool NatpmpInit(natpmp_t* natpmp)\n+static bool ProcessPCP()\n {\n-    const int r_init = initnatpmp(natpmp, /* detect gateway automatically */ 0, /* forced gateway - NOT APPLIED*/ 0);\n-    if (r_init == 0) return true;\n-    LogPrintf(\"natpmp: initnatpmp() failed with %d error.\\n\", r_init);\n-    return false;\n-}\n+    // The same nonce is used for all mappings, this is allowed by the spec, and simplifies keeping track of them.\n+    PCPMappingNonce pcp_nonce;\n+    GetRandBytes(pcp_nonce);\n \n-static bool NatpmpDiscover(natpmp_t* natpmp, struct in_addr& external_ipv4_addr)\n-{\n-    const int r_send = sendpublicaddressrequest(natpmp);\n-    if (r_send == 2 /* OK */) {\n-        int r_read;\n-        natpmpresp_t response;\n-        do {\n-            r_read = readnatpmpresponseorretry(natpmp, &response);\n-        } while (r_read == NATPMP_TRYAGAIN);\n-\n-        if (r_read == 0) {\n-            external_ipv4_addr = response.pnu.publicaddress.addr;\n-            return true;\n-        } else if (r_read == NATPMP_ERR_NOGATEWAYSUPPORT) {\n-            LogPrintf(\"natpmp: The gateway does not support NAT-PMP.\\n\");\n+    bool ret = false;\n+    bool no_resources = false;\n+    const uint16_t private_port = GetListenPort();\n+    // Multiply the reannounce period by two, as we'll try to renew approximately halfway.\n+    const uint32_t requested_lifetime = std::chrono::seconds(PORT_MAPPING_REANNOUNCE_PERIOD * 2).count();\n+    uint32_t actual_lifetime = 0;\n+    std::chrono::milliseconds sleep_time;\n+\n+    // Local functor to handle result from PCP/NATPMP mapping.\n+    auto handle_mapping = [&](std::variant<MappingResult, MappingError> &res) -> void {\n+        if (MappingResult* mapping = std::get_if<MappingResult>(&res)) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Info, \"portmap: Added mapping %s\\n\", mapping->ToString());\n+            AddLocal(mapping->external, LOCAL_MAPPED);\n+            ret = true;\n+            actual_lifetime = std::min(actual_lifetime, mapping->lifetime);",
      "path": "src/mapport.cpp",
      "position": 73,
      "original_position": 73,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "23916f2a7717b463799207b4b81b5795f2e9d7e3",
      "in_reply_to_id": 1658751623,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Again, i intentionally use a simple imlementation here. i don't want to complicate the code too much. As i understand, this covers the practical cases. It chooses the minimum because we don't want holes in coverage while renewing the mapping more than necessary doesn't hurt.",
      "created_at": "2024-07-03T11:27:04Z",
      "updated_at": "2024-07-03T11:27:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1664036768",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1664036768"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 66,
      "original_line": 66,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1664067870",
      "pull_request_review_id": 2156242997,
      "id": 1664067870,
      "node_id": "PRRC_kwDOABII585jL6ke",
      "diff_hunk": "@@ -46,104 +43,96 @@ using namespace std::chrono_literals;\n static constexpr auto PORT_MAPPING_REANNOUNCE_PERIOD{20min};\n static constexpr auto PORT_MAPPING_RETRY_PERIOD{5min};\n \n-#ifdef USE_NATPMP\n-static uint16_t g_mapport_external_port = 0;\n-static bool NatpmpInit(natpmp_t* natpmp)\n+static bool ProcessPCP()\n {\n-    const int r_init = initnatpmp(natpmp, /* detect gateway automatically */ 0, /* forced gateway - NOT APPLIED*/ 0);\n-    if (r_init == 0) return true;\n-    LogPrintf(\"natpmp: initnatpmp() failed with %d error.\\n\", r_init);\n-    return false;\n-}\n+    // The same nonce is used for all mappings, this is allowed by the spec, and simplifies keeping track of them.\n+    PCPMappingNonce pcp_nonce;\n+    GetRandBytes(pcp_nonce);\n \n-static bool NatpmpDiscover(natpmp_t* natpmp, struct in_addr& external_ipv4_addr)\n-{\n-    const int r_send = sendpublicaddressrequest(natpmp);\n-    if (r_send == 2 /* OK */) {\n-        int r_read;\n-        natpmpresp_t response;\n-        do {\n-            r_read = readnatpmpresponseorretry(natpmp, &response);\n-        } while (r_read == NATPMP_TRYAGAIN);\n-\n-        if (r_read == 0) {\n-            external_ipv4_addr = response.pnu.publicaddress.addr;\n-            return true;\n-        } else if (r_read == NATPMP_ERR_NOGATEWAYSUPPORT) {\n-            LogPrintf(\"natpmp: The gateway does not support NAT-PMP.\\n\");\n+    bool ret = false;\n+    bool no_resources = false;\n+    const uint16_t private_port = GetListenPort();\n+    // Multiply the reannounce period by two, as we'll try to renew approximately halfway.\n+    const uint32_t requested_lifetime = std::chrono::seconds(PORT_MAPPING_REANNOUNCE_PERIOD * 2).count();\n+    uint32_t actual_lifetime = 0;\n+    std::chrono::milliseconds sleep_time;\n+\n+    // Local functor to handle result from PCP/NATPMP mapping.\n+    auto handle_mapping = [&](std::variant<MappingResult, MappingError> &res) -> void {\n+        if (MappingResult* mapping = std::get_if<MappingResult>(&res)) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Info, \"portmap: Added mapping %s\\n\", mapping->ToString());\n+            AddLocal(mapping->external, LOCAL_MAPPED);\n+            ret = true;\n+            actual_lifetime = std::min(actual_lifetime, mapping->lifetime);\n+        } else if (MappingError *err = std::get_if<MappingError>(&res)) {\n+            // Detailed error will already have been logged internally in respective Portmap function.\n+            if (*err == MappingError::NO_RESOURCES) {\n+                no_resources = true;\n+            }\n+        }\n+    };\n+\n+    do {\n+        actual_lifetime = requested_lifetime;\n+        no_resources = false; // Set to true if there was any \"no resources\" error.\n+        ret = false; // Set to true if any mapping succeeds.\n+\n+        // IPv4\n+        std::optional<CNetAddr> gateway4 = QueryDefaultGateway(NET_IPV4);\n+        if (!gateway4) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: Could not determine IPv4 default gateway\\n\");\n         } else {\n-            LogPrintf(\"natpmp: readnatpmpresponseorretry() for public address failed with %d error.\\n\", r_read);\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: gateway [IPv4]: %s\\n\", gateway4->ToStringAddr());\n+\n+            // Open a port mapping on whatever local address we have toward the gateway.\n+            struct in_addr inaddr_any;\n+            inaddr_any.s_addr = htonl(INADDR_ANY);\n+            auto res = PCPRequestPortMap(pcp_nonce, *gateway4, CNetAddr(inaddr_any), private_port, requested_lifetime);\n+            MappingError* pcp_err = std::get_if<MappingError>(&res);\n+            if (pcp_err && *pcp_err == MappingError::UNSUPP_VERSION) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: Got unsupported PCP version response, falling back to NAT-PMP\\n\");\n+                res = NATPMPRequestPortMap(*gateway4, private_port, requested_lifetime);\n+            }\n+            handle_mapping(res);\n         }\n-    } else {\n-        LogPrintf(\"natpmp: sendpublicaddressrequest() failed with %d error.\\n\", r_send);\n-    }\n \n-    return false;\n-}\n+        // IPv6\n+        std::optional<CNetAddr> gateway6 = QueryDefaultGateway(NET_IPV6);\n+        if (!gateway6) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: Could not determine IPv6 default gateway\\n\");",
      "path": "src/mapport.cpp",
      "position": 115,
      "original_position": 115,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "23916f2a7717b463799207b4b81b5795f2e9d7e3",
      "in_reply_to_id": 1658764974,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Yes, that makes sense, in the case of onlynet=ipv6 we wouldn't want to advertise a port on ipv4 and vice versa.",
      "created_at": "2024-07-03T11:53:44Z",
      "updated_at": "2024-07-03T11:53:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1664067870",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1664067870"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 102,
      "original_line": 102,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1664071010",
      "pull_request_review_id": 2156248162,
      "id": 1664071010,
      "node_id": "PRRC_kwDOABII585jL7Vi",
      "diff_hunk": "@@ -46,104 +43,96 @@ using namespace std::chrono_literals;\n static constexpr auto PORT_MAPPING_REANNOUNCE_PERIOD{20min};\n static constexpr auto PORT_MAPPING_RETRY_PERIOD{5min};\n \n-#ifdef USE_NATPMP\n-static uint16_t g_mapport_external_port = 0;\n-static bool NatpmpInit(natpmp_t* natpmp)\n+static bool ProcessPCP()\n {\n-    const int r_init = initnatpmp(natpmp, /* detect gateway automatically */ 0, /* forced gateway - NOT APPLIED*/ 0);\n-    if (r_init == 0) return true;\n-    LogPrintf(\"natpmp: initnatpmp() failed with %d error.\\n\", r_init);\n-    return false;\n-}\n+    // The same nonce is used for all mappings, this is allowed by the spec, and simplifies keeping track of them.\n+    PCPMappingNonce pcp_nonce;\n+    GetRandBytes(pcp_nonce);\n \n-static bool NatpmpDiscover(natpmp_t* natpmp, struct in_addr& external_ipv4_addr)\n-{\n-    const int r_send = sendpublicaddressrequest(natpmp);\n-    if (r_send == 2 /* OK */) {\n-        int r_read;\n-        natpmpresp_t response;\n-        do {\n-            r_read = readnatpmpresponseorretry(natpmp, &response);\n-        } while (r_read == NATPMP_TRYAGAIN);\n-\n-        if (r_read == 0) {\n-            external_ipv4_addr = response.pnu.publicaddress.addr;\n-            return true;\n-        } else if (r_read == NATPMP_ERR_NOGATEWAYSUPPORT) {\n-            LogPrintf(\"natpmp: The gateway does not support NAT-PMP.\\n\");\n+    bool ret = false;\n+    bool no_resources = false;\n+    const uint16_t private_port = GetListenPort();\n+    // Multiply the reannounce period by two, as we'll try to renew approximately halfway.\n+    const uint32_t requested_lifetime = std::chrono::seconds(PORT_MAPPING_REANNOUNCE_PERIOD * 2).count();\n+    uint32_t actual_lifetime = 0;\n+    std::chrono::milliseconds sleep_time;\n+\n+    // Local functor to handle result from PCP/NATPMP mapping.\n+    auto handle_mapping = [&](std::variant<MappingResult, MappingError> &res) -> void {\n+        if (MappingResult* mapping = std::get_if<MappingResult>(&res)) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Info, \"portmap: Added mapping %s\\n\", mapping->ToString());\n+            AddLocal(mapping->external, LOCAL_MAPPED);\n+            ret = true;\n+            actual_lifetime = std::min(actual_lifetime, mapping->lifetime);\n+        } else if (MappingError *err = std::get_if<MappingError>(&res)) {\n+            // Detailed error will already have been logged internally in respective Portmap function.\n+            if (*err == MappingError::NO_RESOURCES) {\n+                no_resources = true;\n+            }\n+        }\n+    };\n+\n+    do {\n+        actual_lifetime = requested_lifetime;\n+        no_resources = false; // Set to true if there was any \"no resources\" error.\n+        ret = false; // Set to true if any mapping succeeds.\n+\n+        // IPv4\n+        std::optional<CNetAddr> gateway4 = QueryDefaultGateway(NET_IPV4);\n+        if (!gateway4) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: Could not determine IPv4 default gateway\\n\");\n         } else {\n-            LogPrintf(\"natpmp: readnatpmpresponseorretry() for public address failed with %d error.\\n\", r_read);\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: gateway [IPv4]: %s\\n\", gateway4->ToStringAddr());\n+\n+            // Open a port mapping on whatever local address we have toward the gateway.\n+            struct in_addr inaddr_any;\n+            inaddr_any.s_addr = htonl(INADDR_ANY);\n+            auto res = PCPRequestPortMap(pcp_nonce, *gateway4, CNetAddr(inaddr_any), private_port, requested_lifetime);",
      "path": "src/mapport.cpp",
      "position": 98,
      "original_position": 98,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "23916f2a7717b463799207b4b81b5795f2e9d7e3",
      "in_reply_to_id": 1658779455,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "i've thought about this, but due to how bitcoin handles non-standard ports, we really want the configured external port, not another one, i think it makes sense to keep trying to get it, even if the router assigns us a different one once.",
      "created_at": "2024-07-03T11:56:12Z",
      "updated_at": "2024-07-03T11:56:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1664071010",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1664071010"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 90,
      "original_line": 90,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1664074217",
      "pull_request_review_id": 2156253037,
      "id": 1664074217,
      "node_id": "PRRC_kwDOABII585jL8Hp",
      "diff_hunk": "@@ -46,104 +43,96 @@ using namespace std::chrono_literals;\n static constexpr auto PORT_MAPPING_REANNOUNCE_PERIOD{20min};\n static constexpr auto PORT_MAPPING_RETRY_PERIOD{5min};\n \n-#ifdef USE_NATPMP\n-static uint16_t g_mapport_external_port = 0;\n-static bool NatpmpInit(natpmp_t* natpmp)\n+static bool ProcessPCP()\n {\n-    const int r_init = initnatpmp(natpmp, /* detect gateway automatically */ 0, /* forced gateway - NOT APPLIED*/ 0);\n-    if (r_init == 0) return true;\n-    LogPrintf(\"natpmp: initnatpmp() failed with %d error.\\n\", r_init);\n-    return false;\n-}\n+    // The same nonce is used for all mappings, this is allowed by the spec, and simplifies keeping track of them.\n+    PCPMappingNonce pcp_nonce;\n+    GetRandBytes(pcp_nonce);\n \n-static bool NatpmpDiscover(natpmp_t* natpmp, struct in_addr& external_ipv4_addr)\n-{\n-    const int r_send = sendpublicaddressrequest(natpmp);\n-    if (r_send == 2 /* OK */) {\n-        int r_read;\n-        natpmpresp_t response;\n-        do {\n-            r_read = readnatpmpresponseorretry(natpmp, &response);\n-        } while (r_read == NATPMP_TRYAGAIN);\n-\n-        if (r_read == 0) {\n-            external_ipv4_addr = response.pnu.publicaddress.addr;\n-            return true;\n-        } else if (r_read == NATPMP_ERR_NOGATEWAYSUPPORT) {\n-            LogPrintf(\"natpmp: The gateway does not support NAT-PMP.\\n\");\n+    bool ret = false;\n+    bool no_resources = false;\n+    const uint16_t private_port = GetListenPort();\n+    // Multiply the reannounce period by two, as we'll try to renew approximately halfway.\n+    const uint32_t requested_lifetime = std::chrono::seconds(PORT_MAPPING_REANNOUNCE_PERIOD * 2).count();\n+    uint32_t actual_lifetime = 0;\n+    std::chrono::milliseconds sleep_time;\n+\n+    // Local functor to handle result from PCP/NATPMP mapping.\n+    auto handle_mapping = [&](std::variant<MappingResult, MappingError> &res) -> void {\n+        if (MappingResult* mapping = std::get_if<MappingResult>(&res)) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Info, \"portmap: Added mapping %s\\n\", mapping->ToString());\n+            AddLocal(mapping->external, LOCAL_MAPPED);\n+            ret = true;\n+            actual_lifetime = std::min(actual_lifetime, mapping->lifetime);\n+        } else if (MappingError *err = std::get_if<MappingError>(&res)) {\n+            // Detailed error will already have been logged internally in respective Portmap function.\n+            if (*err == MappingError::NO_RESOURCES) {\n+                no_resources = true;\n+            }\n+        }\n+    };\n+\n+    do {\n+        actual_lifetime = requested_lifetime;\n+        no_resources = false; // Set to true if there was any \"no resources\" error.\n+        ret = false; // Set to true if any mapping succeeds.\n+\n+        // IPv4\n+        std::optional<CNetAddr> gateway4 = QueryDefaultGateway(NET_IPV4);\n+        if (!gateway4) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: Could not determine IPv4 default gateway\\n\");\n         } else {\n-            LogPrintf(\"natpmp: readnatpmpresponseorretry() for public address failed with %d error.\\n\", r_read);\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: gateway [IPv4]: %s\\n\", gateway4->ToStringAddr());\n+\n+            // Open a port mapping on whatever local address we have toward the gateway.\n+            struct in_addr inaddr_any;\n+            inaddr_any.s_addr = htonl(INADDR_ANY);\n+            auto res = PCPRequestPortMap(pcp_nonce, *gateway4, CNetAddr(inaddr_any), private_port, requested_lifetime);\n+            MappingError* pcp_err = std::get_if<MappingError>(&res);\n+            if (pcp_err && *pcp_err == MappingError::UNSUPP_VERSION) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: Got unsupported PCP version response, falling back to NAT-PMP\\n\");\n+                res = NATPMPRequestPortMap(*gateway4, private_port, requested_lifetime);\n+            }\n+            handle_mapping(res);\n         }\n-    } else {\n-        LogPrintf(\"natpmp: sendpublicaddressrequest() failed with %d error.\\n\", r_send);\n-    }\n \n-    return false;\n-}\n+        // IPv6\n+        std::optional<CNetAddr> gateway6 = QueryDefaultGateway(NET_IPV6);\n+        if (!gateway6) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: Could not determine IPv6 default gateway\\n\");\n+        } else {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: gateway [IPv6]: %s\\n\", gateway6->ToStringAddr());\n \n-static bool NatpmpMapping(natpmp_t* natpmp, const struct in_addr& external_ipv4_addr, uint16_t private_port, bool& external_ip_discovered)\n-{\n-    const uint16_t suggested_external_port = g_mapport_external_port ? g_mapport_external_port : private_port;\n-    const int r_send = sendnewportmappingrequest(natpmp, NATPMP_PROTOCOL_TCP, private_port, suggested_external_port, 3600 /*seconds*/);\n-    if (r_send == 12 /* OK */) {\n-        int r_read;\n-        natpmpresp_t response;\n-        do {\n-            r_read = readnatpmpresponseorretry(natpmp, &response);\n-        } while (r_read == NATPMP_TRYAGAIN);\n-\n-        if (r_read == 0) {\n-            auto pm = response.pnu.newportmapping;\n-            if (private_port == pm.privateport && pm.lifetime > 0) {\n-                g_mapport_external_port = pm.mappedpublicport;\n-                const CService external{external_ipv4_addr, pm.mappedpublicport};\n-                if (!external_ip_discovered && fDiscover) {\n-                    AddLocal(external, LOCAL_MAPPED);\n-                    external_ip_discovered = true;\n-                }\n-                LogPrintf(\"natpmp: Port mapping successful. External address = %s\\n\", external.ToStringAddrPort());\n-                return true;\n-            } else {\n-                LogPrintf(\"natpmp: Port mapping failed.\\n\");\n+            // Try to open pinholes for all routable local IPv6 addresses.\n+            for (const auto &addr: GetLocalAddresses()) {\n+                if (!addr.IsRoutable() || !addr.IsIPv6()) continue;\n+                auto res = PCPRequestPortMap(pcp_nonce, *gateway6, addr, private_port, requested_lifetime);",
      "path": "src/mapport.cpp",
      "position": 146,
      "original_position": 146,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "23916f2a7717b463799207b4b81b5795f2e9d7e3",
      "in_reply_to_id": 1658879358,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": ">  Why make mappings for all local IPv6 addresses?\r\n\r\nIt's the sensible choice IMO. Some routers will assign a whole bunch of routable IPv6 addresses but only allow pinholing for some (eg not for temporary privacy addresses), without a way to distinguish them. It's doesn't hurt to try.\r\n\r\n> I think it is going to result in multiple mappings on the same external IPv6 address but on different ports.\r\n\r\ni don't think so? We only request one mapping per IPv6 address at most.\r\n\r\n> Also, it just occurred to me, GetLocalAddresses() operates regardless of -bind= option\r\n\r\n~~Yes. But mind that `-natpmp` and `-pnp` are set to 0 if  `-bind` is specified. In that case we assume the user has a more complex configuration and will just do their own mapping.~~\r\nWhoops this is not the case. Only for `-proxy` and `-listen=0`. Yes, makes sense to take explicit binds into account if specified.\r\n",
      "created_at": "2024-07-03T11:58:43Z",
      "updated_at": "2024-07-03T12:06:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1664074217",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1664074217"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": 106,
      "original_start_line": 106,
      "start_side": "RIGHT",
      "line": 109,
      "original_line": 109,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1664088207",
      "pull_request_review_id": 2156276555,
      "id": 1664088207,
      "node_id": "PRRC_kwDOABII585jL_iP",
      "diff_hunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/pcp.h>\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <span.h>\n+#include <util/check.h>\n+#include <util/netif.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+namespace {\n+\n+// RFC6886 NAT-PMP and RFC6887 Port Control Protocol (PCP) implementation.\n+// NAT-PMP and PCP use network byte order (big-endian).\n+\n+// NAT-PMP (v0) protocol constants.\n+//! NAT-PMP uses a fixed server port number (RFC6887 section 1.1).\n+constexpr uint16_t NATPMP_SERVER_PORT = 5351;\n+//! Version byte for NATPMP (RFC6886 1.1)\n+constexpr uint8_t NATPMP_VERSION = 0;\n+//! Request opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_REQUEST = 0x00;\n+//! Response opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_RESPONSE = 0x80;\n+//! Get external address (RFC6886 3.2)\n+constexpr uint8_t NATPMP_OP_GETEXTERNAL = 0x00;\n+//! Map TCP port (RFC6886 3.3)\n+constexpr uint8_t NATPMP_OP_MAP_TCP = 0x02;\n+//! Shared request header size in bytes.\n+constexpr size_t NATPMP_REQUEST_HDR_SIZE = 2;\n+//! Shared response header (minimum) size in bytes.\n+constexpr size_t NATPMP_RESPONSE_HDR_SIZE = 8;\n+//! GETEXTERNAL request size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 0;\n+//! GETEXTERNAL response size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 4;\n+//! MAP request size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 10;\n+//! MAP response size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 8;\n+\n+// Shared header offsets (RFC6886 3.2, 3.3), relative to start of packet.\n+//!  Offset of version field in packets.\n+constexpr size_t NATPMP_HDR_VERSION_OFS = 0;\n+//!  Offset of opcode field in packets\n+constexpr size_t NATPMP_HDR_OP_OFS = 1;\n+//!  Offset of result code in packets. Result codes are 16 bit in NAT-PMP instead of 8 bit in PCP.\n+constexpr size_t NATPMP_RESPONSE_HDR_RESULT_OFS = 2;\n+\n+// GETEXTERNAL response offsets (RFC6886 3.2), relative to start of packet.\n+//!  Returned external address\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_IP_OFS = 8;\n+\n+// MAP request offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port to be mapped.\n+constexpr size_t NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS = 4;\n+//!  Suggested external port for mapping.\n+constexpr size_t NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS = 6;\n+//!  Requested port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_REQUEST_LIFETIME_OFS = 8;\n+\n+// MAP response offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port for mapping (will match internal port of request).\n+constexpr size_t NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS = 8;\n+//!  External port for mapping.\n+constexpr size_t NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS = 10;\n+//!  Created port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_RESPONSE_LIFETIME_OFS = 12;\n+\n+// Relevant NETPMP result codes (RFC6886 3.5).\n+//! Result code representing success status.\n+constexpr uint8_t NATPMP_RESULT_SUCCESS = 0;\n+//! Result code representing unsupported version.\n+constexpr uint8_t NATPMP_RESULT_UNSUPP_VERSION = 1;\n+//! Result code representing lack of resources.\n+constexpr uint8_t NATPMP_RESULT_NO_RESOURCES = 4;\n+\n+//! Mapping of NATPMP result code to string (RFC6886 3.5). Result codes <=2 match PCP.\n+const std::map<uint8_t, std::string> NATPMP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"NETWORK_FAILURE\"},\n+    {4,  \"NO_RESOURCES\"},\n+    {5,  \"UNSUPP_OPCODE\"},\n+};\n+\n+// PCP (v2) protocol constants.\n+//! Maximum packet size in bytes (RFC6887 section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (RFC6887 section 19.1). Shared with NAT-PMP.\n+constexpr uint16_t PCP_SERVER_PORT = NATPMP_SERVER_PORT;\n+//! Version byte. 0 is NAT-PMP (RFC6886), 1 is forbidden, 2 for PCP (RFC6887).\n+constexpr uint8_t PCP_VERSION = 2;\n+//! PCP Request Header. See RFC6887 section 7.1. Shared with NAT-PMP.\n+constexpr uint8_t PCP_REQUEST = NATPMP_REQUEST; // R = 0\n+//! PCP Response Header. See RFC6887 section 7.2. Shared with NAT-PMP.\n+constexpr uint8_t PCP_RESPONSE = NATPMP_RESPONSE; // R = 1\n+//! Map opcode. See RFC6887 section 19.2\n+constexpr uint8_t PCP_OP_MAP = 0x01;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Request and response header size in bytes (RFC6887 section 7.1).\n+constexpr size_t PCP_HDR_SIZE = 24;\n+//! Map request and response size in bytes (RFC6887 section 11.1).\n+constexpr size_t PCP_MAP_SIZE = 36;\n+\n+// Header offsets shared between request and responses (RFC6887 7.1, 7.2), relative to start of packet.\n+//!  Version field (1 byte).\n+constexpr size_t PCP_HDR_VERSION_OFS = NATPMP_HDR_VERSION_OFS;\n+//!  Opcode field (1 byte).\n+constexpr size_t PCP_HDR_OP_OFS = NATPMP_HDR_OP_OFS;\n+//!  Requested lifetime (request), granted lifetime (response) (2 bytes).\n+constexpr size_t PCP_HDR_LIFETIME_OFS = 4;\n+\n+// Request header offsets (RFC6887 7.1), relative to start of packet.\n+//!  PCP client's IP address (16 bytes).\n+constexpr size_t PCP_REQUEST_HDR_IP_OFS = 8;\n+\n+// Response header offsets (RFC6887 7.2), relative to start of packet.\n+//!  Result code (1 byte).\n+constexpr size_t PCP_RESPONSE_HDR_RESULT_OFS = 3;\n+\n+// MAP request/response offsets (RFC6887 11.1), relative to start of opcode-specific data.\n+//!  Mapping nonce (12 bytes).\n+constexpr size_t PCP_MAP_NONCE_OFS = 0;\n+//!  Protocol (1 byte).\n+constexpr size_t PCP_MAP_PROTOCOL_OFS = 12;\n+//!  Internal port for mapping (2 bytes).\n+constexpr size_t PCP_MAP_INTERNAL_PORT_OFS = 16;\n+//!  Suggested external port (request), assigned external port (response) (2 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_PORT_OFS = 18;\n+//!  Suggested external IP (request), assigned external IP (response) (16 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_IP_OFS = 20;\n+\n+//! Result code representing success (RFC6887 7.4), shared with NAT-PMP.\n+constexpr uint8_t PCP_RESULT_SUCCESS = NATPMP_RESULT_SUCCESS;\n+//! Result code representing lack of resources (RFC6887 7.4).\n+constexpr uint8_t PCP_RESULT_NO_RESOURCES = 8;\n+\n+//! Mapping of PCP result code to string (RFC6887 7.4). Result codes <=2 match NAT-PMP.\n+const std::map<uint8_t, std::string> PCP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"MALFORMED_REQUEST\"},\n+    {4,  \"UNSUPP_OPCODE\"},\n+    {5,  \"UNSUPP_OPTION\"},\n+    {6,  \"MALFORMED_OPTION\"},\n+    {7,  \"NETWORK_FAILURE\"},\n+    {8,  \"NO_RESOURCES\"},\n+    {9,  \"UNSUPP_PROTOCOL\"},\n+    {10, \"USER_EX_QUOTA\"},\n+    {11, \"CANNOT_PROVIDE_EXTERNAL\"},\n+    {12, \"ADDRESS_MISMATCH\"},\n+    {13, \"EXCESSIVE_REMOTE_PEER\"},\n+};\n+\n+//! Return human-readable string from NATPMP result code.\n+std::string NATPMPResultString(uint8_t result_code)\n+{\n+    auto result_i = NATPMP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == NATPMP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Return human-readable string from PCP result code.\n+std::string PCPResultString(uint8_t result_code)\n+{\n+    auto result_i = PCP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == PCP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Wrap address in IPv6 according to RFC6887. wrapped_addr needs to be able to store 16 bytes.\n+[[nodiscard]] bool PCPWrapAddress(Span<uint8_t> wrapped_addr, const CNetAddr &addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (addr.IsIPv4()) {\n+        struct in_addr addr4;\n+        if (!addr.GetInAddr(&addr4)) return false;\n+        // Section 5: \"When the address field holds an IPv4 address, an IPv4-mapped IPv6 address [RFC4291] is used (::ffff:0:0/96).\"\n+        std::memcpy(wrapped_addr.data(), IPV4_IN_IPV6_PREFIX.data(), IPV4_IN_IPV6_PREFIX.size());\n+        std::memcpy(wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), &addr4, ADDR_IPV4_SIZE);\n+        return true;\n+    } else if (addr.IsIPv6()) {\n+        struct in6_addr addr6;\n+        if (!addr.GetIn6Addr(&addr6)) return false;\n+        std::memcpy(wrapped_addr.data(), &addr6, ADDR_IPV6_SIZE);\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+//! Unwrap PCP-encoded address according to RFC6887.\n+CNetAddr PCPUnwrapAddress(Span<const uint8_t> wrapped_addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (util::HasPrefix(wrapped_addr, IPV4_IN_IPV6_PREFIX)) {\n+        struct in_addr addr4;\n+        std::memcpy(&addr4, wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), ADDR_IPV4_SIZE);\n+        return CNetAddr(addr4);\n+    } else {\n+        struct in6_addr addr6;\n+        std::memcpy(&addr6, wrapped_addr.data(), ADDR_IPV6_SIZE);\n+        return CNetAddr(addr6);\n+    }\n+}\n+\n+//! PCP or NAT-PMP send-receive loop.\n+std::optional<std::vector<uint8_t>> PCPSendRecv(Sock &sock, const std::string &protocol, Span<const uint8_t> request, int num_tries,\n+        std::chrono::milliseconds timeout_per_try,\n+        std::function<bool(Span<const uint8_t>)> check_packet)\n+{\n+    using namespace std::chrono;\n+    // UDP is a potentially lossy protocol, so we try to send again a few times.\n+    uint8_t response[PCP_MAX_SIZE];\n+    bool got_response = false;\n+    int recvsz = 0;\n+    for (int ntry = 0; !got_response && ntry < num_tries; ++ntry) {\n+        if (ntry > 0) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Retrying (%d)\\n\", protocol, ntry);\n+        }\n+        // Dispatch packet to gateway.\n+        if (sock.Send(request.data(), request.size(), 0) != static_cast<ssize_t>(request.size())) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not send request: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+            return std::nullopt; // Network-level error, probably no use retrying.\n+        }\n+\n+        // Wait for response(s) until we get a valid response, a network error, or time out.\n+        auto cur_time = time_point_cast<milliseconds>(steady_clock::now());\n+        auto deadline = cur_time + timeout_per_try;\n+        while ((cur_time = time_point_cast<milliseconds>(steady_clock::now())) < deadline) {\n+            Sock::Event occurred = 0;\n+            if (!sock.Wait(deadline - cur_time, Sock::RECV, &occurred)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not wait on socket: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            if (!occurred) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Timeout\\n\", protocol);\n+                break; // Retry.\n+            }\n+\n+            // Receive response.\n+            recvsz = sock.Recv(response, sizeof(response), MSG_DONTWAIT);\n+            if (recvsz < 0) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not receive response: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Received response of %d bytes: %s\\n\", protocol, recvsz, HexStr(Span(response, recvsz)));\n+\n+            if (check_packet(Span<uint8_t>(response, recvsz))) {\n+                got_response = true; // Got expected response, break from receive loop as well as from retry loop.\n+                break;\n+            }\n+        }\n+    }\n+    if (!got_response) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Giving up after %d tries\\n\", protocol, num_tries);\n+        return std::nullopt;\n+    }\n+    return std::vector<uint8_t>(response, response + recvsz);\n+}\n+\n+}\n+\n+std::variant<MappingResult, MappingError> NATPMPRequestPortMap(const CNetAddr &gateway, uint16_t port, uint32_t lifetime, int num_tries, std::chrono::milliseconds timeout_per_try)\n+{\n+    struct sockaddr_storage dest_addr;\n+    socklen_t dest_addrlen = sizeof(struct sockaddr_storage);\n+\n+    LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"natpmp: Requesting port mapping port %d from gateway %s\\n\", port, gateway.ToStringAddr());\n+\n+    // Validate gateway, make sure it's IPv4. NAT-PMP does not support IPv6.\n+    if (!CService(gateway, PCP_SERVER_PORT).GetSockAddr((struct sockaddr*)&dest_addr, &dest_addrlen)) return MappingError::NETWORK_ERROR;\n+    if (dest_addr.ss_family != AF_INET) return MappingError::NETWORK_ERROR;\n+\n+    // Create IPv4 UDP socket\n+    auto sock{CreateSock(AF_INET, SOCK_DGRAM, IPPROTO_UDP)};\n+    if (!sock) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Could not create UDP socket: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Associate UDP socket to gateway.\n+    if (sock->Connect((struct sockaddr*)&dest_addr, dest_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Could not connect to gateway: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Use getsockname to get the address toward the default gateway (the internal address).\n+    struct sockaddr_in internal;\n+    socklen_t internal_addrlen = sizeof(struct sockaddr_in);\n+    if (sock->GetSockName((struct sockaddr*)&internal, &internal_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Could not get sock name: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Request external IP address (RFC6886 section 3.2).\n+    std::vector<uint8_t> request(NATPMP_GETEXTERNAL_REQUEST_SIZE);\n+    request[NATPMP_HDR_VERSION_OFS] = NATPMP_VERSION;\n+    request[NATPMP_HDR_OP_OFS] = NATPMP_REQUEST | NATPMP_OP_GETEXTERNAL;\n+\n+    auto recv_res = PCPSendRecv(*sock, \"natpmp\", request, num_tries, timeout_per_try,\n+        [&](const Span<const uint8_t> response) -> bool {\n+            if (response.size() < NATPMP_GETEXTERNAL_RESPONSE_SIZE) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response too small\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            if (response[NATPMP_HDR_VERSION_OFS] != NATPMP_VERSION || response[NATPMP_HDR_OP_OFS] != (NATPMP_RESPONSE | NATPMP_OP_GETEXTERNAL)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response to wrong command\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            return true;\n+        });\n+\n+    struct in_addr external_addr;\n+    if (recv_res) {\n+        const std::span<const uint8_t> response = *recv_res;\n+\n+        Assume(response.size() >= NATPMP_GETEXTERNAL_RESPONSE_SIZE);\n+        uint16_t result_code = ReadBE16(response.data() + NATPMP_RESPONSE_HDR_RESULT_OFS);\n+        if (result_code != NATPMP_RESULT_SUCCESS) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Getting external address failed with result %s\\n\", NATPMPResultString(result_code));\n+            return MappingError::PROTOCOL_ERROR;\n+        }\n+\n+        std::memcpy(&external_addr, response.data() + NATPMP_GETEXTERNAL_RESPONSE_IP_OFS, ADDR_IPV4_SIZE);\n+    } else {\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Create TCP mapping request (RFC6886 section 3.3).\n+    request = std::vector<uint8_t>(NATPMP_MAP_REQUEST_SIZE);\n+    request[NATPMP_HDR_VERSION_OFS] = NATPMP_VERSION;\n+    request[NATPMP_HDR_OP_OFS] = NATPMP_REQUEST | NATPMP_OP_MAP_TCP;\n+    WriteBE16(request.data() + NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS, port);\n+    WriteBE16(request.data() + NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS, port);\n+    WriteBE32(request.data() + NATPMP_MAP_REQUEST_LIFETIME_OFS, lifetime);\n+\n+    recv_res = PCPSendRecv(*sock, \"natpmp\", request, num_tries, timeout_per_try,\n+        [&](const Span<const uint8_t> response) -> bool {\n+            if (response.size() < NATPMP_MAP_RESPONSE_SIZE) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response too small\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            if (response[0] != NATPMP_VERSION || response[1] != (NATPMP_RESPONSE | NATPMP_OP_MAP_TCP)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response to wrong command\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            uint16_t internal_port = ReadBE16(response.data() + NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS);\n+            if (internal_port != port) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response port doesn't match request\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            return true;\n+        });\n+\n+    if (recv_res) {\n+        const std::span<uint8_t> response = *recv_res;\n+\n+        Assume(response.size() >= NATPMP_MAP_RESPONSE_SIZE);\n+        uint16_t result_code = ReadBE16(response.data() + NATPMP_RESPONSE_HDR_RESULT_OFS);\n+        if (result_code != NATPMP_RESULT_SUCCESS) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Port mapping failed with result %s\\n\", NATPMPResultString(result_code));\n+            if (result_code == NATPMP_RESULT_NO_RESOURCES) {\n+                return MappingError::NO_RESOURCES;\n+            }\n+            return MappingError::PROTOCOL_ERROR;\n+        }\n+\n+        uint32_t lifetime_ret = ReadBE32(response.data() + NATPMP_MAP_RESPONSE_LIFETIME_OFS);\n+        uint16_t external_port = ReadBE16(response.data() + NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS);\n+        return MappingResult(NATPMP_VERSION, CService(internal.sin_addr, port), CService(external_addr, external_port), lifetime_ret);\n+    } else {\n+        return MappingError::NETWORK_ERROR;\n+    }\n+}\n+\n+std::variant<MappingResult, MappingError> PCPRequestPortMap(const PCPMappingNonce &nonce, const CNetAddr &gateway, const CNetAddr &bind, uint16_t port, uint32_t lifetime, int num_tries, std::chrono::milliseconds timeout_per_try)\n+{\n+    struct sockaddr_storage dest_addr, bind_addr;\n+    socklen_t dest_addrlen = sizeof(struct sockaddr_storage), bind_addrlen = sizeof(struct sockaddr_storage);\n+\n+    LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"pcp: Requesting port mapping for addr %s port %d from gateway %s\\n\", bind.ToStringAddr(), port, gateway.ToStringAddr());\n+\n+    // Validate addresses, make sure they're the same network family.\n+    if (!CService(gateway, PCP_SERVER_PORT).GetSockAddr((struct sockaddr*)&dest_addr, &dest_addrlen)) return MappingError::NETWORK_ERROR;\n+    if (!CService(bind, 0).GetSockAddr((struct sockaddr*)&bind_addr, &bind_addrlen)) return MappingError::NETWORK_ERROR;\n+    if (dest_addr.ss_family != bind_addr.ss_family) return MappingError::NETWORK_ERROR;\n+\n+    // Create UDP socket (IPv4 or IPv6 based on provided gateway).\n+    auto sock{CreateSock(dest_addr.ss_family, SOCK_DGRAM, IPPROTO_UDP)};\n+    if (!sock) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp: Could not create UDP socket: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Make sure that we send from requested destination address, anything else will be\n+    // rejected by a security-conscious router.\n+    if (sock->Bind((struct sockaddr*)&bind_addr, bind_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp: Could not bind to address: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Associate UDP socket to gateway.\n+    if (sock->Connect((struct sockaddr*)&dest_addr, dest_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp: Could not connect to gateway: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Use getsockname to get the address toward the default gateway (the internal address),\n+    // in case we don't know what address to map\n+    // (this is only needed if bind is INADDR_ANY, but it doesn't hurt as an extra check).\n+    struct sockaddr_storage internal_addr;\n+    socklen_t internal_addrlen = sizeof(struct sockaddr_storage);\n+    if (sock->GetSockName((struct sockaddr*)&internal_addr, &internal_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp: Could not get sock name: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+    CService internal;\n+    if (!internal.SetSockAddr((struct sockaddr*)&internal_addr)) return MappingError::NETWORK_ERROR;\n+    LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"pcp: Internal address after connect: %s\\n\", internal.ToStringAddr());\n+\n+    // Build request packet. Make sure the packet is zeroed so that reserved fields are zero\n+    // as required by the spec (and not potentially leak data).\n+    // Make sure there's space for the request header and MAP specific request data.\n+    std::vector<uint8_t> request(PCP_HDR_SIZE + PCP_MAP_SIZE);\n+    // Fill in request header, See RFC6887 Figure 2.\n+    size_t ofs = 0;\n+    request[ofs + PCP_HDR_VERSION_OFS] = PCP_VERSION;\n+    request[ofs + PCP_HDR_OP_OFS] = PCP_REQUEST | PCP_OP_MAP;\n+    WriteBE32(request.data() + ofs + PCP_HDR_LIFETIME_OFS, lifetime);\n+    if (!PCPWrapAddress(Span(request).subspan(ofs + PCP_REQUEST_HDR_IP_OFS, ADDR_IPV6_SIZE), internal)) return MappingError::NETWORK_ERROR;\n+\n+    ofs += PCP_HDR_SIZE;\n+\n+    // Fill in MAP request packet, See RFC6887 Figure 9.\n+    // Randomize mapping nonce (this is repeated in the response, to be able to\n+    // correlate requests and responses, and used to authenticate changes to the mapping).",
      "path": "src/util/pcp.cpp",
      "position": 447,
      "original_position": 447,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "23916f2a7717b463799207b4b81b5795f2e9d7e3",
      "in_reply_to_id": 1657447061,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Yes, i initially had the wrong idea of what it did, should update the comment.",
      "created_at": "2024-07-03T12:10:28Z",
      "updated_at": "2024-07-03T12:10:28Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1664088207",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1664088207"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": 446,
      "original_start_line": 446,
      "start_side": "RIGHT",
      "line": 447,
      "original_line": 447,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1664095090",
      "pull_request_review_id": 2156287791,
      "id": 1664095090,
      "node_id": "PRRC_kwDOABII585jMBNy",
      "diff_hunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/pcp.h>\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <span.h>\n+#include <util/check.h>\n+#include <util/netif.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+namespace {\n+\n+// RFC6886 NAT-PMP and RFC6887 Port Control Protocol (PCP) implementation.\n+// NAT-PMP and PCP use network byte order (big-endian).\n+\n+// NAT-PMP (v0) protocol constants.\n+//! NAT-PMP uses a fixed server port number (RFC6887 section 1.1).\n+constexpr uint16_t NATPMP_SERVER_PORT = 5351;\n+//! Version byte for NATPMP (RFC6886 1.1)\n+constexpr uint8_t NATPMP_VERSION = 0;\n+//! Request opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_REQUEST = 0x00;\n+//! Response opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_RESPONSE = 0x80;\n+//! Get external address (RFC6886 3.2)\n+constexpr uint8_t NATPMP_OP_GETEXTERNAL = 0x00;\n+//! Map TCP port (RFC6886 3.3)\n+constexpr uint8_t NATPMP_OP_MAP_TCP = 0x02;\n+//! Shared request header size in bytes.\n+constexpr size_t NATPMP_REQUEST_HDR_SIZE = 2;\n+//! Shared response header (minimum) size in bytes.\n+constexpr size_t NATPMP_RESPONSE_HDR_SIZE = 8;\n+//! GETEXTERNAL request size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 0;\n+//! GETEXTERNAL response size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 4;\n+//! MAP request size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 10;\n+//! MAP response size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 8;\n+\n+// Shared header offsets (RFC6886 3.2, 3.3), relative to start of packet.\n+//!  Offset of version field in packets.\n+constexpr size_t NATPMP_HDR_VERSION_OFS = 0;\n+//!  Offset of opcode field in packets\n+constexpr size_t NATPMP_HDR_OP_OFS = 1;\n+//!  Offset of result code in packets. Result codes are 16 bit in NAT-PMP instead of 8 bit in PCP.\n+constexpr size_t NATPMP_RESPONSE_HDR_RESULT_OFS = 2;\n+\n+// GETEXTERNAL response offsets (RFC6886 3.2), relative to start of packet.\n+//!  Returned external address\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_IP_OFS = 8;\n+\n+// MAP request offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port to be mapped.\n+constexpr size_t NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS = 4;\n+//!  Suggested external port for mapping.\n+constexpr size_t NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS = 6;\n+//!  Requested port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_REQUEST_LIFETIME_OFS = 8;\n+\n+// MAP response offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port for mapping (will match internal port of request).\n+constexpr size_t NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS = 8;\n+//!  External port for mapping.\n+constexpr size_t NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS = 10;\n+//!  Created port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_RESPONSE_LIFETIME_OFS = 12;\n+\n+// Relevant NETPMP result codes (RFC6886 3.5).\n+//! Result code representing success status.\n+constexpr uint8_t NATPMP_RESULT_SUCCESS = 0;\n+//! Result code representing unsupported version.\n+constexpr uint8_t NATPMP_RESULT_UNSUPP_VERSION = 1;\n+//! Result code representing lack of resources.\n+constexpr uint8_t NATPMP_RESULT_NO_RESOURCES = 4;\n+\n+//! Mapping of NATPMP result code to string (RFC6886 3.5). Result codes <=2 match PCP.\n+const std::map<uint8_t, std::string> NATPMP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"NETWORK_FAILURE\"},\n+    {4,  \"NO_RESOURCES\"},\n+    {5,  \"UNSUPP_OPCODE\"},\n+};\n+\n+// PCP (v2) protocol constants.\n+//! Maximum packet size in bytes (RFC6887 section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (RFC6887 section 19.1). Shared with NAT-PMP.\n+constexpr uint16_t PCP_SERVER_PORT = NATPMP_SERVER_PORT;\n+//! Version byte. 0 is NAT-PMP (RFC6886), 1 is forbidden, 2 for PCP (RFC6887).\n+constexpr uint8_t PCP_VERSION = 2;\n+//! PCP Request Header. See RFC6887 section 7.1. Shared with NAT-PMP.\n+constexpr uint8_t PCP_REQUEST = NATPMP_REQUEST; // R = 0\n+//! PCP Response Header. See RFC6887 section 7.2. Shared with NAT-PMP.\n+constexpr uint8_t PCP_RESPONSE = NATPMP_RESPONSE; // R = 1\n+//! Map opcode. See RFC6887 section 19.2\n+constexpr uint8_t PCP_OP_MAP = 0x01;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Request and response header size in bytes (RFC6887 section 7.1).\n+constexpr size_t PCP_HDR_SIZE = 24;\n+//! Map request and response size in bytes (RFC6887 section 11.1).\n+constexpr size_t PCP_MAP_SIZE = 36;\n+\n+// Header offsets shared between request and responses (RFC6887 7.1, 7.2), relative to start of packet.\n+//!  Version field (1 byte).\n+constexpr size_t PCP_HDR_VERSION_OFS = NATPMP_HDR_VERSION_OFS;\n+//!  Opcode field (1 byte).\n+constexpr size_t PCP_HDR_OP_OFS = NATPMP_HDR_OP_OFS;\n+//!  Requested lifetime (request), granted lifetime (response) (2 bytes).\n+constexpr size_t PCP_HDR_LIFETIME_OFS = 4;\n+\n+// Request header offsets (RFC6887 7.1), relative to start of packet.\n+//!  PCP client's IP address (16 bytes).\n+constexpr size_t PCP_REQUEST_HDR_IP_OFS = 8;\n+\n+// Response header offsets (RFC6887 7.2), relative to start of packet.\n+//!  Result code (1 byte).\n+constexpr size_t PCP_RESPONSE_HDR_RESULT_OFS = 3;\n+\n+// MAP request/response offsets (RFC6887 11.1), relative to start of opcode-specific data.\n+//!  Mapping nonce (12 bytes).\n+constexpr size_t PCP_MAP_NONCE_OFS = 0;\n+//!  Protocol (1 byte).\n+constexpr size_t PCP_MAP_PROTOCOL_OFS = 12;\n+//!  Internal port for mapping (2 bytes).\n+constexpr size_t PCP_MAP_INTERNAL_PORT_OFS = 16;\n+//!  Suggested external port (request), assigned external port (response) (2 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_PORT_OFS = 18;\n+//!  Suggested external IP (request), assigned external IP (response) (16 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_IP_OFS = 20;\n+\n+//! Result code representing success (RFC6887 7.4), shared with NAT-PMP.\n+constexpr uint8_t PCP_RESULT_SUCCESS = NATPMP_RESULT_SUCCESS;\n+//! Result code representing lack of resources (RFC6887 7.4).\n+constexpr uint8_t PCP_RESULT_NO_RESOURCES = 8;\n+\n+//! Mapping of PCP result code to string (RFC6887 7.4). Result codes <=2 match NAT-PMP.\n+const std::map<uint8_t, std::string> PCP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"MALFORMED_REQUEST\"},\n+    {4,  \"UNSUPP_OPCODE\"},\n+    {5,  \"UNSUPP_OPTION\"},\n+    {6,  \"MALFORMED_OPTION\"},\n+    {7,  \"NETWORK_FAILURE\"},\n+    {8,  \"NO_RESOURCES\"},\n+    {9,  \"UNSUPP_PROTOCOL\"},\n+    {10, \"USER_EX_QUOTA\"},\n+    {11, \"CANNOT_PROVIDE_EXTERNAL\"},\n+    {12, \"ADDRESS_MISMATCH\"},\n+    {13, \"EXCESSIVE_REMOTE_PEER\"},\n+};\n+\n+//! Return human-readable string from NATPMP result code.\n+std::string NATPMPResultString(uint8_t result_code)\n+{\n+    auto result_i = NATPMP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == NATPMP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Return human-readable string from PCP result code.\n+std::string PCPResultString(uint8_t result_code)\n+{\n+    auto result_i = PCP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == PCP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Wrap address in IPv6 according to RFC6887. wrapped_addr needs to be able to store 16 bytes.\n+[[nodiscard]] bool PCPWrapAddress(Span<uint8_t> wrapped_addr, const CNetAddr &addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (addr.IsIPv4()) {\n+        struct in_addr addr4;\n+        if (!addr.GetInAddr(&addr4)) return false;\n+        // Section 5: \"When the address field holds an IPv4 address, an IPv4-mapped IPv6 address [RFC4291] is used (::ffff:0:0/96).\"\n+        std::memcpy(wrapped_addr.data(), IPV4_IN_IPV6_PREFIX.data(), IPV4_IN_IPV6_PREFIX.size());\n+        std::memcpy(wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), &addr4, ADDR_IPV4_SIZE);\n+        return true;\n+    } else if (addr.IsIPv6()) {\n+        struct in6_addr addr6;\n+        if (!addr.GetIn6Addr(&addr6)) return false;\n+        std::memcpy(wrapped_addr.data(), &addr6, ADDR_IPV6_SIZE);\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+//! Unwrap PCP-encoded address according to RFC6887.\n+CNetAddr PCPUnwrapAddress(Span<const uint8_t> wrapped_addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (util::HasPrefix(wrapped_addr, IPV4_IN_IPV6_PREFIX)) {\n+        struct in_addr addr4;\n+        std::memcpy(&addr4, wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), ADDR_IPV4_SIZE);\n+        return CNetAddr(addr4);\n+    } else {\n+        struct in6_addr addr6;\n+        std::memcpy(&addr6, wrapped_addr.data(), ADDR_IPV6_SIZE);\n+        return CNetAddr(addr6);\n+    }\n+}\n+\n+//! PCP or NAT-PMP send-receive loop.\n+std::optional<std::vector<uint8_t>> PCPSendRecv(Sock &sock, const std::string &protocol, Span<const uint8_t> request, int num_tries,\n+        std::chrono::milliseconds timeout_per_try,\n+        std::function<bool(Span<const uint8_t>)> check_packet)\n+{\n+    using namespace std::chrono;\n+    // UDP is a potentially lossy protocol, so we try to send again a few times.\n+    uint8_t response[PCP_MAX_SIZE];\n+    bool got_response = false;\n+    int recvsz = 0;\n+    for (int ntry = 0; !got_response && ntry < num_tries; ++ntry) {\n+        if (ntry > 0) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Retrying (%d)\\n\", protocol, ntry);\n+        }\n+        // Dispatch packet to gateway.\n+        if (sock.Send(request.data(), request.size(), 0) != static_cast<ssize_t>(request.size())) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not send request: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+            return std::nullopt; // Network-level error, probably no use retrying.\n+        }\n+\n+        // Wait for response(s) until we get a valid response, a network error, or time out.\n+        auto cur_time = time_point_cast<milliseconds>(steady_clock::now());\n+        auto deadline = cur_time + timeout_per_try;\n+        while ((cur_time = time_point_cast<milliseconds>(steady_clock::now())) < deadline) {\n+            Sock::Event occurred = 0;\n+            if (!sock.Wait(deadline - cur_time, Sock::RECV, &occurred)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not wait on socket: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            if (!occurred) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Timeout\\n\", protocol);\n+                break; // Retry.\n+            }\n+\n+            // Receive response.\n+            recvsz = sock.Recv(response, sizeof(response), MSG_DONTWAIT);\n+            if (recvsz < 0) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not receive response: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Received response of %d bytes: %s\\n\", protocol, recvsz, HexStr(Span(response, recvsz)));\n+\n+            if (check_packet(Span<uint8_t>(response, recvsz))) {\n+                got_response = true; // Got expected response, break from receive loop as well as from retry loop.\n+                break;\n+            }\n+        }\n+    }\n+    if (!got_response) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Giving up after %d tries\\n\", protocol, num_tries);\n+        return std::nullopt;\n+    }\n+    return std::vector<uint8_t>(response, response + recvsz);\n+}\n+\n+}\n+\n+std::variant<MappingResult, MappingError> NATPMPRequestPortMap(const CNetAddr &gateway, uint16_t port, uint32_t lifetime, int num_tries, std::chrono::milliseconds timeout_per_try)\n+{\n+    struct sockaddr_storage dest_addr;\n+    socklen_t dest_addrlen = sizeof(struct sockaddr_storage);\n+\n+    LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"natpmp: Requesting port mapping port %d from gateway %s\\n\", port, gateway.ToStringAddr());\n+\n+    // Validate gateway, make sure it's IPv4. NAT-PMP does not support IPv6.\n+    if (!CService(gateway, PCP_SERVER_PORT).GetSockAddr((struct sockaddr*)&dest_addr, &dest_addrlen)) return MappingError::NETWORK_ERROR;\n+    if (dest_addr.ss_family != AF_INET) return MappingError::NETWORK_ERROR;\n+\n+    // Create IPv4 UDP socket\n+    auto sock{CreateSock(AF_INET, SOCK_DGRAM, IPPROTO_UDP)};\n+    if (!sock) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Could not create UDP socket: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Associate UDP socket to gateway.\n+    if (sock->Connect((struct sockaddr*)&dest_addr, dest_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Could not connect to gateway: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Use getsockname to get the address toward the default gateway (the internal address).\n+    struct sockaddr_in internal;\n+    socklen_t internal_addrlen = sizeof(struct sockaddr_in);\n+    if (sock->GetSockName((struct sockaddr*)&internal, &internal_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Could not get sock name: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Request external IP address (RFC6886 section 3.2).\n+    std::vector<uint8_t> request(NATPMP_GETEXTERNAL_REQUEST_SIZE);\n+    request[NATPMP_HDR_VERSION_OFS] = NATPMP_VERSION;\n+    request[NATPMP_HDR_OP_OFS] = NATPMP_REQUEST | NATPMP_OP_GETEXTERNAL;\n+\n+    auto recv_res = PCPSendRecv(*sock, \"natpmp\", request, num_tries, timeout_per_try,\n+        [&](const Span<const uint8_t> response) -> bool {\n+            if (response.size() < NATPMP_GETEXTERNAL_RESPONSE_SIZE) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response too small\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            if (response[NATPMP_HDR_VERSION_OFS] != NATPMP_VERSION || response[NATPMP_HDR_OP_OFS] != (NATPMP_RESPONSE | NATPMP_OP_GETEXTERNAL)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response to wrong command\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            return true;\n+        });\n+\n+    struct in_addr external_addr;\n+    if (recv_res) {\n+        const std::span<const uint8_t> response = *recv_res;\n+\n+        Assume(response.size() >= NATPMP_GETEXTERNAL_RESPONSE_SIZE);\n+        uint16_t result_code = ReadBE16(response.data() + NATPMP_RESPONSE_HDR_RESULT_OFS);\n+        if (result_code != NATPMP_RESULT_SUCCESS) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Getting external address failed with result %s\\n\", NATPMPResultString(result_code));\n+            return MappingError::PROTOCOL_ERROR;\n+        }\n+\n+        std::memcpy(&external_addr, response.data() + NATPMP_GETEXTERNAL_RESPONSE_IP_OFS, ADDR_IPV4_SIZE);\n+    } else {\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Create TCP mapping request (RFC6886 section 3.3).\n+    request = std::vector<uint8_t>(NATPMP_MAP_REQUEST_SIZE);\n+    request[NATPMP_HDR_VERSION_OFS] = NATPMP_VERSION;\n+    request[NATPMP_HDR_OP_OFS] = NATPMP_REQUEST | NATPMP_OP_MAP_TCP;\n+    WriteBE16(request.data() + NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS, port);\n+    WriteBE16(request.data() + NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS, port);\n+    WriteBE32(request.data() + NATPMP_MAP_REQUEST_LIFETIME_OFS, lifetime);\n+\n+    recv_res = PCPSendRecv(*sock, \"natpmp\", request, num_tries, timeout_per_try,\n+        [&](const Span<const uint8_t> response) -> bool {\n+            if (response.size() < NATPMP_MAP_RESPONSE_SIZE) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response too small\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            if (response[0] != NATPMP_VERSION || response[1] != (NATPMP_RESPONSE | NATPMP_OP_MAP_TCP)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response to wrong command\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            uint16_t internal_port = ReadBE16(response.data() + NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS);\n+            if (internal_port != port) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response port doesn't match request\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            return true;\n+        });\n+\n+    if (recv_res) {\n+        const std::span<uint8_t> response = *recv_res;\n+\n+        Assume(response.size() >= NATPMP_MAP_RESPONSE_SIZE);\n+        uint16_t result_code = ReadBE16(response.data() + NATPMP_RESPONSE_HDR_RESULT_OFS);\n+        if (result_code != NATPMP_RESULT_SUCCESS) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Port mapping failed with result %s\\n\", NATPMPResultString(result_code));\n+            if (result_code == NATPMP_RESULT_NO_RESOURCES) {\n+                return MappingError::NO_RESOURCES;\n+            }\n+            return MappingError::PROTOCOL_ERROR;\n+        }\n+\n+        uint32_t lifetime_ret = ReadBE32(response.data() + NATPMP_MAP_RESPONSE_LIFETIME_OFS);\n+        uint16_t external_port = ReadBE16(response.data() + NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS);\n+        return MappingResult(NATPMP_VERSION, CService(internal.sin_addr, port), CService(external_addr, external_port), lifetime_ret);\n+    } else {\n+        return MappingError::NETWORK_ERROR;\n+    }\n+}\n+\n+std::variant<MappingResult, MappingError> PCPRequestPortMap(const PCPMappingNonce &nonce, const CNetAddr &gateway, const CNetAddr &bind, uint16_t port, uint32_t lifetime, int num_tries, std::chrono::milliseconds timeout_per_try)\n+{\n+    struct sockaddr_storage dest_addr, bind_addr;\n+    socklen_t dest_addrlen = sizeof(struct sockaddr_storage), bind_addrlen = sizeof(struct sockaddr_storage);\n+\n+    LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"pcp: Requesting port mapping for addr %s port %d from gateway %s\\n\", bind.ToStringAddr(), port, gateway.ToStringAddr());\n+\n+    // Validate addresses, make sure they're the same network family.\n+    if (!CService(gateway, PCP_SERVER_PORT).GetSockAddr((struct sockaddr*)&dest_addr, &dest_addrlen)) return MappingError::NETWORK_ERROR;\n+    if (!CService(bind, 0).GetSockAddr((struct sockaddr*)&bind_addr, &bind_addrlen)) return MappingError::NETWORK_ERROR;\n+    if (dest_addr.ss_family != bind_addr.ss_family) return MappingError::NETWORK_ERROR;\n+\n+    // Create UDP socket (IPv4 or IPv6 based on provided gateway).\n+    auto sock{CreateSock(dest_addr.ss_family, SOCK_DGRAM, IPPROTO_UDP)};\n+    if (!sock) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp: Could not create UDP socket: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Make sure that we send from requested destination address, anything else will be\n+    // rejected by a security-conscious router.\n+    if (sock->Bind((struct sockaddr*)&bind_addr, bind_addrlen) != 0) {",
      "path": "src/util/pcp.cpp",
      "position": 408,
      "original_position": 408,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "23916f2a7717b463799207b4b81b5795f2e9d7e3",
      "in_reply_to_id": 1657164986,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "NATPMP is IPv4 only. In the case of IPv4 we don't need to explicitly bind. We don't do this for PCP either (hence passing the BIND_ANY address to bind, effectively a NO-OP). For IPv6 we know what internal address we want, and what external address we want so it's different.\r\n\r\n(FWIW, this kind of confusion is exactly why i was hestitant to also implement this for IPv4 in the beginning, NAT and pinholing are basically two wildly different cases, which happen to share code)",
      "created_at": "2024-07-03T12:16:00Z",
      "updated_at": "2024-07-03T12:19:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1664095090",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1664095090"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": 406,
      "original_start_line": 406,
      "start_side": "RIGHT",
      "line": 408,
      "original_line": 408,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1668158370",
      "pull_request_review_id": 2162545915,
      "id": 1668158370,
      "node_id": "PRRC_kwDOABII585jbhOi",
      "diff_hunk": "@@ -46,104 +43,96 @@ using namespace std::chrono_literals;\n static constexpr auto PORT_MAPPING_REANNOUNCE_PERIOD{20min};\n static constexpr auto PORT_MAPPING_RETRY_PERIOD{5min};\n \n-#ifdef USE_NATPMP\n-static uint16_t g_mapport_external_port = 0;\n-static bool NatpmpInit(natpmp_t* natpmp)\n+static bool ProcessPCP()\n {\n-    const int r_init = initnatpmp(natpmp, /* detect gateway automatically */ 0, /* forced gateway - NOT APPLIED*/ 0);\n-    if (r_init == 0) return true;\n-    LogPrintf(\"natpmp: initnatpmp() failed with %d error.\\n\", r_init);\n-    return false;\n-}\n+    // The same nonce is used for all mappings, this is allowed by the spec, and simplifies keeping track of them.\n+    PCPMappingNonce pcp_nonce;\n+    GetRandBytes(pcp_nonce);\n \n-static bool NatpmpDiscover(natpmp_t* natpmp, struct in_addr& external_ipv4_addr)\n-{\n-    const int r_send = sendpublicaddressrequest(natpmp);\n-    if (r_send == 2 /* OK */) {\n-        int r_read;\n-        natpmpresp_t response;\n-        do {\n-            r_read = readnatpmpresponseorretry(natpmp, &response);\n-        } while (r_read == NATPMP_TRYAGAIN);\n-\n-        if (r_read == 0) {\n-            external_ipv4_addr = response.pnu.publicaddress.addr;\n-            return true;\n-        } else if (r_read == NATPMP_ERR_NOGATEWAYSUPPORT) {\n-            LogPrintf(\"natpmp: The gateway does not support NAT-PMP.\\n\");\n+    bool ret = false;\n+    bool no_resources = false;\n+    const uint16_t private_port = GetListenPort();\n+    // Multiply the reannounce period by two, as we'll try to renew approximately halfway.\n+    const uint32_t requested_lifetime = std::chrono::seconds(PORT_MAPPING_REANNOUNCE_PERIOD * 2).count();\n+    uint32_t actual_lifetime = 0;\n+    std::chrono::milliseconds sleep_time;\n+\n+    // Local functor to handle result from PCP/NATPMP mapping.\n+    auto handle_mapping = [&](std::variant<MappingResult, MappingError> &res) -> void {\n+        if (MappingResult* mapping = std::get_if<MappingResult>(&res)) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Info, \"portmap: Added mapping %s\\n\", mapping->ToString());\n+            AddLocal(mapping->external, LOCAL_MAPPED);\n+            ret = true;\n+            actual_lifetime = std::min(actual_lifetime, mapping->lifetime);\n+        } else if (MappingError *err = std::get_if<MappingError>(&res)) {\n+            // Detailed error will already have been logged internally in respective Portmap function.\n+            if (*err == MappingError::NO_RESOURCES) {\n+                no_resources = true;\n+            }\n+        }\n+    };\n+\n+    do {\n+        actual_lifetime = requested_lifetime;\n+        no_resources = false; // Set to true if there was any \"no resources\" error.\n+        ret = false; // Set to true if any mapping succeeds.\n+\n+        // IPv4\n+        std::optional<CNetAddr> gateway4 = QueryDefaultGateway(NET_IPV4);\n+        if (!gateway4) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: Could not determine IPv4 default gateway\\n\");\n         } else {\n-            LogPrintf(\"natpmp: readnatpmpresponseorretry() for public address failed with %d error.\\n\", r_read);\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: gateway [IPv4]: %s\\n\", gateway4->ToStringAddr());\n+\n+            // Open a port mapping on whatever local address we have toward the gateway.\n+            struct in_addr inaddr_any;\n+            inaddr_any.s_addr = htonl(INADDR_ANY);\n+            auto res = PCPRequestPortMap(pcp_nonce, *gateway4, CNetAddr(inaddr_any), private_port, requested_lifetime);\n+            MappingError* pcp_err = std::get_if<MappingError>(&res);\n+            if (pcp_err && *pcp_err == MappingError::UNSUPP_VERSION) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: Got unsupported PCP version response, falling back to NAT-PMP\\n\");\n+                res = NATPMPRequestPortMap(*gateway4, private_port, requested_lifetime);\n+            }\n+            handle_mapping(res);\n         }\n-    } else {\n-        LogPrintf(\"natpmp: sendpublicaddressrequest() failed with %d error.\\n\", r_send);\n-    }\n \n-    return false;\n-}\n+        // IPv6\n+        std::optional<CNetAddr> gateway6 = QueryDefaultGateway(NET_IPV6);\n+        if (!gateway6) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: Could not determine IPv6 default gateway\\n\");\n+        } else {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: gateway [IPv6]: %s\\n\", gateway6->ToStringAddr());\n \n-static bool NatpmpMapping(natpmp_t* natpmp, const struct in_addr& external_ipv4_addr, uint16_t private_port, bool& external_ip_discovered)\n-{\n-    const uint16_t suggested_external_port = g_mapport_external_port ? g_mapport_external_port : private_port;\n-    const int r_send = sendnewportmappingrequest(natpmp, NATPMP_PROTOCOL_TCP, private_port, suggested_external_port, 3600 /*seconds*/);\n-    if (r_send == 12 /* OK */) {\n-        int r_read;\n-        natpmpresp_t response;\n-        do {\n-            r_read = readnatpmpresponseorretry(natpmp, &response);\n-        } while (r_read == NATPMP_TRYAGAIN);\n-\n-        if (r_read == 0) {\n-            auto pm = response.pnu.newportmapping;\n-            if (private_port == pm.privateport && pm.lifetime > 0) {\n-                g_mapport_external_port = pm.mappedpublicport;\n-                const CService external{external_ipv4_addr, pm.mappedpublicport};\n-                if (!external_ip_discovered && fDiscover) {\n-                    AddLocal(external, LOCAL_MAPPED);\n-                    external_ip_discovered = true;\n-                }\n-                LogPrintf(\"natpmp: Port mapping successful. External address = %s\\n\", external.ToStringAddrPort());\n-                return true;\n-            } else {\n-                LogPrintf(\"natpmp: Port mapping failed.\\n\");\n+            // Try to open pinholes for all routable local IPv6 addresses.\n+            for (const auto &addr: GetLocalAddresses()) {\n+                if (!addr.IsRoutable() || !addr.IsIPv6()) continue;\n+                auto res = PCPRequestPortMap(pcp_nonce, *gateway6, addr, private_port, requested_lifetime);",
      "path": "src/mapport.cpp",
      "position": 146,
      "original_position": 146,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "23916f2a7717b463799207b4b81b5795f2e9d7e3",
      "in_reply_to_id": 1658879358,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": ">> I think it is going to result in multiple mappings on the same external IPv6 address but on different ports.\r\n\r\n> i don't think so? We only request one mapping per IPv6 address at most.\r\n\r\nAfaik PCP always uses a pinhole, which does not involve assigning a (different) port.\r\n\r\nWe do end up with our node being announced multiple times with different IP addresses, which could cause some other node to connect to us twice. That can already happen when you have IPv4 and IPv6 (and Tor and I2P) enabled.\r\n\r\nIf we're really worried about this, it might make sense to try each IPv6 address sequentially and stop when one is acknowledged. I think that can wait for a followup.",
      "created_at": "2024-07-08T07:54:51Z",
      "updated_at": "2024-07-08T07:55:24Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1668158370",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1668158370"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": 106,
      "original_start_line": 106,
      "start_side": "RIGHT",
      "line": 109,
      "original_line": 109,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1668161856",
      "pull_request_review_id": 2162551604,
      "id": 1668161856,
      "node_id": "PRRC_kwDOABII585jbiFA",
      "diff_hunk": "@@ -46,104 +43,96 @@ using namespace std::chrono_literals;\n static constexpr auto PORT_MAPPING_REANNOUNCE_PERIOD{20min};\n static constexpr auto PORT_MAPPING_RETRY_PERIOD{5min};\n \n-#ifdef USE_NATPMP\n-static uint16_t g_mapport_external_port = 0;\n-static bool NatpmpInit(natpmp_t* natpmp)\n+static bool ProcessPCP()\n {\n-    const int r_init = initnatpmp(natpmp, /* detect gateway automatically */ 0, /* forced gateway - NOT APPLIED*/ 0);\n-    if (r_init == 0) return true;\n-    LogPrintf(\"natpmp: initnatpmp() failed with %d error.\\n\", r_init);\n-    return false;\n-}\n+    // The same nonce is used for all mappings, this is allowed by the spec, and simplifies keeping track of them.\n+    PCPMappingNonce pcp_nonce;\n+    GetRandBytes(pcp_nonce);\n \n-static bool NatpmpDiscover(natpmp_t* natpmp, struct in_addr& external_ipv4_addr)\n-{\n-    const int r_send = sendpublicaddressrequest(natpmp);\n-    if (r_send == 2 /* OK */) {\n-        int r_read;\n-        natpmpresp_t response;\n-        do {\n-            r_read = readnatpmpresponseorretry(natpmp, &response);\n-        } while (r_read == NATPMP_TRYAGAIN);\n-\n-        if (r_read == 0) {\n-            external_ipv4_addr = response.pnu.publicaddress.addr;\n-            return true;\n-        } else if (r_read == NATPMP_ERR_NOGATEWAYSUPPORT) {\n-            LogPrintf(\"natpmp: The gateway does not support NAT-PMP.\\n\");\n+    bool ret = false;\n+    bool no_resources = false;\n+    const uint16_t private_port = GetListenPort();\n+    // Multiply the reannounce period by two, as we'll try to renew approximately halfway.\n+    const uint32_t requested_lifetime = std::chrono::seconds(PORT_MAPPING_REANNOUNCE_PERIOD * 2).count();\n+    uint32_t actual_lifetime = 0;\n+    std::chrono::milliseconds sleep_time;\n+\n+    // Local functor to handle result from PCP/NATPMP mapping.\n+    auto handle_mapping = [&](std::variant<MappingResult, MappingError> &res) -> void {\n+        if (MappingResult* mapping = std::get_if<MappingResult>(&res)) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Info, \"portmap: Added mapping %s\\n\", mapping->ToString());\n+            AddLocal(mapping->external, LOCAL_MAPPED);\n+            ret = true;\n+            actual_lifetime = std::min(actual_lifetime, mapping->lifetime);\n+        } else if (MappingError *err = std::get_if<MappingError>(&res)) {\n+            // Detailed error will already have been logged internally in respective Portmap function.\n+            if (*err == MappingError::NO_RESOURCES) {\n+                no_resources = true;\n+            }\n+        }\n+    };\n+\n+    do {\n+        actual_lifetime = requested_lifetime;\n+        no_resources = false; // Set to true if there was any \"no resources\" error.\n+        ret = false; // Set to true if any mapping succeeds.\n+\n+        // IPv4\n+        std::optional<CNetAddr> gateway4 = QueryDefaultGateway(NET_IPV4);\n+        if (!gateway4) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: Could not determine IPv4 default gateway\\n\");\n         } else {\n-            LogPrintf(\"natpmp: readnatpmpresponseorretry() for public address failed with %d error.\\n\", r_read);\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: gateway [IPv4]: %s\\n\", gateway4->ToStringAddr());\n+\n+            // Open a port mapping on whatever local address we have toward the gateway.\n+            struct in_addr inaddr_any;\n+            inaddr_any.s_addr = htonl(INADDR_ANY);\n+            auto res = PCPRequestPortMap(pcp_nonce, *gateway4, CNetAddr(inaddr_any), private_port, requested_lifetime);",
      "path": "src/mapport.cpp",
      "position": 98,
      "original_position": 98,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "23916f2a7717b463799207b4b81b5795f2e9d7e3",
      "in_reply_to_id": 1658779455,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Indeed. Maybe just add a comment that this is intentional.",
      "created_at": "2024-07-08T07:57:35Z",
      "updated_at": "2024-07-08T07:57:36Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1668161856",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1668161856"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 90,
      "original_line": 90,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1668367047",
      "pull_request_review_id": 2162874052,
      "id": 1668367047,
      "node_id": "PRRC_kwDOABII585jcULH",
      "diff_hunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/pcp.h>\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <span.h>\n+#include <util/check.h>\n+#include <util/netif.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+namespace {\n+\n+// RFC6886 NAT-PMP and RFC6887 Port Control Protocol (PCP) implementation.\n+// NAT-PMP and PCP use network byte order (big-endian).\n+\n+// NAT-PMP (v0) protocol constants.\n+//! NAT-PMP uses a fixed server port number (RFC6887 section 1.1).\n+constexpr uint16_t NATPMP_SERVER_PORT = 5351;\n+//! Version byte for NATPMP (RFC6886 1.1)\n+constexpr uint8_t NATPMP_VERSION = 0;\n+//! Request opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_REQUEST = 0x00;\n+//! Response opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_RESPONSE = 0x80;\n+//! Get external address (RFC6886 3.2)\n+constexpr uint8_t NATPMP_OP_GETEXTERNAL = 0x00;\n+//! Map TCP port (RFC6886 3.3)\n+constexpr uint8_t NATPMP_OP_MAP_TCP = 0x02;\n+//! Shared request header size in bytes.\n+constexpr size_t NATPMP_REQUEST_HDR_SIZE = 2;\n+//! Shared response header (minimum) size in bytes.\n+constexpr size_t NATPMP_RESPONSE_HDR_SIZE = 8;\n+//! GETEXTERNAL request size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 0;\n+//! GETEXTERNAL response size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 4;\n+//! MAP request size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 10;\n+//! MAP response size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 8;\n+\n+// Shared header offsets (RFC6886 3.2, 3.3), relative to start of packet.\n+//!  Offset of version field in packets.\n+constexpr size_t NATPMP_HDR_VERSION_OFS = 0;\n+//!  Offset of opcode field in packets\n+constexpr size_t NATPMP_HDR_OP_OFS = 1;\n+//!  Offset of result code in packets. Result codes are 16 bit in NAT-PMP instead of 8 bit in PCP.\n+constexpr size_t NATPMP_RESPONSE_HDR_RESULT_OFS = 2;\n+\n+// GETEXTERNAL response offsets (RFC6886 3.2), relative to start of packet.\n+//!  Returned external address\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_IP_OFS = 8;\n+\n+// MAP request offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port to be mapped.\n+constexpr size_t NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS = 4;\n+//!  Suggested external port for mapping.\n+constexpr size_t NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS = 6;\n+//!  Requested port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_REQUEST_LIFETIME_OFS = 8;\n+\n+// MAP response offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port for mapping (will match internal port of request).\n+constexpr size_t NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS = 8;\n+//!  External port for mapping.\n+constexpr size_t NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS = 10;\n+//!  Created port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_RESPONSE_LIFETIME_OFS = 12;\n+\n+// Relevant NETPMP result codes (RFC6886 3.5).\n+//! Result code representing success status.\n+constexpr uint8_t NATPMP_RESULT_SUCCESS = 0;\n+//! Result code representing unsupported version.\n+constexpr uint8_t NATPMP_RESULT_UNSUPP_VERSION = 1;\n+//! Result code representing lack of resources.\n+constexpr uint8_t NATPMP_RESULT_NO_RESOURCES = 4;\n+\n+//! Mapping of NATPMP result code to string (RFC6886 3.5). Result codes <=2 match PCP.\n+const std::map<uint8_t, std::string> NATPMP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"NETWORK_FAILURE\"},\n+    {4,  \"NO_RESOURCES\"},\n+    {5,  \"UNSUPP_OPCODE\"},\n+};\n+\n+// PCP (v2) protocol constants.\n+//! Maximum packet size in bytes (RFC6887 section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (RFC6887 section 19.1). Shared with NAT-PMP.\n+constexpr uint16_t PCP_SERVER_PORT = NATPMP_SERVER_PORT;\n+//! Version byte. 0 is NAT-PMP (RFC6886), 1 is forbidden, 2 for PCP (RFC6887).\n+constexpr uint8_t PCP_VERSION = 2;\n+//! PCP Request Header. See RFC6887 section 7.1. Shared with NAT-PMP.\n+constexpr uint8_t PCP_REQUEST = NATPMP_REQUEST; // R = 0\n+//! PCP Response Header. See RFC6887 section 7.2. Shared with NAT-PMP.\n+constexpr uint8_t PCP_RESPONSE = NATPMP_RESPONSE; // R = 1\n+//! Map opcode. See RFC6887 section 19.2\n+constexpr uint8_t PCP_OP_MAP = 0x01;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Request and response header size in bytes (RFC6887 section 7.1).\n+constexpr size_t PCP_HDR_SIZE = 24;\n+//! Map request and response size in bytes (RFC6887 section 11.1).\n+constexpr size_t PCP_MAP_SIZE = 36;\n+\n+// Header offsets shared between request and responses (RFC6887 7.1, 7.2), relative to start of packet.\n+//!  Version field (1 byte).\n+constexpr size_t PCP_HDR_VERSION_OFS = NATPMP_HDR_VERSION_OFS;\n+//!  Opcode field (1 byte).\n+constexpr size_t PCP_HDR_OP_OFS = NATPMP_HDR_OP_OFS;\n+//!  Requested lifetime (request), granted lifetime (response) (2 bytes).\n+constexpr size_t PCP_HDR_LIFETIME_OFS = 4;\n+\n+// Request header offsets (RFC6887 7.1), relative to start of packet.\n+//!  PCP client's IP address (16 bytes).\n+constexpr size_t PCP_REQUEST_HDR_IP_OFS = 8;\n+\n+// Response header offsets (RFC6887 7.2), relative to start of packet.\n+//!  Result code (1 byte).\n+constexpr size_t PCP_RESPONSE_HDR_RESULT_OFS = 3;\n+\n+// MAP request/response offsets (RFC6887 11.1), relative to start of opcode-specific data.\n+//!  Mapping nonce (12 bytes).\n+constexpr size_t PCP_MAP_NONCE_OFS = 0;\n+//!  Protocol (1 byte).\n+constexpr size_t PCP_MAP_PROTOCOL_OFS = 12;\n+//!  Internal port for mapping (2 bytes).\n+constexpr size_t PCP_MAP_INTERNAL_PORT_OFS = 16;\n+//!  Suggested external port (request), assigned external port (response) (2 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_PORT_OFS = 18;\n+//!  Suggested external IP (request), assigned external IP (response) (16 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_IP_OFS = 20;\n+\n+//! Result code representing success (RFC6887 7.4), shared with NAT-PMP.\n+constexpr uint8_t PCP_RESULT_SUCCESS = NATPMP_RESULT_SUCCESS;\n+//! Result code representing lack of resources (RFC6887 7.4).\n+constexpr uint8_t PCP_RESULT_NO_RESOURCES = 8;\n+\n+//! Mapping of PCP result code to string (RFC6887 7.4). Result codes <=2 match NAT-PMP.\n+const std::map<uint8_t, std::string> PCP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"MALFORMED_REQUEST\"},\n+    {4,  \"UNSUPP_OPCODE\"},\n+    {5,  \"UNSUPP_OPTION\"},\n+    {6,  \"MALFORMED_OPTION\"},\n+    {7,  \"NETWORK_FAILURE\"},\n+    {8,  \"NO_RESOURCES\"},\n+    {9,  \"UNSUPP_PROTOCOL\"},\n+    {10, \"USER_EX_QUOTA\"},\n+    {11, \"CANNOT_PROVIDE_EXTERNAL\"},\n+    {12, \"ADDRESS_MISMATCH\"},\n+    {13, \"EXCESSIVE_REMOTE_PEER\"},\n+};\n+\n+//! Return human-readable string from NATPMP result code.\n+std::string NATPMPResultString(uint8_t result_code)\n+{\n+    auto result_i = NATPMP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == NATPMP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Return human-readable string from PCP result code.\n+std::string PCPResultString(uint8_t result_code)\n+{\n+    auto result_i = PCP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == PCP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Wrap address in IPv6 according to RFC6887. wrapped_addr needs to be able to store 16 bytes.\n+[[nodiscard]] bool PCPWrapAddress(Span<uint8_t> wrapped_addr, const CNetAddr &addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (addr.IsIPv4()) {\n+        struct in_addr addr4;\n+        if (!addr.GetInAddr(&addr4)) return false;\n+        // Section 5: \"When the address field holds an IPv4 address, an IPv4-mapped IPv6 address [RFC4291] is used (::ffff:0:0/96).\"\n+        std::memcpy(wrapped_addr.data(), IPV4_IN_IPV6_PREFIX.data(), IPV4_IN_IPV6_PREFIX.size());\n+        std::memcpy(wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), &addr4, ADDR_IPV4_SIZE);\n+        return true;\n+    } else if (addr.IsIPv6()) {\n+        struct in6_addr addr6;\n+        if (!addr.GetIn6Addr(&addr6)) return false;\n+        std::memcpy(wrapped_addr.data(), &addr6, ADDR_IPV6_SIZE);\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+//! Unwrap PCP-encoded address according to RFC6887.\n+CNetAddr PCPUnwrapAddress(Span<const uint8_t> wrapped_addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (util::HasPrefix(wrapped_addr, IPV4_IN_IPV6_PREFIX)) {\n+        struct in_addr addr4;\n+        std::memcpy(&addr4, wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), ADDR_IPV4_SIZE);\n+        return CNetAddr(addr4);\n+    } else {\n+        struct in6_addr addr6;\n+        std::memcpy(&addr6, wrapped_addr.data(), ADDR_IPV6_SIZE);\n+        return CNetAddr(addr6);\n+    }\n+}\n+\n+//! PCP or NAT-PMP send-receive loop.\n+std::optional<std::vector<uint8_t>> PCPSendRecv(Sock &sock, const std::string &protocol, Span<const uint8_t> request, int num_tries,\n+        std::chrono::milliseconds timeout_per_try,\n+        std::function<bool(Span<const uint8_t>)> check_packet)\n+{\n+    using namespace std::chrono;\n+    // UDP is a potentially lossy protocol, so we try to send again a few times.\n+    uint8_t response[PCP_MAX_SIZE];\n+    bool got_response = false;\n+    int recvsz = 0;\n+    for (int ntry = 0; !got_response && ntry < num_tries; ++ntry) {\n+        if (ntry > 0) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Retrying (%d)\\n\", protocol, ntry);\n+        }\n+        // Dispatch packet to gateway.\n+        if (sock.Send(request.data(), request.size(), 0) != static_cast<ssize_t>(request.size())) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not send request: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+            return std::nullopt; // Network-level error, probably no use retrying.\n+        }\n+\n+        // Wait for response(s) until we get a valid response, a network error, or time out.\n+        auto cur_time = time_point_cast<milliseconds>(steady_clock::now());\n+        auto deadline = cur_time + timeout_per_try;\n+        while ((cur_time = time_point_cast<milliseconds>(steady_clock::now())) < deadline) {\n+            Sock::Event occurred = 0;\n+            if (!sock.Wait(deadline - cur_time, Sock::RECV, &occurred)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not wait on socket: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            if (!occurred) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Timeout\\n\", protocol);\n+                break; // Retry.\n+            }\n+\n+            // Receive response.\n+            recvsz = sock.Recv(response, sizeof(response), MSG_DONTWAIT);\n+            if (recvsz < 0) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not receive response: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Received response of %d bytes: %s\\n\", protocol, recvsz, HexStr(Span(response, recvsz)));\n+\n+            if (check_packet(Span<uint8_t>(response, recvsz))) {\n+                got_response = true; // Got expected response, break from receive loop as well as from retry loop.\n+                break;\n+            }\n+        }\n+    }\n+    if (!got_response) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Giving up after %d tries\\n\", protocol, num_tries);\n+        return std::nullopt;\n+    }\n+    return std::vector<uint8_t>(response, response + recvsz);\n+}\n+\n+}\n+\n+std::variant<MappingResult, MappingError> NATPMPRequestPortMap(const CNetAddr &gateway, uint16_t port, uint32_t lifetime, int num_tries, std::chrono::milliseconds timeout_per_try)\n+{\n+    struct sockaddr_storage dest_addr;\n+    socklen_t dest_addrlen = sizeof(struct sockaddr_storage);\n+\n+    LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"natpmp: Requesting port mapping port %d from gateway %s\\n\", port, gateway.ToStringAddr());\n+\n+    // Validate gateway, make sure it's IPv4. NAT-PMP does not support IPv6.\n+    if (!CService(gateway, PCP_SERVER_PORT).GetSockAddr((struct sockaddr*)&dest_addr, &dest_addrlen)) return MappingError::NETWORK_ERROR;\n+    if (dest_addr.ss_family != AF_INET) return MappingError::NETWORK_ERROR;\n+\n+    // Create IPv4 UDP socket\n+    auto sock{CreateSock(AF_INET, SOCK_DGRAM, IPPROTO_UDP)};\n+    if (!sock) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Could not create UDP socket: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Associate UDP socket to gateway.\n+    if (sock->Connect((struct sockaddr*)&dest_addr, dest_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Could not connect to gateway: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Use getsockname to get the address toward the default gateway (the internal address).\n+    struct sockaddr_in internal;\n+    socklen_t internal_addrlen = sizeof(struct sockaddr_in);\n+    if (sock->GetSockName((struct sockaddr*)&internal, &internal_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Could not get sock name: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Request external IP address (RFC6886 section 3.2).\n+    std::vector<uint8_t> request(NATPMP_GETEXTERNAL_REQUEST_SIZE);\n+    request[NATPMP_HDR_VERSION_OFS] = NATPMP_VERSION;\n+    request[NATPMP_HDR_OP_OFS] = NATPMP_REQUEST | NATPMP_OP_GETEXTERNAL;\n+\n+    auto recv_res = PCPSendRecv(*sock, \"natpmp\", request, num_tries, timeout_per_try,\n+        [&](const Span<const uint8_t> response) -> bool {\n+            if (response.size() < NATPMP_GETEXTERNAL_RESPONSE_SIZE) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response too small\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            if (response[NATPMP_HDR_VERSION_OFS] != NATPMP_VERSION || response[NATPMP_HDR_OP_OFS] != (NATPMP_RESPONSE | NATPMP_OP_GETEXTERNAL)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response to wrong command\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            return true;\n+        });\n+\n+    struct in_addr external_addr;\n+    if (recv_res) {\n+        const std::span<const uint8_t> response = *recv_res;\n+\n+        Assume(response.size() >= NATPMP_GETEXTERNAL_RESPONSE_SIZE);\n+        uint16_t result_code = ReadBE16(response.data() + NATPMP_RESPONSE_HDR_RESULT_OFS);\n+        if (result_code != NATPMP_RESULT_SUCCESS) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Getting external address failed with result %s\\n\", NATPMPResultString(result_code));\n+            return MappingError::PROTOCOL_ERROR;\n+        }\n+\n+        std::memcpy(&external_addr, response.data() + NATPMP_GETEXTERNAL_RESPONSE_IP_OFS, ADDR_IPV4_SIZE);\n+    } else {\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Create TCP mapping request (RFC6886 section 3.3).\n+    request = std::vector<uint8_t>(NATPMP_MAP_REQUEST_SIZE);\n+    request[NATPMP_HDR_VERSION_OFS] = NATPMP_VERSION;\n+    request[NATPMP_HDR_OP_OFS] = NATPMP_REQUEST | NATPMP_OP_MAP_TCP;\n+    WriteBE16(request.data() + NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS, port);\n+    WriteBE16(request.data() + NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS, port);\n+    WriteBE32(request.data() + NATPMP_MAP_REQUEST_LIFETIME_OFS, lifetime);\n+\n+    recv_res = PCPSendRecv(*sock, \"natpmp\", request, num_tries, timeout_per_try,\n+        [&](const Span<const uint8_t> response) -> bool {\n+            if (response.size() < NATPMP_MAP_RESPONSE_SIZE) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response too small\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            if (response[0] != NATPMP_VERSION || response[1] != (NATPMP_RESPONSE | NATPMP_OP_MAP_TCP)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response to wrong command\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            uint16_t internal_port = ReadBE16(response.data() + NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS);\n+            if (internal_port != port) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response port doesn't match request\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            return true;\n+        });\n+\n+    if (recv_res) {\n+        const std::span<uint8_t> response = *recv_res;\n+\n+        Assume(response.size() >= NATPMP_MAP_RESPONSE_SIZE);\n+        uint16_t result_code = ReadBE16(response.data() + NATPMP_RESPONSE_HDR_RESULT_OFS);\n+        if (result_code != NATPMP_RESULT_SUCCESS) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Port mapping failed with result %s\\n\", NATPMPResultString(result_code));\n+            if (result_code == NATPMP_RESULT_NO_RESOURCES) {\n+                return MappingError::NO_RESOURCES;\n+            }\n+            return MappingError::PROTOCOL_ERROR;\n+        }\n+\n+        uint32_t lifetime_ret = ReadBE32(response.data() + NATPMP_MAP_RESPONSE_LIFETIME_OFS);\n+        uint16_t external_port = ReadBE16(response.data() + NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS);\n+        return MappingResult(NATPMP_VERSION, CService(internal.sin_addr, port), CService(external_addr, external_port), lifetime_ret);\n+    } else {\n+        return MappingError::NETWORK_ERROR;\n+    }\n+}\n+\n+std::variant<MappingResult, MappingError> PCPRequestPortMap(const PCPMappingNonce &nonce, const CNetAddr &gateway, const CNetAddr &bind, uint16_t port, uint32_t lifetime, int num_tries, std::chrono::milliseconds timeout_per_try)\n+{\n+    struct sockaddr_storage dest_addr, bind_addr;\n+    socklen_t dest_addrlen = sizeof(struct sockaddr_storage), bind_addrlen = sizeof(struct sockaddr_storage);\n+\n+    LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"pcp: Requesting port mapping for addr %s port %d from gateway %s\\n\", bind.ToStringAddr(), port, gateway.ToStringAddr());\n+\n+    // Validate addresses, make sure they're the same network family.\n+    if (!CService(gateway, PCP_SERVER_PORT).GetSockAddr((struct sockaddr*)&dest_addr, &dest_addrlen)) return MappingError::NETWORK_ERROR;\n+    if (!CService(bind, 0).GetSockAddr((struct sockaddr*)&bind_addr, &bind_addrlen)) return MappingError::NETWORK_ERROR;\n+    if (dest_addr.ss_family != bind_addr.ss_family) return MappingError::NETWORK_ERROR;\n+\n+    // Create UDP socket (IPv4 or IPv6 based on provided gateway).\n+    auto sock{CreateSock(dest_addr.ss_family, SOCK_DGRAM, IPPROTO_UDP)};\n+    if (!sock) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp: Could not create UDP socket: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Make sure that we send from requested destination address, anything else will be\n+    // rejected by a security-conscious router.\n+    if (sock->Bind((struct sockaddr*)&bind_addr, bind_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp: Could not bind to address: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Associate UDP socket to gateway.\n+    if (sock->Connect((struct sockaddr*)&dest_addr, dest_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp: Could not connect to gateway: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Use getsockname to get the address toward the default gateway (the internal address),\n+    // in case we don't know what address to map\n+    // (this is only needed if bind is INADDR_ANY, but it doesn't hurt as an extra check).\n+    struct sockaddr_storage internal_addr;\n+    socklen_t internal_addrlen = sizeof(struct sockaddr_storage);\n+    if (sock->GetSockName((struct sockaddr*)&internal_addr, &internal_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp: Could not get sock name: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+    CService internal;\n+    if (!internal.SetSockAddr((struct sockaddr*)&internal_addr)) return MappingError::NETWORK_ERROR;\n+    LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"pcp: Internal address after connect: %s\\n\", internal.ToStringAddr());\n+\n+    // Build request packet. Make sure the packet is zeroed so that reserved fields are zero\n+    // as required by the spec (and not potentially leak data).\n+    // Make sure there's space for the request header and MAP specific request data.\n+    std::vector<uint8_t> request(PCP_HDR_SIZE + PCP_MAP_SIZE);\n+    // Fill in request header, See RFC6887 Figure 2.\n+    size_t ofs = 0;\n+    request[ofs + PCP_HDR_VERSION_OFS] = PCP_VERSION;\n+    request[ofs + PCP_HDR_OP_OFS] = PCP_REQUEST | PCP_OP_MAP;\n+    WriteBE32(request.data() + ofs + PCP_HDR_LIFETIME_OFS, lifetime);\n+    if (!PCPWrapAddress(Span(request).subspan(ofs + PCP_REQUEST_HDR_IP_OFS, ADDR_IPV6_SIZE), internal)) return MappingError::NETWORK_ERROR;\n+\n+    ofs += PCP_HDR_SIZE;\n+\n+    // Fill in MAP request packet, See RFC6887 Figure 9.\n+    // Randomize mapping nonce (this is repeated in the response, to be able to\n+    // correlate requests and responses, and used to authenticate changes to the mapping).",
      "path": "src/util/pcp.cpp",
      "position": 447,
      "original_position": 447,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "23916f2a7717b463799207b4b81b5795f2e9d7e3",
      "in_reply_to_id": 1657447061,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> some lame form of authentication\r\n\r\nhttps://github.com/miniupnp/miniupnp/issues/748 (I still need to test the fix PR)",
      "created_at": "2024-07-08T10:11:12Z",
      "updated_at": "2024-07-08T10:11:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1668367047",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1668367047"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": 446,
      "original_start_line": 446,
      "start_side": "RIGHT",
      "line": 447,
      "original_line": 447,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1668523385",
      "pull_request_review_id": 2163132612,
      "id": 1668523385,
      "node_id": "PRRC_kwDOABII585jc6V5",
      "diff_hunk": "@@ -0,0 +1,299 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <osreldate.h>\n+#if __FreeBSD_version >= 1400000\n+// Workaround https://github.com/freebsd/freebsd-src/pull/1070.\n+#define typeof __typeof\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+#elif defined(WIN32)\n+#include <iphlpapi.h>\n+#elif defined(__APPLE__)\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+#endif\n+\n+namespace {\n+\n+// Linux and FreeBSD 14.0+. For FreeBSD 13.2 the code can be compiled but\n+// running it requires loading a special kernel module, otherwise socket(AF_NETLINK,...)\n+// will fail, so we skip that.\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1400000)\n+\n+std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    auto sock{CreateSock(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (!sock) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.dst_data.\n+    const size_t dst_data_len = family == AF_INET ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    // Linux IPv4 / IPv6 - this must be present, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = family;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    // Linux IPv4 / IPv6 this must be absent, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock->Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    int64_t recv_result;\n+    do {\n+        recv_result = sock->Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, recv_result); hdr = NLMSG_NEXT(hdr, recv_result)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF && sizeof(int) == RTA_PAYLOAD(attr)) {\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (family == AF_INET && sizeof(in_addr) == RTA_PAYLOAD(rta_gateway)) {\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (family == AF_INET6 && sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway)) {\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    destination_address.si_family = family;\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    Assume(best_route.NextHop.si_family == family);\n+    if (family == AF_INET) {\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(family == AF_INET6) {\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Check valid length. Note that sa_len is not part of POSIX, and exists on MacOS and some BSDs only, so we can't\n+    // do this check in SetSockAddr.\n+    if (!(addr->sa_family == AF_INET && addr->sa_len == sizeof(struct sockaddr_in)) &&\n+        !(addr->sa_family == AF_INET6 && addr->sa_len == sizeof(struct sockaddr_in6))) {\n+        return std::nullopt;\n+    }\n+\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+//! MacOS: Get default gateway from route table. See route(4) for the format.\n+std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // net.route.0.inet[6].flags.gateway\n+    int mib[] = {CTL_NET, PF_ROUTE, 0, family, NET_RT_FLAGS, RTF_GATEWAY};\n+    // The size of the available data is determined by calling sysctl() with oldp=nullptr. See sysctl(3).\n+    size_t l = 0;\n+    if (sysctl(/*name=*/mib, /*namelen=*/sizeof(mib) / sizeof(int), /*oldp=*/nullptr, /*oldlenp=*/&l, /*newp=*/nullptr, /*newlen=*/0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl length of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    std::vector<std::byte> buf(l);\n+    if (sysctl(/*name=*/mib, /*namelen=*/sizeof(mib) / sizeof(int), /*oldp=*/buf.data(), /*oldlenp=*/&l, /*newp=*/nullptr, /*newlen=*/0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl data of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    // Iterate over messages (each message is a routing table entry).\n+    for (size_t msg_pos = 0; msg_pos < buf.size(); ) {\n+        if ((msg_pos + sizeof(rt_msghdr)) > buf.size()) return std::nullopt;\n+        const struct rt_msghdr* rt = (const struct rt_msghdr*)(buf.data() + msg_pos);\n+        const size_t next_msg_pos = msg_pos + rt->rtm_msglen;\n+        if (rt->rtm_msglen < sizeof(rt_msghdr) || next_msg_pos > buf.size()) return std::nullopt;\n+        // Iterate over addresses within message, get destination and gateway (if present).\n+        // Address data starts after header.\n+        size_t sa_pos = msg_pos + sizeof(struct rt_msghdr);\n+        std::optional<CNetAddr> dst, gateway;\n+        for (int i = 0; i < RTAX_MAX; i++) {\n+            if (rt->rtm_addrs & (1 << i)) {\n+                // 2 is just sa_len + sa_family, the theoretical minimum size of a socket address.\n+                if ((sa_pos + 2) > next_msg_pos) return std::nullopt;\n+                const struct sockaddr* sa = (const struct sockaddr*)(buf.data() + sa_pos);\n+                if (sa->sa_len < 2 || (sa_pos + sa->sa_len) > next_msg_pos) return std::nullopt;",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 215,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "9a067b5ac154154ec9008a0e8f2d8f03e994a589",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "9a067b5ac154154ec9008a0e8f2d8f03e994a589: this is triggered on my Intel macOS 14.5 machine. If I comment out the `if` statement it works fine.",
      "created_at": "2024-07-08T12:19:20Z",
      "updated_at": "2024-07-08T12:19:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1668523385",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1668523385"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 215,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1668531523",
      "pull_request_review_id": 2163144926,
      "id": 1668531523,
      "node_id": "PRRC_kwDOABII585jc8VD",
      "diff_hunk": "@@ -0,0 +1,299 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <osreldate.h>\n+#if __FreeBSD_version >= 1400000\n+// Workaround https://github.com/freebsd/freebsd-src/pull/1070.\n+#define typeof __typeof\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+#elif defined(WIN32)\n+#include <iphlpapi.h>\n+#elif defined(__APPLE__)\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+#endif\n+\n+namespace {\n+\n+// Linux and FreeBSD 14.0+. For FreeBSD 13.2 the code can be compiled but\n+// running it requires loading a special kernel module, otherwise socket(AF_NETLINK,...)\n+// will fail, so we skip that.\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1400000)\n+\n+std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    auto sock{CreateSock(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (!sock) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.dst_data.\n+    const size_t dst_data_len = family == AF_INET ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    // Linux IPv4 / IPv6 - this must be present, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = family;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    // Linux IPv4 / IPv6 this must be absent, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock->Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    int64_t recv_result;\n+    do {\n+        recv_result = sock->Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, recv_result); hdr = NLMSG_NEXT(hdr, recv_result)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF && sizeof(int) == RTA_PAYLOAD(attr)) {\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (family == AF_INET && sizeof(in_addr) == RTA_PAYLOAD(rta_gateway)) {\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (family == AF_INET6 && sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway)) {\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    destination_address.si_family = family;\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    Assume(best_route.NextHop.si_family == family);\n+    if (family == AF_INET) {\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(family == AF_INET6) {\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Check valid length. Note that sa_len is not part of POSIX, and exists on MacOS and some BSDs only, so we can't\n+    // do this check in SetSockAddr.\n+    if (!(addr->sa_family == AF_INET && addr->sa_len == sizeof(struct sockaddr_in)) &&\n+        !(addr->sa_family == AF_INET6 && addr->sa_len == sizeof(struct sockaddr_in6))) {\n+        return std::nullopt;\n+    }\n+\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+//! MacOS: Get default gateway from route table. See route(4) for the format.\n+std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // net.route.0.inet[6].flags.gateway\n+    int mib[] = {CTL_NET, PF_ROUTE, 0, family, NET_RT_FLAGS, RTF_GATEWAY};\n+    // The size of the available data is determined by calling sysctl() with oldp=nullptr. See sysctl(3).\n+    size_t l = 0;\n+    if (sysctl(/*name=*/mib, /*namelen=*/sizeof(mib) / sizeof(int), /*oldp=*/nullptr, /*oldlenp=*/&l, /*newp=*/nullptr, /*newlen=*/0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl length of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    std::vector<std::byte> buf(l);\n+    if (sysctl(/*name=*/mib, /*namelen=*/sizeof(mib) / sizeof(int), /*oldp=*/buf.data(), /*oldlenp=*/&l, /*newp=*/nullptr, /*newlen=*/0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl data of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    // Iterate over messages (each message is a routing table entry).\n+    for (size_t msg_pos = 0; msg_pos < buf.size(); ) {\n+        if ((msg_pos + sizeof(rt_msghdr)) > buf.size()) return std::nullopt;\n+        const struct rt_msghdr* rt = (const struct rt_msghdr*)(buf.data() + msg_pos);\n+        const size_t next_msg_pos = msg_pos + rt->rtm_msglen;\n+        if (rt->rtm_msglen < sizeof(rt_msghdr) || next_msg_pos > buf.size()) return std::nullopt;\n+        // Iterate over addresses within message, get destination and gateway (if present).\n+        // Address data starts after header.\n+        size_t sa_pos = msg_pos + sizeof(struct rt_msghdr);\n+        std::optional<CNetAddr> dst, gateway;\n+        for (int i = 0; i < RTAX_MAX; i++) {\n+            if (rt->rtm_addrs & (1 << i)) {\n+                // 2 is just sa_len + sa_family, the theoretical minimum size of a socket address.\n+                if ((sa_pos + 2) > next_msg_pos) return std::nullopt;\n+                const struct sockaddr* sa = (const struct sockaddr*)(buf.data() + sa_pos);\n+                if (sa->sa_len < 2 || (sa_pos + sa->sa_len) > next_msg_pos) return std::nullopt;",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 215,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "9a067b5ac154154ec9008a0e8f2d8f03e994a589",
      "in_reply_to_id": 1668523385,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "For IPv4:\r\n\r\n```\r\nsa->sa_len=16 sa_pos=92 next_msg_pos=144\r\nsa->sa_len=16 sa_pos=108 next_msg_pos=144\r\nsa->sa_len=0 sa_pos=124 next_msg_pos=144\r\n2024-07-08T12:24:02Z [mapport] [net] portmap: Could not determine IPv4 default gateway\r\n```\r\n\r\nFor IPv6:\r\n\r\n```\r\nsa->sa_len=28 sa_pos=92 next_msg_pos=180\r\nsa->sa_len=28 sa_pos=120 next_msg_pos=180\r\nsa->sa_len=0 sa_pos=148 next_msg_pos=180\r\n2024-07-08T12:24:02Z [mapport] [net] portmap: Could not determine IPv6 default gateway\r\n```",
      "created_at": "2024-07-08T12:24:38Z",
      "updated_at": "2024-07-08T12:24:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1668531523",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1668531523"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 215,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1668537577",
      "pull_request_review_id": 2163153734,
      "id": 1668537577,
      "node_id": "PRRC_kwDOABII585jc9zp",
      "diff_hunk": "@@ -0,0 +1,299 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <osreldate.h>\n+#if __FreeBSD_version >= 1400000\n+// Workaround https://github.com/freebsd/freebsd-src/pull/1070.\n+#define typeof __typeof\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+#elif defined(WIN32)\n+#include <iphlpapi.h>\n+#elif defined(__APPLE__)\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+#endif\n+\n+namespace {\n+\n+// Linux and FreeBSD 14.0+. For FreeBSD 13.2 the code can be compiled but\n+// running it requires loading a special kernel module, otherwise socket(AF_NETLINK,...)\n+// will fail, so we skip that.\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1400000)\n+\n+std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    auto sock{CreateSock(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (!sock) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.dst_data.\n+    const size_t dst_data_len = family == AF_INET ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    // Linux IPv4 / IPv6 - this must be present, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = family;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    // Linux IPv4 / IPv6 this must be absent, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock->Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    int64_t recv_result;\n+    do {\n+        recv_result = sock->Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, recv_result); hdr = NLMSG_NEXT(hdr, recv_result)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF && sizeof(int) == RTA_PAYLOAD(attr)) {\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (family == AF_INET && sizeof(in_addr) == RTA_PAYLOAD(rta_gateway)) {\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (family == AF_INET6 && sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway)) {\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    destination_address.si_family = family;\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    Assume(best_route.NextHop.si_family == family);\n+    if (family == AF_INET) {\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(family == AF_INET6) {\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Check valid length. Note that sa_len is not part of POSIX, and exists on MacOS and some BSDs only, so we can't\n+    // do this check in SetSockAddr.\n+    if (!(addr->sa_family == AF_INET && addr->sa_len == sizeof(struct sockaddr_in)) &&\n+        !(addr->sa_family == AF_INET6 && addr->sa_len == sizeof(struct sockaddr_in6))) {\n+        return std::nullopt;\n+    }\n+\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+//! MacOS: Get default gateway from route table. See route(4) for the format.\n+std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // net.route.0.inet[6].flags.gateway\n+    int mib[] = {CTL_NET, PF_ROUTE, 0, family, NET_RT_FLAGS, RTF_GATEWAY};\n+    // The size of the available data is determined by calling sysctl() with oldp=nullptr. See sysctl(3).\n+    size_t l = 0;\n+    if (sysctl(/*name=*/mib, /*namelen=*/sizeof(mib) / sizeof(int), /*oldp=*/nullptr, /*oldlenp=*/&l, /*newp=*/nullptr, /*newlen=*/0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl length of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    std::vector<std::byte> buf(l);\n+    if (sysctl(/*name=*/mib, /*namelen=*/sizeof(mib) / sizeof(int), /*oldp=*/buf.data(), /*oldlenp=*/&l, /*newp=*/nullptr, /*newlen=*/0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl data of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    // Iterate over messages (each message is a routing table entry).\n+    for (size_t msg_pos = 0; msg_pos < buf.size(); ) {\n+        if ((msg_pos + sizeof(rt_msghdr)) > buf.size()) return std::nullopt;\n+        const struct rt_msghdr* rt = (const struct rt_msghdr*)(buf.data() + msg_pos);\n+        const size_t next_msg_pos = msg_pos + rt->rtm_msglen;\n+        if (rt->rtm_msglen < sizeof(rt_msghdr) || next_msg_pos > buf.size()) return std::nullopt;\n+        // Iterate over addresses within message, get destination and gateway (if present).\n+        // Address data starts after header.\n+        size_t sa_pos = msg_pos + sizeof(struct rt_msghdr);\n+        std::optional<CNetAddr> dst, gateway;\n+        for (int i = 0; i < RTAX_MAX; i++) {\n+            if (rt->rtm_addrs & (1 << i)) {\n+                // 2 is just sa_len + sa_family, the theoretical minimum size of a socket address.\n+                if ((sa_pos + 2) > next_msg_pos) return std::nullopt;\n+                const struct sockaddr* sa = (const struct sockaddr*)(buf.data() + sa_pos);\n+                if (sa->sa_len < 2 || (sa_pos + sa->sa_len) > next_msg_pos) return std::nullopt;",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 215,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "9a067b5ac154154ec9008a0e8f2d8f03e994a589",
      "in_reply_to_id": 1668523385,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Maybe replacing `return std::nullopt;` with `continue;`?",
      "created_at": "2024-07-08T12:27:47Z",
      "updated_at": "2024-07-08T12:27:48Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1668537577",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1668537577"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 215,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1668563657",
      "pull_request_review_id": 2163198117,
      "id": 1668563657,
      "node_id": "PRRC_kwDOABII585jdELJ",
      "diff_hunk": "@@ -0,0 +1,299 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <osreldate.h>\n+#if __FreeBSD_version >= 1400000\n+// Workaround https://github.com/freebsd/freebsd-src/pull/1070.\n+#define typeof __typeof\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+#elif defined(WIN32)\n+#include <iphlpapi.h>\n+#elif defined(__APPLE__)\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+#endif\n+\n+namespace {\n+\n+// Linux and FreeBSD 14.0+. For FreeBSD 13.2 the code can be compiled but\n+// running it requires loading a special kernel module, otherwise socket(AF_NETLINK,...)\n+// will fail, so we skip that.\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1400000)\n+\n+std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    auto sock{CreateSock(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (!sock) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.dst_data.\n+    const size_t dst_data_len = family == AF_INET ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    // Linux IPv4 / IPv6 - this must be present, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = family;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    // Linux IPv4 / IPv6 this must be absent, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock->Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    int64_t recv_result;\n+    do {\n+        recv_result = sock->Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, recv_result); hdr = NLMSG_NEXT(hdr, recv_result)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF && sizeof(int) == RTA_PAYLOAD(attr)) {\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (family == AF_INET && sizeof(in_addr) == RTA_PAYLOAD(rta_gateway)) {\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (family == AF_INET6 && sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway)) {\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    destination_address.si_family = family;\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    Assume(best_route.NextHop.si_family == family);\n+    if (family == AF_INET) {\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(family == AF_INET6) {\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Check valid length. Note that sa_len is not part of POSIX, and exists on MacOS and some BSDs only, so we can't\n+    // do this check in SetSockAddr.\n+    if (!(addr->sa_family == AF_INET && addr->sa_len == sizeof(struct sockaddr_in)) &&\n+        !(addr->sa_family == AF_INET6 && addr->sa_len == sizeof(struct sockaddr_in6))) {\n+        return std::nullopt;\n+    }\n+\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+//! MacOS: Get default gateway from route table. See route(4) for the format.\n+std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // net.route.0.inet[6].flags.gateway\n+    int mib[] = {CTL_NET, PF_ROUTE, 0, family, NET_RT_FLAGS, RTF_GATEWAY};\n+    // The size of the available data is determined by calling sysctl() with oldp=nullptr. See sysctl(3).\n+    size_t l = 0;\n+    if (sysctl(/*name=*/mib, /*namelen=*/sizeof(mib) / sizeof(int), /*oldp=*/nullptr, /*oldlenp=*/&l, /*newp=*/nullptr, /*newlen=*/0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl length of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    std::vector<std::byte> buf(l);\n+    if (sysctl(/*name=*/mib, /*namelen=*/sizeof(mib) / sizeof(int), /*oldp=*/buf.data(), /*oldlenp=*/&l, /*newp=*/nullptr, /*newlen=*/0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl data of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    // Iterate over messages (each message is a routing table entry).\n+    for (size_t msg_pos = 0; msg_pos < buf.size(); ) {\n+        if ((msg_pos + sizeof(rt_msghdr)) > buf.size()) return std::nullopt;\n+        const struct rt_msghdr* rt = (const struct rt_msghdr*)(buf.data() + msg_pos);\n+        const size_t next_msg_pos = msg_pos + rt->rtm_msglen;\n+        if (rt->rtm_msglen < sizeof(rt_msghdr) || next_msg_pos > buf.size()) return std::nullopt;\n+        // Iterate over addresses within message, get destination and gateway (if present).\n+        // Address data starts after header.\n+        size_t sa_pos = msg_pos + sizeof(struct rt_msghdr);\n+        std::optional<CNetAddr> dst, gateway;\n+        for (int i = 0; i < RTAX_MAX; i++) {\n+            if (rt->rtm_addrs & (1 << i)) {\n+                // 2 is just sa_len + sa_family, the theoretical minimum size of a socket address.\n+                if ((sa_pos + 2) > next_msg_pos) return std::nullopt;\n+                const struct sockaddr* sa = (const struct sockaddr*)(buf.data() + sa_pos);\n+                if (sa->sa_len < 2 || (sa_pos + sa->sa_len) > next_msg_pos) return std::nullopt;",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 215,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "9a067b5ac154154ec9008a0e8f2d8f03e994a589",
      "in_reply_to_id": 1668523385,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Or maybe the following:\r\n\r\n```cpp\r\nif (rt->rtm_addrs & (1 << i)) {\r\n    // 2 is just sa_len + sa_family, the theoretical minimum size of a socket address.\r\n    if ((sa_pos + 2) > next_msg_pos) return std::nullopt;\r\n    const struct sockaddr* sa = (const struct sockaddr*)(buf.data() + sa_pos);\r\n    if (sa->sa_len >= 2 && (sa_pos + sa->sa_len) <= next_msg_pos) {\r\n        if (i == RTAX_DST) {\r\n            dst = FromSockAddr(sa);\r\n        } else if (i == RTAX_GATEWAY) {\r\n            gateway = FromSockAddr(sa);\r\n        }\r\n    }\r\n    // Skip to next address.\r\n    sa_pos += sa->sa_len;\r\n}\r\n```\r\n\r\nOn macOS `RTAX_DST` is 0 and `RTAX_GATEWAY` is 1. \r\n\r\n```\r\ni=0 sa->sa_len=16 sa_pos=92 next_msg_pos=144\r\ni=1 sa->sa_len=16 sa_pos=108 next_msg_pos=144\r\ni=2 sa->sa_len=0 sa_pos=124 next_msg_pos=144\r\ni=5 sa->sa_len=0 sa_pos=124 next_msg_pos=144\r\n```\r\n\r\nAs for the i=2 and i=5:\r\n\r\n```cpp\r\n/*\r\n * Index offsets for sockaddr array for alternate internal encoding.\r\n */\r\n#define RTAX_DST        0       /* destination sockaddr present */\r\n#define RTAX_GATEWAY    1       /* gateway sockaddr present */\r\n#define RTAX_NETMASK    2       /* netmask sockaddr present */\r\n#define RTAX_GENMASK    3       /* cloning mask sockaddr present */\r\n#define RTAX_IFP        4       /* interface name sockaddr present */\r\n#define RTAX_IFA        5       /* interface addr sockaddr present */\r\n#define RTAX_AUTHOR     6       /* sockaddr for author of redirect */\r\n#define RTAX_BRD        7       /* for NEWADDR, broadcast or p-p dest addr */\r\n#define RTAX_MAX        8       /* size of array to allocate */\r\n```",
      "created_at": "2024-07-08T12:45:00Z",
      "updated_at": "2024-07-08T13:12:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1668563657",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1668563657"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 215,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1679709347",
      "pull_request_review_id": 2180742154,
      "id": 1679709347,
      "node_id": "PRRC_kwDOABII585kHlSj",
      "diff_hunk": "@@ -46,104 +43,96 @@ using namespace std::chrono_literals;\n static constexpr auto PORT_MAPPING_REANNOUNCE_PERIOD{20min};\n static constexpr auto PORT_MAPPING_RETRY_PERIOD{5min};\n \n-#ifdef USE_NATPMP\n-static uint16_t g_mapport_external_port = 0;\n-static bool NatpmpInit(natpmp_t* natpmp)\n+static bool ProcessPCP()\n {\n-    const int r_init = initnatpmp(natpmp, /* detect gateway automatically */ 0, /* forced gateway - NOT APPLIED*/ 0);\n-    if (r_init == 0) return true;\n-    LogPrintf(\"natpmp: initnatpmp() failed with %d error.\\n\", r_init);\n-    return false;\n-}\n+    // The same nonce is used for all mappings, this is allowed by the spec, and simplifies keeping track of them.\n+    PCPMappingNonce pcp_nonce;\n+    GetRandBytes(pcp_nonce);\n \n-static bool NatpmpDiscover(natpmp_t* natpmp, struct in_addr& external_ipv4_addr)\n-{\n-    const int r_send = sendpublicaddressrequest(natpmp);\n-    if (r_send == 2 /* OK */) {\n-        int r_read;\n-        natpmpresp_t response;\n-        do {\n-            r_read = readnatpmpresponseorretry(natpmp, &response);\n-        } while (r_read == NATPMP_TRYAGAIN);\n-\n-        if (r_read == 0) {\n-            external_ipv4_addr = response.pnu.publicaddress.addr;\n-            return true;\n-        } else if (r_read == NATPMP_ERR_NOGATEWAYSUPPORT) {\n-            LogPrintf(\"natpmp: The gateway does not support NAT-PMP.\\n\");\n+    bool ret = false;\n+    bool no_resources = false;\n+    const uint16_t private_port = GetListenPort();\n+    // Multiply the reannounce period by two, as we'll try to renew approximately halfway.\n+    const uint32_t requested_lifetime = std::chrono::seconds(PORT_MAPPING_REANNOUNCE_PERIOD * 2).count();\n+    uint32_t actual_lifetime = 0;\n+    std::chrono::milliseconds sleep_time;\n+\n+    // Local functor to handle result from PCP/NATPMP mapping.\n+    auto handle_mapping = [&](std::variant<MappingResult, MappingError> &res) -> void {\n+        if (MappingResult* mapping = std::get_if<MappingResult>(&res)) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Info, \"portmap: Added mapping %s\\n\", mapping->ToString());\n+            AddLocal(mapping->external, LOCAL_MAPPED);\n+            ret = true;\n+            actual_lifetime = std::min(actual_lifetime, mapping->lifetime);\n+        } else if (MappingError *err = std::get_if<MappingError>(&res)) {\n+            // Detailed error will already have been logged internally in respective Portmap function.\n+            if (*err == MappingError::NO_RESOURCES) {\n+                no_resources = true;\n+            }\n+        }\n+    };\n+\n+    do {\n+        actual_lifetime = requested_lifetime;\n+        no_resources = false; // Set to true if there was any \"no resources\" error.\n+        ret = false; // Set to true if any mapping succeeds.\n+\n+        // IPv4\n+        std::optional<CNetAddr> gateway4 = QueryDefaultGateway(NET_IPV4);\n+        if (!gateway4) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: Could not determine IPv4 default gateway\\n\");\n         } else {\n-            LogPrintf(\"natpmp: readnatpmpresponseorretry() for public address failed with %d error.\\n\", r_read);\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: gateway [IPv4]: %s\\n\", gateway4->ToStringAddr());\n+\n+            // Open a port mapping on whatever local address we have toward the gateway.\n+            struct in_addr inaddr_any;\n+            inaddr_any.s_addr = htonl(INADDR_ANY);\n+            auto res = PCPRequestPortMap(pcp_nonce, *gateway4, CNetAddr(inaddr_any), private_port, requested_lifetime);",
      "path": "src/mapport.cpp",
      "position": 98,
      "original_position": 98,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "23916f2a7717b463799207b4b81b5795f2e9d7e3",
      "in_reply_to_id": 1658779455,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Ok, I am fine with just adding a comment and leave the code as is. This is probably too edge case to bother complicating the code with it, but just mentioning why I think it is better to keep using the initially assigned port even if it is different than the one we requested:\r\n\r\n* We request port `8333`, but for whatever reason the router assigns `15000` with an external address let's say `1.2.3.4`.\r\n* We start using and advertise `1.2.3.4:15000` to other peers, it propagates into nodes' addrmans. The ones that actually connect to us will have it as good in their tried tables.\r\n* Eventually we renew but try port `8333` as in the initial PCP request. This time it succeeds so we get `8333`, or it is still unavailable, but we get another random port e.g. `16000`. We start advertising `1.2.3.4:8333` or `1.2.3.4:16000` and the good old `1.2.3.4:15000` is now junk in nodes' addrmans. This can repeat over and over with different random ports.",
      "created_at": "2024-07-16T16:19:39Z",
      "updated_at": "2024-07-16T16:19:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1679709347",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1679709347"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 90,
      "original_line": 90,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1679713040",
      "pull_request_review_id": 2180748089,
      "id": 1679713040,
      "node_id": "PRRC_kwDOABII585kHmMQ",
      "diff_hunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/pcp.h>\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <span.h>\n+#include <util/check.h>\n+#include <util/netif.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+namespace {\n+\n+// RFC6886 NAT-PMP and RFC6887 Port Control Protocol (PCP) implementation.\n+// NAT-PMP and PCP use network byte order (big-endian).\n+\n+// NAT-PMP (v0) protocol constants.\n+//! NAT-PMP uses a fixed server port number (RFC6887 section 1.1).\n+constexpr uint16_t NATPMP_SERVER_PORT = 5351;\n+//! Version byte for NATPMP (RFC6886 1.1)\n+constexpr uint8_t NATPMP_VERSION = 0;\n+//! Request opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_REQUEST = 0x00;\n+//! Response opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_RESPONSE = 0x80;\n+//! Get external address (RFC6886 3.2)\n+constexpr uint8_t NATPMP_OP_GETEXTERNAL = 0x00;\n+//! Map TCP port (RFC6886 3.3)\n+constexpr uint8_t NATPMP_OP_MAP_TCP = 0x02;\n+//! Shared request header size in bytes.\n+constexpr size_t NATPMP_REQUEST_HDR_SIZE = 2;\n+//! Shared response header (minimum) size in bytes.\n+constexpr size_t NATPMP_RESPONSE_HDR_SIZE = 8;\n+//! GETEXTERNAL request size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 0;\n+//! GETEXTERNAL response size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 4;\n+//! MAP request size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 10;\n+//! MAP response size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 8;\n+\n+// Shared header offsets (RFC6886 3.2, 3.3), relative to start of packet.\n+//!  Offset of version field in packets.\n+constexpr size_t NATPMP_HDR_VERSION_OFS = 0;\n+//!  Offset of opcode field in packets\n+constexpr size_t NATPMP_HDR_OP_OFS = 1;\n+//!  Offset of result code in packets. Result codes are 16 bit in NAT-PMP instead of 8 bit in PCP.\n+constexpr size_t NATPMP_RESPONSE_HDR_RESULT_OFS = 2;\n+\n+// GETEXTERNAL response offsets (RFC6886 3.2), relative to start of packet.\n+//!  Returned external address\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_IP_OFS = 8;\n+\n+// MAP request offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port to be mapped.\n+constexpr size_t NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS = 4;\n+//!  Suggested external port for mapping.\n+constexpr size_t NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS = 6;\n+//!  Requested port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_REQUEST_LIFETIME_OFS = 8;\n+\n+// MAP response offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port for mapping (will match internal port of request).\n+constexpr size_t NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS = 8;\n+//!  External port for mapping.\n+constexpr size_t NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS = 10;\n+//!  Created port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_RESPONSE_LIFETIME_OFS = 12;\n+\n+// Relevant NETPMP result codes (RFC6886 3.5).\n+//! Result code representing success status.\n+constexpr uint8_t NATPMP_RESULT_SUCCESS = 0;\n+//! Result code representing unsupported version.\n+constexpr uint8_t NATPMP_RESULT_UNSUPP_VERSION = 1;\n+//! Result code representing lack of resources.\n+constexpr uint8_t NATPMP_RESULT_NO_RESOURCES = 4;\n+\n+//! Mapping of NATPMP result code to string (RFC6886 3.5). Result codes <=2 match PCP.\n+const std::map<uint8_t, std::string> NATPMP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"NETWORK_FAILURE\"},\n+    {4,  \"NO_RESOURCES\"},\n+    {5,  \"UNSUPP_OPCODE\"},\n+};\n+\n+// PCP (v2) protocol constants.\n+//! Maximum packet size in bytes (RFC6887 section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (RFC6887 section 19.1). Shared with NAT-PMP.\n+constexpr uint16_t PCP_SERVER_PORT = NATPMP_SERVER_PORT;\n+//! Version byte. 0 is NAT-PMP (RFC6886), 1 is forbidden, 2 for PCP (RFC6887).\n+constexpr uint8_t PCP_VERSION = 2;\n+//! PCP Request Header. See RFC6887 section 7.1. Shared with NAT-PMP.\n+constexpr uint8_t PCP_REQUEST = NATPMP_REQUEST; // R = 0\n+//! PCP Response Header. See RFC6887 section 7.2. Shared with NAT-PMP.\n+constexpr uint8_t PCP_RESPONSE = NATPMP_RESPONSE; // R = 1\n+//! Map opcode. See RFC6887 section 19.2\n+constexpr uint8_t PCP_OP_MAP = 0x01;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Request and response header size in bytes (RFC6887 section 7.1).\n+constexpr size_t PCP_HDR_SIZE = 24;\n+//! Map request and response size in bytes (RFC6887 section 11.1).\n+constexpr size_t PCP_MAP_SIZE = 36;\n+\n+// Header offsets shared between request and responses (RFC6887 7.1, 7.2), relative to start of packet.\n+//!  Version field (1 byte).\n+constexpr size_t PCP_HDR_VERSION_OFS = NATPMP_HDR_VERSION_OFS;\n+//!  Opcode field (1 byte).\n+constexpr size_t PCP_HDR_OP_OFS = NATPMP_HDR_OP_OFS;\n+//!  Requested lifetime (request), granted lifetime (response) (2 bytes).\n+constexpr size_t PCP_HDR_LIFETIME_OFS = 4;\n+\n+// Request header offsets (RFC6887 7.1), relative to start of packet.\n+//!  PCP client's IP address (16 bytes).\n+constexpr size_t PCP_REQUEST_HDR_IP_OFS = 8;\n+\n+// Response header offsets (RFC6887 7.2), relative to start of packet.\n+//!  Result code (1 byte).\n+constexpr size_t PCP_RESPONSE_HDR_RESULT_OFS = 3;\n+\n+// MAP request/response offsets (RFC6887 11.1), relative to start of opcode-specific data.\n+//!  Mapping nonce (12 bytes).\n+constexpr size_t PCP_MAP_NONCE_OFS = 0;\n+//!  Protocol (1 byte).\n+constexpr size_t PCP_MAP_PROTOCOL_OFS = 12;\n+//!  Internal port for mapping (2 bytes).\n+constexpr size_t PCP_MAP_INTERNAL_PORT_OFS = 16;\n+//!  Suggested external port (request), assigned external port (response) (2 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_PORT_OFS = 18;\n+//!  Suggested external IP (request), assigned external IP (response) (16 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_IP_OFS = 20;\n+\n+//! Result code representing success (RFC6887 7.4), shared with NAT-PMP.\n+constexpr uint8_t PCP_RESULT_SUCCESS = NATPMP_RESULT_SUCCESS;\n+//! Result code representing lack of resources (RFC6887 7.4).\n+constexpr uint8_t PCP_RESULT_NO_RESOURCES = 8;\n+\n+//! Mapping of PCP result code to string (RFC6887 7.4). Result codes <=2 match NAT-PMP.\n+const std::map<uint8_t, std::string> PCP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"MALFORMED_REQUEST\"},\n+    {4,  \"UNSUPP_OPCODE\"},\n+    {5,  \"UNSUPP_OPTION\"},\n+    {6,  \"MALFORMED_OPTION\"},\n+    {7,  \"NETWORK_FAILURE\"},\n+    {8,  \"NO_RESOURCES\"},\n+    {9,  \"UNSUPP_PROTOCOL\"},\n+    {10, \"USER_EX_QUOTA\"},\n+    {11, \"CANNOT_PROVIDE_EXTERNAL\"},\n+    {12, \"ADDRESS_MISMATCH\"},\n+    {13, \"EXCESSIVE_REMOTE_PEER\"},\n+};\n+\n+//! Return human-readable string from NATPMP result code.\n+std::string NATPMPResultString(uint8_t result_code)\n+{\n+    auto result_i = NATPMP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == NATPMP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Return human-readable string from PCP result code.\n+std::string PCPResultString(uint8_t result_code)\n+{\n+    auto result_i = PCP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == PCP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Wrap address in IPv6 according to RFC6887. wrapped_addr needs to be able to store 16 bytes.\n+[[nodiscard]] bool PCPWrapAddress(Span<uint8_t> wrapped_addr, const CNetAddr &addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (addr.IsIPv4()) {\n+        struct in_addr addr4;\n+        if (!addr.GetInAddr(&addr4)) return false;\n+        // Section 5: \"When the address field holds an IPv4 address, an IPv4-mapped IPv6 address [RFC4291] is used (::ffff:0:0/96).\"\n+        std::memcpy(wrapped_addr.data(), IPV4_IN_IPV6_PREFIX.data(), IPV4_IN_IPV6_PREFIX.size());\n+        std::memcpy(wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), &addr4, ADDR_IPV4_SIZE);\n+        return true;\n+    } else if (addr.IsIPv6()) {\n+        struct in6_addr addr6;\n+        if (!addr.GetIn6Addr(&addr6)) return false;\n+        std::memcpy(wrapped_addr.data(), &addr6, ADDR_IPV6_SIZE);\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+//! Unwrap PCP-encoded address according to RFC6887.\n+CNetAddr PCPUnwrapAddress(Span<const uint8_t> wrapped_addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (util::HasPrefix(wrapped_addr, IPV4_IN_IPV6_PREFIX)) {\n+        struct in_addr addr4;\n+        std::memcpy(&addr4, wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), ADDR_IPV4_SIZE);\n+        return CNetAddr(addr4);\n+    } else {\n+        struct in6_addr addr6;\n+        std::memcpy(&addr6, wrapped_addr.data(), ADDR_IPV6_SIZE);\n+        return CNetAddr(addr6);\n+    }\n+}\n+\n+//! PCP or NAT-PMP send-receive loop.\n+std::optional<std::vector<uint8_t>> PCPSendRecv(Sock &sock, const std::string &protocol, Span<const uint8_t> request, int num_tries,\n+        std::chrono::milliseconds timeout_per_try,\n+        std::function<bool(Span<const uint8_t>)> check_packet)\n+{\n+    using namespace std::chrono;\n+    // UDP is a potentially lossy protocol, so we try to send again a few times.\n+    uint8_t response[PCP_MAX_SIZE];\n+    bool got_response = false;\n+    int recvsz = 0;\n+    for (int ntry = 0; !got_response && ntry < num_tries; ++ntry) {\n+        if (ntry > 0) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Retrying (%d)\\n\", protocol, ntry);\n+        }\n+        // Dispatch packet to gateway.\n+        if (sock.Send(request.data(), request.size(), 0) != static_cast<ssize_t>(request.size())) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not send request: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+            return std::nullopt; // Network-level error, probably no use retrying.\n+        }\n+\n+        // Wait for response(s) until we get a valid response, a network error, or time out.\n+        auto cur_time = time_point_cast<milliseconds>(steady_clock::now());\n+        auto deadline = cur_time + timeout_per_try;\n+        while ((cur_time = time_point_cast<milliseconds>(steady_clock::now())) < deadline) {\n+            Sock::Event occurred = 0;\n+            if (!sock.Wait(deadline - cur_time, Sock::RECV, &occurred)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not wait on socket: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            if (!occurred) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Timeout\\n\", protocol);\n+                break; // Retry.\n+            }\n+\n+            // Receive response.\n+            recvsz = sock.Recv(response, sizeof(response), MSG_DONTWAIT);\n+            if (recvsz < 0) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not receive response: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Received response of %d bytes: %s\\n\", protocol, recvsz, HexStr(Span(response, recvsz)));\n+\n+            if (check_packet(Span<uint8_t>(response, recvsz))) {\n+                got_response = true; // Got expected response, break from receive loop as well as from retry loop.\n+                break;\n+            }\n+        }\n+    }\n+    if (!got_response) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Giving up after %d tries\\n\", protocol, num_tries);\n+        return std::nullopt;\n+    }\n+    return std::vector<uint8_t>(response, response + recvsz);\n+}\n+\n+}\n+\n+std::variant<MappingResult, MappingError> NATPMPRequestPortMap(const CNetAddr &gateway, uint16_t port, uint32_t lifetime, int num_tries, std::chrono::milliseconds timeout_per_try)\n+{\n+    struct sockaddr_storage dest_addr;\n+    socklen_t dest_addrlen = sizeof(struct sockaddr_storage);\n+\n+    LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"natpmp: Requesting port mapping port %d from gateway %s\\n\", port, gateway.ToStringAddr());\n+\n+    // Validate gateway, make sure it's IPv4. NAT-PMP does not support IPv6.\n+    if (!CService(gateway, PCP_SERVER_PORT).GetSockAddr((struct sockaddr*)&dest_addr, &dest_addrlen)) return MappingError::NETWORK_ERROR;\n+    if (dest_addr.ss_family != AF_INET) return MappingError::NETWORK_ERROR;\n+\n+    // Create IPv4 UDP socket\n+    auto sock{CreateSock(AF_INET, SOCK_DGRAM, IPPROTO_UDP)};\n+    if (!sock) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Could not create UDP socket: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Associate UDP socket to gateway.\n+    if (sock->Connect((struct sockaddr*)&dest_addr, dest_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Could not connect to gateway: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Use getsockname to get the address toward the default gateway (the internal address).\n+    struct sockaddr_in internal;\n+    socklen_t internal_addrlen = sizeof(struct sockaddr_in);\n+    if (sock->GetSockName((struct sockaddr*)&internal, &internal_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Could not get sock name: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Request external IP address (RFC6886 section 3.2).\n+    std::vector<uint8_t> request(NATPMP_GETEXTERNAL_REQUEST_SIZE);\n+    request[NATPMP_HDR_VERSION_OFS] = NATPMP_VERSION;\n+    request[NATPMP_HDR_OP_OFS] = NATPMP_REQUEST | NATPMP_OP_GETEXTERNAL;\n+\n+    auto recv_res = PCPSendRecv(*sock, \"natpmp\", request, num_tries, timeout_per_try,\n+        [&](const Span<const uint8_t> response) -> bool {\n+            if (response.size() < NATPMP_GETEXTERNAL_RESPONSE_SIZE) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response too small\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            if (response[NATPMP_HDR_VERSION_OFS] != NATPMP_VERSION || response[NATPMP_HDR_OP_OFS] != (NATPMP_RESPONSE | NATPMP_OP_GETEXTERNAL)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response to wrong command\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            return true;\n+        });\n+\n+    struct in_addr external_addr;\n+    if (recv_res) {\n+        const std::span<const uint8_t> response = *recv_res;\n+\n+        Assume(response.size() >= NATPMP_GETEXTERNAL_RESPONSE_SIZE);\n+        uint16_t result_code = ReadBE16(response.data() + NATPMP_RESPONSE_HDR_RESULT_OFS);\n+        if (result_code != NATPMP_RESULT_SUCCESS) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Getting external address failed with result %s\\n\", NATPMPResultString(result_code));\n+            return MappingError::PROTOCOL_ERROR;\n+        }\n+\n+        std::memcpy(&external_addr, response.data() + NATPMP_GETEXTERNAL_RESPONSE_IP_OFS, ADDR_IPV4_SIZE);\n+    } else {\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Create TCP mapping request (RFC6886 section 3.3).\n+    request = std::vector<uint8_t>(NATPMP_MAP_REQUEST_SIZE);\n+    request[NATPMP_HDR_VERSION_OFS] = NATPMP_VERSION;\n+    request[NATPMP_HDR_OP_OFS] = NATPMP_REQUEST | NATPMP_OP_MAP_TCP;\n+    WriteBE16(request.data() + NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS, port);\n+    WriteBE16(request.data() + NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS, port);\n+    WriteBE32(request.data() + NATPMP_MAP_REQUEST_LIFETIME_OFS, lifetime);\n+\n+    recv_res = PCPSendRecv(*sock, \"natpmp\", request, num_tries, timeout_per_try,\n+        [&](const Span<const uint8_t> response) -> bool {\n+            if (response.size() < NATPMP_MAP_RESPONSE_SIZE) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response too small\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            if (response[0] != NATPMP_VERSION || response[1] != (NATPMP_RESPONSE | NATPMP_OP_MAP_TCP)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response to wrong command\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            uint16_t internal_port = ReadBE16(response.data() + NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS);\n+            if (internal_port != port) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response port doesn't match request\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            return true;\n+        });\n+\n+    if (recv_res) {\n+        const std::span<uint8_t> response = *recv_res;\n+\n+        Assume(response.size() >= NATPMP_MAP_RESPONSE_SIZE);\n+        uint16_t result_code = ReadBE16(response.data() + NATPMP_RESPONSE_HDR_RESULT_OFS);\n+        if (result_code != NATPMP_RESULT_SUCCESS) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Port mapping failed with result %s\\n\", NATPMPResultString(result_code));\n+            if (result_code == NATPMP_RESULT_NO_RESOURCES) {\n+                return MappingError::NO_RESOURCES;\n+            }\n+            return MappingError::PROTOCOL_ERROR;\n+        }\n+\n+        uint32_t lifetime_ret = ReadBE32(response.data() + NATPMP_MAP_RESPONSE_LIFETIME_OFS);\n+        uint16_t external_port = ReadBE16(response.data() + NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS);\n+        return MappingResult(NATPMP_VERSION, CService(internal.sin_addr, port), CService(external_addr, external_port), lifetime_ret);\n+    } else {\n+        return MappingError::NETWORK_ERROR;\n+    }\n+}\n+\n+std::variant<MappingResult, MappingError> PCPRequestPortMap(const PCPMappingNonce &nonce, const CNetAddr &gateway, const CNetAddr &bind, uint16_t port, uint32_t lifetime, int num_tries, std::chrono::milliseconds timeout_per_try)\n+{\n+    struct sockaddr_storage dest_addr, bind_addr;\n+    socklen_t dest_addrlen = sizeof(struct sockaddr_storage), bind_addrlen = sizeof(struct sockaddr_storage);\n+\n+    LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"pcp: Requesting port mapping for addr %s port %d from gateway %s\\n\", bind.ToStringAddr(), port, gateway.ToStringAddr());\n+\n+    // Validate addresses, make sure they're the same network family.\n+    if (!CService(gateway, PCP_SERVER_PORT).GetSockAddr((struct sockaddr*)&dest_addr, &dest_addrlen)) return MappingError::NETWORK_ERROR;\n+    if (!CService(bind, 0).GetSockAddr((struct sockaddr*)&bind_addr, &bind_addrlen)) return MappingError::NETWORK_ERROR;\n+    if (dest_addr.ss_family != bind_addr.ss_family) return MappingError::NETWORK_ERROR;\n+\n+    // Create UDP socket (IPv4 or IPv6 based on provided gateway).\n+    auto sock{CreateSock(dest_addr.ss_family, SOCK_DGRAM, IPPROTO_UDP)};",
      "path": "src/util/pcp.cpp",
      "position": 400,
      "original_position": 400,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "23916f2a7717b463799207b4b81b5795f2e9d7e3",
      "in_reply_to_id": 1658892377,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Yes, missed updates should result in us advertising the wrong (old) address only until the next renewal.",
      "created_at": "2024-07-16T16:22:36Z",
      "updated_at": "2024-07-16T16:22:36Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1679713040",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1679713040"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 400,
      "original_line": 400,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1680748974",
      "pull_request_review_id": 2182418318,
      "id": 1680748974,
      "node_id": "PRRC_kwDOABII585kLjGu",
      "diff_hunk": "@@ -46,104 +43,96 @@ using namespace std::chrono_literals;\n static constexpr auto PORT_MAPPING_REANNOUNCE_PERIOD{20min};\n static constexpr auto PORT_MAPPING_RETRY_PERIOD{5min};\n \n-#ifdef USE_NATPMP\n-static uint16_t g_mapport_external_port = 0;\n-static bool NatpmpInit(natpmp_t* natpmp)\n+static bool ProcessPCP()\n {\n-    const int r_init = initnatpmp(natpmp, /* detect gateway automatically */ 0, /* forced gateway - NOT APPLIED*/ 0);\n-    if (r_init == 0) return true;\n-    LogPrintf(\"natpmp: initnatpmp() failed with %d error.\\n\", r_init);\n-    return false;\n-}\n+    // The same nonce is used for all mappings, this is allowed by the spec, and simplifies keeping track of them.\n+    PCPMappingNonce pcp_nonce;\n+    GetRandBytes(pcp_nonce);\n \n-static bool NatpmpDiscover(natpmp_t* natpmp, struct in_addr& external_ipv4_addr)\n-{\n-    const int r_send = sendpublicaddressrequest(natpmp);\n-    if (r_send == 2 /* OK */) {\n-        int r_read;\n-        natpmpresp_t response;\n-        do {\n-            r_read = readnatpmpresponseorretry(natpmp, &response);\n-        } while (r_read == NATPMP_TRYAGAIN);\n-\n-        if (r_read == 0) {\n-            external_ipv4_addr = response.pnu.publicaddress.addr;\n-            return true;\n-        } else if (r_read == NATPMP_ERR_NOGATEWAYSUPPORT) {\n-            LogPrintf(\"natpmp: The gateway does not support NAT-PMP.\\n\");\n+    bool ret = false;\n+    bool no_resources = false;\n+    const uint16_t private_port = GetListenPort();\n+    // Multiply the reannounce period by two, as we'll try to renew approximately halfway.\n+    const uint32_t requested_lifetime = std::chrono::seconds(PORT_MAPPING_REANNOUNCE_PERIOD * 2).count();\n+    uint32_t actual_lifetime = 0;\n+    std::chrono::milliseconds sleep_time;\n+\n+    // Local functor to handle result from PCP/NATPMP mapping.\n+    auto handle_mapping = [&](std::variant<MappingResult, MappingError> &res) -> void {\n+        if (MappingResult* mapping = std::get_if<MappingResult>(&res)) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Info, \"portmap: Added mapping %s\\n\", mapping->ToString());\n+            AddLocal(mapping->external, LOCAL_MAPPED);\n+            ret = true;\n+            actual_lifetime = std::min(actual_lifetime, mapping->lifetime);\n+        } else if (MappingError *err = std::get_if<MappingError>(&res)) {\n+            // Detailed error will already have been logged internally in respective Portmap function.\n+            if (*err == MappingError::NO_RESOURCES) {\n+                no_resources = true;\n+            }\n+        }\n+    };\n+\n+    do {\n+        actual_lifetime = requested_lifetime;\n+        no_resources = false; // Set to true if there was any \"no resources\" error.\n+        ret = false; // Set to true if any mapping succeeds.\n+\n+        // IPv4\n+        std::optional<CNetAddr> gateway4 = QueryDefaultGateway(NET_IPV4);\n+        if (!gateway4) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: Could not determine IPv4 default gateway\\n\");\n         } else {\n-            LogPrintf(\"natpmp: readnatpmpresponseorretry() for public address failed with %d error.\\n\", r_read);\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: gateway [IPv4]: %s\\n\", gateway4->ToStringAddr());\n+\n+            // Open a port mapping on whatever local address we have toward the gateway.\n+            struct in_addr inaddr_any;\n+            inaddr_any.s_addr = htonl(INADDR_ANY);\n+            auto res = PCPRequestPortMap(pcp_nonce, *gateway4, CNetAddr(inaddr_any), private_port, requested_lifetime);",
      "path": "src/mapport.cpp",
      "position": 98,
      "original_position": 98,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "23916f2a7717b463799207b4b81b5795f2e9d7e3",
      "in_reply_to_id": 1658779455,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> due to how bitcoin handles non-standard ports, we really want the configured external port\r\n\r\nBitcoin Core had a strong preference to connect to peers that listen on port `8333`. Is this what you mean? That was removed at some point.",
      "created_at": "2024-07-17T09:37:20Z",
      "updated_at": "2024-07-17T09:37:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1680748974",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1680748974"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 90,
      "original_line": 90,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1680885121",
      "pull_request_review_id": 2182637583,
      "id": 1680885121,
      "node_id": "PRRC_kwDOABII585kMEWB",
      "diff_hunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/pcp.h>\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <span.h>\n+#include <util/check.h>\n+#include <util/netif.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+namespace {\n+\n+// RFC6886 NAT-PMP and RFC6887 Port Control Protocol (PCP) implementation.\n+// NAT-PMP and PCP use network byte order (big-endian).\n+\n+// NAT-PMP (v0) protocol constants.\n+//! NAT-PMP uses a fixed server port number (RFC6887 section 1.1).\n+constexpr uint16_t NATPMP_SERVER_PORT = 5351;\n+//! Version byte for NATPMP (RFC6886 1.1)\n+constexpr uint8_t NATPMP_VERSION = 0;\n+//! Request opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_REQUEST = 0x00;\n+//! Response opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_RESPONSE = 0x80;\n+//! Get external address (RFC6886 3.2)\n+constexpr uint8_t NATPMP_OP_GETEXTERNAL = 0x00;\n+//! Map TCP port (RFC6886 3.3)\n+constexpr uint8_t NATPMP_OP_MAP_TCP = 0x02;\n+//! Shared request header size in bytes.\n+constexpr size_t NATPMP_REQUEST_HDR_SIZE = 2;\n+//! Shared response header (minimum) size in bytes.\n+constexpr size_t NATPMP_RESPONSE_HDR_SIZE = 8;\n+//! GETEXTERNAL request size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 0;\n+//! GETEXTERNAL response size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 4;\n+//! MAP request size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 10;\n+//! MAP response size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 8;\n+\n+// Shared header offsets (RFC6886 3.2, 3.3), relative to start of packet.\n+//!  Offset of version field in packets.\n+constexpr size_t NATPMP_HDR_VERSION_OFS = 0;\n+//!  Offset of opcode field in packets\n+constexpr size_t NATPMP_HDR_OP_OFS = 1;\n+//!  Offset of result code in packets. Result codes are 16 bit in NAT-PMP instead of 8 bit in PCP.\n+constexpr size_t NATPMP_RESPONSE_HDR_RESULT_OFS = 2;\n+\n+// GETEXTERNAL response offsets (RFC6886 3.2), relative to start of packet.\n+//!  Returned external address\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_IP_OFS = 8;\n+\n+// MAP request offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port to be mapped.\n+constexpr size_t NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS = 4;\n+//!  Suggested external port for mapping.\n+constexpr size_t NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS = 6;\n+//!  Requested port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_REQUEST_LIFETIME_OFS = 8;\n+\n+// MAP response offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port for mapping (will match internal port of request).\n+constexpr size_t NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS = 8;\n+//!  External port for mapping.\n+constexpr size_t NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS = 10;\n+//!  Created port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_RESPONSE_LIFETIME_OFS = 12;\n+\n+// Relevant NETPMP result codes (RFC6886 3.5).\n+//! Result code representing success status.\n+constexpr uint8_t NATPMP_RESULT_SUCCESS = 0;\n+//! Result code representing unsupported version.\n+constexpr uint8_t NATPMP_RESULT_UNSUPP_VERSION = 1;\n+//! Result code representing lack of resources.\n+constexpr uint8_t NATPMP_RESULT_NO_RESOURCES = 4;\n+\n+//! Mapping of NATPMP result code to string (RFC6886 3.5). Result codes <=2 match PCP.\n+const std::map<uint8_t, std::string> NATPMP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"NETWORK_FAILURE\"},\n+    {4,  \"NO_RESOURCES\"},\n+    {5,  \"UNSUPP_OPCODE\"},\n+};\n+\n+// PCP (v2) protocol constants.\n+//! Maximum packet size in bytes (RFC6887 section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (RFC6887 section 19.1). Shared with NAT-PMP.\n+constexpr uint16_t PCP_SERVER_PORT = NATPMP_SERVER_PORT;\n+//! Version byte. 0 is NAT-PMP (RFC6886), 1 is forbidden, 2 for PCP (RFC6887).\n+constexpr uint8_t PCP_VERSION = 2;\n+//! PCP Request Header. See RFC6887 section 7.1. Shared with NAT-PMP.\n+constexpr uint8_t PCP_REQUEST = NATPMP_REQUEST; // R = 0\n+//! PCP Response Header. See RFC6887 section 7.2. Shared with NAT-PMP.\n+constexpr uint8_t PCP_RESPONSE = NATPMP_RESPONSE; // R = 1\n+//! Map opcode. See RFC6887 section 19.2\n+constexpr uint8_t PCP_OP_MAP = 0x01;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Request and response header size in bytes (RFC6887 section 7.1).\n+constexpr size_t PCP_HDR_SIZE = 24;\n+//! Map request and response size in bytes (RFC6887 section 11.1).\n+constexpr size_t PCP_MAP_SIZE = 36;\n+\n+// Header offsets shared between request and responses (RFC6887 7.1, 7.2), relative to start of packet.\n+//!  Version field (1 byte).\n+constexpr size_t PCP_HDR_VERSION_OFS = NATPMP_HDR_VERSION_OFS;\n+//!  Opcode field (1 byte).\n+constexpr size_t PCP_HDR_OP_OFS = NATPMP_HDR_OP_OFS;\n+//!  Requested lifetime (request), granted lifetime (response) (2 bytes).\n+constexpr size_t PCP_HDR_LIFETIME_OFS = 4;\n+\n+// Request header offsets (RFC6887 7.1), relative to start of packet.\n+//!  PCP client's IP address (16 bytes).\n+constexpr size_t PCP_REQUEST_HDR_IP_OFS = 8;\n+\n+// Response header offsets (RFC6887 7.2), relative to start of packet.\n+//!  Result code (1 byte).\n+constexpr size_t PCP_RESPONSE_HDR_RESULT_OFS = 3;\n+\n+// MAP request/response offsets (RFC6887 11.1), relative to start of opcode-specific data.\n+//!  Mapping nonce (12 bytes).\n+constexpr size_t PCP_MAP_NONCE_OFS = 0;\n+//!  Protocol (1 byte).\n+constexpr size_t PCP_MAP_PROTOCOL_OFS = 12;\n+//!  Internal port for mapping (2 bytes).\n+constexpr size_t PCP_MAP_INTERNAL_PORT_OFS = 16;\n+//!  Suggested external port (request), assigned external port (response) (2 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_PORT_OFS = 18;\n+//!  Suggested external IP (request), assigned external IP (response) (16 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_IP_OFS = 20;\n+\n+//! Result code representing success (RFC6887 7.4), shared with NAT-PMP.\n+constexpr uint8_t PCP_RESULT_SUCCESS = NATPMP_RESULT_SUCCESS;\n+//! Result code representing lack of resources (RFC6887 7.4).\n+constexpr uint8_t PCP_RESULT_NO_RESOURCES = 8;\n+\n+//! Mapping of PCP result code to string (RFC6887 7.4). Result codes <=2 match NAT-PMP.\n+const std::map<uint8_t, std::string> PCP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"MALFORMED_REQUEST\"},\n+    {4,  \"UNSUPP_OPCODE\"},\n+    {5,  \"UNSUPP_OPTION\"},\n+    {6,  \"MALFORMED_OPTION\"},\n+    {7,  \"NETWORK_FAILURE\"},\n+    {8,  \"NO_RESOURCES\"},\n+    {9,  \"UNSUPP_PROTOCOL\"},\n+    {10, \"USER_EX_QUOTA\"},\n+    {11, \"CANNOT_PROVIDE_EXTERNAL\"},\n+    {12, \"ADDRESS_MISMATCH\"},\n+    {13, \"EXCESSIVE_REMOTE_PEER\"},\n+};\n+\n+//! Return human-readable string from NATPMP result code.\n+std::string NATPMPResultString(uint8_t result_code)\n+{\n+    auto result_i = NATPMP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == NATPMP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Return human-readable string from PCP result code.\n+std::string PCPResultString(uint8_t result_code)\n+{\n+    auto result_i = PCP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == PCP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Wrap address in IPv6 according to RFC6887. wrapped_addr needs to be able to store 16 bytes.\n+[[nodiscard]] bool PCPWrapAddress(Span<uint8_t> wrapped_addr, const CNetAddr &addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (addr.IsIPv4()) {\n+        struct in_addr addr4;\n+        if (!addr.GetInAddr(&addr4)) return false;\n+        // Section 5: \"When the address field holds an IPv4 address, an IPv4-mapped IPv6 address [RFC4291] is used (::ffff:0:0/96).\"\n+        std::memcpy(wrapped_addr.data(), IPV4_IN_IPV6_PREFIX.data(), IPV4_IN_IPV6_PREFIX.size());\n+        std::memcpy(wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), &addr4, ADDR_IPV4_SIZE);\n+        return true;\n+    } else if (addr.IsIPv6()) {\n+        struct in6_addr addr6;\n+        if (!addr.GetIn6Addr(&addr6)) return false;\n+        std::memcpy(wrapped_addr.data(), &addr6, ADDR_IPV6_SIZE);\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+//! Unwrap PCP-encoded address according to RFC6887.\n+CNetAddr PCPUnwrapAddress(Span<const uint8_t> wrapped_addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (util::HasPrefix(wrapped_addr, IPV4_IN_IPV6_PREFIX)) {\n+        struct in_addr addr4;\n+        std::memcpy(&addr4, wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), ADDR_IPV4_SIZE);\n+        return CNetAddr(addr4);\n+    } else {\n+        struct in6_addr addr6;\n+        std::memcpy(&addr6, wrapped_addr.data(), ADDR_IPV6_SIZE);\n+        return CNetAddr(addr6);\n+    }\n+}\n+\n+//! PCP or NAT-PMP send-receive loop.\n+std::optional<std::vector<uint8_t>> PCPSendRecv(Sock &sock, const std::string &protocol, Span<const uint8_t> request, int num_tries,\n+        std::chrono::milliseconds timeout_per_try,\n+        std::function<bool(Span<const uint8_t>)> check_packet)\n+{\n+    using namespace std::chrono;\n+    // UDP is a potentially lossy protocol, so we try to send again a few times.\n+    uint8_t response[PCP_MAX_SIZE];\n+    bool got_response = false;\n+    int recvsz = 0;\n+    for (int ntry = 0; !got_response && ntry < num_tries; ++ntry) {\n+        if (ntry > 0) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Retrying (%d)\\n\", protocol, ntry);\n+        }\n+        // Dispatch packet to gateway.\n+        if (sock.Send(request.data(), request.size(), 0) != static_cast<ssize_t>(request.size())) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not send request: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+            return std::nullopt; // Network-level error, probably no use retrying.\n+        }\n+\n+        // Wait for response(s) until we get a valid response, a network error, or time out.\n+        auto cur_time = time_point_cast<milliseconds>(steady_clock::now());\n+        auto deadline = cur_time + timeout_per_try;\n+        while ((cur_time = time_point_cast<milliseconds>(steady_clock::now())) < deadline) {\n+            Sock::Event occurred = 0;\n+            if (!sock.Wait(deadline - cur_time, Sock::RECV, &occurred)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not wait on socket: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            if (!occurred) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Timeout\\n\", protocol);\n+                break; // Retry.\n+            }\n+\n+            // Receive response.\n+            recvsz = sock.Recv(response, sizeof(response), MSG_DONTWAIT);\n+            if (recvsz < 0) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not receive response: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Received response of %d bytes: %s\\n\", protocol, recvsz, HexStr(Span(response, recvsz)));\n+\n+            if (check_packet(Span<uint8_t>(response, recvsz))) {\n+                got_response = true; // Got expected response, break from receive loop as well as from retry loop.\n+                break;\n+            }\n+        }\n+    }\n+    if (!got_response) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Giving up after %d tries\\n\", protocol, num_tries);\n+        return std::nullopt;\n+    }\n+    return std::vector<uint8_t>(response, response + recvsz);\n+}\n+\n+}\n+\n+std::variant<MappingResult, MappingError> NATPMPRequestPortMap(const CNetAddr &gateway, uint16_t port, uint32_t lifetime, int num_tries, std::chrono::milliseconds timeout_per_try)\n+{\n+    struct sockaddr_storage dest_addr;\n+    socklen_t dest_addrlen = sizeof(struct sockaddr_storage);\n+\n+    LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"natpmp: Requesting port mapping port %d from gateway %s\\n\", port, gateway.ToStringAddr());\n+\n+    // Validate gateway, make sure it's IPv4. NAT-PMP does not support IPv6.\n+    if (!CService(gateway, PCP_SERVER_PORT).GetSockAddr((struct sockaddr*)&dest_addr, &dest_addrlen)) return MappingError::NETWORK_ERROR;\n+    if (dest_addr.ss_family != AF_INET) return MappingError::NETWORK_ERROR;\n+\n+    // Create IPv4 UDP socket\n+    auto sock{CreateSock(AF_INET, SOCK_DGRAM, IPPROTO_UDP)};\n+    if (!sock) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Could not create UDP socket: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Associate UDP socket to gateway.\n+    if (sock->Connect((struct sockaddr*)&dest_addr, dest_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Could not connect to gateway: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Use getsockname to get the address toward the default gateway (the internal address).\n+    struct sockaddr_in internal;\n+    socklen_t internal_addrlen = sizeof(struct sockaddr_in);\n+    if (sock->GetSockName((struct sockaddr*)&internal, &internal_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Could not get sock name: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Request external IP address (RFC6886 section 3.2).\n+    std::vector<uint8_t> request(NATPMP_GETEXTERNAL_REQUEST_SIZE);\n+    request[NATPMP_HDR_VERSION_OFS] = NATPMP_VERSION;\n+    request[NATPMP_HDR_OP_OFS] = NATPMP_REQUEST | NATPMP_OP_GETEXTERNAL;\n+\n+    auto recv_res = PCPSendRecv(*sock, \"natpmp\", request, num_tries, timeout_per_try,\n+        [&](const Span<const uint8_t> response) -> bool {\n+            if (response.size() < NATPMP_GETEXTERNAL_RESPONSE_SIZE) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response too small\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            if (response[NATPMP_HDR_VERSION_OFS] != NATPMP_VERSION || response[NATPMP_HDR_OP_OFS] != (NATPMP_RESPONSE | NATPMP_OP_GETEXTERNAL)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response to wrong command\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            return true;\n+        });\n+\n+    struct in_addr external_addr;\n+    if (recv_res) {\n+        const std::span<const uint8_t> response = *recv_res;\n+\n+        Assume(response.size() >= NATPMP_GETEXTERNAL_RESPONSE_SIZE);\n+        uint16_t result_code = ReadBE16(response.data() + NATPMP_RESPONSE_HDR_RESULT_OFS);\n+        if (result_code != NATPMP_RESULT_SUCCESS) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Getting external address failed with result %s\\n\", NATPMPResultString(result_code));\n+            return MappingError::PROTOCOL_ERROR;\n+        }\n+\n+        std::memcpy(&external_addr, response.data() + NATPMP_GETEXTERNAL_RESPONSE_IP_OFS, ADDR_IPV4_SIZE);\n+    } else {\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Create TCP mapping request (RFC6886 section 3.3).\n+    request = std::vector<uint8_t>(NATPMP_MAP_REQUEST_SIZE);\n+    request[NATPMP_HDR_VERSION_OFS] = NATPMP_VERSION;\n+    request[NATPMP_HDR_OP_OFS] = NATPMP_REQUEST | NATPMP_OP_MAP_TCP;\n+    WriteBE16(request.data() + NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS, port);\n+    WriteBE16(request.data() + NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS, port);\n+    WriteBE32(request.data() + NATPMP_MAP_REQUEST_LIFETIME_OFS, lifetime);\n+\n+    recv_res = PCPSendRecv(*sock, \"natpmp\", request, num_tries, timeout_per_try,\n+        [&](const Span<const uint8_t> response) -> bool {\n+            if (response.size() < NATPMP_MAP_RESPONSE_SIZE) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response too small\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            if (response[0] != NATPMP_VERSION || response[1] != (NATPMP_RESPONSE | NATPMP_OP_MAP_TCP)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response to wrong command\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            uint16_t internal_port = ReadBE16(response.data() + NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS);\n+            if (internal_port != port) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response port doesn't match request\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            return true;\n+        });\n+\n+    if (recv_res) {\n+        const std::span<uint8_t> response = *recv_res;\n+\n+        Assume(response.size() >= NATPMP_MAP_RESPONSE_SIZE);\n+        uint16_t result_code = ReadBE16(response.data() + NATPMP_RESPONSE_HDR_RESULT_OFS);\n+        if (result_code != NATPMP_RESULT_SUCCESS) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Port mapping failed with result %s\\n\", NATPMPResultString(result_code));\n+            if (result_code == NATPMP_RESULT_NO_RESOURCES) {\n+                return MappingError::NO_RESOURCES;\n+            }\n+            return MappingError::PROTOCOL_ERROR;\n+        }\n+\n+        uint32_t lifetime_ret = ReadBE32(response.data() + NATPMP_MAP_RESPONSE_LIFETIME_OFS);\n+        uint16_t external_port = ReadBE16(response.data() + NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS);\n+        return MappingResult(NATPMP_VERSION, CService(internal.sin_addr, port), CService(external_addr, external_port), lifetime_ret);\n+    } else {\n+        return MappingError::NETWORK_ERROR;\n+    }\n+}\n+\n+std::variant<MappingResult, MappingError> PCPRequestPortMap(const PCPMappingNonce &nonce, const CNetAddr &gateway, const CNetAddr &bind, uint16_t port, uint32_t lifetime, int num_tries, std::chrono::milliseconds timeout_per_try)\n+{\n+    struct sockaddr_storage dest_addr, bind_addr;\n+    socklen_t dest_addrlen = sizeof(struct sockaddr_storage), bind_addrlen = sizeof(struct sockaddr_storage);\n+\n+    LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"pcp: Requesting port mapping for addr %s port %d from gateway %s\\n\", bind.ToStringAddr(), port, gateway.ToStringAddr());\n+\n+    // Validate addresses, make sure they're the same network family.\n+    if (!CService(gateway, PCP_SERVER_PORT).GetSockAddr((struct sockaddr*)&dest_addr, &dest_addrlen)) return MappingError::NETWORK_ERROR;\n+    if (!CService(bind, 0).GetSockAddr((struct sockaddr*)&bind_addr, &bind_addrlen)) return MappingError::NETWORK_ERROR;\n+    if (dest_addr.ss_family != bind_addr.ss_family) return MappingError::NETWORK_ERROR;\n+\n+    // Create UDP socket (IPv4 or IPv6 based on provided gateway).\n+    auto sock{CreateSock(dest_addr.ss_family, SOCK_DGRAM, IPPROTO_UDP)};\n+    if (!sock) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp: Could not create UDP socket: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Make sure that we send from requested destination address, anything else will be\n+    // rejected by a security-conscious router.\n+    if (sock->Bind((struct sockaddr*)&bind_addr, bind_addrlen) != 0) {",
      "path": "src/util/pcp.cpp",
      "position": 408,
      "original_position": 408,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "23916f2a7717b463799207b4b81b5795f2e9d7e3",
      "in_reply_to_id": 1657164986,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I admit I am somewhat confused.\r\n\r\nDo we assume that for IPv6, address translation is never done (e.g. https://www.rfc-editor.org/rfc/rfc6296) and that for IPv6 we only need to pinhole the firewall?\r\nEdit: apparently yes, since we only process `IsRoutable()` addresses returned by `GetLocalAddresses()`.\r\n\r\n> For IPv6 we know what internal address we want, and what external address we want\r\n\r\nYou mean that both internal and external are the same and we get that from `GetLocalAddresses()`?",
      "created_at": "2024-07-17T11:24:51Z",
      "updated_at": "2024-07-17T12:09:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1680885121",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1680885121"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": 406,
      "original_start_line": 406,
      "start_side": "RIGHT",
      "line": 408,
      "original_line": 408,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1680951137",
      "pull_request_review_id": 2182755464,
      "id": 1680951137,
      "node_id": "PRRC_kwDOABII585kMUdh",
      "diff_hunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/pcp.h>\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <span.h>\n+#include <util/check.h>\n+#include <util/netif.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+namespace {\n+\n+// RFC6886 NAT-PMP and RFC6887 Port Control Protocol (PCP) implementation.\n+// NAT-PMP and PCP use network byte order (big-endian).\n+\n+// NAT-PMP (v0) protocol constants.\n+//! NAT-PMP uses a fixed server port number (RFC6887 section 1.1).\n+constexpr uint16_t NATPMP_SERVER_PORT = 5351;\n+//! Version byte for NATPMP (RFC6886 1.1)\n+constexpr uint8_t NATPMP_VERSION = 0;\n+//! Request opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_REQUEST = 0x00;\n+//! Response opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_RESPONSE = 0x80;\n+//! Get external address (RFC6886 3.2)\n+constexpr uint8_t NATPMP_OP_GETEXTERNAL = 0x00;\n+//! Map TCP port (RFC6886 3.3)\n+constexpr uint8_t NATPMP_OP_MAP_TCP = 0x02;\n+//! Shared request header size in bytes.\n+constexpr size_t NATPMP_REQUEST_HDR_SIZE = 2;\n+//! Shared response header (minimum) size in bytes.\n+constexpr size_t NATPMP_RESPONSE_HDR_SIZE = 8;\n+//! GETEXTERNAL request size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 0;\n+//! GETEXTERNAL response size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 4;\n+//! MAP request size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 10;\n+//! MAP response size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 8;\n+\n+// Shared header offsets (RFC6886 3.2, 3.3), relative to start of packet.\n+//!  Offset of version field in packets.\n+constexpr size_t NATPMP_HDR_VERSION_OFS = 0;\n+//!  Offset of opcode field in packets\n+constexpr size_t NATPMP_HDR_OP_OFS = 1;\n+//!  Offset of result code in packets. Result codes are 16 bit in NAT-PMP instead of 8 bit in PCP.\n+constexpr size_t NATPMP_RESPONSE_HDR_RESULT_OFS = 2;\n+\n+// GETEXTERNAL response offsets (RFC6886 3.2), relative to start of packet.\n+//!  Returned external address\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_IP_OFS = 8;\n+\n+// MAP request offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port to be mapped.\n+constexpr size_t NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS = 4;\n+//!  Suggested external port for mapping.\n+constexpr size_t NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS = 6;\n+//!  Requested port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_REQUEST_LIFETIME_OFS = 8;\n+\n+// MAP response offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port for mapping (will match internal port of request).\n+constexpr size_t NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS = 8;\n+//!  External port for mapping.\n+constexpr size_t NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS = 10;\n+//!  Created port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_RESPONSE_LIFETIME_OFS = 12;\n+\n+// Relevant NETPMP result codes (RFC6886 3.5).\n+//! Result code representing success status.\n+constexpr uint8_t NATPMP_RESULT_SUCCESS = 0;\n+//! Result code representing unsupported version.\n+constexpr uint8_t NATPMP_RESULT_UNSUPP_VERSION = 1;\n+//! Result code representing lack of resources.\n+constexpr uint8_t NATPMP_RESULT_NO_RESOURCES = 4;\n+\n+//! Mapping of NATPMP result code to string (RFC6886 3.5). Result codes <=2 match PCP.\n+const std::map<uint8_t, std::string> NATPMP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"NETWORK_FAILURE\"},\n+    {4,  \"NO_RESOURCES\"},\n+    {5,  \"UNSUPP_OPCODE\"},\n+};\n+\n+// PCP (v2) protocol constants.\n+//! Maximum packet size in bytes (RFC6887 section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (RFC6887 section 19.1). Shared with NAT-PMP.\n+constexpr uint16_t PCP_SERVER_PORT = NATPMP_SERVER_PORT;\n+//! Version byte. 0 is NAT-PMP (RFC6886), 1 is forbidden, 2 for PCP (RFC6887).\n+constexpr uint8_t PCP_VERSION = 2;\n+//! PCP Request Header. See RFC6887 section 7.1. Shared with NAT-PMP.\n+constexpr uint8_t PCP_REQUEST = NATPMP_REQUEST; // R = 0\n+//! PCP Response Header. See RFC6887 section 7.2. Shared with NAT-PMP.\n+constexpr uint8_t PCP_RESPONSE = NATPMP_RESPONSE; // R = 1\n+//! Map opcode. See RFC6887 section 19.2\n+constexpr uint8_t PCP_OP_MAP = 0x01;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Request and response header size in bytes (RFC6887 section 7.1).\n+constexpr size_t PCP_HDR_SIZE = 24;\n+//! Map request and response size in bytes (RFC6887 section 11.1).\n+constexpr size_t PCP_MAP_SIZE = 36;\n+\n+// Header offsets shared between request and responses (RFC6887 7.1, 7.2), relative to start of packet.\n+//!  Version field (1 byte).\n+constexpr size_t PCP_HDR_VERSION_OFS = NATPMP_HDR_VERSION_OFS;\n+//!  Opcode field (1 byte).\n+constexpr size_t PCP_HDR_OP_OFS = NATPMP_HDR_OP_OFS;\n+//!  Requested lifetime (request), granted lifetime (response) (2 bytes).\n+constexpr size_t PCP_HDR_LIFETIME_OFS = 4;\n+\n+// Request header offsets (RFC6887 7.1), relative to start of packet.\n+//!  PCP client's IP address (16 bytes).\n+constexpr size_t PCP_REQUEST_HDR_IP_OFS = 8;\n+\n+// Response header offsets (RFC6887 7.2), relative to start of packet.\n+//!  Result code (1 byte).\n+constexpr size_t PCP_RESPONSE_HDR_RESULT_OFS = 3;\n+\n+// MAP request/response offsets (RFC6887 11.1), relative to start of opcode-specific data.\n+//!  Mapping nonce (12 bytes).\n+constexpr size_t PCP_MAP_NONCE_OFS = 0;\n+//!  Protocol (1 byte).\n+constexpr size_t PCP_MAP_PROTOCOL_OFS = 12;\n+//!  Internal port for mapping (2 bytes).\n+constexpr size_t PCP_MAP_INTERNAL_PORT_OFS = 16;\n+//!  Suggested external port (request), assigned external port (response) (2 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_PORT_OFS = 18;\n+//!  Suggested external IP (request), assigned external IP (response) (16 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_IP_OFS = 20;\n+\n+//! Result code representing success (RFC6887 7.4), shared with NAT-PMP.\n+constexpr uint8_t PCP_RESULT_SUCCESS = NATPMP_RESULT_SUCCESS;\n+//! Result code representing lack of resources (RFC6887 7.4).\n+constexpr uint8_t PCP_RESULT_NO_RESOURCES = 8;\n+\n+//! Mapping of PCP result code to string (RFC6887 7.4). Result codes <=2 match NAT-PMP.\n+const std::map<uint8_t, std::string> PCP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"MALFORMED_REQUEST\"},\n+    {4,  \"UNSUPP_OPCODE\"},\n+    {5,  \"UNSUPP_OPTION\"},\n+    {6,  \"MALFORMED_OPTION\"},\n+    {7,  \"NETWORK_FAILURE\"},\n+    {8,  \"NO_RESOURCES\"},\n+    {9,  \"UNSUPP_PROTOCOL\"},\n+    {10, \"USER_EX_QUOTA\"},\n+    {11, \"CANNOT_PROVIDE_EXTERNAL\"},\n+    {12, \"ADDRESS_MISMATCH\"},\n+    {13, \"EXCESSIVE_REMOTE_PEER\"},\n+};\n+\n+//! Return human-readable string from NATPMP result code.\n+std::string NATPMPResultString(uint8_t result_code)\n+{\n+    auto result_i = NATPMP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == NATPMP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Return human-readable string from PCP result code.\n+std::string PCPResultString(uint8_t result_code)\n+{\n+    auto result_i = PCP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == PCP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Wrap address in IPv6 according to RFC6887. wrapped_addr needs to be able to store 16 bytes.\n+[[nodiscard]] bool PCPWrapAddress(Span<uint8_t> wrapped_addr, const CNetAddr &addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (addr.IsIPv4()) {\n+        struct in_addr addr4;\n+        if (!addr.GetInAddr(&addr4)) return false;\n+        // Section 5: \"When the address field holds an IPv4 address, an IPv4-mapped IPv6 address [RFC4291] is used (::ffff:0:0/96).\"\n+        std::memcpy(wrapped_addr.data(), IPV4_IN_IPV6_PREFIX.data(), IPV4_IN_IPV6_PREFIX.size());\n+        std::memcpy(wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), &addr4, ADDR_IPV4_SIZE);\n+        return true;\n+    } else if (addr.IsIPv6()) {\n+        struct in6_addr addr6;\n+        if (!addr.GetIn6Addr(&addr6)) return false;\n+        std::memcpy(wrapped_addr.data(), &addr6, ADDR_IPV6_SIZE);\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+//! Unwrap PCP-encoded address according to RFC6887.\n+CNetAddr PCPUnwrapAddress(Span<const uint8_t> wrapped_addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (util::HasPrefix(wrapped_addr, IPV4_IN_IPV6_PREFIX)) {\n+        struct in_addr addr4;\n+        std::memcpy(&addr4, wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), ADDR_IPV4_SIZE);\n+        return CNetAddr(addr4);\n+    } else {\n+        struct in6_addr addr6;\n+        std::memcpy(&addr6, wrapped_addr.data(), ADDR_IPV6_SIZE);\n+        return CNetAddr(addr6);\n+    }\n+}\n+\n+//! PCP or NAT-PMP send-receive loop.\n+std::optional<std::vector<uint8_t>> PCPSendRecv(Sock &sock, const std::string &protocol, Span<const uint8_t> request, int num_tries,\n+        std::chrono::milliseconds timeout_per_try,\n+        std::function<bool(Span<const uint8_t>)> check_packet)\n+{\n+    using namespace std::chrono;\n+    // UDP is a potentially lossy protocol, so we try to send again a few times.\n+    uint8_t response[PCP_MAX_SIZE];\n+    bool got_response = false;\n+    int recvsz = 0;\n+    for (int ntry = 0; !got_response && ntry < num_tries; ++ntry) {\n+        if (ntry > 0) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Retrying (%d)\\n\", protocol, ntry);\n+        }\n+        // Dispatch packet to gateway.\n+        if (sock.Send(request.data(), request.size(), 0) != static_cast<ssize_t>(request.size())) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not send request: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+            return std::nullopt; // Network-level error, probably no use retrying.\n+        }\n+\n+        // Wait for response(s) until we get a valid response, a network error, or time out.\n+        auto cur_time = time_point_cast<milliseconds>(steady_clock::now());\n+        auto deadline = cur_time + timeout_per_try;\n+        while ((cur_time = time_point_cast<milliseconds>(steady_clock::now())) < deadline) {\n+            Sock::Event occurred = 0;\n+            if (!sock.Wait(deadline - cur_time, Sock::RECV, &occurred)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not wait on socket: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            if (!occurred) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Timeout\\n\", protocol);\n+                break; // Retry.\n+            }\n+\n+            // Receive response.\n+            recvsz = sock.Recv(response, sizeof(response), MSG_DONTWAIT);\n+            if (recvsz < 0) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"%s: Could not receive response: %s\\n\", protocol, NetworkErrorString(WSAGetLastError()));\n+                return std::nullopt; // Network-level error, probably no use retrying.\n+            }\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Received response of %d bytes: %s\\n\", protocol, recvsz, HexStr(Span(response, recvsz)));\n+\n+            if (check_packet(Span<uint8_t>(response, recvsz))) {\n+                got_response = true; // Got expected response, break from receive loop as well as from retry loop.\n+                break;\n+            }\n+        }\n+    }\n+    if (!got_response) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"%s: Giving up after %d tries\\n\", protocol, num_tries);\n+        return std::nullopt;\n+    }\n+    return std::vector<uint8_t>(response, response + recvsz);\n+}\n+\n+}\n+\n+std::variant<MappingResult, MappingError> NATPMPRequestPortMap(const CNetAddr &gateway, uint16_t port, uint32_t lifetime, int num_tries, std::chrono::milliseconds timeout_per_try)\n+{\n+    struct sockaddr_storage dest_addr;\n+    socklen_t dest_addrlen = sizeof(struct sockaddr_storage);\n+\n+    LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"natpmp: Requesting port mapping port %d from gateway %s\\n\", port, gateway.ToStringAddr());\n+\n+    // Validate gateway, make sure it's IPv4. NAT-PMP does not support IPv6.\n+    if (!CService(gateway, PCP_SERVER_PORT).GetSockAddr((struct sockaddr*)&dest_addr, &dest_addrlen)) return MappingError::NETWORK_ERROR;\n+    if (dest_addr.ss_family != AF_INET) return MappingError::NETWORK_ERROR;\n+\n+    // Create IPv4 UDP socket\n+    auto sock{CreateSock(AF_INET, SOCK_DGRAM, IPPROTO_UDP)};\n+    if (!sock) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Could not create UDP socket: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Associate UDP socket to gateway.\n+    if (sock->Connect((struct sockaddr*)&dest_addr, dest_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Could not connect to gateway: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Use getsockname to get the address toward the default gateway (the internal address).\n+    struct sockaddr_in internal;\n+    socklen_t internal_addrlen = sizeof(struct sockaddr_in);\n+    if (sock->GetSockName((struct sockaddr*)&internal, &internal_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Could not get sock name: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Request external IP address (RFC6886 section 3.2).\n+    std::vector<uint8_t> request(NATPMP_GETEXTERNAL_REQUEST_SIZE);\n+    request[NATPMP_HDR_VERSION_OFS] = NATPMP_VERSION;\n+    request[NATPMP_HDR_OP_OFS] = NATPMP_REQUEST | NATPMP_OP_GETEXTERNAL;\n+\n+    auto recv_res = PCPSendRecv(*sock, \"natpmp\", request, num_tries, timeout_per_try,\n+        [&](const Span<const uint8_t> response) -> bool {\n+            if (response.size() < NATPMP_GETEXTERNAL_RESPONSE_SIZE) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response too small\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            if (response[NATPMP_HDR_VERSION_OFS] != NATPMP_VERSION || response[NATPMP_HDR_OP_OFS] != (NATPMP_RESPONSE | NATPMP_OP_GETEXTERNAL)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response to wrong command\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            return true;\n+        });\n+\n+    struct in_addr external_addr;\n+    if (recv_res) {\n+        const std::span<const uint8_t> response = *recv_res;\n+\n+        Assume(response.size() >= NATPMP_GETEXTERNAL_RESPONSE_SIZE);\n+        uint16_t result_code = ReadBE16(response.data() + NATPMP_RESPONSE_HDR_RESULT_OFS);\n+        if (result_code != NATPMP_RESULT_SUCCESS) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Getting external address failed with result %s\\n\", NATPMPResultString(result_code));\n+            return MappingError::PROTOCOL_ERROR;\n+        }\n+\n+        std::memcpy(&external_addr, response.data() + NATPMP_GETEXTERNAL_RESPONSE_IP_OFS, ADDR_IPV4_SIZE);\n+    } else {\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Create TCP mapping request (RFC6886 section 3.3).\n+    request = std::vector<uint8_t>(NATPMP_MAP_REQUEST_SIZE);\n+    request[NATPMP_HDR_VERSION_OFS] = NATPMP_VERSION;\n+    request[NATPMP_HDR_OP_OFS] = NATPMP_REQUEST | NATPMP_OP_MAP_TCP;\n+    WriteBE16(request.data() + NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS, port);\n+    WriteBE16(request.data() + NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS, port);\n+    WriteBE32(request.data() + NATPMP_MAP_REQUEST_LIFETIME_OFS, lifetime);\n+\n+    recv_res = PCPSendRecv(*sock, \"natpmp\", request, num_tries, timeout_per_try,\n+        [&](const Span<const uint8_t> response) -> bool {\n+            if (response.size() < NATPMP_MAP_RESPONSE_SIZE) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response too small\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            if (response[0] != NATPMP_VERSION || response[1] != (NATPMP_RESPONSE | NATPMP_OP_MAP_TCP)) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response to wrong command\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            uint16_t internal_port = ReadBE16(response.data() + NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS);\n+            if (internal_port != port) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Response port doesn't match request\\n\");\n+                return false; // Wasn't response to what we expected, try receiving next packet.\n+            }\n+            return true;\n+        });\n+\n+    if (recv_res) {\n+        const std::span<uint8_t> response = *recv_res;\n+\n+        Assume(response.size() >= NATPMP_MAP_RESPONSE_SIZE);\n+        uint16_t result_code = ReadBE16(response.data() + NATPMP_RESPONSE_HDR_RESULT_OFS);\n+        if (result_code != NATPMP_RESULT_SUCCESS) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"natpmp: Port mapping failed with result %s\\n\", NATPMPResultString(result_code));\n+            if (result_code == NATPMP_RESULT_NO_RESOURCES) {\n+                return MappingError::NO_RESOURCES;\n+            }\n+            return MappingError::PROTOCOL_ERROR;\n+        }\n+\n+        uint32_t lifetime_ret = ReadBE32(response.data() + NATPMP_MAP_RESPONSE_LIFETIME_OFS);\n+        uint16_t external_port = ReadBE16(response.data() + NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS);\n+        return MappingResult(NATPMP_VERSION, CService(internal.sin_addr, port), CService(external_addr, external_port), lifetime_ret);\n+    } else {\n+        return MappingError::NETWORK_ERROR;\n+    }\n+}\n+\n+std::variant<MappingResult, MappingError> PCPRequestPortMap(const PCPMappingNonce &nonce, const CNetAddr &gateway, const CNetAddr &bind, uint16_t port, uint32_t lifetime, int num_tries, std::chrono::milliseconds timeout_per_try)\n+{\n+    struct sockaddr_storage dest_addr, bind_addr;\n+    socklen_t dest_addrlen = sizeof(struct sockaddr_storage), bind_addrlen = sizeof(struct sockaddr_storage);\n+\n+    LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"pcp: Requesting port mapping for addr %s port %d from gateway %s\\n\", bind.ToStringAddr(), port, gateway.ToStringAddr());\n+\n+    // Validate addresses, make sure they're the same network family.\n+    if (!CService(gateway, PCP_SERVER_PORT).GetSockAddr((struct sockaddr*)&dest_addr, &dest_addrlen)) return MappingError::NETWORK_ERROR;\n+    if (!CService(bind, 0).GetSockAddr((struct sockaddr*)&bind_addr, &bind_addrlen)) return MappingError::NETWORK_ERROR;\n+    if (dest_addr.ss_family != bind_addr.ss_family) return MappingError::NETWORK_ERROR;\n+\n+    // Create UDP socket (IPv4 or IPv6 based on provided gateway).\n+    auto sock{CreateSock(dest_addr.ss_family, SOCK_DGRAM, IPPROTO_UDP)};\n+    if (!sock) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp: Could not create UDP socket: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Make sure that we send from requested destination address, anything else will be\n+    // rejected by a security-conscious router.\n+    if (sock->Bind((struct sockaddr*)&bind_addr, bind_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp: Could not bind to address: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Associate UDP socket to gateway.\n+    if (sock->Connect((struct sockaddr*)&dest_addr, dest_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp: Could not connect to gateway: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+\n+    // Use getsockname to get the address toward the default gateway (the internal address),\n+    // in case we don't know what address to map\n+    // (this is only needed if bind is INADDR_ANY, but it doesn't hurt as an extra check).\n+    struct sockaddr_storage internal_addr;\n+    socklen_t internal_addrlen = sizeof(struct sockaddr_storage);\n+    if (sock->GetSockName((struct sockaddr*)&internal_addr, &internal_addrlen) != 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"pcp: Could not get sock name: %s\\n\", NetworkErrorString(WSAGetLastError()));\n+        return MappingError::NETWORK_ERROR;\n+    }\n+    CService internal;\n+    if (!internal.SetSockAddr((struct sockaddr*)&internal_addr)) return MappingError::NETWORK_ERROR;\n+    LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"pcp: Internal address after connect: %s\\n\", internal.ToStringAddr());\n+\n+    // Build request packet. Make sure the packet is zeroed so that reserved fields are zero\n+    // as required by the spec (and not potentially leak data).\n+    // Make sure there's space for the request header and MAP specific request data.\n+    std::vector<uint8_t> request(PCP_HDR_SIZE + PCP_MAP_SIZE);\n+    // Fill in request header, See RFC6887 Figure 2.\n+    size_t ofs = 0;\n+    request[ofs + PCP_HDR_VERSION_OFS] = PCP_VERSION;\n+    request[ofs + PCP_HDR_OP_OFS] = PCP_REQUEST | PCP_OP_MAP;\n+    WriteBE32(request.data() + ofs + PCP_HDR_LIFETIME_OFS, lifetime);\n+    if (!PCPWrapAddress(Span(request).subspan(ofs + PCP_REQUEST_HDR_IP_OFS, ADDR_IPV6_SIZE), internal)) return MappingError::NETWORK_ERROR;\n+\n+    ofs += PCP_HDR_SIZE;\n+\n+    // Fill in MAP request packet, See RFC6887 Figure 9.\n+    // Randomize mapping nonce (this is repeated in the response, to be able to\n+    // correlate requests and responses, and used to authenticate changes to the mapping).\n+    std::memcpy(request.data() + ofs + PCP_MAP_NONCE_OFS, nonce.data(), PCP_MAP_NONCE_SIZE);\n+    request[ofs + PCP_MAP_PROTOCOL_OFS] = PCP_PROTOCOL_TCP;\n+    WriteBE16(request.data() + ofs + PCP_MAP_INTERNAL_PORT_OFS, port);\n+    WriteBE16(request.data() + ofs + PCP_MAP_EXTERNAL_PORT_OFS, port);\n+    if (!PCPWrapAddress(Span(request).subspan(ofs + PCP_MAP_EXTERNAL_IP_OFS, ADDR_IPV6_SIZE), bind)) return MappingError::NETWORK_ERROR;",
      "path": "src/util/pcp.cpp",
      "position": 452,
      "original_position": 452,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "23916f2a7717b463799207b4b81b5795f2e9d7e3",
      "in_reply_to_id": 1658485708,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Would all-zeros work as well for IPv6 / pinholing? If yes, then this can probably be simplified to always pass all-zeros.",
      "created_at": "2024-07-17T12:17:19Z",
      "updated_at": "2024-07-17T12:17:19Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1680951137",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1680951137"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 452,
      "original_line": 452,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1681052659",
      "pull_request_review_id": 2182926171,
      "id": 1681052659,
      "node_id": "PRRC_kwDOABII585kMtPz",
      "diff_hunk": "@@ -46,104 +43,96 @@ using namespace std::chrono_literals;\n static constexpr auto PORT_MAPPING_REANNOUNCE_PERIOD{20min};\n static constexpr auto PORT_MAPPING_RETRY_PERIOD{5min};\n \n-#ifdef USE_NATPMP\n-static uint16_t g_mapport_external_port = 0;\n-static bool NatpmpInit(natpmp_t* natpmp)\n+static bool ProcessPCP()\n {\n-    const int r_init = initnatpmp(natpmp, /* detect gateway automatically */ 0, /* forced gateway - NOT APPLIED*/ 0);\n-    if (r_init == 0) return true;\n-    LogPrintf(\"natpmp: initnatpmp() failed with %d error.\\n\", r_init);\n-    return false;\n-}\n+    // The same nonce is used for all mappings, this is allowed by the spec, and simplifies keeping track of them.\n+    PCPMappingNonce pcp_nonce;\n+    GetRandBytes(pcp_nonce);\n \n-static bool NatpmpDiscover(natpmp_t* natpmp, struct in_addr& external_ipv4_addr)\n-{\n-    const int r_send = sendpublicaddressrequest(natpmp);\n-    if (r_send == 2 /* OK */) {\n-        int r_read;\n-        natpmpresp_t response;\n-        do {\n-            r_read = readnatpmpresponseorretry(natpmp, &response);\n-        } while (r_read == NATPMP_TRYAGAIN);\n-\n-        if (r_read == 0) {\n-            external_ipv4_addr = response.pnu.publicaddress.addr;\n-            return true;\n-        } else if (r_read == NATPMP_ERR_NOGATEWAYSUPPORT) {\n-            LogPrintf(\"natpmp: The gateway does not support NAT-PMP.\\n\");\n+    bool ret = false;\n+    bool no_resources = false;\n+    const uint16_t private_port = GetListenPort();\n+    // Multiply the reannounce period by two, as we'll try to renew approximately halfway.\n+    const uint32_t requested_lifetime = std::chrono::seconds(PORT_MAPPING_REANNOUNCE_PERIOD * 2).count();\n+    uint32_t actual_lifetime = 0;\n+    std::chrono::milliseconds sleep_time;\n+\n+    // Local functor to handle result from PCP/NATPMP mapping.\n+    auto handle_mapping = [&](std::variant<MappingResult, MappingError> &res) -> void {\n+        if (MappingResult* mapping = std::get_if<MappingResult>(&res)) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Info, \"portmap: Added mapping %s\\n\", mapping->ToString());\n+            AddLocal(mapping->external, LOCAL_MAPPED);\n+            ret = true;\n+            actual_lifetime = std::min(actual_lifetime, mapping->lifetime);\n+        } else if (MappingError *err = std::get_if<MappingError>(&res)) {\n+            // Detailed error will already have been logged internally in respective Portmap function.\n+            if (*err == MappingError::NO_RESOURCES) {\n+                no_resources = true;\n+            }\n+        }\n+    };\n+\n+    do {\n+        actual_lifetime = requested_lifetime;\n+        no_resources = false; // Set to true if there was any \"no resources\" error.\n+        ret = false; // Set to true if any mapping succeeds.\n+\n+        // IPv4\n+        std::optional<CNetAddr> gateway4 = QueryDefaultGateway(NET_IPV4);\n+        if (!gateway4) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: Could not determine IPv4 default gateway\\n\");\n         } else {\n-            LogPrintf(\"natpmp: readnatpmpresponseorretry() for public address failed with %d error.\\n\", r_read);\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: gateway [IPv4]: %s\\n\", gateway4->ToStringAddr());\n+\n+            // Open a port mapping on whatever local address we have toward the gateway.\n+            struct in_addr inaddr_any;\n+            inaddr_any.s_addr = htonl(INADDR_ANY);\n+            auto res = PCPRequestPortMap(pcp_nonce, *gateway4, CNetAddr(inaddr_any), private_port, requested_lifetime);\n+            MappingError* pcp_err = std::get_if<MappingError>(&res);\n+            if (pcp_err && *pcp_err == MappingError::UNSUPP_VERSION) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: Got unsupported PCP version response, falling back to NAT-PMP\\n\");\n+                res = NATPMPRequestPortMap(*gateway4, private_port, requested_lifetime);\n+            }\n+            handle_mapping(res);\n         }\n-    } else {\n-        LogPrintf(\"natpmp: sendpublicaddressrequest() failed with %d error.\\n\", r_send);\n-    }\n \n-    return false;\n-}\n+        // IPv6\n+        std::optional<CNetAddr> gateway6 = QueryDefaultGateway(NET_IPV6);\n+        if (!gateway6) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: Could not determine IPv6 default gateway\\n\");\n+        } else {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: gateway [IPv6]: %s\\n\", gateway6->ToStringAddr());\n \n-static bool NatpmpMapping(natpmp_t* natpmp, const struct in_addr& external_ipv4_addr, uint16_t private_port, bool& external_ip_discovered)\n-{\n-    const uint16_t suggested_external_port = g_mapport_external_port ? g_mapport_external_port : private_port;\n-    const int r_send = sendnewportmappingrequest(natpmp, NATPMP_PROTOCOL_TCP, private_port, suggested_external_port, 3600 /*seconds*/);\n-    if (r_send == 12 /* OK */) {\n-        int r_read;\n-        natpmpresp_t response;\n-        do {\n-            r_read = readnatpmpresponseorretry(natpmp, &response);\n-        } while (r_read == NATPMP_TRYAGAIN);\n-\n-        if (r_read == 0) {\n-            auto pm = response.pnu.newportmapping;\n-            if (private_port == pm.privateport && pm.lifetime > 0) {\n-                g_mapport_external_port = pm.mappedpublicport;\n-                const CService external{external_ipv4_addr, pm.mappedpublicport};\n-                if (!external_ip_discovered && fDiscover) {\n-                    AddLocal(external, LOCAL_MAPPED);\n-                    external_ip_discovered = true;\n-                }\n-                LogPrintf(\"natpmp: Port mapping successful. External address = %s\\n\", external.ToStringAddrPort());\n-                return true;\n-            } else {\n-                LogPrintf(\"natpmp: Port mapping failed.\\n\");\n+            // Try to open pinholes for all routable local IPv6 addresses.\n+            for (const auto &addr: GetLocalAddresses()) {\n+                if (!addr.IsRoutable() || !addr.IsIPv6()) continue;\n+                auto res = PCPRequestPortMap(pcp_nonce, *gateway6, addr, private_port, requested_lifetime);",
      "path": "src/mapport.cpp",
      "position": 146,
      "original_position": 146,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "23916f2a7717b463799207b4b81b5795f2e9d7e3",
      "in_reply_to_id": 1658879358,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Ok, I was having NAT in mind when I wrote \"is going to result in multiple mappings on the same external IPv6 address\". Sorry for the noise.",
      "created_at": "2024-07-17T13:27:30Z",
      "updated_at": "2024-07-17T13:27:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1681052659",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1681052659"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": 106,
      "original_start_line": 106,
      "start_side": "RIGHT",
      "line": 109,
      "original_line": 109,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1684368824",
      "pull_request_review_id": 2188216629,
      "id": 1684368824,
      "node_id": "PRRC_kwDOABII585kZW24",
      "diff_hunk": "@@ -46,104 +43,96 @@ using namespace std::chrono_literals;\n static constexpr auto PORT_MAPPING_REANNOUNCE_PERIOD{20min};\n static constexpr auto PORT_MAPPING_RETRY_PERIOD{5min};\n \n-#ifdef USE_NATPMP\n-static uint16_t g_mapport_external_port = 0;\n-static bool NatpmpInit(natpmp_t* natpmp)\n+static bool ProcessPCP()\n {\n-    const int r_init = initnatpmp(natpmp, /* detect gateway automatically */ 0, /* forced gateway - NOT APPLIED*/ 0);\n-    if (r_init == 0) return true;\n-    LogPrintf(\"natpmp: initnatpmp() failed with %d error.\\n\", r_init);\n-    return false;\n-}\n+    // The same nonce is used for all mappings, this is allowed by the spec, and simplifies keeping track of them.\n+    PCPMappingNonce pcp_nonce;\n+    GetRandBytes(pcp_nonce);\n \n-static bool NatpmpDiscover(natpmp_t* natpmp, struct in_addr& external_ipv4_addr)\n-{\n-    const int r_send = sendpublicaddressrequest(natpmp);\n-    if (r_send == 2 /* OK */) {\n-        int r_read;\n-        natpmpresp_t response;\n-        do {\n-            r_read = readnatpmpresponseorretry(natpmp, &response);\n-        } while (r_read == NATPMP_TRYAGAIN);\n-\n-        if (r_read == 0) {\n-            external_ipv4_addr = response.pnu.publicaddress.addr;\n-            return true;\n-        } else if (r_read == NATPMP_ERR_NOGATEWAYSUPPORT) {\n-            LogPrintf(\"natpmp: The gateway does not support NAT-PMP.\\n\");\n+    bool ret = false;\n+    bool no_resources = false;\n+    const uint16_t private_port = GetListenPort();\n+    // Multiply the reannounce period by two, as we'll try to renew approximately halfway.\n+    const uint32_t requested_lifetime = std::chrono::seconds(PORT_MAPPING_REANNOUNCE_PERIOD * 2).count();\n+    uint32_t actual_lifetime = 0;\n+    std::chrono::milliseconds sleep_time;\n+\n+    // Local functor to handle result from PCP/NATPMP mapping.\n+    auto handle_mapping = [&](std::variant<MappingResult, MappingError> &res) -> void {\n+        if (MappingResult* mapping = std::get_if<MappingResult>(&res)) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Info, \"portmap: Added mapping %s\\n\", mapping->ToString());\n+            AddLocal(mapping->external, LOCAL_MAPPED);\n+            ret = true;\n+            actual_lifetime = std::min(actual_lifetime, mapping->lifetime);\n+        } else if (MappingError *err = std::get_if<MappingError>(&res)) {\n+            // Detailed error will already have been logged internally in respective Portmap function.\n+            if (*err == MappingError::NO_RESOURCES) {\n+                no_resources = true;\n+            }\n+        }\n+    };\n+\n+    do {\n+        actual_lifetime = requested_lifetime;\n+        no_resources = false; // Set to true if there was any \"no resources\" error.\n+        ret = false; // Set to true if any mapping succeeds.\n+\n+        // IPv4\n+        std::optional<CNetAddr> gateway4 = QueryDefaultGateway(NET_IPV4);\n+        if (!gateway4) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: Could not determine IPv4 default gateway\\n\");\n         } else {\n-            LogPrintf(\"natpmp: readnatpmpresponseorretry() for public address failed with %d error.\\n\", r_read);\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: gateway [IPv4]: %s\\n\", gateway4->ToStringAddr());\n+\n+            // Open a port mapping on whatever local address we have toward the gateway.\n+            struct in_addr inaddr_any;\n+            inaddr_any.s_addr = htonl(INADDR_ANY);\n+            auto res = PCPRequestPortMap(pcp_nonce, *gateway4, CNetAddr(inaddr_any), private_port, requested_lifetime);\n+            MappingError* pcp_err = std::get_if<MappingError>(&res);\n+            if (pcp_err && *pcp_err == MappingError::UNSUPP_VERSION) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: Got unsupported PCP version response, falling back to NAT-PMP\\n\");\n+                res = NATPMPRequestPortMap(*gateway4, private_port, requested_lifetime);\n+            }\n+            handle_mapping(res);\n         }\n-    } else {\n-        LogPrintf(\"natpmp: sendpublicaddressrequest() failed with %d error.\\n\", r_send);\n-    }\n \n-    return false;\n-}\n+        // IPv6\n+        std::optional<CNetAddr> gateway6 = QueryDefaultGateway(NET_IPV6);\n+        if (!gateway6) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: Could not determine IPv6 default gateway\\n\");\n+        } else {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: gateway [IPv6]: %s\\n\", gateway6->ToStringAddr());\n \n-static bool NatpmpMapping(natpmp_t* natpmp, const struct in_addr& external_ipv4_addr, uint16_t private_port, bool& external_ip_discovered)\n-{\n-    const uint16_t suggested_external_port = g_mapport_external_port ? g_mapport_external_port : private_port;\n-    const int r_send = sendnewportmappingrequest(natpmp, NATPMP_PROTOCOL_TCP, private_port, suggested_external_port, 3600 /*seconds*/);\n-    if (r_send == 12 /* OK */) {\n-        int r_read;\n-        natpmpresp_t response;\n-        do {\n-            r_read = readnatpmpresponseorretry(natpmp, &response);\n-        } while (r_read == NATPMP_TRYAGAIN);\n-\n-        if (r_read == 0) {\n-            auto pm = response.pnu.newportmapping;\n-            if (private_port == pm.privateport && pm.lifetime > 0) {\n-                g_mapport_external_port = pm.mappedpublicport;\n-                const CService external{external_ipv4_addr, pm.mappedpublicport};\n-                if (!external_ip_discovered && fDiscover) {\n-                    AddLocal(external, LOCAL_MAPPED);\n-                    external_ip_discovered = true;\n-                }\n-                LogPrintf(\"natpmp: Port mapping successful. External address = %s\\n\", external.ToStringAddrPort());\n-                return true;\n-            } else {\n-                LogPrintf(\"natpmp: Port mapping failed.\\n\");\n+            // Try to open pinholes for all routable local IPv6 addresses.\n+            for (const auto &addr: GetLocalAddresses()) {\n+                if (!addr.IsRoutable() || !addr.IsIPv6()) continue;\n+                auto res = PCPRequestPortMap(pcp_nonce, *gateway6, addr, private_port, requested_lifetime);",
      "path": "src/mapport.cpp",
      "position": 146,
      "original_position": 146,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "23916f2a7717b463799207b4b81b5795f2e9d7e3",
      "in_reply_to_id": 1658879358,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In addition to the `-bind` [thing](https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1658949236) there is also a complication with the port: if `-bind=10.0.0.1:20000 -bind=[5566::1]:30000` has been used, then `GetListenPort()`, currently used by `mapport.cpp`, is not the right thing to do because it would return `20000`.\r\n\r\nTo resolve both, we could get the listening addresses + the correct ports from:\r\n1. `AddLocal()` / `mapLocalHost`, is called after bind (good), but also from other places and after the bind it is called only if `fDiscover` is true (bad).\r\n2. `CConnman::vhListenSocket`, has sockets that used `BF_DONT_ADVERTISE` during bind. Those should be omitted.\r\n3. `-bind` arguments, could get it from `init.cpp / connOptions`. Need to duplicate some of the logic of `CConnman::InitBinds()`.\r\n4. introduce a new global list of `addr:port`, similar but not identical to `mapLocalHost`, seems imperfect because the list is almost the same as `mapLocalHost`, ideally those addresses should be in one place with proper flags to distinguish them (or maybe not?).\r\n\r\nHere is a crude implementation of 4:\r\n\r\n<details>\r\n<summary>[patch] do 4.</summary>\r\n\r\n```diff\r\ndiff --git a/src/mapport.cpp b/src/mapport.cpp\r\nindex a1d584dae9..56d21e792b 100644\r\n--- a/src/mapport.cpp\r\n+++ b/src/mapport.cpp\r\n@@ -48,13 +48,13 @@ static bool ProcessPCP()\r\n     // The same nonce is used for all mappings, this is allowed by the spec, and simplifies keeping track of them.\r\n     PCPMappingNonce pcp_nonce;\r\n     GetRandBytes(pcp_nonce);\r\n \r\n     bool ret = false;\r\n     bool no_resources = false;\r\n-    const uint16_t private_port = GetListenPort();\r\n+    const uint16_t private_port = GetListenPort(); // XXX could be the wrong port if -bind is used\r\n     // Multiply the reannounce period by two, as we'll try to renew approximately halfway.\r\n     const uint32_t requested_lifetime = std::chrono::seconds(PORT_MAPPING_REANNOUNCE_PERIOD * 2).count();\r\n     uint32_t actual_lifetime = 0;\r\n     std::chrono::milliseconds sleep_time;\r\n \r\n     // Local functor to handle result from PCP/NATPMP mapping.\r\n@@ -101,14 +101,18 @@ static bool ProcessPCP()\r\n         if (!gateway6) {\r\n             LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: Could not determine IPv6 default gateway\\n\");\r\n         } else {\r\n             LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: gateway [IPv6]: %s\\n\", gateway6->ToStringAddr());\r\n \r\n             // Try to open pinholes for all routable local IPv6 addresses.\r\n-            for (const auto &addr: GetLocalAddresses()) {\r\n-                if (!addr.IsRoutable() || !addr.IsIPv6()) continue;\r\n+            const auto addresses =\r\n+                WITH_LOCK(g_addresses_for_port_map.mutex, return g_addresses_for_port_map.addresses);\r\n+            for (const auto& addr : addresses) {\r\n+                if (!addr.IsIPv6()) {\r\n+                    continue;\r\n+                }\r\n                 auto res = PCPRequestPortMap(pcp_nonce, *gateway6, addr, private_port, requested_lifetime);\r\n                 handle_mapping(res);\r\n             }\r\n         }\r\n \r\n         // Log message if we got NO_RESOURCES.\r\ndiff --git a/src/net.cpp b/src/net.cpp\r\nindex 7c6babc389..b621e76696 100644\r\n--- a/src/net.cpp\r\n+++ b/src/net.cpp\r\n@@ -112,12 +112,15 @@ static const uint64_t RANDOMIZER_ID_ADDRCACHE = 0x1cf2e4ddd306dda9ULL; // SHA256\r\n // Global state variables\r\n //\r\n bool fDiscover = true;\r\n bool fListen = true;\r\n GlobalMutex g_maplocalhost_mutex;\r\n std::map<CNetAddr, LocalServiceInfo> mapLocalHost GUARDED_BY(g_maplocalhost_mutex);\r\n+\r\n+AddressesForPortMap g_addresses_for_port_map;\r\n+\r\n std::string strSubVersion;\r\n \r\n size_t CSerializedNetMsg::GetMemoryUsage() const noexcept\r\n {\r\n     // Don't count the dynamic memory used for the m_type string, by assuming it fits in the\r\n     // \"small string\" optimization area (which stores data inside the object itself, up to some\r\n@@ -3151,14 +3154,17 @@ bool CConnman::Bind(const CService& addr_, unsigned int flags, NetPermissionFlag\r\n         if ((flags & BF_REPORT_ERROR) && m_client_interface) {\r\n             m_client_interface->ThreadSafeMessageBox(strError, \"\", CClientUIInterface::MSG_ERROR);\r\n         }\r\n         return false;\r\n     }\r\n \r\n-    if (addr.IsRoutable() && fDiscover && !(flags & BF_DONT_ADVERTISE) && !NetPermissions::HasFlag(permissions, NetPermissionFlags::NoBan)) {\r\n-        AddLocal(addr, LOCAL_BIND);\r\n+    if (addr.IsRoutable() && !(flags & BF_DONT_ADVERTISE) && !NetPermissions::HasFlag(permissions, NetPermissionFlags::NoBan)) {\r\n+        if (fDiscover) {\r\n+            AddLocal(addr, LOCAL_BIND);\r\n+        }\r\n+        WITH_LOCK(g_addresses_for_port_map.mutex, g_addresses_for_port_map.addresses.push_back(addr));\r\n     }\r\n \r\n     return true;\r\n }\r\n \r\n bool CConnman::InitBinds(const Options& options)\r\ndiff --git a/src/net.h b/src/net.h\r\nindex 11cb01a95d..ae08603e64 100644\r\n--- a/src/net.h\r\n+++ b/src/net.h\r\n@@ -175,12 +175,17 @@ struct LocalServiceInfo {\r\n     uint16_t nPort;\r\n };\r\n \r\n extern GlobalMutex g_maplocalhost_mutex;\r\n extern std::map<CNetAddr, LocalServiceInfo> mapLocalHost GUARDED_BY(g_maplocalhost_mutex);\r\n \r\n+extern struct AddressesForPortMap {\r\n+    Mutex mutex;\r\n+    std::vector<CService> addresses GUARDED_BY(mutex);\r\n+} g_addresses_for_port_map;\r\n+\r\n extern const std::string NET_MESSAGE_TYPE_OTHER;\r\n using mapMsgTypeSize = std::map</* message type */ std::string, /* total bytes */ uint64_t>;\r\n \r\n class CNodeStats\r\n {\r\n public:\r\n```\r\n</details>",
      "created_at": "2024-07-19T13:15:57Z",
      "updated_at": "2024-07-19T13:15:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1684368824",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1684368824"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": 106,
      "original_start_line": 106,
      "start_side": "RIGHT",
      "line": 109,
      "original_line": 109,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1709596999",
      "pull_request_review_id": 2228007835,
      "id": 1709596999,
      "node_id": "PRRC_kwDOABII585l5mFH",
      "diff_hunk": "@@ -46,104 +43,96 @@ using namespace std::chrono_literals;\n static constexpr auto PORT_MAPPING_REANNOUNCE_PERIOD{20min};\n static constexpr auto PORT_MAPPING_RETRY_PERIOD{5min};\n \n-#ifdef USE_NATPMP\n-static uint16_t g_mapport_external_port = 0;\n-static bool NatpmpInit(natpmp_t* natpmp)\n+static bool ProcessPCP()\n {\n-    const int r_init = initnatpmp(natpmp, /* detect gateway automatically */ 0, /* forced gateway - NOT APPLIED*/ 0);\n-    if (r_init == 0) return true;\n-    LogPrintf(\"natpmp: initnatpmp() failed with %d error.\\n\", r_init);\n-    return false;\n-}\n+    // The same nonce is used for all mappings, this is allowed by the spec, and simplifies keeping track of them.\n+    PCPMappingNonce pcp_nonce;\n+    GetRandBytes(pcp_nonce);\n \n-static bool NatpmpDiscover(natpmp_t* natpmp, struct in_addr& external_ipv4_addr)\n-{\n-    const int r_send = sendpublicaddressrequest(natpmp);\n-    if (r_send == 2 /* OK */) {\n-        int r_read;\n-        natpmpresp_t response;\n-        do {\n-            r_read = readnatpmpresponseorretry(natpmp, &response);\n-        } while (r_read == NATPMP_TRYAGAIN);\n-\n-        if (r_read == 0) {\n-            external_ipv4_addr = response.pnu.publicaddress.addr;\n-            return true;\n-        } else if (r_read == NATPMP_ERR_NOGATEWAYSUPPORT) {\n-            LogPrintf(\"natpmp: The gateway does not support NAT-PMP.\\n\");\n+    bool ret = false;\n+    bool no_resources = false;\n+    const uint16_t private_port = GetListenPort();\n+    // Multiply the reannounce period by two, as we'll try to renew approximately halfway.\n+    const uint32_t requested_lifetime = std::chrono::seconds(PORT_MAPPING_REANNOUNCE_PERIOD * 2).count();\n+    uint32_t actual_lifetime = 0;\n+    std::chrono::milliseconds sleep_time;\n+\n+    // Local functor to handle result from PCP/NATPMP mapping.\n+    auto handle_mapping = [&](std::variant<MappingResult, MappingError> &res) -> void {\n+        if (MappingResult* mapping = std::get_if<MappingResult>(&res)) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Info, \"portmap: Added mapping %s\\n\", mapping->ToString());\n+            AddLocal(mapping->external, LOCAL_MAPPED);\n+            ret = true;\n+            actual_lifetime = std::min(actual_lifetime, mapping->lifetime);\n+        } else if (MappingError *err = std::get_if<MappingError>(&res)) {\n+            // Detailed error will already have been logged internally in respective Portmap function.\n+            if (*err == MappingError::NO_RESOURCES) {\n+                no_resources = true;\n+            }\n+        }\n+    };\n+\n+    do {\n+        actual_lifetime = requested_lifetime;\n+        no_resources = false; // Set to true if there was any \"no resources\" error.\n+        ret = false; // Set to true if any mapping succeeds.\n+\n+        // IPv4\n+        std::optional<CNetAddr> gateway4 = QueryDefaultGateway(NET_IPV4);\n+        if (!gateway4) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: Could not determine IPv4 default gateway\\n\");\n         } else {\n-            LogPrintf(\"natpmp: readnatpmpresponseorretry() for public address failed with %d error.\\n\", r_read);\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: gateway [IPv4]: %s\\n\", gateway4->ToStringAddr());\n+\n+            // Open a port mapping on whatever local address we have toward the gateway.\n+            struct in_addr inaddr_any;\n+            inaddr_any.s_addr = htonl(INADDR_ANY);\n+            auto res = PCPRequestPortMap(pcp_nonce, *gateway4, CNetAddr(inaddr_any), private_port, requested_lifetime);",
      "path": "src/mapport.cpp",
      "position": 98,
      "original_position": 98,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "23916f2a7717b463799207b4b81b5795f2e9d7e3",
      "in_reply_to_id": 1658779455,
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> Bitcoin Core had a strong preference to connect to peers that listen on port `8333`. Is this what you mean? That was removed at some point.\r\n\r\nYes, that preference for clearnet connections was removed in https://github.com/bitcoin/bitcoin/pull/23542.\r\n",
      "created_at": "2024-08-08T14:10:00Z",
      "updated_at": "2024-08-08T14:10:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1709596999",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1709596999"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 90,
      "original_line": 90,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1732784821",
      "pull_request_review_id": 2263241097,
      "id": 1732784821,
      "node_id": "PRRC_kwDOABII585nSDK1",
      "diff_hunk": "@@ -0,0 +1,299 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <osreldate.h>\n+#if __FreeBSD_version >= 1400000\n+// Workaround https://github.com/freebsd/freebsd-src/pull/1070.\n+#define typeof __typeof\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+#elif defined(WIN32)\n+#include <iphlpapi.h>\n+#elif defined(__APPLE__)\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+#endif\n+\n+namespace {\n+\n+// Linux and FreeBSD 14.0+. For FreeBSD 13.2 the code can be compiled but\n+// running it requires loading a special kernel module, otherwise socket(AF_NETLINK,...)\n+// will fail, so we skip that.\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1400000)\n+\n+std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    auto sock{CreateSock(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (!sock) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.dst_data.\n+    const size_t dst_data_len = family == AF_INET ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    // Linux IPv4 / IPv6 - this must be present, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = family;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    // Linux IPv4 / IPv6 this must be absent, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock->Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    int64_t recv_result;\n+    do {\n+        recv_result = sock->Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, recv_result); hdr = NLMSG_NEXT(hdr, recv_result)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF && sizeof(int) == RTA_PAYLOAD(attr)) {\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (family == AF_INET && sizeof(in_addr) == RTA_PAYLOAD(rta_gateway)) {\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (family == AF_INET6 && sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway)) {\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    destination_address.si_family = family;\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    Assume(best_route.NextHop.si_family == family);\n+    if (family == AF_INET) {\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(family == AF_INET6) {\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Check valid length. Note that sa_len is not part of POSIX, and exists on MacOS and some BSDs only, so we can't\n+    // do this check in SetSockAddr.\n+    if (!(addr->sa_family == AF_INET && addr->sa_len == sizeof(struct sockaddr_in)) &&\n+        !(addr->sa_family == AF_INET6 && addr->sa_len == sizeof(struct sockaddr_in6))) {\n+        return std::nullopt;\n+    }\n+\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+//! MacOS: Get default gateway from route table. See route(4) for the format.\n+std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // net.route.0.inet[6].flags.gateway\n+    int mib[] = {CTL_NET, PF_ROUTE, 0, family, NET_RT_FLAGS, RTF_GATEWAY};\n+    // The size of the available data is determined by calling sysctl() with oldp=nullptr. See sysctl(3).\n+    size_t l = 0;\n+    if (sysctl(/*name=*/mib, /*namelen=*/sizeof(mib) / sizeof(int), /*oldp=*/nullptr, /*oldlenp=*/&l, /*newp=*/nullptr, /*newlen=*/0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl length of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    std::vector<std::byte> buf(l);\n+    if (sysctl(/*name=*/mib, /*namelen=*/sizeof(mib) / sizeof(int), /*oldp=*/buf.data(), /*oldlenp=*/&l, /*newp=*/nullptr, /*newlen=*/0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl data of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    // Iterate over messages (each message is a routing table entry).\n+    for (size_t msg_pos = 0; msg_pos < buf.size(); ) {\n+        if ((msg_pos + sizeof(rt_msghdr)) > buf.size()) return std::nullopt;\n+        const struct rt_msghdr* rt = (const struct rt_msghdr*)(buf.data() + msg_pos);\n+        const size_t next_msg_pos = msg_pos + rt->rtm_msglen;\n+        if (rt->rtm_msglen < sizeof(rt_msghdr) || next_msg_pos > buf.size()) return std::nullopt;\n+        // Iterate over addresses within message, get destination and gateway (if present).\n+        // Address data starts after header.\n+        size_t sa_pos = msg_pos + sizeof(struct rt_msghdr);\n+        std::optional<CNetAddr> dst, gateway;\n+        for (int i = 0; i < RTAX_MAX; i++) {\n+            if (rt->rtm_addrs & (1 << i)) {\n+                // 2 is just sa_len + sa_family, the theoretical minimum size of a socket address.\n+                if ((sa_pos + 2) > next_msg_pos) return std::nullopt;\n+                const struct sockaddr* sa = (const struct sockaddr*)(buf.data() + sa_pos);\n+                if (sa->sa_len < 2 || (sa_pos + sa->sa_len) > next_msg_pos) return std::nullopt;",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 215,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "9a067b5ac154154ec9008a0e8f2d8f03e994a589",
      "in_reply_to_id": 1668523385,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "hm... `sa_len=0` is really strange because it doesn't know how to advance, there isn't even place for the size! (which it just read in the line above it!) it should at least break out of the loop in that case.\r\n\r\nbut i expect there's either something else wrong in the parsing that causes this to happen, or it's a mistake in the data which no one ever noticed.\r\n\r\n(`msg_next_pos != sa_pos` suggests that there is still more data in that message so it also probably isn't an end-marker, though also we don't care about that data as we already have `DST` and `GATEWAY`)",
      "created_at": "2024-08-27T12:45:33Z",
      "updated_at": "2024-08-27T12:58:24Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1732784821",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1732784821"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 215,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1732832981",
      "pull_request_review_id": 2263326889,
      "id": 1732832981,
      "node_id": "PRRC_kwDOABII585nSO7V",
      "diff_hunk": "@@ -0,0 +1,299 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <osreldate.h>\n+#if __FreeBSD_version >= 1400000\n+// Workaround https://github.com/freebsd/freebsd-src/pull/1070.\n+#define typeof __typeof\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+#elif defined(WIN32)\n+#include <iphlpapi.h>\n+#elif defined(__APPLE__)\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+#endif\n+\n+namespace {\n+\n+// Linux and FreeBSD 14.0+. For FreeBSD 13.2 the code can be compiled but\n+// running it requires loading a special kernel module, otherwise socket(AF_NETLINK,...)\n+// will fail, so we skip that.\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1400000)\n+\n+std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    auto sock{CreateSock(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (!sock) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.dst_data.\n+    const size_t dst_data_len = family == AF_INET ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    // Linux IPv4 / IPv6 - this must be present, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = family;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    // Linux IPv4 / IPv6 this must be absent, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock->Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    int64_t recv_result;\n+    do {\n+        recv_result = sock->Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, recv_result); hdr = NLMSG_NEXT(hdr, recv_result)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF && sizeof(int) == RTA_PAYLOAD(attr)) {\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (family == AF_INET && sizeof(in_addr) == RTA_PAYLOAD(rta_gateway)) {\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (family == AF_INET6 && sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway)) {\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    destination_address.si_family = family;\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    Assume(best_route.NextHop.si_family == family);\n+    if (family == AF_INET) {\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(family == AF_INET6) {\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Check valid length. Note that sa_len is not part of POSIX, and exists on MacOS and some BSDs only, so we can't\n+    // do this check in SetSockAddr.\n+    if (!(addr->sa_family == AF_INET && addr->sa_len == sizeof(struct sockaddr_in)) &&\n+        !(addr->sa_family == AF_INET6 && addr->sa_len == sizeof(struct sockaddr_in6))) {\n+        return std::nullopt;\n+    }\n+\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+//! MacOS: Get default gateway from route table. See route(4) for the format.\n+std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // net.route.0.inet[6].flags.gateway\n+    int mib[] = {CTL_NET, PF_ROUTE, 0, family, NET_RT_FLAGS, RTF_GATEWAY};\n+    // The size of the available data is determined by calling sysctl() with oldp=nullptr. See sysctl(3).\n+    size_t l = 0;\n+    if (sysctl(/*name=*/mib, /*namelen=*/sizeof(mib) / sizeof(int), /*oldp=*/nullptr, /*oldlenp=*/&l, /*newp=*/nullptr, /*newlen=*/0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl length of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    std::vector<std::byte> buf(l);\n+    if (sysctl(/*name=*/mib, /*namelen=*/sizeof(mib) / sizeof(int), /*oldp=*/buf.data(), /*oldlenp=*/&l, /*newp=*/nullptr, /*newlen=*/0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl data of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    // Iterate over messages (each message is a routing table entry).\n+    for (size_t msg_pos = 0; msg_pos < buf.size(); ) {\n+        if ((msg_pos + sizeof(rt_msghdr)) > buf.size()) return std::nullopt;\n+        const struct rt_msghdr* rt = (const struct rt_msghdr*)(buf.data() + msg_pos);\n+        const size_t next_msg_pos = msg_pos + rt->rtm_msglen;\n+        if (rt->rtm_msglen < sizeof(rt_msghdr) || next_msg_pos > buf.size()) return std::nullopt;\n+        // Iterate over addresses within message, get destination and gateway (if present).\n+        // Address data starts after header.\n+        size_t sa_pos = msg_pos + sizeof(struct rt_msghdr);\n+        std::optional<CNetAddr> dst, gateway;\n+        for (int i = 0; i < RTAX_MAX; i++) {\n+            if (rt->rtm_addrs & (1 << i)) {\n+                // 2 is just sa_len + sa_family, the theoretical minimum size of a socket address.\n+                if ((sa_pos + 2) > next_msg_pos) return std::nullopt;\n+                const struct sockaddr* sa = (const struct sockaddr*)(buf.data() + sa_pos);\n+                if (sa->sa_len < 2 || (sa_pos + sa->sa_len) > next_msg_pos) return std::nullopt;",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 215,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "9a067b5ac154154ec9008a0e8f2d8f03e994a589",
      "in_reply_to_id": 1668523385,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "i think i get it, we're advancing in the wrong way; see https://opensource.apple.com/source/xnu/xnu-1504.9.17/bsd/net/rtsock.c.auto.html (some actual Apple source code)\r\n```\r\n#define ROUNDUP32(a) \\\r\n\t((a) > 0 ? (1 + (((a) - 1) | (sizeof(uint32_t) - 1))) : sizeof(uint32_t))\r\n#define ADVANCE32(x, n) (x += ROUNDUP32((n)->sa_len))\r\n...\r\n\t\tdlen = ROUNDUP32(sa->sa_len);\r\n\t\tm_copyback(m, len, dlen, (caddr_t)sa);\r\n\t\tlen += dlen;\r\n...\r\n```\r\nROUNDUP32:\r\n- if the size is 0, advance by sizeof(uint32_t)\r\n- otherwise, round it up to 32 bit units\r\n\r\nCan you try this please (let's just take over the macro as-is)?",
      "created_at": "2024-08-27T13:15:23Z",
      "updated_at": "2024-08-27T13:15:48Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1732832981",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1732832981"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 215,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1732943642",
      "pull_request_review_id": 2263517934,
      "id": 1732943642,
      "node_id": "PRRC_kwDOABII585nSp8a",
      "diff_hunk": "@@ -0,0 +1,299 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <osreldate.h>\n+#if __FreeBSD_version >= 1400000\n+// Workaround https://github.com/freebsd/freebsd-src/pull/1070.\n+#define typeof __typeof\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+#elif defined(WIN32)\n+#include <iphlpapi.h>\n+#elif defined(__APPLE__)\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+#endif\n+\n+namespace {\n+\n+// Linux and FreeBSD 14.0+. For FreeBSD 13.2 the code can be compiled but\n+// running it requires loading a special kernel module, otherwise socket(AF_NETLINK,...)\n+// will fail, so we skip that.\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1400000)\n+\n+std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    auto sock{CreateSock(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (!sock) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.dst_data.\n+    const size_t dst_data_len = family == AF_INET ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    // Linux IPv4 / IPv6 - this must be present, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = family;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    // Linux IPv4 / IPv6 this must be absent, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock->Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    int64_t recv_result;\n+    do {\n+        recv_result = sock->Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, recv_result); hdr = NLMSG_NEXT(hdr, recv_result)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF && sizeof(int) == RTA_PAYLOAD(attr)) {\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (family == AF_INET && sizeof(in_addr) == RTA_PAYLOAD(rta_gateway)) {\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (family == AF_INET6 && sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway)) {\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    destination_address.si_family = family;\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    Assume(best_route.NextHop.si_family == family);\n+    if (family == AF_INET) {\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(family == AF_INET6) {\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Check valid length. Note that sa_len is not part of POSIX, and exists on MacOS and some BSDs only, so we can't\n+    // do this check in SetSockAddr.\n+    if (!(addr->sa_family == AF_INET && addr->sa_len == sizeof(struct sockaddr_in)) &&\n+        !(addr->sa_family == AF_INET6 && addr->sa_len == sizeof(struct sockaddr_in6))) {\n+        return std::nullopt;\n+    }\n+\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+//! MacOS: Get default gateway from route table. See route(4) for the format.\n+std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // net.route.0.inet[6].flags.gateway\n+    int mib[] = {CTL_NET, PF_ROUTE, 0, family, NET_RT_FLAGS, RTF_GATEWAY};\n+    // The size of the available data is determined by calling sysctl() with oldp=nullptr. See sysctl(3).\n+    size_t l = 0;\n+    if (sysctl(/*name=*/mib, /*namelen=*/sizeof(mib) / sizeof(int), /*oldp=*/nullptr, /*oldlenp=*/&l, /*newp=*/nullptr, /*newlen=*/0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl length of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    std::vector<std::byte> buf(l);\n+    if (sysctl(/*name=*/mib, /*namelen=*/sizeof(mib) / sizeof(int), /*oldp=*/buf.data(), /*oldlenp=*/&l, /*newp=*/nullptr, /*newlen=*/0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl data of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    // Iterate over messages (each message is a routing table entry).\n+    for (size_t msg_pos = 0; msg_pos < buf.size(); ) {\n+        if ((msg_pos + sizeof(rt_msghdr)) > buf.size()) return std::nullopt;\n+        const struct rt_msghdr* rt = (const struct rt_msghdr*)(buf.data() + msg_pos);\n+        const size_t next_msg_pos = msg_pos + rt->rtm_msglen;\n+        if (rt->rtm_msglen < sizeof(rt_msghdr) || next_msg_pos > buf.size()) return std::nullopt;\n+        // Iterate over addresses within message, get destination and gateway (if present).\n+        // Address data starts after header.\n+        size_t sa_pos = msg_pos + sizeof(struct rt_msghdr);\n+        std::optional<CNetAddr> dst, gateway;\n+        for (int i = 0; i < RTAX_MAX; i++) {\n+            if (rt->rtm_addrs & (1 << i)) {\n+                // 2 is just sa_len + sa_family, the theoretical minimum size of a socket address.\n+                if ((sa_pos + 2) > next_msg_pos) return std::nullopt;\n+                const struct sockaddr* sa = (const struct sockaddr*)(buf.data() + sa_pos);\n+                if (sa->sa_len < 2 || (sa_pos + sa->sa_len) > next_msg_pos) return std::nullopt;",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 215,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "9a067b5ac154154ec9008a0e8f2d8f03e994a589",
      "in_reply_to_id": 1668523385,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I'm a bit confused where you want this code to go...",
      "created_at": "2024-08-27T14:14:58Z",
      "updated_at": "2024-08-27T14:14:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1732943642",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1732943642"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 215,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1733163380",
      "pull_request_review_id": 2263879248,
      "id": 1733163380,
      "node_id": "PRRC_kwDOABII585nTfl0",
      "diff_hunk": "@@ -0,0 +1,299 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <osreldate.h>\n+#if __FreeBSD_version >= 1400000\n+// Workaround https://github.com/freebsd/freebsd-src/pull/1070.\n+#define typeof __typeof\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+#elif defined(WIN32)\n+#include <iphlpapi.h>\n+#elif defined(__APPLE__)\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+#endif\n+\n+namespace {\n+\n+// Linux and FreeBSD 14.0+. For FreeBSD 13.2 the code can be compiled but\n+// running it requires loading a special kernel module, otherwise socket(AF_NETLINK,...)\n+// will fail, so we skip that.\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1400000)\n+\n+std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    auto sock{CreateSock(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (!sock) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.dst_data.\n+    const size_t dst_data_len = family == AF_INET ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    // Linux IPv4 / IPv6 - this must be present, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = family;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    // Linux IPv4 / IPv6 this must be absent, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock->Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    int64_t recv_result;\n+    do {\n+        recv_result = sock->Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, recv_result); hdr = NLMSG_NEXT(hdr, recv_result)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF && sizeof(int) == RTA_PAYLOAD(attr)) {\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (family == AF_INET && sizeof(in_addr) == RTA_PAYLOAD(rta_gateway)) {\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (family == AF_INET6 && sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway)) {\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    destination_address.si_family = family;\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    Assume(best_route.NextHop.si_family == family);\n+    if (family == AF_INET) {\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(family == AF_INET6) {\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Check valid length. Note that sa_len is not part of POSIX, and exists on MacOS and some BSDs only, so we can't\n+    // do this check in SetSockAddr.\n+    if (!(addr->sa_family == AF_INET && addr->sa_len == sizeof(struct sockaddr_in)) &&\n+        !(addr->sa_family == AF_INET6 && addr->sa_len == sizeof(struct sockaddr_in6))) {\n+        return std::nullopt;\n+    }\n+\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+//! MacOS: Get default gateway from route table. See route(4) for the format.\n+std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // net.route.0.inet[6].flags.gateway\n+    int mib[] = {CTL_NET, PF_ROUTE, 0, family, NET_RT_FLAGS, RTF_GATEWAY};\n+    // The size of the available data is determined by calling sysctl() with oldp=nullptr. See sysctl(3).\n+    size_t l = 0;\n+    if (sysctl(/*name=*/mib, /*namelen=*/sizeof(mib) / sizeof(int), /*oldp=*/nullptr, /*oldlenp=*/&l, /*newp=*/nullptr, /*newlen=*/0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl length of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    std::vector<std::byte> buf(l);\n+    if (sysctl(/*name=*/mib, /*namelen=*/sizeof(mib) / sizeof(int), /*oldp=*/buf.data(), /*oldlenp=*/&l, /*newp=*/nullptr, /*newlen=*/0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl data of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    // Iterate over messages (each message is a routing table entry).\n+    for (size_t msg_pos = 0; msg_pos < buf.size(); ) {\n+        if ((msg_pos + sizeof(rt_msghdr)) > buf.size()) return std::nullopt;\n+        const struct rt_msghdr* rt = (const struct rt_msghdr*)(buf.data() + msg_pos);\n+        const size_t next_msg_pos = msg_pos + rt->rtm_msglen;\n+        if (rt->rtm_msglen < sizeof(rt_msghdr) || next_msg_pos > buf.size()) return std::nullopt;\n+        // Iterate over addresses within message, get destination and gateway (if present).\n+        // Address data starts after header.\n+        size_t sa_pos = msg_pos + sizeof(struct rt_msghdr);\n+        std::optional<CNetAddr> dst, gateway;\n+        for (int i = 0; i < RTAX_MAX; i++) {\n+            if (rt->rtm_addrs & (1 << i)) {\n+                // 2 is just sa_len + sa_family, the theoretical minimum size of a socket address.\n+                if ((sa_pos + 2) > next_msg_pos) return std::nullopt;\n+                const struct sockaddr* sa = (const struct sockaddr*)(buf.data() + sa_pos);\n+                if (sa->sa_len < 2 || (sa_pos + sa->sa_len) > next_msg_pos) return std::nullopt;",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 215,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "9a067b5ac154154ec9008a0e8f2d8f03e994a589",
      "in_reply_to_id": 1668523385,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "yeah no problem, i'll push the change as a commit (after rebase, i guess)",
      "created_at": "2024-08-27T16:05:36Z",
      "updated_at": "2024-08-27T16:05:36Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1733163380",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1733163380"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 215,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1735899318",
      "pull_request_review_id": 2268223315,
      "id": 1735899318,
      "node_id": "PRRC_kwDOABII585nd7i2",
      "diff_hunk": "@@ -0,0 +1,299 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <osreldate.h>\n+#if __FreeBSD_version >= 1400000\n+// Workaround https://github.com/freebsd/freebsd-src/pull/1070.\n+#define typeof __typeof\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+#elif defined(WIN32)\n+#include <iphlpapi.h>\n+#elif defined(__APPLE__)\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+#endif\n+\n+namespace {\n+\n+// Linux and FreeBSD 14.0+. For FreeBSD 13.2 the code can be compiled but\n+// running it requires loading a special kernel module, otherwise socket(AF_NETLINK,...)\n+// will fail, so we skip that.\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1400000)\n+\n+std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    auto sock{CreateSock(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (!sock) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.dst_data.\n+    const size_t dst_data_len = family == AF_INET ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    // Linux IPv4 / IPv6 - this must be present, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = family;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    // Linux IPv4 / IPv6 this must be absent, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock->Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    int64_t recv_result;\n+    do {\n+        recv_result = sock->Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, recv_result); hdr = NLMSG_NEXT(hdr, recv_result)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF && sizeof(int) == RTA_PAYLOAD(attr)) {\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (family == AF_INET && sizeof(in_addr) == RTA_PAYLOAD(rta_gateway)) {\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (family == AF_INET6 && sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway)) {\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    destination_address.si_family = family;\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    Assume(best_route.NextHop.si_family == family);\n+    if (family == AF_INET) {\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(family == AF_INET6) {\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Check valid length. Note that sa_len is not part of POSIX, and exists on MacOS and some BSDs only, so we can't\n+    // do this check in SetSockAddr.\n+    if (!(addr->sa_family == AF_INET && addr->sa_len == sizeof(struct sockaddr_in)) &&\n+        !(addr->sa_family == AF_INET6 && addr->sa_len == sizeof(struct sockaddr_in6))) {\n+        return std::nullopt;\n+    }\n+\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+//! MacOS: Get default gateway from route table. See route(4) for the format.\n+std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // net.route.0.inet[6].flags.gateway\n+    int mib[] = {CTL_NET, PF_ROUTE, 0, family, NET_RT_FLAGS, RTF_GATEWAY};\n+    // The size of the available data is determined by calling sysctl() with oldp=nullptr. See sysctl(3).\n+    size_t l = 0;\n+    if (sysctl(/*name=*/mib, /*namelen=*/sizeof(mib) / sizeof(int), /*oldp=*/nullptr, /*oldlenp=*/&l, /*newp=*/nullptr, /*newlen=*/0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl length of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    std::vector<std::byte> buf(l);\n+    if (sysctl(/*name=*/mib, /*namelen=*/sizeof(mib) / sizeof(int), /*oldp=*/buf.data(), /*oldlenp=*/&l, /*newp=*/nullptr, /*newlen=*/0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl data of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    // Iterate over messages (each message is a routing table entry).\n+    for (size_t msg_pos = 0; msg_pos < buf.size(); ) {\n+        if ((msg_pos + sizeof(rt_msghdr)) > buf.size()) return std::nullopt;\n+        const struct rt_msghdr* rt = (const struct rt_msghdr*)(buf.data() + msg_pos);\n+        const size_t next_msg_pos = msg_pos + rt->rtm_msglen;\n+        if (rt->rtm_msglen < sizeof(rt_msghdr) || next_msg_pos > buf.size()) return std::nullopt;\n+        // Iterate over addresses within message, get destination and gateway (if present).\n+        // Address data starts after header.\n+        size_t sa_pos = msg_pos + sizeof(struct rt_msghdr);\n+        std::optional<CNetAddr> dst, gateway;\n+        for (int i = 0; i < RTAX_MAX; i++) {\n+            if (rt->rtm_addrs & (1 << i)) {\n+                // 2 is just sa_len + sa_family, the theoretical minimum size of a socket address.\n+                if ((sa_pos + 2) > next_msg_pos) return std::nullopt;\n+                const struct sockaddr* sa = (const struct sockaddr*)(buf.data() + sa_pos);\n+                if (sa->sa_len < 2 || (sa_pos + sa->sa_len) > next_msg_pos) return std::nullopt;",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 215,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "9a067b5ac154154ec9008a0e8f2d8f03e994a589",
      "in_reply_to_id": 1668523385,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "It works again with 26436dce049d4215a112a1147b624c0435dbc8a6.",
      "created_at": "2024-08-29T09:41:42Z",
      "updated_at": "2024-08-29T09:41:42Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1735899318",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1735899318"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 215,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1738466645",
      "pull_request_review_id": 2272016302,
      "id": 1738466645,
      "node_id": "PRRC_kwDOABII585nnuVV",
      "diff_hunk": "@@ -0,0 +1,299 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <osreldate.h>\n+#if __FreeBSD_version >= 1400000\n+// Workaround https://github.com/freebsd/freebsd-src/pull/1070.\n+#define typeof __typeof\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+#elif defined(WIN32)\n+#include <iphlpapi.h>\n+#elif defined(__APPLE__)\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+#endif\n+\n+namespace {\n+\n+// Linux and FreeBSD 14.0+. For FreeBSD 13.2 the code can be compiled but\n+// running it requires loading a special kernel module, otherwise socket(AF_NETLINK,...)\n+// will fail, so we skip that.\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1400000)\n+\n+std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    auto sock{CreateSock(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (!sock) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.dst_data.\n+    const size_t dst_data_len = family == AF_INET ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    // Linux IPv4 / IPv6 - this must be present, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = family;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    // Linux IPv4 / IPv6 this must be absent, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock->Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    int64_t recv_result;\n+    do {\n+        recv_result = sock->Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, recv_result); hdr = NLMSG_NEXT(hdr, recv_result)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF && sizeof(int) == RTA_PAYLOAD(attr)) {\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (family == AF_INET && sizeof(in_addr) == RTA_PAYLOAD(rta_gateway)) {\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (family == AF_INET6 && sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway)) {\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    destination_address.si_family = family;\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    Assume(best_route.NextHop.si_family == family);\n+    if (family == AF_INET) {\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(family == AF_INET6) {\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Check valid length. Note that sa_len is not part of POSIX, and exists on MacOS and some BSDs only, so we can't\n+    // do this check in SetSockAddr.\n+    if (!(addr->sa_family == AF_INET && addr->sa_len == sizeof(struct sockaddr_in)) &&\n+        !(addr->sa_family == AF_INET6 && addr->sa_len == sizeof(struct sockaddr_in6))) {\n+        return std::nullopt;\n+    }\n+\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+//! MacOS: Get default gateway from route table. See route(4) for the format.\n+std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // net.route.0.inet[6].flags.gateway\n+    int mib[] = {CTL_NET, PF_ROUTE, 0, family, NET_RT_FLAGS, RTF_GATEWAY};\n+    // The size of the available data is determined by calling sysctl() with oldp=nullptr. See sysctl(3).\n+    size_t l = 0;\n+    if (sysctl(/*name=*/mib, /*namelen=*/sizeof(mib) / sizeof(int), /*oldp=*/nullptr, /*oldlenp=*/&l, /*newp=*/nullptr, /*newlen=*/0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl length of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    std::vector<std::byte> buf(l);\n+    if (sysctl(/*name=*/mib, /*namelen=*/sizeof(mib) / sizeof(int), /*oldp=*/buf.data(), /*oldlenp=*/&l, /*newp=*/nullptr, /*newlen=*/0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl data of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    // Iterate over messages (each message is a routing table entry).\n+    for (size_t msg_pos = 0; msg_pos < buf.size(); ) {\n+        if ((msg_pos + sizeof(rt_msghdr)) > buf.size()) return std::nullopt;\n+        const struct rt_msghdr* rt = (const struct rt_msghdr*)(buf.data() + msg_pos);\n+        const size_t next_msg_pos = msg_pos + rt->rtm_msglen;\n+        if (rt->rtm_msglen < sizeof(rt_msghdr) || next_msg_pos > buf.size()) return std::nullopt;\n+        // Iterate over addresses within message, get destination and gateway (if present).\n+        // Address data starts after header.\n+        size_t sa_pos = msg_pos + sizeof(struct rt_msghdr);\n+        std::optional<CNetAddr> dst, gateway;\n+        for (int i = 0; i < RTAX_MAX; i++) {\n+            if (rt->rtm_addrs & (1 << i)) {\n+                // 2 is just sa_len + sa_family, the theoretical minimum size of a socket address.\n+                if ((sa_pos + 2) > next_msg_pos) return std::nullopt;\n+                const struct sockaddr* sa = (const struct sockaddr*)(buf.data() + sa_pos);\n+                if (sa->sa_len < 2 || (sa_pos + sa->sa_len) > next_msg_pos) return std::nullopt;",
      "path": "src/util/netif.cpp",
      "position": null,
      "original_position": 215,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "9a067b5ac154154ec9008a0e8f2d8f03e994a589",
      "in_reply_to_id": 1668523385,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Thanks for testing, apperently we over-simplified that. WIl keep it like this.",
      "created_at": "2024-08-30T11:33:35Z",
      "updated_at": "2024-08-30T11:33:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1738466645",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1738466645"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 215,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1745243016",
      "pull_request_review_id": 2282566304,
      "id": 1745243016,
      "node_id": "PRRC_kwDOABII585oBkuI",
      "diff_hunk": "@@ -46,104 +43,96 @@ using namespace std::chrono_literals;\n static constexpr auto PORT_MAPPING_REANNOUNCE_PERIOD{20min};\n static constexpr auto PORT_MAPPING_RETRY_PERIOD{5min};\n \n-#ifdef USE_NATPMP\n-static uint16_t g_mapport_external_port = 0;\n-static bool NatpmpInit(natpmp_t* natpmp)\n+static bool ProcessPCP()\n {\n-    const int r_init = initnatpmp(natpmp, /* detect gateway automatically */ 0, /* forced gateway - NOT APPLIED*/ 0);\n-    if (r_init == 0) return true;\n-    LogPrintf(\"natpmp: initnatpmp() failed with %d error.\\n\", r_init);\n-    return false;\n-}\n+    // The same nonce is used for all mappings, this is allowed by the spec, and simplifies keeping track of them.\n+    PCPMappingNonce pcp_nonce;\n+    GetRandBytes(pcp_nonce);\n \n-static bool NatpmpDiscover(natpmp_t* natpmp, struct in_addr& external_ipv4_addr)\n-{\n-    const int r_send = sendpublicaddressrequest(natpmp);\n-    if (r_send == 2 /* OK */) {\n-        int r_read;\n-        natpmpresp_t response;\n-        do {\n-            r_read = readnatpmpresponseorretry(natpmp, &response);\n-        } while (r_read == NATPMP_TRYAGAIN);\n-\n-        if (r_read == 0) {\n-            external_ipv4_addr = response.pnu.publicaddress.addr;\n-            return true;\n-        } else if (r_read == NATPMP_ERR_NOGATEWAYSUPPORT) {\n-            LogPrintf(\"natpmp: The gateway does not support NAT-PMP.\\n\");\n+    bool ret = false;\n+    bool no_resources = false;\n+    const uint16_t private_port = GetListenPort();\n+    // Multiply the reannounce period by two, as we'll try to renew approximately halfway.\n+    const uint32_t requested_lifetime = std::chrono::seconds(PORT_MAPPING_REANNOUNCE_PERIOD * 2).count();\n+    uint32_t actual_lifetime = 0;\n+    std::chrono::milliseconds sleep_time;\n+\n+    // Local functor to handle result from PCP/NATPMP mapping.\n+    auto handle_mapping = [&](std::variant<MappingResult, MappingError> &res) -> void {\n+        if (MappingResult* mapping = std::get_if<MappingResult>(&res)) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Info, \"portmap: Added mapping %s\\n\", mapping->ToString());\n+            AddLocal(mapping->external, LOCAL_MAPPED);\n+            ret = true;\n+            actual_lifetime = std::min(actual_lifetime, mapping->lifetime);\n+        } else if (MappingError *err = std::get_if<MappingError>(&res)) {\n+            // Detailed error will already have been logged internally in respective Portmap function.\n+            if (*err == MappingError::NO_RESOURCES) {\n+                no_resources = true;\n+            }\n+        }\n+    };\n+\n+    do {\n+        actual_lifetime = requested_lifetime;\n+        no_resources = false; // Set to true if there was any \"no resources\" error.\n+        ret = false; // Set to true if any mapping succeeds.\n+\n+        // IPv4\n+        std::optional<CNetAddr> gateway4 = QueryDefaultGateway(NET_IPV4);\n+        if (!gateway4) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: Could not determine IPv4 default gateway\\n\");\n         } else {\n-            LogPrintf(\"natpmp: readnatpmpresponseorretry() for public address failed with %d error.\\n\", r_read);\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: gateway [IPv4]: %s\\n\", gateway4->ToStringAddr());\n+\n+            // Open a port mapping on whatever local address we have toward the gateway.\n+            struct in_addr inaddr_any;\n+            inaddr_any.s_addr = htonl(INADDR_ANY);\n+            auto res = PCPRequestPortMap(pcp_nonce, *gateway4, CNetAddr(inaddr_any), private_port, requested_lifetime);\n+            MappingError* pcp_err = std::get_if<MappingError>(&res);\n+            if (pcp_err && *pcp_err == MappingError::UNSUPP_VERSION) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: Got unsupported PCP version response, falling back to NAT-PMP\\n\");\n+                res = NATPMPRequestPortMap(*gateway4, private_port, requested_lifetime);\n+            }\n+            handle_mapping(res);\n         }\n-    } else {\n-        LogPrintf(\"natpmp: sendpublicaddressrequest() failed with %d error.\\n\", r_send);\n-    }\n \n-    return false;\n-}\n+        // IPv6\n+        std::optional<CNetAddr> gateway6 = QueryDefaultGateway(NET_IPV6);\n+        if (!gateway6) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: Could not determine IPv6 default gateway\\n\");\n+        } else {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: gateway [IPv6]: %s\\n\", gateway6->ToStringAddr());\n \n-static bool NatpmpMapping(natpmp_t* natpmp, const struct in_addr& external_ipv4_addr, uint16_t private_port, bool& external_ip_discovered)\n-{\n-    const uint16_t suggested_external_port = g_mapport_external_port ? g_mapport_external_port : private_port;\n-    const int r_send = sendnewportmappingrequest(natpmp, NATPMP_PROTOCOL_TCP, private_port, suggested_external_port, 3600 /*seconds*/);\n-    if (r_send == 12 /* OK */) {\n-        int r_read;\n-        natpmpresp_t response;\n-        do {\n-            r_read = readnatpmpresponseorretry(natpmp, &response);\n-        } while (r_read == NATPMP_TRYAGAIN);\n-\n-        if (r_read == 0) {\n-            auto pm = response.pnu.newportmapping;\n-            if (private_port == pm.privateport && pm.lifetime > 0) {\n-                g_mapport_external_port = pm.mappedpublicport;\n-                const CService external{external_ipv4_addr, pm.mappedpublicport};\n-                if (!external_ip_discovered && fDiscover) {\n-                    AddLocal(external, LOCAL_MAPPED);\n-                    external_ip_discovered = true;\n-                }\n-                LogPrintf(\"natpmp: Port mapping successful. External address = %s\\n\", external.ToStringAddrPort());\n-                return true;\n-            } else {\n-                LogPrintf(\"natpmp: Port mapping failed.\\n\");\n+            // Try to open pinholes for all routable local IPv6 addresses.\n+            for (const auto &addr: GetLocalAddresses()) {\n+                if (!addr.IsRoutable() || !addr.IsIPv6()) continue;\n+                auto res = PCPRequestPortMap(pcp_nonce, *gateway6, addr, private_port, requested_lifetime);\n+                handle_mapping(res);\n             }\n-        } else if (r_read == NATPMP_ERR_NOGATEWAYSUPPORT) {\n-            LogPrintf(\"natpmp: The gateway does not support NAT-PMP.\\n\");\n-        } else {\n-            LogPrintf(\"natpmp: readnatpmpresponseorretry() for port mapping failed with %d error.\\n\", r_read);\n         }\n-    } else {\n-        LogPrintf(\"natpmp: sendnewportmappingrequest() failed with %d error.\\n\", r_send);\n-    }\n-\n-    return false;\n-}\n \n-static bool ProcessNatpmp()\n-{\n-    bool ret = false;\n-    natpmp_t natpmp;\n-    struct in_addr external_ipv4_addr;\n-    if (NatpmpInit(&natpmp) && NatpmpDiscover(&natpmp, external_ipv4_addr)) {\n-        bool external_ip_discovered = false;\n-        const uint16_t private_port = GetListenPort();\n-        do {\n-            ret = NatpmpMapping(&natpmp, external_ipv4_addr, private_port, external_ip_discovered);\n-        } while (ret && g_mapport_interrupt.sleep_for(PORT_MAPPING_REANNOUNCE_PERIOD));\n-        g_mapport_interrupt.reset();\n+        // Log message if we got NO_RESOURCES.\n+        if (no_resources) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"portmap: At least one mapping failed because of a NO_RESOURCES error. This usually indicates that the port is already used on the router. If this is the only instance of bitcoin running on the network, this will resolve itself automatically. Otherwise, you might want to choose a different P2P port to prevent this conflict.\\n\");\n+        }\n \n-        const int r_send = sendnewportmappingrequest(&natpmp, NATPMP_PROTOCOL_TCP, private_port, g_mapport_external_port, /* remove a port mapping */ 0);\n-        g_mapport_external_port = 0;\n-        if (r_send == 12 /* OK */) {\n-            LogPrintf(\"natpmp: Port mapping removed successfully.\\n\");\n-        } else {\n-            LogPrintf(\"natpmp: sendnewportmappingrequest(0) failed with %d error.\\n\", r_send);\n+        // Sanity-check returned lifetime.\n+        if (actual_lifetime < 30) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"portmap: Got impossibly short mapping lifetime of %d seconds\\n\", actual_lifetime);\n+            return false;\n         }\n-    }\n+        // RFC6887 11.2.1 recommends that clients send their first renewal packet at a time chosen with uniform random\n+        // distribution in the range 1/2 to 5/8 of expiration time.\n+        std::chrono::seconds sleep_time_min(actual_lifetime / 2);\n+        std::chrono::seconds sleep_time_max(actual_lifetime * 5 / 8);\n+        sleep_time = sleep_time_min + GetRandMillis(sleep_time_max - sleep_time_min);",
      "path": "src/mapport.cpp",
      "position": null,
      "original_position": 194,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "4ef4eee3b7806ad3710c12cbf4e305a814ba8b40",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "4ef4eee3b7806ad3710c12cbf4e305a814ba8b40: this commit still uses `GetRandMillis`",
      "created_at": "2024-09-05T10:52:17Z",
      "updated_at": "2024-09-05T10:52:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1745243016",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1745243016"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 128,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1745244511",
      "pull_request_review_id": 2282568617,
      "id": 1745244511,
      "node_id": "PRRC_kwDOABII585oBlFf",
      "diff_hunk": "@@ -46,104 +43,96 @@ using namespace std::chrono_literals;\n static constexpr auto PORT_MAPPING_REANNOUNCE_PERIOD{20min};\n static constexpr auto PORT_MAPPING_RETRY_PERIOD{5min};\n \n-#ifdef USE_NATPMP\n-static uint16_t g_mapport_external_port = 0;\n-static bool NatpmpInit(natpmp_t* natpmp)\n+static bool ProcessPCP()\n {\n-    const int r_init = initnatpmp(natpmp, /* detect gateway automatically */ 0, /* forced gateway - NOT APPLIED*/ 0);\n-    if (r_init == 0) return true;\n-    LogPrintf(\"natpmp: initnatpmp() failed with %d error.\\n\", r_init);\n-    return false;\n-}\n+    // The same nonce is used for all mappings, this is allowed by the spec, and simplifies keeping track of them.\n+    PCPMappingNonce pcp_nonce;\n+    GetRandBytes(pcp_nonce);\n \n-static bool NatpmpDiscover(natpmp_t* natpmp, struct in_addr& external_ipv4_addr)\n-{\n-    const int r_send = sendpublicaddressrequest(natpmp);\n-    if (r_send == 2 /* OK */) {\n-        int r_read;\n-        natpmpresp_t response;\n-        do {\n-            r_read = readnatpmpresponseorretry(natpmp, &response);\n-        } while (r_read == NATPMP_TRYAGAIN);\n-\n-        if (r_read == 0) {\n-            external_ipv4_addr = response.pnu.publicaddress.addr;\n-            return true;\n-        } else if (r_read == NATPMP_ERR_NOGATEWAYSUPPORT) {\n-            LogPrintf(\"natpmp: The gateway does not support NAT-PMP.\\n\");\n+    bool ret = false;\n+    bool no_resources = false;\n+    const uint16_t private_port = GetListenPort();\n+    // Multiply the reannounce period by two, as we'll try to renew approximately halfway.\n+    const uint32_t requested_lifetime = std::chrono::seconds(PORT_MAPPING_REANNOUNCE_PERIOD * 2).count();\n+    uint32_t actual_lifetime = 0;\n+    std::chrono::milliseconds sleep_time;\n+\n+    // Local functor to handle result from PCP/NATPMP mapping.\n+    auto handle_mapping = [&](std::variant<MappingResult, MappingError> &res) -> void {\n+        if (MappingResult* mapping = std::get_if<MappingResult>(&res)) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Info, \"portmap: Added mapping %s\\n\", mapping->ToString());\n+            AddLocal(mapping->external, LOCAL_MAPPED);\n+            ret = true;\n+            actual_lifetime = std::min(actual_lifetime, mapping->lifetime);\n+        } else if (MappingError *err = std::get_if<MappingError>(&res)) {\n+            // Detailed error will already have been logged internally in respective Portmap function.\n+            if (*err == MappingError::NO_RESOURCES) {\n+                no_resources = true;\n+            }\n+        }\n+    };\n+\n+    do {\n+        actual_lifetime = requested_lifetime;\n+        no_resources = false; // Set to true if there was any \"no resources\" error.\n+        ret = false; // Set to true if any mapping succeeds.\n+\n+        // IPv4\n+        std::optional<CNetAddr> gateway4 = QueryDefaultGateway(NET_IPV4);\n+        if (!gateway4) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: Could not determine IPv4 default gateway\\n\");\n         } else {\n-            LogPrintf(\"natpmp: readnatpmpresponseorretry() for public address failed with %d error.\\n\", r_read);\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: gateway [IPv4]: %s\\n\", gateway4->ToStringAddr());\n+\n+            // Open a port mapping on whatever local address we have toward the gateway.\n+            struct in_addr inaddr_any;\n+            inaddr_any.s_addr = htonl(INADDR_ANY);\n+            auto res = PCPRequestPortMap(pcp_nonce, *gateway4, CNetAddr(inaddr_any), private_port, requested_lifetime);\n+            MappingError* pcp_err = std::get_if<MappingError>(&res);\n+            if (pcp_err && *pcp_err == MappingError::UNSUPP_VERSION) {\n+                LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: Got unsupported PCP version response, falling back to NAT-PMP\\n\");\n+                res = NATPMPRequestPortMap(*gateway4, private_port, requested_lifetime);\n+            }\n+            handle_mapping(res);\n         }\n-    } else {\n-        LogPrintf(\"natpmp: sendpublicaddressrequest() failed with %d error.\\n\", r_send);\n-    }\n \n-    return false;\n-}\n+        // IPv6\n+        std::optional<CNetAddr> gateway6 = QueryDefaultGateway(NET_IPV6);\n+        if (!gateway6) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: Could not determine IPv6 default gateway\\n\");\n+        } else {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Debug, \"portmap: gateway [IPv6]: %s\\n\", gateway6->ToStringAddr());\n \n-static bool NatpmpMapping(natpmp_t* natpmp, const struct in_addr& external_ipv4_addr, uint16_t private_port, bool& external_ip_discovered)\n-{\n-    const uint16_t suggested_external_port = g_mapport_external_port ? g_mapport_external_port : private_port;\n-    const int r_send = sendnewportmappingrequest(natpmp, NATPMP_PROTOCOL_TCP, private_port, suggested_external_port, 3600 /*seconds*/);\n-    if (r_send == 12 /* OK */) {\n-        int r_read;\n-        natpmpresp_t response;\n-        do {\n-            r_read = readnatpmpresponseorretry(natpmp, &response);\n-        } while (r_read == NATPMP_TRYAGAIN);\n-\n-        if (r_read == 0) {\n-            auto pm = response.pnu.newportmapping;\n-            if (private_port == pm.privateport && pm.lifetime > 0) {\n-                g_mapport_external_port = pm.mappedpublicport;\n-                const CService external{external_ipv4_addr, pm.mappedpublicport};\n-                if (!external_ip_discovered && fDiscover) {\n-                    AddLocal(external, LOCAL_MAPPED);\n-                    external_ip_discovered = true;\n-                }\n-                LogPrintf(\"natpmp: Port mapping successful. External address = %s\\n\", external.ToStringAddrPort());\n-                return true;\n-            } else {\n-                LogPrintf(\"natpmp: Port mapping failed.\\n\");\n+            // Try to open pinholes for all routable local IPv6 addresses.\n+            for (const auto &addr: GetLocalAddresses()) {\n+                if (!addr.IsRoutable() || !addr.IsIPv6()) continue;\n+                auto res = PCPRequestPortMap(pcp_nonce, *gateway6, addr, private_port, requested_lifetime);\n+                handle_mapping(res);\n             }\n-        } else if (r_read == NATPMP_ERR_NOGATEWAYSUPPORT) {\n-            LogPrintf(\"natpmp: The gateway does not support NAT-PMP.\\n\");\n-        } else {\n-            LogPrintf(\"natpmp: readnatpmpresponseorretry() for port mapping failed with %d error.\\n\", r_read);\n         }\n-    } else {\n-        LogPrintf(\"natpmp: sendnewportmappingrequest() failed with %d error.\\n\", r_send);\n-    }\n-\n-    return false;\n-}\n \n-static bool ProcessNatpmp()\n-{\n-    bool ret = false;\n-    natpmp_t natpmp;\n-    struct in_addr external_ipv4_addr;\n-    if (NatpmpInit(&natpmp) && NatpmpDiscover(&natpmp, external_ipv4_addr)) {\n-        bool external_ip_discovered = false;\n-        const uint16_t private_port = GetListenPort();\n-        do {\n-            ret = NatpmpMapping(&natpmp, external_ipv4_addr, private_port, external_ip_discovered);\n-        } while (ret && g_mapport_interrupt.sleep_for(PORT_MAPPING_REANNOUNCE_PERIOD));\n-        g_mapport_interrupt.reset();\n+        // Log message if we got NO_RESOURCES.\n+        if (no_resources) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"portmap: At least one mapping failed because of a NO_RESOURCES error. This usually indicates that the port is already used on the router. If this is the only instance of bitcoin running on the network, this will resolve itself automatically. Otherwise, you might want to choose a different P2P port to prevent this conflict.\\n\");\n+        }\n \n-        const int r_send = sendnewportmappingrequest(&natpmp, NATPMP_PROTOCOL_TCP, private_port, g_mapport_external_port, /* remove a port mapping */ 0);\n-        g_mapport_external_port = 0;\n-        if (r_send == 12 /* OK */) {\n-            LogPrintf(\"natpmp: Port mapping removed successfully.\\n\");\n-        } else {\n-            LogPrintf(\"natpmp: sendnewportmappingrequest(0) failed with %d error.\\n\", r_send);\n+        // Sanity-check returned lifetime.\n+        if (actual_lifetime < 30) {\n+            LogPrintLevel(BCLog::NET, BCLog::Level::Warning, \"portmap: Got impossibly short mapping lifetime of %d seconds\\n\", actual_lifetime);\n+            return false;\n         }\n-    }\n+        // RFC6887 11.2.1 recommends that clients send their first renewal packet at a time chosen with uniform random\n+        // distribution in the range 1/2 to 5/8 of expiration time.\n+        std::chrono::seconds sleep_time_min(actual_lifetime / 2);\n+        std::chrono::seconds sleep_time_max(actual_lifetime * 5 / 8);\n+        sleep_time = sleep_time_min + GetRandMillis(sleep_time_max - sleep_time_min);",
      "path": "src/mapport.cpp",
      "position": null,
      "original_position": 194,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "4ef4eee3b7806ad3710c12cbf4e305a814ba8b40",
      "in_reply_to_id": 1745243016,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Oh nvm, the fixup! commit isn't squashed yet.",
      "created_at": "2024-09-05T10:53:30Z",
      "updated_at": "2024-09-05T10:53:31Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1745244511",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1745244511"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 128,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1772017020",
      "pull_request_review_id": 2323214511,
      "id": 1772017020,
      "node_id": "PRRC_kwDOABII585pntV8",
      "diff_hunk": "@@ -0,0 +1,303 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <osreldate.h>\n+#if __FreeBSD_version >= 1400000\n+// Workaround https://github.com/freebsd/freebsd-src/pull/1070.\n+#define typeof __typeof\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+#elif defined(WIN32)\n+#include <iphlpapi.h>\n+#elif defined(__APPLE__)\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+#endif\n+\n+namespace {\n+\n+// Linux and FreeBSD 14.0+. For FreeBSD 13.2 the code can be compiled but\n+// running it requires loading a special kernel module, otherwise socket(AF_NETLINK,...)\n+// will fail, so we skip that.\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1400000)\n+\n+std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    auto sock{CreateSock(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (!sock) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.dst_data.\n+    const size_t dst_data_len = family == AF_INET ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    // Linux IPv4 / IPv6 - this must be present, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = family;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    // Linux IPv4 / IPv6 this must be absent, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock->Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    int64_t recv_result;\n+    do {\n+        recv_result = sock->Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, recv_result); hdr = NLMSG_NEXT(hdr, recv_result)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF && sizeof(int) == RTA_PAYLOAD(attr)) {\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (family == AF_INET && sizeof(in_addr) == RTA_PAYLOAD(rta_gateway)) {\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (family == AF_INET6 && sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway)) {\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    destination_address.si_family = family;\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    Assume(best_route.NextHop.si_family == family);\n+    if (family == AF_INET) {\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(family == AF_INET6) {\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+#define ROUNDUP32(a) \\\n+    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(uint32_t) - 1))) : sizeof(uint32_t))\n+\n+std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Check valid length. Note that sa_len is not part of POSIX, and exists on MacOS and some BSDs only, so we can't\n+    // do this check in SetSockAddr.\n+    if (!(addr->sa_family == AF_INET && addr->sa_len == sizeof(struct sockaddr_in)) &&\n+        !(addr->sa_family == AF_INET6 && addr->sa_len == sizeof(struct sockaddr_in6))) {\n+        return std::nullopt;\n+    }\n+\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+//! MacOS: Get default gateway from route table. See route(4) for the format.\n+std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // net.route.0.inet[6].flags.gateway\n+    int mib[] = {CTL_NET, PF_ROUTE, 0, family, NET_RT_FLAGS, RTF_GATEWAY};\n+    // The size of the available data is determined by calling sysctl() with oldp=nullptr. See sysctl(3).\n+    size_t l = 0;\n+    if (sysctl(/*name=*/mib, /*namelen=*/sizeof(mib) / sizeof(int), /*oldp=*/nullptr, /*oldlenp=*/&l, /*newp=*/nullptr, /*newlen=*/0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl length of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    std::vector<std::byte> buf(l);\n+    if (sysctl(/*name=*/mib, /*namelen=*/sizeof(mib) / sizeof(int), /*oldp=*/buf.data(), /*oldlenp=*/&l, /*newp=*/nullptr, /*newlen=*/0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl data of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    // Iterate over messages (each message is a routing table entry).\n+    for (size_t msg_pos = 0; msg_pos < buf.size(); ) {\n+        if ((msg_pos + sizeof(rt_msghdr)) > buf.size()) return std::nullopt;\n+        const struct rt_msghdr* rt = (const struct rt_msghdr*)(buf.data() + msg_pos);\n+        const size_t next_msg_pos = msg_pos + rt->rtm_msglen;\n+        if (rt->rtm_msglen < sizeof(rt_msghdr) || next_msg_pos > buf.size()) return std::nullopt;\n+        // Iterate over addresses within message, get destination and gateway (if present).\n+        // Address data starts after header.\n+        size_t sa_pos = msg_pos + sizeof(struct rt_msghdr);\n+        std::optional<CNetAddr> dst, gateway;\n+        for (int i = 0; i < RTAX_MAX; i++) {\n+            if (rt->rtm_addrs & (1 << i)) {\n+                // 2 is just sa_len + sa_family, the theoretical minimum size of a socket address.\n+                if ((sa_pos + 2) > next_msg_pos) return std::nullopt;\n+                const struct sockaddr* sa = (const struct sockaddr*)(buf.data() + sa_pos);\n+                if ((sa_pos + sa->sa_len) > next_msg_pos) return std::nullopt;\n+                if (i == RTAX_DST) {\n+                    dst = FromSockAddr(sa);\n+                } else if (i == RTAX_GATEWAY) {\n+                    gateway = FromSockAddr(sa);\n+                }\n+                // Skip sockaddr entries for bit flags we're not interested in,\n+                // move cursor.\n+                sa_pos += ROUNDUP32(sa->sa_len);\n+            }\n+        }\n+        // Found default gateway?\n+        if (dst && gateway && dst->IsBindAny()) { // Route to 0.0.0.0 or :: ?\n+            return *gateway;\n+        }\n+        // Skip to next message.\n+        msg_pos = next_msg_pos;\n+    }\n+    return std::nullopt;\n+}\n+\n+#else\n+\n+// Dummy implementation.\n+std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t)\n+{\n+    return std::nullopt;\n+}\n+\n+#endif\n+\n+}\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+\n+    sa_family_t family;\n+    if (network == NET_IPV4) {\n+        family = AF_INET;\n+    } else if(network == NET_IPV6) {\n+        family = AF_INET6;\n+    } else {\n+        return std::nullopt;\n+    }\n+\n+    std::optional<CNetAddr> ret = QueryDefaultGatewayImpl(family);\n+\n+    // It's possible for the default gateway to be 0.0.0.0 or ::0 on at least Windows\n+    // for some routing strategies. If so, return as if no default gateway was found.\n+    if (ret && !ret->IsBindAny()) {\n+        return ret;\n+    } else {\n+        return std::nullopt;\n+    }\n+}\n+\n+std::vector<CNetAddr> GetLocalAddresses()\n+{\n+    std::vector<CNetAddr> addresses;\n+#ifdef WIN32\n+    char pszHostName[256] = \"\";\n+    if (gethostname(pszHostName, sizeof(pszHostName)) != SOCKET_ERROR) {\n+        addresses = LookupHost(pszHostName, 0, true);",
      "path": "src/util/netif.cpp",
      "position": 281,
      "original_position": 281,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "e02030432b77abbf27bb4f67d879d3ad6d6366e6",
      "in_reply_to_id": null,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In e02030432b77abbf27bb4f67d879d3ad6d6366e6 \"net: Add netif utility\"\r\n\r\nIt seems a little bit odd to me to get the local addresses this way when the Windows header already being used by this file provides a [`GetAdaptersAddresses`](https://learn.microsoft.com/en-us/windows/win32/api/iphlpapi/nf-iphlpapi-getadaptersaddresses) function that appears to be equivalent to `getifaddrs`.",
      "created_at": "2024-09-23T20:12:04Z",
      "updated_at": "2024-09-23T21:43:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1772017020",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1772017020"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": 279,
      "original_start_line": 279,
      "start_side": "RIGHT",
      "line": 281,
      "original_line": 281,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1772081225",
      "pull_request_review_id": 2323214511,
      "id": 1772081225,
      "node_id": "PRRC_kwDOABII585pn9BJ",
      "diff_hunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/pcp.h>\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <span.h>\n+#include <util/check.h>\n+#include <util/netif.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+namespace {\n+\n+// RFC6886 NAT-PMP and RFC6887 Port Control Protocol (PCP) implementation.\n+// NAT-PMP and PCP use network byte order (big-endian).\n+\n+// NAT-PMP (v0) protocol constants.\n+//! NAT-PMP uses a fixed server port number (RFC6887 section 1.1).\n+constexpr uint16_t NATPMP_SERVER_PORT = 5351;\n+//! Version byte for NATPMP (RFC6886 1.1)\n+constexpr uint8_t NATPMP_VERSION = 0;\n+//! Request opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_REQUEST = 0x00;\n+//! Response opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_RESPONSE = 0x80;\n+//! Get external address (RFC6886 3.2)\n+constexpr uint8_t NATPMP_OP_GETEXTERNAL = 0x00;\n+//! Map TCP port (RFC6886 3.3)\n+constexpr uint8_t NATPMP_OP_MAP_TCP = 0x02;\n+//! Shared request header size in bytes.\n+constexpr size_t NATPMP_REQUEST_HDR_SIZE = 2;\n+//! Shared response header (minimum) size in bytes.\n+constexpr size_t NATPMP_RESPONSE_HDR_SIZE = 8;\n+//! GETEXTERNAL request size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 0;\n+//! GETEXTERNAL response size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 4;\n+//! MAP request size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 10;\n+//! MAP response size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 8;\n+\n+// Shared header offsets (RFC6886 3.2, 3.3), relative to start of packet.\n+//!  Offset of version field in packets.\n+constexpr size_t NATPMP_HDR_VERSION_OFS = 0;\n+//!  Offset of opcode field in packets\n+constexpr size_t NATPMP_HDR_OP_OFS = 1;\n+//!  Offset of result code in packets. Result codes are 16 bit in NAT-PMP instead of 8 bit in PCP.\n+constexpr size_t NATPMP_RESPONSE_HDR_RESULT_OFS = 2;\n+\n+// GETEXTERNAL response offsets (RFC6886 3.2), relative to start of packet.\n+//!  Returned external address\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_IP_OFS = 8;\n+\n+// MAP request offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port to be mapped.\n+constexpr size_t NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS = 4;\n+//!  Suggested external port for mapping.\n+constexpr size_t NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS = 6;\n+//!  Requested port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_REQUEST_LIFETIME_OFS = 8;\n+\n+// MAP response offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port for mapping (will match internal port of request).\n+constexpr size_t NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS = 8;\n+//!  External port for mapping.\n+constexpr size_t NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS = 10;\n+//!  Created port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_RESPONSE_LIFETIME_OFS = 12;\n+\n+// Relevant NETPMP result codes (RFC6886 3.5).\n+//! Result code representing success status.\n+constexpr uint8_t NATPMP_RESULT_SUCCESS = 0;\n+//! Result code representing unsupported version.\n+constexpr uint8_t NATPMP_RESULT_UNSUPP_VERSION = 1;\n+//! Result code representing lack of resources.\n+constexpr uint8_t NATPMP_RESULT_NO_RESOURCES = 4;\n+\n+//! Mapping of NATPMP result code to string (RFC6886 3.5). Result codes <=2 match PCP.\n+const std::map<uint8_t, std::string> NATPMP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"NETWORK_FAILURE\"},\n+    {4,  \"NO_RESOURCES\"},\n+    {5,  \"UNSUPP_OPCODE\"},\n+};\n+\n+// PCP (v2) protocol constants.\n+//! Maximum packet size in bytes (RFC6887 section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (RFC6887 section 19.1). Shared with NAT-PMP.\n+constexpr uint16_t PCP_SERVER_PORT = NATPMP_SERVER_PORT;\n+//! Version byte. 0 is NAT-PMP (RFC6886), 1 is forbidden, 2 for PCP (RFC6887).\n+constexpr uint8_t PCP_VERSION = 2;\n+//! PCP Request Header. See RFC6887 section 7.1. Shared with NAT-PMP.\n+constexpr uint8_t PCP_REQUEST = NATPMP_REQUEST; // R = 0\n+//! PCP Response Header. See RFC6887 section 7.2. Shared with NAT-PMP.\n+constexpr uint8_t PCP_RESPONSE = NATPMP_RESPONSE; // R = 1\n+//! Map opcode. See RFC6887 section 19.2\n+constexpr uint8_t PCP_OP_MAP = 0x01;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Request and response header size in bytes (RFC6887 section 7.1).\n+constexpr size_t PCP_HDR_SIZE = 24;\n+//! Map request and response size in bytes (RFC6887 section 11.1).\n+constexpr size_t PCP_MAP_SIZE = 36;\n+\n+// Header offsets shared between request and responses (RFC6887 7.1, 7.2), relative to start of packet.\n+//!  Version field (1 byte).\n+constexpr size_t PCP_HDR_VERSION_OFS = NATPMP_HDR_VERSION_OFS;\n+//!  Opcode field (1 byte).\n+constexpr size_t PCP_HDR_OP_OFS = NATPMP_HDR_OP_OFS;\n+//!  Requested lifetime (request), granted lifetime (response) (2 bytes).",
      "path": "src/util/pcp.cpp",
      "position": null,
      "original_position": 121,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "cbb053c5f6fa63b08fe8fb200b143cca64fc0626",
      "in_reply_to_id": null,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In cbb053c5f6fa63b08fe8fb200b143cca64fc0626 \"net: Add PCP and NATPMP implementation\"\r\n\r\nLifetime is 4 bytes.",
      "created_at": "2024-09-23T21:12:39Z",
      "updated_at": "2024-09-23T21:43:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1772081225",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1772081225"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 121,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1772139009",
      "pull_request_review_id": 2323214511,
      "id": 1772139009,
      "node_id": "PRRC_kwDOABII585poLIB",
      "diff_hunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/pcp.h>\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <span.h>\n+#include <util/check.h>\n+#include <util/netif.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+namespace {\n+\n+// RFC6886 NAT-PMP and RFC6887 Port Control Protocol (PCP) implementation.\n+// NAT-PMP and PCP use network byte order (big-endian).\n+\n+// NAT-PMP (v0) protocol constants.\n+//! NAT-PMP uses a fixed server port number (RFC6887 section 1.1).\n+constexpr uint16_t NATPMP_SERVER_PORT = 5351;\n+//! Version byte for NATPMP (RFC6886 1.1)\n+constexpr uint8_t NATPMP_VERSION = 0;\n+//! Request opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_REQUEST = 0x00;\n+//! Response opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_RESPONSE = 0x80;\n+//! Get external address (RFC6886 3.2)\n+constexpr uint8_t NATPMP_OP_GETEXTERNAL = 0x00;\n+//! Map TCP port (RFC6886 3.3)\n+constexpr uint8_t NATPMP_OP_MAP_TCP = 0x02;\n+//! Shared request header size in bytes.\n+constexpr size_t NATPMP_REQUEST_HDR_SIZE = 2;\n+//! Shared response header (minimum) size in bytes.\n+constexpr size_t NATPMP_RESPONSE_HDR_SIZE = 8;\n+//! GETEXTERNAL request size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 0;\n+//! GETEXTERNAL response size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 4;\n+//! MAP request size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 10;\n+//! MAP response size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 8;\n+\n+// Shared header offsets (RFC6886 3.2, 3.3), relative to start of packet.\n+//!  Offset of version field in packets.\n+constexpr size_t NATPMP_HDR_VERSION_OFS = 0;\n+//!  Offset of opcode field in packets\n+constexpr size_t NATPMP_HDR_OP_OFS = 1;\n+//!  Offset of result code in packets. Result codes are 16 bit in NAT-PMP instead of 8 bit in PCP.\n+constexpr size_t NATPMP_RESPONSE_HDR_RESULT_OFS = 2;\n+\n+// GETEXTERNAL response offsets (RFC6886 3.2), relative to start of packet.\n+//!  Returned external address\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_IP_OFS = 8;\n+\n+// MAP request offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port to be mapped.\n+constexpr size_t NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS = 4;\n+//!  Suggested external port for mapping.\n+constexpr size_t NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS = 6;\n+//!  Requested port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_REQUEST_LIFETIME_OFS = 8;\n+\n+// MAP response offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port for mapping (will match internal port of request).\n+constexpr size_t NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS = 8;\n+//!  External port for mapping.\n+constexpr size_t NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS = 10;\n+//!  Created port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_RESPONSE_LIFETIME_OFS = 12;\n+\n+// Relevant NETPMP result codes (RFC6886 3.5).\n+//! Result code representing success status.\n+constexpr uint8_t NATPMP_RESULT_SUCCESS = 0;\n+//! Result code representing unsupported version.\n+constexpr uint8_t NATPMP_RESULT_UNSUPP_VERSION = 1;\n+//! Result code representing lack of resources.\n+constexpr uint8_t NATPMP_RESULT_NO_RESOURCES = 4;\n+\n+//! Mapping of NATPMP result code to string (RFC6886 3.5). Result codes <=2 match PCP.\n+const std::map<uint8_t, std::string> NATPMP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"NETWORK_FAILURE\"},\n+    {4,  \"NO_RESOURCES\"},\n+    {5,  \"UNSUPP_OPCODE\"},\n+};\n+\n+// PCP (v2) protocol constants.\n+//! Maximum packet size in bytes (RFC6887 section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (RFC6887 section 19.1). Shared with NAT-PMP.\n+constexpr uint16_t PCP_SERVER_PORT = NATPMP_SERVER_PORT;\n+//! Version byte. 0 is NAT-PMP (RFC6886), 1 is forbidden, 2 for PCP (RFC6887).\n+constexpr uint8_t PCP_VERSION = 2;\n+//! PCP Request Header. See RFC6887 section 7.1. Shared with NAT-PMP.\n+constexpr uint8_t PCP_REQUEST = NATPMP_REQUEST; // R = 0\n+//! PCP Response Header. See RFC6887 section 7.2. Shared with NAT-PMP.\n+constexpr uint8_t PCP_RESPONSE = NATPMP_RESPONSE; // R = 1\n+//! Map opcode. See RFC6887 section 19.2\n+constexpr uint8_t PCP_OP_MAP = 0x01;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Request and response header size in bytes (RFC6887 section 7.1).\n+constexpr size_t PCP_HDR_SIZE = 24;\n+//! Map request and response size in bytes (RFC6887 section 11.1).\n+constexpr size_t PCP_MAP_SIZE = 36;\n+\n+// Header offsets shared between request and responses (RFC6887 7.1, 7.2), relative to start of packet.\n+//!  Version field (1 byte).\n+constexpr size_t PCP_HDR_VERSION_OFS = NATPMP_HDR_VERSION_OFS;\n+//!  Opcode field (1 byte).\n+constexpr size_t PCP_HDR_OP_OFS = NATPMP_HDR_OP_OFS;\n+//!  Requested lifetime (request), granted lifetime (response) (2 bytes).\n+constexpr size_t PCP_HDR_LIFETIME_OFS = 4;\n+\n+// Request header offsets (RFC6887 7.1), relative to start of packet.\n+//!  PCP client's IP address (16 bytes).\n+constexpr size_t PCP_REQUEST_HDR_IP_OFS = 8;\n+\n+// Response header offsets (RFC6887 7.2), relative to start of packet.\n+//!  Result code (1 byte).\n+constexpr size_t PCP_RESPONSE_HDR_RESULT_OFS = 3;\n+\n+// MAP request/response offsets (RFC6887 11.1), relative to start of opcode-specific data.\n+//!  Mapping nonce (12 bytes).\n+constexpr size_t PCP_MAP_NONCE_OFS = 0;\n+//!  Protocol (1 byte).\n+constexpr size_t PCP_MAP_PROTOCOL_OFS = 12;\n+//!  Internal port for mapping (2 bytes).\n+constexpr size_t PCP_MAP_INTERNAL_PORT_OFS = 16;\n+//!  Suggested external port (request), assigned external port (response) (2 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_PORT_OFS = 18;\n+//!  Suggested external IP (request), assigned external IP (response) (16 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_IP_OFS = 20;\n+\n+//! Result code representing success (RFC6887 7.4), shared with NAT-PMP.\n+constexpr uint8_t PCP_RESULT_SUCCESS = NATPMP_RESULT_SUCCESS;\n+//! Result code representing lack of resources (RFC6887 7.4).\n+constexpr uint8_t PCP_RESULT_NO_RESOURCES = 8;\n+\n+//! Mapping of PCP result code to string (RFC6887 7.4). Result codes <=2 match NAT-PMP.\n+const std::map<uint8_t, std::string> PCP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"MALFORMED_REQUEST\"},\n+    {4,  \"UNSUPP_OPCODE\"},\n+    {5,  \"UNSUPP_OPTION\"},\n+    {6,  \"MALFORMED_OPTION\"},\n+    {7,  \"NETWORK_FAILURE\"},\n+    {8,  \"NO_RESOURCES\"},\n+    {9,  \"UNSUPP_PROTOCOL\"},\n+    {10, \"USER_EX_QUOTA\"},\n+    {11, \"CANNOT_PROVIDE_EXTERNAL\"},\n+    {12, \"ADDRESS_MISMATCH\"},\n+    {13, \"EXCESSIVE_REMOTE_PEER\"},\n+};\n+\n+//! Return human-readable string from NATPMP result code.\n+std::string NATPMPResultString(uint8_t result_code)\n+{\n+    auto result_i = NATPMP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == NATPMP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Return human-readable string from PCP result code.\n+std::string PCPResultString(uint8_t result_code)\n+{\n+    auto result_i = PCP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == PCP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Wrap address in IPv6 according to RFC6887. wrapped_addr needs to be able to store 16 bytes.\n+[[nodiscard]] bool PCPWrapAddress(Span<uint8_t> wrapped_addr, const CNetAddr &addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (addr.IsIPv4()) {\n+        struct in_addr addr4;\n+        if (!addr.GetInAddr(&addr4)) return false;\n+        // Section 5: \"When the address field holds an IPv4 address, an IPv4-mapped IPv6 address [RFC4291] is used (::ffff:0:0/96).\"\n+        std::memcpy(wrapped_addr.data(), IPV4_IN_IPV6_PREFIX.data(), IPV4_IN_IPV6_PREFIX.size());\n+        std::memcpy(wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), &addr4, ADDR_IPV4_SIZE);\n+        return true;\n+    } else if (addr.IsIPv6()) {\n+        struct in6_addr addr6;\n+        if (!addr.GetIn6Addr(&addr6)) return false;\n+        std::memcpy(wrapped_addr.data(), &addr6, ADDR_IPV6_SIZE);\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+//! Unwrap PCP-encoded address according to RFC6887.\n+CNetAddr PCPUnwrapAddress(Span<const uint8_t> wrapped_addr)",
      "path": "src/util/pcp.cpp",
      "position": 203,
      "original_position": 203,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "cbb053c5f6fa63b08fe8fb200b143cca64fc0626",
      "in_reply_to_id": null,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In cbb053c5f6fa63b08fe8fb200b143cca64fc0626 \"net: Add PCP and NATPMP implementation\"\r\n\r\n`CNetAddr` has a `SetLegacyIPv6` method which does the same thing. Could use that instead of duplicating implementation.",
      "created_at": "2024-09-23T21:30:34Z",
      "updated_at": "2024-09-23T21:43:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1772139009",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1772139009"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 203,
      "original_line": 203,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1772790585",
      "pull_request_review_id": 2324333782,
      "id": 1772790585,
      "node_id": "PRRC_kwDOABII585pqqM5",
      "diff_hunk": "@@ -0,0 +1,303 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <osreldate.h>\n+#if __FreeBSD_version >= 1400000\n+// Workaround https://github.com/freebsd/freebsd-src/pull/1070.\n+#define typeof __typeof\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+#elif defined(WIN32)\n+#include <iphlpapi.h>\n+#elif defined(__APPLE__)\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+#endif\n+\n+namespace {\n+\n+// Linux and FreeBSD 14.0+. For FreeBSD 13.2 the code can be compiled but\n+// running it requires loading a special kernel module, otherwise socket(AF_NETLINK,...)\n+// will fail, so we skip that.\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1400000)\n+\n+std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    auto sock{CreateSock(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (!sock) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.dst_data.\n+    const size_t dst_data_len = family == AF_INET ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    // Linux IPv4 / IPv6 - this must be present, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = family;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    // Linux IPv4 / IPv6 this must be absent, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock->Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    int64_t recv_result;\n+    do {\n+        recv_result = sock->Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, recv_result); hdr = NLMSG_NEXT(hdr, recv_result)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF && sizeof(int) == RTA_PAYLOAD(attr)) {\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (family == AF_INET && sizeof(in_addr) == RTA_PAYLOAD(rta_gateway)) {\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (family == AF_INET6 && sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway)) {\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    destination_address.si_family = family;\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    Assume(best_route.NextHop.si_family == family);\n+    if (family == AF_INET) {\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(family == AF_INET6) {\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+#define ROUNDUP32(a) \\\n+    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(uint32_t) - 1))) : sizeof(uint32_t))\n+\n+std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Check valid length. Note that sa_len is not part of POSIX, and exists on MacOS and some BSDs only, so we can't\n+    // do this check in SetSockAddr.\n+    if (!(addr->sa_family == AF_INET && addr->sa_len == sizeof(struct sockaddr_in)) &&\n+        !(addr->sa_family == AF_INET6 && addr->sa_len == sizeof(struct sockaddr_in6))) {\n+        return std::nullopt;\n+    }\n+\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+//! MacOS: Get default gateway from route table. See route(4) for the format.\n+std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // net.route.0.inet[6].flags.gateway\n+    int mib[] = {CTL_NET, PF_ROUTE, 0, family, NET_RT_FLAGS, RTF_GATEWAY};\n+    // The size of the available data is determined by calling sysctl() with oldp=nullptr. See sysctl(3).\n+    size_t l = 0;\n+    if (sysctl(/*name=*/mib, /*namelen=*/sizeof(mib) / sizeof(int), /*oldp=*/nullptr, /*oldlenp=*/&l, /*newp=*/nullptr, /*newlen=*/0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl length of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    std::vector<std::byte> buf(l);\n+    if (sysctl(/*name=*/mib, /*namelen=*/sizeof(mib) / sizeof(int), /*oldp=*/buf.data(), /*oldlenp=*/&l, /*newp=*/nullptr, /*newlen=*/0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl data of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    // Iterate over messages (each message is a routing table entry).\n+    for (size_t msg_pos = 0; msg_pos < buf.size(); ) {\n+        if ((msg_pos + sizeof(rt_msghdr)) > buf.size()) return std::nullopt;\n+        const struct rt_msghdr* rt = (const struct rt_msghdr*)(buf.data() + msg_pos);\n+        const size_t next_msg_pos = msg_pos + rt->rtm_msglen;\n+        if (rt->rtm_msglen < sizeof(rt_msghdr) || next_msg_pos > buf.size()) return std::nullopt;\n+        // Iterate over addresses within message, get destination and gateway (if present).\n+        // Address data starts after header.\n+        size_t sa_pos = msg_pos + sizeof(struct rt_msghdr);\n+        std::optional<CNetAddr> dst, gateway;\n+        for (int i = 0; i < RTAX_MAX; i++) {\n+            if (rt->rtm_addrs & (1 << i)) {\n+                // 2 is just sa_len + sa_family, the theoretical minimum size of a socket address.\n+                if ((sa_pos + 2) > next_msg_pos) return std::nullopt;\n+                const struct sockaddr* sa = (const struct sockaddr*)(buf.data() + sa_pos);\n+                if ((sa_pos + sa->sa_len) > next_msg_pos) return std::nullopt;\n+                if (i == RTAX_DST) {\n+                    dst = FromSockAddr(sa);\n+                } else if (i == RTAX_GATEWAY) {\n+                    gateway = FromSockAddr(sa);\n+                }\n+                // Skip sockaddr entries for bit flags we're not interested in,\n+                // move cursor.\n+                sa_pos += ROUNDUP32(sa->sa_len);\n+            }\n+        }\n+        // Found default gateway?\n+        if (dst && gateway && dst->IsBindAny()) { // Route to 0.0.0.0 or :: ?\n+            return *gateway;\n+        }\n+        // Skip to next message.\n+        msg_pos = next_msg_pos;\n+    }\n+    return std::nullopt;\n+}\n+\n+#else\n+\n+// Dummy implementation.\n+std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t)\n+{\n+    return std::nullopt;\n+}\n+\n+#endif\n+\n+}\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+\n+    sa_family_t family;\n+    if (network == NET_IPV4) {\n+        family = AF_INET;\n+    } else if(network == NET_IPV6) {\n+        family = AF_INET6;\n+    } else {\n+        return std::nullopt;\n+    }\n+\n+    std::optional<CNetAddr> ret = QueryDefaultGatewayImpl(family);\n+\n+    // It's possible for the default gateway to be 0.0.0.0 or ::0 on at least Windows\n+    // for some routing strategies. If so, return as if no default gateway was found.\n+    if (ret && !ret->IsBindAny()) {\n+        return ret;\n+    } else {\n+        return std::nullopt;\n+    }\n+}\n+\n+std::vector<CNetAddr> GetLocalAddresses()\n+{\n+    std::vector<CNetAddr> addresses;\n+#ifdef WIN32\n+    char pszHostName[256] = \"\";\n+    if (gethostname(pszHostName, sizeof(pszHostName)) != SOCKET_ERROR) {\n+        addresses = LookupHost(pszHostName, 0, true);",
      "path": "src/util/netif.cpp",
      "position": 281,
      "original_position": 281,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "e02030432b77abbf27bb4f67d879d3ad6d6366e6",
      "in_reply_to_id": 1772017020,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Completely agree, but i think it's out of scope for this PR to change this. This function was literally transplanted from net.cpp's `Discover`. It's a satoshi-ism that has worked for all previous versions, changing it should probably be carefullly considered and tested in a seperate PR. \r\n(like i did for #29984)",
      "created_at": "2024-09-24T07:34:59Z",
      "updated_at": "2024-09-24T07:56:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1772790585",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1772790585"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": 279,
      "original_start_line": 279,
      "start_side": "RIGHT",
      "line": 281,
      "original_line": 281,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1772793740",
      "pull_request_review_id": 2324339075,
      "id": 1772793740,
      "node_id": "PRRC_kwDOABII585pqq-M",
      "diff_hunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/pcp.h>\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <span.h>\n+#include <util/check.h>\n+#include <util/netif.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+namespace {\n+\n+// RFC6886 NAT-PMP and RFC6887 Port Control Protocol (PCP) implementation.\n+// NAT-PMP and PCP use network byte order (big-endian).\n+\n+// NAT-PMP (v0) protocol constants.\n+//! NAT-PMP uses a fixed server port number (RFC6887 section 1.1).\n+constexpr uint16_t NATPMP_SERVER_PORT = 5351;\n+//! Version byte for NATPMP (RFC6886 1.1)\n+constexpr uint8_t NATPMP_VERSION = 0;\n+//! Request opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_REQUEST = 0x00;\n+//! Response opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_RESPONSE = 0x80;\n+//! Get external address (RFC6886 3.2)\n+constexpr uint8_t NATPMP_OP_GETEXTERNAL = 0x00;\n+//! Map TCP port (RFC6886 3.3)\n+constexpr uint8_t NATPMP_OP_MAP_TCP = 0x02;\n+//! Shared request header size in bytes.\n+constexpr size_t NATPMP_REQUEST_HDR_SIZE = 2;\n+//! Shared response header (minimum) size in bytes.\n+constexpr size_t NATPMP_RESPONSE_HDR_SIZE = 8;\n+//! GETEXTERNAL request size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 0;\n+//! GETEXTERNAL response size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 4;\n+//! MAP request size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 10;\n+//! MAP response size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 8;\n+\n+// Shared header offsets (RFC6886 3.2, 3.3), relative to start of packet.\n+//!  Offset of version field in packets.\n+constexpr size_t NATPMP_HDR_VERSION_OFS = 0;\n+//!  Offset of opcode field in packets\n+constexpr size_t NATPMP_HDR_OP_OFS = 1;\n+//!  Offset of result code in packets. Result codes are 16 bit in NAT-PMP instead of 8 bit in PCP.\n+constexpr size_t NATPMP_RESPONSE_HDR_RESULT_OFS = 2;\n+\n+// GETEXTERNAL response offsets (RFC6886 3.2), relative to start of packet.\n+//!  Returned external address\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_IP_OFS = 8;\n+\n+// MAP request offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port to be mapped.\n+constexpr size_t NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS = 4;\n+//!  Suggested external port for mapping.\n+constexpr size_t NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS = 6;\n+//!  Requested port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_REQUEST_LIFETIME_OFS = 8;\n+\n+// MAP response offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port for mapping (will match internal port of request).\n+constexpr size_t NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS = 8;\n+//!  External port for mapping.\n+constexpr size_t NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS = 10;\n+//!  Created port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_RESPONSE_LIFETIME_OFS = 12;\n+\n+// Relevant NETPMP result codes (RFC6886 3.5).\n+//! Result code representing success status.\n+constexpr uint8_t NATPMP_RESULT_SUCCESS = 0;\n+//! Result code representing unsupported version.\n+constexpr uint8_t NATPMP_RESULT_UNSUPP_VERSION = 1;\n+//! Result code representing lack of resources.\n+constexpr uint8_t NATPMP_RESULT_NO_RESOURCES = 4;\n+\n+//! Mapping of NATPMP result code to string (RFC6886 3.5). Result codes <=2 match PCP.\n+const std::map<uint8_t, std::string> NATPMP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"NETWORK_FAILURE\"},\n+    {4,  \"NO_RESOURCES\"},\n+    {5,  \"UNSUPP_OPCODE\"},\n+};\n+\n+// PCP (v2) protocol constants.\n+//! Maximum packet size in bytes (RFC6887 section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (RFC6887 section 19.1). Shared with NAT-PMP.\n+constexpr uint16_t PCP_SERVER_PORT = NATPMP_SERVER_PORT;\n+//! Version byte. 0 is NAT-PMP (RFC6886), 1 is forbidden, 2 for PCP (RFC6887).\n+constexpr uint8_t PCP_VERSION = 2;\n+//! PCP Request Header. See RFC6887 section 7.1. Shared with NAT-PMP.\n+constexpr uint8_t PCP_REQUEST = NATPMP_REQUEST; // R = 0\n+//! PCP Response Header. See RFC6887 section 7.2. Shared with NAT-PMP.\n+constexpr uint8_t PCP_RESPONSE = NATPMP_RESPONSE; // R = 1\n+//! Map opcode. See RFC6887 section 19.2\n+constexpr uint8_t PCP_OP_MAP = 0x01;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Request and response header size in bytes (RFC6887 section 7.1).\n+constexpr size_t PCP_HDR_SIZE = 24;\n+//! Map request and response size in bytes (RFC6887 section 11.1).\n+constexpr size_t PCP_MAP_SIZE = 36;\n+\n+// Header offsets shared between request and responses (RFC6887 7.1, 7.2), relative to start of packet.\n+//!  Version field (1 byte).\n+constexpr size_t PCP_HDR_VERSION_OFS = NATPMP_HDR_VERSION_OFS;\n+//!  Opcode field (1 byte).\n+constexpr size_t PCP_HDR_OP_OFS = NATPMP_HDR_OP_OFS;\n+//!  Requested lifetime (request), granted lifetime (response) (2 bytes).\n+constexpr size_t PCP_HDR_LIFETIME_OFS = 4;\n+\n+// Request header offsets (RFC6887 7.1), relative to start of packet.\n+//!  PCP client's IP address (16 bytes).\n+constexpr size_t PCP_REQUEST_HDR_IP_OFS = 8;\n+\n+// Response header offsets (RFC6887 7.2), relative to start of packet.\n+//!  Result code (1 byte).\n+constexpr size_t PCP_RESPONSE_HDR_RESULT_OFS = 3;\n+\n+// MAP request/response offsets (RFC6887 11.1), relative to start of opcode-specific data.\n+//!  Mapping nonce (12 bytes).\n+constexpr size_t PCP_MAP_NONCE_OFS = 0;\n+//!  Protocol (1 byte).\n+constexpr size_t PCP_MAP_PROTOCOL_OFS = 12;\n+//!  Internal port for mapping (2 bytes).\n+constexpr size_t PCP_MAP_INTERNAL_PORT_OFS = 16;\n+//!  Suggested external port (request), assigned external port (response) (2 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_PORT_OFS = 18;\n+//!  Suggested external IP (request), assigned external IP (response) (16 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_IP_OFS = 20;\n+\n+//! Result code representing success (RFC6887 7.4), shared with NAT-PMP.\n+constexpr uint8_t PCP_RESULT_SUCCESS = NATPMP_RESULT_SUCCESS;\n+//! Result code representing lack of resources (RFC6887 7.4).\n+constexpr uint8_t PCP_RESULT_NO_RESOURCES = 8;\n+\n+//! Mapping of PCP result code to string (RFC6887 7.4). Result codes <=2 match NAT-PMP.\n+const std::map<uint8_t, std::string> PCP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"MALFORMED_REQUEST\"},\n+    {4,  \"UNSUPP_OPCODE\"},\n+    {5,  \"UNSUPP_OPTION\"},\n+    {6,  \"MALFORMED_OPTION\"},\n+    {7,  \"NETWORK_FAILURE\"},\n+    {8,  \"NO_RESOURCES\"},\n+    {9,  \"UNSUPP_PROTOCOL\"},\n+    {10, \"USER_EX_QUOTA\"},\n+    {11, \"CANNOT_PROVIDE_EXTERNAL\"},\n+    {12, \"ADDRESS_MISMATCH\"},\n+    {13, \"EXCESSIVE_REMOTE_PEER\"},\n+};\n+\n+//! Return human-readable string from NATPMP result code.\n+std::string NATPMPResultString(uint8_t result_code)\n+{\n+    auto result_i = NATPMP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == NATPMP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Return human-readable string from PCP result code.\n+std::string PCPResultString(uint8_t result_code)\n+{\n+    auto result_i = PCP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == PCP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Wrap address in IPv6 according to RFC6887. wrapped_addr needs to be able to store 16 bytes.\n+[[nodiscard]] bool PCPWrapAddress(Span<uint8_t> wrapped_addr, const CNetAddr &addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (addr.IsIPv4()) {\n+        struct in_addr addr4;\n+        if (!addr.GetInAddr(&addr4)) return false;\n+        // Section 5: \"When the address field holds an IPv4 address, an IPv4-mapped IPv6 address [RFC4291] is used (::ffff:0:0/96).\"\n+        std::memcpy(wrapped_addr.data(), IPV4_IN_IPV6_PREFIX.data(), IPV4_IN_IPV6_PREFIX.size());\n+        std::memcpy(wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), &addr4, ADDR_IPV4_SIZE);\n+        return true;\n+    } else if (addr.IsIPv6()) {\n+        struct in6_addr addr6;\n+        if (!addr.GetIn6Addr(&addr6)) return false;\n+        std::memcpy(wrapped_addr.data(), &addr6, ADDR_IPV6_SIZE);\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+//! Unwrap PCP-encoded address according to RFC6887.\n+CNetAddr PCPUnwrapAddress(Span<const uint8_t> wrapped_addr)",
      "path": "src/util/pcp.cpp",
      "position": 203,
      "original_position": 203,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "cbb053c5f6fa63b08fe8fb200b143cca64fc0626",
      "in_reply_to_id": 1772139009,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "i looked into that at thet time but  but remember the implementation was ever so slightly different from specified in the RFC, so thought it was more clear to implement it here exactly according to that, instead of relying on an external function that's beholden to bitcoin's requirements. Fine with doing this, though.\r\n\r\nEdit: especially as *legacy* sort of sounds like *to be deprecated* to me.",
      "created_at": "2024-09-24T07:37:24Z",
      "updated_at": "2024-09-24T07:37:55Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1772793740",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1772793740"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 203,
      "original_line": 203,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1772803946",
      "pull_request_review_id": 2324356629,
      "id": 1772803946,
      "node_id": "PRRC_kwDOABII585pqtdq",
      "diff_hunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/pcp.h>\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <span.h>\n+#include <util/check.h>\n+#include <util/netif.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+namespace {\n+\n+// RFC6886 NAT-PMP and RFC6887 Port Control Protocol (PCP) implementation.\n+// NAT-PMP and PCP use network byte order (big-endian).\n+\n+// NAT-PMP (v0) protocol constants.\n+//! NAT-PMP uses a fixed server port number (RFC6887 section 1.1).\n+constexpr uint16_t NATPMP_SERVER_PORT = 5351;\n+//! Version byte for NATPMP (RFC6886 1.1)\n+constexpr uint8_t NATPMP_VERSION = 0;\n+//! Request opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_REQUEST = 0x00;\n+//! Response opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_RESPONSE = 0x80;\n+//! Get external address (RFC6886 3.2)\n+constexpr uint8_t NATPMP_OP_GETEXTERNAL = 0x00;\n+//! Map TCP port (RFC6886 3.3)\n+constexpr uint8_t NATPMP_OP_MAP_TCP = 0x02;\n+//! Shared request header size in bytes.\n+constexpr size_t NATPMP_REQUEST_HDR_SIZE = 2;\n+//! Shared response header (minimum) size in bytes.\n+constexpr size_t NATPMP_RESPONSE_HDR_SIZE = 8;\n+//! GETEXTERNAL request size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 0;\n+//! GETEXTERNAL response size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 4;\n+//! MAP request size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 10;\n+//! MAP response size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 8;\n+\n+// Shared header offsets (RFC6886 3.2, 3.3), relative to start of packet.\n+//!  Offset of version field in packets.\n+constexpr size_t NATPMP_HDR_VERSION_OFS = 0;\n+//!  Offset of opcode field in packets\n+constexpr size_t NATPMP_HDR_OP_OFS = 1;\n+//!  Offset of result code in packets. Result codes are 16 bit in NAT-PMP instead of 8 bit in PCP.\n+constexpr size_t NATPMP_RESPONSE_HDR_RESULT_OFS = 2;\n+\n+// GETEXTERNAL response offsets (RFC6886 3.2), relative to start of packet.\n+//!  Returned external address\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_IP_OFS = 8;\n+\n+// MAP request offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port to be mapped.\n+constexpr size_t NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS = 4;\n+//!  Suggested external port for mapping.\n+constexpr size_t NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS = 6;\n+//!  Requested port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_REQUEST_LIFETIME_OFS = 8;\n+\n+// MAP response offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port for mapping (will match internal port of request).\n+constexpr size_t NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS = 8;\n+//!  External port for mapping.\n+constexpr size_t NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS = 10;\n+//!  Created port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_RESPONSE_LIFETIME_OFS = 12;\n+\n+// Relevant NETPMP result codes (RFC6886 3.5).\n+//! Result code representing success status.\n+constexpr uint8_t NATPMP_RESULT_SUCCESS = 0;\n+//! Result code representing unsupported version.\n+constexpr uint8_t NATPMP_RESULT_UNSUPP_VERSION = 1;\n+//! Result code representing lack of resources.\n+constexpr uint8_t NATPMP_RESULT_NO_RESOURCES = 4;\n+\n+//! Mapping of NATPMP result code to string (RFC6886 3.5). Result codes <=2 match PCP.\n+const std::map<uint8_t, std::string> NATPMP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"NETWORK_FAILURE\"},\n+    {4,  \"NO_RESOURCES\"},\n+    {5,  \"UNSUPP_OPCODE\"},\n+};\n+\n+// PCP (v2) protocol constants.\n+//! Maximum packet size in bytes (RFC6887 section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (RFC6887 section 19.1). Shared with NAT-PMP.\n+constexpr uint16_t PCP_SERVER_PORT = NATPMP_SERVER_PORT;\n+//! Version byte. 0 is NAT-PMP (RFC6886), 1 is forbidden, 2 for PCP (RFC6887).\n+constexpr uint8_t PCP_VERSION = 2;\n+//! PCP Request Header. See RFC6887 section 7.1. Shared with NAT-PMP.\n+constexpr uint8_t PCP_REQUEST = NATPMP_REQUEST; // R = 0\n+//! PCP Response Header. See RFC6887 section 7.2. Shared with NAT-PMP.\n+constexpr uint8_t PCP_RESPONSE = NATPMP_RESPONSE; // R = 1\n+//! Map opcode. See RFC6887 section 19.2\n+constexpr uint8_t PCP_OP_MAP = 0x01;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Request and response header size in bytes (RFC6887 section 7.1).\n+constexpr size_t PCP_HDR_SIZE = 24;\n+//! Map request and response size in bytes (RFC6887 section 11.1).\n+constexpr size_t PCP_MAP_SIZE = 36;\n+\n+// Header offsets shared between request and responses (RFC6887 7.1, 7.2), relative to start of packet.\n+//!  Version field (1 byte).\n+constexpr size_t PCP_HDR_VERSION_OFS = NATPMP_HDR_VERSION_OFS;\n+//!  Opcode field (1 byte).\n+constexpr size_t PCP_HDR_OP_OFS = NATPMP_HDR_OP_OFS;\n+//!  Requested lifetime (request), granted lifetime (response) (2 bytes).",
      "path": "src/util/pcp.cpp",
      "position": null,
      "original_position": 121,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "cbb053c5f6fa63b08fe8fb200b143cca64fc0626",
      "in_reply_to_id": 1772081225,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Thanks, will update",
      "created_at": "2024-09-24T07:44:17Z",
      "updated_at": "2024-09-24T07:44:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1772803946",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1772803946"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 121,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1772921229",
      "pull_request_review_id": 2324547709,
      "id": 1772921229,
      "node_id": "PRRC_kwDOABII585prKGN",
      "diff_hunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/pcp.h>\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <span.h>\n+#include <util/check.h>\n+#include <util/netif.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+namespace {\n+\n+// RFC6886 NAT-PMP and RFC6887 Port Control Protocol (PCP) implementation.\n+// NAT-PMP and PCP use network byte order (big-endian).\n+\n+// NAT-PMP (v0) protocol constants.\n+//! NAT-PMP uses a fixed server port number (RFC6887 section 1.1).\n+constexpr uint16_t NATPMP_SERVER_PORT = 5351;\n+//! Version byte for NATPMP (RFC6886 1.1)\n+constexpr uint8_t NATPMP_VERSION = 0;\n+//! Request opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_REQUEST = 0x00;\n+//! Response opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_RESPONSE = 0x80;\n+//! Get external address (RFC6886 3.2)\n+constexpr uint8_t NATPMP_OP_GETEXTERNAL = 0x00;\n+//! Map TCP port (RFC6886 3.3)\n+constexpr uint8_t NATPMP_OP_MAP_TCP = 0x02;\n+//! Shared request header size in bytes.\n+constexpr size_t NATPMP_REQUEST_HDR_SIZE = 2;\n+//! Shared response header (minimum) size in bytes.\n+constexpr size_t NATPMP_RESPONSE_HDR_SIZE = 8;\n+//! GETEXTERNAL request size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 0;\n+//! GETEXTERNAL response size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 4;\n+//! MAP request size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 10;\n+//! MAP response size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 8;\n+\n+// Shared header offsets (RFC6886 3.2, 3.3), relative to start of packet.\n+//!  Offset of version field in packets.\n+constexpr size_t NATPMP_HDR_VERSION_OFS = 0;\n+//!  Offset of opcode field in packets\n+constexpr size_t NATPMP_HDR_OP_OFS = 1;\n+//!  Offset of result code in packets. Result codes are 16 bit in NAT-PMP instead of 8 bit in PCP.\n+constexpr size_t NATPMP_RESPONSE_HDR_RESULT_OFS = 2;\n+\n+// GETEXTERNAL response offsets (RFC6886 3.2), relative to start of packet.\n+//!  Returned external address\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_IP_OFS = 8;\n+\n+// MAP request offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port to be mapped.\n+constexpr size_t NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS = 4;\n+//!  Suggested external port for mapping.\n+constexpr size_t NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS = 6;\n+//!  Requested port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_REQUEST_LIFETIME_OFS = 8;\n+\n+// MAP response offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port for mapping (will match internal port of request).\n+constexpr size_t NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS = 8;\n+//!  External port for mapping.\n+constexpr size_t NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS = 10;\n+//!  Created port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_RESPONSE_LIFETIME_OFS = 12;\n+\n+// Relevant NETPMP result codes (RFC6886 3.5).\n+//! Result code representing success status.\n+constexpr uint8_t NATPMP_RESULT_SUCCESS = 0;\n+//! Result code representing unsupported version.\n+constexpr uint8_t NATPMP_RESULT_UNSUPP_VERSION = 1;\n+//! Result code representing lack of resources.\n+constexpr uint8_t NATPMP_RESULT_NO_RESOURCES = 4;\n+\n+//! Mapping of NATPMP result code to string (RFC6886 3.5). Result codes <=2 match PCP.\n+const std::map<uint8_t, std::string> NATPMP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"NETWORK_FAILURE\"},\n+    {4,  \"NO_RESOURCES\"},\n+    {5,  \"UNSUPP_OPCODE\"},\n+};\n+\n+// PCP (v2) protocol constants.\n+//! Maximum packet size in bytes (RFC6887 section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (RFC6887 section 19.1). Shared with NAT-PMP.\n+constexpr uint16_t PCP_SERVER_PORT = NATPMP_SERVER_PORT;\n+//! Version byte. 0 is NAT-PMP (RFC6886), 1 is forbidden, 2 for PCP (RFC6887).\n+constexpr uint8_t PCP_VERSION = 2;\n+//! PCP Request Header. See RFC6887 section 7.1. Shared with NAT-PMP.\n+constexpr uint8_t PCP_REQUEST = NATPMP_REQUEST; // R = 0\n+//! PCP Response Header. See RFC6887 section 7.2. Shared with NAT-PMP.\n+constexpr uint8_t PCP_RESPONSE = NATPMP_RESPONSE; // R = 1\n+//! Map opcode. See RFC6887 section 19.2\n+constexpr uint8_t PCP_OP_MAP = 0x01;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Request and response header size in bytes (RFC6887 section 7.1).\n+constexpr size_t PCP_HDR_SIZE = 24;\n+//! Map request and response size in bytes (RFC6887 section 11.1).\n+constexpr size_t PCP_MAP_SIZE = 36;\n+\n+// Header offsets shared between request and responses (RFC6887 7.1, 7.2), relative to start of packet.\n+//!  Version field (1 byte).\n+constexpr size_t PCP_HDR_VERSION_OFS = NATPMP_HDR_VERSION_OFS;\n+//!  Opcode field (1 byte).\n+constexpr size_t PCP_HDR_OP_OFS = NATPMP_HDR_OP_OFS;\n+//!  Requested lifetime (request), granted lifetime (response) (2 bytes).\n+constexpr size_t PCP_HDR_LIFETIME_OFS = 4;\n+\n+// Request header offsets (RFC6887 7.1), relative to start of packet.\n+//!  PCP client's IP address (16 bytes).\n+constexpr size_t PCP_REQUEST_HDR_IP_OFS = 8;\n+\n+// Response header offsets (RFC6887 7.2), relative to start of packet.\n+//!  Result code (1 byte).\n+constexpr size_t PCP_RESPONSE_HDR_RESULT_OFS = 3;\n+\n+// MAP request/response offsets (RFC6887 11.1), relative to start of opcode-specific data.\n+//!  Mapping nonce (12 bytes).\n+constexpr size_t PCP_MAP_NONCE_OFS = 0;\n+//!  Protocol (1 byte).\n+constexpr size_t PCP_MAP_PROTOCOL_OFS = 12;\n+//!  Internal port for mapping (2 bytes).\n+constexpr size_t PCP_MAP_INTERNAL_PORT_OFS = 16;\n+//!  Suggested external port (request), assigned external port (response) (2 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_PORT_OFS = 18;\n+//!  Suggested external IP (request), assigned external IP (response) (16 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_IP_OFS = 20;\n+\n+//! Result code representing success (RFC6887 7.4), shared with NAT-PMP.\n+constexpr uint8_t PCP_RESULT_SUCCESS = NATPMP_RESULT_SUCCESS;\n+//! Result code representing lack of resources (RFC6887 7.4).\n+constexpr uint8_t PCP_RESULT_NO_RESOURCES = 8;\n+\n+//! Mapping of PCP result code to string (RFC6887 7.4). Result codes <=2 match NAT-PMP.\n+const std::map<uint8_t, std::string> PCP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"MALFORMED_REQUEST\"},\n+    {4,  \"UNSUPP_OPCODE\"},\n+    {5,  \"UNSUPP_OPTION\"},\n+    {6,  \"MALFORMED_OPTION\"},\n+    {7,  \"NETWORK_FAILURE\"},\n+    {8,  \"NO_RESOURCES\"},\n+    {9,  \"UNSUPP_PROTOCOL\"},\n+    {10, \"USER_EX_QUOTA\"},\n+    {11, \"CANNOT_PROVIDE_EXTERNAL\"},\n+    {12, \"ADDRESS_MISMATCH\"},\n+    {13, \"EXCESSIVE_REMOTE_PEER\"},\n+};\n+\n+//! Return human-readable string from NATPMP result code.\n+std::string NATPMPResultString(uint8_t result_code)\n+{\n+    auto result_i = NATPMP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == NATPMP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Return human-readable string from PCP result code.\n+std::string PCPResultString(uint8_t result_code)\n+{\n+    auto result_i = PCP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == PCP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Wrap address in IPv6 according to RFC6887. wrapped_addr needs to be able to store 16 bytes.\n+[[nodiscard]] bool PCPWrapAddress(Span<uint8_t> wrapped_addr, const CNetAddr &addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (addr.IsIPv4()) {\n+        struct in_addr addr4;\n+        if (!addr.GetInAddr(&addr4)) return false;\n+        // Section 5: \"When the address field holds an IPv4 address, an IPv4-mapped IPv6 address [RFC4291] is used (::ffff:0:0/96).\"\n+        std::memcpy(wrapped_addr.data(), IPV4_IN_IPV6_PREFIX.data(), IPV4_IN_IPV6_PREFIX.size());\n+        std::memcpy(wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), &addr4, ADDR_IPV4_SIZE);\n+        return true;\n+    } else if (addr.IsIPv6()) {\n+        struct in6_addr addr6;\n+        if (!addr.GetIn6Addr(&addr6)) return false;\n+        std::memcpy(wrapped_addr.data(), &addr6, ADDR_IPV6_SIZE);\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+//! Unwrap PCP-encoded address according to RFC6887.\n+CNetAddr PCPUnwrapAddress(Span<const uint8_t> wrapped_addr)",
      "path": "src/util/pcp.cpp",
      "position": 203,
      "original_position": 203,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "cbb053c5f6fa63b08fe8fb200b143cca64fc0626",
      "in_reply_to_id": 1772139009,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Maybe the other way around, replace the `CNetAddr` implementation with what you wrote here? But that sounds like a followup.",
      "created_at": "2024-09-24T08:43:13Z",
      "updated_at": "2024-09-24T08:43:23Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1772921229",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1772921229"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 203,
      "original_line": 203,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1772922894",
      "pull_request_review_id": 2324550264,
      "id": 1772922894,
      "node_id": "PRRC_kwDOABII585prKgO",
      "diff_hunk": "@@ -0,0 +1,303 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <config/bitcoin-config.h> // IWYU pragma: keep\n+\n+#include <util/netif.h>\n+\n+#include <logging.h>\n+#include <netbase.h>\n+#include <util/check.h>\n+#include <util/sock.h>\n+#include <util/syserror.h>\n+\n+#if defined(__linux__)\n+#include <linux/rtnetlink.h>\n+#elif defined(__FreeBSD__)\n+#include <osreldate.h>\n+#if __FreeBSD_version >= 1400000\n+// Workaround https://github.com/freebsd/freebsd-src/pull/1070.\n+#define typeof __typeof\n+#include <netlink/netlink.h>\n+#include <netlink/netlink_route.h>\n+#endif\n+#elif defined(WIN32)\n+#include <iphlpapi.h>\n+#elif defined(__APPLE__)\n+#include <net/route.h>\n+#include <sys/sysctl.h>\n+#endif\n+\n+namespace {\n+\n+// Linux and FreeBSD 14.0+. For FreeBSD 13.2 the code can be compiled but\n+// running it requires loading a special kernel module, otherwise socket(AF_NETLINK,...)\n+// will fail, so we skip that.\n+#if defined(__linux__) || (defined(__FreeBSD__) && __FreeBSD_version >= 1400000)\n+\n+std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // Create a netlink socket.\n+    auto sock{CreateSock(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE)};\n+    if (!sock) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"socket(AF_NETLINK): %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Send request.\n+    struct {\n+        nlmsghdr hdr; ///< Request header.\n+        rtmsg data; ///< Request data, a \"route message\".\n+        nlattr dst_hdr; ///< One attribute, conveying the route destination address.\n+        char dst_data[16]; ///< Route destination address. To query the default route we use 0.0.0.0/0 or [::]/0. For IPv4 the first 4 bytes are used.\n+    } request{};\n+\n+    // Whether to use the first 4 or 16 bytes from request.dst_data.\n+    const size_t dst_data_len = family == AF_INET ? 4 : 16;\n+\n+    request.hdr.nlmsg_type = RTM_GETROUTE;\n+    request.hdr.nlmsg_flags = NLM_F_REQUEST;\n+#ifdef __linux__\n+    // Linux IPv4 / IPv6 - this must be present, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be absent, otherwise no gateway is found\n+    request.hdr.nlmsg_flags |= NLM_F_DUMP;\n+#endif\n+    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(rtmsg) + sizeof(nlattr) + dst_data_len);\n+    request.hdr.nlmsg_seq = 0; // Sequence number, used to match which reply is to which request. Irrelevant for us because we send just one request.\n+    request.data.rtm_family = family;\n+    request.data.rtm_dst_len = 0; // Prefix length.\n+#ifdef __FreeBSD__\n+    // Linux IPv4 / IPv6 this must be absent, otherwise no gateway is found\n+    // FreeBSD IPv4 - does not matter, the gateway is found with or without this\n+    // FreeBSD IPv6 - this must be present, otherwise no gateway is found\n+    request.data.rtm_flags = RTM_F_PREFIX;\n+#endif\n+    request.dst_hdr.nla_type = RTA_DST;\n+    request.dst_hdr.nla_len = sizeof(nlattr) + dst_data_len;\n+\n+    if (sock->Send(&request, request.hdr.nlmsg_len, 0) != static_cast<ssize_t>(request.hdr.nlmsg_len)) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"send() to netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    // Receive response.\n+    char response[4096];\n+    int64_t recv_result;\n+    do {\n+        recv_result = sock->Recv(response, sizeof(response), 0);\n+    } while (recv_result < 0 && (errno == EINTR || errno == EAGAIN));\n+    if (recv_result < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"recv() from netlink socket: %s\\n\", NetworkErrorString(errno));\n+        return std::nullopt;\n+    }\n+\n+    for (nlmsghdr* hdr = (nlmsghdr*)response; NLMSG_OK(hdr, recv_result); hdr = NLMSG_NEXT(hdr, recv_result)) {\n+        rtmsg* r = (rtmsg*)NLMSG_DATA(hdr);\n+        int remaining_len = RTM_PAYLOAD(hdr);\n+\n+        // Iterate over the attributes.\n+        rtattr *rta_gateway = nullptr;\n+        int scope_id = 0;\n+        for (rtattr* attr = RTM_RTA(r); RTA_OK(attr, remaining_len); attr = RTA_NEXT(attr, remaining_len)) {\n+            if (attr->rta_type == RTA_GATEWAY) {\n+                rta_gateway = attr;\n+            } else if (attr->rta_type == RTA_OIF && sizeof(int) == RTA_PAYLOAD(attr)) {\n+                std::memcpy(&scope_id, RTA_DATA(attr), sizeof(scope_id));\n+            }\n+        }\n+\n+        // Found gateway?\n+        if (rta_gateway != nullptr) {\n+            if (family == AF_INET && sizeof(in_addr) == RTA_PAYLOAD(rta_gateway)) {\n+                in_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw);\n+            } else if (family == AF_INET6 && sizeof(in6_addr) == RTA_PAYLOAD(rta_gateway)) {\n+                in6_addr gw;\n+                std::memcpy(&gw, RTA_DATA(rta_gateway), sizeof(gw));\n+                return CNetAddr(gw, scope_id);\n+            }\n+        }\n+    }\n+\n+    return std::nullopt;\n+}\n+\n+#elif defined(WIN32)\n+\n+std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    NET_LUID interface_luid = {};\n+    SOCKADDR_INET destination_address = {};\n+    MIB_IPFORWARD_ROW2 best_route = {};\n+    SOCKADDR_INET best_source_address = {};\n+    DWORD best_if_idx = 0;\n+    DWORD status = 0;\n+\n+    // Pass empty destination address of the requested type (:: or 0.0.0.0) to get interface of default route.\n+    destination_address.si_family = family;\n+    status = GetBestInterfaceEx((sockaddr*)&destination_address, &best_if_idx);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best interface for default route: %s\\n\", NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    // Get best route to default gateway.\n+    // Leave interface_luid at all-zeros to use interface index instead.\n+    status = GetBestRoute2(&interface_luid, best_if_idx, nullptr, &destination_address, 0, &best_route, &best_source_address);\n+    if (status != NO_ERROR) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get best route for default route for interface index %d: %s\\n\",\n+                best_if_idx, NetworkErrorString(status));\n+        return std::nullopt;\n+    }\n+\n+    Assume(best_route.NextHop.si_family == family);\n+    if (family == AF_INET) {\n+        return CNetAddr(best_route.NextHop.Ipv4.sin_addr);\n+    } else if(family == AF_INET6) {\n+        return CNetAddr(best_route.NextHop.Ipv6.sin6_addr, best_route.InterfaceIndex);\n+    }\n+    return std::nullopt;\n+}\n+\n+#elif defined(__APPLE__)\n+\n+#define ROUNDUP32(a) \\\n+    ((a) > 0 ? (1 + (((a) - 1) | (sizeof(uint32_t) - 1))) : sizeof(uint32_t))\n+\n+std::optional<CNetAddr> FromSockAddr(const struct sockaddr* addr)\n+{\n+    // Check valid length. Note that sa_len is not part of POSIX, and exists on MacOS and some BSDs only, so we can't\n+    // do this check in SetSockAddr.\n+    if (!(addr->sa_family == AF_INET && addr->sa_len == sizeof(struct sockaddr_in)) &&\n+        !(addr->sa_family == AF_INET6 && addr->sa_len == sizeof(struct sockaddr_in6))) {\n+        return std::nullopt;\n+    }\n+\n+    // Fill in a CService from the sockaddr, then drop the port part.\n+    CService service;\n+    if (service.SetSockAddr(addr)) {\n+        return (CNetAddr)service;\n+    }\n+    return std::nullopt;\n+}\n+\n+//! MacOS: Get default gateway from route table. See route(4) for the format.\n+std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t family)\n+{\n+    // net.route.0.inet[6].flags.gateway\n+    int mib[] = {CTL_NET, PF_ROUTE, 0, family, NET_RT_FLAGS, RTF_GATEWAY};\n+    // The size of the available data is determined by calling sysctl() with oldp=nullptr. See sysctl(3).\n+    size_t l = 0;\n+    if (sysctl(/*name=*/mib, /*namelen=*/sizeof(mib) / sizeof(int), /*oldp=*/nullptr, /*oldlenp=*/&l, /*newp=*/nullptr, /*newlen=*/0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl length of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    std::vector<std::byte> buf(l);\n+    if (sysctl(/*name=*/mib, /*namelen=*/sizeof(mib) / sizeof(int), /*oldp=*/buf.data(), /*oldlenp=*/&l, /*newp=*/nullptr, /*newlen=*/0) < 0) {\n+        LogPrintLevel(BCLog::NET, BCLog::Level::Error, \"Could not get sysctl data of routing table: %s\\n\", SysErrorString(errno));\n+        return std::nullopt;\n+    }\n+    // Iterate over messages (each message is a routing table entry).\n+    for (size_t msg_pos = 0; msg_pos < buf.size(); ) {\n+        if ((msg_pos + sizeof(rt_msghdr)) > buf.size()) return std::nullopt;\n+        const struct rt_msghdr* rt = (const struct rt_msghdr*)(buf.data() + msg_pos);\n+        const size_t next_msg_pos = msg_pos + rt->rtm_msglen;\n+        if (rt->rtm_msglen < sizeof(rt_msghdr) || next_msg_pos > buf.size()) return std::nullopt;\n+        // Iterate over addresses within message, get destination and gateway (if present).\n+        // Address data starts after header.\n+        size_t sa_pos = msg_pos + sizeof(struct rt_msghdr);\n+        std::optional<CNetAddr> dst, gateway;\n+        for (int i = 0; i < RTAX_MAX; i++) {\n+            if (rt->rtm_addrs & (1 << i)) {\n+                // 2 is just sa_len + sa_family, the theoretical minimum size of a socket address.\n+                if ((sa_pos + 2) > next_msg_pos) return std::nullopt;\n+                const struct sockaddr* sa = (const struct sockaddr*)(buf.data() + sa_pos);\n+                if ((sa_pos + sa->sa_len) > next_msg_pos) return std::nullopt;\n+                if (i == RTAX_DST) {\n+                    dst = FromSockAddr(sa);\n+                } else if (i == RTAX_GATEWAY) {\n+                    gateway = FromSockAddr(sa);\n+                }\n+                // Skip sockaddr entries for bit flags we're not interested in,\n+                // move cursor.\n+                sa_pos += ROUNDUP32(sa->sa_len);\n+            }\n+        }\n+        // Found default gateway?\n+        if (dst && gateway && dst->IsBindAny()) { // Route to 0.0.0.0 or :: ?\n+            return *gateway;\n+        }\n+        // Skip to next message.\n+        msg_pos = next_msg_pos;\n+    }\n+    return std::nullopt;\n+}\n+\n+#else\n+\n+// Dummy implementation.\n+std::optional<CNetAddr> QueryDefaultGatewayImpl(sa_family_t)\n+{\n+    return std::nullopt;\n+}\n+\n+#endif\n+\n+}\n+\n+std::optional<CNetAddr> QueryDefaultGateway(Network network)\n+{\n+    Assume(network == NET_IPV4 || network == NET_IPV6);\n+\n+    sa_family_t family;\n+    if (network == NET_IPV4) {\n+        family = AF_INET;\n+    } else if(network == NET_IPV6) {\n+        family = AF_INET6;\n+    } else {\n+        return std::nullopt;\n+    }\n+\n+    std::optional<CNetAddr> ret = QueryDefaultGatewayImpl(family);\n+\n+    // It's possible for the default gateway to be 0.0.0.0 or ::0 on at least Windows\n+    // for some routing strategies. If so, return as if no default gateway was found.\n+    if (ret && !ret->IsBindAny()) {\n+        return ret;\n+    } else {\n+        return std::nullopt;\n+    }\n+}\n+\n+std::vector<CNetAddr> GetLocalAddresses()\n+{\n+    std::vector<CNetAddr> addresses;\n+#ifdef WIN32\n+    char pszHostName[256] = \"\";\n+    if (gethostname(pszHostName, sizeof(pszHostName)) != SOCKET_ERROR) {\n+        addresses = LookupHost(pszHostName, 0, true);",
      "path": "src/util/netif.cpp",
      "position": 281,
      "original_position": 281,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "e02030432b77abbf27bb4f67d879d3ad6d6366e6",
      "in_reply_to_id": 1772017020,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Agree that fixing satoshi-isms can be done in a followup.",
      "created_at": "2024-09-24T08:44:15Z",
      "updated_at": "2024-09-24T08:44:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1772922894",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1772922894"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": 279,
      "original_start_line": 279,
      "start_side": "RIGHT",
      "line": 281,
      "original_line": 281,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1773088147",
      "pull_request_review_id": 2324823547,
      "id": 1773088147,
      "node_id": "PRRC_kwDOABII585pry2T",
      "diff_hunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/pcp.h>\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <span.h>\n+#include <util/check.h>\n+#include <util/netif.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+namespace {\n+\n+// RFC6886 NAT-PMP and RFC6887 Port Control Protocol (PCP) implementation.\n+// NAT-PMP and PCP use network byte order (big-endian).\n+\n+// NAT-PMP (v0) protocol constants.\n+//! NAT-PMP uses a fixed server port number (RFC6887 section 1.1).\n+constexpr uint16_t NATPMP_SERVER_PORT = 5351;\n+//! Version byte for NATPMP (RFC6886 1.1)\n+constexpr uint8_t NATPMP_VERSION = 0;\n+//! Request opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_REQUEST = 0x00;\n+//! Response opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_RESPONSE = 0x80;\n+//! Get external address (RFC6886 3.2)\n+constexpr uint8_t NATPMP_OP_GETEXTERNAL = 0x00;\n+//! Map TCP port (RFC6886 3.3)\n+constexpr uint8_t NATPMP_OP_MAP_TCP = 0x02;\n+//! Shared request header size in bytes.\n+constexpr size_t NATPMP_REQUEST_HDR_SIZE = 2;\n+//! Shared response header (minimum) size in bytes.\n+constexpr size_t NATPMP_RESPONSE_HDR_SIZE = 8;\n+//! GETEXTERNAL request size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 0;\n+//! GETEXTERNAL response size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 4;\n+//! MAP request size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 10;\n+//! MAP response size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 8;\n+\n+// Shared header offsets (RFC6886 3.2, 3.3), relative to start of packet.\n+//!  Offset of version field in packets.\n+constexpr size_t NATPMP_HDR_VERSION_OFS = 0;\n+//!  Offset of opcode field in packets\n+constexpr size_t NATPMP_HDR_OP_OFS = 1;\n+//!  Offset of result code in packets. Result codes are 16 bit in NAT-PMP instead of 8 bit in PCP.\n+constexpr size_t NATPMP_RESPONSE_HDR_RESULT_OFS = 2;\n+\n+// GETEXTERNAL response offsets (RFC6886 3.2), relative to start of packet.\n+//!  Returned external address\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_IP_OFS = 8;\n+\n+// MAP request offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port to be mapped.\n+constexpr size_t NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS = 4;\n+//!  Suggested external port for mapping.\n+constexpr size_t NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS = 6;\n+//!  Requested port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_REQUEST_LIFETIME_OFS = 8;\n+\n+// MAP response offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port for mapping (will match internal port of request).\n+constexpr size_t NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS = 8;\n+//!  External port for mapping.\n+constexpr size_t NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS = 10;\n+//!  Created port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_RESPONSE_LIFETIME_OFS = 12;\n+\n+// Relevant NETPMP result codes (RFC6886 3.5).\n+//! Result code representing success status.\n+constexpr uint8_t NATPMP_RESULT_SUCCESS = 0;\n+//! Result code representing unsupported version.\n+constexpr uint8_t NATPMP_RESULT_UNSUPP_VERSION = 1;\n+//! Result code representing lack of resources.\n+constexpr uint8_t NATPMP_RESULT_NO_RESOURCES = 4;\n+\n+//! Mapping of NATPMP result code to string (RFC6886 3.5). Result codes <=2 match PCP.\n+const std::map<uint8_t, std::string> NATPMP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"NETWORK_FAILURE\"},\n+    {4,  \"NO_RESOURCES\"},\n+    {5,  \"UNSUPP_OPCODE\"},\n+};\n+\n+// PCP (v2) protocol constants.\n+//! Maximum packet size in bytes (RFC6887 section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (RFC6887 section 19.1). Shared with NAT-PMP.\n+constexpr uint16_t PCP_SERVER_PORT = NATPMP_SERVER_PORT;\n+//! Version byte. 0 is NAT-PMP (RFC6886), 1 is forbidden, 2 for PCP (RFC6887).\n+constexpr uint8_t PCP_VERSION = 2;\n+//! PCP Request Header. See RFC6887 section 7.1. Shared with NAT-PMP.\n+constexpr uint8_t PCP_REQUEST = NATPMP_REQUEST; // R = 0\n+//! PCP Response Header. See RFC6887 section 7.2. Shared with NAT-PMP.\n+constexpr uint8_t PCP_RESPONSE = NATPMP_RESPONSE; // R = 1\n+//! Map opcode. See RFC6887 section 19.2\n+constexpr uint8_t PCP_OP_MAP = 0x01;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Request and response header size in bytes (RFC6887 section 7.1).\n+constexpr size_t PCP_HDR_SIZE = 24;\n+//! Map request and response size in bytes (RFC6887 section 11.1).\n+constexpr size_t PCP_MAP_SIZE = 36;\n+\n+// Header offsets shared between request and responses (RFC6887 7.1, 7.2), relative to start of packet.\n+//!  Version field (1 byte).\n+constexpr size_t PCP_HDR_VERSION_OFS = NATPMP_HDR_VERSION_OFS;\n+//!  Opcode field (1 byte).\n+constexpr size_t PCP_HDR_OP_OFS = NATPMP_HDR_OP_OFS;\n+//!  Requested lifetime (request), granted lifetime (response) (2 bytes).\n+constexpr size_t PCP_HDR_LIFETIME_OFS = 4;\n+\n+// Request header offsets (RFC6887 7.1), relative to start of packet.\n+//!  PCP client's IP address (16 bytes).\n+constexpr size_t PCP_REQUEST_HDR_IP_OFS = 8;\n+\n+// Response header offsets (RFC6887 7.2), relative to start of packet.\n+//!  Result code (1 byte).\n+constexpr size_t PCP_RESPONSE_HDR_RESULT_OFS = 3;\n+\n+// MAP request/response offsets (RFC6887 11.1), relative to start of opcode-specific data.\n+//!  Mapping nonce (12 bytes).\n+constexpr size_t PCP_MAP_NONCE_OFS = 0;\n+//!  Protocol (1 byte).\n+constexpr size_t PCP_MAP_PROTOCOL_OFS = 12;\n+//!  Internal port for mapping (2 bytes).\n+constexpr size_t PCP_MAP_INTERNAL_PORT_OFS = 16;\n+//!  Suggested external port (request), assigned external port (response) (2 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_PORT_OFS = 18;\n+//!  Suggested external IP (request), assigned external IP (response) (16 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_IP_OFS = 20;\n+\n+//! Result code representing success (RFC6887 7.4), shared with NAT-PMP.\n+constexpr uint8_t PCP_RESULT_SUCCESS = NATPMP_RESULT_SUCCESS;\n+//! Result code representing lack of resources (RFC6887 7.4).\n+constexpr uint8_t PCP_RESULT_NO_RESOURCES = 8;\n+\n+//! Mapping of PCP result code to string (RFC6887 7.4). Result codes <=2 match NAT-PMP.\n+const std::map<uint8_t, std::string> PCP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"MALFORMED_REQUEST\"},\n+    {4,  \"UNSUPP_OPCODE\"},\n+    {5,  \"UNSUPP_OPTION\"},\n+    {6,  \"MALFORMED_OPTION\"},\n+    {7,  \"NETWORK_FAILURE\"},\n+    {8,  \"NO_RESOURCES\"},\n+    {9,  \"UNSUPP_PROTOCOL\"},\n+    {10, \"USER_EX_QUOTA\"},\n+    {11, \"CANNOT_PROVIDE_EXTERNAL\"},\n+    {12, \"ADDRESS_MISMATCH\"},\n+    {13, \"EXCESSIVE_REMOTE_PEER\"},\n+};\n+\n+//! Return human-readable string from NATPMP result code.\n+std::string NATPMPResultString(uint8_t result_code)\n+{\n+    auto result_i = NATPMP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == NATPMP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Return human-readable string from PCP result code.\n+std::string PCPResultString(uint8_t result_code)\n+{\n+    auto result_i = PCP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == PCP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Wrap address in IPv6 according to RFC6887. wrapped_addr needs to be able to store 16 bytes.\n+[[nodiscard]] bool PCPWrapAddress(Span<uint8_t> wrapped_addr, const CNetAddr &addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (addr.IsIPv4()) {\n+        struct in_addr addr4;\n+        if (!addr.GetInAddr(&addr4)) return false;\n+        // Section 5: \"When the address field holds an IPv4 address, an IPv4-mapped IPv6 address [RFC4291] is used (::ffff:0:0/96).\"\n+        std::memcpy(wrapped_addr.data(), IPV4_IN_IPV6_PREFIX.data(), IPV4_IN_IPV6_PREFIX.size());\n+        std::memcpy(wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), &addr4, ADDR_IPV4_SIZE);\n+        return true;\n+    } else if (addr.IsIPv6()) {\n+        struct in6_addr addr6;\n+        if (!addr.GetIn6Addr(&addr6)) return false;\n+        std::memcpy(wrapped_addr.data(), &addr6, ADDR_IPV6_SIZE);\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+//! Unwrap PCP-encoded address according to RFC6887.\n+CNetAddr PCPUnwrapAddress(Span<const uint8_t> wrapped_addr)",
      "path": "src/util/pcp.cpp",
      "position": 203,
      "original_position": 203,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "cbb053c5f6fa63b08fe8fb200b143cca64fc0626",
      "in_reply_to_id": 1772139009,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Wouldn't that have the same conceptual issue, but the other way around? eg locking the bitcoin implementation to RFC6887 specifics. \r\n\r\nIt didn't feel right, it's different specifications coming from a different place that somehow in a parallel evolution ended up similarly.\r\n\r\nNow looking at `SetLegacyIPv6` i see the differences: \r\n- there's the TORV2 case. It just marks the addess as invalid, which it would be anyway, so *that* wouldn't be problematic here.\r\n- there's also the `NET_INTERNAL` case, which makes no sense in this context.\r\n\r\ni think it's the second one that made me doubt the most-i have no idea what else we'd want to encode into addresses IPv6 in the future, but it shouldn't interfere with the PCP implementation. Similarly, special cases for PCP handling that may be necessary for whatever reason in the future shouldn't affect bitcoin protocol handling.",
      "created_at": "2024-09-24T10:36:03Z",
      "updated_at": "2024-09-24T10:44:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1773088147",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1773088147"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 203,
      "original_line": 203,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1773194231",
      "pull_request_review_id": 2325000339,
      "id": 1773194231,
      "node_id": "PRRC_kwDOABII585psMv3",
      "diff_hunk": "@@ -0,0 +1,524 @@\n+// Copyright (c) 2024 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/pcp.h>\n+\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <span.h>\n+#include <util/check.h>\n+#include <util/netif.h>\n+#include <util/readwritefile.h>\n+#include <util/sock.h>\n+#include <util/strencodings.h>\n+\n+namespace {\n+\n+// RFC6886 NAT-PMP and RFC6887 Port Control Protocol (PCP) implementation.\n+// NAT-PMP and PCP use network byte order (big-endian).\n+\n+// NAT-PMP (v0) protocol constants.\n+//! NAT-PMP uses a fixed server port number (RFC6887 section 1.1).\n+constexpr uint16_t NATPMP_SERVER_PORT = 5351;\n+//! Version byte for NATPMP (RFC6886 1.1)\n+constexpr uint8_t NATPMP_VERSION = 0;\n+//! Request opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_REQUEST = 0x00;\n+//! Response opcode base (RFC6886 3).\n+constexpr uint8_t NATPMP_RESPONSE = 0x80;\n+//! Get external address (RFC6886 3.2)\n+constexpr uint8_t NATPMP_OP_GETEXTERNAL = 0x00;\n+//! Map TCP port (RFC6886 3.3)\n+constexpr uint8_t NATPMP_OP_MAP_TCP = 0x02;\n+//! Shared request header size in bytes.\n+constexpr size_t NATPMP_REQUEST_HDR_SIZE = 2;\n+//! Shared response header (minimum) size in bytes.\n+constexpr size_t NATPMP_RESPONSE_HDR_SIZE = 8;\n+//! GETEXTERNAL request size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 0;\n+//! GETEXTERNAL response size in bytes, including header (RFC6886 3.2).\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 4;\n+//! MAP request size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_REQUEST_SIZE = NATPMP_REQUEST_HDR_SIZE + 10;\n+//! MAP response size in bytes, including header (RFC6886 3.3).\n+constexpr size_t NATPMP_MAP_RESPONSE_SIZE = NATPMP_RESPONSE_HDR_SIZE + 8;\n+\n+// Shared header offsets (RFC6886 3.2, 3.3), relative to start of packet.\n+//!  Offset of version field in packets.\n+constexpr size_t NATPMP_HDR_VERSION_OFS = 0;\n+//!  Offset of opcode field in packets\n+constexpr size_t NATPMP_HDR_OP_OFS = 1;\n+//!  Offset of result code in packets. Result codes are 16 bit in NAT-PMP instead of 8 bit in PCP.\n+constexpr size_t NATPMP_RESPONSE_HDR_RESULT_OFS = 2;\n+\n+// GETEXTERNAL response offsets (RFC6886 3.2), relative to start of packet.\n+//!  Returned external address\n+constexpr size_t NATPMP_GETEXTERNAL_RESPONSE_IP_OFS = 8;\n+\n+// MAP request offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port to be mapped.\n+constexpr size_t NATPMP_MAP_REQUEST_INTERNAL_PORT_OFS = 4;\n+//!  Suggested external port for mapping.\n+constexpr size_t NATPMP_MAP_REQUEST_EXTERNAL_PORT_OFS = 6;\n+//!  Requested port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_REQUEST_LIFETIME_OFS = 8;\n+\n+// MAP response offsets (RFC6886 3.3), relative to start of packet.\n+//!  Internal port for mapping (will match internal port of request).\n+constexpr size_t NATPMP_MAP_RESPONSE_INTERNAL_PORT_OFS = 8;\n+//!  External port for mapping.\n+constexpr size_t NATPMP_MAP_RESPONSE_EXTERNAL_PORT_OFS = 10;\n+//!  Created port mapping lifetime in seconds.\n+constexpr size_t NATPMP_MAP_RESPONSE_LIFETIME_OFS = 12;\n+\n+// Relevant NETPMP result codes (RFC6886 3.5).\n+//! Result code representing success status.\n+constexpr uint8_t NATPMP_RESULT_SUCCESS = 0;\n+//! Result code representing unsupported version.\n+constexpr uint8_t NATPMP_RESULT_UNSUPP_VERSION = 1;\n+//! Result code representing lack of resources.\n+constexpr uint8_t NATPMP_RESULT_NO_RESOURCES = 4;\n+\n+//! Mapping of NATPMP result code to string (RFC6886 3.5). Result codes <=2 match PCP.\n+const std::map<uint8_t, std::string> NATPMP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"NETWORK_FAILURE\"},\n+    {4,  \"NO_RESOURCES\"},\n+    {5,  \"UNSUPP_OPCODE\"},\n+};\n+\n+// PCP (v2) protocol constants.\n+//! Maximum packet size in bytes (RFC6887 section 7).\n+constexpr size_t PCP_MAX_SIZE = 1100;\n+//! PCP uses a fixed server port number (RFC6887 section 19.1). Shared with NAT-PMP.\n+constexpr uint16_t PCP_SERVER_PORT = NATPMP_SERVER_PORT;\n+//! Version byte. 0 is NAT-PMP (RFC6886), 1 is forbidden, 2 for PCP (RFC6887).\n+constexpr uint8_t PCP_VERSION = 2;\n+//! PCP Request Header. See RFC6887 section 7.1. Shared with NAT-PMP.\n+constexpr uint8_t PCP_REQUEST = NATPMP_REQUEST; // R = 0\n+//! PCP Response Header. See RFC6887 section 7.2. Shared with NAT-PMP.\n+constexpr uint8_t PCP_RESPONSE = NATPMP_RESPONSE; // R = 1\n+//! Map opcode. See RFC6887 section 19.2\n+constexpr uint8_t PCP_OP_MAP = 0x01;\n+//! TCP protocol number (IANA).\n+constexpr uint16_t PCP_PROTOCOL_TCP = 6;\n+//! Request and response header size in bytes (RFC6887 section 7.1).\n+constexpr size_t PCP_HDR_SIZE = 24;\n+//! Map request and response size in bytes (RFC6887 section 11.1).\n+constexpr size_t PCP_MAP_SIZE = 36;\n+\n+// Header offsets shared between request and responses (RFC6887 7.1, 7.2), relative to start of packet.\n+//!  Version field (1 byte).\n+constexpr size_t PCP_HDR_VERSION_OFS = NATPMP_HDR_VERSION_OFS;\n+//!  Opcode field (1 byte).\n+constexpr size_t PCP_HDR_OP_OFS = NATPMP_HDR_OP_OFS;\n+//!  Requested lifetime (request), granted lifetime (response) (2 bytes).\n+constexpr size_t PCP_HDR_LIFETIME_OFS = 4;\n+\n+// Request header offsets (RFC6887 7.1), relative to start of packet.\n+//!  PCP client's IP address (16 bytes).\n+constexpr size_t PCP_REQUEST_HDR_IP_OFS = 8;\n+\n+// Response header offsets (RFC6887 7.2), relative to start of packet.\n+//!  Result code (1 byte).\n+constexpr size_t PCP_RESPONSE_HDR_RESULT_OFS = 3;\n+\n+// MAP request/response offsets (RFC6887 11.1), relative to start of opcode-specific data.\n+//!  Mapping nonce (12 bytes).\n+constexpr size_t PCP_MAP_NONCE_OFS = 0;\n+//!  Protocol (1 byte).\n+constexpr size_t PCP_MAP_PROTOCOL_OFS = 12;\n+//!  Internal port for mapping (2 bytes).\n+constexpr size_t PCP_MAP_INTERNAL_PORT_OFS = 16;\n+//!  Suggested external port (request), assigned external port (response) (2 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_PORT_OFS = 18;\n+//!  Suggested external IP (request), assigned external IP (response) (16 bytes).\n+constexpr size_t PCP_MAP_EXTERNAL_IP_OFS = 20;\n+\n+//! Result code representing success (RFC6887 7.4), shared with NAT-PMP.\n+constexpr uint8_t PCP_RESULT_SUCCESS = NATPMP_RESULT_SUCCESS;\n+//! Result code representing lack of resources (RFC6887 7.4).\n+constexpr uint8_t PCP_RESULT_NO_RESOURCES = 8;\n+\n+//! Mapping of PCP result code to string (RFC6887 7.4). Result codes <=2 match NAT-PMP.\n+const std::map<uint8_t, std::string> PCP_RESULT_STR{\n+    {0,  \"SUCCESS\"},\n+    {1,  \"UNSUPP_VERSION\"},\n+    {2,  \"NOT_AUTHORIZED\"},\n+    {3,  \"MALFORMED_REQUEST\"},\n+    {4,  \"UNSUPP_OPCODE\"},\n+    {5,  \"UNSUPP_OPTION\"},\n+    {6,  \"MALFORMED_OPTION\"},\n+    {7,  \"NETWORK_FAILURE\"},\n+    {8,  \"NO_RESOURCES\"},\n+    {9,  \"UNSUPP_PROTOCOL\"},\n+    {10, \"USER_EX_QUOTA\"},\n+    {11, \"CANNOT_PROVIDE_EXTERNAL\"},\n+    {12, \"ADDRESS_MISMATCH\"},\n+    {13, \"EXCESSIVE_REMOTE_PEER\"},\n+};\n+\n+//! Return human-readable string from NATPMP result code.\n+std::string NATPMPResultString(uint8_t result_code)\n+{\n+    auto result_i = NATPMP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == NATPMP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Return human-readable string from PCP result code.\n+std::string PCPResultString(uint8_t result_code)\n+{\n+    auto result_i = PCP_RESULT_STR.find(result_code);\n+    return strprintf(\"%s (code %d)\", result_i == PCP_RESULT_STR.end() ? \"(unknown)\" : result_i->second,  result_code);\n+}\n+\n+//! Wrap address in IPv6 according to RFC6887. wrapped_addr needs to be able to store 16 bytes.\n+[[nodiscard]] bool PCPWrapAddress(Span<uint8_t> wrapped_addr, const CNetAddr &addr)\n+{\n+    Assume(wrapped_addr.size() == ADDR_IPV6_SIZE);\n+    if (addr.IsIPv4()) {\n+        struct in_addr addr4;\n+        if (!addr.GetInAddr(&addr4)) return false;\n+        // Section 5: \"When the address field holds an IPv4 address, an IPv4-mapped IPv6 address [RFC4291] is used (::ffff:0:0/96).\"\n+        std::memcpy(wrapped_addr.data(), IPV4_IN_IPV6_PREFIX.data(), IPV4_IN_IPV6_PREFIX.size());\n+        std::memcpy(wrapped_addr.data() + IPV4_IN_IPV6_PREFIX.size(), &addr4, ADDR_IPV4_SIZE);\n+        return true;\n+    } else if (addr.IsIPv6()) {\n+        struct in6_addr addr6;\n+        if (!addr.GetIn6Addr(&addr6)) return false;\n+        std::memcpy(wrapped_addr.data(), &addr6, ADDR_IPV6_SIZE);\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+//! Unwrap PCP-encoded address according to RFC6887.\n+CNetAddr PCPUnwrapAddress(Span<const uint8_t> wrapped_addr)",
      "path": "src/util/pcp.cpp",
      "position": 203,
      "original_position": 203,
      "commit_id": "5c7cacf649a6b474b876a7d219c7dc683a25e33d",
      "original_commit_id": "cbb053c5f6fa63b08fe8fb200b143cca64fc0626",
      "in_reply_to_id": 1772139009,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I think it makes sense to keep the two separate. Just because two specifications (\"Bitcoin ADDR message encoding\" and \"RFC6887\") happen to be largely the same doesn't mean they should be treated as a single thing, and in that case it seems cleaner to keep the implementations separate too.",
      "created_at": "2024-09-24T11:54:55Z",
      "updated_at": "2024-09-24T11:54:55Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/30043#discussion_r1773194231",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1773194231"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/30043"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 203,
      "original_line": 203,
      "side": "RIGHT"
    }
  ]
}