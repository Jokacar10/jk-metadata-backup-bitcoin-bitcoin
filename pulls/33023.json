{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33023",
    "id": 2680024170,
    "node_id": "PR_kwDOABII586fvexq",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/33023",
    "diff_url": "https://github.com/bitcoin/bitcoin/pull/33023.diff",
    "patch_url": "https://github.com/bitcoin/bitcoin/pull/33023.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33023",
    "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33023/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33023/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33023/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/f9c6331cb26f3bafc3dba7f5a72622a9ff4f190d",
    "number": 33023,
    "state": "open",
    "locked": false,
    "maintainer_can_modify": true,
    "title": "test: Add functional tests for blockreconstructionextratxn and extra pool (compactblocks)",
    "user": {
      "login": "bigshiny90",
      "id": 23282055,
      "node_id": "MDQ6VXNlcjIzMjgyMDU1",
      "avatar_url": "https://avatars.githubusercontent.com/u/23282055?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bigshiny90",
      "html_url": "https://github.com/bigshiny90",
      "followers_url": "https://api.github.com/users/bigshiny90/followers",
      "following_url": "https://api.github.com/users/bigshiny90/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/bigshiny90/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/bigshiny90/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/bigshiny90/subscriptions",
      "organizations_url": "https://api.github.com/users/bigshiny90/orgs",
      "repos_url": "https://api.github.com/users/bigshiny90/repos",
      "events_url": "https://api.github.com/users/bigshiny90/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/bigshiny90/received_events",
      "type": "User",
      "site_admin": false,
      "patch_url": null
    },
    "body": "This tests the -blockreconstructionextratxn parameter and extra pool memory (ring buffer) behavior used specifically for compact block reconstruction. The \"extra transaction pool\" stores transactions that were rejected from the mempool for policy reasons (dust, low fees, non-standard scripts), txs replaced via rbf, etcâ€¦\r\n\r\nThere is no test coverage for this. (no unit tests either as the code being tested - in PeerManagerImpl - isn't publicly accessible in the net_processing.h file)\r\n\r\nThe code being tested is in src/net_processing.cpp - look for vExtraTxnForCompact, AddToCompactExtraTransactions and -blockreconstructionextratxn start arg.\r\n\r\nThis tests\r\n\r\nPolicy-rejected transactions are stored in the extra pool: Transactions rejected for being dust, having low fees, or using non-standard scripts are kept in the extra pool\r\nPool capacity limits work correctly: Tests various pool sizes (0, 1, 50, 400, 100000). Default is 100.\r\nEviction behavior: When the extra pool is full, the oldest transactions are evicted (FIFO)\r\nWraparound behavior: The extra pool correctly wraps around when adding new transactions\r\nCompact block reconstruction: These extra transactions are actually used during block reconstruction\r\n\r\nUses policy rejected transactions to populate the extra pool for tests.",
    "labels": [
      {
        "id": 62963516,
        "node_id": "MDU6TGFiZWw2Mjk2MzUxNg==",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Tests",
        "name": "Tests",
        "color": "d4c5f9",
        "default": false
      },
      {
        "id": 5334691551,
        "node_id": "LA_kwDOABII588AAAABPfju3w",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/CI%20failed",
        "name": "CI failed",
        "description": "",
        "color": "cccccc",
        "default": false
      }
    ],
    "created_at": "2025-07-20T16:40:28Z",
    "updated_at": "2025-08-29T07:51:11Z",
    "mergeable": true,
    "mergeable_state": "blocked",
    "merged": false,
    "merge_commit_sha": "aa856014435e85fa08e4a3ae0c428e0dcd6047b6",
    "assignees": [],
    "requested_reviewers": [
      {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      {
        "login": "kevkevinpal",
        "id": 15950706,
        "node_id": "MDQ6VXNlcjE1OTUwNzA2",
        "avatar_url": "https://avatars.githubusercontent.com/u/15950706?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kevkevinpal",
        "html_url": "https://github.com/kevkevinpal",
        "followers_url": "https://api.github.com/users/kevkevinpal/followers",
        "following_url": "https://api.github.com/users/kevkevinpal/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kevkevinpal/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kevkevinpal/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kevkevinpal/subscriptions",
        "organizations_url": "https://api.github.com/users/kevkevinpal/orgs",
        "repos_url": "https://api.github.com/users/kevkevinpal/repos",
        "events_url": "https://api.github.com/users/kevkevinpal/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kevkevinpal/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    ],
    "requested_teams": [],
    "rebaseable": true,
    "head": {
      "label": "bigshiny90:compactblocks-extratxs-tests-core",
      "ref": "compactblocks-extratxs-tests-core",
      "sha": "f9c6331cb26f3bafc3dba7f5a72622a9ff4f190d",
      "user": {
        "login": "bigshiny90",
        "id": 23282055,
        "node_id": "MDQ6VXNlcjIzMjgyMDU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23282055?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigshiny90",
        "html_url": "https://github.com/bigshiny90",
        "followers_url": "https://api.github.com/users/bigshiny90/followers",
        "following_url": "https://api.github.com/users/bigshiny90/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigshiny90/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigshiny90/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigshiny90/subscriptions",
        "organizations_url": "https://api.github.com/users/bigshiny90/orgs",
        "repos_url": "https://api.github.com/users/bigshiny90/repos",
        "events_url": "https://api.github.com/users/bigshiny90/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigshiny90/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "repo": {
        "id": 997628551,
        "node_id": "R_kgDOO3aahw",
        "name": "bitcoin",
        "full_name": "bigshiny90/bitcoin",
        "owner": {
          "login": "bigshiny90",
          "id": 23282055,
          "node_id": "MDQ6VXNlcjIzMjgyMDU1",
          "avatar_url": "https://avatars.githubusercontent.com/u/23282055?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bigshiny90",
          "html_url": "https://github.com/bigshiny90",
          "followers_url": "https://api.github.com/users/bigshiny90/followers",
          "following_url": "https://api.github.com/users/bigshiny90/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bigshiny90/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bigshiny90/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bigshiny90/subscriptions",
          "organizations_url": "https://api.github.com/users/bigshiny90/orgs",
          "repos_url": "https://api.github.com/users/bigshiny90/repos",
          "events_url": "https://api.github.com/users/bigshiny90/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bigshiny90/received_events",
          "type": "User",
          "site_admin": false,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/bigshiny90/bitcoin",
        "description": "Bitcoin Knots enhanced Bitcoin node/wallet software",
        "fork": true,
        "url": "https://api.github.com/repos/bigshiny90/bitcoin",
        "archive_url": "https://api.github.com/repos/bigshiny90/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bigshiny90/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bigshiny90/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bigshiny90/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bigshiny90/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bigshiny90/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bigshiny90/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bigshiny90/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bigshiny90/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bigshiny90/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/bigshiny90/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/bigshiny90/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/bigshiny90/bitcoin/events",
        "forks_url": "https://api.github.com/repos/bigshiny90/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/bigshiny90/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bigshiny90/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bigshiny90/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bigshiny90/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/bigshiny90/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bigshiny90/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bigshiny90/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bigshiny90/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bigshiny90/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bigshiny90/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/bigshiny90/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/bigshiny90/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bigshiny90/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bigshiny90/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bigshiny90/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:bigshiny90/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/bigshiny90/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/bigshiny90/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bigshiny90/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/bigshiny90/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/bigshiny90/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/bigshiny90/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/bigshiny90/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bigshiny90/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/bigshiny90/bitcoin/hooks",
        "svn_url": "https://github.com/bigshiny90/bitcoin",
        "homepage": "",
        "forks_count": 0,
        "stargazers_count": 0,
        "watchers_count": 0,
        "size": 315392,
        "default_branch": "28.x-knots",
        "open_issues_count": 0,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2025-08-28T01:25:09Z",
        "created_at": "2025-06-06T21:23:28Z",
        "updated_at": "2025-07-19T16:28:24Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "6ca6f3b37b992591726bd13b494369bee3bd6468",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false,
        "patch_url": null
      },
      "repo": {
        "id": 1181927,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTgxOTI3",
        "name": "bitcoin",
        "full_name": "bitcoin/bitcoin",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bitcoin",
        "archive_url": "https://api.github.com/repos/bitcoin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bitcoin/hooks",
        "svn_url": "https://github.com/bitcoin/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 37674,
        "stargazers_count": 85242,
        "watchers_count": 85242,
        "size": 291764,
        "default_branch": "master",
        "open_issues_count": 757,
        "is_template": false,
        "topics": [
          "bitcoin",
          "c-plus-plus",
          "cryptocurrency",
          "cryptography",
          "p2p"
        ],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2025-08-28T23:10:55Z",
        "created_at": "2010-12-19T15:16:43Z",
        "updated_at": "2025-08-29T05:50:11Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33023"
      }
    },
    "author_association": "NONE",
    "draft": false,
    "additions": 338,
    "deletions": 0,
    "changed_files": 2,
    "commits": 1,
    "review_comments": 10,
    "comments": 5
  },
  "events": [
    {
      "event": "labeled",
      "id": 18717281684,
      "node_id": "LE_lADOABII587BgayLzwAAAARbow2U",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18717281684",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-20T16:40:31Z",
      "label": {
        "name": "Tests",
        "color": "d4c5f9"
      }
    },
    {
      "event": "commented",
      "id": 3094639886,
      "node_id": "IC_kwDOABII5864dHUO",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3094639886",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-20T16:40:33Z",
      "updated_at": "2025-07-20T16:40:40Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage & Benchmarks\nFor details see: https://corecheck.dev/bitcoin/bitcoin/pulls/33023.\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\nA summary of reviews will appear here.\n<!--5faf32d7da4f0f540f40219e4f7537a3-->",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33023#issuecomment-3094639886",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33023"
    },
    {
      "event": "labeled",
      "id": 18717611632,
      "node_id": "LE_lADOABII587BgayLzwAAAARbqBZw",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18717611632",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-20T18:35:07Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 3094696436,
      "node_id": "IC_kwDOABII5864dVH0",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3094696436",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-20T18:35:08Z",
      "updated_at": "2025-07-20T18:35:08Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\nðŸš§ At least one of the CI tasks failed.\n<sub>Task `lint`: https://github.com/bitcoin/bitcoin/runs/46342861746</sub>\n<sub>LLM reason (âœ¨ experimental): The CI failure is primarily caused by lint errors detected by `ruff`, including issues with trailing whitespace and possible spelling errors.</sub>\n\n<details><summary>Hints</summary>\n\nTry to run the tests locally, according to the documentation. However, a CI failure may still\nhappen due to a number of reasons, for example:\n\n* Possibly due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\n* A sanitizer issue, which can only be found by compiling with the sanitizer and running the\n  affected test.\n\n* An intermittent issue.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n</details>\n\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33023#issuecomment-3094696436",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33023"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18772546322,
      "node_id": "HRFPE_lADOABII587BgayLzwAAAARe7lMS",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18772546322",
      "actor": {
        "login": "bigshiny90",
        "id": 23282055,
        "node_id": "MDQ6VXNlcjIzMjgyMDU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23282055?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigshiny90",
        "html_url": "https://github.com/bigshiny90",
        "followers_url": "https://api.github.com/users/bigshiny90/followers",
        "following_url": "https://api.github.com/users/bigshiny90/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigshiny90/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigshiny90/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigshiny90/subscriptions",
        "organizations_url": "https://api.github.com/users/bigshiny90/orgs",
        "repos_url": "https://api.github.com/users/bigshiny90/repos",
        "events_url": "https://api.github.com/users/bigshiny90/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigshiny90/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "3e933784d259b004808cdcadeb06fb2476ec1c7a",
      "commit_url": "https://api.github.com/repos/bigshiny90/bitcoin/commits/3e933784d259b004808cdcadeb06fb2476ec1c7a",
      "created_at": "2025-07-23T11:51:15Z"
    },
    {
      "event": "convert_to_draft",
      "id": 18792106849,
      "node_id": "CTDE_lADOABII587BgayLzwAAAARgGMth",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18792106849",
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-24T10:06:02Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18793230096,
      "node_id": "HRFPE_lADOABII587BgayLzwAAAARgKe8Q",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18793230096",
      "actor": {
        "login": "bigshiny90",
        "id": 23282055,
        "node_id": "MDQ6VXNlcjIzMjgyMDU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23282055?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigshiny90",
        "html_url": "https://github.com/bigshiny90",
        "followers_url": "https://api.github.com/users/bigshiny90/followers",
        "following_url": "https://api.github.com/users/bigshiny90/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigshiny90/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigshiny90/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigshiny90/subscriptions",
        "organizations_url": "https://api.github.com/users/bigshiny90/orgs",
        "repos_url": "https://api.github.com/users/bigshiny90/repos",
        "events_url": "https://api.github.com/users/bigshiny90/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigshiny90/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "57c481fe741e042b6ca4311773e0acadd4bfc8bc",
      "commit_url": "https://api.github.com/repos/bigshiny90/bitcoin/commits/57c481fe741e042b6ca4311773e0acadd4bfc8bc",
      "created_at": "2025-07-24T11:16:37Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18793302393,
      "node_id": "HRFPE_lADOABII587BgayLzwAAAARgKwl5",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18793302393",
      "actor": {
        "login": "bigshiny90",
        "id": 23282055,
        "node_id": "MDQ6VXNlcjIzMjgyMDU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23282055?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigshiny90",
        "html_url": "https://github.com/bigshiny90",
        "followers_url": "https://api.github.com/users/bigshiny90/followers",
        "following_url": "https://api.github.com/users/bigshiny90/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigshiny90/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigshiny90/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigshiny90/subscriptions",
        "organizations_url": "https://api.github.com/users/bigshiny90/orgs",
        "repos_url": "https://api.github.com/users/bigshiny90/repos",
        "events_url": "https://api.github.com/users/bigshiny90/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigshiny90/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "90f0f1d51f6c7261a7319ec09a953e622eb7f6ac",
      "commit_url": "https://api.github.com/repos/bigshiny90/bitcoin/commits/90f0f1d51f6c7261a7319ec09a953e622eb7f6ac",
      "created_at": "2025-07-24T11:21:40Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18793429445,
      "node_id": "HRFPE_lADOABII587BgayLzwAAAARgLPnF",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18793429445",
      "actor": {
        "login": "bigshiny90",
        "id": 23282055,
        "node_id": "MDQ6VXNlcjIzMjgyMDU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23282055?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigshiny90",
        "html_url": "https://github.com/bigshiny90",
        "followers_url": "https://api.github.com/users/bigshiny90/followers",
        "following_url": "https://api.github.com/users/bigshiny90/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigshiny90/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigshiny90/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigshiny90/subscriptions",
        "organizations_url": "https://api.github.com/users/bigshiny90/orgs",
        "repos_url": "https://api.github.com/users/bigshiny90/repos",
        "events_url": "https://api.github.com/users/bigshiny90/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigshiny90/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "a01547c7b678040e3bad1f8477d12d502ae7fa85",
      "commit_url": "https://api.github.com/repos/bigshiny90/bitcoin/commits/a01547c7b678040e3bad1f8477d12d502ae7fa85",
      "created_at": "2025-07-24T11:30:30Z"
    },
    {
      "event": "commented",
      "id": 3113104256,
      "node_id": "IC_kwDOABII5865jjOA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3113104256",
      "actor": {
        "login": "bigshiny90",
        "id": 23282055,
        "node_id": "MDQ6VXNlcjIzMjgyMDU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23282055?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigshiny90",
        "html_url": "https://github.com/bigshiny90",
        "followers_url": "https://api.github.com/users/bigshiny90/followers",
        "following_url": "https://api.github.com/users/bigshiny90/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigshiny90/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigshiny90/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigshiny90/subscriptions",
        "organizations_url": "https://api.github.com/users/bigshiny90/orgs",
        "repos_url": "https://api.github.com/users/bigshiny90/repos",
        "events_url": "https://api.github.com/users/bigshiny90/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigshiny90/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-24T11:31:19Z",
      "updated_at": "2025-07-24T12:25:06Z",
      "author_association": "NONE",
      "body": "updated to fix CI Lint errors\r\n\r\n(also had to remove an unused param)",
      "user": {
        "login": "bigshiny90",
        "id": 23282055,
        "node_id": "MDQ6VXNlcjIzMjgyMDU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23282055?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigshiny90",
        "html_url": "https://github.com/bigshiny90",
        "followers_url": "https://api.github.com/users/bigshiny90/followers",
        "following_url": "https://api.github.com/users/bigshiny90/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigshiny90/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigshiny90/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigshiny90/subscriptions",
        "organizations_url": "https://api.github.com/users/bigshiny90/orgs",
        "repos_url": "https://api.github.com/users/bigshiny90/repos",
        "events_url": "https://api.github.com/users/bigshiny90/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigshiny90/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33023#issuecomment-3113104256",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33023"
    },
    {
      "event": "ready_for_review",
      "id": 18793683751,
      "node_id": "RFRE_lADOABII587BgayLzwAAAARgMNsn",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18793683751",
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-24T11:47:47Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18794167016,
      "node_id": "HRFPE_lADOABII587BgayLzwAAAARgODro",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18794167016",
      "actor": {
        "login": "bigshiny90",
        "id": 23282055,
        "node_id": "MDQ6VXNlcjIzMjgyMDU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23282055?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigshiny90",
        "html_url": "https://github.com/bigshiny90",
        "followers_url": "https://api.github.com/users/bigshiny90/followers",
        "following_url": "https://api.github.com/users/bigshiny90/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigshiny90/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigshiny90/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigshiny90/subscriptions",
        "organizations_url": "https://api.github.com/users/bigshiny90/orgs",
        "repos_url": "https://api.github.com/users/bigshiny90/repos",
        "events_url": "https://api.github.com/users/bigshiny90/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigshiny90/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "4985235dd29de317f42edf1709606fa5663e2074",
      "commit_url": "https://api.github.com/repos/bigshiny90/bitcoin/commits/4985235dd29de317f42edf1709606fa5663e2074",
      "created_at": "2025-07-24T12:16:41Z"
    },
    {
      "event": "unlabeled",
      "id": 18799900724,
      "node_id": "UNLE_lADOABII587BgayLzwAAAARgj7g0",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18799900724",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-24T17:21:11Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 3053070561,
      "node_id": "PRR_kwDOABII5861-ijh",
      "url": null,
      "actor": null,
      "commit_id": "4985235dd29de317f42edf1709606fa5663e2074",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-07-24T19:48:53Z",
      "author_association": "CONTRIBUTOR",
      "body": "I think the description is not clear about what you're trying to cover/achieve with the test. Can you explain it better? Also, corecheck doesn't show any related new coverage.",
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33023#pullrequestreview-3053070561",
      "submitted_at": "2025-07-24T19:48:53Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33023"
    },
    {
      "event": "commented",
      "id": 3114783342,
      "node_id": "IC_kwDOABII5865p9Ju",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3114783342",
      "actor": {
        "login": "bigshiny90",
        "id": 23282055,
        "node_id": "MDQ6VXNlcjIzMjgyMDU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23282055?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigshiny90",
        "html_url": "https://github.com/bigshiny90",
        "followers_url": "https://api.github.com/users/bigshiny90/followers",
        "following_url": "https://api.github.com/users/bigshiny90/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigshiny90/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigshiny90/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigshiny90/subscriptions",
        "organizations_url": "https://api.github.com/users/bigshiny90/orgs",
        "repos_url": "https://api.github.com/users/bigshiny90/repos",
        "events_url": "https://api.github.com/users/bigshiny90/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigshiny90/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-24T20:11:44Z",
      "updated_at": "2025-07-29T22:07:36Z",
      "author_association": "NONE",
      "body": "> I think the description is not clear about what you're trying to cover/achieve with the test. Can you explain it better? Also, corecheck doesn't show any related new coverage.\r\n\r\nAdded better description (hopefully) to PR\r\n\r\nI'm not sure about corecheck, but i'll hazard a guess:\r\n\r\nThere are other tests that cover the p2p_compactblocks - so these tests seem to cover the same ground, though in reality they are testing something new. (also, the fact that most of what is being tested is not publicly exposed). Just a guess, as I donâ€™t know how corecheck determines things\r\n\r\nHopefully answers the questions?\r\n  ",
      "user": {
        "login": "bigshiny90",
        "id": 23282055,
        "node_id": "MDQ6VXNlcjIzMjgyMDU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23282055?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigshiny90",
        "html_url": "https://github.com/bigshiny90",
        "followers_url": "https://api.github.com/users/bigshiny90/followers",
        "following_url": "https://api.github.com/users/bigshiny90/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigshiny90/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigshiny90/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigshiny90/subscriptions",
        "organizations_url": "https://api.github.com/users/bigshiny90/orgs",
        "repos_url": "https://api.github.com/users/bigshiny90/repos",
        "events_url": "https://api.github.com/users/bigshiny90/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigshiny90/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33023#issuecomment-3114783342",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33023"
    },
    {
      "event": "renamed",
      "id": 18812178624,
      "node_id": "RTE_lADOABII587BgayLzwAAAARhSxDA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18812178624",
      "actor": {
        "login": "bigshiny90",
        "id": 23282055,
        "node_id": "MDQ6VXNlcjIzMjgyMDU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23282055?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigshiny90",
        "html_url": "https://github.com/bigshiny90",
        "followers_url": "https://api.github.com/users/bigshiny90/followers",
        "following_url": "https://api.github.com/users/bigshiny90/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigshiny90/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigshiny90/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigshiny90/subscriptions",
        "organizations_url": "https://api.github.com/users/bigshiny90/orgs",
        "repos_url": "https://api.github.com/users/bigshiny90/repos",
        "events_url": "https://api.github.com/users/bigshiny90/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigshiny90/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-25T10:34:19Z",
      "rename": {
        "from": "test: Add functional tests for blockreconstructionextratxn parameter",
        "to": "test: Add functional tests for blockreconstructionextratxn and extra pool (compactblocks)"
      }
    },
    {
      "event": "reviewed",
      "id": 3069251735,
      "node_id": "PRR_kwDOABII58628RCX",
      "url": null,
      "actor": null,
      "commit_id": "4985235dd29de317f42edf1709606fa5663e2074",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-07-29T21:34:21Z",
      "author_association": "MEMBER",
      "user": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33023#pullrequestreview-3069251735",
      "submitted_at": "2025-07-29T21:34:21Z",
      "state": "CHANGES_REQUESTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33023"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18887631085,
      "node_id": "HRFPE_lADOABII587BgayLzwAAAARlymDt",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18887631085",
      "actor": {
        "login": "bigshiny90",
        "id": 23282055,
        "node_id": "MDQ6VXNlcjIzMjgyMDU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23282055?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigshiny90",
        "html_url": "https://github.com/bigshiny90",
        "followers_url": "https://api.github.com/users/bigshiny90/followers",
        "following_url": "https://api.github.com/users/bigshiny90/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigshiny90/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigshiny90/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigshiny90/subscriptions",
        "organizations_url": "https://api.github.com/users/bigshiny90/orgs",
        "repos_url": "https://api.github.com/users/bigshiny90/repos",
        "events_url": "https://api.github.com/users/bigshiny90/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigshiny90/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "b4f34aabe9741bbc4d27639a9a7de4fb2243b354",
      "commit_url": "https://api.github.com/repos/bigshiny90/bitcoin/commits/b4f34aabe9741bbc4d27639a9a7de4fb2243b354",
      "created_at": "2025-07-29T22:02:54Z"
    },
    {
      "event": "review_requested",
      "id": 18887662733,
      "node_id": "RRE_lADOABII587BgayLzwAAAARlytyN",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18887662733",
      "actor": {
        "login": "bigshiny90",
        "id": 23282055,
        "node_id": "MDQ6VXNlcjIzMjgyMDU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23282055?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigshiny90",
        "html_url": "https://github.com/bigshiny90",
        "followers_url": "https://api.github.com/users/bigshiny90/followers",
        "following_url": "https://api.github.com/users/bigshiny90/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigshiny90/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigshiny90/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigshiny90/subscriptions",
        "organizations_url": "https://api.github.com/users/bigshiny90/orgs",
        "repos_url": "https://api.github.com/users/bigshiny90/repos",
        "events_url": "https://api.github.com/users/bigshiny90/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigshiny90/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-29T22:05:32Z",
      "requested_reviewer": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "bigshiny90",
        "id": 23282055,
        "node_id": "MDQ6VXNlcjIzMjgyMDU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23282055?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigshiny90",
        "html_url": "https://github.com/bigshiny90",
        "followers_url": "https://api.github.com/users/bigshiny90/followers",
        "following_url": "https://api.github.com/users/bigshiny90/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigshiny90/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigshiny90/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigshiny90/subscriptions",
        "organizations_url": "https://api.github.com/users/bigshiny90/orgs",
        "repos_url": "https://api.github.com/users/bigshiny90/repos",
        "events_url": "https://api.github.com/users/bigshiny90/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigshiny90/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "review_requested",
      "id": 18887677962,
      "node_id": "RRE_lADOABII587BgayLzwAAAARlyxgK",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18887677962",
      "actor": {
        "login": "bigshiny90",
        "id": 23282055,
        "node_id": "MDQ6VXNlcjIzMjgyMDU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23282055?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigshiny90",
        "html_url": "https://github.com/bigshiny90",
        "followers_url": "https://api.github.com/users/bigshiny90/followers",
        "following_url": "https://api.github.com/users/bigshiny90/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigshiny90/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigshiny90/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigshiny90/subscriptions",
        "organizations_url": "https://api.github.com/users/bigshiny90/orgs",
        "repos_url": "https://api.github.com/users/bigshiny90/repos",
        "events_url": "https://api.github.com/users/bigshiny90/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigshiny90/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-07-29T22:06:51Z",
      "requested_reviewer": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "bigshiny90",
        "id": 23282055,
        "node_id": "MDQ6VXNlcjIzMjgyMDU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23282055?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigshiny90",
        "html_url": "https://github.com/bigshiny90",
        "followers_url": "https://api.github.com/users/bigshiny90/followers",
        "following_url": "https://api.github.com/users/bigshiny90/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigshiny90/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigshiny90/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigshiny90/subscriptions",
        "organizations_url": "https://api.github.com/users/bigshiny90/orgs",
        "repos_url": "https://api.github.com/users/bigshiny90/repos",
        "events_url": "https://api.github.com/users/bigshiny90/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigshiny90/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 18906861372,
      "node_id": "HRFPE_lADOABII587BgayLzwAAAARm7888",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18906861372",
      "actor": {
        "login": "bigshiny90",
        "id": 23282055,
        "node_id": "MDQ6VXNlcjIzMjgyMDU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23282055?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigshiny90",
        "html_url": "https://github.com/bigshiny90",
        "followers_url": "https://api.github.com/users/bigshiny90/followers",
        "following_url": "https://api.github.com/users/bigshiny90/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigshiny90/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigshiny90/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigshiny90/subscriptions",
        "organizations_url": "https://api.github.com/users/bigshiny90/orgs",
        "repos_url": "https://api.github.com/users/bigshiny90/repos",
        "events_url": "https://api.github.com/users/bigshiny90/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigshiny90/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "bd1c6b4ea9b94ab4b2604f2a4b8a7fd1fe55c92a",
      "commit_url": "https://api.github.com/repos/bigshiny90/bitcoin/commits/bd1c6b4ea9b94ab4b2604f2a4b8a7fd1fe55c92a",
      "created_at": "2025-07-30T20:13:12Z"
    },
    {
      "event": "referenced",
      "id": 18978471422,
      "node_id": "REFE_lADOABII587BgayLzwAAAARrNH3-",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18978471422",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "d78bbe5707e8146737d89715b42067a00f2c96a4",
      "commit_url": "https://api.github.com/repos/bitcoinknots/bitcoin/commits/d78bbe5707e8146737d89715b42067a00f2c96a4",
      "created_at": "2025-08-04T21:05:53Z"
    },
    {
      "event": "reviewed",
      "id": 3153147837,
      "node_id": "PRR_kwDOABII58678Te9",
      "url": null,
      "actor": null,
      "commit_id": "bd1c6b4ea9b94ab4b2604f2a4b8a7fd1fe55c92a",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-08-25T22:09:43Z",
      "author_association": "CONTRIBUTOR",
      "body": "I get the idea of testing the extra pool. I think some of the tests can be consolidated.\n\nI did run the test locally, and it passes for me. I haven't checked code coverage either to see if it covers anything extra,\n\nbut `grep -nri \"blockreconstructionextratxn\" ./test/functional/` does not have any matches",
      "user": {
        "login": "kevkevinpal",
        "id": 15950706,
        "node_id": "MDQ6VXNlcjE1OTUwNzA2",
        "avatar_url": "https://avatars.githubusercontent.com/u/15950706?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kevkevinpal",
        "html_url": "https://github.com/kevkevinpal",
        "followers_url": "https://api.github.com/users/kevkevinpal/followers",
        "following_url": "https://api.github.com/users/kevkevinpal/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kevkevinpal/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kevkevinpal/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kevkevinpal/subscriptions",
        "organizations_url": "https://api.github.com/users/kevkevinpal/orgs",
        "repos_url": "https://api.github.com/users/kevkevinpal/repos",
        "events_url": "https://api.github.com/users/kevkevinpal/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kevkevinpal/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33023#pullrequestreview-3153147837",
      "submitted_at": "2025-08-25T22:09:43Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33023"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGY5YzYzMzFjYjI2ZjNiYWZjM2RiYTdmNWE3MjYyMmE5ZmY0ZjE5MGQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f9c6331cb26f3bafc3dba7f5a72622a9ff4f190d",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/f9c6331cb26f3bafc3dba7f5a72622a9ff4f190d",
      "tree": {
        "sha": "ad797f24eaccee4d3c682a4b6c70ae1e2a9b6a06",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ad797f24eaccee4d3c682a4b6c70ae1e2a9b6a06"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/672c85cb1ea0d76ef9e596b2a964b2311b11b815",
          "sha": "672c85cb1ea0d76ef9e596b2a964b2311b11b815",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/672c85cb1ea0d76ef9e596b2a964b2311b11b815"
        }
      ],
      "message": "test: Add functional tests for blockreconstructionextratxn parameter\n\nThis adds comprehensive functional tests for the extra transaction pool\nused in compact block reconstruction, controlled by the\n-blockreconstructionextratxn parameter.",
      "committer": {
        "name": "shiny",
        "email": "23282055+bigshiny90@users.noreply.github.com",
        "date": "2025-08-25T23:39:41Z"
      },
      "author": {
        "name": "shiny",
        "email": "23282055+bigshiny90@users.noreply.github.com",
        "date": "2025-07-23T11:51:00Z"
      },
      "sha": "f9c6331cb26f3bafc3dba7f5a72622a9ff4f190d"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 19332198585,
      "node_id": "HRFPE_lADOABII587BgayLzwAAAASASfC5",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19332198585",
      "actor": {
        "login": "bigshiny90",
        "id": 23282055,
        "node_id": "MDQ6VXNlcjIzMjgyMDU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23282055?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigshiny90",
        "html_url": "https://github.com/bigshiny90",
        "followers_url": "https://api.github.com/users/bigshiny90/followers",
        "following_url": "https://api.github.com/users/bigshiny90/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigshiny90/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigshiny90/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigshiny90/subscriptions",
        "organizations_url": "https://api.github.com/users/bigshiny90/orgs",
        "repos_url": "https://api.github.com/users/bigshiny90/repos",
        "events_url": "https://api.github.com/users/bigshiny90/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigshiny90/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "f9c6331cb26f3bafc3dba7f5a72622a9ff4f190d",
      "commit_url": "https://api.github.com/repos/bigshiny90/bitcoin/commits/f9c6331cb26f3bafc3dba7f5a72622a9ff4f190d",
      "created_at": "2025-08-25T23:40:30Z"
    },
    {
      "event": "review_requested",
      "id": 19332263802,
      "node_id": "RRE_lADOABII587BgayLzwAAAASASu96",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19332263802",
      "actor": {
        "login": "bigshiny90",
        "id": 23282055,
        "node_id": "MDQ6VXNlcjIzMjgyMDU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23282055?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigshiny90",
        "html_url": "https://github.com/bigshiny90",
        "followers_url": "https://api.github.com/users/bigshiny90/followers",
        "following_url": "https://api.github.com/users/bigshiny90/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigshiny90/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigshiny90/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigshiny90/subscriptions",
        "organizations_url": "https://api.github.com/users/bigshiny90/orgs",
        "repos_url": "https://api.github.com/users/bigshiny90/repos",
        "events_url": "https://api.github.com/users/bigshiny90/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigshiny90/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-25T23:46:39Z",
      "requested_reviewer": {
        "login": "kevkevinpal",
        "id": 15950706,
        "node_id": "MDQ6VXNlcjE1OTUwNzA2",
        "avatar_url": "https://avatars.githubusercontent.com/u/15950706?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kevkevinpal",
        "html_url": "https://github.com/kevkevinpal",
        "followers_url": "https://api.github.com/users/kevkevinpal/followers",
        "following_url": "https://api.github.com/users/kevkevinpal/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kevkevinpal/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kevkevinpal/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kevkevinpal/subscriptions",
        "organizations_url": "https://api.github.com/users/kevkevinpal/orgs",
        "repos_url": "https://api.github.com/users/kevkevinpal/repos",
        "events_url": "https://api.github.com/users/kevkevinpal/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kevkevinpal/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "bigshiny90",
        "id": 23282055,
        "node_id": "MDQ6VXNlcjIzMjgyMDU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23282055?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigshiny90",
        "html_url": "https://github.com/bigshiny90",
        "followers_url": "https://api.github.com/users/bigshiny90/followers",
        "following_url": "https://api.github.com/users/bigshiny90/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigshiny90/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigshiny90/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigshiny90/subscriptions",
        "organizations_url": "https://api.github.com/users/bigshiny90/orgs",
        "repos_url": "https://api.github.com/users/bigshiny90/repos",
        "events_url": "https://api.github.com/users/bigshiny90/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigshiny90/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "labeled",
      "id": 19332831527,
      "node_id": "LE_lADOABII587BgayLzwAAAASAU5kn",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19332831527",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-26T00:46:50Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "referenced",
      "id": 19380072827,
      "node_id": "REFE_lADOABII587BgayLzwAAAASDJHF7",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/19380072827",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "1af7b8a326fe6d74003eeed02bdd7039606e2a7d",
      "commit_url": "https://api.github.com/repos/bitcoinknots/bitcoin/commits/1af7b8a326fe6d74003eeed02bdd7039606e2a7d",
      "created_at": "2025-08-28T00:38:27Z"
    },
    {
      "event": "commented",
      "id": 3236087975,
      "node_id": "IC_kwDOABII587A4sin",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3236087975",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-08-29T07:51:11Z",
      "updated_at": "2025-08-29T07:51:11Z",
      "author_association": "CONTRIBUTOR",
      "body": "Could turn into draft while CI is red?",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33023#issuecomment-3236087975",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33023"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2241039496",
      "pull_request_review_id": 3069251735,
      "id": 2241039496,
      "node_id": "PRRC_kwDOABII586Fk4yI",
      "diff_hunk": "@@ -0,0 +1,428 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2025 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test blockreconstructionextratxn option with compact blocks.\"\"\"\n+\n+from test_framework.blocktools import (\n+    COINBASE_MATURITY,\n+    NORMAL_GBT_REQUEST_PARAMS,\n+    create_block,\n+    add_witness_commitment,\n+)\n+from test_framework.messages import (\n+    CTxOut,\n+    HeaderAndShortIDs,\n+    MSG_BLOCK,\n+    msg_cmpctblock,\n+    msg_sendcmpct,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+    p2p_lock,\n+)\n+from test_framework.script import (\n+    CScript,\n+    OP_TRUE,\n+)\n+from test_framework.script_util import (\n+    keys_to_multisig_script,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    softfork_active,\n+)\n+from decimal import Decimal\n+from test_framework.wallet import MiniWallet\n+\n+\n+# TestP2PConn: A peer we use to send messages to bitcoind, and store responses.\n+class TestP2PConn(P2PInterface):\n+    def __init__(self):\n+        super().__init__()\n+        self.last_sendcmpct = []\n+        self.block_announced = False\n+        # Store the hashes of blocks we've seen announced.\n+        # This is for synchronizing the p2p message traffic,\n+        # so we can eg wait until a particular block is announced.\n+        self.announced_blockhashes = set()\n+\n+    def on_sendcmpct(self, message):\n+        self.last_sendcmpct.append(message)\n+\n+    def on_cmpctblock(self, message):\n+        self.block_announced = True\n+        self.last_message[\"cmpctblock\"].header_and_shortids.header.calc_sha256()\n+        self.announced_blockhashes.add(self.last_message[\"cmpctblock\"].header_and_shortids.header.sha256)\n+\n+    def on_headers(self, message):\n+        self.block_announced = True\n+        for x in self.last_message[\"headers\"].headers:\n+            x.calc_sha256()\n+            self.announced_blockhashes.add(x.sha256)\n+\n+    def on_inv(self, message):\n+        for x in self.last_message[\"inv\"].inv:\n+            if x.type == MSG_BLOCK:\n+                self.block_announced = True\n+                self.announced_blockhashes.add(x.hash)\n+\n+    # Requires caller to hold p2p_lock\n+    def received_block_announcement(self):\n+        return self.block_announced\n+\n+    def clear_block_announcement(self):\n+        with p2p_lock:\n+            self.block_announced = False\n+            self.last_message.pop(\"inv\", None)\n+            self.last_message.pop(\"headers\", None)\n+            self.last_message.pop(\"cmpctblock\", None)\n+\n+    def clear_getblocktxn(self):\n+        with p2p_lock:\n+            self.last_message.pop(\"getblocktxn\", None)\n+\n+\n+class CompactBlocksBlockReconstructionLimitTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+        self.extra_args = [[\n+            \"-acceptnonstdtxn=0\",\n+            \"-debug=net\",\n+        ]]\n+        self.utxos = []\n+\n+    def build_block_on_tip(self, node):\n+        \"\"\"Build a block on top of the current tip.\"\"\"\n+        block = create_block(tmpl=node.getblocktemplate(NORMAL_GBT_REQUEST_PARAMS))\n+        block.solve()\n+        return block\n+\n+    def make_utxos(self):\n+        \"\"\"Generate blocks to create UTXOs for the wallet.\"\"\"\n+        self.generate(self.wallet, COINBASE_MATURITY + 800)\n+\n+    def restart_node_with_limit(self, count=None):\n+        \"\"\"Restart node with specific count limit.\"\"\"\n+        extra_args = [\"-acceptnonstdtxn=0\", \"-debug=net\"]\n+\n+        if count is not None:\n+            self.log.info(f\"Setting transaction count limit: {count}\")\n+            extra_args.append(f\"-blockreconstructionextratxn={count}\")\n+\n+        self.log.info(f\"Restarting node with args: {extra_args}\")\n+        self.restart_node(0, extra_args=extra_args)\n+        self.segwit_node = self.nodes[0].add_p2p_connection(TestP2PConn())\n+        self.segwit_node.send_and_ping(msg_sendcmpct(announce=True, version=2))\n+\n+    def create_policy_rejected_tx(self, rejection_type=\"dust\"):\n+        \"\"\"Create a transaction that will be rejected for policy reasons but added to extra pool.\"\"\"\n+\n+        if rejection_type == \"dust\":\n+            tx_info = self.wallet.create_self_transfer()\n+            dust_amount = 100\n+            dust_script = CScript([OP_TRUE])\n+            tx_info['tx'].vout.append(CTxOut(dust_amount, dust_script))\n+            tx_info['tx'].vout[0].nValue -= dust_amount\n+\n+        elif rejection_type == \"low_fee\":\n+            tx_info = self.wallet.create_self_transfer(fee_rate=Decimal('0.00000100'))\n+\n+        elif rejection_type == \"nonstandard_script\":\n+            tx_info = self.wallet.create_self_transfer()\n+            pubkeys = []\n+            for _ in range(4):\n+                pubkeys.append(bytes([0x02] + [0x00] * 32))\n+            multisig_script = keys_to_multisig_script(pubkeys, k=4)\n+            tx_info['tx'].vout.append(CTxOut(10000, multisig_script))\n+            tx_info['tx'].vout[0].nValue -= 10000\n+\n+        else:\n+            raise ValueError(f\"Unknown rejection type: {rejection_type}\")\n+\n+        tx_info['hex'] = tx_info['tx'].serialize().hex()\n+        return tx_info\n+\n+    def populate_extra_pool(self, num_txs, rejection_type=\"dust\"):\n+        \"\"\"Populate the extra transaction pool using policy-rejected transactions.\"\"\"\n+        rejected_txs = []\n+\n+        for i in range(num_txs):\n+            tx_info = self.create_policy_rejected_tx(rejection_type)\n+            tx_obj = tx_from_hex(tx_info['hex'])\n+            self.segwit_node.send_without_ping(msg_tx(tx_obj))\n+            rejected_txs.append(tx_info)\n+\n+        self.segwit_node.sync_with_ping()\n+\n+        return rejected_txs\n+\n+    def send_compact_block(self, transactions, indices):\n+        \"\"\"Send a compact block and check which transactions are requested for reconstruction.\"\"\"\n+        node = self.nodes[0]\n+\n+        # Build block\n+        block = self.build_block_on_tip(node)\n+\n+        for i in indices:\n+            tx_obj = tx_from_hex(transactions[i]['hex'])\n+            block.vtx.append(tx_obj)\n+\n+        # Add witness commitment for blocks with witness transactions\n+        add_witness_commitment(block)\n+        block.solve()\n+\n+        # Send as compact block\n+        cmpct_block = HeaderAndShortIDs()\n+        cmpct_block.initialize_from_block(block, use_witness=True)\n+        self.segwit_node.send_and_ping(msg_cmpctblock(cmpct_block.to_p2p()))\n+\n+        # Check if node requested missing transactions\n+        with p2p_lock:\n+            getblocktxn = self.segwit_node.last_message.get(\"getblocktxn\")\n+\n+        num_tx_requested = len(getblocktxn.block_txn_request.indexes) if getblocktxn else 0\n+        self.segwit_node.clear_getblocktxn()\n+\n+        # Convert differential encoding to absolute indices (from BlockTransactionRequest)\n+        missing_indices = []\n+        if getblocktxn:\n+            absolute_block_indices = getblocktxn.block_txn_request.to_absolute()\n+            # Convert from block positions to transaction indices (subtract 1 for coinbase)\n+            missing_indices = [idx - 1 for idx in absolute_block_indices]\n+\n+        return {\n+            \"block\": block,\n+            \"getblocktxn\": getblocktxn,\n+            \"num_tx_requested\": num_tx_requested,\n+            \"missing_indices\": missing_indices\n+        }\n+\n+    # TEST: policy-rejected transactions\n+\n+    def test_policy_rejection_types(self):\n+        \"\"\"Test that each policy rejection type adds transactions to extra pool.\"\"\"\n+        self.log.info(\"Testing policy rejection types for extra pool...\")\n+\n+        self.restart_node(0, extra_args=[\n+            \"-debug=net\",\n+            \"-blockreconstructionextratxn=100\"\n+        ])\n+\n+        self.segwit_node = self.nodes[0].add_p2p_connection(TestP2PConn())\n+        self.segwit_node.send_and_ping(msg_sendcmpct(announce=True, version=2))\n+\n+        rejection_types = [\"dust\", \"low_fee\", \"nonstandard_script\"]\n+        rejected_txs = []\n+\n+        for rejection_type in rejection_types:\n+            self.log.info(f\"Testing {rejection_type} rejection...\")\n+            tx_info = self.create_policy_rejected_tx(rejection_type)\n+\n+            tx_obj = tx_from_hex(tx_info['hex'])\n+            self.segwit_node.send_without_ping(msg_tx(tx_obj))\n+\n+            rejected_txs.append({\n+                'type': rejection_type,\n+                'tx_info': tx_info,\n+                'txid': tx_info['tx'].txid_hex\n+            })\n+\n+        self.segwit_node.sync_with_ping()\n+\n+        mempool = self.nodes[0].getrawmempool()\n+        for rejected in rejected_txs:\n+            assert_equal(rejected['txid'] in mempool, False)\n+            self.log.info(f\"âœ“ {rejected['type']} transaction rejected from mempool\")\n+\n+        indices = list(range(len(rejected_txs)))\n+        tx_list = [r['tx_info'] for r in rejected_txs]\n+\n+        result = self.send_compact_block(tx_list, indices)\n+\n+        assert_equal(result[\"missing_indices\"], [])\n+        self.log.info(\"âœ“ All rejected transactions are available in extra pool\")\n+\n+    # TEST: blockreconstructionextratxn\n+\n+    def test_extratxnpool_disabled(self):\n+        \"\"\"Test that setting count to 0 disables the extra transaction pool.\"\"\"\n+        self.log.info(\"Testing disabled extra transaction pool (0 capacity)...\")\n+\n+        self.restart_node_with_limit(count=0)\n+        buffersize = 5\n+        rejected_txs = self.populate_extra_pool(buffersize)\n+\n+        indices = list(range(buffersize))\n+        result = self.send_compact_block(rejected_txs, indices)\n+        assert_equal(result[\"missing_indices\"], indices)\n+        self.log.info(f\"âœ“ All {buffersize} transactions are missing (extra txn pool disabled)\")\n+\n+    def test_extratxnpool_capacity(self):\n+        \"\"\"Test extra transaction pool capacity transactions.\"\"\"\n+        self.log.info(\"Testing extra transaction pool capacity (50 transactions)...\")\n+\n+        buffersize = 50\n+        self.restart_node_with_limit(count=buffersize)\n+\n+        rejected_txs = self.populate_extra_pool(buffersize)\n+\n+        indices = list(range(buffersize))\n+        result = self.send_compact_block(rejected_txs, indices)\n+\n+        assert_equal(result[\"missing_indices\"], [])\n+        self.log.info(\"âœ“ All rejected transactions are in the extra txn pool\")\n+\n+        # Test that adding a 51st transaction causes eviction\n+        self.log.info(\"Adding transaction to test eviction...\")\n+        self.populate_extra_pool(1)\n+\n+        # Check original transactions again - first one should be evicted\n+        result2 = self.send_compact_block(rejected_txs, indices)\n+        assert_equal(result2[\"missing_indices\"], [0])\n+        self.log.info(\"âœ“ Transaction 0 was evicted as expected\")\n+\n+    def test_single_extratxnpool_capacity(self):\n+        \"\"\"Test edge case of single capacity extra transaction pool.\"\"\"\n+        self.log.info(\"Testing single capacity extra transaction pool...\")\n+\n+        self.restart_node_with_limit(count=1)\n+        tx_count = 5\n+\n+        rejected_txs = self.populate_extra_pool(tx_count)\n+\n+        indices = list(range(tx_count))\n+        result = self.send_compact_block(rejected_txs, indices)\n+\n+        expected_missing = list(range(4))\n+        assert_equal(result[\"missing_indices\"], expected_missing)\n+\n+    def test_extratxn_large_capacity(self):\n+        \"\"\"Test extra transaction pool with very large count parameter.\"\"\"\n+        self.log.info(\"Testing with count=400 to ensure large buffers work correctly...\")\n+\n+        buffersize = 400\n+        self.restart_node_with_limit(count=buffersize)\n+\n+        rejected_txs = self.populate_extra_pool(buffersize)\n+\n+        indices = list(range(buffersize))\n+        result = self.send_compact_block(rejected_txs, indices)\n+\n+        assert_equal(result[\"missing_indices\"], [])\n+        self.log.info(\"âœ“ All rejected transactions are in the extra txn pool\")\n+\n+        # Test that adding a transaction causes eviction\n+        self.log.info(\"Adding another transaction to test eviction...\")\n+        self.populate_extra_pool(1)\n+\n+        # Check original transactions again - first one should be evicted\n+        result2 = self.send_compact_block(rejected_txs, indices)\n+        assert_equal(result2[\"missing_indices\"], [0])\n+        self.log.info(\"âœ“ Transaction 0 was evicted as expected\")\n+\n+    def test_extratxn_buffer_wraparound(self):\n+        \"\"\"Test that adding transactions to a full buffer evicts oldest slots.\"\"\"\n+        self.log.info(\"Testing extratxn buffer wraparound - fill buffer then add more...\")\n+\n+        buffersize = 20\n+\n+        new_tx_count = 17\n+        self.restart_node_with_limit(count=buffersize)\n+\n+        # Step 1: Fill the buffer with rejected transactions\n+        rejected_txs = self.populate_extra_pool(buffersize)\n+\n+        # Verify all rejected transactions are in the extra pool\n+        indices = list(range(buffersize))\n+        result = self.send_compact_block(rejected_txs, indices)\n+        assert_equal(result[\"missing_indices\"], [])\n+        self.log.info(\"âœ“ All rejected transactions are in the extra pool\")\n+\n+        # Step 2: Add more rejected transactions\n+        self.log.info(f\"Step 2: Adding {new_tx_count} more rejected transactions (should wrap and evict slots 0-{new_tx_count-1})\")\n+        self.populate_extra_pool(new_tx_count)\n+\n+        result2 = self.send_compact_block(rejected_txs, indices)\n+\n+        # Verify wraparound worked correctly - first new_tx_count should be evicted\n+        expected_missing = list(range(new_tx_count))\n+        assert_equal(result2['missing_indices'], expected_missing)\n+        self.log.info(f\"âœ“ Wraparound worked correctly! Transactions {expected_missing} were evicted as expected\")\n+\n+    def test_extratxn_minimal_capacity_eviction(self):\n+        \"\"\"Test frequent eviction with minimal capacity.\"\"\"\n+        self.log.info(\"Testing minimal capacity eviction with count=2...\")\n+\n+        self.restart_node_with_limit(count=2)\n+\n+        # Add 10 rejected transactions to stress eviction\n+        num_txs = 10\n+        rejected_txs = self.populate_extra_pool(num_txs)\n+\n+        # Only the last 2 should remain\n+        # Try to reconstruct with all 10\n+        indices = list(range(num_txs))\n+        result = self.send_compact_block(rejected_txs, indices)\n+\n+        # First 8 should be missing (evicted)\n+        expected_missing = list(range(8))\n+        assert_equal(result[\"missing_indices\"], expected_missing)\n+\n+    def test_extratxn_invalid_parameters(self):\n+        \"\"\"Test handling of invalid blockreconstructionextratxn values.\"\"\"\n+        self.log.info(\"Testing invalid parameter values...\")\n+\n+        # Test negative value - should be clamped to 0 (disabled)\n+        self.log.info(\"Testing negative value (-1)...\")\n+        self.restart_node_with_limit(count=-1)\n+\n+        # Add a transaction and verify pool is disabled\n+        rejected_txs = self.populate_extra_pool(1)\n+        result = self.send_compact_block(rejected_txs, [0])\n+        assert_equal(result[\"missing_indices\"], [0])\n+\n+        # Test extremely large value\n+        self.log.info(\"Testing large value (100000)...\")\n+        self.restart_node_with_limit(count=100000)  # Very large but reasonable\n+\n+        # Add some transactions - should work but be clamped\n+        rejected_txs = self.populate_extra_pool(10)\n+        result = self.send_compact_block(rejected_txs, list(range(10)))\n+        assert_equal(result[\"missing_indices\"], [])\n+\n+\n+    def run_test(self):\n+        self.wallet = MiniWallet(self.nodes[0])\n+\n+        # Setup the p2p connection\n+        self.segwit_node = self.nodes[0].add_p2p_connection(TestP2PConn())\n+\n+        # Create UTXOs for testing\n+        self.make_utxos()\n+\n+        # Ensure segwit is active\n+        assert softfork_active(self.nodes[0], \"segwit\")\n+\n+       # Test policy rejection types first",
      "path": "test/functional/p2p_compactblocks_extratxs.py",
      "position": 1,
      "original_position": 411,
      "commit_id": "f9c6331cb26f3bafc3dba7f5a72622a9ff4f190d",
      "original_commit_id": "4985235dd29de317f42edf1709606fa5663e2074",
      "in_reply_to_id": null,
      "user": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Missing a space",
      "created_at": "2025-07-29T21:18:40Z",
      "updated_at": "2025-07-29T21:34:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33023#discussion_r2241039496",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2241039496"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33023"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 411,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2241107374",
      "pull_request_review_id": 3069336014,
      "id": 2241107374,
      "node_id": "PRRC_kwDOABII586FlJWu",
      "diff_hunk": "@@ -0,0 +1,428 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2025 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test blockreconstructionextratxn option with compact blocks.\"\"\"\n+\n+from test_framework.blocktools import (\n+    COINBASE_MATURITY,\n+    NORMAL_GBT_REQUEST_PARAMS,\n+    create_block,\n+    add_witness_commitment,\n+)\n+from test_framework.messages import (\n+    CTxOut,\n+    HeaderAndShortIDs,\n+    MSG_BLOCK,\n+    msg_cmpctblock,\n+    msg_sendcmpct,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+    p2p_lock,\n+)\n+from test_framework.script import (\n+    CScript,\n+    OP_TRUE,\n+)\n+from test_framework.script_util import (\n+    keys_to_multisig_script,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    softfork_active,\n+)\n+from decimal import Decimal\n+from test_framework.wallet import MiniWallet\n+\n+\n+# TestP2PConn: A peer we use to send messages to bitcoind, and store responses.\n+class TestP2PConn(P2PInterface):\n+    def __init__(self):\n+        super().__init__()\n+        self.last_sendcmpct = []\n+        self.block_announced = False\n+        # Store the hashes of blocks we've seen announced.\n+        # This is for synchronizing the p2p message traffic,\n+        # so we can eg wait until a particular block is announced.\n+        self.announced_blockhashes = set()\n+\n+    def on_sendcmpct(self, message):\n+        self.last_sendcmpct.append(message)\n+\n+    def on_cmpctblock(self, message):\n+        self.block_announced = True\n+        self.last_message[\"cmpctblock\"].header_and_shortids.header.calc_sha256()\n+        self.announced_blockhashes.add(self.last_message[\"cmpctblock\"].header_and_shortids.header.sha256)\n+\n+    def on_headers(self, message):\n+        self.block_announced = True\n+        for x in self.last_message[\"headers\"].headers:\n+            x.calc_sha256()\n+            self.announced_blockhashes.add(x.sha256)\n+\n+    def on_inv(self, message):\n+        for x in self.last_message[\"inv\"].inv:\n+            if x.type == MSG_BLOCK:\n+                self.block_announced = True\n+                self.announced_blockhashes.add(x.hash)\n+\n+    # Requires caller to hold p2p_lock\n+    def received_block_announcement(self):\n+        return self.block_announced\n+\n+    def clear_block_announcement(self):\n+        with p2p_lock:\n+            self.block_announced = False\n+            self.last_message.pop(\"inv\", None)\n+            self.last_message.pop(\"headers\", None)\n+            self.last_message.pop(\"cmpctblock\", None)\n+\n+    def clear_getblocktxn(self):\n+        with p2p_lock:\n+            self.last_message.pop(\"getblocktxn\", None)\n+\n+\n+class CompactBlocksBlockReconstructionLimitTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+        self.extra_args = [[\n+            \"-acceptnonstdtxn=0\",\n+            \"-debug=net\",\n+        ]]\n+        self.utxos = []\n+\n+    def build_block_on_tip(self, node):\n+        \"\"\"Build a block on top of the current tip.\"\"\"\n+        block = create_block(tmpl=node.getblocktemplate(NORMAL_GBT_REQUEST_PARAMS))\n+        block.solve()\n+        return block\n+\n+    def make_utxos(self):\n+        \"\"\"Generate blocks to create UTXOs for the wallet.\"\"\"\n+        self.generate(self.wallet, COINBASE_MATURITY + 800)\n+\n+    def restart_node_with_limit(self, count=None):\n+        \"\"\"Restart node with specific count limit.\"\"\"\n+        extra_args = [\"-acceptnonstdtxn=0\", \"-debug=net\"]\n+\n+        if count is not None:\n+            self.log.info(f\"Setting transaction count limit: {count}\")\n+            extra_args.append(f\"-blockreconstructionextratxn={count}\")\n+\n+        self.log.info(f\"Restarting node with args: {extra_args}\")\n+        self.restart_node(0, extra_args=extra_args)\n+        self.segwit_node = self.nodes[0].add_p2p_connection(TestP2PConn())\n+        self.segwit_node.send_and_ping(msg_sendcmpct(announce=True, version=2))\n+\n+    def create_policy_rejected_tx(self, rejection_type=\"dust\"):\n+        \"\"\"Create a transaction that will be rejected for policy reasons but added to extra pool.\"\"\"\n+\n+        if rejection_type == \"dust\":\n+            tx_info = self.wallet.create_self_transfer()\n+            dust_amount = 100\n+            dust_script = CScript([OP_TRUE])\n+            tx_info['tx'].vout.append(CTxOut(dust_amount, dust_script))\n+            tx_info['tx'].vout[0].nValue -= dust_amount\n+\n+        elif rejection_type == \"low_fee\":\n+            tx_info = self.wallet.create_self_transfer(fee_rate=Decimal('0.00000100'))\n+\n+        elif rejection_type == \"nonstandard_script\":\n+            tx_info = self.wallet.create_self_transfer()\n+            pubkeys = []\n+            for _ in range(4):\n+                pubkeys.append(bytes([0x02] + [0x00] * 32))\n+            multisig_script = keys_to_multisig_script(pubkeys, k=4)\n+            tx_info['tx'].vout.append(CTxOut(10000, multisig_script))\n+            tx_info['tx'].vout[0].nValue -= 10000\n+\n+        else:\n+            raise ValueError(f\"Unknown rejection type: {rejection_type}\")\n+\n+        tx_info['hex'] = tx_info['tx'].serialize().hex()\n+        return tx_info\n+\n+    def populate_extra_pool(self, num_txs, rejection_type=\"dust\"):\n+        \"\"\"Populate the extra transaction pool using policy-rejected transactions.\"\"\"\n+        rejected_txs = []\n+\n+        for i in range(num_txs):\n+            tx_info = self.create_policy_rejected_tx(rejection_type)\n+            tx_obj = tx_from_hex(tx_info['hex'])\n+            self.segwit_node.send_without_ping(msg_tx(tx_obj))\n+            rejected_txs.append(tx_info)\n+\n+        self.segwit_node.sync_with_ping()\n+\n+        return rejected_txs\n+\n+    def send_compact_block(self, transactions, indices):\n+        \"\"\"Send a compact block and check which transactions are requested for reconstruction.\"\"\"\n+        node = self.nodes[0]\n+\n+        # Build block\n+        block = self.build_block_on_tip(node)\n+\n+        for i in indices:\n+            tx_obj = tx_from_hex(transactions[i]['hex'])\n+            block.vtx.append(tx_obj)\n+\n+        # Add witness commitment for blocks with witness transactions\n+        add_witness_commitment(block)\n+        block.solve()\n+\n+        # Send as compact block\n+        cmpct_block = HeaderAndShortIDs()\n+        cmpct_block.initialize_from_block(block, use_witness=True)\n+        self.segwit_node.send_and_ping(msg_cmpctblock(cmpct_block.to_p2p()))\n+\n+        # Check if node requested missing transactions\n+        with p2p_lock:\n+            getblocktxn = self.segwit_node.last_message.get(\"getblocktxn\")\n+\n+        num_tx_requested = len(getblocktxn.block_txn_request.indexes) if getblocktxn else 0\n+        self.segwit_node.clear_getblocktxn()\n+\n+        # Convert differential encoding to absolute indices (from BlockTransactionRequest)\n+        missing_indices = []\n+        if getblocktxn:\n+            absolute_block_indices = getblocktxn.block_txn_request.to_absolute()\n+            # Convert from block positions to transaction indices (subtract 1 for coinbase)\n+            missing_indices = [idx - 1 for idx in absolute_block_indices]\n+\n+        return {\n+            \"block\": block,\n+            \"getblocktxn\": getblocktxn,\n+            \"num_tx_requested\": num_tx_requested,\n+            \"missing_indices\": missing_indices\n+        }\n+\n+    # TEST: policy-rejected transactions\n+\n+    def test_policy_rejection_types(self):\n+        \"\"\"Test that each policy rejection type adds transactions to extra pool.\"\"\"\n+        self.log.info(\"Testing policy rejection types for extra pool...\")\n+\n+        self.restart_node(0, extra_args=[\n+            \"-debug=net\",\n+            \"-blockreconstructionextratxn=100\"\n+        ])\n+\n+        self.segwit_node = self.nodes[0].add_p2p_connection(TestP2PConn())\n+        self.segwit_node.send_and_ping(msg_sendcmpct(announce=True, version=2))\n+\n+        rejection_types = [\"dust\", \"low_fee\", \"nonstandard_script\"]\n+        rejected_txs = []\n+\n+        for rejection_type in rejection_types:\n+            self.log.info(f\"Testing {rejection_type} rejection...\")\n+            tx_info = self.create_policy_rejected_tx(rejection_type)\n+\n+            tx_obj = tx_from_hex(tx_info['hex'])\n+            self.segwit_node.send_without_ping(msg_tx(tx_obj))\n+\n+            rejected_txs.append({\n+                'type': rejection_type,\n+                'tx_info': tx_info,\n+                'txid': tx_info['tx'].txid_hex\n+            })\n+\n+        self.segwit_node.sync_with_ping()\n+\n+        mempool = self.nodes[0].getrawmempool()\n+        for rejected in rejected_txs:\n+            assert_equal(rejected['txid'] in mempool, False)\n+            self.log.info(f\"âœ“ {rejected['type']} transaction rejected from mempool\")\n+\n+        indices = list(range(len(rejected_txs)))\n+        tx_list = [r['tx_info'] for r in rejected_txs]\n+\n+        result = self.send_compact_block(tx_list, indices)\n+\n+        assert_equal(result[\"missing_indices\"], [])\n+        self.log.info(\"âœ“ All rejected transactions are available in extra pool\")\n+\n+    # TEST: blockreconstructionextratxn\n+\n+    def test_extratxnpool_disabled(self):\n+        \"\"\"Test that setting count to 0 disables the extra transaction pool.\"\"\"\n+        self.log.info(\"Testing disabled extra transaction pool (0 capacity)...\")\n+\n+        self.restart_node_with_limit(count=0)\n+        buffersize = 5\n+        rejected_txs = self.populate_extra_pool(buffersize)\n+\n+        indices = list(range(buffersize))\n+        result = self.send_compact_block(rejected_txs, indices)\n+        assert_equal(result[\"missing_indices\"], indices)\n+        self.log.info(f\"âœ“ All {buffersize} transactions are missing (extra txn pool disabled)\")\n+\n+    def test_extratxnpool_capacity(self):\n+        \"\"\"Test extra transaction pool capacity transactions.\"\"\"\n+        self.log.info(\"Testing extra transaction pool capacity (50 transactions)...\")\n+\n+        buffersize = 50\n+        self.restart_node_with_limit(count=buffersize)\n+\n+        rejected_txs = self.populate_extra_pool(buffersize)\n+\n+        indices = list(range(buffersize))\n+        result = self.send_compact_block(rejected_txs, indices)\n+\n+        assert_equal(result[\"missing_indices\"], [])\n+        self.log.info(\"âœ“ All rejected transactions are in the extra txn pool\")\n+\n+        # Test that adding a 51st transaction causes eviction\n+        self.log.info(\"Adding transaction to test eviction...\")\n+        self.populate_extra_pool(1)\n+\n+        # Check original transactions again - first one should be evicted\n+        result2 = self.send_compact_block(rejected_txs, indices)\n+        assert_equal(result2[\"missing_indices\"], [0])\n+        self.log.info(\"âœ“ Transaction 0 was evicted as expected\")\n+\n+    def test_single_extratxnpool_capacity(self):\n+        \"\"\"Test edge case of single capacity extra transaction pool.\"\"\"\n+        self.log.info(\"Testing single capacity extra transaction pool...\")\n+\n+        self.restart_node_with_limit(count=1)\n+        tx_count = 5\n+\n+        rejected_txs = self.populate_extra_pool(tx_count)\n+\n+        indices = list(range(tx_count))\n+        result = self.send_compact_block(rejected_txs, indices)\n+\n+        expected_missing = list(range(4))\n+        assert_equal(result[\"missing_indices\"], expected_missing)\n+\n+    def test_extratxn_large_capacity(self):\n+        \"\"\"Test extra transaction pool with very large count parameter.\"\"\"\n+        self.log.info(\"Testing with count=400 to ensure large buffers work correctly...\")\n+\n+        buffersize = 400\n+        self.restart_node_with_limit(count=buffersize)\n+\n+        rejected_txs = self.populate_extra_pool(buffersize)\n+\n+        indices = list(range(buffersize))\n+        result = self.send_compact_block(rejected_txs, indices)\n+\n+        assert_equal(result[\"missing_indices\"], [])\n+        self.log.info(\"âœ“ All rejected transactions are in the extra txn pool\")\n+\n+        # Test that adding a transaction causes eviction\n+        self.log.info(\"Adding another transaction to test eviction...\")\n+        self.populate_extra_pool(1)\n+\n+        # Check original transactions again - first one should be evicted\n+        result2 = self.send_compact_block(rejected_txs, indices)\n+        assert_equal(result2[\"missing_indices\"], [0])\n+        self.log.info(\"âœ“ Transaction 0 was evicted as expected\")\n+\n+    def test_extratxn_buffer_wraparound(self):\n+        \"\"\"Test that adding transactions to a full buffer evicts oldest slots.\"\"\"\n+        self.log.info(\"Testing extratxn buffer wraparound - fill buffer then add more...\")\n+\n+        buffersize = 20\n+\n+        new_tx_count = 17\n+        self.restart_node_with_limit(count=buffersize)\n+\n+        # Step 1: Fill the buffer with rejected transactions\n+        rejected_txs = self.populate_extra_pool(buffersize)\n+\n+        # Verify all rejected transactions are in the extra pool\n+        indices = list(range(buffersize))\n+        result = self.send_compact_block(rejected_txs, indices)\n+        assert_equal(result[\"missing_indices\"], [])\n+        self.log.info(\"âœ“ All rejected transactions are in the extra pool\")\n+\n+        # Step 2: Add more rejected transactions\n+        self.log.info(f\"Step 2: Adding {new_tx_count} more rejected transactions (should wrap and evict slots 0-{new_tx_count-1})\")\n+        self.populate_extra_pool(new_tx_count)\n+\n+        result2 = self.send_compact_block(rejected_txs, indices)\n+\n+        # Verify wraparound worked correctly - first new_tx_count should be evicted\n+        expected_missing = list(range(new_tx_count))\n+        assert_equal(result2['missing_indices'], expected_missing)\n+        self.log.info(f\"âœ“ Wraparound worked correctly! Transactions {expected_missing} were evicted as expected\")\n+\n+    def test_extratxn_minimal_capacity_eviction(self):\n+        \"\"\"Test frequent eviction with minimal capacity.\"\"\"\n+        self.log.info(\"Testing minimal capacity eviction with count=2...\")\n+\n+        self.restart_node_with_limit(count=2)\n+\n+        # Add 10 rejected transactions to stress eviction\n+        num_txs = 10\n+        rejected_txs = self.populate_extra_pool(num_txs)\n+\n+        # Only the last 2 should remain\n+        # Try to reconstruct with all 10\n+        indices = list(range(num_txs))\n+        result = self.send_compact_block(rejected_txs, indices)\n+\n+        # First 8 should be missing (evicted)\n+        expected_missing = list(range(8))\n+        assert_equal(result[\"missing_indices\"], expected_missing)\n+\n+    def test_extratxn_invalid_parameters(self):\n+        \"\"\"Test handling of invalid blockreconstructionextratxn values.\"\"\"\n+        self.log.info(\"Testing invalid parameter values...\")\n+\n+        # Test negative value - should be clamped to 0 (disabled)\n+        self.log.info(\"Testing negative value (-1)...\")\n+        self.restart_node_with_limit(count=-1)\n+\n+        # Add a transaction and verify pool is disabled\n+        rejected_txs = self.populate_extra_pool(1)\n+        result = self.send_compact_block(rejected_txs, [0])\n+        assert_equal(result[\"missing_indices\"], [0])\n+\n+        # Test extremely large value\n+        self.log.info(\"Testing large value (100000)...\")\n+        self.restart_node_with_limit(count=100000)  # Very large but reasonable\n+\n+        # Add some transactions - should work but be clamped\n+        rejected_txs = self.populate_extra_pool(10)\n+        result = self.send_compact_block(rejected_txs, list(range(10)))\n+        assert_equal(result[\"missing_indices\"], [])\n+\n+\n+    def run_test(self):\n+        self.wallet = MiniWallet(self.nodes[0])\n+\n+        # Setup the p2p connection\n+        self.segwit_node = self.nodes[0].add_p2p_connection(TestP2PConn())\n+\n+        # Create UTXOs for testing\n+        self.make_utxos()\n+\n+        # Ensure segwit is active\n+        assert softfork_active(self.nodes[0], \"segwit\")\n+\n+       # Test policy rejection types first",
      "path": "test/functional/p2p_compactblocks_extratxs.py",
      "position": 1,
      "original_position": 411,
      "commit_id": "f9c6331cb26f3bafc3dba7f5a72622a9ff4f190d",
      "original_commit_id": "4985235dd29de317f42edf1709606fa5663e2074",
      "in_reply_to_id": 2241039496,
      "user": {
        "login": "bigshiny90",
        "id": 23282055,
        "node_id": "MDQ6VXNlcjIzMjgyMDU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23282055?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigshiny90",
        "html_url": "https://github.com/bigshiny90",
        "followers_url": "https://api.github.com/users/bigshiny90/followers",
        "following_url": "https://api.github.com/users/bigshiny90/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigshiny90/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigshiny90/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigshiny90/subscriptions",
        "organizations_url": "https://api.github.com/users/bigshiny90/orgs",
        "repos_url": "https://api.github.com/users/bigshiny90/repos",
        "events_url": "https://api.github.com/users/bigshiny90/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigshiny90/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "fixed. Thanks!",
      "created_at": "2025-07-29T22:05:14Z",
      "updated_at": "2025-07-29T22:05:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33023#discussion_r2241107374",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2241107374"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33023"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 411,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2299227722",
      "pull_request_review_id": 3153147837,
      "id": 2299227722,
      "node_id": "PRRC_kwDOABII586JC25K",
      "diff_hunk": "@@ -0,0 +1,422 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2025 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test blockreconstructionextratxn option with compact blocks.\"\"\"\n+\n+from test_framework.blocktools import (\n+    COINBASE_MATURITY,\n+    NORMAL_GBT_REQUEST_PARAMS,\n+    create_block,\n+    add_witness_commitment,\n+)\n+from test_framework.messages import (\n+    CTxOut,\n+    HeaderAndShortIDs,\n+    MSG_BLOCK,\n+    msg_cmpctblock,\n+    msg_sendcmpct,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+    p2p_lock,\n+)\n+from test_framework.script import (\n+    CScript,\n+    OP_TRUE,\n+)\n+from test_framework.script_util import (\n+    keys_to_multisig_script,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    softfork_active,\n+)\n+from decimal import Decimal\n+from test_framework.wallet import MiniWallet\n+\n+\n+# TestP2PConn: A peer we use to send messages to bitcoind, and store responses.\n+class TestP2PConn(P2PInterface):\n+    def __init__(self):\n+        super().__init__()\n+        self.last_sendcmpct = []\n+        self.block_announced = False\n+        # Store the hashes of blocks we've seen announced.\n+        # This is for synchronizing the p2p message traffic,\n+        # so we can eg wait until a particular block is announced.\n+        self.announced_blockhashes = set()\n+\n+    def on_sendcmpct(self, message):\n+        self.last_sendcmpct.append(message)\n+\n+    def on_cmpctblock(self, message):\n+        self.block_announced = True\n+        self.last_message[\"cmpctblock\"].header_and_shortids.header.calc_sha256()\n+        self.announced_blockhashes.add(self.last_message[\"cmpctblock\"].header_and_shortids.header.sha256)\n+\n+    def on_headers(self, message):\n+        self.block_announced = True\n+        for x in self.last_message[\"headers\"].headers:\n+            x.calc_sha256()\n+            self.announced_blockhashes.add(x.sha256)\n+\n+    def on_inv(self, message):\n+        for x in self.last_message[\"inv\"].inv:\n+            if x.type == MSG_BLOCK:\n+                self.block_announced = True\n+                self.announced_blockhashes.add(x.hash)\n+\n+    # Requires caller to hold p2p_lock\n+    def received_block_announcement(self):\n+        return self.block_announced\n+\n+    def clear_block_announcement(self):\n+        with p2p_lock:\n+            self.block_announced = False\n+            self.last_message.pop(\"inv\", None)\n+            self.last_message.pop(\"headers\", None)\n+            self.last_message.pop(\"cmpctblock\", None)\n+\n+    def clear_getblocktxn(self):\n+        with p2p_lock:\n+            self.last_message.pop(\"getblocktxn\", None)\n+\n+\n+class CompactBlocksBlockReconstructionLimitTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+        self.extra_args = [[\n+            \"-acceptnonstdtxn=0\",\n+            \"-debug=net\",\n+        ]]\n+        self.utxos = []\n+\n+    def build_block_on_tip(self, node):\n+        \"\"\"Build a block on top of the current tip.\"\"\"\n+        block = create_block(tmpl=node.getblocktemplate(NORMAL_GBT_REQUEST_PARAMS))\n+        block.solve()\n+        return block\n+\n+    def make_utxos(self):\n+        \"\"\"Generate blocks to create UTXOs for the wallet.\"\"\"\n+        self.generate(self.wallet, COINBASE_MATURITY + 800)\n+\n+    def restart_node_with_limit(self, count=None):\n+        \"\"\"Restart node with specific count limit.\"\"\"\n+        extra_args = [\"-acceptnonstdtxn=0\", \"-debug=net\"]\n+\n+        if count is not None:\n+            self.log.info(f\"Setting transaction count limit: {count}\")\n+            extra_args.append(f\"-blockreconstructionextratxn={count}\")\n+\n+        self.log.info(f\"Restarting node with args: {extra_args}\")\n+        self.restart_node(0, extra_args=extra_args)\n+        self.segwit_node = self.nodes[0].add_p2p_connection(TestP2PConn())\n+        self.segwit_node.send_and_ping(msg_sendcmpct(announce=True, version=2))\n+\n+    def create_policy_rejected_tx(self, rejection_type=\"dust\"):\n+        \"\"\"Create a transaction that will be rejected for policy reasons but added to extra pool.\"\"\"\n+\n+        if rejection_type == \"dust\":\n+            tx_info = self.wallet.create_self_transfer()\n+            dust_amount = 100\n+            dust_script = CScript([OP_TRUE])\n+            tx_info['tx'].vout.append(CTxOut(dust_amount, dust_script))\n+            tx_info['tx'].vout[0].nValue -= dust_amount\n+\n+        elif rejection_type == \"low_fee\":\n+            tx_info = self.wallet.create_self_transfer(fee_rate=Decimal('0.00000100'))\n+\n+        elif rejection_type == \"nonstandard_script\":\n+            tx_info = self.wallet.create_self_transfer()\n+            pubkeys = []\n+            for _ in range(4):\n+                pubkeys.append(bytes([0x02] + [0x00] * 32))\n+            multisig_script = keys_to_multisig_script(pubkeys, k=4)\n+            tx_info['tx'].vout.append(CTxOut(10000, multisig_script))\n+            tx_info['tx'].vout[0].nValue -= 10000\n+\n+        else:\n+            raise ValueError(f\"Unknown rejection type: {rejection_type}\")\n+\n+        tx_info['hex'] = tx_info['tx'].serialize().hex()\n+        return tx_info\n+\n+    def populate_extra_pool(self, num_txs, rejection_type=\"dust\"):\n+        \"\"\"Populate the extra transaction pool using policy-rejected transactions.\"\"\"\n+        rejected_txs = []\n+\n+        for i in range(num_txs):\n+            tx_info = self.create_policy_rejected_tx(rejection_type)\n+            tx_obj = tx_from_hex(tx_info['hex'])\n+            self.segwit_node.send_without_ping(msg_tx(tx_obj))\n+            rejected_txs.append(tx_info)\n+\n+        self.segwit_node.sync_with_ping()\n+\n+        return rejected_txs\n+\n+    def send_compact_block(self, transactions, indices):\n+        \"\"\"Send a compact block and check which transactions are requested for reconstruction.\"\"\"\n+        node = self.nodes[0]\n+\n+        # Build block\n+        block = self.build_block_on_tip(node)\n+\n+        for i in indices:\n+            tx_obj = tx_from_hex(transactions[i]['hex'])\n+            block.vtx.append(tx_obj)\n+\n+        # Add witness commitment for blocks with witness transactions\n+        add_witness_commitment(block)\n+        block.solve()\n+\n+        # Send as compact block\n+        cmpct_block = HeaderAndShortIDs()\n+        cmpct_block.initialize_from_block(block, use_witness=True)\n+        self.segwit_node.send_and_ping(msg_cmpctblock(cmpct_block.to_p2p()))\n+\n+        # Check if node requested missing transactions\n+        with p2p_lock:\n+            getblocktxn = self.segwit_node.last_message.get(\"getblocktxn\")\n+\n+        num_tx_requested = len(getblocktxn.block_txn_request.indexes) if getblocktxn else 0\n+        self.segwit_node.clear_getblocktxn()\n+\n+        # Convert differential encoding to absolute indices (from BlockTransactionRequest)\n+        missing_indices = []\n+        if getblocktxn:\n+            absolute_block_indices = getblocktxn.block_txn_request.to_absolute()\n+            # Convert from block positions to transaction indices (subtract 1 for coinbase)\n+            missing_indices = [idx - 1 for idx in absolute_block_indices]\n+\n+        return {\n+            \"block\": block,\n+            \"getblocktxn\": getblocktxn,\n+            \"num_tx_requested\": num_tx_requested,\n+            \"missing_indices\": missing_indices\n+        }\n+\n+    # TEST: policy-rejected transactions\n+\n+    def test_policy_rejection_types(self):\n+        \"\"\"Test that each policy rejection type adds transactions to extra pool.\"\"\"\n+        self.log.info(\"Testing policy rejection types for extra pool...\")\n+\n+        self.restart_node_with_limit(count=100)\n+\n+        rejection_types = [\"dust\", \"low_fee\", \"nonstandard_script\"]\n+        rejected_txs = []\n+\n+        for rejection_type in rejection_types:\n+            self.log.info(f\"Testing {rejection_type} rejection...\")\n+            tx_info = self.create_policy_rejected_tx(rejection_type)\n+\n+            tx_obj = tx_from_hex(tx_info['hex'])\n+            self.segwit_node.send_without_ping(msg_tx(tx_obj))\n+\n+            rejected_txs.append({\n+                'type': rejection_type,\n+                'tx_info': tx_info,\n+                'txid': tx_info['tx'].txid_hex\n+            })\n+\n+        self.segwit_node.sync_with_ping()\n+\n+        mempool = self.nodes[0].getrawmempool()\n+        for rejected in rejected_txs:\n+            assert_equal(rejected['txid'] in mempool, False)\n+            self.log.info(f\"âœ“ {rejected['type']} transaction rejected from mempool\")\n+\n+        indices = list(range(len(rejected_txs)))\n+        tx_list = [r['tx_info'] for r in rejected_txs]\n+\n+        result = self.send_compact_block(tx_list, indices)\n+\n+        assert_equal(result[\"missing_indices\"], [])\n+        self.log.info(\"âœ“ All rejected transactions are available in extra pool\")\n+\n+    # TEST: blockreconstructionextratxn\n+\n+    def test_extratxnpool_disabled(self):\n+        \"\"\"Test that setting count to 0 disables the extra transaction pool.\"\"\"\n+        self.log.info(\"Testing disabled extra transaction pool (0 capacity)...\")\n+\n+        self.restart_node_with_limit(count=0)\n+        buffersize = 5\n+        rejected_txs = self.populate_extra_pool(buffersize)\n+\n+        indices = list(range(buffersize))\n+        result = self.send_compact_block(rejected_txs, indices)\n+        assert_equal(result[\"missing_indices\"], indices)\n+        self.log.info(f\"âœ“ All {buffersize} transactions are missing (extra txn pool disabled)\")\n+\n+    def test_extratxnpool_capacity(self):\n+        \"\"\"Test extra transaction pool capacity transactions.\"\"\"\n+        self.log.info(\"Testing extra transaction pool capacity (50 transactions)...\")\n+\n+        buffersize = 50\n+        self.restart_node_with_limit(count=buffersize)\n+\n+        rejected_txs = self.populate_extra_pool(buffersize)\n+\n+        indices = list(range(buffersize))\n+        result = self.send_compact_block(rejected_txs, indices)\n+\n+        assert_equal(result[\"missing_indices\"], [])\n+        self.log.info(\"âœ“ All rejected transactions are in the extra txn pool\")\n+\n+        # Test that adding a 51st transaction causes eviction\n+        self.log.info(\"Adding transaction to test eviction...\")\n+        self.populate_extra_pool(1)\n+\n+        # Check original transactions again - first one should be evicted\n+        result2 = self.send_compact_block(rejected_txs, indices)\n+        assert_equal(result2[\"missing_indices\"], [0])\n+        self.log.info(\"âœ“ Transaction 0 was evicted as expected\")\n+\n+    def test_single_extratxnpool_capacity(self):\n+        \"\"\"Test edge case of single capacity extra transaction pool.\"\"\"\n+        self.log.info(\"Testing single capacity extra transaction pool...\")\n+\n+        self.restart_node_with_limit(count=1)\n+        tx_count = 5\n+\n+        rejected_txs = self.populate_extra_pool(tx_count)\n+\n+        indices = list(range(tx_count))\n+        result = self.send_compact_block(rejected_txs, indices)\n+\n+        expected_missing = list(range(4))\n+        assert_equal(result[\"missing_indices\"], expected_missing)\n+\n+    def test_extratxn_large_capacity(self):\n+        \"\"\"Test extra transaction pool with very large count parameter.\"\"\"\n+        self.log.info(\"Testing with count=400 to ensure large buffers work correctly...\")\n+\n+        buffersize = 400\n+        self.restart_node_with_limit(count=buffersize)\n+\n+        rejected_txs = self.populate_extra_pool(buffersize)\n+\n+        indices = list(range(buffersize))\n+        result = self.send_compact_block(rejected_txs, indices)\n+\n+        assert_equal(result[\"missing_indices\"], [])\n+        self.log.info(\"âœ“ All rejected transactions are in the extra txn pool\")\n+\n+        # Test that adding a transaction causes eviction\n+        self.log.info(\"Adding another transaction to test eviction...\")\n+        self.populate_extra_pool(1)\n+\n+        # Check original transactions again - first one should be evicted\n+        result2 = self.send_compact_block(rejected_txs, indices)\n+        assert_equal(result2[\"missing_indices\"], [0])\n+        self.log.info(\"âœ“ Transaction 0 was evicted as expected\")\n+\n+    def test_extratxn_buffer_wraparound(self):\n+        \"\"\"Test that adding transactions to a full buffer evicts oldest slots.\"\"\"\n+        self.log.info(\"Testing extratxn buffer wraparound - fill buffer then add more...\")\n+\n+        buffersize = 20\n+\n+        new_tx_count = 17\n+        self.restart_node_with_limit(count=buffersize)\n+\n+        # Step 1: Fill the buffer with rejected transactions\n+        rejected_txs = self.populate_extra_pool(buffersize)\n+\n+        # Verify all rejected transactions are in the extra pool\n+        indices = list(range(buffersize))\n+        result = self.send_compact_block(rejected_txs, indices)\n+        assert_equal(result[\"missing_indices\"], [])\n+        self.log.info(\"âœ“ All rejected transactions are in the extra pool\")\n+\n+        # Step 2: Add more rejected transactions\n+        self.log.info(f\"Step 2: Adding {new_tx_count} more rejected transactions (should wrap and evict slots 0-{new_tx_count-1})\")\n+        self.populate_extra_pool(new_tx_count)\n+\n+        result2 = self.send_compact_block(rejected_txs, indices)\n+\n+        # Verify wraparound worked correctly - first new_tx_count should be evicted\n+        expected_missing = list(range(new_tx_count))\n+        assert_equal(result2['missing_indices'], expected_missing)\n+        self.log.info(f\"âœ“ Wraparound worked correctly! Transactions {expected_missing} were evicted as expected\")\n+\n+    def test_extratxn_minimal_capacity_eviction(self):\n+        \"\"\"Test frequent eviction with minimal capacity.\"\"\"\n+        self.log.info(\"Testing minimal capacity eviction with count=2...\")\n+\n+        self.restart_node_with_limit(count=2)\n+\n+        # Add 10 rejected transactions to stress eviction\n+        num_txs = 10\n+        rejected_txs = self.populate_extra_pool(num_txs)\n+\n+        # Only the last 2 should remain\n+        # Try to reconstruct with all 10\n+        indices = list(range(num_txs))\n+        result = self.send_compact_block(rejected_txs, indices)\n+\n+        # First 8 should be missing (evicted)\n+        expected_missing = list(range(8))\n+        assert_equal(result[\"missing_indices\"], expected_missing)\n+\n+    def test_extratxn_invalid_parameters(self):\n+        \"\"\"Test handling of invalid blockreconstructionextratxn values.\"\"\"\n+        self.log.info(\"Testing invalid parameter values...\")\n+\n+        # Test negative value - should be clamped to 0 (disabled)\n+        self.log.info(\"Testing negative value (-1)...\")\n+        self.restart_node_with_limit(count=-1)\n+\n+        # Add a transaction and verify pool is disabled\n+        rejected_txs = self.populate_extra_pool(1)\n+        result = self.send_compact_block(rejected_txs, [0])\n+        assert_equal(result[\"missing_indices\"], [0])\n+\n+        # Test extremely large value\n+        self.log.info(\"Testing large value (100000)...\")\n+        self.restart_node_with_limit(count=100000)  # Very large but reasonable\n+\n+        # Add some transactions - should work but be clamped\n+        rejected_txs = self.populate_extra_pool(10)\n+        result = self.send_compact_block(rejected_txs, list(range(10)))\n+        assert_equal(result[\"missing_indices\"], [])",
      "path": "test/functional/p2p_compactblocks_extratxs.py",
      "position": 1,
      "original_position": 390,
      "commit_id": "f9c6331cb26f3bafc3dba7f5a72622a9ff4f190d",
      "original_commit_id": "bd1c6b4ea9b94ab4b2604f2a4b8a7fd1fe55c92a",
      "in_reply_to_id": null,
      "user": {
        "login": "kevkevinpal",
        "id": 15950706,
        "node_id": "MDQ6VXNlcjE1OTUwNzA2",
        "avatar_url": "https://avatars.githubusercontent.com/u/15950706?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kevkevinpal",
        "html_url": "https://github.com/kevkevinpal",
        "followers_url": "https://api.github.com/users/kevkevinpal/followers",
        "following_url": "https://api.github.com/users/kevkevinpal/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kevkevinpal/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kevkevinpal/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kevkevinpal/subscriptions",
        "organizations_url": "https://api.github.com/users/kevkevinpal/orgs",
        "repos_url": "https://api.github.com/users/kevkevinpal/repos",
        "events_url": "https://api.github.com/users/kevkevinpal/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kevkevinpal/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "This seems misplaced for this test `test_extratxn_invalid_parameters`",
      "created_at": "2025-08-25T21:55:36Z",
      "updated_at": "2025-08-25T22:09:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33023#discussion_r2299227722",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2299227722"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33023"
        }
      },
      "start_line": null,
      "original_start_line": 383,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 390,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2299231394",
      "pull_request_review_id": 3153147837,
      "id": 2299231394,
      "node_id": "PRRC_kwDOABII586JC3yi",
      "diff_hunk": "@@ -0,0 +1,422 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2025 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test blockreconstructionextratxn option with compact blocks.\"\"\"\n+\n+from test_framework.blocktools import (\n+    COINBASE_MATURITY,\n+    NORMAL_GBT_REQUEST_PARAMS,\n+    create_block,\n+    add_witness_commitment,\n+)\n+from test_framework.messages import (\n+    CTxOut,\n+    HeaderAndShortIDs,\n+    MSG_BLOCK,\n+    msg_cmpctblock,\n+    msg_sendcmpct,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+    p2p_lock,\n+)\n+from test_framework.script import (\n+    CScript,\n+    OP_TRUE,\n+)\n+from test_framework.script_util import (\n+    keys_to_multisig_script,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    softfork_active,\n+)\n+from decimal import Decimal\n+from test_framework.wallet import MiniWallet\n+\n+\n+# TestP2PConn: A peer we use to send messages to bitcoind, and store responses.\n+class TestP2PConn(P2PInterface):\n+    def __init__(self):\n+        super().__init__()\n+        self.last_sendcmpct = []\n+        self.block_announced = False\n+        # Store the hashes of blocks we've seen announced.\n+        # This is for synchronizing the p2p message traffic,\n+        # so we can eg wait until a particular block is announced.\n+        self.announced_blockhashes = set()\n+\n+    def on_sendcmpct(self, message):\n+        self.last_sendcmpct.append(message)\n+\n+    def on_cmpctblock(self, message):\n+        self.block_announced = True\n+        self.last_message[\"cmpctblock\"].header_and_shortids.header.calc_sha256()\n+        self.announced_blockhashes.add(self.last_message[\"cmpctblock\"].header_and_shortids.header.sha256)\n+\n+    def on_headers(self, message):\n+        self.block_announced = True\n+        for x in self.last_message[\"headers\"].headers:\n+            x.calc_sha256()\n+            self.announced_blockhashes.add(x.sha256)\n+\n+    def on_inv(self, message):\n+        for x in self.last_message[\"inv\"].inv:\n+            if x.type == MSG_BLOCK:\n+                self.block_announced = True\n+                self.announced_blockhashes.add(x.hash)\n+\n+    # Requires caller to hold p2p_lock\n+    def received_block_announcement(self):\n+        return self.block_announced\n+\n+    def clear_block_announcement(self):\n+        with p2p_lock:\n+            self.block_announced = False\n+            self.last_message.pop(\"inv\", None)\n+            self.last_message.pop(\"headers\", None)\n+            self.last_message.pop(\"cmpctblock\", None)\n+\n+    def clear_getblocktxn(self):\n+        with p2p_lock:\n+            self.last_message.pop(\"getblocktxn\", None)\n+\n+\n+class CompactBlocksBlockReconstructionLimitTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+        self.extra_args = [[\n+            \"-acceptnonstdtxn=0\",\n+            \"-debug=net\",\n+        ]]\n+        self.utxos = []\n+\n+    def build_block_on_tip(self, node):\n+        \"\"\"Build a block on top of the current tip.\"\"\"\n+        block = create_block(tmpl=node.getblocktemplate(NORMAL_GBT_REQUEST_PARAMS))\n+        block.solve()\n+        return block\n+\n+    def make_utxos(self):\n+        \"\"\"Generate blocks to create UTXOs for the wallet.\"\"\"\n+        self.generate(self.wallet, COINBASE_MATURITY + 800)\n+\n+    def restart_node_with_limit(self, count=None):\n+        \"\"\"Restart node with specific count limit.\"\"\"\n+        extra_args = [\"-acceptnonstdtxn=0\", \"-debug=net\"]\n+\n+        if count is not None:\n+            self.log.info(f\"Setting transaction count limit: {count}\")\n+            extra_args.append(f\"-blockreconstructionextratxn={count}\")\n+\n+        self.log.info(f\"Restarting node with args: {extra_args}\")\n+        self.restart_node(0, extra_args=extra_args)\n+        self.segwit_node = self.nodes[0].add_p2p_connection(TestP2PConn())\n+        self.segwit_node.send_and_ping(msg_sendcmpct(announce=True, version=2))\n+\n+    def create_policy_rejected_tx(self, rejection_type=\"dust\"):\n+        \"\"\"Create a transaction that will be rejected for policy reasons but added to extra pool.\"\"\"\n+\n+        if rejection_type == \"dust\":\n+            tx_info = self.wallet.create_self_transfer()\n+            dust_amount = 100\n+            dust_script = CScript([OP_TRUE])\n+            tx_info['tx'].vout.append(CTxOut(dust_amount, dust_script))\n+            tx_info['tx'].vout[0].nValue -= dust_amount\n+\n+        elif rejection_type == \"low_fee\":\n+            tx_info = self.wallet.create_self_transfer(fee_rate=Decimal('0.00000100'))\n+\n+        elif rejection_type == \"nonstandard_script\":\n+            tx_info = self.wallet.create_self_transfer()\n+            pubkeys = []\n+            for _ in range(4):\n+                pubkeys.append(bytes([0x02] + [0x00] * 32))\n+            multisig_script = keys_to_multisig_script(pubkeys, k=4)\n+            tx_info['tx'].vout.append(CTxOut(10000, multisig_script))\n+            tx_info['tx'].vout[0].nValue -= 10000\n+\n+        else:\n+            raise ValueError(f\"Unknown rejection type: {rejection_type}\")\n+\n+        tx_info['hex'] = tx_info['tx'].serialize().hex()\n+        return tx_info\n+\n+    def populate_extra_pool(self, num_txs, rejection_type=\"dust\"):\n+        \"\"\"Populate the extra transaction pool using policy-rejected transactions.\"\"\"\n+        rejected_txs = []\n+\n+        for i in range(num_txs):\n+            tx_info = self.create_policy_rejected_tx(rejection_type)\n+            tx_obj = tx_from_hex(tx_info['hex'])\n+            self.segwit_node.send_without_ping(msg_tx(tx_obj))\n+            rejected_txs.append(tx_info)\n+\n+        self.segwit_node.sync_with_ping()\n+\n+        return rejected_txs\n+\n+    def send_compact_block(self, transactions, indices):\n+        \"\"\"Send a compact block and check which transactions are requested for reconstruction.\"\"\"\n+        node = self.nodes[0]\n+\n+        # Build block\n+        block = self.build_block_on_tip(node)\n+\n+        for i in indices:\n+            tx_obj = tx_from_hex(transactions[i]['hex'])\n+            block.vtx.append(tx_obj)\n+\n+        # Add witness commitment for blocks with witness transactions\n+        add_witness_commitment(block)\n+        block.solve()\n+\n+        # Send as compact block\n+        cmpct_block = HeaderAndShortIDs()\n+        cmpct_block.initialize_from_block(block, use_witness=True)\n+        self.segwit_node.send_and_ping(msg_cmpctblock(cmpct_block.to_p2p()))\n+\n+        # Check if node requested missing transactions\n+        with p2p_lock:\n+            getblocktxn = self.segwit_node.last_message.get(\"getblocktxn\")\n+\n+        num_tx_requested = len(getblocktxn.block_txn_request.indexes) if getblocktxn else 0\n+        self.segwit_node.clear_getblocktxn()\n+\n+        # Convert differential encoding to absolute indices (from BlockTransactionRequest)\n+        missing_indices = []\n+        if getblocktxn:\n+            absolute_block_indices = getblocktxn.block_txn_request.to_absolute()\n+            # Convert from block positions to transaction indices (subtract 1 for coinbase)\n+            missing_indices = [idx - 1 for idx in absolute_block_indices]\n+\n+        return {\n+            \"block\": block,\n+            \"getblocktxn\": getblocktxn,\n+            \"num_tx_requested\": num_tx_requested,\n+            \"missing_indices\": missing_indices\n+        }\n+\n+    # TEST: policy-rejected transactions\n+\n+    def test_policy_rejection_types(self):\n+        \"\"\"Test that each policy rejection type adds transactions to extra pool.\"\"\"\n+        self.log.info(\"Testing policy rejection types for extra pool...\")\n+\n+        self.restart_node_with_limit(count=100)\n+\n+        rejection_types = [\"dust\", \"low_fee\", \"nonstandard_script\"]\n+        rejected_txs = []\n+\n+        for rejection_type in rejection_types:\n+            self.log.info(f\"Testing {rejection_type} rejection...\")\n+            tx_info = self.create_policy_rejected_tx(rejection_type)\n+\n+            tx_obj = tx_from_hex(tx_info['hex'])\n+            self.segwit_node.send_without_ping(msg_tx(tx_obj))\n+\n+            rejected_txs.append({\n+                'type': rejection_type,\n+                'tx_info': tx_info,\n+                'txid': tx_info['tx'].txid_hex\n+            })\n+\n+        self.segwit_node.sync_with_ping()\n+\n+        mempool = self.nodes[0].getrawmempool()\n+        for rejected in rejected_txs:\n+            assert_equal(rejected['txid'] in mempool, False)\n+            self.log.info(f\"âœ“ {rejected['type']} transaction rejected from mempool\")\n+\n+        indices = list(range(len(rejected_txs)))\n+        tx_list = [r['tx_info'] for r in rejected_txs]\n+\n+        result = self.send_compact_block(tx_list, indices)\n+\n+        assert_equal(result[\"missing_indices\"], [])\n+        self.log.info(\"âœ“ All rejected transactions are available in extra pool\")\n+\n+    # TEST: blockreconstructionextratxn\n+\n+    def test_extratxnpool_disabled(self):\n+        \"\"\"Test that setting count to 0 disables the extra transaction pool.\"\"\"\n+        self.log.info(\"Testing disabled extra transaction pool (0 capacity)...\")\n+\n+        self.restart_node_with_limit(count=0)\n+        buffersize = 5\n+        rejected_txs = self.populate_extra_pool(buffersize)\n+\n+        indices = list(range(buffersize))\n+        result = self.send_compact_block(rejected_txs, indices)\n+        assert_equal(result[\"missing_indices\"], indices)\n+        self.log.info(f\"âœ“ All {buffersize} transactions are missing (extra txn pool disabled)\")\n+\n+    def test_extratxnpool_capacity(self):\n+        \"\"\"Test extra transaction pool capacity transactions.\"\"\"\n+        self.log.info(\"Testing extra transaction pool capacity (50 transactions)...\")\n+\n+        buffersize = 50\n+        self.restart_node_with_limit(count=buffersize)\n+\n+        rejected_txs = self.populate_extra_pool(buffersize)\n+\n+        indices = list(range(buffersize))\n+        result = self.send_compact_block(rejected_txs, indices)\n+\n+        assert_equal(result[\"missing_indices\"], [])\n+        self.log.info(\"âœ“ All rejected transactions are in the extra txn pool\")\n+\n+        # Test that adding a 51st transaction causes eviction\n+        self.log.info(\"Adding transaction to test eviction...\")\n+        self.populate_extra_pool(1)\n+\n+        # Check original transactions again - first one should be evicted\n+        result2 = self.send_compact_block(rejected_txs, indices)\n+        assert_equal(result2[\"missing_indices\"], [0])\n+        self.log.info(\"âœ“ Transaction 0 was evicted as expected\")\n+\n+    def test_single_extratxnpool_capacity(self):\n+        \"\"\"Test edge case of single capacity extra transaction pool.\"\"\"\n+        self.log.info(\"Testing single capacity extra transaction pool...\")\n+\n+        self.restart_node_with_limit(count=1)\n+        tx_count = 5\n+\n+        rejected_txs = self.populate_extra_pool(tx_count)\n+\n+        indices = list(range(tx_count))\n+        result = self.send_compact_block(rejected_txs, indices)\n+\n+        expected_missing = list(range(4))\n+        assert_equal(result[\"missing_indices\"], expected_missing)\n+\n+    def test_extratxn_large_capacity(self):\n+        \"\"\"Test extra transaction pool with very large count parameter.\"\"\"\n+        self.log.info(\"Testing with count=400 to ensure large buffers work correctly...\")\n+\n+        buffersize = 400\n+        self.restart_node_with_limit(count=buffersize)\n+\n+        rejected_txs = self.populate_extra_pool(buffersize)\n+\n+        indices = list(range(buffersize))\n+        result = self.send_compact_block(rejected_txs, indices)\n+\n+        assert_equal(result[\"missing_indices\"], [])\n+        self.log.info(\"âœ“ All rejected transactions are in the extra txn pool\")\n+\n+        # Test that adding a transaction causes eviction\n+        self.log.info(\"Adding another transaction to test eviction...\")\n+        self.populate_extra_pool(1)\n+\n+        # Check original transactions again - first one should be evicted\n+        result2 = self.send_compact_block(rejected_txs, indices)\n+        assert_equal(result2[\"missing_indices\"], [0])\n+        self.log.info(\"âœ“ Transaction 0 was evicted as expected\")\n+\n+    def test_extratxn_buffer_wraparound(self):\n+        \"\"\"Test that adding transactions to a full buffer evicts oldest slots.\"\"\"\n+        self.log.info(\"Testing extratxn buffer wraparound - fill buffer then add more...\")\n+\n+        buffersize = 20\n+\n+        new_tx_count = 17\n+        self.restart_node_with_limit(count=buffersize)\n+\n+        # Step 1: Fill the buffer with rejected transactions\n+        rejected_txs = self.populate_extra_pool(buffersize)\n+\n+        # Verify all rejected transactions are in the extra pool\n+        indices = list(range(buffersize))\n+        result = self.send_compact_block(rejected_txs, indices)\n+        assert_equal(result[\"missing_indices\"], [])\n+        self.log.info(\"âœ“ All rejected transactions are in the extra pool\")\n+\n+        # Step 2: Add more rejected transactions\n+        self.log.info(f\"Step 2: Adding {new_tx_count} more rejected transactions (should wrap and evict slots 0-{new_tx_count-1})\")\n+        self.populate_extra_pool(new_tx_count)\n+\n+        result2 = self.send_compact_block(rejected_txs, indices)\n+\n+        # Verify wraparound worked correctly - first new_tx_count should be evicted\n+        expected_missing = list(range(new_tx_count))\n+        assert_equal(result2['missing_indices'], expected_missing)\n+        self.log.info(f\"âœ“ Wraparound worked correctly! Transactions {expected_missing} were evicted as expected\")\n+\n+    def test_extratxn_minimal_capacity_eviction(self):\n+        \"\"\"Test frequent eviction with minimal capacity.\"\"\"\n+        self.log.info(\"Testing minimal capacity eviction with count=2...\")\n+\n+        self.restart_node_with_limit(count=2)\n+\n+        # Add 10 rejected transactions to stress eviction\n+        num_txs = 10\n+        rejected_txs = self.populate_extra_pool(num_txs)\n+\n+        # Only the last 2 should remain\n+        # Try to reconstruct with all 10\n+        indices = list(range(num_txs))\n+        result = self.send_compact_block(rejected_txs, indices)\n+\n+        # First 8 should be missing (evicted)\n+        expected_missing = list(range(8))",
      "path": "test/functional/p2p_compactblocks_extratxs.py",
      "position": 1,
      "original_position": 367,
      "commit_id": "f9c6331cb26f3bafc3dba7f5a72622a9ff4f190d",
      "original_commit_id": "bd1c6b4ea9b94ab4b2604f2a4b8a7fd1fe55c92a",
      "in_reply_to_id": null,
      "user": {
        "login": "kevkevinpal",
        "id": 15950706,
        "node_id": "MDQ6VXNlcjE1OTUwNzA2",
        "avatar_url": "https://avatars.githubusercontent.com/u/15950706?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kevkevinpal",
        "html_url": "https://github.com/kevkevinpal",
        "followers_url": "https://api.github.com/users/kevkevinpal/followers",
        "following_url": "https://api.github.com/users/kevkevinpal/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kevkevinpal/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kevkevinpal/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kevkevinpal/subscriptions",
        "organizations_url": "https://api.github.com/users/kevkevinpal/orgs",
        "repos_url": "https://api.github.com/users/kevkevinpal/repos",
        "events_url": "https://api.github.com/users/kevkevinpal/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kevkevinpal/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "instead of 8 can you make this `num_txs - count`, it makes sense to not have magic numbers",
      "created_at": "2025-08-25T21:58:10Z",
      "updated_at": "2025-08-25T22:09:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33023#discussion_r2299231394",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2299231394"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33023"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 367,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2299239940",
      "pull_request_review_id": 3153147837,
      "id": 2299239940,
      "node_id": "PRRC_kwDOABII586JC54E",
      "diff_hunk": "@@ -0,0 +1,422 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2025 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test blockreconstructionextratxn option with compact blocks.\"\"\"\n+\n+from test_framework.blocktools import (\n+    COINBASE_MATURITY,\n+    NORMAL_GBT_REQUEST_PARAMS,\n+    create_block,\n+    add_witness_commitment,\n+)\n+from test_framework.messages import (\n+    CTxOut,\n+    HeaderAndShortIDs,\n+    MSG_BLOCK,\n+    msg_cmpctblock,\n+    msg_sendcmpct,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+    p2p_lock,\n+)\n+from test_framework.script import (\n+    CScript,\n+    OP_TRUE,\n+)\n+from test_framework.script_util import (\n+    keys_to_multisig_script,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    softfork_active,\n+)\n+from decimal import Decimal\n+from test_framework.wallet import MiniWallet\n+\n+\n+# TestP2PConn: A peer we use to send messages to bitcoind, and store responses.\n+class TestP2PConn(P2PInterface):\n+    def __init__(self):\n+        super().__init__()\n+        self.last_sendcmpct = []\n+        self.block_announced = False\n+        # Store the hashes of blocks we've seen announced.\n+        # This is for synchronizing the p2p message traffic,\n+        # so we can eg wait until a particular block is announced.\n+        self.announced_blockhashes = set()\n+\n+    def on_sendcmpct(self, message):\n+        self.last_sendcmpct.append(message)\n+\n+    def on_cmpctblock(self, message):\n+        self.block_announced = True\n+        self.last_message[\"cmpctblock\"].header_and_shortids.header.calc_sha256()\n+        self.announced_blockhashes.add(self.last_message[\"cmpctblock\"].header_and_shortids.header.sha256)\n+\n+    def on_headers(self, message):\n+        self.block_announced = True\n+        for x in self.last_message[\"headers\"].headers:\n+            x.calc_sha256()\n+            self.announced_blockhashes.add(x.sha256)\n+\n+    def on_inv(self, message):\n+        for x in self.last_message[\"inv\"].inv:\n+            if x.type == MSG_BLOCK:\n+                self.block_announced = True\n+                self.announced_blockhashes.add(x.hash)\n+\n+    # Requires caller to hold p2p_lock\n+    def received_block_announcement(self):\n+        return self.block_announced\n+\n+    def clear_block_announcement(self):\n+        with p2p_lock:\n+            self.block_announced = False\n+            self.last_message.pop(\"inv\", None)\n+            self.last_message.pop(\"headers\", None)\n+            self.last_message.pop(\"cmpctblock\", None)\n+\n+    def clear_getblocktxn(self):\n+        with p2p_lock:\n+            self.last_message.pop(\"getblocktxn\", None)\n+\n+\n+class CompactBlocksBlockReconstructionLimitTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+        self.extra_args = [[\n+            \"-acceptnonstdtxn=0\",\n+            \"-debug=net\",\n+        ]]\n+        self.utxos = []\n+\n+    def build_block_on_tip(self, node):\n+        \"\"\"Build a block on top of the current tip.\"\"\"\n+        block = create_block(tmpl=node.getblocktemplate(NORMAL_GBT_REQUEST_PARAMS))\n+        block.solve()\n+        return block\n+\n+    def make_utxos(self):\n+        \"\"\"Generate blocks to create UTXOs for the wallet.\"\"\"\n+        self.generate(self.wallet, COINBASE_MATURITY + 800)\n+\n+    def restart_node_with_limit(self, count=None):\n+        \"\"\"Restart node with specific count limit.\"\"\"\n+        extra_args = [\"-acceptnonstdtxn=0\", \"-debug=net\"]\n+\n+        if count is not None:\n+            self.log.info(f\"Setting transaction count limit: {count}\")\n+            extra_args.append(f\"-blockreconstructionextratxn={count}\")\n+\n+        self.log.info(f\"Restarting node with args: {extra_args}\")\n+        self.restart_node(0, extra_args=extra_args)\n+        self.segwit_node = self.nodes[0].add_p2p_connection(TestP2PConn())\n+        self.segwit_node.send_and_ping(msg_sendcmpct(announce=True, version=2))\n+\n+    def create_policy_rejected_tx(self, rejection_type=\"dust\"):\n+        \"\"\"Create a transaction that will be rejected for policy reasons but added to extra pool.\"\"\"\n+\n+        if rejection_type == \"dust\":\n+            tx_info = self.wallet.create_self_transfer()\n+            dust_amount = 100\n+            dust_script = CScript([OP_TRUE])\n+            tx_info['tx'].vout.append(CTxOut(dust_amount, dust_script))\n+            tx_info['tx'].vout[0].nValue -= dust_amount\n+\n+        elif rejection_type == \"low_fee\":\n+            tx_info = self.wallet.create_self_transfer(fee_rate=Decimal('0.00000100'))\n+\n+        elif rejection_type == \"nonstandard_script\":\n+            tx_info = self.wallet.create_self_transfer()\n+            pubkeys = []\n+            for _ in range(4):\n+                pubkeys.append(bytes([0x02] + [0x00] * 32))\n+            multisig_script = keys_to_multisig_script(pubkeys, k=4)\n+            tx_info['tx'].vout.append(CTxOut(10000, multisig_script))\n+            tx_info['tx'].vout[0].nValue -= 10000\n+\n+        else:\n+            raise ValueError(f\"Unknown rejection type: {rejection_type}\")\n+\n+        tx_info['hex'] = tx_info['tx'].serialize().hex()\n+        return tx_info\n+\n+    def populate_extra_pool(self, num_txs, rejection_type=\"dust\"):\n+        \"\"\"Populate the extra transaction pool using policy-rejected transactions.\"\"\"\n+        rejected_txs = []\n+\n+        for i in range(num_txs):\n+            tx_info = self.create_policy_rejected_tx(rejection_type)\n+            tx_obj = tx_from_hex(tx_info['hex'])\n+            self.segwit_node.send_without_ping(msg_tx(tx_obj))\n+            rejected_txs.append(tx_info)\n+\n+        self.segwit_node.sync_with_ping()\n+\n+        return rejected_txs\n+\n+    def send_compact_block(self, transactions, indices):\n+        \"\"\"Send a compact block and check which transactions are requested for reconstruction.\"\"\"\n+        node = self.nodes[0]\n+\n+        # Build block\n+        block = self.build_block_on_tip(node)\n+\n+        for i in indices:\n+            tx_obj = tx_from_hex(transactions[i]['hex'])\n+            block.vtx.append(tx_obj)\n+\n+        # Add witness commitment for blocks with witness transactions\n+        add_witness_commitment(block)\n+        block.solve()\n+\n+        # Send as compact block\n+        cmpct_block = HeaderAndShortIDs()\n+        cmpct_block.initialize_from_block(block, use_witness=True)\n+        self.segwit_node.send_and_ping(msg_cmpctblock(cmpct_block.to_p2p()))\n+\n+        # Check if node requested missing transactions\n+        with p2p_lock:\n+            getblocktxn = self.segwit_node.last_message.get(\"getblocktxn\")\n+\n+        num_tx_requested = len(getblocktxn.block_txn_request.indexes) if getblocktxn else 0\n+        self.segwit_node.clear_getblocktxn()\n+\n+        # Convert differential encoding to absolute indices (from BlockTransactionRequest)\n+        missing_indices = []\n+        if getblocktxn:\n+            absolute_block_indices = getblocktxn.block_txn_request.to_absolute()\n+            # Convert from block positions to transaction indices (subtract 1 for coinbase)\n+            missing_indices = [idx - 1 for idx in absolute_block_indices]\n+\n+        return {\n+            \"block\": block,\n+            \"getblocktxn\": getblocktxn,\n+            \"num_tx_requested\": num_tx_requested,\n+            \"missing_indices\": missing_indices\n+        }\n+\n+    # TEST: policy-rejected transactions\n+\n+    def test_policy_rejection_types(self):\n+        \"\"\"Test that each policy rejection type adds transactions to extra pool.\"\"\"\n+        self.log.info(\"Testing policy rejection types for extra pool...\")\n+\n+        self.restart_node_with_limit(count=100)\n+\n+        rejection_types = [\"dust\", \"low_fee\", \"nonstandard_script\"]\n+        rejected_txs = []\n+\n+        for rejection_type in rejection_types:\n+            self.log.info(f\"Testing {rejection_type} rejection...\")\n+            tx_info = self.create_policy_rejected_tx(rejection_type)\n+\n+            tx_obj = tx_from_hex(tx_info['hex'])\n+            self.segwit_node.send_without_ping(msg_tx(tx_obj))\n+\n+            rejected_txs.append({\n+                'type': rejection_type,\n+                'tx_info': tx_info,\n+                'txid': tx_info['tx'].txid_hex\n+            })\n+\n+        self.segwit_node.sync_with_ping()\n+\n+        mempool = self.nodes[0].getrawmempool()\n+        for rejected in rejected_txs:\n+            assert_equal(rejected['txid'] in mempool, False)\n+            self.log.info(f\"âœ“ {rejected['type']} transaction rejected from mempool\")\n+\n+        indices = list(range(len(rejected_txs)))\n+        tx_list = [r['tx_info'] for r in rejected_txs]\n+\n+        result = self.send_compact_block(tx_list, indices)\n+\n+        assert_equal(result[\"missing_indices\"], [])\n+        self.log.info(\"âœ“ All rejected transactions are available in extra pool\")\n+\n+    # TEST: blockreconstructionextratxn\n+\n+    def test_extratxnpool_disabled(self):\n+        \"\"\"Test that setting count to 0 disables the extra transaction pool.\"\"\"\n+        self.log.info(\"Testing disabled extra transaction pool (0 capacity)...\")\n+\n+        self.restart_node_with_limit(count=0)\n+        buffersize = 5\n+        rejected_txs = self.populate_extra_pool(buffersize)\n+\n+        indices = list(range(buffersize))\n+        result = self.send_compact_block(rejected_txs, indices)\n+        assert_equal(result[\"missing_indices\"], indices)\n+        self.log.info(f\"âœ“ All {buffersize} transactions are missing (extra txn pool disabled)\")\n+\n+    def test_extratxnpool_capacity(self):\n+        \"\"\"Test extra transaction pool capacity transactions.\"\"\"\n+        self.log.info(\"Testing extra transaction pool capacity (50 transactions)...\")\n+\n+        buffersize = 50\n+        self.restart_node_with_limit(count=buffersize)\n+\n+        rejected_txs = self.populate_extra_pool(buffersize)\n+\n+        indices = list(range(buffersize))\n+        result = self.send_compact_block(rejected_txs, indices)\n+\n+        assert_equal(result[\"missing_indices\"], [])\n+        self.log.info(\"âœ“ All rejected transactions are in the extra txn pool\")\n+\n+        # Test that adding a 51st transaction causes eviction\n+        self.log.info(\"Adding transaction to test eviction...\")\n+        self.populate_extra_pool(1)\n+\n+        # Check original transactions again - first one should be evicted\n+        result2 = self.send_compact_block(rejected_txs, indices)\n+        assert_equal(result2[\"missing_indices\"], [0])\n+        self.log.info(\"âœ“ Transaction 0 was evicted as expected\")\n+\n+    def test_single_extratxnpool_capacity(self):\n+        \"\"\"Test edge case of single capacity extra transaction pool.\"\"\"\n+        self.log.info(\"Testing single capacity extra transaction pool...\")\n+\n+        self.restart_node_with_limit(count=1)\n+        tx_count = 5\n+\n+        rejected_txs = self.populate_extra_pool(tx_count)\n+\n+        indices = list(range(tx_count))\n+        result = self.send_compact_block(rejected_txs, indices)\n+\n+        expected_missing = list(range(4))\n+        assert_equal(result[\"missing_indices\"], expected_missing)\n+\n+    def test_extratxn_large_capacity(self):\n+        \"\"\"Test extra transaction pool with very large count parameter.\"\"\"\n+        self.log.info(\"Testing with count=400 to ensure large buffers work correctly...\")\n+\n+        buffersize = 400\n+        self.restart_node_with_limit(count=buffersize)\n+\n+        rejected_txs = self.populate_extra_pool(buffersize)\n+\n+        indices = list(range(buffersize))\n+        result = self.send_compact_block(rejected_txs, indices)\n+\n+        assert_equal(result[\"missing_indices\"], [])\n+        self.log.info(\"âœ“ All rejected transactions are in the extra txn pool\")\n+\n+        # Test that adding a transaction causes eviction\n+        self.log.info(\"Adding another transaction to test eviction...\")\n+        self.populate_extra_pool(1)\n+\n+        # Check original transactions again - first one should be evicted\n+        result2 = self.send_compact_block(rejected_txs, indices)\n+        assert_equal(result2[\"missing_indices\"], [0])\n+        self.log.info(\"âœ“ Transaction 0 was evicted as expected\")\n+\n+    def test_extratxn_buffer_wraparound(self):\n+        \"\"\"Test that adding transactions to a full buffer evicts oldest slots.\"\"\"\n+        self.log.info(\"Testing extratxn buffer wraparound - fill buffer then add more...\")\n+\n+        buffersize = 20\n+\n+        new_tx_count = 17\n+        self.restart_node_with_limit(count=buffersize)\n+\n+        # Step 1: Fill the buffer with rejected transactions\n+        rejected_txs = self.populate_extra_pool(buffersize)\n+\n+        # Verify all rejected transactions are in the extra pool\n+        indices = list(range(buffersize))\n+        result = self.send_compact_block(rejected_txs, indices)\n+        assert_equal(result[\"missing_indices\"], [])\n+        self.log.info(\"âœ“ All rejected transactions are in the extra pool\")\n+\n+        # Step 2: Add more rejected transactions\n+        self.log.info(f\"Step 2: Adding {new_tx_count} more rejected transactions (should wrap and evict slots 0-{new_tx_count-1})\")\n+        self.populate_extra_pool(new_tx_count)\n+\n+        result2 = self.send_compact_block(rejected_txs, indices)\n+\n+        # Verify wraparound worked correctly - first new_tx_count should be evicted\n+        expected_missing = list(range(new_tx_count))\n+        assert_equal(result2['missing_indices'], expected_missing)\n+        self.log.info(f\"âœ“ Wraparound worked correctly! Transactions {expected_missing} were evicted as expected\")\n+\n+    def test_extratxn_minimal_capacity_eviction(self):",
      "path": "test/functional/p2p_compactblocks_extratxs.py",
      "position": 1,
      "original_position": 351,
      "commit_id": "f9c6331cb26f3bafc3dba7f5a72622a9ff4f190d",
      "original_commit_id": "bd1c6b4ea9b94ab4b2604f2a4b8a7fd1fe55c92a",
      "in_reply_to_id": null,
      "user": {
        "login": "kevkevinpal",
        "id": 15950706,
        "node_id": "MDQ6VXNlcjE1OTUwNzA2",
        "avatar_url": "https://avatars.githubusercontent.com/u/15950706?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kevkevinpal",
        "html_url": "https://github.com/kevkevinpal",
        "followers_url": "https://api.github.com/users/kevkevinpal/followers",
        "following_url": "https://api.github.com/users/kevkevinpal/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kevkevinpal/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kevkevinpal/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kevkevinpal/subscriptions",
        "organizations_url": "https://api.github.com/users/kevkevinpal/orgs",
        "repos_url": "https://api.github.com/users/kevkevinpal/repos",
        "events_url": "https://api.github.com/users/kevkevinpal/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kevkevinpal/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "what is the point of testing with 2 when you have another test, testing with 1?",
      "created_at": "2025-08-25T22:03:53Z",
      "updated_at": "2025-08-25T22:09:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33023#discussion_r2299239940",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2299239940"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33023"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 351,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2299245392",
      "pull_request_review_id": 3153147837,
      "id": 2299245392,
      "node_id": "PRRC_kwDOABII586JC7NQ",
      "diff_hunk": "@@ -0,0 +1,422 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2025 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test blockreconstructionextratxn option with compact blocks.\"\"\"\n+\n+from test_framework.blocktools import (\n+    COINBASE_MATURITY,\n+    NORMAL_GBT_REQUEST_PARAMS,\n+    create_block,\n+    add_witness_commitment,\n+)\n+from test_framework.messages import (\n+    CTxOut,\n+    HeaderAndShortIDs,\n+    MSG_BLOCK,\n+    msg_cmpctblock,\n+    msg_sendcmpct,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+    p2p_lock,\n+)\n+from test_framework.script import (\n+    CScript,\n+    OP_TRUE,\n+)\n+from test_framework.script_util import (\n+    keys_to_multisig_script,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    softfork_active,\n+)\n+from decimal import Decimal\n+from test_framework.wallet import MiniWallet\n+\n+\n+# TestP2PConn: A peer we use to send messages to bitcoind, and store responses.\n+class TestP2PConn(P2PInterface):\n+    def __init__(self):\n+        super().__init__()\n+        self.last_sendcmpct = []\n+        self.block_announced = False\n+        # Store the hashes of blocks we've seen announced.\n+        # This is for synchronizing the p2p message traffic,\n+        # so we can eg wait until a particular block is announced.\n+        self.announced_blockhashes = set()\n+\n+    def on_sendcmpct(self, message):\n+        self.last_sendcmpct.append(message)\n+\n+    def on_cmpctblock(self, message):\n+        self.block_announced = True\n+        self.last_message[\"cmpctblock\"].header_and_shortids.header.calc_sha256()\n+        self.announced_blockhashes.add(self.last_message[\"cmpctblock\"].header_and_shortids.header.sha256)\n+\n+    def on_headers(self, message):\n+        self.block_announced = True\n+        for x in self.last_message[\"headers\"].headers:\n+            x.calc_sha256()\n+            self.announced_blockhashes.add(x.sha256)\n+\n+    def on_inv(self, message):\n+        for x in self.last_message[\"inv\"].inv:\n+            if x.type == MSG_BLOCK:\n+                self.block_announced = True\n+                self.announced_blockhashes.add(x.hash)\n+\n+    # Requires caller to hold p2p_lock\n+    def received_block_announcement(self):\n+        return self.block_announced\n+\n+    def clear_block_announcement(self):\n+        with p2p_lock:\n+            self.block_announced = False\n+            self.last_message.pop(\"inv\", None)\n+            self.last_message.pop(\"headers\", None)\n+            self.last_message.pop(\"cmpctblock\", None)\n+\n+    def clear_getblocktxn(self):\n+        with p2p_lock:\n+            self.last_message.pop(\"getblocktxn\", None)\n+\n+\n+class CompactBlocksBlockReconstructionLimitTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+        self.extra_args = [[\n+            \"-acceptnonstdtxn=0\",\n+            \"-debug=net\",\n+        ]]\n+        self.utxos = []\n+\n+    def build_block_on_tip(self, node):\n+        \"\"\"Build a block on top of the current tip.\"\"\"\n+        block = create_block(tmpl=node.getblocktemplate(NORMAL_GBT_REQUEST_PARAMS))\n+        block.solve()\n+        return block\n+\n+    def make_utxos(self):\n+        \"\"\"Generate blocks to create UTXOs for the wallet.\"\"\"\n+        self.generate(self.wallet, COINBASE_MATURITY + 800)\n+\n+    def restart_node_with_limit(self, count=None):\n+        \"\"\"Restart node with specific count limit.\"\"\"\n+        extra_args = [\"-acceptnonstdtxn=0\", \"-debug=net\"]\n+\n+        if count is not None:\n+            self.log.info(f\"Setting transaction count limit: {count}\")\n+            extra_args.append(f\"-blockreconstructionextratxn={count}\")\n+\n+        self.log.info(f\"Restarting node with args: {extra_args}\")\n+        self.restart_node(0, extra_args=extra_args)\n+        self.segwit_node = self.nodes[0].add_p2p_connection(TestP2PConn())\n+        self.segwit_node.send_and_ping(msg_sendcmpct(announce=True, version=2))\n+\n+    def create_policy_rejected_tx(self, rejection_type=\"dust\"):\n+        \"\"\"Create a transaction that will be rejected for policy reasons but added to extra pool.\"\"\"\n+\n+        if rejection_type == \"dust\":\n+            tx_info = self.wallet.create_self_transfer()\n+            dust_amount = 100\n+            dust_script = CScript([OP_TRUE])\n+            tx_info['tx'].vout.append(CTxOut(dust_amount, dust_script))\n+            tx_info['tx'].vout[0].nValue -= dust_amount\n+\n+        elif rejection_type == \"low_fee\":\n+            tx_info = self.wallet.create_self_transfer(fee_rate=Decimal('0.00000100'))\n+\n+        elif rejection_type == \"nonstandard_script\":\n+            tx_info = self.wallet.create_self_transfer()\n+            pubkeys = []\n+            for _ in range(4):\n+                pubkeys.append(bytes([0x02] + [0x00] * 32))\n+            multisig_script = keys_to_multisig_script(pubkeys, k=4)\n+            tx_info['tx'].vout.append(CTxOut(10000, multisig_script))\n+            tx_info['tx'].vout[0].nValue -= 10000\n+\n+        else:\n+            raise ValueError(f\"Unknown rejection type: {rejection_type}\")\n+\n+        tx_info['hex'] = tx_info['tx'].serialize().hex()\n+        return tx_info\n+\n+    def populate_extra_pool(self, num_txs, rejection_type=\"dust\"):\n+        \"\"\"Populate the extra transaction pool using policy-rejected transactions.\"\"\"\n+        rejected_txs = []\n+\n+        for i in range(num_txs):\n+            tx_info = self.create_policy_rejected_tx(rejection_type)\n+            tx_obj = tx_from_hex(tx_info['hex'])\n+            self.segwit_node.send_without_ping(msg_tx(tx_obj))\n+            rejected_txs.append(tx_info)\n+\n+        self.segwit_node.sync_with_ping()\n+\n+        return rejected_txs\n+\n+    def send_compact_block(self, transactions, indices):\n+        \"\"\"Send a compact block and check which transactions are requested for reconstruction.\"\"\"\n+        node = self.nodes[0]\n+\n+        # Build block\n+        block = self.build_block_on_tip(node)\n+\n+        for i in indices:\n+            tx_obj = tx_from_hex(transactions[i]['hex'])\n+            block.vtx.append(tx_obj)\n+\n+        # Add witness commitment for blocks with witness transactions\n+        add_witness_commitment(block)\n+        block.solve()\n+\n+        # Send as compact block\n+        cmpct_block = HeaderAndShortIDs()\n+        cmpct_block.initialize_from_block(block, use_witness=True)\n+        self.segwit_node.send_and_ping(msg_cmpctblock(cmpct_block.to_p2p()))\n+\n+        # Check if node requested missing transactions\n+        with p2p_lock:\n+            getblocktxn = self.segwit_node.last_message.get(\"getblocktxn\")\n+\n+        num_tx_requested = len(getblocktxn.block_txn_request.indexes) if getblocktxn else 0\n+        self.segwit_node.clear_getblocktxn()\n+\n+        # Convert differential encoding to absolute indices (from BlockTransactionRequest)\n+        missing_indices = []\n+        if getblocktxn:\n+            absolute_block_indices = getblocktxn.block_txn_request.to_absolute()\n+            # Convert from block positions to transaction indices (subtract 1 for coinbase)\n+            missing_indices = [idx - 1 for idx in absolute_block_indices]\n+\n+        return {\n+            \"block\": block,\n+            \"getblocktxn\": getblocktxn,\n+            \"num_tx_requested\": num_tx_requested,\n+            \"missing_indices\": missing_indices\n+        }\n+\n+    # TEST: policy-rejected transactions\n+\n+    def test_policy_rejection_types(self):\n+        \"\"\"Test that each policy rejection type adds transactions to extra pool.\"\"\"\n+        self.log.info(\"Testing policy rejection types for extra pool...\")\n+\n+        self.restart_node_with_limit(count=100)\n+\n+        rejection_types = [\"dust\", \"low_fee\", \"nonstandard_script\"]\n+        rejected_txs = []\n+\n+        for rejection_type in rejection_types:\n+            self.log.info(f\"Testing {rejection_type} rejection...\")\n+            tx_info = self.create_policy_rejected_tx(rejection_type)\n+\n+            tx_obj = tx_from_hex(tx_info['hex'])\n+            self.segwit_node.send_without_ping(msg_tx(tx_obj))\n+\n+            rejected_txs.append({\n+                'type': rejection_type,\n+                'tx_info': tx_info,\n+                'txid': tx_info['tx'].txid_hex\n+            })\n+\n+        self.segwit_node.sync_with_ping()\n+\n+        mempool = self.nodes[0].getrawmempool()\n+        for rejected in rejected_txs:\n+            assert_equal(rejected['txid'] in mempool, False)\n+            self.log.info(f\"âœ“ {rejected['type']} transaction rejected from mempool\")\n+\n+        indices = list(range(len(rejected_txs)))\n+        tx_list = [r['tx_info'] for r in rejected_txs]\n+\n+        result = self.send_compact_block(tx_list, indices)\n+\n+        assert_equal(result[\"missing_indices\"], [])\n+        self.log.info(\"âœ“ All rejected transactions are available in extra pool\")\n+\n+    # TEST: blockreconstructionextratxn\n+\n+    def test_extratxnpool_disabled(self):\n+        \"\"\"Test that setting count to 0 disables the extra transaction pool.\"\"\"\n+        self.log.info(\"Testing disabled extra transaction pool (0 capacity)...\")\n+\n+        self.restart_node_with_limit(count=0)\n+        buffersize = 5\n+        rejected_txs = self.populate_extra_pool(buffersize)\n+\n+        indices = list(range(buffersize))\n+        result = self.send_compact_block(rejected_txs, indices)\n+        assert_equal(result[\"missing_indices\"], indices)\n+        self.log.info(f\"âœ“ All {buffersize} transactions are missing (extra txn pool disabled)\")\n+\n+    def test_extratxnpool_capacity(self):",
      "path": "test/functional/p2p_compactblocks_extratxs.py",
      "position": 1,
      "original_position": 259,
      "commit_id": "f9c6331cb26f3bafc3dba7f5a72622a9ff4f190d",
      "original_commit_id": "bd1c6b4ea9b94ab4b2604f2a4b8a7fd1fe55c92a",
      "in_reply_to_id": null,
      "user": {
        "login": "kevkevinpal",
        "id": 15950706,
        "node_id": "MDQ6VXNlcjE1OTUwNzA2",
        "avatar_url": "https://avatars.githubusercontent.com/u/15950706?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kevkevinpal",
        "html_url": "https://github.com/kevkevinpal",
        "followers_url": "https://api.github.com/users/kevkevinpal/followers",
        "following_url": "https://api.github.com/users/kevkevinpal/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kevkevinpal/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kevkevinpal/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kevkevinpal/subscriptions",
        "organizations_url": "https://api.github.com/users/kevkevinpal/orgs",
        "repos_url": "https://api.github.com/users/kevkevinpal/repos",
        "events_url": "https://api.github.com/users/kevkevinpal/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kevkevinpal/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "If you could why not set buffersize to 400, and then after checking the capacity test the wrap around?\n\nThen you can drop `test_extratxn_large_capacity` and `test_extratxn_buffer_wraparound` seems redundant to do the setup multiple times when they can be done in the same test.",
      "created_at": "2025-08-25T22:07:09Z",
      "updated_at": "2025-08-25T22:09:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33023#discussion_r2299245392",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2299245392"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33023"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 259,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2299367679",
      "pull_request_review_id": 3153338558,
      "id": 2299367679,
      "node_id": "PRRC_kwDOABII586JDZD_",
      "diff_hunk": "@@ -0,0 +1,422 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2025 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test blockreconstructionextratxn option with compact blocks.\"\"\"\n+\n+from test_framework.blocktools import (\n+    COINBASE_MATURITY,\n+    NORMAL_GBT_REQUEST_PARAMS,\n+    create_block,\n+    add_witness_commitment,\n+)\n+from test_framework.messages import (\n+    CTxOut,\n+    HeaderAndShortIDs,\n+    MSG_BLOCK,\n+    msg_cmpctblock,\n+    msg_sendcmpct,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+    p2p_lock,\n+)\n+from test_framework.script import (\n+    CScript,\n+    OP_TRUE,\n+)\n+from test_framework.script_util import (\n+    keys_to_multisig_script,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    softfork_active,\n+)\n+from decimal import Decimal\n+from test_framework.wallet import MiniWallet\n+\n+\n+# TestP2PConn: A peer we use to send messages to bitcoind, and store responses.\n+class TestP2PConn(P2PInterface):\n+    def __init__(self):\n+        super().__init__()\n+        self.last_sendcmpct = []\n+        self.block_announced = False\n+        # Store the hashes of blocks we've seen announced.\n+        # This is for synchronizing the p2p message traffic,\n+        # so we can eg wait until a particular block is announced.\n+        self.announced_blockhashes = set()\n+\n+    def on_sendcmpct(self, message):\n+        self.last_sendcmpct.append(message)\n+\n+    def on_cmpctblock(self, message):\n+        self.block_announced = True\n+        self.last_message[\"cmpctblock\"].header_and_shortids.header.calc_sha256()\n+        self.announced_blockhashes.add(self.last_message[\"cmpctblock\"].header_and_shortids.header.sha256)\n+\n+    def on_headers(self, message):\n+        self.block_announced = True\n+        for x in self.last_message[\"headers\"].headers:\n+            x.calc_sha256()\n+            self.announced_blockhashes.add(x.sha256)\n+\n+    def on_inv(self, message):\n+        for x in self.last_message[\"inv\"].inv:\n+            if x.type == MSG_BLOCK:\n+                self.block_announced = True\n+                self.announced_blockhashes.add(x.hash)\n+\n+    # Requires caller to hold p2p_lock\n+    def received_block_announcement(self):\n+        return self.block_announced\n+\n+    def clear_block_announcement(self):\n+        with p2p_lock:\n+            self.block_announced = False\n+            self.last_message.pop(\"inv\", None)\n+            self.last_message.pop(\"headers\", None)\n+            self.last_message.pop(\"cmpctblock\", None)\n+\n+    def clear_getblocktxn(self):\n+        with p2p_lock:\n+            self.last_message.pop(\"getblocktxn\", None)\n+\n+\n+class CompactBlocksBlockReconstructionLimitTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+        self.extra_args = [[\n+            \"-acceptnonstdtxn=0\",\n+            \"-debug=net\",\n+        ]]\n+        self.utxos = []\n+\n+    def build_block_on_tip(self, node):\n+        \"\"\"Build a block on top of the current tip.\"\"\"\n+        block = create_block(tmpl=node.getblocktemplate(NORMAL_GBT_REQUEST_PARAMS))\n+        block.solve()\n+        return block\n+\n+    def make_utxos(self):\n+        \"\"\"Generate blocks to create UTXOs for the wallet.\"\"\"\n+        self.generate(self.wallet, COINBASE_MATURITY + 800)\n+\n+    def restart_node_with_limit(self, count=None):\n+        \"\"\"Restart node with specific count limit.\"\"\"\n+        extra_args = [\"-acceptnonstdtxn=0\", \"-debug=net\"]\n+\n+        if count is not None:\n+            self.log.info(f\"Setting transaction count limit: {count}\")\n+            extra_args.append(f\"-blockreconstructionextratxn={count}\")\n+\n+        self.log.info(f\"Restarting node with args: {extra_args}\")\n+        self.restart_node(0, extra_args=extra_args)\n+        self.segwit_node = self.nodes[0].add_p2p_connection(TestP2PConn())\n+        self.segwit_node.send_and_ping(msg_sendcmpct(announce=True, version=2))\n+\n+    def create_policy_rejected_tx(self, rejection_type=\"dust\"):\n+        \"\"\"Create a transaction that will be rejected for policy reasons but added to extra pool.\"\"\"\n+\n+        if rejection_type == \"dust\":\n+            tx_info = self.wallet.create_self_transfer()\n+            dust_amount = 100\n+            dust_script = CScript([OP_TRUE])\n+            tx_info['tx'].vout.append(CTxOut(dust_amount, dust_script))\n+            tx_info['tx'].vout[0].nValue -= dust_amount\n+\n+        elif rejection_type == \"low_fee\":\n+            tx_info = self.wallet.create_self_transfer(fee_rate=Decimal('0.00000100'))\n+\n+        elif rejection_type == \"nonstandard_script\":\n+            tx_info = self.wallet.create_self_transfer()\n+            pubkeys = []\n+            for _ in range(4):\n+                pubkeys.append(bytes([0x02] + [0x00] * 32))\n+            multisig_script = keys_to_multisig_script(pubkeys, k=4)\n+            tx_info['tx'].vout.append(CTxOut(10000, multisig_script))\n+            tx_info['tx'].vout[0].nValue -= 10000\n+\n+        else:\n+            raise ValueError(f\"Unknown rejection type: {rejection_type}\")\n+\n+        tx_info['hex'] = tx_info['tx'].serialize().hex()\n+        return tx_info\n+\n+    def populate_extra_pool(self, num_txs, rejection_type=\"dust\"):\n+        \"\"\"Populate the extra transaction pool using policy-rejected transactions.\"\"\"\n+        rejected_txs = []\n+\n+        for i in range(num_txs):\n+            tx_info = self.create_policy_rejected_tx(rejection_type)\n+            tx_obj = tx_from_hex(tx_info['hex'])\n+            self.segwit_node.send_without_ping(msg_tx(tx_obj))\n+            rejected_txs.append(tx_info)\n+\n+        self.segwit_node.sync_with_ping()\n+\n+        return rejected_txs\n+\n+    def send_compact_block(self, transactions, indices):\n+        \"\"\"Send a compact block and check which transactions are requested for reconstruction.\"\"\"\n+        node = self.nodes[0]\n+\n+        # Build block\n+        block = self.build_block_on_tip(node)\n+\n+        for i in indices:\n+            tx_obj = tx_from_hex(transactions[i]['hex'])\n+            block.vtx.append(tx_obj)\n+\n+        # Add witness commitment for blocks with witness transactions\n+        add_witness_commitment(block)\n+        block.solve()\n+\n+        # Send as compact block\n+        cmpct_block = HeaderAndShortIDs()\n+        cmpct_block.initialize_from_block(block, use_witness=True)\n+        self.segwit_node.send_and_ping(msg_cmpctblock(cmpct_block.to_p2p()))\n+\n+        # Check if node requested missing transactions\n+        with p2p_lock:\n+            getblocktxn = self.segwit_node.last_message.get(\"getblocktxn\")\n+\n+        num_tx_requested = len(getblocktxn.block_txn_request.indexes) if getblocktxn else 0\n+        self.segwit_node.clear_getblocktxn()\n+\n+        # Convert differential encoding to absolute indices (from BlockTransactionRequest)\n+        missing_indices = []\n+        if getblocktxn:\n+            absolute_block_indices = getblocktxn.block_txn_request.to_absolute()\n+            # Convert from block positions to transaction indices (subtract 1 for coinbase)\n+            missing_indices = [idx - 1 for idx in absolute_block_indices]\n+\n+        return {\n+            \"block\": block,\n+            \"getblocktxn\": getblocktxn,\n+            \"num_tx_requested\": num_tx_requested,\n+            \"missing_indices\": missing_indices\n+        }\n+\n+    # TEST: policy-rejected transactions\n+\n+    def test_policy_rejection_types(self):\n+        \"\"\"Test that each policy rejection type adds transactions to extra pool.\"\"\"\n+        self.log.info(\"Testing policy rejection types for extra pool...\")\n+\n+        self.restart_node_with_limit(count=100)\n+\n+        rejection_types = [\"dust\", \"low_fee\", \"nonstandard_script\"]\n+        rejected_txs = []\n+\n+        for rejection_type in rejection_types:\n+            self.log.info(f\"Testing {rejection_type} rejection...\")\n+            tx_info = self.create_policy_rejected_tx(rejection_type)\n+\n+            tx_obj = tx_from_hex(tx_info['hex'])\n+            self.segwit_node.send_without_ping(msg_tx(tx_obj))\n+\n+            rejected_txs.append({\n+                'type': rejection_type,\n+                'tx_info': tx_info,\n+                'txid': tx_info['tx'].txid_hex\n+            })\n+\n+        self.segwit_node.sync_with_ping()\n+\n+        mempool = self.nodes[0].getrawmempool()\n+        for rejected in rejected_txs:\n+            assert_equal(rejected['txid'] in mempool, False)\n+            self.log.info(f\"âœ“ {rejected['type']} transaction rejected from mempool\")\n+\n+        indices = list(range(len(rejected_txs)))\n+        tx_list = [r['tx_info'] for r in rejected_txs]\n+\n+        result = self.send_compact_block(tx_list, indices)\n+\n+        assert_equal(result[\"missing_indices\"], [])\n+        self.log.info(\"âœ“ All rejected transactions are available in extra pool\")\n+\n+    # TEST: blockreconstructionextratxn\n+\n+    def test_extratxnpool_disabled(self):\n+        \"\"\"Test that setting count to 0 disables the extra transaction pool.\"\"\"\n+        self.log.info(\"Testing disabled extra transaction pool (0 capacity)...\")\n+\n+        self.restart_node_with_limit(count=0)\n+        buffersize = 5\n+        rejected_txs = self.populate_extra_pool(buffersize)\n+\n+        indices = list(range(buffersize))\n+        result = self.send_compact_block(rejected_txs, indices)\n+        assert_equal(result[\"missing_indices\"], indices)\n+        self.log.info(f\"âœ“ All {buffersize} transactions are missing (extra txn pool disabled)\")\n+\n+    def test_extratxnpool_capacity(self):\n+        \"\"\"Test extra transaction pool capacity transactions.\"\"\"\n+        self.log.info(\"Testing extra transaction pool capacity (50 transactions)...\")\n+\n+        buffersize = 50\n+        self.restart_node_with_limit(count=buffersize)\n+\n+        rejected_txs = self.populate_extra_pool(buffersize)\n+\n+        indices = list(range(buffersize))\n+        result = self.send_compact_block(rejected_txs, indices)\n+\n+        assert_equal(result[\"missing_indices\"], [])\n+        self.log.info(\"âœ“ All rejected transactions are in the extra txn pool\")\n+\n+        # Test that adding a 51st transaction causes eviction\n+        self.log.info(\"Adding transaction to test eviction...\")\n+        self.populate_extra_pool(1)\n+\n+        # Check original transactions again - first one should be evicted\n+        result2 = self.send_compact_block(rejected_txs, indices)\n+        assert_equal(result2[\"missing_indices\"], [0])\n+        self.log.info(\"âœ“ Transaction 0 was evicted as expected\")\n+\n+    def test_single_extratxnpool_capacity(self):\n+        \"\"\"Test edge case of single capacity extra transaction pool.\"\"\"\n+        self.log.info(\"Testing single capacity extra transaction pool...\")\n+\n+        self.restart_node_with_limit(count=1)\n+        tx_count = 5\n+\n+        rejected_txs = self.populate_extra_pool(tx_count)\n+\n+        indices = list(range(tx_count))\n+        result = self.send_compact_block(rejected_txs, indices)\n+\n+        expected_missing = list(range(4))\n+        assert_equal(result[\"missing_indices\"], expected_missing)\n+\n+    def test_extratxn_large_capacity(self):\n+        \"\"\"Test extra transaction pool with very large count parameter.\"\"\"\n+        self.log.info(\"Testing with count=400 to ensure large buffers work correctly...\")\n+\n+        buffersize = 400\n+        self.restart_node_with_limit(count=buffersize)\n+\n+        rejected_txs = self.populate_extra_pool(buffersize)\n+\n+        indices = list(range(buffersize))\n+        result = self.send_compact_block(rejected_txs, indices)\n+\n+        assert_equal(result[\"missing_indices\"], [])\n+        self.log.info(\"âœ“ All rejected transactions are in the extra txn pool\")\n+\n+        # Test that adding a transaction causes eviction\n+        self.log.info(\"Adding another transaction to test eviction...\")\n+        self.populate_extra_pool(1)\n+\n+        # Check original transactions again - first one should be evicted\n+        result2 = self.send_compact_block(rejected_txs, indices)\n+        assert_equal(result2[\"missing_indices\"], [0])\n+        self.log.info(\"âœ“ Transaction 0 was evicted as expected\")\n+\n+    def test_extratxn_buffer_wraparound(self):\n+        \"\"\"Test that adding transactions to a full buffer evicts oldest slots.\"\"\"\n+        self.log.info(\"Testing extratxn buffer wraparound - fill buffer then add more...\")\n+\n+        buffersize = 20\n+\n+        new_tx_count = 17\n+        self.restart_node_with_limit(count=buffersize)\n+\n+        # Step 1: Fill the buffer with rejected transactions\n+        rejected_txs = self.populate_extra_pool(buffersize)\n+\n+        # Verify all rejected transactions are in the extra pool\n+        indices = list(range(buffersize))\n+        result = self.send_compact_block(rejected_txs, indices)\n+        assert_equal(result[\"missing_indices\"], [])\n+        self.log.info(\"âœ“ All rejected transactions are in the extra pool\")\n+\n+        # Step 2: Add more rejected transactions\n+        self.log.info(f\"Step 2: Adding {new_tx_count} more rejected transactions (should wrap and evict slots 0-{new_tx_count-1})\")\n+        self.populate_extra_pool(new_tx_count)\n+\n+        result2 = self.send_compact_block(rejected_txs, indices)\n+\n+        # Verify wraparound worked correctly - first new_tx_count should be evicted\n+        expected_missing = list(range(new_tx_count))\n+        assert_equal(result2['missing_indices'], expected_missing)\n+        self.log.info(f\"âœ“ Wraparound worked correctly! Transactions {expected_missing} were evicted as expected\")\n+\n+    def test_extratxn_minimal_capacity_eviction(self):\n+        \"\"\"Test frequent eviction with minimal capacity.\"\"\"\n+        self.log.info(\"Testing minimal capacity eviction with count=2...\")\n+\n+        self.restart_node_with_limit(count=2)\n+\n+        # Add 10 rejected transactions to stress eviction\n+        num_txs = 10\n+        rejected_txs = self.populate_extra_pool(num_txs)\n+\n+        # Only the last 2 should remain\n+        # Try to reconstruct with all 10\n+        indices = list(range(num_txs))\n+        result = self.send_compact_block(rejected_txs, indices)\n+\n+        # First 8 should be missing (evicted)\n+        expected_missing = list(range(8))\n+        assert_equal(result[\"missing_indices\"], expected_missing)\n+\n+    def test_extratxn_invalid_parameters(self):\n+        \"\"\"Test handling of invalid blockreconstructionextratxn values.\"\"\"\n+        self.log.info(\"Testing invalid parameter values...\")\n+\n+        # Test negative value - should be clamped to 0 (disabled)\n+        self.log.info(\"Testing negative value (-1)...\")\n+        self.restart_node_with_limit(count=-1)\n+\n+        # Add a transaction and verify pool is disabled\n+        rejected_txs = self.populate_extra_pool(1)\n+        result = self.send_compact_block(rejected_txs, [0])\n+        assert_equal(result[\"missing_indices\"], [0])\n+\n+        # Test extremely large value\n+        self.log.info(\"Testing large value (100000)...\")\n+        self.restart_node_with_limit(count=100000)  # Very large but reasonable\n+\n+        # Add some transactions - should work but be clamped\n+        rejected_txs = self.populate_extra_pool(10)\n+        result = self.send_compact_block(rejected_txs, list(range(10)))\n+        assert_equal(result[\"missing_indices\"], [])",
      "path": "test/functional/p2p_compactblocks_extratxs.py",
      "position": 1,
      "original_position": 390,
      "commit_id": "f9c6331cb26f3bafc3dba7f5a72622a9ff4f190d",
      "original_commit_id": "bd1c6b4ea9b94ab4b2604f2a4b8a7fd1fe55c92a",
      "in_reply_to_id": 2299227722,
      "user": {
        "login": "bigshiny90",
        "id": 23282055,
        "node_id": "MDQ6VXNlcjIzMjgyMDU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23282055?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigshiny90",
        "html_url": "https://github.com/bigshiny90",
        "followers_url": "https://api.github.com/users/bigshiny90/followers",
        "following_url": "https://api.github.com/users/bigshiny90/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigshiny90/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigshiny90/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigshiny90/subscriptions",
        "organizations_url": "https://api.github.com/users/bigshiny90/orgs",
        "repos_url": "https://api.github.com/users/bigshiny90/repos",
        "events_url": "https://api.github.com/users/bigshiny90/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigshiny90/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "removed.  now just tests for invalid capacity -1",
      "created_at": "2025-08-25T23:41:49Z",
      "updated_at": "2025-08-25T23:41:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33023#discussion_r2299367679",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2299367679"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33023"
        }
      },
      "start_line": null,
      "original_start_line": 383,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 390,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2299369204",
      "pull_request_review_id": 3153340458,
      "id": 2299369204,
      "node_id": "PRRC_kwDOABII586JDZb0",
      "diff_hunk": "@@ -0,0 +1,422 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2025 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test blockreconstructionextratxn option with compact blocks.\"\"\"\n+\n+from test_framework.blocktools import (\n+    COINBASE_MATURITY,\n+    NORMAL_GBT_REQUEST_PARAMS,\n+    create_block,\n+    add_witness_commitment,\n+)\n+from test_framework.messages import (\n+    CTxOut,\n+    HeaderAndShortIDs,\n+    MSG_BLOCK,\n+    msg_cmpctblock,\n+    msg_sendcmpct,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+    p2p_lock,\n+)\n+from test_framework.script import (\n+    CScript,\n+    OP_TRUE,\n+)\n+from test_framework.script_util import (\n+    keys_to_multisig_script,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    softfork_active,\n+)\n+from decimal import Decimal\n+from test_framework.wallet import MiniWallet\n+\n+\n+# TestP2PConn: A peer we use to send messages to bitcoind, and store responses.\n+class TestP2PConn(P2PInterface):\n+    def __init__(self):\n+        super().__init__()\n+        self.last_sendcmpct = []\n+        self.block_announced = False\n+        # Store the hashes of blocks we've seen announced.\n+        # This is for synchronizing the p2p message traffic,\n+        # so we can eg wait until a particular block is announced.\n+        self.announced_blockhashes = set()\n+\n+    def on_sendcmpct(self, message):\n+        self.last_sendcmpct.append(message)\n+\n+    def on_cmpctblock(self, message):\n+        self.block_announced = True\n+        self.last_message[\"cmpctblock\"].header_and_shortids.header.calc_sha256()\n+        self.announced_blockhashes.add(self.last_message[\"cmpctblock\"].header_and_shortids.header.sha256)\n+\n+    def on_headers(self, message):\n+        self.block_announced = True\n+        for x in self.last_message[\"headers\"].headers:\n+            x.calc_sha256()\n+            self.announced_blockhashes.add(x.sha256)\n+\n+    def on_inv(self, message):\n+        for x in self.last_message[\"inv\"].inv:\n+            if x.type == MSG_BLOCK:\n+                self.block_announced = True\n+                self.announced_blockhashes.add(x.hash)\n+\n+    # Requires caller to hold p2p_lock\n+    def received_block_announcement(self):\n+        return self.block_announced\n+\n+    def clear_block_announcement(self):\n+        with p2p_lock:\n+            self.block_announced = False\n+            self.last_message.pop(\"inv\", None)\n+            self.last_message.pop(\"headers\", None)\n+            self.last_message.pop(\"cmpctblock\", None)\n+\n+    def clear_getblocktxn(self):\n+        with p2p_lock:\n+            self.last_message.pop(\"getblocktxn\", None)\n+\n+\n+class CompactBlocksBlockReconstructionLimitTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+        self.extra_args = [[\n+            \"-acceptnonstdtxn=0\",\n+            \"-debug=net\",\n+        ]]\n+        self.utxos = []\n+\n+    def build_block_on_tip(self, node):\n+        \"\"\"Build a block on top of the current tip.\"\"\"\n+        block = create_block(tmpl=node.getblocktemplate(NORMAL_GBT_REQUEST_PARAMS))\n+        block.solve()\n+        return block\n+\n+    def make_utxos(self):\n+        \"\"\"Generate blocks to create UTXOs for the wallet.\"\"\"\n+        self.generate(self.wallet, COINBASE_MATURITY + 800)\n+\n+    def restart_node_with_limit(self, count=None):\n+        \"\"\"Restart node with specific count limit.\"\"\"\n+        extra_args = [\"-acceptnonstdtxn=0\", \"-debug=net\"]\n+\n+        if count is not None:\n+            self.log.info(f\"Setting transaction count limit: {count}\")\n+            extra_args.append(f\"-blockreconstructionextratxn={count}\")\n+\n+        self.log.info(f\"Restarting node with args: {extra_args}\")\n+        self.restart_node(0, extra_args=extra_args)\n+        self.segwit_node = self.nodes[0].add_p2p_connection(TestP2PConn())\n+        self.segwit_node.send_and_ping(msg_sendcmpct(announce=True, version=2))\n+\n+    def create_policy_rejected_tx(self, rejection_type=\"dust\"):\n+        \"\"\"Create a transaction that will be rejected for policy reasons but added to extra pool.\"\"\"\n+\n+        if rejection_type == \"dust\":\n+            tx_info = self.wallet.create_self_transfer()\n+            dust_amount = 100\n+            dust_script = CScript([OP_TRUE])\n+            tx_info['tx'].vout.append(CTxOut(dust_amount, dust_script))\n+            tx_info['tx'].vout[0].nValue -= dust_amount\n+\n+        elif rejection_type == \"low_fee\":\n+            tx_info = self.wallet.create_self_transfer(fee_rate=Decimal('0.00000100'))\n+\n+        elif rejection_type == \"nonstandard_script\":\n+            tx_info = self.wallet.create_self_transfer()\n+            pubkeys = []\n+            for _ in range(4):\n+                pubkeys.append(bytes([0x02] + [0x00] * 32))\n+            multisig_script = keys_to_multisig_script(pubkeys, k=4)\n+            tx_info['tx'].vout.append(CTxOut(10000, multisig_script))\n+            tx_info['tx'].vout[0].nValue -= 10000\n+\n+        else:\n+            raise ValueError(f\"Unknown rejection type: {rejection_type}\")\n+\n+        tx_info['hex'] = tx_info['tx'].serialize().hex()\n+        return tx_info\n+\n+    def populate_extra_pool(self, num_txs, rejection_type=\"dust\"):\n+        \"\"\"Populate the extra transaction pool using policy-rejected transactions.\"\"\"\n+        rejected_txs = []\n+\n+        for i in range(num_txs):\n+            tx_info = self.create_policy_rejected_tx(rejection_type)\n+            tx_obj = tx_from_hex(tx_info['hex'])\n+            self.segwit_node.send_without_ping(msg_tx(tx_obj))\n+            rejected_txs.append(tx_info)\n+\n+        self.segwit_node.sync_with_ping()\n+\n+        return rejected_txs\n+\n+    def send_compact_block(self, transactions, indices):\n+        \"\"\"Send a compact block and check which transactions are requested for reconstruction.\"\"\"\n+        node = self.nodes[0]\n+\n+        # Build block\n+        block = self.build_block_on_tip(node)\n+\n+        for i in indices:\n+            tx_obj = tx_from_hex(transactions[i]['hex'])\n+            block.vtx.append(tx_obj)\n+\n+        # Add witness commitment for blocks with witness transactions\n+        add_witness_commitment(block)\n+        block.solve()\n+\n+        # Send as compact block\n+        cmpct_block = HeaderAndShortIDs()\n+        cmpct_block.initialize_from_block(block, use_witness=True)\n+        self.segwit_node.send_and_ping(msg_cmpctblock(cmpct_block.to_p2p()))\n+\n+        # Check if node requested missing transactions\n+        with p2p_lock:\n+            getblocktxn = self.segwit_node.last_message.get(\"getblocktxn\")\n+\n+        num_tx_requested = len(getblocktxn.block_txn_request.indexes) if getblocktxn else 0\n+        self.segwit_node.clear_getblocktxn()\n+\n+        # Convert differential encoding to absolute indices (from BlockTransactionRequest)\n+        missing_indices = []\n+        if getblocktxn:\n+            absolute_block_indices = getblocktxn.block_txn_request.to_absolute()\n+            # Convert from block positions to transaction indices (subtract 1 for coinbase)\n+            missing_indices = [idx - 1 for idx in absolute_block_indices]\n+\n+        return {\n+            \"block\": block,\n+            \"getblocktxn\": getblocktxn,\n+            \"num_tx_requested\": num_tx_requested,\n+            \"missing_indices\": missing_indices\n+        }\n+\n+    # TEST: policy-rejected transactions\n+\n+    def test_policy_rejection_types(self):\n+        \"\"\"Test that each policy rejection type adds transactions to extra pool.\"\"\"\n+        self.log.info(\"Testing policy rejection types for extra pool...\")\n+\n+        self.restart_node_with_limit(count=100)\n+\n+        rejection_types = [\"dust\", \"low_fee\", \"nonstandard_script\"]\n+        rejected_txs = []\n+\n+        for rejection_type in rejection_types:\n+            self.log.info(f\"Testing {rejection_type} rejection...\")\n+            tx_info = self.create_policy_rejected_tx(rejection_type)\n+\n+            tx_obj = tx_from_hex(tx_info['hex'])\n+            self.segwit_node.send_without_ping(msg_tx(tx_obj))\n+\n+            rejected_txs.append({\n+                'type': rejection_type,\n+                'tx_info': tx_info,\n+                'txid': tx_info['tx'].txid_hex\n+            })\n+\n+        self.segwit_node.sync_with_ping()\n+\n+        mempool = self.nodes[0].getrawmempool()\n+        for rejected in rejected_txs:\n+            assert_equal(rejected['txid'] in mempool, False)\n+            self.log.info(f\"âœ“ {rejected['type']} transaction rejected from mempool\")\n+\n+        indices = list(range(len(rejected_txs)))\n+        tx_list = [r['tx_info'] for r in rejected_txs]\n+\n+        result = self.send_compact_block(tx_list, indices)\n+\n+        assert_equal(result[\"missing_indices\"], [])\n+        self.log.info(\"âœ“ All rejected transactions are available in extra pool\")\n+\n+    # TEST: blockreconstructionextratxn\n+\n+    def test_extratxnpool_disabled(self):\n+        \"\"\"Test that setting count to 0 disables the extra transaction pool.\"\"\"\n+        self.log.info(\"Testing disabled extra transaction pool (0 capacity)...\")\n+\n+        self.restart_node_with_limit(count=0)\n+        buffersize = 5\n+        rejected_txs = self.populate_extra_pool(buffersize)\n+\n+        indices = list(range(buffersize))\n+        result = self.send_compact_block(rejected_txs, indices)\n+        assert_equal(result[\"missing_indices\"], indices)\n+        self.log.info(f\"âœ“ All {buffersize} transactions are missing (extra txn pool disabled)\")\n+\n+    def test_extratxnpool_capacity(self):\n+        \"\"\"Test extra transaction pool capacity transactions.\"\"\"\n+        self.log.info(\"Testing extra transaction pool capacity (50 transactions)...\")\n+\n+        buffersize = 50\n+        self.restart_node_with_limit(count=buffersize)\n+\n+        rejected_txs = self.populate_extra_pool(buffersize)\n+\n+        indices = list(range(buffersize))\n+        result = self.send_compact_block(rejected_txs, indices)\n+\n+        assert_equal(result[\"missing_indices\"], [])\n+        self.log.info(\"âœ“ All rejected transactions are in the extra txn pool\")\n+\n+        # Test that adding a 51st transaction causes eviction\n+        self.log.info(\"Adding transaction to test eviction...\")\n+        self.populate_extra_pool(1)\n+\n+        # Check original transactions again - first one should be evicted\n+        result2 = self.send_compact_block(rejected_txs, indices)\n+        assert_equal(result2[\"missing_indices\"], [0])\n+        self.log.info(\"âœ“ Transaction 0 was evicted as expected\")\n+\n+    def test_single_extratxnpool_capacity(self):\n+        \"\"\"Test edge case of single capacity extra transaction pool.\"\"\"\n+        self.log.info(\"Testing single capacity extra transaction pool...\")\n+\n+        self.restart_node_with_limit(count=1)\n+        tx_count = 5\n+\n+        rejected_txs = self.populate_extra_pool(tx_count)\n+\n+        indices = list(range(tx_count))\n+        result = self.send_compact_block(rejected_txs, indices)\n+\n+        expected_missing = list(range(4))\n+        assert_equal(result[\"missing_indices\"], expected_missing)\n+\n+    def test_extratxn_large_capacity(self):\n+        \"\"\"Test extra transaction pool with very large count parameter.\"\"\"\n+        self.log.info(\"Testing with count=400 to ensure large buffers work correctly...\")\n+\n+        buffersize = 400\n+        self.restart_node_with_limit(count=buffersize)\n+\n+        rejected_txs = self.populate_extra_pool(buffersize)\n+\n+        indices = list(range(buffersize))\n+        result = self.send_compact_block(rejected_txs, indices)\n+\n+        assert_equal(result[\"missing_indices\"], [])\n+        self.log.info(\"âœ“ All rejected transactions are in the extra txn pool\")\n+\n+        # Test that adding a transaction causes eviction\n+        self.log.info(\"Adding another transaction to test eviction...\")\n+        self.populate_extra_pool(1)\n+\n+        # Check original transactions again - first one should be evicted\n+        result2 = self.send_compact_block(rejected_txs, indices)\n+        assert_equal(result2[\"missing_indices\"], [0])\n+        self.log.info(\"âœ“ Transaction 0 was evicted as expected\")\n+\n+    def test_extratxn_buffer_wraparound(self):\n+        \"\"\"Test that adding transactions to a full buffer evicts oldest slots.\"\"\"\n+        self.log.info(\"Testing extratxn buffer wraparound - fill buffer then add more...\")\n+\n+        buffersize = 20\n+\n+        new_tx_count = 17\n+        self.restart_node_with_limit(count=buffersize)\n+\n+        # Step 1: Fill the buffer with rejected transactions\n+        rejected_txs = self.populate_extra_pool(buffersize)\n+\n+        # Verify all rejected transactions are in the extra pool\n+        indices = list(range(buffersize))\n+        result = self.send_compact_block(rejected_txs, indices)\n+        assert_equal(result[\"missing_indices\"], [])\n+        self.log.info(\"âœ“ All rejected transactions are in the extra pool\")\n+\n+        # Step 2: Add more rejected transactions\n+        self.log.info(f\"Step 2: Adding {new_tx_count} more rejected transactions (should wrap and evict slots 0-{new_tx_count-1})\")\n+        self.populate_extra_pool(new_tx_count)\n+\n+        result2 = self.send_compact_block(rejected_txs, indices)\n+\n+        # Verify wraparound worked correctly - first new_tx_count should be evicted\n+        expected_missing = list(range(new_tx_count))\n+        assert_equal(result2['missing_indices'], expected_missing)\n+        self.log.info(f\"âœ“ Wraparound worked correctly! Transactions {expected_missing} were evicted as expected\")\n+\n+    def test_extratxn_minimal_capacity_eviction(self):\n+        \"\"\"Test frequent eviction with minimal capacity.\"\"\"\n+        self.log.info(\"Testing minimal capacity eviction with count=2...\")\n+\n+        self.restart_node_with_limit(count=2)\n+\n+        # Add 10 rejected transactions to stress eviction\n+        num_txs = 10\n+        rejected_txs = self.populate_extra_pool(num_txs)\n+\n+        # Only the last 2 should remain\n+        # Try to reconstruct with all 10\n+        indices = list(range(num_txs))\n+        result = self.send_compact_block(rejected_txs, indices)\n+\n+        # First 8 should be missing (evicted)\n+        expected_missing = list(range(8))",
      "path": "test/functional/p2p_compactblocks_extratxs.py",
      "position": 1,
      "original_position": 367,
      "commit_id": "f9c6331cb26f3bafc3dba7f5a72622a9ff4f190d",
      "original_commit_id": "bd1c6b4ea9b94ab4b2604f2a4b8a7fd1fe55c92a",
      "in_reply_to_id": 2299231394,
      "user": {
        "login": "bigshiny90",
        "id": 23282055,
        "node_id": "MDQ6VXNlcjIzMjgyMDU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23282055?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigshiny90",
        "html_url": "https://github.com/bigshiny90",
        "followers_url": "https://api.github.com/users/bigshiny90/followers",
        "following_url": "https://api.github.com/users/bigshiny90/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigshiny90/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigshiny90/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigshiny90/subscriptions",
        "organizations_url": "https://api.github.com/users/bigshiny90/orgs",
        "repos_url": "https://api.github.com/users/bigshiny90/repos",
        "events_url": "https://api.github.com/users/bigshiny90/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigshiny90/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "done",
      "created_at": "2025-08-25T23:43:15Z",
      "updated_at": "2025-08-25T23:43:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33023#discussion_r2299369204",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2299369204"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33023"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 367,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2299369564",
      "pull_request_review_id": 3153340834,
      "id": 2299369564,
      "node_id": "PRRC_kwDOABII586JDZhc",
      "diff_hunk": "@@ -0,0 +1,422 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2025 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test blockreconstructionextratxn option with compact blocks.\"\"\"\n+\n+from test_framework.blocktools import (\n+    COINBASE_MATURITY,\n+    NORMAL_GBT_REQUEST_PARAMS,\n+    create_block,\n+    add_witness_commitment,\n+)\n+from test_framework.messages import (\n+    CTxOut,\n+    HeaderAndShortIDs,\n+    MSG_BLOCK,\n+    msg_cmpctblock,\n+    msg_sendcmpct,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+    p2p_lock,\n+)\n+from test_framework.script import (\n+    CScript,\n+    OP_TRUE,\n+)\n+from test_framework.script_util import (\n+    keys_to_multisig_script,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    softfork_active,\n+)\n+from decimal import Decimal\n+from test_framework.wallet import MiniWallet\n+\n+\n+# TestP2PConn: A peer we use to send messages to bitcoind, and store responses.\n+class TestP2PConn(P2PInterface):\n+    def __init__(self):\n+        super().__init__()\n+        self.last_sendcmpct = []\n+        self.block_announced = False\n+        # Store the hashes of blocks we've seen announced.\n+        # This is for synchronizing the p2p message traffic,\n+        # so we can eg wait until a particular block is announced.\n+        self.announced_blockhashes = set()\n+\n+    def on_sendcmpct(self, message):\n+        self.last_sendcmpct.append(message)\n+\n+    def on_cmpctblock(self, message):\n+        self.block_announced = True\n+        self.last_message[\"cmpctblock\"].header_and_shortids.header.calc_sha256()\n+        self.announced_blockhashes.add(self.last_message[\"cmpctblock\"].header_and_shortids.header.sha256)\n+\n+    def on_headers(self, message):\n+        self.block_announced = True\n+        for x in self.last_message[\"headers\"].headers:\n+            x.calc_sha256()\n+            self.announced_blockhashes.add(x.sha256)\n+\n+    def on_inv(self, message):\n+        for x in self.last_message[\"inv\"].inv:\n+            if x.type == MSG_BLOCK:\n+                self.block_announced = True\n+                self.announced_blockhashes.add(x.hash)\n+\n+    # Requires caller to hold p2p_lock\n+    def received_block_announcement(self):\n+        return self.block_announced\n+\n+    def clear_block_announcement(self):\n+        with p2p_lock:\n+            self.block_announced = False\n+            self.last_message.pop(\"inv\", None)\n+            self.last_message.pop(\"headers\", None)\n+            self.last_message.pop(\"cmpctblock\", None)\n+\n+    def clear_getblocktxn(self):\n+        with p2p_lock:\n+            self.last_message.pop(\"getblocktxn\", None)\n+\n+\n+class CompactBlocksBlockReconstructionLimitTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+        self.extra_args = [[\n+            \"-acceptnonstdtxn=0\",\n+            \"-debug=net\",\n+        ]]\n+        self.utxos = []\n+\n+    def build_block_on_tip(self, node):\n+        \"\"\"Build a block on top of the current tip.\"\"\"\n+        block = create_block(tmpl=node.getblocktemplate(NORMAL_GBT_REQUEST_PARAMS))\n+        block.solve()\n+        return block\n+\n+    def make_utxos(self):\n+        \"\"\"Generate blocks to create UTXOs for the wallet.\"\"\"\n+        self.generate(self.wallet, COINBASE_MATURITY + 800)\n+\n+    def restart_node_with_limit(self, count=None):\n+        \"\"\"Restart node with specific count limit.\"\"\"\n+        extra_args = [\"-acceptnonstdtxn=0\", \"-debug=net\"]\n+\n+        if count is not None:\n+            self.log.info(f\"Setting transaction count limit: {count}\")\n+            extra_args.append(f\"-blockreconstructionextratxn={count}\")\n+\n+        self.log.info(f\"Restarting node with args: {extra_args}\")\n+        self.restart_node(0, extra_args=extra_args)\n+        self.segwit_node = self.nodes[0].add_p2p_connection(TestP2PConn())\n+        self.segwit_node.send_and_ping(msg_sendcmpct(announce=True, version=2))\n+\n+    def create_policy_rejected_tx(self, rejection_type=\"dust\"):\n+        \"\"\"Create a transaction that will be rejected for policy reasons but added to extra pool.\"\"\"\n+\n+        if rejection_type == \"dust\":\n+            tx_info = self.wallet.create_self_transfer()\n+            dust_amount = 100\n+            dust_script = CScript([OP_TRUE])\n+            tx_info['tx'].vout.append(CTxOut(dust_amount, dust_script))\n+            tx_info['tx'].vout[0].nValue -= dust_amount\n+\n+        elif rejection_type == \"low_fee\":\n+            tx_info = self.wallet.create_self_transfer(fee_rate=Decimal('0.00000100'))\n+\n+        elif rejection_type == \"nonstandard_script\":\n+            tx_info = self.wallet.create_self_transfer()\n+            pubkeys = []\n+            for _ in range(4):\n+                pubkeys.append(bytes([0x02] + [0x00] * 32))\n+            multisig_script = keys_to_multisig_script(pubkeys, k=4)\n+            tx_info['tx'].vout.append(CTxOut(10000, multisig_script))\n+            tx_info['tx'].vout[0].nValue -= 10000\n+\n+        else:\n+            raise ValueError(f\"Unknown rejection type: {rejection_type}\")\n+\n+        tx_info['hex'] = tx_info['tx'].serialize().hex()\n+        return tx_info\n+\n+    def populate_extra_pool(self, num_txs, rejection_type=\"dust\"):\n+        \"\"\"Populate the extra transaction pool using policy-rejected transactions.\"\"\"\n+        rejected_txs = []\n+\n+        for i in range(num_txs):\n+            tx_info = self.create_policy_rejected_tx(rejection_type)\n+            tx_obj = tx_from_hex(tx_info['hex'])\n+            self.segwit_node.send_without_ping(msg_tx(tx_obj))\n+            rejected_txs.append(tx_info)\n+\n+        self.segwit_node.sync_with_ping()\n+\n+        return rejected_txs\n+\n+    def send_compact_block(self, transactions, indices):\n+        \"\"\"Send a compact block and check which transactions are requested for reconstruction.\"\"\"\n+        node = self.nodes[0]\n+\n+        # Build block\n+        block = self.build_block_on_tip(node)\n+\n+        for i in indices:\n+            tx_obj = tx_from_hex(transactions[i]['hex'])\n+            block.vtx.append(tx_obj)\n+\n+        # Add witness commitment for blocks with witness transactions\n+        add_witness_commitment(block)\n+        block.solve()\n+\n+        # Send as compact block\n+        cmpct_block = HeaderAndShortIDs()\n+        cmpct_block.initialize_from_block(block, use_witness=True)\n+        self.segwit_node.send_and_ping(msg_cmpctblock(cmpct_block.to_p2p()))\n+\n+        # Check if node requested missing transactions\n+        with p2p_lock:\n+            getblocktxn = self.segwit_node.last_message.get(\"getblocktxn\")\n+\n+        num_tx_requested = len(getblocktxn.block_txn_request.indexes) if getblocktxn else 0\n+        self.segwit_node.clear_getblocktxn()\n+\n+        # Convert differential encoding to absolute indices (from BlockTransactionRequest)\n+        missing_indices = []\n+        if getblocktxn:\n+            absolute_block_indices = getblocktxn.block_txn_request.to_absolute()\n+            # Convert from block positions to transaction indices (subtract 1 for coinbase)\n+            missing_indices = [idx - 1 for idx in absolute_block_indices]\n+\n+        return {\n+            \"block\": block,\n+            \"getblocktxn\": getblocktxn,\n+            \"num_tx_requested\": num_tx_requested,\n+            \"missing_indices\": missing_indices\n+        }\n+\n+    # TEST: policy-rejected transactions\n+\n+    def test_policy_rejection_types(self):\n+        \"\"\"Test that each policy rejection type adds transactions to extra pool.\"\"\"\n+        self.log.info(\"Testing policy rejection types for extra pool...\")\n+\n+        self.restart_node_with_limit(count=100)\n+\n+        rejection_types = [\"dust\", \"low_fee\", \"nonstandard_script\"]\n+        rejected_txs = []\n+\n+        for rejection_type in rejection_types:\n+            self.log.info(f\"Testing {rejection_type} rejection...\")\n+            tx_info = self.create_policy_rejected_tx(rejection_type)\n+\n+            tx_obj = tx_from_hex(tx_info['hex'])\n+            self.segwit_node.send_without_ping(msg_tx(tx_obj))\n+\n+            rejected_txs.append({\n+                'type': rejection_type,\n+                'tx_info': tx_info,\n+                'txid': tx_info['tx'].txid_hex\n+            })\n+\n+        self.segwit_node.sync_with_ping()\n+\n+        mempool = self.nodes[0].getrawmempool()\n+        for rejected in rejected_txs:\n+            assert_equal(rejected['txid'] in mempool, False)\n+            self.log.info(f\"âœ“ {rejected['type']} transaction rejected from mempool\")\n+\n+        indices = list(range(len(rejected_txs)))\n+        tx_list = [r['tx_info'] for r in rejected_txs]\n+\n+        result = self.send_compact_block(tx_list, indices)\n+\n+        assert_equal(result[\"missing_indices\"], [])\n+        self.log.info(\"âœ“ All rejected transactions are available in extra pool\")\n+\n+    # TEST: blockreconstructionextratxn\n+\n+    def test_extratxnpool_disabled(self):\n+        \"\"\"Test that setting count to 0 disables the extra transaction pool.\"\"\"\n+        self.log.info(\"Testing disabled extra transaction pool (0 capacity)...\")\n+\n+        self.restart_node_with_limit(count=0)\n+        buffersize = 5\n+        rejected_txs = self.populate_extra_pool(buffersize)\n+\n+        indices = list(range(buffersize))\n+        result = self.send_compact_block(rejected_txs, indices)\n+        assert_equal(result[\"missing_indices\"], indices)\n+        self.log.info(f\"âœ“ All {buffersize} transactions are missing (extra txn pool disabled)\")\n+\n+    def test_extratxnpool_capacity(self):\n+        \"\"\"Test extra transaction pool capacity transactions.\"\"\"\n+        self.log.info(\"Testing extra transaction pool capacity (50 transactions)...\")\n+\n+        buffersize = 50\n+        self.restart_node_with_limit(count=buffersize)\n+\n+        rejected_txs = self.populate_extra_pool(buffersize)\n+\n+        indices = list(range(buffersize))\n+        result = self.send_compact_block(rejected_txs, indices)\n+\n+        assert_equal(result[\"missing_indices\"], [])\n+        self.log.info(\"âœ“ All rejected transactions are in the extra txn pool\")\n+\n+        # Test that adding a 51st transaction causes eviction\n+        self.log.info(\"Adding transaction to test eviction...\")\n+        self.populate_extra_pool(1)\n+\n+        # Check original transactions again - first one should be evicted\n+        result2 = self.send_compact_block(rejected_txs, indices)\n+        assert_equal(result2[\"missing_indices\"], [0])\n+        self.log.info(\"âœ“ Transaction 0 was evicted as expected\")\n+\n+    def test_single_extratxnpool_capacity(self):\n+        \"\"\"Test edge case of single capacity extra transaction pool.\"\"\"\n+        self.log.info(\"Testing single capacity extra transaction pool...\")\n+\n+        self.restart_node_with_limit(count=1)\n+        tx_count = 5\n+\n+        rejected_txs = self.populate_extra_pool(tx_count)\n+\n+        indices = list(range(tx_count))\n+        result = self.send_compact_block(rejected_txs, indices)\n+\n+        expected_missing = list(range(4))\n+        assert_equal(result[\"missing_indices\"], expected_missing)\n+\n+    def test_extratxn_large_capacity(self):\n+        \"\"\"Test extra transaction pool with very large count parameter.\"\"\"\n+        self.log.info(\"Testing with count=400 to ensure large buffers work correctly...\")\n+\n+        buffersize = 400\n+        self.restart_node_with_limit(count=buffersize)\n+\n+        rejected_txs = self.populate_extra_pool(buffersize)\n+\n+        indices = list(range(buffersize))\n+        result = self.send_compact_block(rejected_txs, indices)\n+\n+        assert_equal(result[\"missing_indices\"], [])\n+        self.log.info(\"âœ“ All rejected transactions are in the extra txn pool\")\n+\n+        # Test that adding a transaction causes eviction\n+        self.log.info(\"Adding another transaction to test eviction...\")\n+        self.populate_extra_pool(1)\n+\n+        # Check original transactions again - first one should be evicted\n+        result2 = self.send_compact_block(rejected_txs, indices)\n+        assert_equal(result2[\"missing_indices\"], [0])\n+        self.log.info(\"âœ“ Transaction 0 was evicted as expected\")\n+\n+    def test_extratxn_buffer_wraparound(self):\n+        \"\"\"Test that adding transactions to a full buffer evicts oldest slots.\"\"\"\n+        self.log.info(\"Testing extratxn buffer wraparound - fill buffer then add more...\")\n+\n+        buffersize = 20\n+\n+        new_tx_count = 17\n+        self.restart_node_with_limit(count=buffersize)\n+\n+        # Step 1: Fill the buffer with rejected transactions\n+        rejected_txs = self.populate_extra_pool(buffersize)\n+\n+        # Verify all rejected transactions are in the extra pool\n+        indices = list(range(buffersize))\n+        result = self.send_compact_block(rejected_txs, indices)\n+        assert_equal(result[\"missing_indices\"], [])\n+        self.log.info(\"âœ“ All rejected transactions are in the extra pool\")\n+\n+        # Step 2: Add more rejected transactions\n+        self.log.info(f\"Step 2: Adding {new_tx_count} more rejected transactions (should wrap and evict slots 0-{new_tx_count-1})\")\n+        self.populate_extra_pool(new_tx_count)\n+\n+        result2 = self.send_compact_block(rejected_txs, indices)\n+\n+        # Verify wraparound worked correctly - first new_tx_count should be evicted\n+        expected_missing = list(range(new_tx_count))\n+        assert_equal(result2['missing_indices'], expected_missing)\n+        self.log.info(f\"âœ“ Wraparound worked correctly! Transactions {expected_missing} were evicted as expected\")\n+\n+    def test_extratxn_minimal_capacity_eviction(self):",
      "path": "test/functional/p2p_compactblocks_extratxs.py",
      "position": 1,
      "original_position": 351,
      "commit_id": "f9c6331cb26f3bafc3dba7f5a72622a9ff4f190d",
      "original_commit_id": "bd1c6b4ea9b94ab4b2604f2a4b8a7fd1fe55c92a",
      "in_reply_to_id": 2299239940,
      "user": {
        "login": "bigshiny90",
        "id": 23282055,
        "node_id": "MDQ6VXNlcjIzMjgyMDU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23282055?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigshiny90",
        "html_url": "https://github.com/bigshiny90",
        "followers_url": "https://api.github.com/users/bigshiny90/followers",
        "following_url": "https://api.github.com/users/bigshiny90/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigshiny90/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigshiny90/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigshiny90/subscriptions",
        "organizations_url": "https://api.github.com/users/bigshiny90/orgs",
        "repos_url": "https://api.github.com/users/bigshiny90/repos",
        "events_url": "https://api.github.com/users/bigshiny90/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigshiny90/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "yes, removed redundant test - test_extratxn_minimal_capacity_eviction",
      "created_at": "2025-08-25T23:43:34Z",
      "updated_at": "2025-08-25T23:46:28Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33023#discussion_r2299369564",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2299369564"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33023"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 351,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2299372290",
      "pull_request_review_id": 3153346260,
      "id": 2299372290,
      "node_id": "PRRC_kwDOABII586JDaMC",
      "diff_hunk": "@@ -0,0 +1,422 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2025 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test blockreconstructionextratxn option with compact blocks.\"\"\"\n+\n+from test_framework.blocktools import (\n+    COINBASE_MATURITY,\n+    NORMAL_GBT_REQUEST_PARAMS,\n+    create_block,\n+    add_witness_commitment,\n+)\n+from test_framework.messages import (\n+    CTxOut,\n+    HeaderAndShortIDs,\n+    MSG_BLOCK,\n+    msg_cmpctblock,\n+    msg_sendcmpct,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+    p2p_lock,\n+)\n+from test_framework.script import (\n+    CScript,\n+    OP_TRUE,\n+)\n+from test_framework.script_util import (\n+    keys_to_multisig_script,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    softfork_active,\n+)\n+from decimal import Decimal\n+from test_framework.wallet import MiniWallet\n+\n+\n+# TestP2PConn: A peer we use to send messages to bitcoind, and store responses.\n+class TestP2PConn(P2PInterface):\n+    def __init__(self):\n+        super().__init__()\n+        self.last_sendcmpct = []\n+        self.block_announced = False\n+        # Store the hashes of blocks we've seen announced.\n+        # This is for synchronizing the p2p message traffic,\n+        # so we can eg wait until a particular block is announced.\n+        self.announced_blockhashes = set()\n+\n+    def on_sendcmpct(self, message):\n+        self.last_sendcmpct.append(message)\n+\n+    def on_cmpctblock(self, message):\n+        self.block_announced = True\n+        self.last_message[\"cmpctblock\"].header_and_shortids.header.calc_sha256()\n+        self.announced_blockhashes.add(self.last_message[\"cmpctblock\"].header_and_shortids.header.sha256)\n+\n+    def on_headers(self, message):\n+        self.block_announced = True\n+        for x in self.last_message[\"headers\"].headers:\n+            x.calc_sha256()\n+            self.announced_blockhashes.add(x.sha256)\n+\n+    def on_inv(self, message):\n+        for x in self.last_message[\"inv\"].inv:\n+            if x.type == MSG_BLOCK:\n+                self.block_announced = True\n+                self.announced_blockhashes.add(x.hash)\n+\n+    # Requires caller to hold p2p_lock\n+    def received_block_announcement(self):\n+        return self.block_announced\n+\n+    def clear_block_announcement(self):\n+        with p2p_lock:\n+            self.block_announced = False\n+            self.last_message.pop(\"inv\", None)\n+            self.last_message.pop(\"headers\", None)\n+            self.last_message.pop(\"cmpctblock\", None)\n+\n+    def clear_getblocktxn(self):\n+        with p2p_lock:\n+            self.last_message.pop(\"getblocktxn\", None)\n+\n+\n+class CompactBlocksBlockReconstructionLimitTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+        self.extra_args = [[\n+            \"-acceptnonstdtxn=0\",\n+            \"-debug=net\",\n+        ]]\n+        self.utxos = []\n+\n+    def build_block_on_tip(self, node):\n+        \"\"\"Build a block on top of the current tip.\"\"\"\n+        block = create_block(tmpl=node.getblocktemplate(NORMAL_GBT_REQUEST_PARAMS))\n+        block.solve()\n+        return block\n+\n+    def make_utxos(self):\n+        \"\"\"Generate blocks to create UTXOs for the wallet.\"\"\"\n+        self.generate(self.wallet, COINBASE_MATURITY + 800)\n+\n+    def restart_node_with_limit(self, count=None):\n+        \"\"\"Restart node with specific count limit.\"\"\"\n+        extra_args = [\"-acceptnonstdtxn=0\", \"-debug=net\"]\n+\n+        if count is not None:\n+            self.log.info(f\"Setting transaction count limit: {count}\")\n+            extra_args.append(f\"-blockreconstructionextratxn={count}\")\n+\n+        self.log.info(f\"Restarting node with args: {extra_args}\")\n+        self.restart_node(0, extra_args=extra_args)\n+        self.segwit_node = self.nodes[0].add_p2p_connection(TestP2PConn())\n+        self.segwit_node.send_and_ping(msg_sendcmpct(announce=True, version=2))\n+\n+    def create_policy_rejected_tx(self, rejection_type=\"dust\"):\n+        \"\"\"Create a transaction that will be rejected for policy reasons but added to extra pool.\"\"\"\n+\n+        if rejection_type == \"dust\":\n+            tx_info = self.wallet.create_self_transfer()\n+            dust_amount = 100\n+            dust_script = CScript([OP_TRUE])\n+            tx_info['tx'].vout.append(CTxOut(dust_amount, dust_script))\n+            tx_info['tx'].vout[0].nValue -= dust_amount\n+\n+        elif rejection_type == \"low_fee\":\n+            tx_info = self.wallet.create_self_transfer(fee_rate=Decimal('0.00000100'))\n+\n+        elif rejection_type == \"nonstandard_script\":\n+            tx_info = self.wallet.create_self_transfer()\n+            pubkeys = []\n+            for _ in range(4):\n+                pubkeys.append(bytes([0x02] + [0x00] * 32))\n+            multisig_script = keys_to_multisig_script(pubkeys, k=4)\n+            tx_info['tx'].vout.append(CTxOut(10000, multisig_script))\n+            tx_info['tx'].vout[0].nValue -= 10000\n+\n+        else:\n+            raise ValueError(f\"Unknown rejection type: {rejection_type}\")\n+\n+        tx_info['hex'] = tx_info['tx'].serialize().hex()\n+        return tx_info\n+\n+    def populate_extra_pool(self, num_txs, rejection_type=\"dust\"):\n+        \"\"\"Populate the extra transaction pool using policy-rejected transactions.\"\"\"\n+        rejected_txs = []\n+\n+        for i in range(num_txs):\n+            tx_info = self.create_policy_rejected_tx(rejection_type)\n+            tx_obj = tx_from_hex(tx_info['hex'])\n+            self.segwit_node.send_without_ping(msg_tx(tx_obj))\n+            rejected_txs.append(tx_info)\n+\n+        self.segwit_node.sync_with_ping()\n+\n+        return rejected_txs\n+\n+    def send_compact_block(self, transactions, indices):\n+        \"\"\"Send a compact block and check which transactions are requested for reconstruction.\"\"\"\n+        node = self.nodes[0]\n+\n+        # Build block\n+        block = self.build_block_on_tip(node)\n+\n+        for i in indices:\n+            tx_obj = tx_from_hex(transactions[i]['hex'])\n+            block.vtx.append(tx_obj)\n+\n+        # Add witness commitment for blocks with witness transactions\n+        add_witness_commitment(block)\n+        block.solve()\n+\n+        # Send as compact block\n+        cmpct_block = HeaderAndShortIDs()\n+        cmpct_block.initialize_from_block(block, use_witness=True)\n+        self.segwit_node.send_and_ping(msg_cmpctblock(cmpct_block.to_p2p()))\n+\n+        # Check if node requested missing transactions\n+        with p2p_lock:\n+            getblocktxn = self.segwit_node.last_message.get(\"getblocktxn\")\n+\n+        num_tx_requested = len(getblocktxn.block_txn_request.indexes) if getblocktxn else 0\n+        self.segwit_node.clear_getblocktxn()\n+\n+        # Convert differential encoding to absolute indices (from BlockTransactionRequest)\n+        missing_indices = []\n+        if getblocktxn:\n+            absolute_block_indices = getblocktxn.block_txn_request.to_absolute()\n+            # Convert from block positions to transaction indices (subtract 1 for coinbase)\n+            missing_indices = [idx - 1 for idx in absolute_block_indices]\n+\n+        return {\n+            \"block\": block,\n+            \"getblocktxn\": getblocktxn,\n+            \"num_tx_requested\": num_tx_requested,\n+            \"missing_indices\": missing_indices\n+        }\n+\n+    # TEST: policy-rejected transactions\n+\n+    def test_policy_rejection_types(self):\n+        \"\"\"Test that each policy rejection type adds transactions to extra pool.\"\"\"\n+        self.log.info(\"Testing policy rejection types for extra pool...\")\n+\n+        self.restart_node_with_limit(count=100)\n+\n+        rejection_types = [\"dust\", \"low_fee\", \"nonstandard_script\"]\n+        rejected_txs = []\n+\n+        for rejection_type in rejection_types:\n+            self.log.info(f\"Testing {rejection_type} rejection...\")\n+            tx_info = self.create_policy_rejected_tx(rejection_type)\n+\n+            tx_obj = tx_from_hex(tx_info['hex'])\n+            self.segwit_node.send_without_ping(msg_tx(tx_obj))\n+\n+            rejected_txs.append({\n+                'type': rejection_type,\n+                'tx_info': tx_info,\n+                'txid': tx_info['tx'].txid_hex\n+            })\n+\n+        self.segwit_node.sync_with_ping()\n+\n+        mempool = self.nodes[0].getrawmempool()\n+        for rejected in rejected_txs:\n+            assert_equal(rejected['txid'] in mempool, False)\n+            self.log.info(f\"âœ“ {rejected['type']} transaction rejected from mempool\")\n+\n+        indices = list(range(len(rejected_txs)))\n+        tx_list = [r['tx_info'] for r in rejected_txs]\n+\n+        result = self.send_compact_block(tx_list, indices)\n+\n+        assert_equal(result[\"missing_indices\"], [])\n+        self.log.info(\"âœ“ All rejected transactions are available in extra pool\")\n+\n+    # TEST: blockreconstructionextratxn\n+\n+    def test_extratxnpool_disabled(self):\n+        \"\"\"Test that setting count to 0 disables the extra transaction pool.\"\"\"\n+        self.log.info(\"Testing disabled extra transaction pool (0 capacity)...\")\n+\n+        self.restart_node_with_limit(count=0)\n+        buffersize = 5\n+        rejected_txs = self.populate_extra_pool(buffersize)\n+\n+        indices = list(range(buffersize))\n+        result = self.send_compact_block(rejected_txs, indices)\n+        assert_equal(result[\"missing_indices\"], indices)\n+        self.log.info(f\"âœ“ All {buffersize} transactions are missing (extra txn pool disabled)\")\n+\n+    def test_extratxnpool_capacity(self):",
      "path": "test/functional/p2p_compactblocks_extratxs.py",
      "position": 1,
      "original_position": 259,
      "commit_id": "f9c6331cb26f3bafc3dba7f5a72622a9ff4f190d",
      "original_commit_id": "bd1c6b4ea9b94ab4b2604f2a4b8a7fd1fe55c92a",
      "in_reply_to_id": 2299245392,
      "user": {
        "login": "bigshiny90",
        "id": 23282055,
        "node_id": "MDQ6VXNlcjIzMjgyMDU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23282055?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigshiny90",
        "html_url": "https://github.com/bigshiny90",
        "followers_url": "https://api.github.com/users/bigshiny90/followers",
        "following_url": "https://api.github.com/users/bigshiny90/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigshiny90/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigshiny90/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigshiny90/subscriptions",
        "organizations_url": "https://api.github.com/users/bigshiny90/orgs",
        "repos_url": "https://api.github.com/users/bigshiny90/repos",
        "events_url": "https://api.github.com/users/bigshiny90/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigshiny90/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I combined the 3 separate tests - test_extratxnpool_capacity, test_extratxn_large_capacity, test_extratxn_buffer_wraparound - and created one test test_extratxnpool_capacity_and_wraparound, which tests capacity 400 and wraparound behavior",
      "created_at": "2025-08-25T23:46:07Z",
      "updated_at": "2025-08-25T23:46:07Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33023#discussion_r2299372290",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2299372290"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33023"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 259,
      "side": "RIGHT"
    }
  ]
}