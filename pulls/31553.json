{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553",
    "id": 2248495552,
    "node_id": "PR_kwDOABII586GBVHA",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/31553",
    "diff_url": "https://github.com/bitcoin/bitcoin/pull/31553.diff",
    "patch_url": "https://github.com/bitcoin/bitcoin/pull/31553.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31553",
    "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31553/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/3744b8318d8f465603f0e6f9eb72e679d763c4ca",
    "number": 31553,
    "state": "open",
    "locked": false,
    "maintainer_can_modify": true,
    "title": "cluster mempool: add TxGraph reorg functionality",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false,
      "patch_url": null
    },
    "body": "Part of cluster mempool (#30289). Builds on top of #31444.\r\n\r\nDuring reorganisations, it is possible that dependencies get added which would result in clusters that violate policy limits (cluster count, cluster weight), when linking the new from-block transactions to the old from-mempool transactions. Unlike RBF scenarios, we cannot simply reject the changes when they are due to received blocks. To accommodate this, add a `TxGraph::Trim()`, which removes some subset of transactions (including descendants) in order to make all resulting clusters satisfy the limits.\r\n\r\nConceptually, the way this is done is by defining a rudimentary linearization for the entire would-be too-large cluster, iterating it from beginning to end, and reasoning about the counts and weights of the clusters that would be reached using transactions up to that point. If a transaction is encountered whose addition would violate the limit, it is removed, together with all its descendants.\r\n\r\nThis rudimentary linearization is like a merge sort of the chunks of the clusters being combined, but respecting topology. More specifically, it is continuously picking the highest-chunk-feerate remaining transaction among those which have no unmet dependencies left. For efficiency, this rudimentary linearization is computed lazily, by putting all viable transactions in a heap, sorted by chunk feerate, and adding new transactions to it as they become viable.\r\n\r\nThe `Trim()` function is rather unusual compared to the `TxGraph` functionality added in previous PRs, in that `Trim()` makes it own decisions about what the resulting graph contents will be, without good specification of how it makes that decision - it is just a best-effort attempt (which is improved in the last commit). All other `TxGraph` mutators are simply to inform the graph about changes the calling mempool code decided on; this one lets the decision be made by txgraph.\r\n\r\nAs part of this, the \"oversized\" property is expanded to also encompass a configurable cluster weight limit (in addition to cluster count limit). \r\n",
    "labels": [
      {
        "id": 164208572,
        "node_id": "MDU6TGFiZWwxNjQyMDg1NzI=",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Mempool",
        "name": "Mempool",
        "color": "fef2c0",
        "default": false
      }
    ],
    "created_at": "2024-12-22T19:06:05Z",
    "updated_at": "2025-03-20T00:05:26Z",
    "mergeable": true,
    "mergeable_state": "blocked",
    "merged": false,
    "merge_commit_sha": "601fbe7abb440eeda4768eb897074566b14eb2bc",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "rebaseable": true,
    "head": {
      "label": "sipa:202412_txgraph_trim",
      "ref": "202412_txgraph_trim",
      "sha": "3744b8318d8f465603f0e6f9eb72e679d763c4ca",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "repo": {
        "id": 1458655,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNDU4NjU1",
        "name": "bitcoin",
        "full_name": "sipa/bitcoin",
        "owner": {
          "login": "sipa",
          "id": 548488,
          "node_id": "MDQ6VXNlcjU0ODQ4OA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/sipa",
          "html_url": "https://github.com/sipa",
          "followers_url": "https://api.github.com/users/sipa/followers",
          "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
          "organizations_url": "https://api.github.com/users/sipa/orgs",
          "repos_url": "https://api.github.com/users/sipa/repos",
          "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/sipa/received_events",
          "type": "User",
          "site_admin": false,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/sipa/bitcoin",
        "description": "Bitcoin integration/staging tree",
        "fork": true,
        "url": "https://api.github.com/repos/sipa/bitcoin",
        "archive_url": "https://api.github.com/repos/sipa/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/sipa/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/sipa/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/sipa/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/sipa/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/sipa/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/sipa/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/sipa/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/sipa/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/sipa/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/sipa/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/sipa/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/sipa/bitcoin/events",
        "forks_url": "https://api.github.com/repos/sipa/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/sipa/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/sipa/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/sipa/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/sipa/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/sipa/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/sipa/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/sipa/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/sipa/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/sipa/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/sipa/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/sipa/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/sipa/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/sipa/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/sipa/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/sipa/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:sipa/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/sipa/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/sipa/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/sipa/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/sipa/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/sipa/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/sipa/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/sipa/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/sipa/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/sipa/bitcoin/hooks",
        "svn_url": "https://github.com/sipa/bitcoin",
        "homepage": "http://www.bitcoin.org",
        "language": "TypeScript",
        "forks_count": 20,
        "stargazers_count": 90,
        "watchers_count": 90,
        "size": 257974,
        "default_branch": "lows",
        "open_issues_count": 16,
        "is_template": false,
        "topics": [],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2025-03-19T21:24:00Z",
        "created_at": "2011-03-09T10:46:59Z",
        "updated_at": "2025-02-27T11:11:39Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "e568c1dd134e0318c46113cb7dfc23b40e2829e8",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false,
        "patch_url": null
      },
      "repo": {
        "id": 1181927,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTgxOTI3",
        "name": "bitcoin",
        "full_name": "bitcoin/bitcoin",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bitcoin",
        "archive_url": "https://api.github.com/repos/bitcoin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bitcoin/hooks",
        "svn_url": "https://github.com/bitcoin/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 36946,
        "stargazers_count": 82549,
        "watchers_count": 82549,
        "size": 278428,
        "default_branch": "master",
        "open_issues_count": 687,
        "is_template": false,
        "topics": [
          "bitcoin",
          "c-plus-plus",
          "cryptocurrency",
          "cryptography",
          "p2p"
        ],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2025-03-18T23:39:35Z",
        "created_at": "2010-12-19T15:16:43Z",
        "updated_at": "2025-03-20T00:54:34Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
      }
    },
    "author_association": "MEMBER",
    "draft": false,
    "additions": 4351,
    "deletions": 151,
    "changed_files": 12,
    "commits": 35,
    "review_comments": 22,
    "comments": 9
  },
  "events": [
    {
      "event": "commented",
      "id": 2558561140,
      "node_id": "IC_kwDOABII586YgIt0",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2558561140",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-12-22T19:06:08Z",
      "updated_at": "2025-03-13T05:16:38Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage & Benchmarks\nFor details see: https://corecheck.dev/bitcoin/bitcoin/pulls/31553.\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\nA summary of reviews will appear here.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#31868](https://github.com/bitcoin/bitcoin/pull/31868) ([IBD] specialize block serialization by l0rinc)\n* [#31519](https://github.com/bitcoin/bitcoin/pull/31519) (refactor: Use std::span over Span by maflcko)\n* [#30605](https://github.com/bitcoin/bitcoin/pull/30605) (Cluster linearization: separate tests from tests-of-tests by sipa)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#issuecomment-2558561140",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31553"
    },
    {
      "event": "labeled",
      "id": 15798589053,
      "node_id": "LE_lADOABII586kMugSzwAAAAOtq1Z9",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15798589053",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-02T13:05:14Z",
      "label": {
        "name": "Mempool",
        "color": "fef2c0"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15861077490,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAOxZNXy",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15861077490",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "3e809fa9e6c0fc025ad180fe2d47e03cb9e6da4b",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/3e809fa9e6c0fc025ad180fe2d47e03cb9e6da4b",
      "created_at": "2025-01-08T23:27:48Z"
    },
    {
      "event": "labeled",
      "id": 15861624638,
      "node_id": "LE_lADOABII586kMugSzwAAAAOxbS8-",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15861624638",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-09T00:52:10Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2578976969,
      "node_id": "IC_kwDOABII586ZuBDJ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2578976969",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-09T00:52:11Z",
      "updated_at": "2025-01-09T00:52:11Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\n🚧 At least one of the CI tasks failed.\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/35343429418</sub>\n\n<details><summary>Hints</summary>\n\nTry to run the tests locally, according to the documentation. However, a CI failure may still\nhappen due to a number of reasons, for example:\n\n* Possibly due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\n* A sanitizer issue, which can only be found by compiling with the sanitizer and running the\n  affected test.\n\n* An intermittent issue.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n</details>\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#issuecomment-2578976969",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31553"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15861756974,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAOxbzQu",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15861756974",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "75c675702ae91a234eca58a8733f69ebcf21eef4",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/75c675702ae91a234eca58a8733f69ebcf21eef4",
      "created_at": "2025-01-09T01:12:51Z"
    },
    {
      "event": "unlabeled",
      "id": 15862045073,
      "node_id": "UNLE_lADOABII586kMugSzwAAAAOxc5mR",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15862045073",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-09T02:34:45Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15868145094,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAOx0K3G",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15868145094",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "5a6550f8cafae8317eccf7bfc797669189176924",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/5a6550f8cafae8317eccf7bfc797669189176924",
      "created_at": "2025-01-09T13:41:37Z"
    },
    {
      "event": "reviewed",
      "id": 2540686525,
      "node_id": "PRR_kwDOABII586Xb8y9",
      "url": null,
      "actor": null,
      "commit_id": "5a6550f8cafae8317eccf7bfc797669189176924",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Very quick and shallow pass through the initial impl commit. This PR is a lot to get through :)",
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#pullrequestreview-2540686525",
      "submitted_at": "2025-01-09T20:03:57Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15873846189,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAOyJ6ut",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15873846189",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "fa14d0679f9362024cf5513e498b969cd74819a2",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/fa14d0679f9362024cf5513e498b969cd74819a2",
      "created_at": "2025-01-09T21:34:39Z"
    },
    {
      "event": "labeled",
      "id": 15874780470,
      "node_id": "LE_lADOABII586kMugSzwAAAAOyNe02",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15874780470",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-09T23:22:13Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2581434615,
      "node_id": "IC_kwDOABII586Z3ZD3",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2581434615",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-09T23:22:14Z",
      "updated_at": "2025-01-09T23:22:14Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\n🚧 At least one of the CI tasks failed.\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/35398283653</sub>\n\n<details><summary>Hints</summary>\n\nTry to run the tests locally, according to the documentation. However, a CI failure may still\nhappen due to a number of reasons, for example:\n\n* Possibly due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\n* A sanitizer issue, which can only be found by compiling with the sanitizer and running the\n  affected test.\n\n* An intermittent issue.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n</details>\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#issuecomment-2581434615",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31553"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15875391286,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAOyPz82",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15875391286",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "ab08987564dee21f805f8bc789b717e71eece9b7",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/ab08987564dee21f805f8bc789b717e71eece9b7",
      "created_at": "2025-01-10T01:19:28Z"
    },
    {
      "event": "unlabeled",
      "id": 15875791692,
      "node_id": "UNLE_lADOABII586kMugSzwAAAAOyRVtM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15875791692",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-10T02:22:43Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15876195420,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAOyS4Rc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15876195420",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "fbd6568f6590726a3f786577628df1e6bcf971cc",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/fbd6568f6590726a3f786577628df1e6bcf971cc",
      "created_at": "2025-01-10T03:34:07Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15967733445,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAO3wEbF",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15967733445",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "9046cbf9ed4426ff8d2b9bec06f2ca72378f644c",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/9046cbf9ed4426ff8d2b9bec06f2ca72378f644c",
      "created_at": "2025-01-16T21:13:01Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16034249752,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAO7tzwY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16034249752",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "e4a2fd900cdf417b231dc6cca33d0532adf1e9d4",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/e4a2fd900cdf417b231dc6cca33d0532adf1e9d4",
      "created_at": "2025-01-22T20:02:02Z"
    },
    {
      "event": "reviewed",
      "id": 2572752495,
      "node_id": "PRR_kwDOABII586ZWRZv",
      "url": null,
      "actor": null,
      "commit_id": "6cb99b067cf9028777a2036a8a3240c2511a3caf",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#pullrequestreview-2572752495",
      "submitted_at": "2025-01-24T14:10:52Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16064776329,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAO9iQiJ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16064776329",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "a312648704640dc946939dfe42f21ebfcd62ae92",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/a312648704640dc946939dfe42f21ebfcd62ae92",
      "created_at": "2025-01-24T22:11:35Z"
    },
    {
      "event": "commented",
      "id": 2613488644,
      "node_id": "IC_kwDOABII586bxqwE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2613488644",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-24T22:14:46Z",
      "updated_at": "2025-01-24T22:14:46Z",
      "author_association": "MEMBER",
      "body": "Some changes:\r\n* As a result of dropping `Cleanup` in the base PR, `Trim` now reports which transactions it removed, as it becomes the caller's responsibility of destroying Refs.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#issuecomment-2613488644",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31553"
    },
    {
      "event": "labeled",
      "id": 16065345293,
      "node_id": "LE_lADOABII586kMugSzwAAAAO9kbcN",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16065345293",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-24T23:23:36Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2613584141,
      "node_id": "IC_kwDOABII586byCEN",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2613584141",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-24T23:23:37Z",
      "updated_at": "2025-01-24T23:23:37Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\n🚧 At least one of the CI tasks failed.\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/36148923463</sub>\n\n<details><summary>Hints</summary>\n\nTry to run the tests locally, according to the documentation. However, a CI failure may still\nhappen due to a number of reasons, for example:\n\n* Possibly due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\n* A sanitizer issue, which can only be found by compiling with the sanitizer and running the\n  affected test.\n\n* An intermittent issue.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n</details>\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#issuecomment-2613584141",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31553"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16068867983,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAO9x3eP",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16068867983",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "52c4105a1c341a7a82dab3e792a2f8f5b9ca51b4",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/52c4105a1c341a7a82dab3e792a2f8f5b9ca51b4",
      "created_at": "2025-01-26T04:37:22Z"
    },
    {
      "event": "commented",
      "id": 2614209321,
      "node_id": "IC_kwDOABII586b0asp",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2614209321",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-26T04:42:19Z",
      "updated_at": "2025-01-26T04:42:19Z",
      "author_association": "MEMBER",
      "body": "* Add support for calling `AddTransaction` with a feerate whose size already violates the cluster size limit.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#issuecomment-2614209321",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31553"
    },
    {
      "event": "unlabeled",
      "id": 16070110443,
      "node_id": "UNLE_lADOABII586kMugSzwAAAAO92mzr",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16070110443",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-26T13:42:29Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16070941633,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAO95xvB",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16070941633",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "df7185517f2d9ecae9a7c0114bf4a33ca73638a0",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/df7185517f2d9ecae9a7c0114bf4a33ca73638a0",
      "created_at": "2025-01-26T19:57:25Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16131781541,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAPBh3Ol",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16131781541",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "265ad9efa9401c4cbe4395b88370c778fc5e6ae3",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/265ad9efa9401c4cbe4395b88370c778fc5e6ae3",
      "created_at": "2025-01-30T23:46:30Z"
    },
    {
      "event": "commented",
      "id": 2626051202,
      "node_id": "IC_kwDOABII586chlyC",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2626051202",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-31T01:01:46Z",
      "updated_at": "2025-01-31T01:01:46Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\n🚧 At least one of the CI tasks failed.\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/36451226624</sub>\n\n<details><summary>Hints</summary>\n\nTry to run the tests locally, according to the documentation. However, a CI failure may still\nhappen due to a number of reasons, for example:\n\n* Possibly due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\n* A sanitizer issue, which can only be found by compiling with the sanitizer and running the\n  affected test.\n\n* An intermittent issue.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n</details>\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#issuecomment-2626051202",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31553"
    },
    {
      "event": "labeled",
      "id": 16132409137,
      "node_id": "LE_lADOABII586kMugSzwAAAAPBkQcx",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16132409137",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-31T01:01:46Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16134011538,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAPBqXqS",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16134011538",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "e9b4cb1e9bd6309717372c4cc9d0dea3bb4010fa",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/e9b4cb1e9bd6309717372c4cc9d0dea3bb4010fa",
      "created_at": "2025-01-31T05:00:00Z"
    },
    {
      "event": "unlabeled",
      "id": 16134472638,
      "node_id": "UNLE_lADOABII586kMugSzwAAAAPBsIO-",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16134472638",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-31T06:09:40Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16146246231,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAPCZCpX",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16146246231",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "2cac7317b6d799e276ccb3536c30d7b84fb2a765",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/2cac7317b6d799e276ccb3536c30d7b84fb2a765",
      "created_at": "2025-01-31T22:01:28Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16148263464,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAPCgvIo",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16148263464",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "42d725960c70c22c2ad7d94cb02dc12c407ae111",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/42d725960c70c22c2ad7d94cb02dc12c407ae111",
      "created_at": "2025-02-01T03:43:33Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16181709103,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAPEgUkv",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16181709103",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "c4f31251b0e85079f6abfe776a23fecb2c832317",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/c4f31251b0e85079f6abfe776a23fecb2c832317",
      "created_at": "2025-02-04T16:18:01Z"
    },
    {
      "event": "labeled",
      "id": 16184169710,
      "node_id": "LE_lADOABII586kMugSzwAAAAPEptTu",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16184169710",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-02-04T19:32:57Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "unlabeled",
      "id": 16186256526,
      "node_id": "UNLE_lADOABII586kMugSzwAAAAPExqyO",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16186256526",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-02-04T23:03:25Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16204090793,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAPF1s2p",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16204090793",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "9618a33eb754443a6bd7d1504d60896013d3a102",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/9618a33eb754443a6bd7d1504d60896013d3a102",
      "created_at": "2025-02-06T04:28:11Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16271005473,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAPJ09ch",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16271005473",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "9da91b512cc1c0ff1df657473b601ff6d1a4786c",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/9da91b512cc1c0ff1df657473b601ff6d1a4786c",
      "created_at": "2025-02-11T20:33:09Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16287907888,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAPK1cAw",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16287907888",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "c7624ac16934bdf1dc106f87ce66da328ceeed3d",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/c7624ac16934bdf1dc106f87ce66da328ceeed3d",
      "created_at": "2025-02-12T22:29:24Z"
    },
    {
      "event": "commented",
      "id": 2655103200,
      "node_id": "IC_kwDOABII586eQajg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2655103200",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-02-12T23:49:28Z",
      "updated_at": "2025-02-12T23:49:28Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\n🚧 At least one of the CI tasks failed.\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/37128455883</sub>\n\n<details><summary>Hints</summary>\n\nTry to run the tests locally, according to the documentation. However, a CI failure may still\nhappen due to a number of reasons, for example:\n\n* Possibly due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\n* A sanitizer issue, which can only be found by compiling with the sanitizer and running the\n  affected test.\n\n* An intermittent issue.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n</details>\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#issuecomment-2655103200",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31553"
    },
    {
      "event": "labeled",
      "id": 16288507322,
      "node_id": "LE_lADOABII586kMugSzwAAAAPK3uW6",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16288507322",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-02-12T23:49:28Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16290332108,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAPK-r3M",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16290332108",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "490981ff0b9c745793fc6edf43cc28954386fab5",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/490981ff0b9c745793fc6edf43cc28954386fab5",
      "created_at": "2025-02-13T04:33:43Z"
    },
    {
      "event": "unlabeled",
      "id": 16290929989,
      "node_id": "UNLE_lADOABII586kMugSzwAAAAPLA91F",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16290929989",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-02-13T05:52:05Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16318032388,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAPMoWoE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16318032388",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "1dfe3ca0f712e8effaff9cb4b1f22a3e1377f160",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/1dfe3ca0f712e8effaff9cb4b1f22a3e1377f160",
      "created_at": "2025-02-14T22:27:24Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16386455066,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAPQtXYa",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16386455066",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "e1e90c7004327e9bde8de4fabcd78fc75361362c",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/e1e90c7004327e9bde8de4fabcd78fc75361362c",
      "created_at": "2025-02-20T17:20:19Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16407979573,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAPR_eY1",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16407979573",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "e43f6ca3b80cff2e05f88223ee9de3e2fe014243",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/e43f6ca3b80cff2e05f88223ee9de3e2fe014243",
      "created_at": "2025-02-21T22:09:24Z"
    },
    {
      "event": "reviewed",
      "id": 2638575710,
      "node_id": "PRR_kwDOABII586dRXhe",
      "url": null,
      "actor": null,
      "commit_id": "e43f6ca3b80cff2e05f88223ee9de3e2fe014243",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "yancyribbens",
        "id": 817736,
        "node_id": "MDQ6VXNlcjgxNzczNg==",
        "avatar_url": "https://avatars.githubusercontent.com/u/817736?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yancyribbens",
        "html_url": "https://github.com/yancyribbens",
        "followers_url": "https://api.github.com/users/yancyribbens/followers",
        "following_url": "https://api.github.com/users/yancyribbens/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/yancyribbens/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/yancyribbens/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/yancyribbens/subscriptions",
        "organizations_url": "https://api.github.com/users/yancyribbens/orgs",
        "repos_url": "https://api.github.com/users/yancyribbens/repos",
        "events_url": "https://api.github.com/users/yancyribbens/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/yancyribbens/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#pullrequestreview-2638575710",
      "submitted_at": "2025-02-24T22:20:13Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
    },
    {
      "event": "reviewed",
      "id": 2638627438,
      "node_id": "PRR_kwDOABII586dRkJu",
      "url": null,
      "actor": null,
      "commit_id": "e43f6ca3b80cff2e05f88223ee9de3e2fe014243",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "yancyribbens",
        "id": 817736,
        "node_id": "MDQ6VXNlcjgxNzczNg==",
        "avatar_url": "https://avatars.githubusercontent.com/u/817736?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yancyribbens",
        "html_url": "https://github.com/yancyribbens",
        "followers_url": "https://api.github.com/users/yancyribbens/followers",
        "following_url": "https://api.github.com/users/yancyribbens/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/yancyribbens/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/yancyribbens/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/yancyribbens/subscriptions",
        "organizations_url": "https://api.github.com/users/yancyribbens/orgs",
        "repos_url": "https://api.github.com/users/yancyribbens/repos",
        "events_url": "https://api.github.com/users/yancyribbens/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/yancyribbens/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#pullrequestreview-2638627438",
      "submitted_at": "2025-02-24T22:48:56Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16541382065,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAPZ8XWx",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16541382065",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "8400928ba1d0e89547c480482a41e05edda05126",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/8400928ba1d0e89547c480482a41e05edda05126",
      "created_at": "2025-03-03T21:51:21Z"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDRhNzhmOTIwOWRhMzdkM2M2ODk2MTZiZWNkNDhjNTg0NWFiZmExY2U",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4a78f9209da37d3c689616becd48c5845abfa1ce",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/4a78f9209da37d3c689616becd48c5845abfa1ce",
      "tree": {
        "sha": "7cdef1f794d8f60e18bb72a90805141a3ca18974",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7cdef1f794d8f60e18bb72a90805141a3ca18974"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e568c1dd134e0318c46113cb7dfc23b40e2829e8",
          "sha": "e568c1dd134e0318c46113cb7dfc23b40e2829e8",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/e568c1dd134e0318c46113cb7dfc23b40e2829e8"
        }
      ],
      "message": "clusterlin: add FixLinearization function + fuzz test\n\nThis function takes an existing ordering for transactions in a DepGraph, and\nmakes it a valid linearization for it (i.e., topological). Any topological\nprefix of the input remains untouched.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-03-19T14:40:04Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-10-25T18:11:50Z"
      },
      "sha": "4a78f9209da37d3c689616becd48c5845abfa1ce"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDE5OGFmZDZiZjE1OTU1MTk0ODE0MDg5MGViZWZlMTExNDg5ZmJlYzY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/198afd6bf159551948140890ebefe111489fbec6",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/198afd6bf159551948140890ebefe111489fbec6",
      "tree": {
        "sha": "26d0c2a4a32f9c6694c887714d4083b758fe2be2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/26d0c2a4a32f9c6694c887714d4083b758fe2be2"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4a78f9209da37d3c689616becd48c5845abfa1ce",
          "sha": "4a78f9209da37d3c689616becd48c5845abfa1ce",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/4a78f9209da37d3c689616becd48c5845abfa1ce"
        }
      ],
      "message": "clusterlin: make IsAcyclic() a DepGraph member function\n\n... instead of being a separate test-only function.\n\nAlso add a fuzz test for it returning false.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-03-19T14:40:04Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-11-12T20:13:58Z"
      },
      "sha": "198afd6bf159551948140890ebefe111489fbec6"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16878631671,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAPuC3r3",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16878631671",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "a6ac3751048b4ee3b52de54f38fac338c7a5834b",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/a6ac3751048b4ee3b52de54f38fac338c7a5834b",
      "created_at": "2025-03-19T20:28:57Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16879645092,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAPuGvGk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16879645092",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "7e7a49cd2e3b456b95fbc5c75cb5b62472f7d908",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/7e7a49cd2e3b456b95fbc5c75cb5b62472f7d908",
      "created_at": "2025-03-19T21:06:28Z"
    },
    {
      "event": "labeled",
      "id": 16879645757,
      "node_id": "LE_lADOABII586kMugSzwAAAAPuGvQ9",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16879645757",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-19T21:06:33Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2738113567,
      "node_id": "IC_kwDOABII586jNEwf",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2738113567",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-19T21:06:34Z",
      "updated_at": "2025-03-19T21:06:34Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\n🚧 At least one of the CI tasks failed.\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/39067440822</sub>\n\n<details><summary>Hints</summary>\n\nTry to run the tests locally, according to the documentation. However, a CI failure may still\nhappen due to a number of reasons, for example:\n\n* Possibly due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\n* A sanitizer issue, which can only be found by compiling with the sanitizer and running the\n  affected test.\n\n* An intermittent issue.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n</details>\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#issuecomment-2738113567",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31553"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDU2Y2FjYWM1NDc0YTY1ZGQ2OGVmODY0MzY5OGM0MTczN2E1NDRjNDM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/56cacac5474a65dd68ef8643698c41737a544c43",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/56cacac5474a65dd68ef8643698c41737a544c43",
      "tree": {
        "sha": "8fb3bde64a2964de284ee775acc4c414b31350b6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8fb3bde64a2964de284ee775acc4c414b31350b6"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/198afd6bf159551948140890ebefe111489fbec6",
          "sha": "198afd6bf159551948140890ebefe111489fbec6",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/198afd6bf159551948140890ebefe111489fbec6"
        }
      ],
      "message": "scripted-diff: (refactor) ClusterIndex -> DepGraphIndex\n\nSince cluster_linearize.h does not actually have a Cluster type anymore, it is more\nappropriate to rename the index type to DepGraphIndex.\n\n-BEGIN VERIFY SCRIPT-\nsed -i 's/Data type to represent transaction indices in clusters./Data type to represent transaction indices in DepGraphs and the clusters they represent./' $(git grep -l 'using ClusterIndex')\nsed -i 's|\\<ClusterIndex\\>|DepGraphIndex|g' $(git grep -l 'ClusterIndex')\n-END VERIFY SCRIPT-",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-03-19T21:23:15Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-01-31T21:26:06Z"
      },
      "sha": "56cacac5474a65dd68ef8643698c41737a544c43"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDQxMGE5ZWIzYmE0Y2Q3NmE1ZWVjYjI1OTRjZDQ0ZTQyNzIxMDEyNjc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/410a9eb3ba4cd76a5eecb2594cd44e4272101267",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/410a9eb3ba4cd76a5eecb2594cd44e4272101267",
      "tree": {
        "sha": "b05e3bc761ff00395e76dfe2a055f1a54ae2947a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b05e3bc761ff00395e76dfe2a055f1a54ae2947a"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/56cacac5474a65dd68ef8643698c41737a544c43",
          "sha": "56cacac5474a65dd68ef8643698c41737a544c43",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/56cacac5474a65dd68ef8643698c41737a544c43"
        }
      ],
      "message": "feefrac: introduce tagged wrappers to distinguish vsize/WU rates",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-03-19T21:23:17Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-01-30T22:14:52Z"
      },
      "sha": "410a9eb3ba4cd76a5eecb2594cd44e4272101267"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDEzYjIyMmM5MzVlNDMwZDA2ZGMxMDcxM2U5N2NjYTk3NDJiOTU2ZDU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/13b222c935e430d06dc10713e97cca9742b956d5",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/13b222c935e430d06dc10713e97cca9742b956d5",
      "tree": {
        "sha": "d9ae8f378ed23919e209aef8f10b1fdafea818b4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d9ae8f378ed23919e209aef8f10b1fdafea818b4"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/410a9eb3ba4cd76a5eecb2594cd44e4272101267",
          "sha": "410a9eb3ba4cd76a5eecb2594cd44e4272101267",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/410a9eb3ba4cd76a5eecb2594cd44e4272101267"
        }
      ],
      "message": "txgraph: (feature) add initial version\n\nThis adds an initial version of the txgraph module, with the TxGraph class.\nIt encapsulates knowledge about the fees, sizes, and dependencies between all\nmempool transactions, but nothing else.\n\nIn particular, it lacks knowledge about txids, inputs, outputs, CTransactions,\n... and so forth. Instead, it exposes a generic TxGraph::Ref type to reference\nnodes in the TxGraph, which can be passed around and stored by layers on top.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-03-19T21:23:17Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-08-21T18:37:00Z"
      },
      "sha": "13b222c935e430d06dc10713e97cca9742b956d5"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGI1MmJiNmNhYzMyOTlhNTE0ZTk4NTk0NzFmMGNlY2FkZDQ4YTZmYjc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b52bb6cac3299a514e9859471f0cecadd48a6fb7",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/b52bb6cac3299a514e9859471f0cecadd48a6fb7",
      "tree": {
        "sha": "10ffa910c8dbcbea10f8622aa9901440bafbe629",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/10ffa910c8dbcbea10f8622aa9901440bafbe629"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/13b222c935e430d06dc10713e97cca9742b956d5",
          "sha": "13b222c935e430d06dc10713e97cca9742b956d5",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/13b222c935e430d06dc10713e97cca9742b956d5"
        }
      ],
      "message": "txgraph: (tests) add simulation fuzz test\n\nThis adds a simulation fuzz test for txgraph, by comparing with a naive\nreimplementation that models the entire graph as a single DepGraph, and\nclusters in TxGraph as connected components within that DepGraph.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-03-19T21:23:17Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-11-15T19:15:12Z"
      },
      "sha": "b52bb6cac3299a514e9859471f0cecadd48a6fb7"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDdmNDVkZjI3YjlmY2UwMmUzYzRiNGE3NmY2ODdiZTQ2NzBjNGIxM2U",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7f45df27b9fce02e3c4b4a76f687be4670c4b13e",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/7f45df27b9fce02e3c4b4a76f687be4670c4b13e",
      "tree": {
        "sha": "c95c83a4d1aa1034ed2d62bc957cfdb43a98825b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c95c83a4d1aa1034ed2d62bc957cfdb43a98825b"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b52bb6cac3299a514e9859471f0cecadd48a6fb7",
          "sha": "b52bb6cac3299a514e9859471f0cecadd48a6fb7",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/b52bb6cac3299a514e9859471f0cecadd48a6fb7"
        }
      ],
      "message": "txgraph: (tests) add internal sanity check function\n\nTo make testing more powerful, expose a function to perform an internal sanity\ncheck on the state of a TxGraph. This is especially important as TxGraphImpl\ncontains many redundantly represented pieces of information:\n\n* graph contains clusters, which refer to entries, but the entries refer back\n* graph maintains pointers to Ref objects, which point back to the graph.\n\nThis lets us make sure they are always in sync.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-03-19T21:23:17Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-11-15T03:45:46Z"
      },
      "sha": "7f45df27b9fce02e3c4b4a76f687be4670c4b13e"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDEwMWE4ZWUzMjgwZTUwYzMyNzJhODA5MzliNDZhNjdmYWNhODM4ZTQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/101a8ee3280e50c3272a80939b46a67faca838e4",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/101a8ee3280e50c3272a80939b46a67faca838e4",
      "tree": {
        "sha": "95210e0c05b2853489efdc6d66a3bd0b29d78f6e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/95210e0c05b2853489efdc6d66a3bd0b29d78f6e"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7f45df27b9fce02e3c4b4a76f687be4670c4b13e",
          "sha": "7f45df27b9fce02e3c4b4a76f687be4670c4b13e",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/7f45df27b9fce02e3c4b4a76f687be4670c4b13e"
        }
      ],
      "message": "txgraph: (optimization) avoid per-group vectors for clusters & dependencies\n\nInstead construct a single vector with the list of all clusters in all groups,\nand then store per-group offset/range in that list.\n\nFor dependencies, reuse m_deps_to_add, and store offset/range into that.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-03-19T21:23:17Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-01-26T04:23:28Z"
      },
      "sha": "101a8ee3280e50c3272a80939b46a67faca838e4"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGU2NjA1YjJjMmY4ZThjMmJjNWM5NWUxYjUwODFhOTFlZDMxNDU3NGI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e6605b2c2f8e8c2bc5c95e1b5081a91ed314574b",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/e6605b2c2f8e8c2bc5c95e1b5081a91ed314574b",
      "tree": {
        "sha": "351d753747563a688a54c8254fc1591a20cf4be7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/351d753747563a688a54c8254fc1591a20cf4be7"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/101a8ee3280e50c3272a80939b46a67faca838e4",
          "sha": "101a8ee3280e50c3272a80939b46a67faca838e4",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/101a8ee3280e50c3272a80939b46a67faca838e4"
        }
      ],
      "message": "txgraph: (feature) Add GetChunkFeerate\n\nThis adds a function to query the chunk feerate of a transaction, by caching it\ninside the Entry objects.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-03-19T21:23:17Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-03-19T20:22:25Z"
      },
      "sha": "e6605b2c2f8e8c2bc5c95e1b5081a91ed314574b"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDg1MzBkYzU2N2U1MDQ3MzhkY2RlYWM1NGQ4N2MyOTU3ZGViMTYxODY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8530dc567e504738dcdeac54d87c2957deb16186",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/8530dc567e504738dcdeac54d87c2957deb16186",
      "tree": {
        "sha": "bb322e925331452d73823a38a84de2a12fc92a9a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/bb322e925331452d73823a38a84de2a12fc92a9a"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e6605b2c2f8e8c2bc5c95e1b5081a91ed314574b",
          "sha": "e6605b2c2f8e8c2bc5c95e1b5081a91ed314574b",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/e6605b2c2f8e8c2bc5c95e1b5081a91ed314574b"
        }
      ],
      "message": "txgraph: (feature) make max cluster count configurable and \"oversize\" state\n\nInstead of leaving the responsibility on higher layers to guarantee that\nno connected component within TxGraph (a barely exposed concept, except through\nGetCluster()) exceeds the cluster count limit, move this responsibility to\nTxGraph itself:\n* TxGraph retains a cluster count limit, but it becomes configurable at construction\n  time (this primarily helps with testing that it is properly enforced).\n* It is always allowed to perform mutators on TxGraph, even if they would cause the\n  cluster count limit to be exceeded. Instead, TxGraph exposes an IsOversized()\n  function, which queries whether it is in a special \"oversize\" state.\n* During oversize state, many inspectors are unavailable, but mutators remain valid,\n  so the higher layer can \"fix\" the oversize state before continuing.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-03-19T21:23:17Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-11-24T13:53:50Z"
      },
      "sha": "8530dc567e504738dcdeac54d87c2957deb16186"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGM4NWFmZmZlNjEzZWE0ZWI0NTI3Y2RkMDlmNjZlOTk3YTI3YzFhYzg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c85afffe613ea4eb4527cdd09f66e997a27c1ac8",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/c85afffe613ea4eb4527cdd09f66e997a27c1ac8",
      "tree": {
        "sha": "7ade89ab5143368fdcd3092fd8229f65c813be99",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7ade89ab5143368fdcd3092fd8229f65c813be99"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8530dc567e504738dcdeac54d87c2957deb16186",
          "sha": "8530dc567e504738dcdeac54d87c2957deb16186",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/8530dc567e504738dcdeac54d87c2957deb16186"
        }
      ],
      "message": "txgraph: (optimization) avoid representative lookup for each dependency\n\nThe m_deps_to_add vector is sorted by child Cluster*, which matches the\norder of an_clusters. This means we can walk through m_deps_to_add while\ndoing the representative lookups for an_clusters, and reuse them.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-03-19T21:23:17Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-01-22T19:53:32Z"
      },
      "sha": "c85afffe613ea4eb4527cdd09f66e997a27c1ac8"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDZjMWEyZDcyYTdlZTA2YjZkZDk5YTg0YmYxYTFlMzE4MzU5ZWYwOWI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6c1a2d72a7ee06b6dd99a84bf1a1e318359ef09b",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/6c1a2d72a7ee06b6dd99a84bf1a1e318359ef09b",
      "tree": {
        "sha": "b77895cb9d2ca95934fb7c5cfdb6b7d656268710",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b77895cb9d2ca95934fb7c5cfdb6b7d656268710"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c85afffe613ea4eb4527cdd09f66e997a27c1ac8",
          "sha": "c85afffe613ea4eb4527cdd09f66e997a27c1ac8",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/c85afffe613ea4eb4527cdd09f66e997a27c1ac8"
        }
      ],
      "message": "txgraph: (optimization) avoid looking up the same child cluster repeatedly\n\nSince m_deps_to_add has been sorted by child Cluster* already, all dependencies\nwith the same child will be processed consecutively. Take advantage of this by\nremember the last partition merged with, and reusing that if applicable.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-03-19T21:23:17Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-01-22T19:36:00Z"
      },
      "sha": "6c1a2d72a7ee06b6dd99a84bf1a1e318359ef09b"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDU5MGQxNDA2Mjk0M2E4NjE0Mjk1YzAyMjA0NGIzZmEyNTA3ZjQwMzY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/590d14062943a8614295c022044b3fa2507f4036",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/590d14062943a8614295c022044b3fa2507f4036",
      "tree": {
        "sha": "ca80104c4ea390c15ad5f58dd12b13ff3074aed2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ca80104c4ea390c15ad5f58dd12b13ff3074aed2"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6c1a2d72a7ee06b6dd99a84bf1a1e318359ef09b",
          "sha": "6c1a2d72a7ee06b6dd99a84bf1a1e318359ef09b",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/6c1a2d72a7ee06b6dd99a84bf1a1e318359ef09b"
        }
      ],
      "message": "txgraph: (optimization) delay chunking while sub-acceptable\n\nChunk-based information (primarily, chunk feerates) are never accessed without\nfirst bringing the relevant Clusters to an \"acceptable\" quality level. Thus,\nwhile operations are ongoing and Clusters are not acceptable, we can omit\ncomputing the chunkings and chunk feerates for Clusters.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-03-19T21:23:17Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-11-15T18:31:23Z"
      },
      "sha": "590d14062943a8614295c022044b3fa2507f4036"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDc1MTEwNDQzZjFjZTE0ZTc5ZGZhYmY3MGEwMmUzOGE1YTY4OTkyOTU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/75110443f1ce14e79dfabf70a02e38a5a6899295",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/75110443f1ce14e79dfabf70a02e38a5a6899295",
      "tree": {
        "sha": "3acc280539a63dc83715ca611bc5d275768c8940",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3acc280539a63dc83715ca611bc5d275768c8940"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/590d14062943a8614295c022044b3fa2507f4036",
          "sha": "590d14062943a8614295c022044b3fa2507f4036",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/590d14062943a8614295c022044b3fa2507f4036"
        }
      ],
      "message": "txgraph: (optimization) special-case removal of tail of cluster\n\nWhen transactions are removed from the tail of a cluster, we know the existing\nlinearization remains acceptable (if it already was), but may just need splitting\nand postlinearization, so special case these into separate quality levels.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-03-19T21:23:17Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-11-14T23:10:24Z"
      },
      "sha": "75110443f1ce14e79dfabf70a02e38a5a6899295"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDliZDM3OTQ1N2Q0NjFlZWZlNzhlOTA2ODFlMzYyZmUyODVhYTI4ZDQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9bd379457d461eefe78e90681e362fe285aa28d4",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/9bd379457d461eefe78e90681e362fe285aa28d4",
      "tree": {
        "sha": "25821f8eea3e24c58a44f1ae1c68586dee5d4191",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/25821f8eea3e24c58a44f1ae1c68586dee5d4191"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/75110443f1ce14e79dfabf70a02e38a5a6899295",
          "sha": "75110443f1ce14e79dfabf70a02e38a5a6899295",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/75110443f1ce14e79dfabf70a02e38a5a6899295"
        }
      ],
      "message": "txgraph: (refactor) group per-graph data in ClusterSet\n\nThis is a preparation for a next commit where a TxGraph will start representing\npotentially two distinct graphs (a main one, and a staging one with proposed\nchanges).",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-03-19T21:23:17Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-11-24T13:37:53Z"
      },
      "sha": "9bd379457d461eefe78e90681e362fe285aa28d4"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGUxOWExMDE3NjU1MGZlNTdjM2M1YjQ3ZDM3NjBjOTc3NjUyNTY1ZjM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e19a10176550fe57c3c5b47d3760c977652565f3",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/e19a10176550fe57c3c5b47d3760c977652565f3",
      "tree": {
        "sha": "db35623a5a16406805112a34422c13a504df107a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/db35623a5a16406805112a34422c13a504df107a"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9bd379457d461eefe78e90681e362fe285aa28d4",
          "sha": "9bd379457d461eefe78e90681e362fe285aa28d4",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/9bd379457d461eefe78e90681e362fe285aa28d4"
        }
      ],
      "message": "txgraph: (refactor) abstract out ClearLocator\n\nMove a number of related modifications to TxGraphImpl into a separate\nfunction for removal of transactions. This is preparation for a later\ncommit where this will be useful in more than one place.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-03-19T21:23:17Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-11-24T15:00:59Z"
      },
      "sha": "e19a10176550fe57c3c5b47d3760c977652565f3"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDAwNjBmMTBjOGQwNzExODI4Y2JkZjI5MWEwOTNiMzU2NWZhMDk5NDg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0060f10c8d0711828cbdf291a093b3565fa09948",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/0060f10c8d0711828cbdf291a093b3565fa09948",
      "tree": {
        "sha": "0f0bddea71969060dfaf94f612a2919a2ea24d01",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0f0bddea71969060dfaf94f612a2919a2ea24d01"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e19a10176550fe57c3c5b47d3760c977652565f3",
          "sha": "e19a10176550fe57c3c5b47d3760c977652565f3",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/e19a10176550fe57c3c5b47d3760c977652565f3"
        }
      ],
      "message": "txgraph: (feature) add staging support\n\nIn order to make it easy to evaluate proposed changes to a TxGraph, introduce a\n\"staging\" mode, where mutators (AddTransaction, AddDependency, RemoveTransaction)\ndo not modify the actual graph, but just a staging version of it. That staging\ngraph can then be commited (replacing the main one with it), or aborted (discarding\nthe staging).",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-03-19T21:23:17Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-12-04T14:40:53Z"
      },
      "sha": "0060f10c8d0711828cbdf291a093b3565fa09948"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDE0ZTE3Y2E4YTFlYWIxYTkzMWRkODNhMDA5ODUxYTVhNGMyOTRiNjk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/14e17ca8a1eab1a931dd83a009851a5a4c294b69",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/14e17ca8a1eab1a931dd83a009851a5a4c294b69",
      "tree": {
        "sha": "35a476f1875940f7af3710979ccdae82ce451abd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/35a476f1875940f7af3710979ccdae82ce451abd"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0060f10c8d0711828cbdf291a093b3565fa09948",
          "sha": "0060f10c8d0711828cbdf291a093b3565fa09948",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/0060f10c8d0711828cbdf291a093b3565fa09948"
        }
      ],
      "message": "txgraph: (optimization) cache oversizedness of graphs",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-03-19T21:23:17Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-01-25T05:27:52Z"
      },
      "sha": "14e17ca8a1eab1a931dd83a009851a5a4c294b69"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDkxYzQ4MDEzZTEzM2VlODE0NzBhYjQxMTI2M2NlNWQ4OWI0Zjk4ZGE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/91c48013e133ee81470ab411263ce5d89b4f98da",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/91c48013e133ee81470ab411263ce5d89b4f98da",
      "tree": {
        "sha": "be92893b1260c729e97e151764d2f6b968d21671",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/be92893b1260c729e97e151764d2f6b968d21671"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/14e17ca8a1eab1a931dd83a009851a5a4c294b69",
          "sha": "14e17ca8a1eab1a931dd83a009851a5a4c294b69",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/14e17ca8a1eab1a931dd83a009851a5a4c294b69"
        }
      ],
      "message": "txgraph: (feature) destroying Ref means removing transaction\n\nBefore this commit, if a TxGraph::Ref object is destroyed, it becomes impossible\nto refer to, but the actual corresponding transaction node in the TxGraph remains,\nand remains indefinitely as there is no way to remove it.\n\nFix this by making the destruction of TxGraph::Ref trigger immediate removal of\nthe corresponding transaction in TxGraph, both in main and staging if it exists.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-03-19T21:23:17Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-12-03T16:25:49Z"
      },
      "sha": "91c48013e133ee81470ab411263ce5d89b4f98da"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDM4ZGU1MzZhZDBjOTI5Y2MyYTU0YzJhZDY4YWNkYzU3Y2QwZTQ3YTk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/38de536ad0c929cc2a54c2ad68acdc57cd0e47a9",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/38de536ad0c929cc2a54c2ad68acdc57cd0e47a9",
      "tree": {
        "sha": "561a4612f34e82f04ebbf1d0f461be9b5bd926b8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/561a4612f34e82f04ebbf1d0f461be9b5bd926b8"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/91c48013e133ee81470ab411263ce5d89b4f98da",
          "sha": "91c48013e133ee81470ab411263ce5d89b4f98da",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/91c48013e133ee81470ab411263ce5d89b4f98da"
        }
      ],
      "message": "txgraph: (feature) expose ability to compare transactions\n\nIn order to make it possible for higher layers to compare transaction quality\n(ordering within the implicit total ordering on the mempool), expose a comparison\nfunction and test it.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-03-19T21:23:17Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-11-14T21:16:59Z"
      },
      "sha": "38de536ad0c929cc2a54c2ad68acdc57cd0e47a9"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDI5OTk1MWIxYzA3MDI4MGM3MWY1MTcwYzlkMDJiN2NhZTA3ZTVkNzE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/299951b1c070280c71f5170c9d02b7cae07e5d71",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/299951b1c070280c71f5170c9d02b7cae07e5d71",
      "tree": {
        "sha": "6d00ab9114ca09be2dee986ed6c6523ab6a43a54",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6d00ab9114ca09be2dee986ed6c6523ab6a43a54"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/38de536ad0c929cc2a54c2ad68acdc57cd0e47a9",
          "sha": "38de536ad0c929cc2a54c2ad68acdc57cd0e47a9",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/38de536ad0c929cc2a54c2ad68acdc57cd0e47a9"
        }
      ],
      "message": "txgraph: (feature) Add DoWork function\n\nThis can be called when the caller has time to spend now, and wants future operations\nto be fast.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-03-19T21:23:17Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-01-09T19:22:24Z"
      },
      "sha": "299951b1c070280c71f5170c9d02b7cae07e5d71"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGU1OWU2M2YyNzE1NWY1ZDg1ZmRhZGUwOWQ5MDY3ZTA3YmY3MWU0N2U",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e59e63f27155f5d85fdade09d9067e07bf71e47e",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/e59e63f27155f5d85fdade09d9067e07bf71e47e",
      "tree": {
        "sha": "3a05f1f6ed50d008736cfc874539dc7142ff6a71",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3a05f1f6ed50d008736cfc874539dc7142ff6a71"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/299951b1c070280c71f5170c9d02b7cae07e5d71",
          "sha": "299951b1c070280c71f5170c9d02b7cae07e5d71",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/299951b1c070280c71f5170c9d02b7cae07e5d71"
        }
      ],
      "message": "txgraph: (feature) Add CountDistinctClusters function",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-03-19T21:23:17Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-01-16T21:00:10Z"
      },
      "sha": "e59e63f27155f5d85fdade09d9067e07bf71e47e"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGFmZTM3MTc1ZTk5NWE0NDcyNTM4OWYyNjNmZmEwNmRhYTUzMWQyNTI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/afe37175e995a44725389f263ffa06daa531d252",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/afe37175e995a44725389f263ffa06daa531d252",
      "tree": {
        "sha": "7bb6db8ca78d03bd022ceaa5123686c27767f7bb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7bb6db8ca78d03bd022ceaa5123686c27767f7bb"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e59e63f27155f5d85fdade09d9067e07bf71e47e",
          "sha": "e59e63f27155f5d85fdade09d9067e07bf71e47e",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/e59e63f27155f5d85fdade09d9067e07bf71e47e"
        }
      ],
      "message": "txgraph: (preparation) multiple inputs to Get{Ancestors,Descendant}Refs\n\nThis is a preparation for the next commit, which adds a feature to request\nthe Refs to multiple ancestors/descendants at once.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-03-19T21:23:17Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-02-06T03:53:45Z"
      },
      "sha": "afe37175e995a44725389f263ffa06daa531d252"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDYzYjhmOTZlNjdmOWFkNjQ5MDcwYTIzMTUzMmQ0OGZiNmMzNTczZTQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/63b8f96e67f9ad649070a231532d48fb6c3573e4",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/63b8f96e67f9ad649070a231532d48fb6c3573e4",
      "tree": {
        "sha": "8c83abf1f048954c606f69dc540aec3688f5c318",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8c83abf1f048954c606f69dc540aec3688f5c318"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/afe37175e995a44725389f263ffa06daa531d252",
          "sha": "afe37175e995a44725389f263ffa06daa531d252",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/afe37175e995a44725389f263ffa06daa531d252"
        }
      ],
      "message": "txgraph: (feature) Get{Ancestors,Descendants}Union",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-03-19T21:23:17Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-02-06T03:52:58Z"
      },
      "sha": "63b8f96e67f9ad649070a231532d48fb6c3573e4"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDliOWM2ODQzMjcwOTZmMWEwZmZkNTUwYWE5MmFlZjAyNjM2NjFlZjY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9b9c684327096f1a0ffd550aa92aef0263661ef6",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/9b9c684327096f1a0ffd550aa92aef0263661ef6",
      "tree": {
        "sha": "5cc3360c726608431606a1b3ab81984ff41a7f95",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5cc3360c726608431606a1b3ab81984ff41a7f95"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/63b8f96e67f9ad649070a231532d48fb6c3573e4",
          "sha": "63b8f96e67f9ad649070a231532d48fb6c3573e4",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/63b8f96e67f9ad649070a231532d48fb6c3573e4"
        }
      ],
      "message": "txgraph: (feature) Add GetMainStagingDiagrams function\n\nThis allows determining whether the changes in a staging diagram unambiguously improve\nthe graph, through CompareChunks().",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-03-19T21:23:17Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-11-28T15:40:42Z"
      },
      "sha": "9b9c684327096f1a0ffd550aa92aef0263661ef6"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGZhMmNhZTI1MDZhMzA1ZTI5ZGJhMDIxOGYxZmQ1Nzc3MmRkZDEyZTY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fa2cae2506a305e29dba0218f1fd57772ddd12e6",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/fa2cae2506a305e29dba0218f1fd57772ddd12e6",
      "tree": {
        "sha": "71740c3e7beeb084beae93ad78bf53e02c64c36f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/71740c3e7beeb084beae93ad78bf53e02c64c36f"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9b9c684327096f1a0ffd550aa92aef0263661ef6",
          "sha": "9b9c684327096f1a0ffd550aa92aef0263661ef6",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/9b9c684327096f1a0ffd550aa92aef0263661ef6"
        }
      ],
      "message": "txgraph: (preparation) maintain chunk index\n\nThis is preparation for exposing mining and eviction functionality in\nTxGraph.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-03-19T21:23:17Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-11-14T20:54:03Z"
      },
      "sha": "fa2cae2506a305e29dba0218f1fd57772ddd12e6"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDE5ZDliZDdkZWYyZGI5ZTM2M2Y2OTVlNTkwZjg2ZGY0OTU3MGRiNzM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/19d9bd7def2db9e363f695e590f86df49570db73",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/19d9bd7def2db9e363f695e590f86df49570db73",
      "tree": {
        "sha": "8f7fa82a54f16d1bdaebc3f45d6312958da4639c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8f7fa82a54f16d1bdaebc3f45d6312958da4639c"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fa2cae2506a305e29dba0218f1fd57772ddd12e6",
          "sha": "fa2cae2506a305e29dba0218f1fd57772ddd12e6",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/fa2cae2506a305e29dba0218f1fd57772ddd12e6"
        }
      ],
      "message": "txgraph: (feature) introduce BlockBuilder interface\n\nThis interface lets one iterate efficiently over the chunks of the main\ngraph in a TxGraph, in the same order as CompareMainOrder. Each chunk\ncan be marked as \"included\" or \"skipped\" (and in the latter case,\ndependent chunks will be skipped).",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-03-19T21:23:17Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-11-25T16:31:02Z"
      },
      "sha": "19d9bd7def2db9e363f695e590f86df49570db73"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGE4NmVhMDVmNWZmZTFlY2I4NzE2OTYyMTYzZjVjMTZhNzYyZmY2ZWI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a86ea05f5ffe1ecb8716962163f5c16a762ff6eb",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/a86ea05f5ffe1ecb8716962163f5c16a762ff6eb",
      "tree": {
        "sha": "85832177e37340c6af753b4fcc697af9577dced6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/85832177e37340c6af753b4fcc697af9577dced6"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/19d9bd7def2db9e363f695e590f86df49570db73",
          "sha": "19d9bd7def2db9e363f695e590f86df49570db73",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/19d9bd7def2db9e363f695e590f86df49570db73"
        }
      ],
      "message": "txgraph: (feature) introduce TxGraph::GetWorstMainChunk\n\nIt returns the last chunk that would be suggested for mining by BlockBuilder\nobjects. This is intended for eviction.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-03-19T21:23:17Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-01-08T22:18:12Z"
      },
      "sha": "a86ea05f5ffe1ecb8716962163f5c16a762ff6eb"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDQ1ZmJkMDU0MDI5ZTU3NTE4NGVkODBjNDYwYzA2ODc2ZTE3MmU3ZTY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/45fbd054029e575184ed80c460c06876e172e7e6",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/45fbd054029e575184ed80c460c06876e172e7e6",
      "tree": {
        "sha": "c06d4aeb4e22df52f8d4947c5341ca9c4d7518a2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c06d4aeb4e22df52f8d4947c5341ca9c4d7518a2"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a86ea05f5ffe1ecb8716962163f5c16a762ff6eb",
          "sha": "a86ea05f5ffe1ecb8716962163f5c16a762ff6eb",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/a86ea05f5ffe1ecb8716962163f5c16a762ff6eb"
        }
      ],
      "message": "txgraph: (optimization) reuse discarded chunkindex entries",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-03-19T21:23:17Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-12-02T18:33:41Z"
      },
      "sha": "45fbd054029e575184ed80c460c06876e172e7e6"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDA3ZWVhMWM1YzFkNjM1ZjU3YTc2OGMxZTc3MjQ2NTk5NDY1YWEyZmM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/07eea1c5c1d635f57a768c1e77246599465aa2fc",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/07eea1c5c1d635f57a768c1e77246599465aa2fc",
      "tree": {
        "sha": "a62ec0236e838f8a7d13b35da16d1528964f56a9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a62ec0236e838f8a7d13b35da16d1528964f56a9"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/45fbd054029e575184ed80c460c06876e172e7e6",
          "sha": "45fbd054029e575184ed80c460c06876e172e7e6",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/45fbd054029e575184ed80c460c06876e172e7e6"
        }
      ],
      "message": "txgraph: (optimization) skipping end of cluster has no impact",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-03-19T21:23:17Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-11-27T21:12:10Z"
      },
      "sha": "07eea1c5c1d635f57a768c1e77246599465aa2fc"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDdhZWYxMGQ2Mzg2NTcyOGZhMjE1NDBlZDE4OGViMzYzZmM5MjE1ZTI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7aef10d63865728fa21540ed188eb363fc9215e2",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/7aef10d63865728fa21540ed188eb363fc9215e2",
      "tree": {
        "sha": "fb3ec1b49cb65997da10f5930a923c5b6a748d53",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fb3ec1b49cb65997da10f5930a923c5b6a748d53"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/07eea1c5c1d635f57a768c1e77246599465aa2fc",
          "sha": "07eea1c5c1d635f57a768c1e77246599465aa2fc",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/07eea1c5c1d635f57a768c1e77246599465aa2fc"
        }
      ],
      "message": "txgraph: (optimization) special-case singletons in chunk index",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-03-19T21:23:17Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-11-27T20:29:40Z"
      },
      "sha": "7aef10d63865728fa21540ed188eb363fc9215e2"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDk0ZjUxMzNmZWFmZTcxMGRjMWU1MDQxMTVlMjIyY2I0MjEwNTdlNWE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/94f5133feafe710dc1e504115e222cb421057e5a",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/94f5133feafe710dc1e504115e222cb421057e5a",
      "tree": {
        "sha": "0947f1e48ec55480b605ce21cb7491f2762450b7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0947f1e48ec55480b605ce21cb7491f2762450b7"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7aef10d63865728fa21540ed188eb363fc9215e2",
          "sha": "7aef10d63865728fa21540ed188eb363fc9215e2",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/7aef10d63865728fa21540ed188eb363fc9215e2"
        }
      ],
      "message": "txgraph: (feature) Add ability to configure maximum cluster size (weight)\n\nThis is integrated with the oversized property: the graph is oversized when\nany connected component within it contains more than the cluster count limit\nmany transactions, or when their combined size/weight exceeds the cluster size\nlimit.\n\nIt becomes disallowed to call AddTransaction with a size larger than this limit.\nIn addition, SetTransactionFeeRate becomes SetTransactionFee, so that we do not\nneed to deal with the case that a call to this function might affect the\noversizedness.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-03-19T21:23:17Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-12-17T13:13:25Z"
      },
      "sha": "94f5133feafe710dc1e504115e222cb421057e5a"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGU5NGJmOWZiYWUyODFjZWQ3MjlkZTFjOTgzMmY5ZDEzNWU4YmYwNDk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e94bf9fbae281ced729de1c9832f9d135e8bf049",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/e94bf9fbae281ced729de1c9832f9d135e8bf049",
      "tree": {
        "sha": "2f85203cbfdbd62d02b61eb7d056d30d41356ba7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2f85203cbfdbd62d02b61eb7d056d30d41356ba7"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/94f5133feafe710dc1e504115e222cb421057e5a",
          "sha": "94f5133feafe710dc1e504115e222cb421057e5a",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/94f5133feafe710dc1e504115e222cb421057e5a"
        }
      ],
      "message": "txgraph: (feature) permit transactions that exceed cluster size limit",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-03-19T21:23:17Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-01-25T19:24:41Z"
      },
      "sha": "e94bf9fbae281ced729de1c9832f9d135e8bf049"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDY1ODFjMGMyN2RlZjU2NzI2NGRjMjk4MWI5MmIxOTEzOGRmZTc1NTc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6581c0c27def567264dc2981b92b19138dfe7557",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/6581c0c27def567264dc2981b92b19138dfe7557",
      "tree": {
        "sha": "34971a9fe45671418f54540f7a1180d13c59d4ea",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/34971a9fe45671418f54540f7a1180d13c59d4ea"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e94bf9fbae281ced729de1c9832f9d135e8bf049",
          "sha": "e94bf9fbae281ced729de1c9832f9d135e8bf049",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/e94bf9fbae281ced729de1c9832f9d135e8bf049"
        }
      ],
      "message": "txgraph: (feature) Add ability to trim oversized clusters\n\nDuring reorganisations, it is possible that dependencies get add which\nresult in clusters that violate limits (count, size), when linking the\nnew from-block transactions to the old from-mempool transactions.\n\nUnlike RBF scenarios, we cannot simply reject these policy violations\nwhen they are due to received blocks. To accomodate this, add a Trim()\nfunction to TxGraph, which removes transactions (including descendants)\nin order to make all resulting clusters satisfy the limits.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-03-19T21:23:17Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-12-16T22:57:57Z"
      },
      "sha": "6581c0c27def567264dc2981b92b19138dfe7557"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDM3NDRiODMxOGQ4ZjQ2NTYwM2YwZTZmOWViNzJlNjc5ZDc2M2M0Y2E",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3744b8318d8f465603f0e6f9eb72e679d763c4ca",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/3744b8318d8f465603f0e6f9eb72e679d763c4ca",
      "tree": {
        "sha": "42ac6c206a07e3b15412fa5337eeca1e1918d8c4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/42ac6c206a07e3b15412fa5337eeca1e1918d8c4"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6581c0c27def567264dc2981b92b19138dfe7557",
          "sha": "6581c0c27def567264dc2981b92b19138dfe7557",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/6581c0c27def567264dc2981b92b19138dfe7557"
        }
      ],
      "message": "txgraph: (improvement) track multiple potential would-be clusters in Trim\n\nIn a Trim function, for any given would-be group of clusters, a (rudimentary)\nlinearization for the would-be cluster is constructed on the fly by adding\neligible transactions to a heap. This continues until the total count or\nsize of the transaction exists a configured limit. Any transactions which\nappear later in this linearization are discarded.\n\nHowever, given that transactions at the end are discarded, it is possible that\nthe would-be cluster splits apart into multiple clusters. And those clusters\nmay well permit far more transactions before their limits are reached.\n\nTake this into account by using a union-find structure inside TrimTxData to\nkeep track of the count/size of all would-be clusters that would be formed\nat any point.\n\nThis is not an optimization in terms of CPU usage or memory; it just\nimproves the quality of the transactions removed by Trim().",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-03-19T21:23:17Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-12-20T04:06:07Z"
      },
      "sha": "3744b8318d8f465603f0e6f9eb72e679d763c4ca"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16880113528,
      "node_id": "HRFPE_lADOABII586kMugSzwAAAAPuIhd4",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16880113528",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "3744b8318d8f465603f0e6f9eb72e679d763c4ca",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/3744b8318d8f465603f0e6f9eb72e679d763c4ca",
      "created_at": "2025-03-19T21:23:32Z"
    },
    {
      "event": "unlabeled",
      "id": 16883487972,
      "node_id": "UNLE_lADOABII586kMugSzwAAAAPuVZTk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16883487972",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-20T00:05:26Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909286865",
      "pull_request_review_id": 2540686525,
      "id": 1909286865,
      "node_id": "PRRC_kwDOABII585xzWfR",
      "diff_hunk": "@@ -0,0 +1,1193 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a ClusterIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<ClusterIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(ClusterIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeeFrac GetIndividualFeerate(ClusterIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, ClusterIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Cleanup).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupData\n+    {\n+        /** Where the clusters to be merged start in m_group_clusters. */\n+        uint32_t m_cluster_offset;\n+        /** How many clusters to merge. */\n+        uint32_t m_cluster_count;\n+        /** Where the dependencies for this cluster group in m_deps_to_add start. */\n+        uint32_t m_deps_offset;\n+        /** How many dependencies to add. */\n+        uint32_t m_deps_count;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Which clusters are to be merged. GroupData::m_cluster_offset indexes into this. */\n+    std::vector<Cluster*> m_group_clusters;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupData>> m_group_data = std::vector<GroupData>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        ClusterIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, ClusterIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref;\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeeFrac m_chunk_feerate;\n+\n+        /** Check whether this Entry is not present in any Cluster. */\n+        bool IsWiped() const noexcept\n+        {\n+            return !m_locator.IsPresent();\n+        }\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries that have no IsPresent locators left, and need to be cleaned up. */\n+    std::vector<GraphIndex> m_wiped;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeeFrac& feerate) noexcept final;\n+    void RemoveTransaction(Ref& arg) noexcept final;\n+    void AddDependency(Ref& parent, Ref& child) noexcept final;\n+    void SetTransactionFee(Ref&, int64_t fee) noexcept final;\n+    std::vector<Ref*> Cleanup() noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeeFrac GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeeFrac GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (ClusterIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        while (true) {\n+            ClusterIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = chunk.feerate;\n+            chunk.transactions.Reset(idx);\n+            if (chunk.transactions.None()) break;\n+        }\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        if (entry.IsWiped()) graph.m_wiped.push_back(idx);\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, ClusterIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transaction go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), ClusterIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // ClusterIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<ClusterIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator.SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Sort the list of dependencies to apply by child, so those can be applied in batch.\n+    std::sort(to_apply.begin(), to_apply.end(), [](auto& a, auto& b) { return a.second < b.second; });\n+    // Iterate over groups of to-be-added dependencies with the same child.\n+    auto it = to_apply.begin();\n+    while (it != to_apply.end()) {\n+        auto& first_child = graph.m_entries[it->second].m_locator;\n+        ClusterIndex child_idx = first_child.index;\n+        // Iterate over all to-be-added dependencies within that same child, gather the relevant\n+        // parents.\n+        SetType parents;\n+        while (it != to_apply.end()) {\n+            auto& child = graph.m_entries[it->second].m_locator;\n+            auto& parent = graph.m_entries[it->first].m_locator;\n+            Assume(child.cluster == this && parent.cluster == this);\n+            if (child.index != child_idx) break;\n+            parents.Set(parent.index);\n+            ++it;\n+        }\n+        // Push all dependencies to the underlying DepGraph. Note that this is O(N) in the size of\n+        // the cluster, regardless of the number of parents being added, so batching them together\n+        // has a performance benefit.\n+        m_depgraph.AddDependencies(parents, child_idx);\n+    }\n+\n+    // Finally fix the linearization, as the new dependencies may have invalidated the\n+    // linearization, and post-linearize it to fix up the worst problems with it.\n+    FixLinearization(m_depgraph, m_linearization);\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Finally push the changes to graph.m_entries.\n+    Updated(graph);\n+}\n+\n+std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept\n+{\n+    Assume(quality != QualityLevel::NONE);\n+\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    Assume(setindex < quality_clusters.size());\n+\n+    // Extract the Cluster-owning unique_ptr.\n+    std::unique_ptr<Cluster> ret = std::move(quality_clusters[setindex]);\n+    ret->m_quality = QualityLevel::NONE;\n+    ret->m_setindex = ClusterSetIndex(-1);\n+\n+    // Clean up space in quality_cluster.\n+    auto max_setindex = quality_clusters.size() - 1;\n+    if (setindex != max_setindex) {\n+        // If the cluster was not the last element of quality_clusters, move that to take its place.\n+        quality_clusters.back()->m_quality = quality;\n+        quality_clusters.back()->m_setindex = setindex;\n+        quality_clusters[setindex] = std::move(quality_clusters.back());\n+    }\n+    // The last element of quality_clusters is now unused; drop it.\n+    quality_clusters.pop_back();\n+\n+    return ret;\n+}\n+\n+ClusterSetIndex TxGraphImpl::InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+{\n+    // Cannot insert with quality level NONE (as that would mean not inserted).\n+    Assume(quality != QualityLevel::NONE);\n+    // The passed-in Cluster must not currently be in the TxGraphImpl.\n+    Assume(cluster->m_quality == QualityLevel::NONE);\n+\n+    // Append it at the end of the relevant TxGraphImpl::m_cluster.\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    ClusterSetIndex ret = quality_clusters.size();\n+    cluster->m_quality = quality;\n+    cluster->m_setindex = ret;\n+    quality_clusters.push_back(std::move(cluster));\n+    return ret;\n+}\n+\n+void TxGraphImpl::SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+{\n+    Assume(new_quality != QualityLevel::NONE);\n+\n+    // Don't do anything if the quality did not change.\n+    if (old_quality == new_quality) return;\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(old_quality, old_index);\n+    // And re-insert it where it belongs.\n+    InsertCluster(std::move(cluster_ptr), new_quality);\n+}\n+\n+void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n+{\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(cluster.m_quality, cluster.m_setindex);\n+    // And throw it away.\n+    cluster_ptr.reset();\n+}\n+\n+void TxGraphImpl::ApplyRemovals() noexcept\n+{\n+    auto& to_remove = m_to_remove;\n+    // Skip if there is nothing to remove.\n+    if (to_remove.empty()) return;\n+    // Wipe cached m_group_data, as it may be invalidated by removals.\n+    m_group_data = std::nullopt;\n+    m_group_clusters.clear();\n+    // Group the set of to-be-removed entries by Cluster*.\n+    std::sort(m_to_remove.begin(), m_to_remove.end(), [&](GraphIndex a, GraphIndex b) noexcept {\n+        return std::less{}(m_entries[a].m_locator.cluster, m_entries[b].m_locator.cluster);\n+    });\n+    // Process per Cluster.\n+    std::span to_remove_span{m_to_remove};\n+    while (!to_remove_span.empty()) {\n+        Cluster* cluster = m_entries[to_remove_span.front()].m_locator.cluster;\n+        if (cluster != nullptr) {\n+            // If the first to_remove_span entry's Cluster exists, hand to_remove_span to it, so it\n+            // can pop off whatever applies to it.\n+            cluster->ApplyRemovals(*this, to_remove_span);\n+        } else {\n+            // Otherwise, skip this already-removed entry.\n+            to_remove_span = to_remove_span.subspan(1);\n+        }\n+    }\n+    m_to_remove.clear();\n+}\n+\n+void TxGraphImpl::SwapIndexes(GraphIndex a, GraphIndex b) noexcept\n+{\n+    Assume(a < m_entries.size());\n+    Assume(b < m_entries.size());\n+    // Swap the Entry objects.\n+    std::swap(m_entries[a], m_entries[b]);\n+    // Iterate over both objects.\n+    for (int i = 0; i < 2; ++i) {\n+        GraphIndex idx = i ? b : a;\n+        Entry& entry = m_entries[idx];\n+        // Update linked Ref.\n+        if (entry.m_ref) GetRefIndex(*entry.m_ref) = idx;\n+        // Update the locator. The rest of the Entry information will not change, so no need to\n+        // invoke Cluster::Updated().\n+        Locator& locator = entry.m_locator;\n+        if (locator.IsPresent()) {\n+            locator.cluster->UpdateMapping(locator.index, idx);\n+        }\n+    }\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::Cleanup() noexcept\n+{\n+    ApplyDependencies();\n+    std::vector<Ref*> ret;\n+    // Sort the GraphIndex that need to be cleaned up. This groups them (so duplicates can be\n+    // processed just once). They are sorted in reverse, so the last ones get processed first.\n+    // This means earlier-processed GraphIndexes will not move of later-processed ones (which\n+    // might invalidate them).\n+    std::sort(m_wiped.begin(), m_wiped.end(), std::greater{});\n+    GraphIndex last(-1);\n+    for (GraphIndex idx : m_wiped) {\n+        // m_wiped should never contain the same GraphIndex twice (the code below would fail\n+        // if so, because GraphIndexes get invalidated by removing them).\n+        Assume(idx != last);\n+        last = idx;\n+        Entry& entry = m_entries[idx];\n+        // Gather Ref pointers that are being unlinked.\n+        if (entry.m_ref != nullptr) {\n+            ret.push_back(entry.m_ref);\n+            GetRefGraph(*entry.m_ref) = nullptr;\n+            m_entries[idx].m_ref = nullptr;\n+        }\n+        // Verify removed entries don't have anything that could hold a reference back.\n+        Assume(!entry.m_locator.IsPresent());\n+        if (idx != m_entries.size() - 1) SwapIndexes(idx, m_entries.size() - 1);\n+        m_entries.pop_back();\n+    }\n+    m_wiped.clear();\n+    return ret;\n+}\n+\n+void TxGraphImpl::Split(Cluster& cluster) noexcept\n+{\n+    // To split a Cluster, first make sure all removals are applied (as we might need to split\n+    // again afterwards otherwise).\n+    ApplyRemovals();\n+    bool del = cluster.Split(*this);\n+    if (del) {\n+        // Cluster::Split reports whether the Cluster is to be deleted.\n+        DeleteCluster(cluster);\n+    }\n+}\n+\n+void TxGraphImpl::SplitAll() noexcept\n+{\n+    // Before splitting all Cluster, first make sure all removals are applied.\n+    ApplyRemovals();\n+    auto& queue = m_clusters[int(QualityLevel::NEEDS_SPLIT)];\n+    while (!queue.empty()) {\n+        Split(*queue.back().get());\n+    }\n+}\n+\n+void TxGraphImpl::GroupClusters() noexcept\n+{\n+    // Before computing which Clusters need to be merged together, first apply all removals and\n+    // split the Clusters into connected components. If we would group first, we might end up\n+    // with inefficient Clusters which just end up being split again anyway.\n+    SplitAll();\n+\n+    // If the groupings have been computed already, nothing is left to be done.\n+    if (m_group_data.has_value()) return;\n+\n+    /** Annotated clusters: an entry for each Cluster, together with the representative for the\n+     *  partition it is in if known, or with nullptr if not yet known. */\n+    std::vector<std::pair<Cluster*, Cluster*>> an_clusters;\n+    /** Annotated dependencies: an entry for each m_deps_to_apply entry (excluding ones that apply\n+     *  to removed transactions), together with the representative root of the partition of\n+     *  Clusters it applies to. */\n+    std::vector<std::pair<std::pair<GraphIndex, GraphIndex>, Cluster*>> an_deps;\n+\n+    // Construct a an_clusters entry for every parent and child in the to-be-applied dependencies.\n+    for (const auto& [par, chl] : m_deps_to_add) {\n+        auto par_cluster = m_entries[par].m_locator.cluster;\n+        auto chl_cluster = m_entries[chl].m_locator.cluster;\n+        // Skip dependencies for which the parent or child transaction is removed.\n+        if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+        an_clusters.emplace_back(par_cluster, nullptr);\n+        // Do not include a duplicate when parent and child are identical, as it'll be removed\n+        // below anyway.\n+        if (chl_cluster != par_cluster) an_clusters.emplace_back(chl_cluster, nullptr);\n+    }\n+    // Sort and deduplicate an_clusters, so we end up with a sorted list of all involved Clusters\n+    // to which dependencies apply.\n+    std::sort(an_clusters.begin(), an_clusters.end());\n+    an_clusters.erase(std::unique(an_clusters.begin(), an_clusters.end()), an_clusters.end());\n+\n+    // Sort the dependencies by child Cluster.\n+    std::sort(m_deps_to_add.begin(), m_deps_to_add.end(), [&](auto& a, auto& b) noexcept {\n+        auto [_a_par, a_chl] = a;\n+        auto [_b_par, b_chl] = b;\n+        auto a_chl_cluster = m_entries[a_chl].m_locator.cluster;\n+        auto b_chl_cluster = m_entries[b_chl].m_locator.cluster;\n+        return std::less{}(a_chl_cluster, b_chl_cluster);\n+    });\n+\n+    // Run the union-find algorithm to to find partitions of the input Clusters which need to be\n+    // grouped together. See https://en.wikipedia.org/wiki/Disjoint-set_data_structure.\n+    {\n+        /** Each PartitionData entry contains information about a single input Cluster. */\n+        struct PartitionData\n+        {\n+            /** The cluster this holds information for. */\n+            Cluster* cluster;\n+            /** All PartitionData entries belonging to the same partition are organized in a tree.\n+             *  Each element points to its parent, or to itself if it is the root. The root is then\n+             *  a representative for the entire tree, and can be found by walking upwards from any\n+             *  element. */\n+            PartitionData* parent;\n+            /** (only if this is a root, so when parent == this) An upper bound on the height of\n+             *  tree for this partition. */\n+            unsigned rank;\n+        };\n+        /** Information about each input Cluster. Sorted by Cluster* pointer. */\n+        std::vector<PartitionData> partition_data;\n+\n+        /** Given a Cluster, find its corresponding PartitionData. */\n+        auto locate_uf = [&](Cluster* arg) noexcept -> PartitionData* {\n+            auto it = std::lower_bound(partition_data.begin(), partition_data.end(), arg,\n+                                       [](auto& a, Cluster* ptr) noexcept { return a.cluster < ptr; });\n+            Assume(it != partition_data.end());\n+            Assume(it->cluster == arg);\n+            return &*it;\n+        };\n+\n+        /** Given a PartitionData, find the root of the tree it is in (its representative). */\n+        static constexpr auto find_uf = [](PartitionData* data) noexcept -> PartitionData* {\n+            while (data->parent != data) {\n+                // Replace pointers to parents with pointers to grandparents.\n+                // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Finding_set_representatives.\n+                auto par = data->parent;\n+                data->parent = par->parent;\n+                data = par;\n+            }\n+            return data;\n+        };\n+\n+        /** Given two PartitionDatas, union the partitions they are in, and return their\n+         *  representative. */\n+        static constexpr auto union_uf = [](PartitionData* arg1, PartitionData* arg2) noexcept {\n+            // Find the roots of the trees, and bail out if they are already equal (which would\n+            // mean they are in the same partition already).\n+            auto rep1 = find_uf(arg1);\n+            auto rep2 = find_uf(arg2);\n+            if (rep1 == rep2) return rep1;\n+            // Pick the lower-rank root to become a child of the higher-rank one.\n+            // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Union_by_rank.\n+            if (rep1->rank < rep2->rank) std::swap(rep1, rep2);\n+            rep2->parent = rep1;\n+            rep1->rank += (rep1->rank == rep2->rank);\n+            return rep1;\n+        };\n+\n+        // Start by initializing every Cluster as its own singleton partition.\n+        partition_data.resize(an_clusters.size());\n+        for (size_t i = 0; i < an_clusters.size(); ++i) {\n+            partition_data[i].cluster = an_clusters[i].first;\n+            partition_data[i].parent = &partition_data[i];\n+            partition_data[i].rank = 0;\n+        }\n+\n+        // Run through all parent/child pairs in m_deps_to_add, and union the\n+        // the partitions their Clusters are in.\n+        Cluster* last_chl_cluster{nullptr};\n+        PartitionData* last_partition{nullptr};\n+        for (const auto& [par, chl] : m_deps_to_add) {\n+            auto par_cluster = m_entries[par].m_locator.cluster;\n+            auto chl_cluster = m_entries[chl].m_locator.cluster;\n+            // Nothing to do if parent and child are in the same Cluster.\n+            if (par_cluster == chl_cluster) continue;\n+            // Nothing to do if either parent or child transaction is removed already.\n+            if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+            Assume(par != chl);\n+            if (chl_cluster == last_chl_cluster) {\n+                // If the child Clusters is the same as the previous iteration, union with the\n+                // tree they were in, avoiding the need for another lookup. Note that m_deps_to_add\n+                // is sorted by child Cluster, so batches with the same child are expected.\n+                last_partition = union_uf(locate_uf(par_cluster), last_partition);\n+            } else {\n+                last_chl_cluster = chl_cluster;\n+                last_partition = union_uf(locate_uf(par_cluster), locate_uf(chl_cluster));\n+            }\n+        }\n+\n+        // Populate the an_clusters and an_deps data structures with the list of input Clusters,\n+        // and the input dependencies, annotated with the representative of the Cluster partition\n+        // it applies to.\n+        an_deps.reserve(m_deps_to_add.size());\n+        auto deps_it = m_deps_to_add.begin();\n+        for (size_t i = 0; i < partition_data.size(); ++i) {\n+            auto& data = partition_data[i];\n+            // Find the representative of the partition Cluster i is in, and store it with the\n+            // Cluster.\n+            auto rep = find_uf(&data)->cluster;\n+            an_clusters[i].second = rep;\n+            // Find all dependencies whose child Cluster is Cluster i, and annotate them with rep.\n+            while (deps_it != m_deps_to_add.end()) {\n+                auto [par, chl] = *deps_it;\n+                auto chl_cluster = m_entries[chl].m_locator.cluster;\n+                // Skip dependencies that apply to earlier Clusters (those necessary are for\n+                // deleted transactions, as otherwise we'd have processed them already).\n+                if (!std::less{}(chl_cluster, data.cluster)) {\n+                    if (chl_cluster != data.cluster) break;\n+                    auto par_cluster = m_entries[par].m_locator.cluster;\n+                    // Also filter out dependencies applying to a removed parent.\n+                    if (par_cluster != nullptr) an_deps.emplace_back(*deps_it, rep);\n+                }\n+                ++deps_it;\n+            }\n+        }\n+    }\n+\n+    // Sort both an_clusters and an_deps by representative of the partition they are in, grouping\n+    // all those applying to the same partition together.\n+    std::sort(an_deps.begin(), an_deps.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+    std::sort(an_clusters.begin(), an_clusters.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+\n+    // Translate the resulting cluster groups to the m_group_data structure.\n+    m_group_data = std::vector<GroupData>{};\n+    m_group_clusters.clear();\n+    m_group_clusters.reserve(an_clusters.size());\n+    m_deps_to_add.clear();\n+    m_deps_to_add.reserve(an_deps.size());\n+    auto an_deps_it = an_deps.begin();\n+    auto an_clusters_it = an_clusters.begin();\n+    while (an_deps_it != an_deps.end()) {\n+        auto rep = an_deps_it->second;\n+        // Create and initialize a new GroupData entry for the partition.\n+        auto& new_entry = m_group_data->emplace_back();\n+        new_entry.m_cluster_offset = m_group_clusters.size();\n+        new_entry.m_cluster_count = 0;\n+        new_entry.m_deps_offset = m_deps_to_add.size();\n+        new_entry.m_deps_count = 0;\n+        // Add all its clusters to it (copying those from an_clusters to m_group_clusters).\n+        while (an_clusters_it != an_clusters.end() && an_clusters_it->second == rep) {\n+            m_group_clusters.push_back(an_clusters_it->first);\n+            ++an_clusters_it;\n+            ++new_entry.m_cluster_count;\n+        }\n+        // Add all its dependencies to it (copying those back from an_deps to m_deps_to_add).\n+        while (an_deps_it != an_deps.end() && an_deps_it->second == rep) {\n+            m_deps_to_add.push_back(an_deps_it->first);\n+            ++an_deps_it;\n+            ++new_entry.m_deps_count;\n+        }\n+    }\n+    Assume(an_deps_it == an_deps.end());\n+    Assume(an_clusters_it == an_clusters.end());\n+}\n+\n+void TxGraphImpl::Merge(std::span<Cluster*> to_merge) noexcept\n+{\n+    Assume(!to_merge.empty());\n+    // Nothing to do if a group consists of just a single Cluster.\n+    if (to_merge.size() == 1) return;\n+\n+    // Move the largest Cluster to the front of to_merge. As all transactions in other to-be-merged\n+    // Clusters will be moved to that one, putting the largest one first minimizes the number of\n+    // moves.\n+    size_t max_size_pos{0};\n+    ClusterIndex max_size = to_merge[max_size_pos]->GetTxCount();\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        ClusterIndex size = to_merge[i]->GetTxCount();\n+        if (size > max_size) {\n+            max_size_pos = i;\n+            max_size = size;\n+        }\n+    }\n+    if (max_size_pos != 0) std::swap(to_merge[0], to_merge[max_size_pos]);\n+\n+    // Merge all further Clusters in the group into the first one, and delete them.\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        to_merge[0]->Merge(*this, *to_merge[i]);\n+        DeleteCluster(*to_merge[i]);\n+    }\n+}\n+\n+void TxGraphImpl::ApplyDependencies() noexcept\n+{\n+    // Compute the groups of to-be-merged Clusters (which also applies all removals, and splits).\n+    GroupClusters();\n+    Assume(m_group_data.has_value());\n+    // Nothing to do if there are no dependencies to be added.\n+    if (m_deps_to_add.empty()) return;\n+\n+    // For each group of to-be-merged Clusters.\n+    Assume(m_group_data.has_value());\n+    for (const auto& group_data : *m_group_data) {\n+        // Invoke Merge() to merge them into a single Cluster.\n+        auto cluster_span = std::span{m_group_clusters}\n+                                .subspan(group_data.m_cluster_offset, group_data.m_cluster_count);\n+        Merge(cluster_span);\n+        // Actually apply all to-be-added dependencies (for each, parent and child belong to the\n+        // same Cluster because of the merging above).\n+        auto deps_span = std::span{m_deps_to_add}\n+                             .subspan(group_data.m_deps_offset, group_data.m_deps_count);\n+        Assume(!deps_span.empty());\n+        const auto& loc = m_entries[deps_span[0].second].m_locator;\n+        Assume(loc.IsPresent());\n+        loc.cluster->ApplyDependencies(*this, deps_span);\n+    }\n+\n+    // Wipe the list of to-be-added dependencies now that they are applied.\n+    m_deps_to_add.clear();\n+    // Also no further Cluster mergings are needed (note that we clear, but don't set to\n+    // std::nullopt, as that would imply the groupings are unknown).\n+    m_group_data->clear();\n+    m_group_clusters.clear();\n+}\n+\n+void Cluster::Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept\n+{\n+    // We can only relinearize Clusters that do not need splitting.\n+    Assume(m_quality == QualityLevel::OPTIMAL || m_quality == QualityLevel::ACCEPTABLE ||\n+           m_quality == QualityLevel::NEEDS_RELINEARIZE);\n+    // No work is required for Clusters which are already optimally linearized.\n+    if (m_quality == QualityLevel::OPTIMAL) return;\n+    // Invoke the actual linearization algorithm (passing in the existing one).\n+    uint64_t rng_seed = graph.m_rng.rand64();\n+    auto [linearization, optimal] = Linearize(m_depgraph, max_iters, rng_seed, m_linearization);\n+    // Postlinearize if the result isn't optimal already. This guarantees (among other things)\n+    // that the chunks of the resulting linearization are all connected.\n+    if (!optimal) PostLinearize(m_depgraph, linearization);\n+    // Update the linearization.\n+    m_linearization = std::move(linearization);\n+    // Update the Cluster's quality.\n+    auto new_quality = optimal ? QualityLevel::OPTIMAL : QualityLevel::ACCEPTABLE;\n+    graph.SetClusterQuality(m_quality, m_setindex, new_quality);\n+    // Update the Entry objects.\n+    Updated(graph);\n+}\n+\n+void TxGraphImpl::MakeAcceptable(Cluster& cluster) noexcept\n+{\n+    // Relinearize the Cluster if needed.\n+    if (cluster.m_quality == QualityLevel::NEEDS_RELINEARIZE) {\n+        cluster.Relinearize(*this, 10000);\n+    }\n+}\n+\n+Cluster::Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept\n+{\n+    // Create a new transaction in the DepGraph, and remember its position in m_mapping.\n+    auto cluster_idx = m_depgraph.AddTransaction(feerate);\n+    m_mapping.push_back(graph_index);\n+    m_linearization.push_back(cluster_idx);\n+}\n+\n+TxGraph::Ref TxGraphImpl::AddTransaction(const FeeFrac& feerate) noexcept\n+{\n+    // Construct a new Ref.\n+    Ref ret;\n+    // Construct a new Entry, and link it with the Ref.\n+    auto idx = m_entries.size();\n+    m_entries.emplace_back();\n+    auto& entry = m_entries.back();\n+    entry.m_ref = &ret;",
      "path": "src/txgraph.cpp",
      "position": 1689,
      "original_position": 953,
      "commit_id": "3744b8318d8f465603f0e6f9eb72e679d763c4ca",
      "original_commit_id": "0c8dc2323eb1ec34357a807f0860cf0a08a63a75",
      "in_reply_to_id": null,
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I'm not sure how this is intended to be used, but storing a stack address seems like a problem? RVO may help but that seems brittle. I imagine the caller should be passing in their own `Ref` instead?",
      "created_at": "2025-01-09T18:43:50Z",
      "updated_at": "2025-01-09T20:03:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r1909286865",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909286865"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1689,
      "original_line": 1689,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909293407",
      "pull_request_review_id": 2540686525,
      "id": 1909293407,
      "node_id": "PRRC_kwDOABII585xzYFf",
      "diff_hunk": "@@ -0,0 +1,1193 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a ClusterIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<ClusterIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(ClusterIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeeFrac GetIndividualFeerate(ClusterIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, ClusterIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Cleanup).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupData\n+    {\n+        /** Where the clusters to be merged start in m_group_clusters. */\n+        uint32_t m_cluster_offset;\n+        /** How many clusters to merge. */\n+        uint32_t m_cluster_count;\n+        /** Where the dependencies for this cluster group in m_deps_to_add start. */\n+        uint32_t m_deps_offset;\n+        /** How many dependencies to add. */\n+        uint32_t m_deps_count;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Which clusters are to be merged. GroupData::m_cluster_offset indexes into this. */\n+    std::vector<Cluster*> m_group_clusters;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupData>> m_group_data = std::vector<GroupData>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        ClusterIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, ClusterIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref;\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeeFrac m_chunk_feerate;\n+\n+        /** Check whether this Entry is not present in any Cluster. */\n+        bool IsWiped() const noexcept\n+        {\n+            return !m_locator.IsPresent();\n+        }\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries that have no IsPresent locators left, and need to be cleaned up. */\n+    std::vector<GraphIndex> m_wiped;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeeFrac& feerate) noexcept final;\n+    void RemoveTransaction(Ref& arg) noexcept final;\n+    void AddDependency(Ref& parent, Ref& child) noexcept final;\n+    void SetTransactionFee(Ref&, int64_t fee) noexcept final;\n+    std::vector<Ref*> Cleanup() noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeeFrac GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeeFrac GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (ClusterIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        while (true) {\n+            ClusterIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = chunk.feerate;\n+            chunk.transactions.Reset(idx);\n+            if (chunk.transactions.None()) break;\n+        }\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        if (entry.IsWiped()) graph.m_wiped.push_back(idx);\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, ClusterIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transaction go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), ClusterIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // ClusterIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<ClusterIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator.SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Sort the list of dependencies to apply by child, so those can be applied in batch.\n+    std::sort(to_apply.begin(), to_apply.end(), [](auto& a, auto& b) { return a.second < b.second; });\n+    // Iterate over groups of to-be-added dependencies with the same child.\n+    auto it = to_apply.begin();\n+    while (it != to_apply.end()) {\n+        auto& first_child = graph.m_entries[it->second].m_locator;\n+        ClusterIndex child_idx = first_child.index;\n+        // Iterate over all to-be-added dependencies within that same child, gather the relevant\n+        // parents.\n+        SetType parents;\n+        while (it != to_apply.end()) {\n+            auto& child = graph.m_entries[it->second].m_locator;\n+            auto& parent = graph.m_entries[it->first].m_locator;\n+            Assume(child.cluster == this && parent.cluster == this);\n+            if (child.index != child_idx) break;\n+            parents.Set(parent.index);\n+            ++it;\n+        }\n+        // Push all dependencies to the underlying DepGraph. Note that this is O(N) in the size of\n+        // the cluster, regardless of the number of parents being added, so batching them together\n+        // has a performance benefit.\n+        m_depgraph.AddDependencies(parents, child_idx);\n+    }\n+\n+    // Finally fix the linearization, as the new dependencies may have invalidated the\n+    // linearization, and post-linearize it to fix up the worst problems with it.\n+    FixLinearization(m_depgraph, m_linearization);\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Finally push the changes to graph.m_entries.\n+    Updated(graph);\n+}\n+\n+std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept\n+{\n+    Assume(quality != QualityLevel::NONE);\n+\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    Assume(setindex < quality_clusters.size());\n+\n+    // Extract the Cluster-owning unique_ptr.\n+    std::unique_ptr<Cluster> ret = std::move(quality_clusters[setindex]);\n+    ret->m_quality = QualityLevel::NONE;\n+    ret->m_setindex = ClusterSetIndex(-1);\n+\n+    // Clean up space in quality_cluster.\n+    auto max_setindex = quality_clusters.size() - 1;\n+    if (setindex != max_setindex) {\n+        // If the cluster was not the last element of quality_clusters, move that to take its place.\n+        quality_clusters.back()->m_quality = quality;\n+        quality_clusters.back()->m_setindex = setindex;\n+        quality_clusters[setindex] = std::move(quality_clusters.back());\n+    }\n+    // The last element of quality_clusters is now unused; drop it.\n+    quality_clusters.pop_back();\n+\n+    return ret;\n+}\n+\n+ClusterSetIndex TxGraphImpl::InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+{\n+    // Cannot insert with quality level NONE (as that would mean not inserted).\n+    Assume(quality != QualityLevel::NONE);\n+    // The passed-in Cluster must not currently be in the TxGraphImpl.\n+    Assume(cluster->m_quality == QualityLevel::NONE);\n+\n+    // Append it at the end of the relevant TxGraphImpl::m_cluster.\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    ClusterSetIndex ret = quality_clusters.size();\n+    cluster->m_quality = quality;\n+    cluster->m_setindex = ret;\n+    quality_clusters.push_back(std::move(cluster));\n+    return ret;\n+}\n+\n+void TxGraphImpl::SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+{\n+    Assume(new_quality != QualityLevel::NONE);\n+\n+    // Don't do anything if the quality did not change.\n+    if (old_quality == new_quality) return;\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(old_quality, old_index);\n+    // And re-insert it where it belongs.\n+    InsertCluster(std::move(cluster_ptr), new_quality);\n+}\n+\n+void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n+{\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(cluster.m_quality, cluster.m_setindex);\n+    // And throw it away.\n+    cluster_ptr.reset();\n+}\n+\n+void TxGraphImpl::ApplyRemovals() noexcept\n+{\n+    auto& to_remove = m_to_remove;\n+    // Skip if there is nothing to remove.\n+    if (to_remove.empty()) return;\n+    // Wipe cached m_group_data, as it may be invalidated by removals.\n+    m_group_data = std::nullopt;\n+    m_group_clusters.clear();\n+    // Group the set of to-be-removed entries by Cluster*.\n+    std::sort(m_to_remove.begin(), m_to_remove.end(), [&](GraphIndex a, GraphIndex b) noexcept {\n+        return std::less{}(m_entries[a].m_locator.cluster, m_entries[b].m_locator.cluster);\n+    });\n+    // Process per Cluster.\n+    std::span to_remove_span{m_to_remove};\n+    while (!to_remove_span.empty()) {\n+        Cluster* cluster = m_entries[to_remove_span.front()].m_locator.cluster;\n+        if (cluster != nullptr) {\n+            // If the first to_remove_span entry's Cluster exists, hand to_remove_span to it, so it\n+            // can pop off whatever applies to it.\n+            cluster->ApplyRemovals(*this, to_remove_span);\n+        } else {\n+            // Otherwise, skip this already-removed entry.\n+            to_remove_span = to_remove_span.subspan(1);\n+        }\n+    }\n+    m_to_remove.clear();\n+}\n+\n+void TxGraphImpl::SwapIndexes(GraphIndex a, GraphIndex b) noexcept\n+{\n+    Assume(a < m_entries.size());\n+    Assume(b < m_entries.size());\n+    // Swap the Entry objects.\n+    std::swap(m_entries[a], m_entries[b]);\n+    // Iterate over both objects.\n+    for (int i = 0; i < 2; ++i) {\n+        GraphIndex idx = i ? b : a;\n+        Entry& entry = m_entries[idx];\n+        // Update linked Ref.\n+        if (entry.m_ref) GetRefIndex(*entry.m_ref) = idx;\n+        // Update the locator. The rest of the Entry information will not change, so no need to\n+        // invoke Cluster::Updated().\n+        Locator& locator = entry.m_locator;\n+        if (locator.IsPresent()) {\n+            locator.cluster->UpdateMapping(locator.index, idx);\n+        }\n+    }\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::Cleanup() noexcept\n+{\n+    ApplyDependencies();\n+    std::vector<Ref*> ret;\n+    // Sort the GraphIndex that need to be cleaned up. This groups them (so duplicates can be\n+    // processed just once). They are sorted in reverse, so the last ones get processed first.\n+    // This means earlier-processed GraphIndexes will not move of later-processed ones (which\n+    // might invalidate them).\n+    std::sort(m_wiped.begin(), m_wiped.end(), std::greater{});\n+    GraphIndex last(-1);\n+    for (GraphIndex idx : m_wiped) {\n+        // m_wiped should never contain the same GraphIndex twice (the code below would fail\n+        // if so, because GraphIndexes get invalidated by removing them).\n+        Assume(idx != last);\n+        last = idx;\n+        Entry& entry = m_entries[idx];\n+        // Gather Ref pointers that are being unlinked.\n+        if (entry.m_ref != nullptr) {\n+            ret.push_back(entry.m_ref);\n+            GetRefGraph(*entry.m_ref) = nullptr;\n+            m_entries[idx].m_ref = nullptr;\n+        }\n+        // Verify removed entries don't have anything that could hold a reference back.\n+        Assume(!entry.m_locator.IsPresent());\n+        if (idx != m_entries.size() - 1) SwapIndexes(idx, m_entries.size() - 1);\n+        m_entries.pop_back();\n+    }\n+    m_wiped.clear();\n+    return ret;\n+}\n+\n+void TxGraphImpl::Split(Cluster& cluster) noexcept\n+{\n+    // To split a Cluster, first make sure all removals are applied (as we might need to split\n+    // again afterwards otherwise).\n+    ApplyRemovals();\n+    bool del = cluster.Split(*this);\n+    if (del) {\n+        // Cluster::Split reports whether the Cluster is to be deleted.\n+        DeleteCluster(cluster);\n+    }\n+}\n+\n+void TxGraphImpl::SplitAll() noexcept\n+{\n+    // Before splitting all Cluster, first make sure all removals are applied.\n+    ApplyRemovals();\n+    auto& queue = m_clusters[int(QualityLevel::NEEDS_SPLIT)];\n+    while (!queue.empty()) {\n+        Split(*queue.back().get());\n+    }\n+}\n+\n+void TxGraphImpl::GroupClusters() noexcept\n+{\n+    // Before computing which Clusters need to be merged together, first apply all removals and\n+    // split the Clusters into connected components. If we would group first, we might end up\n+    // with inefficient Clusters which just end up being split again anyway.\n+    SplitAll();\n+\n+    // If the groupings have been computed already, nothing is left to be done.\n+    if (m_group_data.has_value()) return;\n+\n+    /** Annotated clusters: an entry for each Cluster, together with the representative for the\n+     *  partition it is in if known, or with nullptr if not yet known. */\n+    std::vector<std::pair<Cluster*, Cluster*>> an_clusters;\n+    /** Annotated dependencies: an entry for each m_deps_to_apply entry (excluding ones that apply\n+     *  to removed transactions), together with the representative root of the partition of\n+     *  Clusters it applies to. */\n+    std::vector<std::pair<std::pair<GraphIndex, GraphIndex>, Cluster*>> an_deps;\n+\n+    // Construct a an_clusters entry for every parent and child in the to-be-applied dependencies.\n+    for (const auto& [par, chl] : m_deps_to_add) {\n+        auto par_cluster = m_entries[par].m_locator.cluster;\n+        auto chl_cluster = m_entries[chl].m_locator.cluster;\n+        // Skip dependencies for which the parent or child transaction is removed.\n+        if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+        an_clusters.emplace_back(par_cluster, nullptr);\n+        // Do not include a duplicate when parent and child are identical, as it'll be removed\n+        // below anyway.\n+        if (chl_cluster != par_cluster) an_clusters.emplace_back(chl_cluster, nullptr);\n+    }\n+    // Sort and deduplicate an_clusters, so we end up with a sorted list of all involved Clusters\n+    // to which dependencies apply.\n+    std::sort(an_clusters.begin(), an_clusters.end());\n+    an_clusters.erase(std::unique(an_clusters.begin(), an_clusters.end()), an_clusters.end());\n+\n+    // Sort the dependencies by child Cluster.\n+    std::sort(m_deps_to_add.begin(), m_deps_to_add.end(), [&](auto& a, auto& b) noexcept {\n+        auto [_a_par, a_chl] = a;\n+        auto [_b_par, b_chl] = b;\n+        auto a_chl_cluster = m_entries[a_chl].m_locator.cluster;\n+        auto b_chl_cluster = m_entries[b_chl].m_locator.cluster;\n+        return std::less{}(a_chl_cluster, b_chl_cluster);\n+    });\n+\n+    // Run the union-find algorithm to to find partitions of the input Clusters which need to be\n+    // grouped together. See https://en.wikipedia.org/wiki/Disjoint-set_data_structure.\n+    {\n+        /** Each PartitionData entry contains information about a single input Cluster. */\n+        struct PartitionData\n+        {\n+            /** The cluster this holds information for. */\n+            Cluster* cluster;\n+            /** All PartitionData entries belonging to the same partition are organized in a tree.\n+             *  Each element points to its parent, or to itself if it is the root. The root is then\n+             *  a representative for the entire tree, and can be found by walking upwards from any\n+             *  element. */\n+            PartitionData* parent;\n+            /** (only if this is a root, so when parent == this) An upper bound on the height of\n+             *  tree for this partition. */\n+            unsigned rank;\n+        };\n+        /** Information about each input Cluster. Sorted by Cluster* pointer. */\n+        std::vector<PartitionData> partition_data;\n+\n+        /** Given a Cluster, find its corresponding PartitionData. */\n+        auto locate_uf = [&](Cluster* arg) noexcept -> PartitionData* {\n+            auto it = std::lower_bound(partition_data.begin(), partition_data.end(), arg,\n+                                       [](auto& a, Cluster* ptr) noexcept { return a.cluster < ptr; });\n+            Assume(it != partition_data.end());\n+            Assume(it->cluster == arg);\n+            return &*it;\n+        };\n+\n+        /** Given a PartitionData, find the root of the tree it is in (its representative). */\n+        static constexpr auto find_uf = [](PartitionData* data) noexcept -> PartitionData* {\n+            while (data->parent != data) {\n+                // Replace pointers to parents with pointers to grandparents.\n+                // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Finding_set_representatives.\n+                auto par = data->parent;\n+                data->parent = par->parent;\n+                data = par;\n+            }\n+            return data;\n+        };\n+\n+        /** Given two PartitionDatas, union the partitions they are in, and return their\n+         *  representative. */\n+        static constexpr auto union_uf = [](PartitionData* arg1, PartitionData* arg2) noexcept {\n+            // Find the roots of the trees, and bail out if they are already equal (which would\n+            // mean they are in the same partition already).\n+            auto rep1 = find_uf(arg1);\n+            auto rep2 = find_uf(arg2);\n+            if (rep1 == rep2) return rep1;\n+            // Pick the lower-rank root to become a child of the higher-rank one.\n+            // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Union_by_rank.\n+            if (rep1->rank < rep2->rank) std::swap(rep1, rep2);\n+            rep2->parent = rep1;\n+            rep1->rank += (rep1->rank == rep2->rank);\n+            return rep1;\n+        };\n+\n+        // Start by initializing every Cluster as its own singleton partition.\n+        partition_data.resize(an_clusters.size());\n+        for (size_t i = 0; i < an_clusters.size(); ++i) {\n+            partition_data[i].cluster = an_clusters[i].first;\n+            partition_data[i].parent = &partition_data[i];\n+            partition_data[i].rank = 0;\n+        }\n+\n+        // Run through all parent/child pairs in m_deps_to_add, and union the\n+        // the partitions their Clusters are in.\n+        Cluster* last_chl_cluster{nullptr};\n+        PartitionData* last_partition{nullptr};\n+        for (const auto& [par, chl] : m_deps_to_add) {\n+            auto par_cluster = m_entries[par].m_locator.cluster;\n+            auto chl_cluster = m_entries[chl].m_locator.cluster;\n+            // Nothing to do if parent and child are in the same Cluster.\n+            if (par_cluster == chl_cluster) continue;\n+            // Nothing to do if either parent or child transaction is removed already.\n+            if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+            Assume(par != chl);\n+            if (chl_cluster == last_chl_cluster) {\n+                // If the child Clusters is the same as the previous iteration, union with the\n+                // tree they were in, avoiding the need for another lookup. Note that m_deps_to_add\n+                // is sorted by child Cluster, so batches with the same child are expected.\n+                last_partition = union_uf(locate_uf(par_cluster), last_partition);\n+            } else {\n+                last_chl_cluster = chl_cluster;\n+                last_partition = union_uf(locate_uf(par_cluster), locate_uf(chl_cluster));\n+            }\n+        }\n+\n+        // Populate the an_clusters and an_deps data structures with the list of input Clusters,\n+        // and the input dependencies, annotated with the representative of the Cluster partition\n+        // it applies to.\n+        an_deps.reserve(m_deps_to_add.size());\n+        auto deps_it = m_deps_to_add.begin();\n+        for (size_t i = 0; i < partition_data.size(); ++i) {\n+            auto& data = partition_data[i];\n+            // Find the representative of the partition Cluster i is in, and store it with the\n+            // Cluster.\n+            auto rep = find_uf(&data)->cluster;\n+            an_clusters[i].second = rep;\n+            // Find all dependencies whose child Cluster is Cluster i, and annotate them with rep.\n+            while (deps_it != m_deps_to_add.end()) {\n+                auto [par, chl] = *deps_it;\n+                auto chl_cluster = m_entries[chl].m_locator.cluster;\n+                // Skip dependencies that apply to earlier Clusters (those necessary are for\n+                // deleted transactions, as otherwise we'd have processed them already).\n+                if (!std::less{}(chl_cluster, data.cluster)) {\n+                    if (chl_cluster != data.cluster) break;\n+                    auto par_cluster = m_entries[par].m_locator.cluster;\n+                    // Also filter out dependencies applying to a removed parent.\n+                    if (par_cluster != nullptr) an_deps.emplace_back(*deps_it, rep);\n+                }\n+                ++deps_it;\n+            }\n+        }\n+    }\n+\n+    // Sort both an_clusters and an_deps by representative of the partition they are in, grouping\n+    // all those applying to the same partition together.\n+    std::sort(an_deps.begin(), an_deps.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+    std::sort(an_clusters.begin(), an_clusters.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+\n+    // Translate the resulting cluster groups to the m_group_data structure.\n+    m_group_data = std::vector<GroupData>{};\n+    m_group_clusters.clear();\n+    m_group_clusters.reserve(an_clusters.size());\n+    m_deps_to_add.clear();\n+    m_deps_to_add.reserve(an_deps.size());\n+    auto an_deps_it = an_deps.begin();\n+    auto an_clusters_it = an_clusters.begin();\n+    while (an_deps_it != an_deps.end()) {\n+        auto rep = an_deps_it->second;\n+        // Create and initialize a new GroupData entry for the partition.\n+        auto& new_entry = m_group_data->emplace_back();\n+        new_entry.m_cluster_offset = m_group_clusters.size();\n+        new_entry.m_cluster_count = 0;\n+        new_entry.m_deps_offset = m_deps_to_add.size();\n+        new_entry.m_deps_count = 0;\n+        // Add all its clusters to it (copying those from an_clusters to m_group_clusters).\n+        while (an_clusters_it != an_clusters.end() && an_clusters_it->second == rep) {\n+            m_group_clusters.push_back(an_clusters_it->first);\n+            ++an_clusters_it;\n+            ++new_entry.m_cluster_count;\n+        }\n+        // Add all its dependencies to it (copying those back from an_deps to m_deps_to_add).\n+        while (an_deps_it != an_deps.end() && an_deps_it->second == rep) {\n+            m_deps_to_add.push_back(an_deps_it->first);\n+            ++an_deps_it;\n+            ++new_entry.m_deps_count;\n+        }\n+    }\n+    Assume(an_deps_it == an_deps.end());\n+    Assume(an_clusters_it == an_clusters.end());\n+}\n+\n+void TxGraphImpl::Merge(std::span<Cluster*> to_merge) noexcept\n+{\n+    Assume(!to_merge.empty());\n+    // Nothing to do if a group consists of just a single Cluster.\n+    if (to_merge.size() == 1) return;\n+\n+    // Move the largest Cluster to the front of to_merge. As all transactions in other to-be-merged\n+    // Clusters will be moved to that one, putting the largest one first minimizes the number of\n+    // moves.\n+    size_t max_size_pos{0};\n+    ClusterIndex max_size = to_merge[max_size_pos]->GetTxCount();\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        ClusterIndex size = to_merge[i]->GetTxCount();\n+        if (size > max_size) {\n+            max_size_pos = i;\n+            max_size = size;\n+        }\n+    }\n+    if (max_size_pos != 0) std::swap(to_merge[0], to_merge[max_size_pos]);\n+\n+    // Merge all further Clusters in the group into the first one, and delete them.\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        to_merge[0]->Merge(*this, *to_merge[i]);\n+        DeleteCluster(*to_merge[i]);\n+    }\n+}\n+\n+void TxGraphImpl::ApplyDependencies() noexcept\n+{\n+    // Compute the groups of to-be-merged Clusters (which also applies all removals, and splits).\n+    GroupClusters();\n+    Assume(m_group_data.has_value());\n+    // Nothing to do if there are no dependencies to be added.\n+    if (m_deps_to_add.empty()) return;\n+\n+    // For each group of to-be-merged Clusters.\n+    Assume(m_group_data.has_value());\n+    for (const auto& group_data : *m_group_data) {\n+        // Invoke Merge() to merge them into a single Cluster.\n+        auto cluster_span = std::span{m_group_clusters}\n+                                .subspan(group_data.m_cluster_offset, group_data.m_cluster_count);\n+        Merge(cluster_span);\n+        // Actually apply all to-be-added dependencies (for each, parent and child belong to the\n+        // same Cluster because of the merging above).\n+        auto deps_span = std::span{m_deps_to_add}\n+                             .subspan(group_data.m_deps_offset, group_data.m_deps_count);\n+        Assume(!deps_span.empty());\n+        const auto& loc = m_entries[deps_span[0].second].m_locator;\n+        Assume(loc.IsPresent());\n+        loc.cluster->ApplyDependencies(*this, deps_span);\n+    }\n+\n+    // Wipe the list of to-be-added dependencies now that they are applied.\n+    m_deps_to_add.clear();\n+    // Also no further Cluster mergings are needed (note that we clear, but don't set to\n+    // std::nullopt, as that would imply the groupings are unknown).\n+    m_group_data->clear();\n+    m_group_clusters.clear();\n+}\n+\n+void Cluster::Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept\n+{\n+    // We can only relinearize Clusters that do not need splitting.\n+    Assume(m_quality == QualityLevel::OPTIMAL || m_quality == QualityLevel::ACCEPTABLE ||\n+           m_quality == QualityLevel::NEEDS_RELINEARIZE);\n+    // No work is required for Clusters which are already optimally linearized.\n+    if (m_quality == QualityLevel::OPTIMAL) return;\n+    // Invoke the actual linearization algorithm (passing in the existing one).\n+    uint64_t rng_seed = graph.m_rng.rand64();\n+    auto [linearization, optimal] = Linearize(m_depgraph, max_iters, rng_seed, m_linearization);\n+    // Postlinearize if the result isn't optimal already. This guarantees (among other things)\n+    // that the chunks of the resulting linearization are all connected.\n+    if (!optimal) PostLinearize(m_depgraph, linearization);\n+    // Update the linearization.\n+    m_linearization = std::move(linearization);\n+    // Update the Cluster's quality.\n+    auto new_quality = optimal ? QualityLevel::OPTIMAL : QualityLevel::ACCEPTABLE;\n+    graph.SetClusterQuality(m_quality, m_setindex, new_quality);\n+    // Update the Entry objects.\n+    Updated(graph);\n+}\n+\n+void TxGraphImpl::MakeAcceptable(Cluster& cluster) noexcept\n+{\n+    // Relinearize the Cluster if needed.\n+    if (cluster.m_quality == QualityLevel::NEEDS_RELINEARIZE) {\n+        cluster.Relinearize(*this, 10000);\n+    }\n+}\n+\n+Cluster::Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept\n+{\n+    // Create a new transaction in the DepGraph, and remember its position in m_mapping.\n+    auto cluster_idx = m_depgraph.AddTransaction(feerate);\n+    m_mapping.push_back(graph_index);\n+    m_linearization.push_back(cluster_idx);\n+}\n+\n+TxGraph::Ref TxGraphImpl::AddTransaction(const FeeFrac& feerate) noexcept\n+{\n+    // Construct a new Ref.\n+    Ref ret;\n+    // Construct a new Entry, and link it with the Ref.\n+    auto idx = m_entries.size();\n+    m_entries.emplace_back();\n+    auto& entry = m_entries.back();\n+    entry.m_ref = &ret;\n+    GetRefGraph(ret) = this;\n+    GetRefIndex(ret) = idx;\n+    // Construct a new singleton Cluster (which is necessarily optimally linearized).\n+    auto cluster = std::make_unique<Cluster>(*this, feerate, idx);\n+    auto cluster_ptr = cluster.get();\n+    InsertCluster(std::move(cluster), QualityLevel::OPTIMAL);\n+    cluster_ptr->Updated(*this);\n+    ++m_txcount;\n+    // Return the Ref.\n+    return ret;\n+}\n+\n+void TxGraphImpl::RemoveTransaction(Ref& arg) noexcept\n+{\n+    // Don't do anything if the Ref is empty (which may be indicative of the transaction already\n+    // having been removed).\n+    if (GetRefGraph(arg) == nullptr) return;\n+    Assume(GetRefGraph(arg) == this);\n+    // Find the Cluster the transaction is in, and stop if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return;\n+    // Remember that the transaction is to be removed.\n+    m_to_remove.push_back(GetRefIndex(arg));\n+}\n+\n+void TxGraphImpl::AddDependency(Ref& parent, Ref& child) noexcept\n+{\n+    // Don't do anything if either Ref is empty (which may be indicative of it having already been\n+    // removed).\n+    if (GetRefGraph(parent) == nullptr || GetRefGraph(child) == nullptr) return;\n+    Assume(GetRefGraph(parent) == this && GetRefGraph(child) == this);\n+    // Find the Cluster the parent and child transaction are in, and stop if either appears to be\n+    // already removed.\n+    auto par_cluster = m_entries[GetRefIndex(parent)].m_locator.cluster;\n+    if (par_cluster == nullptr) return;\n+    auto chl_cluster = m_entries[GetRefIndex(child)].m_locator.cluster;\n+    if (chl_cluster == nullptr) return;\n+    // Wipe m_group_data (as it will need to be recomputed).\n+    m_group_data.reset();\n+    m_group_clusters.clear();\n+    // Remember that this dependency is to be applied.\n+    m_deps_to_add.emplace_back(GetRefIndex(parent), GetRefIndex(child));\n+}\n+\n+bool TxGraphImpl::Exists(const Ref& arg) noexcept\n+{\n+    if (GetRefGraph(arg) == nullptr) return false;\n+    Assume(GetRefGraph(arg) == this);\n+    // Make sure the transaction isn't scheduled for removal.\n+    ApplyRemovals();\n+    return m_entries[GetRefIndex(arg)].m_locator.IsPresent();\n+}\n+\n+std::vector<TxGraph::Ref*> Cluster::GetAncestorRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept\n+{\n+    std::vector<TxGraph::Ref*> ret;\n+    // Translate all ancestors (in arbitrary order) to Refs (if they have any), and return them.\n+    for (auto idx : m_depgraph.Ancestors(idx)) {\n+        const auto& entry = graph.m_entries[m_mapping[idx]];\n+        ret.push_back(entry.m_ref);\n+    }\n+    return ret;\n+}\n+\n+std::vector<TxGraph::Ref*> Cluster::GetDescendantRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept\n+{\n+    std::vector<TxGraph::Ref*> ret;\n+    // Translate all descendants (in arbitrary order) to Refs (if they have any), and return them.\n+    for (auto idx : m_depgraph.Descendants(idx)) {\n+        const auto& entry = graph.m_entries[m_mapping[idx]];\n+        ret.push_back(entry.m_ref);\n+    }\n+    return ret;\n+}\n+\n+std::vector<TxGraph::Ref*> Cluster::GetClusterRefs(const TxGraphImpl& graph) noexcept\n+{\n+    std::vector<TxGraph::Ref*> ret;\n+    // Translate all transactions in the Cluster (in linearization order) to Refs.\n+    for (auto idx : m_linearization) {\n+        const auto& entry = graph.m_entries[m_mapping[idx]];\n+        ret.push_back(entry.m_ref);\n+    }\n+    return ret;\n+}\n+\n+FeeFrac Cluster::GetIndividualFeerate(ClusterIndex idx) noexcept\n+{\n+    return m_depgraph.FeeRate(idx);\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetAncestors(const Ref& arg) noexcept\n+{\n+    // Return the empty vector if the Ref is empty (which may be indicative of the transaction\n+    // having been removed already.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all dependencies, as the result might be incorrect otherwise.\n+    ApplyDependencies();\n+    // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Dispatch to the Cluster.\n+    return cluster->GetAncestorRefs(*this, m_entries[GetRefIndex(arg)].m_locator.index);\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetDescendants(const Ref& arg) noexcept\n+{\n+    // Return the empty vector if the Ref is empty (which may be indicative of the transaction\n+    // having been removed already.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all dependencies, as the result might be incorrect otherwise.\n+    ApplyDependencies();\n+    // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Dispatch to the Cluster.\n+    return cluster->GetDescendantRefs(*this, m_entries[GetRefIndex(arg)].m_locator.index);\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetCluster(const Ref& arg) noexcept\n+{\n+    // Return the empty vector if the Ref is empty (which may be indicative of the transaction\n+    // having been removed already.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all dependencies, as the result might be incorrect otherwise.\n+    ApplyDependencies();\n+    // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Make sure the Cluster has an acceptable quality level, and then dispatch to it.\n+    MakeAcceptable(*cluster);\n+    return cluster->GetClusterRefs(*this);\n+}\n+\n+TxGraph::GraphIndex TxGraphImpl::GetTransactionCount() noexcept\n+{\n+    ApplyRemovals();\n+    return m_txcount;\n+}\n+\n+FeeFrac TxGraphImpl::GetIndividualFeerate(const Ref& arg) noexcept\n+{\n+    // Return the empty FeeFrac if the passed Ref is empty (which may be indicative of the\n+    // transaction having been removed already.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply removals, so that we can correctly report FeeFrac{} for non-existing transaction.\n+    ApplyRemovals();\n+    // Find the cluster the argument is in, and return the empty FeeFrac if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Dispatch to the Cluster.\n+    return cluster->GetIndividualFeerate(m_entries[GetRefIndex(arg)].m_locator.index);\n+}\n+\n+FeeFrac TxGraphImpl::GetChunkFeerate(const Ref& arg) noexcept\n+{\n+    // Return the empty FeeFrac if the passed Ref is empty (which may be indicative of the\n+    // transaction having been removed already.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all dependencies, as the result might be inaccurate otherwise.\n+    ApplyDependencies();\n+    // Find the cluster the argument is in, and return the empty FeeFrac if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Make sure the Cluster has an acceptable quality level, and then return the transaction's\n+    // chunk feerate.\n+    MakeAcceptable(*cluster);\n+    const auto& entry = m_entries[GetRefIndex(arg)];\n+    return entry.m_chunk_feerate;\n+}\n+\n+void Cluster::SetFee(TxGraphImpl& graph, ClusterIndex idx, int64_t fee) noexcept\n+{\n+    // Make sure the specified ClusterIndex exists in this Cluster.\n+    Assume(m_depgraph.Positions()[idx]);\n+    // Bail out if the fee isn't actually being changed.\n+    if (m_depgraph.FeeRate(idx).fee == fee) return;\n+    // Update the fee, remember that relinearization will be necessary, and update the Entries\n+    // in the same Cluster.\n+    m_depgraph.FeeRate(idx).fee = fee;\n+    if (m_quality != QualityLevel::NEEDS_SPLIT) {\n+        graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+    }\n+    Updated(graph);\n+}\n+\n+void TxGraphImpl::SetTransactionFee(Ref& ref, int64_t fee) noexcept\n+{\n+    // Return the empty FeeFrac if the passed Ref is empty (which may be indicative of the\n+    // transaction having been removed already.\n+    if (GetRefGraph(ref) == nullptr) return;\n+    Assume(GetRefGraph(ref) == this);\n+    // Find the entry, its locator, and inform its Cluster about the new feerate, if any.\n+    auto& entry = m_entries[GetRefIndex(ref)];\n+    auto& locator = entry.m_locator;\n+    if (locator.IsPresent()) {\n+        locator.cluster->SetFee(*this, locator.index, fee);\n+    }\n+}\n+\n+} // namespace\n+\n+TxGraph::Ref::~Ref()\n+{\n+    if (m_graph) {\n+        // Inform the TxGraph about the Ref being destroyed.\n+        m_graph->UnlinkRef(m_index);\n+        m_graph = nullptr;\n+    }\n+}\n+\n+TxGraph::Ref& TxGraph::Ref::operator=(Ref&& other) noexcept\n+{\n+    // Inform both TxGraphs about the Refs being swapped.",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 1172,
      "commit_id": "3744b8318d8f465603f0e6f9eb72e679d763c4ca",
      "original_commit_id": "0c8dc2323eb1ec34357a807f0860cf0a08a63a75",
      "in_reply_to_id": null,
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Why is this doing an effective swap? I would expect this to call `UnlinkRef` on the moved-from value and reset its `m_graph` and `m_index`. Otherwise it wouldn't be unlinked until the moved-from variable goes out of scope, no?",
      "created_at": "2025-01-09T18:48:55Z",
      "updated_at": "2025-01-09T20:03:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r1909293407",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909293407"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1172,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909295799",
      "pull_request_review_id": 2540686525,
      "id": 1909295799,
      "node_id": "PRRC_kwDOABII585xzYq3",
      "diff_hunk": "@@ -0,0 +1,1193 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a ClusterIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<ClusterIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(ClusterIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeeFrac GetIndividualFeerate(ClusterIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, ClusterIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Cleanup).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupData\n+    {\n+        /** Where the clusters to be merged start in m_group_clusters. */\n+        uint32_t m_cluster_offset;\n+        /** How many clusters to merge. */\n+        uint32_t m_cluster_count;\n+        /** Where the dependencies for this cluster group in m_deps_to_add start. */\n+        uint32_t m_deps_offset;\n+        /** How many dependencies to add. */\n+        uint32_t m_deps_count;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Which clusters are to be merged. GroupData::m_cluster_offset indexes into this. */\n+    std::vector<Cluster*> m_group_clusters;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupData>> m_group_data = std::vector<GroupData>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        ClusterIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, ClusterIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref;",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 188,
      "commit_id": "3744b8318d8f465603f0e6f9eb72e679d763c4ca",
      "original_commit_id": "0c8dc2323eb1ec34357a807f0860cf0a08a63a75",
      "in_reply_to_id": null,
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "`m_ref{nullptr};`",
      "created_at": "2025-01-09T18:51:18Z",
      "updated_at": "2025-01-09T20:03:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r1909295799",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909295799"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 188,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909307659",
      "pull_request_review_id": 2540686525,
      "id": 1909307659,
      "node_id": "PRRC_kwDOABII585xzbkL",
      "diff_hunk": "@@ -0,0 +1,1193 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a ClusterIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<ClusterIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(ClusterIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeeFrac GetIndividualFeerate(ClusterIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, ClusterIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Cleanup).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupData\n+    {\n+        /** Where the clusters to be merged start in m_group_clusters. */\n+        uint32_t m_cluster_offset;\n+        /** How many clusters to merge. */\n+        uint32_t m_cluster_count;\n+        /** Where the dependencies for this cluster group in m_deps_to_add start. */\n+        uint32_t m_deps_offset;\n+        /** How many dependencies to add. */\n+        uint32_t m_deps_count;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Which clusters are to be merged. GroupData::m_cluster_offset indexes into this. */\n+    std::vector<Cluster*> m_group_clusters;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupData>> m_group_data = std::vector<GroupData>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        ClusterIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, ClusterIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref;\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeeFrac m_chunk_feerate;\n+\n+        /** Check whether this Entry is not present in any Cluster. */\n+        bool IsWiped() const noexcept\n+        {\n+            return !m_locator.IsPresent();\n+        }\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries that have no IsPresent locators left, and need to be cleaned up. */\n+    std::vector<GraphIndex> m_wiped;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeeFrac& feerate) noexcept final;\n+    void RemoveTransaction(Ref& arg) noexcept final;\n+    void AddDependency(Ref& parent, Ref& child) noexcept final;\n+    void SetTransactionFee(Ref&, int64_t fee) noexcept final;\n+    std::vector<Ref*> Cleanup() noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeeFrac GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeeFrac GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (ClusterIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        while (true) {",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 297,
      "commit_id": "3744b8318d8f465603f0e6f9eb72e679d763c4ca",
      "original_commit_id": "0c8dc2323eb1ec34357a807f0860cf0a08a63a75",
      "in_reply_to_id": null,
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Trying to convince myself this is guaranteed to terminate...\r\n\r\n`do{} while (!chunk.transactions.None())` rather than the `break` for readability? Or just `while()` if we need to guard against an empty linearization (presumably not?)",
      "created_at": "2025-01-09T19:02:47Z",
      "updated_at": "2025-01-09T20:03:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r1909307659",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909307659"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 297,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909321579",
      "pull_request_review_id": 2540686525,
      "id": 1909321579,
      "node_id": "PRRC_kwDOABII585xze9r",
      "diff_hunk": "@@ -0,0 +1,1193 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a ClusterIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<ClusterIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(ClusterIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeeFrac GetIndividualFeerate(ClusterIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, ClusterIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Cleanup).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupData\n+    {\n+        /** Where the clusters to be merged start in m_group_clusters. */\n+        uint32_t m_cluster_offset;\n+        /** How many clusters to merge. */\n+        uint32_t m_cluster_count;\n+        /** Where the dependencies for this cluster group in m_deps_to_add start. */\n+        uint32_t m_deps_offset;\n+        /** How many dependencies to add. */\n+        uint32_t m_deps_count;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Which clusters are to be merged. GroupData::m_cluster_offset indexes into this. */\n+    std::vector<Cluster*> m_group_clusters;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupData>> m_group_data = std::vector<GroupData>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        ClusterIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, ClusterIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref;\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeeFrac m_chunk_feerate;\n+\n+        /** Check whether this Entry is not present in any Cluster. */\n+        bool IsWiped() const noexcept\n+        {\n+            return !m_locator.IsPresent();\n+        }\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries that have no IsPresent locators left, and need to be cleaned up. */\n+    std::vector<GraphIndex> m_wiped;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeeFrac& feerate) noexcept final;\n+    void RemoveTransaction(Ref& arg) noexcept final;\n+    void AddDependency(Ref& parent, Ref& child) noexcept final;\n+    void SetTransactionFee(Ref&, int64_t fee) noexcept final;\n+    std::vector<Ref*> Cleanup() noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeeFrac GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeeFrac GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (ClusterIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        while (true) {\n+            ClusterIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = chunk.feerate;\n+            chunk.transactions.Reset(idx);\n+            if (chunk.transactions.None()) break;\n+        }\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    SetType todo;",
      "path": "src/txgraph.cpp",
      "position": 803,
      "original_position": 311,
      "commit_id": "3744b8318d8f465603f0e6f9eb72e679d763c4ca",
      "original_commit_id": "0c8dc2323eb1ec34357a807f0860cf0a08a63a75",
      "in_reply_to_id": null,
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Assume `!to_remove.empty()` or early return if it's allowed?",
      "created_at": "2025-01-09T19:17:27Z",
      "updated_at": "2025-01-09T20:03:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r1909321579",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909321579"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 803,
      "original_line": 803,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909348870",
      "pull_request_review_id": 2540686525,
      "id": 1909348870,
      "node_id": "PRRC_kwDOABII585xzloG",
      "diff_hunk": "@@ -0,0 +1,1193 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a ClusterIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<ClusterIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(ClusterIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeeFrac GetIndividualFeerate(ClusterIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, ClusterIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Cleanup).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupData\n+    {\n+        /** Where the clusters to be merged start in m_group_clusters. */\n+        uint32_t m_cluster_offset;\n+        /** How many clusters to merge. */\n+        uint32_t m_cluster_count;\n+        /** Where the dependencies for this cluster group in m_deps_to_add start. */\n+        uint32_t m_deps_offset;\n+        /** How many dependencies to add. */\n+        uint32_t m_deps_count;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Which clusters are to be merged. GroupData::m_cluster_offset indexes into this. */\n+    std::vector<Cluster*> m_group_clusters;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupData>> m_group_data = std::vector<GroupData>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        ClusterIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, ClusterIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref;\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeeFrac m_chunk_feerate;\n+\n+        /** Check whether this Entry is not present in any Cluster. */\n+        bool IsWiped() const noexcept\n+        {\n+            return !m_locator.IsPresent();\n+        }\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries that have no IsPresent locators left, and need to be cleaned up. */\n+    std::vector<GraphIndex> m_wiped;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeeFrac& feerate) noexcept final;\n+    void RemoveTransaction(Ref& arg) noexcept final;\n+    void AddDependency(Ref& parent, Ref& child) noexcept final;\n+    void SetTransactionFee(Ref&, int64_t fee) noexcept final;\n+    std::vector<Ref*> Cleanup() noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeeFrac GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeeFrac GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (ClusterIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        while (true) {\n+            ClusterIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = chunk.feerate;\n+            chunk.transactions.Reset(idx);\n+            if (chunk.transactions.None()) break;\n+        }\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        if (entry.IsWiped()) graph.m_wiped.push_back(idx);\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, ClusterIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transaction go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), ClusterIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // ClusterIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<ClusterIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator.SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Sort the list of dependencies to apply by child, so those can be applied in batch.\n+    std::sort(to_apply.begin(), to_apply.end(), [](auto& a, auto& b) { return a.second < b.second; });\n+    // Iterate over groups of to-be-added dependencies with the same child.\n+    auto it = to_apply.begin();\n+    while (it != to_apply.end()) {\n+        auto& first_child = graph.m_entries[it->second].m_locator;\n+        ClusterIndex child_idx = first_child.index;\n+        // Iterate over all to-be-added dependencies within that same child, gather the relevant\n+        // parents.\n+        SetType parents;\n+        while (it != to_apply.end()) {\n+            auto& child = graph.m_entries[it->second].m_locator;\n+            auto& parent = graph.m_entries[it->first].m_locator;\n+            Assume(child.cluster == this && parent.cluster == this);\n+            if (child.index != child_idx) break;\n+            parents.Set(parent.index);\n+            ++it;\n+        }\n+        // Push all dependencies to the underlying DepGraph. Note that this is O(N) in the size of\n+        // the cluster, regardless of the number of parents being added, so batching them together\n+        // has a performance benefit.\n+        m_depgraph.AddDependencies(parents, child_idx);\n+    }\n+\n+    // Finally fix the linearization, as the new dependencies may have invalidated the\n+    // linearization, and post-linearize it to fix up the worst problems with it.\n+    FixLinearization(m_depgraph, m_linearization);\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Finally push the changes to graph.m_entries.\n+    Updated(graph);\n+}\n+\n+std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept\n+{\n+    Assume(quality != QualityLevel::NONE);\n+\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    Assume(setindex < quality_clusters.size());\n+\n+    // Extract the Cluster-owning unique_ptr.\n+    std::unique_ptr<Cluster> ret = std::move(quality_clusters[setindex]);\n+    ret->m_quality = QualityLevel::NONE;\n+    ret->m_setindex = ClusterSetIndex(-1);\n+\n+    // Clean up space in quality_cluster.\n+    auto max_setindex = quality_clusters.size() - 1;\n+    if (setindex != max_setindex) {\n+        // If the cluster was not the last element of quality_clusters, move that to take its place.\n+        quality_clusters.back()->m_quality = quality;\n+        quality_clusters.back()->m_setindex = setindex;\n+        quality_clusters[setindex] = std::move(quality_clusters.back());\n+    }\n+    // The last element of quality_clusters is now unused; drop it.\n+    quality_clusters.pop_back();\n+\n+    return ret;\n+}\n+\n+ClusterSetIndex TxGraphImpl::InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+{\n+    // Cannot insert with quality level NONE (as that would mean not inserted).\n+    Assume(quality != QualityLevel::NONE);\n+    // The passed-in Cluster must not currently be in the TxGraphImpl.\n+    Assume(cluster->m_quality == QualityLevel::NONE);\n+\n+    // Append it at the end of the relevant TxGraphImpl::m_cluster.\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    ClusterSetIndex ret = quality_clusters.size();\n+    cluster->m_quality = quality;\n+    cluster->m_setindex = ret;\n+    quality_clusters.push_back(std::move(cluster));\n+    return ret;\n+}\n+\n+void TxGraphImpl::SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+{\n+    Assume(new_quality != QualityLevel::NONE);\n+\n+    // Don't do anything if the quality did not change.\n+    if (old_quality == new_quality) return;\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(old_quality, old_index);\n+    // And re-insert it where it belongs.\n+    InsertCluster(std::move(cluster_ptr), new_quality);\n+}\n+\n+void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n+{\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(cluster.m_quality, cluster.m_setindex);\n+    // And throw it away.\n+    cluster_ptr.reset();\n+}\n+\n+void TxGraphImpl::ApplyRemovals() noexcept\n+{\n+    auto& to_remove = m_to_remove;\n+    // Skip if there is nothing to remove.\n+    if (to_remove.empty()) return;\n+    // Wipe cached m_group_data, as it may be invalidated by removals.\n+    m_group_data = std::nullopt;\n+    m_group_clusters.clear();\n+    // Group the set of to-be-removed entries by Cluster*.\n+    std::sort(m_to_remove.begin(), m_to_remove.end(), [&](GraphIndex a, GraphIndex b) noexcept {\n+        return std::less{}(m_entries[a].m_locator.cluster, m_entries[b].m_locator.cluster);\n+    });\n+    // Process per Cluster.\n+    std::span to_remove_span{m_to_remove};\n+    while (!to_remove_span.empty()) {\n+        Cluster* cluster = m_entries[to_remove_span.front()].m_locator.cluster;\n+        if (cluster != nullptr) {\n+            // If the first to_remove_span entry's Cluster exists, hand to_remove_span to it, so it\n+            // can pop off whatever applies to it.\n+            cluster->ApplyRemovals(*this, to_remove_span);\n+        } else {\n+            // Otherwise, skip this already-removed entry.\n+            to_remove_span = to_remove_span.subspan(1);\n+        }\n+    }\n+    m_to_remove.clear();\n+}\n+\n+void TxGraphImpl::SwapIndexes(GraphIndex a, GraphIndex b) noexcept\n+{\n+    Assume(a < m_entries.size());\n+    Assume(b < m_entries.size());\n+    // Swap the Entry objects.\n+    std::swap(m_entries[a], m_entries[b]);\n+    // Iterate over both objects.\n+    for (int i = 0; i < 2; ++i) {\n+        GraphIndex idx = i ? b : a;\n+        Entry& entry = m_entries[idx];\n+        // Update linked Ref.\n+        if (entry.m_ref) GetRefIndex(*entry.m_ref) = idx;\n+        // Update the locator. The rest of the Entry information will not change, so no need to\n+        // invoke Cluster::Updated().\n+        Locator& locator = entry.m_locator;\n+        if (locator.IsPresent()) {\n+            locator.cluster->UpdateMapping(locator.index, idx);\n+        }\n+    }\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::Cleanup() noexcept\n+{\n+    ApplyDependencies();\n+    std::vector<Ref*> ret;\n+    // Sort the GraphIndex that need to be cleaned up. This groups them (so duplicates can be\n+    // processed just once). They are sorted in reverse, so the last ones get processed first.\n+    // This means earlier-processed GraphIndexes will not move of later-processed ones (which\n+    // might invalidate them).\n+    std::sort(m_wiped.begin(), m_wiped.end(), std::greater{});\n+    GraphIndex last(-1);\n+    for (GraphIndex idx : m_wiped) {\n+        // m_wiped should never contain the same GraphIndex twice (the code below would fail\n+        // if so, because GraphIndexes get invalidated by removing them).\n+        Assume(idx != last);\n+        last = idx;\n+        Entry& entry = m_entries[idx];\n+        // Gather Ref pointers that are being unlinked.\n+        if (entry.m_ref != nullptr) {\n+            ret.push_back(entry.m_ref);\n+            GetRefGraph(*entry.m_ref) = nullptr;\n+            m_entries[idx].m_ref = nullptr;\n+        }\n+        // Verify removed entries don't have anything that could hold a reference back.\n+        Assume(!entry.m_locator.IsPresent());\n+        if (idx != m_entries.size() - 1) SwapIndexes(idx, m_entries.size() - 1);\n+        m_entries.pop_back();\n+    }\n+    m_wiped.clear();\n+    return ret;\n+}\n+\n+void TxGraphImpl::Split(Cluster& cluster) noexcept\n+{\n+    // To split a Cluster, first make sure all removals are applied (as we might need to split\n+    // again afterwards otherwise).\n+    ApplyRemovals();\n+    bool del = cluster.Split(*this);\n+    if (del) {\n+        // Cluster::Split reports whether the Cluster is to be deleted.\n+        DeleteCluster(cluster);\n+    }\n+}\n+\n+void TxGraphImpl::SplitAll() noexcept\n+{\n+    // Before splitting all Cluster, first make sure all removals are applied.\n+    ApplyRemovals();\n+    auto& queue = m_clusters[int(QualityLevel::NEEDS_SPLIT)];\n+    while (!queue.empty()) {\n+        Split(*queue.back().get());\n+    }\n+}\n+\n+void TxGraphImpl::GroupClusters() noexcept\n+{\n+    // Before computing which Clusters need to be merged together, first apply all removals and\n+    // split the Clusters into connected components. If we would group first, we might end up\n+    // with inefficient Clusters which just end up being split again anyway.\n+    SplitAll();\n+\n+    // If the groupings have been computed already, nothing is left to be done.\n+    if (m_group_data.has_value()) return;\n+\n+    /** Annotated clusters: an entry for each Cluster, together with the representative for the\n+     *  partition it is in if known, or with nullptr if not yet known. */\n+    std::vector<std::pair<Cluster*, Cluster*>> an_clusters;\n+    /** Annotated dependencies: an entry for each m_deps_to_apply entry (excluding ones that apply\n+     *  to removed transactions), together with the representative root of the partition of\n+     *  Clusters it applies to. */\n+    std::vector<std::pair<std::pair<GraphIndex, GraphIndex>, Cluster*>> an_deps;\n+\n+    // Construct a an_clusters entry for every parent and child in the to-be-applied dependencies.\n+    for (const auto& [par, chl] : m_deps_to_add) {\n+        auto par_cluster = m_entries[par].m_locator.cluster;\n+        auto chl_cluster = m_entries[chl].m_locator.cluster;\n+        // Skip dependencies for which the parent or child transaction is removed.\n+        if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+        an_clusters.emplace_back(par_cluster, nullptr);\n+        // Do not include a duplicate when parent and child are identical, as it'll be removed\n+        // below anyway.\n+        if (chl_cluster != par_cluster) an_clusters.emplace_back(chl_cluster, nullptr);\n+    }\n+    // Sort and deduplicate an_clusters, so we end up with a sorted list of all involved Clusters\n+    // to which dependencies apply.\n+    std::sort(an_clusters.begin(), an_clusters.end());\n+    an_clusters.erase(std::unique(an_clusters.begin(), an_clusters.end()), an_clusters.end());\n+\n+    // Sort the dependencies by child Cluster.\n+    std::sort(m_deps_to_add.begin(), m_deps_to_add.end(), [&](auto& a, auto& b) noexcept {\n+        auto [_a_par, a_chl] = a;\n+        auto [_b_par, b_chl] = b;\n+        auto a_chl_cluster = m_entries[a_chl].m_locator.cluster;\n+        auto b_chl_cluster = m_entries[b_chl].m_locator.cluster;\n+        return std::less{}(a_chl_cluster, b_chl_cluster);\n+    });\n+\n+    // Run the union-find algorithm to to find partitions of the input Clusters which need to be\n+    // grouped together. See https://en.wikipedia.org/wiki/Disjoint-set_data_structure.\n+    {\n+        /** Each PartitionData entry contains information about a single input Cluster. */\n+        struct PartitionData\n+        {\n+            /** The cluster this holds information for. */\n+            Cluster* cluster;\n+            /** All PartitionData entries belonging to the same partition are organized in a tree.\n+             *  Each element points to its parent, or to itself if it is the root. The root is then\n+             *  a representative for the entire tree, and can be found by walking upwards from any\n+             *  element. */\n+            PartitionData* parent;\n+            /** (only if this is a root, so when parent == this) An upper bound on the height of\n+             *  tree for this partition. */\n+            unsigned rank;\n+        };\n+        /** Information about each input Cluster. Sorted by Cluster* pointer. */\n+        std::vector<PartitionData> partition_data;\n+\n+        /** Given a Cluster, find its corresponding PartitionData. */\n+        auto locate_uf = [&](Cluster* arg) noexcept -> PartitionData* {\n+            auto it = std::lower_bound(partition_data.begin(), partition_data.end(), arg,\n+                                       [](auto& a, Cluster* ptr) noexcept { return a.cluster < ptr; });\n+            Assume(it != partition_data.end());\n+            Assume(it->cluster == arg);\n+            return &*it;\n+        };\n+\n+        /** Given a PartitionData, find the root of the tree it is in (its representative). */\n+        static constexpr auto find_uf = [](PartitionData* data) noexcept -> PartitionData* {\n+            while (data->parent != data) {\n+                // Replace pointers to parents with pointers to grandparents.\n+                // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Finding_set_representatives.\n+                auto par = data->parent;\n+                data->parent = par->parent;\n+                data = par;\n+            }\n+            return data;\n+        };\n+\n+        /** Given two PartitionDatas, union the partitions they are in, and return their\n+         *  representative. */\n+        static constexpr auto union_uf = [](PartitionData* arg1, PartitionData* arg2) noexcept {\n+            // Find the roots of the trees, and bail out if they are already equal (which would\n+            // mean they are in the same partition already).\n+            auto rep1 = find_uf(arg1);\n+            auto rep2 = find_uf(arg2);\n+            if (rep1 == rep2) return rep1;\n+            // Pick the lower-rank root to become a child of the higher-rank one.\n+            // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Union_by_rank.\n+            if (rep1->rank < rep2->rank) std::swap(rep1, rep2);\n+            rep2->parent = rep1;\n+            rep1->rank += (rep1->rank == rep2->rank);\n+            return rep1;\n+        };\n+\n+        // Start by initializing every Cluster as its own singleton partition.\n+        partition_data.resize(an_clusters.size());\n+        for (size_t i = 0; i < an_clusters.size(); ++i) {\n+            partition_data[i].cluster = an_clusters[i].first;\n+            partition_data[i].parent = &partition_data[i];\n+            partition_data[i].rank = 0;\n+        }\n+\n+        // Run through all parent/child pairs in m_deps_to_add, and union the\n+        // the partitions their Clusters are in.\n+        Cluster* last_chl_cluster{nullptr};\n+        PartitionData* last_partition{nullptr};\n+        for (const auto& [par, chl] : m_deps_to_add) {\n+            auto par_cluster = m_entries[par].m_locator.cluster;\n+            auto chl_cluster = m_entries[chl].m_locator.cluster;\n+            // Nothing to do if parent and child are in the same Cluster.\n+            if (par_cluster == chl_cluster) continue;\n+            // Nothing to do if either parent or child transaction is removed already.\n+            if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+            Assume(par != chl);\n+            if (chl_cluster == last_chl_cluster) {\n+                // If the child Clusters is the same as the previous iteration, union with the\n+                // tree they were in, avoiding the need for another lookup. Note that m_deps_to_add\n+                // is sorted by child Cluster, so batches with the same child are expected.\n+                last_partition = union_uf(locate_uf(par_cluster), last_partition);\n+            } else {\n+                last_chl_cluster = chl_cluster;\n+                last_partition = union_uf(locate_uf(par_cluster), locate_uf(chl_cluster));\n+            }\n+        }\n+\n+        // Populate the an_clusters and an_deps data structures with the list of input Clusters,\n+        // and the input dependencies, annotated with the representative of the Cluster partition\n+        // it applies to.\n+        an_deps.reserve(m_deps_to_add.size());\n+        auto deps_it = m_deps_to_add.begin();\n+        for (size_t i = 0; i < partition_data.size(); ++i) {\n+            auto& data = partition_data[i];\n+            // Find the representative of the partition Cluster i is in, and store it with the\n+            // Cluster.\n+            auto rep = find_uf(&data)->cluster;\n+            an_clusters[i].second = rep;\n+            // Find all dependencies whose child Cluster is Cluster i, and annotate them with rep.\n+            while (deps_it != m_deps_to_add.end()) {\n+                auto [par, chl] = *deps_it;\n+                auto chl_cluster = m_entries[chl].m_locator.cluster;\n+                // Skip dependencies that apply to earlier Clusters (those necessary are for\n+                // deleted transactions, as otherwise we'd have processed them already).\n+                if (!std::less{}(chl_cluster, data.cluster)) {\n+                    if (chl_cluster != data.cluster) break;\n+                    auto par_cluster = m_entries[par].m_locator.cluster;\n+                    // Also filter out dependencies applying to a removed parent.\n+                    if (par_cluster != nullptr) an_deps.emplace_back(*deps_it, rep);\n+                }\n+                ++deps_it;\n+            }\n+        }\n+    }\n+\n+    // Sort both an_clusters and an_deps by representative of the partition they are in, grouping\n+    // all those applying to the same partition together.\n+    std::sort(an_deps.begin(), an_deps.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+    std::sort(an_clusters.begin(), an_clusters.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+\n+    // Translate the resulting cluster groups to the m_group_data structure.\n+    m_group_data = std::vector<GroupData>{};\n+    m_group_clusters.clear();\n+    m_group_clusters.reserve(an_clusters.size());\n+    m_deps_to_add.clear();\n+    m_deps_to_add.reserve(an_deps.size());\n+    auto an_deps_it = an_deps.begin();\n+    auto an_clusters_it = an_clusters.begin();\n+    while (an_deps_it != an_deps.end()) {\n+        auto rep = an_deps_it->second;\n+        // Create and initialize a new GroupData entry for the partition.\n+        auto& new_entry = m_group_data->emplace_back();\n+        new_entry.m_cluster_offset = m_group_clusters.size();\n+        new_entry.m_cluster_count = 0;\n+        new_entry.m_deps_offset = m_deps_to_add.size();\n+        new_entry.m_deps_count = 0;\n+        // Add all its clusters to it (copying those from an_clusters to m_group_clusters).\n+        while (an_clusters_it != an_clusters.end() && an_clusters_it->second == rep) {\n+            m_group_clusters.push_back(an_clusters_it->first);\n+            ++an_clusters_it;\n+            ++new_entry.m_cluster_count;\n+        }\n+        // Add all its dependencies to it (copying those back from an_deps to m_deps_to_add).\n+        while (an_deps_it != an_deps.end() && an_deps_it->second == rep) {\n+            m_deps_to_add.push_back(an_deps_it->first);\n+            ++an_deps_it;\n+            ++new_entry.m_deps_count;\n+        }\n+    }\n+    Assume(an_deps_it == an_deps.end());\n+    Assume(an_clusters_it == an_clusters.end());\n+}\n+\n+void TxGraphImpl::Merge(std::span<Cluster*> to_merge) noexcept\n+{\n+    Assume(!to_merge.empty());\n+    // Nothing to do if a group consists of just a single Cluster.\n+    if (to_merge.size() == 1) return;\n+\n+    // Move the largest Cluster to the front of to_merge. As all transactions in other to-be-merged\n+    // Clusters will be moved to that one, putting the largest one first minimizes the number of\n+    // moves.\n+    size_t max_size_pos{0};\n+    ClusterIndex max_size = to_merge[max_size_pos]->GetTxCount();\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        ClusterIndex size = to_merge[i]->GetTxCount();\n+        if (size > max_size) {\n+            max_size_pos = i;\n+            max_size = size;\n+        }\n+    }\n+    if (max_size_pos != 0) std::swap(to_merge[0], to_merge[max_size_pos]);\n+\n+    // Merge all further Clusters in the group into the first one, and delete them.\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        to_merge[0]->Merge(*this, *to_merge[i]);\n+        DeleteCluster(*to_merge[i]);\n+    }\n+}\n+\n+void TxGraphImpl::ApplyDependencies() noexcept\n+{\n+    // Compute the groups of to-be-merged Clusters (which also applies all removals, and splits).\n+    GroupClusters();\n+    Assume(m_group_data.has_value());\n+    // Nothing to do if there are no dependencies to be added.\n+    if (m_deps_to_add.empty()) return;\n+\n+    // For each group of to-be-merged Clusters.\n+    Assume(m_group_data.has_value());\n+    for (const auto& group_data : *m_group_data) {\n+        // Invoke Merge() to merge them into a single Cluster.\n+        auto cluster_span = std::span{m_group_clusters}\n+                                .subspan(group_data.m_cluster_offset, group_data.m_cluster_count);\n+        Merge(cluster_span);\n+        // Actually apply all to-be-added dependencies (for each, parent and child belong to the\n+        // same Cluster because of the merging above).\n+        auto deps_span = std::span{m_deps_to_add}\n+                             .subspan(group_data.m_deps_offset, group_data.m_deps_count);\n+        Assume(!deps_span.empty());\n+        const auto& loc = m_entries[deps_span[0].second].m_locator;\n+        Assume(loc.IsPresent());\n+        loc.cluster->ApplyDependencies(*this, deps_span);\n+    }\n+\n+    // Wipe the list of to-be-added dependencies now that they are applied.\n+    m_deps_to_add.clear();\n+    // Also no further Cluster mergings are needed (note that we clear, but don't set to\n+    // std::nullopt, as that would imply the groupings are unknown).\n+    m_group_data->clear();\n+    m_group_clusters.clear();\n+}\n+\n+void Cluster::Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept\n+{\n+    // We can only relinearize Clusters that do not need splitting.\n+    Assume(m_quality == QualityLevel::OPTIMAL || m_quality == QualityLevel::ACCEPTABLE ||\n+           m_quality == QualityLevel::NEEDS_RELINEARIZE);\n+    // No work is required for Clusters which are already optimally linearized.\n+    if (m_quality == QualityLevel::OPTIMAL) return;\n+    // Invoke the actual linearization algorithm (passing in the existing one).\n+    uint64_t rng_seed = graph.m_rng.rand64();\n+    auto [linearization, optimal] = Linearize(m_depgraph, max_iters, rng_seed, m_linearization);\n+    // Postlinearize if the result isn't optimal already. This guarantees (among other things)\n+    // that the chunks of the resulting linearization are all connected.\n+    if (!optimal) PostLinearize(m_depgraph, linearization);\n+    // Update the linearization.\n+    m_linearization = std::move(linearization);\n+    // Update the Cluster's quality.\n+    auto new_quality = optimal ? QualityLevel::OPTIMAL : QualityLevel::ACCEPTABLE;\n+    graph.SetClusterQuality(m_quality, m_setindex, new_quality);\n+    // Update the Entry objects.\n+    Updated(graph);\n+}\n+\n+void TxGraphImpl::MakeAcceptable(Cluster& cluster) noexcept\n+{\n+    // Relinearize the Cluster if needed.\n+    if (cluster.m_quality == QualityLevel::NEEDS_RELINEARIZE) {\n+        cluster.Relinearize(*this, 10000);\n+    }\n+}\n+\n+Cluster::Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept\n+{\n+    // Create a new transaction in the DepGraph, and remember its position in m_mapping.\n+    auto cluster_idx = m_depgraph.AddTransaction(feerate);\n+    m_mapping.push_back(graph_index);\n+    m_linearization.push_back(cluster_idx);\n+}\n+\n+TxGraph::Ref TxGraphImpl::AddTransaction(const FeeFrac& feerate) noexcept\n+{\n+    // Construct a new Ref.\n+    Ref ret;\n+    // Construct a new Entry, and link it with the Ref.\n+    auto idx = m_entries.size();\n+    m_entries.emplace_back();\n+    auto& entry = m_entries.back();\n+    entry.m_ref = &ret;\n+    GetRefGraph(ret) = this;\n+    GetRefIndex(ret) = idx;\n+    // Construct a new singleton Cluster (which is necessarily optimally linearized).\n+    auto cluster = std::make_unique<Cluster>(*this, feerate, idx);\n+    auto cluster_ptr = cluster.get();\n+    InsertCluster(std::move(cluster), QualityLevel::OPTIMAL);\n+    cluster_ptr->Updated(*this);\n+    ++m_txcount;\n+    // Return the Ref.\n+    return ret;\n+}\n+\n+void TxGraphImpl::RemoveTransaction(Ref& arg) noexcept\n+{\n+    // Don't do anything if the Ref is empty (which may be indicative of the transaction already\n+    // having been removed).\n+    if (GetRefGraph(arg) == nullptr) return;\n+    Assume(GetRefGraph(arg) == this);\n+    // Find the Cluster the transaction is in, and stop if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return;\n+    // Remember that the transaction is to be removed.\n+    m_to_remove.push_back(GetRefIndex(arg));\n+}\n+\n+void TxGraphImpl::AddDependency(Ref& parent, Ref& child) noexcept\n+{\n+    // Don't do anything if either Ref is empty (which may be indicative of it having already been\n+    // removed).\n+    if (GetRefGraph(parent) == nullptr || GetRefGraph(child) == nullptr) return;\n+    Assume(GetRefGraph(parent) == this && GetRefGraph(child) == this);\n+    // Find the Cluster the parent and child transaction are in, and stop if either appears to be\n+    // already removed.\n+    auto par_cluster = m_entries[GetRefIndex(parent)].m_locator.cluster;\n+    if (par_cluster == nullptr) return;\n+    auto chl_cluster = m_entries[GetRefIndex(child)].m_locator.cluster;\n+    if (chl_cluster == nullptr) return;\n+    // Wipe m_group_data (as it will need to be recomputed).\n+    m_group_data.reset();\n+    m_group_clusters.clear();\n+    // Remember that this dependency is to be applied.\n+    m_deps_to_add.emplace_back(GetRefIndex(parent), GetRefIndex(child));\n+}\n+\n+bool TxGraphImpl::Exists(const Ref& arg) noexcept\n+{\n+    if (GetRefGraph(arg) == nullptr) return false;\n+    Assume(GetRefGraph(arg) == this);\n+    // Make sure the transaction isn't scheduled for removal.\n+    ApplyRemovals();\n+    return m_entries[GetRefIndex(arg)].m_locator.IsPresent();\n+}\n+\n+std::vector<TxGraph::Ref*> Cluster::GetAncestorRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 1007,
      "commit_id": "3744b8318d8f465603f0e6f9eb72e679d763c4ca",
      "original_commit_id": "0c8dc2323eb1ec34357a807f0860cf0a08a63a75",
      "in_reply_to_id": null,
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Looks like these 3 functions could `reserve()` for their `ret` vectors.",
      "created_at": "2025-01-09T19:42:45Z",
      "updated_at": "2025-01-09T20:03:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r1909348870",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909348870"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1662,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909385059",
      "pull_request_review_id": 2540851568,
      "id": 1909385059,
      "node_id": "PRRC_kwDOABII585xzudj",
      "diff_hunk": "@@ -0,0 +1,1193 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a ClusterIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<ClusterIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(ClusterIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeeFrac GetIndividualFeerate(ClusterIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, ClusterIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Cleanup).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupData\n+    {\n+        /** Where the clusters to be merged start in m_group_clusters. */\n+        uint32_t m_cluster_offset;\n+        /** How many clusters to merge. */\n+        uint32_t m_cluster_count;\n+        /** Where the dependencies for this cluster group in m_deps_to_add start. */\n+        uint32_t m_deps_offset;\n+        /** How many dependencies to add. */\n+        uint32_t m_deps_count;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Which clusters are to be merged. GroupData::m_cluster_offset indexes into this. */\n+    std::vector<Cluster*> m_group_clusters;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupData>> m_group_data = std::vector<GroupData>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        ClusterIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, ClusterIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref;\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeeFrac m_chunk_feerate;\n+\n+        /** Check whether this Entry is not present in any Cluster. */\n+        bool IsWiped() const noexcept\n+        {\n+            return !m_locator.IsPresent();\n+        }\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries that have no IsPresent locators left, and need to be cleaned up. */\n+    std::vector<GraphIndex> m_wiped;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeeFrac& feerate) noexcept final;\n+    void RemoveTransaction(Ref& arg) noexcept final;\n+    void AddDependency(Ref& parent, Ref& child) noexcept final;\n+    void SetTransactionFee(Ref&, int64_t fee) noexcept final;\n+    std::vector<Ref*> Cleanup() noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeeFrac GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeeFrac GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (ClusterIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        while (true) {\n+            ClusterIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = chunk.feerate;\n+            chunk.transactions.Reset(idx);\n+            if (chunk.transactions.None()) break;\n+        }\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        if (entry.IsWiped()) graph.m_wiped.push_back(idx);\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, ClusterIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transaction go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), ClusterIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // ClusterIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<ClusterIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator.SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Sort the list of dependencies to apply by child, so those can be applied in batch.\n+    std::sort(to_apply.begin(), to_apply.end(), [](auto& a, auto& b) { return a.second < b.second; });\n+    // Iterate over groups of to-be-added dependencies with the same child.\n+    auto it = to_apply.begin();\n+    while (it != to_apply.end()) {\n+        auto& first_child = graph.m_entries[it->second].m_locator;\n+        ClusterIndex child_idx = first_child.index;\n+        // Iterate over all to-be-added dependencies within that same child, gather the relevant\n+        // parents.\n+        SetType parents;\n+        while (it != to_apply.end()) {\n+            auto& child = graph.m_entries[it->second].m_locator;\n+            auto& parent = graph.m_entries[it->first].m_locator;\n+            Assume(child.cluster == this && parent.cluster == this);\n+            if (child.index != child_idx) break;\n+            parents.Set(parent.index);\n+            ++it;\n+        }\n+        // Push all dependencies to the underlying DepGraph. Note that this is O(N) in the size of\n+        // the cluster, regardless of the number of parents being added, so batching them together\n+        // has a performance benefit.\n+        m_depgraph.AddDependencies(parents, child_idx);\n+    }\n+\n+    // Finally fix the linearization, as the new dependencies may have invalidated the\n+    // linearization, and post-linearize it to fix up the worst problems with it.\n+    FixLinearization(m_depgraph, m_linearization);\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Finally push the changes to graph.m_entries.\n+    Updated(graph);\n+}\n+\n+std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept\n+{\n+    Assume(quality != QualityLevel::NONE);\n+\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    Assume(setindex < quality_clusters.size());\n+\n+    // Extract the Cluster-owning unique_ptr.\n+    std::unique_ptr<Cluster> ret = std::move(quality_clusters[setindex]);\n+    ret->m_quality = QualityLevel::NONE;\n+    ret->m_setindex = ClusterSetIndex(-1);\n+\n+    // Clean up space in quality_cluster.\n+    auto max_setindex = quality_clusters.size() - 1;\n+    if (setindex != max_setindex) {\n+        // If the cluster was not the last element of quality_clusters, move that to take its place.\n+        quality_clusters.back()->m_quality = quality;\n+        quality_clusters.back()->m_setindex = setindex;\n+        quality_clusters[setindex] = std::move(quality_clusters.back());\n+    }\n+    // The last element of quality_clusters is now unused; drop it.\n+    quality_clusters.pop_back();\n+\n+    return ret;\n+}\n+\n+ClusterSetIndex TxGraphImpl::InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+{\n+    // Cannot insert with quality level NONE (as that would mean not inserted).\n+    Assume(quality != QualityLevel::NONE);\n+    // The passed-in Cluster must not currently be in the TxGraphImpl.\n+    Assume(cluster->m_quality == QualityLevel::NONE);\n+\n+    // Append it at the end of the relevant TxGraphImpl::m_cluster.\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    ClusterSetIndex ret = quality_clusters.size();\n+    cluster->m_quality = quality;\n+    cluster->m_setindex = ret;\n+    quality_clusters.push_back(std::move(cluster));\n+    return ret;\n+}\n+\n+void TxGraphImpl::SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+{\n+    Assume(new_quality != QualityLevel::NONE);\n+\n+    // Don't do anything if the quality did not change.\n+    if (old_quality == new_quality) return;\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(old_quality, old_index);\n+    // And re-insert it where it belongs.\n+    InsertCluster(std::move(cluster_ptr), new_quality);\n+}\n+\n+void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n+{\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(cluster.m_quality, cluster.m_setindex);\n+    // And throw it away.\n+    cluster_ptr.reset();\n+}\n+\n+void TxGraphImpl::ApplyRemovals() noexcept\n+{\n+    auto& to_remove = m_to_remove;\n+    // Skip if there is nothing to remove.\n+    if (to_remove.empty()) return;\n+    // Wipe cached m_group_data, as it may be invalidated by removals.\n+    m_group_data = std::nullopt;\n+    m_group_clusters.clear();\n+    // Group the set of to-be-removed entries by Cluster*.\n+    std::sort(m_to_remove.begin(), m_to_remove.end(), [&](GraphIndex a, GraphIndex b) noexcept {\n+        return std::less{}(m_entries[a].m_locator.cluster, m_entries[b].m_locator.cluster);\n+    });\n+    // Process per Cluster.\n+    std::span to_remove_span{m_to_remove};\n+    while (!to_remove_span.empty()) {\n+        Cluster* cluster = m_entries[to_remove_span.front()].m_locator.cluster;\n+        if (cluster != nullptr) {\n+            // If the first to_remove_span entry's Cluster exists, hand to_remove_span to it, so it\n+            // can pop off whatever applies to it.\n+            cluster->ApplyRemovals(*this, to_remove_span);\n+        } else {\n+            // Otherwise, skip this already-removed entry.\n+            to_remove_span = to_remove_span.subspan(1);\n+        }\n+    }\n+    m_to_remove.clear();\n+}\n+\n+void TxGraphImpl::SwapIndexes(GraphIndex a, GraphIndex b) noexcept\n+{\n+    Assume(a < m_entries.size());\n+    Assume(b < m_entries.size());\n+    // Swap the Entry objects.\n+    std::swap(m_entries[a], m_entries[b]);\n+    // Iterate over both objects.\n+    for (int i = 0; i < 2; ++i) {\n+        GraphIndex idx = i ? b : a;\n+        Entry& entry = m_entries[idx];\n+        // Update linked Ref.\n+        if (entry.m_ref) GetRefIndex(*entry.m_ref) = idx;\n+        // Update the locator. The rest of the Entry information will not change, so no need to\n+        // invoke Cluster::Updated().\n+        Locator& locator = entry.m_locator;\n+        if (locator.IsPresent()) {\n+            locator.cluster->UpdateMapping(locator.index, idx);\n+        }\n+    }\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::Cleanup() noexcept\n+{\n+    ApplyDependencies();\n+    std::vector<Ref*> ret;\n+    // Sort the GraphIndex that need to be cleaned up. This groups them (so duplicates can be\n+    // processed just once). They are sorted in reverse, so the last ones get processed first.\n+    // This means earlier-processed GraphIndexes will not move of later-processed ones (which\n+    // might invalidate them).\n+    std::sort(m_wiped.begin(), m_wiped.end(), std::greater{});\n+    GraphIndex last(-1);\n+    for (GraphIndex idx : m_wiped) {\n+        // m_wiped should never contain the same GraphIndex twice (the code below would fail\n+        // if so, because GraphIndexes get invalidated by removing them).\n+        Assume(idx != last);\n+        last = idx;\n+        Entry& entry = m_entries[idx];\n+        // Gather Ref pointers that are being unlinked.\n+        if (entry.m_ref != nullptr) {\n+            ret.push_back(entry.m_ref);\n+            GetRefGraph(*entry.m_ref) = nullptr;\n+            m_entries[idx].m_ref = nullptr;\n+        }\n+        // Verify removed entries don't have anything that could hold a reference back.\n+        Assume(!entry.m_locator.IsPresent());\n+        if (idx != m_entries.size() - 1) SwapIndexes(idx, m_entries.size() - 1);\n+        m_entries.pop_back();\n+    }\n+    m_wiped.clear();\n+    return ret;\n+}\n+\n+void TxGraphImpl::Split(Cluster& cluster) noexcept\n+{\n+    // To split a Cluster, first make sure all removals are applied (as we might need to split\n+    // again afterwards otherwise).\n+    ApplyRemovals();\n+    bool del = cluster.Split(*this);\n+    if (del) {\n+        // Cluster::Split reports whether the Cluster is to be deleted.\n+        DeleteCluster(cluster);\n+    }\n+}\n+\n+void TxGraphImpl::SplitAll() noexcept\n+{\n+    // Before splitting all Cluster, first make sure all removals are applied.\n+    ApplyRemovals();\n+    auto& queue = m_clusters[int(QualityLevel::NEEDS_SPLIT)];\n+    while (!queue.empty()) {\n+        Split(*queue.back().get());\n+    }\n+}\n+\n+void TxGraphImpl::GroupClusters() noexcept\n+{\n+    // Before computing which Clusters need to be merged together, first apply all removals and\n+    // split the Clusters into connected components. If we would group first, we might end up\n+    // with inefficient Clusters which just end up being split again anyway.\n+    SplitAll();\n+\n+    // If the groupings have been computed already, nothing is left to be done.\n+    if (m_group_data.has_value()) return;\n+\n+    /** Annotated clusters: an entry for each Cluster, together with the representative for the\n+     *  partition it is in if known, or with nullptr if not yet known. */\n+    std::vector<std::pair<Cluster*, Cluster*>> an_clusters;\n+    /** Annotated dependencies: an entry for each m_deps_to_apply entry (excluding ones that apply\n+     *  to removed transactions), together with the representative root of the partition of\n+     *  Clusters it applies to. */\n+    std::vector<std::pair<std::pair<GraphIndex, GraphIndex>, Cluster*>> an_deps;\n+\n+    // Construct a an_clusters entry for every parent and child in the to-be-applied dependencies.\n+    for (const auto& [par, chl] : m_deps_to_add) {\n+        auto par_cluster = m_entries[par].m_locator.cluster;\n+        auto chl_cluster = m_entries[chl].m_locator.cluster;\n+        // Skip dependencies for which the parent or child transaction is removed.\n+        if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+        an_clusters.emplace_back(par_cluster, nullptr);\n+        // Do not include a duplicate when parent and child are identical, as it'll be removed\n+        // below anyway.\n+        if (chl_cluster != par_cluster) an_clusters.emplace_back(chl_cluster, nullptr);\n+    }\n+    // Sort and deduplicate an_clusters, so we end up with a sorted list of all involved Clusters\n+    // to which dependencies apply.\n+    std::sort(an_clusters.begin(), an_clusters.end());\n+    an_clusters.erase(std::unique(an_clusters.begin(), an_clusters.end()), an_clusters.end());\n+\n+    // Sort the dependencies by child Cluster.\n+    std::sort(m_deps_to_add.begin(), m_deps_to_add.end(), [&](auto& a, auto& b) noexcept {\n+        auto [_a_par, a_chl] = a;\n+        auto [_b_par, b_chl] = b;\n+        auto a_chl_cluster = m_entries[a_chl].m_locator.cluster;\n+        auto b_chl_cluster = m_entries[b_chl].m_locator.cluster;\n+        return std::less{}(a_chl_cluster, b_chl_cluster);\n+    });\n+\n+    // Run the union-find algorithm to to find partitions of the input Clusters which need to be\n+    // grouped together. See https://en.wikipedia.org/wiki/Disjoint-set_data_structure.\n+    {\n+        /** Each PartitionData entry contains information about a single input Cluster. */\n+        struct PartitionData\n+        {\n+            /** The cluster this holds information for. */\n+            Cluster* cluster;\n+            /** All PartitionData entries belonging to the same partition are organized in a tree.\n+             *  Each element points to its parent, or to itself if it is the root. The root is then\n+             *  a representative for the entire tree, and can be found by walking upwards from any\n+             *  element. */\n+            PartitionData* parent;\n+            /** (only if this is a root, so when parent == this) An upper bound on the height of\n+             *  tree for this partition. */\n+            unsigned rank;\n+        };\n+        /** Information about each input Cluster. Sorted by Cluster* pointer. */\n+        std::vector<PartitionData> partition_data;\n+\n+        /** Given a Cluster, find its corresponding PartitionData. */\n+        auto locate_uf = [&](Cluster* arg) noexcept -> PartitionData* {\n+            auto it = std::lower_bound(partition_data.begin(), partition_data.end(), arg,\n+                                       [](auto& a, Cluster* ptr) noexcept { return a.cluster < ptr; });\n+            Assume(it != partition_data.end());\n+            Assume(it->cluster == arg);\n+            return &*it;\n+        };\n+\n+        /** Given a PartitionData, find the root of the tree it is in (its representative). */\n+        static constexpr auto find_uf = [](PartitionData* data) noexcept -> PartitionData* {\n+            while (data->parent != data) {\n+                // Replace pointers to parents with pointers to grandparents.\n+                // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Finding_set_representatives.\n+                auto par = data->parent;\n+                data->parent = par->parent;\n+                data = par;\n+            }\n+            return data;\n+        };\n+\n+        /** Given two PartitionDatas, union the partitions they are in, and return their\n+         *  representative. */\n+        static constexpr auto union_uf = [](PartitionData* arg1, PartitionData* arg2) noexcept {\n+            // Find the roots of the trees, and bail out if they are already equal (which would\n+            // mean they are in the same partition already).\n+            auto rep1 = find_uf(arg1);\n+            auto rep2 = find_uf(arg2);\n+            if (rep1 == rep2) return rep1;\n+            // Pick the lower-rank root to become a child of the higher-rank one.\n+            // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Union_by_rank.\n+            if (rep1->rank < rep2->rank) std::swap(rep1, rep2);\n+            rep2->parent = rep1;\n+            rep1->rank += (rep1->rank == rep2->rank);\n+            return rep1;\n+        };\n+\n+        // Start by initializing every Cluster as its own singleton partition.\n+        partition_data.resize(an_clusters.size());\n+        for (size_t i = 0; i < an_clusters.size(); ++i) {\n+            partition_data[i].cluster = an_clusters[i].first;\n+            partition_data[i].parent = &partition_data[i];\n+            partition_data[i].rank = 0;\n+        }\n+\n+        // Run through all parent/child pairs in m_deps_to_add, and union the\n+        // the partitions their Clusters are in.\n+        Cluster* last_chl_cluster{nullptr};\n+        PartitionData* last_partition{nullptr};\n+        for (const auto& [par, chl] : m_deps_to_add) {\n+            auto par_cluster = m_entries[par].m_locator.cluster;\n+            auto chl_cluster = m_entries[chl].m_locator.cluster;\n+            // Nothing to do if parent and child are in the same Cluster.\n+            if (par_cluster == chl_cluster) continue;\n+            // Nothing to do if either parent or child transaction is removed already.\n+            if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+            Assume(par != chl);\n+            if (chl_cluster == last_chl_cluster) {\n+                // If the child Clusters is the same as the previous iteration, union with the\n+                // tree they were in, avoiding the need for another lookup. Note that m_deps_to_add\n+                // is sorted by child Cluster, so batches with the same child are expected.\n+                last_partition = union_uf(locate_uf(par_cluster), last_partition);\n+            } else {\n+                last_chl_cluster = chl_cluster;\n+                last_partition = union_uf(locate_uf(par_cluster), locate_uf(chl_cluster));\n+            }\n+        }\n+\n+        // Populate the an_clusters and an_deps data structures with the list of input Clusters,\n+        // and the input dependencies, annotated with the representative of the Cluster partition\n+        // it applies to.\n+        an_deps.reserve(m_deps_to_add.size());\n+        auto deps_it = m_deps_to_add.begin();\n+        for (size_t i = 0; i < partition_data.size(); ++i) {\n+            auto& data = partition_data[i];\n+            // Find the representative of the partition Cluster i is in, and store it with the\n+            // Cluster.\n+            auto rep = find_uf(&data)->cluster;\n+            an_clusters[i].second = rep;\n+            // Find all dependencies whose child Cluster is Cluster i, and annotate them with rep.\n+            while (deps_it != m_deps_to_add.end()) {\n+                auto [par, chl] = *deps_it;\n+                auto chl_cluster = m_entries[chl].m_locator.cluster;\n+                // Skip dependencies that apply to earlier Clusters (those necessary are for\n+                // deleted transactions, as otherwise we'd have processed them already).\n+                if (!std::less{}(chl_cluster, data.cluster)) {\n+                    if (chl_cluster != data.cluster) break;\n+                    auto par_cluster = m_entries[par].m_locator.cluster;\n+                    // Also filter out dependencies applying to a removed parent.\n+                    if (par_cluster != nullptr) an_deps.emplace_back(*deps_it, rep);\n+                }\n+                ++deps_it;\n+            }\n+        }\n+    }\n+\n+    // Sort both an_clusters and an_deps by representative of the partition they are in, grouping\n+    // all those applying to the same partition together.\n+    std::sort(an_deps.begin(), an_deps.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+    std::sort(an_clusters.begin(), an_clusters.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+\n+    // Translate the resulting cluster groups to the m_group_data structure.\n+    m_group_data = std::vector<GroupData>{};\n+    m_group_clusters.clear();\n+    m_group_clusters.reserve(an_clusters.size());\n+    m_deps_to_add.clear();\n+    m_deps_to_add.reserve(an_deps.size());\n+    auto an_deps_it = an_deps.begin();\n+    auto an_clusters_it = an_clusters.begin();\n+    while (an_deps_it != an_deps.end()) {\n+        auto rep = an_deps_it->second;\n+        // Create and initialize a new GroupData entry for the partition.\n+        auto& new_entry = m_group_data->emplace_back();\n+        new_entry.m_cluster_offset = m_group_clusters.size();\n+        new_entry.m_cluster_count = 0;\n+        new_entry.m_deps_offset = m_deps_to_add.size();\n+        new_entry.m_deps_count = 0;\n+        // Add all its clusters to it (copying those from an_clusters to m_group_clusters).\n+        while (an_clusters_it != an_clusters.end() && an_clusters_it->second == rep) {\n+            m_group_clusters.push_back(an_clusters_it->first);\n+            ++an_clusters_it;\n+            ++new_entry.m_cluster_count;\n+        }\n+        // Add all its dependencies to it (copying those back from an_deps to m_deps_to_add).\n+        while (an_deps_it != an_deps.end() && an_deps_it->second == rep) {\n+            m_deps_to_add.push_back(an_deps_it->first);\n+            ++an_deps_it;\n+            ++new_entry.m_deps_count;\n+        }\n+    }\n+    Assume(an_deps_it == an_deps.end());\n+    Assume(an_clusters_it == an_clusters.end());\n+}\n+\n+void TxGraphImpl::Merge(std::span<Cluster*> to_merge) noexcept\n+{\n+    Assume(!to_merge.empty());\n+    // Nothing to do if a group consists of just a single Cluster.\n+    if (to_merge.size() == 1) return;\n+\n+    // Move the largest Cluster to the front of to_merge. As all transactions in other to-be-merged\n+    // Clusters will be moved to that one, putting the largest one first minimizes the number of\n+    // moves.\n+    size_t max_size_pos{0};\n+    ClusterIndex max_size = to_merge[max_size_pos]->GetTxCount();\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        ClusterIndex size = to_merge[i]->GetTxCount();\n+        if (size > max_size) {\n+            max_size_pos = i;\n+            max_size = size;\n+        }\n+    }\n+    if (max_size_pos != 0) std::swap(to_merge[0], to_merge[max_size_pos]);\n+\n+    // Merge all further Clusters in the group into the first one, and delete them.\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        to_merge[0]->Merge(*this, *to_merge[i]);\n+        DeleteCluster(*to_merge[i]);\n+    }\n+}\n+\n+void TxGraphImpl::ApplyDependencies() noexcept\n+{\n+    // Compute the groups of to-be-merged Clusters (which also applies all removals, and splits).\n+    GroupClusters();\n+    Assume(m_group_data.has_value());\n+    // Nothing to do if there are no dependencies to be added.\n+    if (m_deps_to_add.empty()) return;\n+\n+    // For each group of to-be-merged Clusters.\n+    Assume(m_group_data.has_value());\n+    for (const auto& group_data : *m_group_data) {\n+        // Invoke Merge() to merge them into a single Cluster.\n+        auto cluster_span = std::span{m_group_clusters}\n+                                .subspan(group_data.m_cluster_offset, group_data.m_cluster_count);\n+        Merge(cluster_span);\n+        // Actually apply all to-be-added dependencies (for each, parent and child belong to the\n+        // same Cluster because of the merging above).\n+        auto deps_span = std::span{m_deps_to_add}\n+                             .subspan(group_data.m_deps_offset, group_data.m_deps_count);\n+        Assume(!deps_span.empty());\n+        const auto& loc = m_entries[deps_span[0].second].m_locator;\n+        Assume(loc.IsPresent());\n+        loc.cluster->ApplyDependencies(*this, deps_span);\n+    }\n+\n+    // Wipe the list of to-be-added dependencies now that they are applied.\n+    m_deps_to_add.clear();\n+    // Also no further Cluster mergings are needed (note that we clear, but don't set to\n+    // std::nullopt, as that would imply the groupings are unknown).\n+    m_group_data->clear();\n+    m_group_clusters.clear();\n+}\n+\n+void Cluster::Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept\n+{\n+    // We can only relinearize Clusters that do not need splitting.\n+    Assume(m_quality == QualityLevel::OPTIMAL || m_quality == QualityLevel::ACCEPTABLE ||\n+           m_quality == QualityLevel::NEEDS_RELINEARIZE);\n+    // No work is required for Clusters which are already optimally linearized.\n+    if (m_quality == QualityLevel::OPTIMAL) return;\n+    // Invoke the actual linearization algorithm (passing in the existing one).\n+    uint64_t rng_seed = graph.m_rng.rand64();\n+    auto [linearization, optimal] = Linearize(m_depgraph, max_iters, rng_seed, m_linearization);\n+    // Postlinearize if the result isn't optimal already. This guarantees (among other things)\n+    // that the chunks of the resulting linearization are all connected.\n+    if (!optimal) PostLinearize(m_depgraph, linearization);\n+    // Update the linearization.\n+    m_linearization = std::move(linearization);\n+    // Update the Cluster's quality.\n+    auto new_quality = optimal ? QualityLevel::OPTIMAL : QualityLevel::ACCEPTABLE;\n+    graph.SetClusterQuality(m_quality, m_setindex, new_quality);\n+    // Update the Entry objects.\n+    Updated(graph);\n+}\n+\n+void TxGraphImpl::MakeAcceptable(Cluster& cluster) noexcept\n+{\n+    // Relinearize the Cluster if needed.\n+    if (cluster.m_quality == QualityLevel::NEEDS_RELINEARIZE) {\n+        cluster.Relinearize(*this, 10000);\n+    }\n+}\n+\n+Cluster::Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept\n+{\n+    // Create a new transaction in the DepGraph, and remember its position in m_mapping.\n+    auto cluster_idx = m_depgraph.AddTransaction(feerate);\n+    m_mapping.push_back(graph_index);\n+    m_linearization.push_back(cluster_idx);\n+}\n+\n+TxGraph::Ref TxGraphImpl::AddTransaction(const FeeFrac& feerate) noexcept\n+{\n+    // Construct a new Ref.\n+    Ref ret;\n+    // Construct a new Entry, and link it with the Ref.\n+    auto idx = m_entries.size();\n+    m_entries.emplace_back();\n+    auto& entry = m_entries.back();\n+    entry.m_ref = &ret;",
      "path": "src/txgraph.cpp",
      "position": 1689,
      "original_position": 953,
      "commit_id": "3744b8318d8f465603f0e6f9eb72e679d763c4ca",
      "original_commit_id": "0c8dc2323eb1ec34357a807f0860cf0a08a63a75",
      "in_reply_to_id": 1909286865,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I believe it is safe, both with NRVO and without.\r\n\r\nWith NRVO, `ret` is constructed directly in the caller's target destination, so this isn't a pointer to local stack space.\r\n\r\nWithout NRVO, the `Ref(Ref&&)` move constructor is invoked by `return ret;`, which will update the pointer to the caller's destination.",
      "created_at": "2025-01-09T20:19:28Z",
      "updated_at": "2025-01-09T21:17:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r1909385059",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909385059"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1689,
      "original_line": 1689,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909403690",
      "pull_request_review_id": 2540882536,
      "id": 1909403690,
      "node_id": "PRRC_kwDOABII585xzzAq",
      "diff_hunk": "@@ -0,0 +1,1193 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a ClusterIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<ClusterIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(ClusterIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeeFrac GetIndividualFeerate(ClusterIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, ClusterIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Cleanup).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupData\n+    {\n+        /** Where the clusters to be merged start in m_group_clusters. */\n+        uint32_t m_cluster_offset;\n+        /** How many clusters to merge. */\n+        uint32_t m_cluster_count;\n+        /** Where the dependencies for this cluster group in m_deps_to_add start. */\n+        uint32_t m_deps_offset;\n+        /** How many dependencies to add. */\n+        uint32_t m_deps_count;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Which clusters are to be merged. GroupData::m_cluster_offset indexes into this. */\n+    std::vector<Cluster*> m_group_clusters;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupData>> m_group_data = std::vector<GroupData>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        ClusterIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, ClusterIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref;\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeeFrac m_chunk_feerate;\n+\n+        /** Check whether this Entry is not present in any Cluster. */\n+        bool IsWiped() const noexcept\n+        {\n+            return !m_locator.IsPresent();\n+        }\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries that have no IsPresent locators left, and need to be cleaned up. */\n+    std::vector<GraphIndex> m_wiped;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeeFrac& feerate) noexcept final;\n+    void RemoveTransaction(Ref& arg) noexcept final;\n+    void AddDependency(Ref& parent, Ref& child) noexcept final;\n+    void SetTransactionFee(Ref&, int64_t fee) noexcept final;\n+    std::vector<Ref*> Cleanup() noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeeFrac GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeeFrac GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (ClusterIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        while (true) {\n+            ClusterIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = chunk.feerate;\n+            chunk.transactions.Reset(idx);\n+            if (chunk.transactions.None()) break;\n+        }\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        if (entry.IsWiped()) graph.m_wiped.push_back(idx);\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, ClusterIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transaction go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), ClusterIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // ClusterIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<ClusterIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator.SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Sort the list of dependencies to apply by child, so those can be applied in batch.\n+    std::sort(to_apply.begin(), to_apply.end(), [](auto& a, auto& b) { return a.second < b.second; });\n+    // Iterate over groups of to-be-added dependencies with the same child.\n+    auto it = to_apply.begin();\n+    while (it != to_apply.end()) {\n+        auto& first_child = graph.m_entries[it->second].m_locator;\n+        ClusterIndex child_idx = first_child.index;\n+        // Iterate over all to-be-added dependencies within that same child, gather the relevant\n+        // parents.\n+        SetType parents;\n+        while (it != to_apply.end()) {\n+            auto& child = graph.m_entries[it->second].m_locator;\n+            auto& parent = graph.m_entries[it->first].m_locator;\n+            Assume(child.cluster == this && parent.cluster == this);\n+            if (child.index != child_idx) break;\n+            parents.Set(parent.index);\n+            ++it;\n+        }\n+        // Push all dependencies to the underlying DepGraph. Note that this is O(N) in the size of\n+        // the cluster, regardless of the number of parents being added, so batching them together\n+        // has a performance benefit.\n+        m_depgraph.AddDependencies(parents, child_idx);\n+    }\n+\n+    // Finally fix the linearization, as the new dependencies may have invalidated the\n+    // linearization, and post-linearize it to fix up the worst problems with it.\n+    FixLinearization(m_depgraph, m_linearization);\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Finally push the changes to graph.m_entries.\n+    Updated(graph);\n+}\n+\n+std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept\n+{\n+    Assume(quality != QualityLevel::NONE);\n+\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    Assume(setindex < quality_clusters.size());\n+\n+    // Extract the Cluster-owning unique_ptr.\n+    std::unique_ptr<Cluster> ret = std::move(quality_clusters[setindex]);\n+    ret->m_quality = QualityLevel::NONE;\n+    ret->m_setindex = ClusterSetIndex(-1);\n+\n+    // Clean up space in quality_cluster.\n+    auto max_setindex = quality_clusters.size() - 1;\n+    if (setindex != max_setindex) {\n+        // If the cluster was not the last element of quality_clusters, move that to take its place.\n+        quality_clusters.back()->m_quality = quality;\n+        quality_clusters.back()->m_setindex = setindex;\n+        quality_clusters[setindex] = std::move(quality_clusters.back());\n+    }\n+    // The last element of quality_clusters is now unused; drop it.\n+    quality_clusters.pop_back();\n+\n+    return ret;\n+}\n+\n+ClusterSetIndex TxGraphImpl::InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+{\n+    // Cannot insert with quality level NONE (as that would mean not inserted).\n+    Assume(quality != QualityLevel::NONE);\n+    // The passed-in Cluster must not currently be in the TxGraphImpl.\n+    Assume(cluster->m_quality == QualityLevel::NONE);\n+\n+    // Append it at the end of the relevant TxGraphImpl::m_cluster.\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    ClusterSetIndex ret = quality_clusters.size();\n+    cluster->m_quality = quality;\n+    cluster->m_setindex = ret;\n+    quality_clusters.push_back(std::move(cluster));\n+    return ret;\n+}\n+\n+void TxGraphImpl::SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+{\n+    Assume(new_quality != QualityLevel::NONE);\n+\n+    // Don't do anything if the quality did not change.\n+    if (old_quality == new_quality) return;\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(old_quality, old_index);\n+    // And re-insert it where it belongs.\n+    InsertCluster(std::move(cluster_ptr), new_quality);\n+}\n+\n+void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n+{\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(cluster.m_quality, cluster.m_setindex);\n+    // And throw it away.\n+    cluster_ptr.reset();\n+}\n+\n+void TxGraphImpl::ApplyRemovals() noexcept\n+{\n+    auto& to_remove = m_to_remove;\n+    // Skip if there is nothing to remove.\n+    if (to_remove.empty()) return;\n+    // Wipe cached m_group_data, as it may be invalidated by removals.\n+    m_group_data = std::nullopt;\n+    m_group_clusters.clear();\n+    // Group the set of to-be-removed entries by Cluster*.\n+    std::sort(m_to_remove.begin(), m_to_remove.end(), [&](GraphIndex a, GraphIndex b) noexcept {\n+        return std::less{}(m_entries[a].m_locator.cluster, m_entries[b].m_locator.cluster);\n+    });\n+    // Process per Cluster.\n+    std::span to_remove_span{m_to_remove};\n+    while (!to_remove_span.empty()) {\n+        Cluster* cluster = m_entries[to_remove_span.front()].m_locator.cluster;\n+        if (cluster != nullptr) {\n+            // If the first to_remove_span entry's Cluster exists, hand to_remove_span to it, so it\n+            // can pop off whatever applies to it.\n+            cluster->ApplyRemovals(*this, to_remove_span);\n+        } else {\n+            // Otherwise, skip this already-removed entry.\n+            to_remove_span = to_remove_span.subspan(1);\n+        }\n+    }\n+    m_to_remove.clear();\n+}\n+\n+void TxGraphImpl::SwapIndexes(GraphIndex a, GraphIndex b) noexcept\n+{\n+    Assume(a < m_entries.size());\n+    Assume(b < m_entries.size());\n+    // Swap the Entry objects.\n+    std::swap(m_entries[a], m_entries[b]);\n+    // Iterate over both objects.\n+    for (int i = 0; i < 2; ++i) {\n+        GraphIndex idx = i ? b : a;\n+        Entry& entry = m_entries[idx];\n+        // Update linked Ref.\n+        if (entry.m_ref) GetRefIndex(*entry.m_ref) = idx;\n+        // Update the locator. The rest of the Entry information will not change, so no need to\n+        // invoke Cluster::Updated().\n+        Locator& locator = entry.m_locator;\n+        if (locator.IsPresent()) {\n+            locator.cluster->UpdateMapping(locator.index, idx);\n+        }\n+    }\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::Cleanup() noexcept\n+{\n+    ApplyDependencies();\n+    std::vector<Ref*> ret;\n+    // Sort the GraphIndex that need to be cleaned up. This groups them (so duplicates can be\n+    // processed just once). They are sorted in reverse, so the last ones get processed first.\n+    // This means earlier-processed GraphIndexes will not move of later-processed ones (which\n+    // might invalidate them).\n+    std::sort(m_wiped.begin(), m_wiped.end(), std::greater{});\n+    GraphIndex last(-1);\n+    for (GraphIndex idx : m_wiped) {\n+        // m_wiped should never contain the same GraphIndex twice (the code below would fail\n+        // if so, because GraphIndexes get invalidated by removing them).\n+        Assume(idx != last);\n+        last = idx;\n+        Entry& entry = m_entries[idx];\n+        // Gather Ref pointers that are being unlinked.\n+        if (entry.m_ref != nullptr) {\n+            ret.push_back(entry.m_ref);\n+            GetRefGraph(*entry.m_ref) = nullptr;\n+            m_entries[idx].m_ref = nullptr;\n+        }\n+        // Verify removed entries don't have anything that could hold a reference back.\n+        Assume(!entry.m_locator.IsPresent());\n+        if (idx != m_entries.size() - 1) SwapIndexes(idx, m_entries.size() - 1);\n+        m_entries.pop_back();\n+    }\n+    m_wiped.clear();\n+    return ret;\n+}\n+\n+void TxGraphImpl::Split(Cluster& cluster) noexcept\n+{\n+    // To split a Cluster, first make sure all removals are applied (as we might need to split\n+    // again afterwards otherwise).\n+    ApplyRemovals();\n+    bool del = cluster.Split(*this);\n+    if (del) {\n+        // Cluster::Split reports whether the Cluster is to be deleted.\n+        DeleteCluster(cluster);\n+    }\n+}\n+\n+void TxGraphImpl::SplitAll() noexcept\n+{\n+    // Before splitting all Cluster, first make sure all removals are applied.\n+    ApplyRemovals();\n+    auto& queue = m_clusters[int(QualityLevel::NEEDS_SPLIT)];\n+    while (!queue.empty()) {\n+        Split(*queue.back().get());\n+    }\n+}\n+\n+void TxGraphImpl::GroupClusters() noexcept\n+{\n+    // Before computing which Clusters need to be merged together, first apply all removals and\n+    // split the Clusters into connected components. If we would group first, we might end up\n+    // with inefficient Clusters which just end up being split again anyway.\n+    SplitAll();\n+\n+    // If the groupings have been computed already, nothing is left to be done.\n+    if (m_group_data.has_value()) return;\n+\n+    /** Annotated clusters: an entry for each Cluster, together with the representative for the\n+     *  partition it is in if known, or with nullptr if not yet known. */\n+    std::vector<std::pair<Cluster*, Cluster*>> an_clusters;\n+    /** Annotated dependencies: an entry for each m_deps_to_apply entry (excluding ones that apply\n+     *  to removed transactions), together with the representative root of the partition of\n+     *  Clusters it applies to. */\n+    std::vector<std::pair<std::pair<GraphIndex, GraphIndex>, Cluster*>> an_deps;\n+\n+    // Construct a an_clusters entry for every parent and child in the to-be-applied dependencies.\n+    for (const auto& [par, chl] : m_deps_to_add) {\n+        auto par_cluster = m_entries[par].m_locator.cluster;\n+        auto chl_cluster = m_entries[chl].m_locator.cluster;\n+        // Skip dependencies for which the parent or child transaction is removed.\n+        if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+        an_clusters.emplace_back(par_cluster, nullptr);\n+        // Do not include a duplicate when parent and child are identical, as it'll be removed\n+        // below anyway.\n+        if (chl_cluster != par_cluster) an_clusters.emplace_back(chl_cluster, nullptr);\n+    }\n+    // Sort and deduplicate an_clusters, so we end up with a sorted list of all involved Clusters\n+    // to which dependencies apply.\n+    std::sort(an_clusters.begin(), an_clusters.end());\n+    an_clusters.erase(std::unique(an_clusters.begin(), an_clusters.end()), an_clusters.end());\n+\n+    // Sort the dependencies by child Cluster.\n+    std::sort(m_deps_to_add.begin(), m_deps_to_add.end(), [&](auto& a, auto& b) noexcept {\n+        auto [_a_par, a_chl] = a;\n+        auto [_b_par, b_chl] = b;\n+        auto a_chl_cluster = m_entries[a_chl].m_locator.cluster;\n+        auto b_chl_cluster = m_entries[b_chl].m_locator.cluster;\n+        return std::less{}(a_chl_cluster, b_chl_cluster);\n+    });\n+\n+    // Run the union-find algorithm to to find partitions of the input Clusters which need to be\n+    // grouped together. See https://en.wikipedia.org/wiki/Disjoint-set_data_structure.\n+    {\n+        /** Each PartitionData entry contains information about a single input Cluster. */\n+        struct PartitionData\n+        {\n+            /** The cluster this holds information for. */\n+            Cluster* cluster;\n+            /** All PartitionData entries belonging to the same partition are organized in a tree.\n+             *  Each element points to its parent, or to itself if it is the root. The root is then\n+             *  a representative for the entire tree, and can be found by walking upwards from any\n+             *  element. */\n+            PartitionData* parent;\n+            /** (only if this is a root, so when parent == this) An upper bound on the height of\n+             *  tree for this partition. */\n+            unsigned rank;\n+        };\n+        /** Information about each input Cluster. Sorted by Cluster* pointer. */\n+        std::vector<PartitionData> partition_data;\n+\n+        /** Given a Cluster, find its corresponding PartitionData. */\n+        auto locate_uf = [&](Cluster* arg) noexcept -> PartitionData* {\n+            auto it = std::lower_bound(partition_data.begin(), partition_data.end(), arg,\n+                                       [](auto& a, Cluster* ptr) noexcept { return a.cluster < ptr; });\n+            Assume(it != partition_data.end());\n+            Assume(it->cluster == arg);\n+            return &*it;\n+        };\n+\n+        /** Given a PartitionData, find the root of the tree it is in (its representative). */\n+        static constexpr auto find_uf = [](PartitionData* data) noexcept -> PartitionData* {\n+            while (data->parent != data) {\n+                // Replace pointers to parents with pointers to grandparents.\n+                // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Finding_set_representatives.\n+                auto par = data->parent;\n+                data->parent = par->parent;\n+                data = par;\n+            }\n+            return data;\n+        };\n+\n+        /** Given two PartitionDatas, union the partitions they are in, and return their\n+         *  representative. */\n+        static constexpr auto union_uf = [](PartitionData* arg1, PartitionData* arg2) noexcept {\n+            // Find the roots of the trees, and bail out if they are already equal (which would\n+            // mean they are in the same partition already).\n+            auto rep1 = find_uf(arg1);\n+            auto rep2 = find_uf(arg2);\n+            if (rep1 == rep2) return rep1;\n+            // Pick the lower-rank root to become a child of the higher-rank one.\n+            // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Union_by_rank.\n+            if (rep1->rank < rep2->rank) std::swap(rep1, rep2);\n+            rep2->parent = rep1;\n+            rep1->rank += (rep1->rank == rep2->rank);\n+            return rep1;\n+        };\n+\n+        // Start by initializing every Cluster as its own singleton partition.\n+        partition_data.resize(an_clusters.size());\n+        for (size_t i = 0; i < an_clusters.size(); ++i) {\n+            partition_data[i].cluster = an_clusters[i].first;\n+            partition_data[i].parent = &partition_data[i];\n+            partition_data[i].rank = 0;\n+        }\n+\n+        // Run through all parent/child pairs in m_deps_to_add, and union the\n+        // the partitions their Clusters are in.\n+        Cluster* last_chl_cluster{nullptr};\n+        PartitionData* last_partition{nullptr};\n+        for (const auto& [par, chl] : m_deps_to_add) {\n+            auto par_cluster = m_entries[par].m_locator.cluster;\n+            auto chl_cluster = m_entries[chl].m_locator.cluster;\n+            // Nothing to do if parent and child are in the same Cluster.\n+            if (par_cluster == chl_cluster) continue;\n+            // Nothing to do if either parent or child transaction is removed already.\n+            if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+            Assume(par != chl);\n+            if (chl_cluster == last_chl_cluster) {\n+                // If the child Clusters is the same as the previous iteration, union with the\n+                // tree they were in, avoiding the need for another lookup. Note that m_deps_to_add\n+                // is sorted by child Cluster, so batches with the same child are expected.\n+                last_partition = union_uf(locate_uf(par_cluster), last_partition);\n+            } else {\n+                last_chl_cluster = chl_cluster;\n+                last_partition = union_uf(locate_uf(par_cluster), locate_uf(chl_cluster));\n+            }\n+        }\n+\n+        // Populate the an_clusters and an_deps data structures with the list of input Clusters,\n+        // and the input dependencies, annotated with the representative of the Cluster partition\n+        // it applies to.\n+        an_deps.reserve(m_deps_to_add.size());\n+        auto deps_it = m_deps_to_add.begin();\n+        for (size_t i = 0; i < partition_data.size(); ++i) {\n+            auto& data = partition_data[i];\n+            // Find the representative of the partition Cluster i is in, and store it with the\n+            // Cluster.\n+            auto rep = find_uf(&data)->cluster;\n+            an_clusters[i].second = rep;\n+            // Find all dependencies whose child Cluster is Cluster i, and annotate them with rep.\n+            while (deps_it != m_deps_to_add.end()) {\n+                auto [par, chl] = *deps_it;\n+                auto chl_cluster = m_entries[chl].m_locator.cluster;\n+                // Skip dependencies that apply to earlier Clusters (those necessary are for\n+                // deleted transactions, as otherwise we'd have processed them already).\n+                if (!std::less{}(chl_cluster, data.cluster)) {\n+                    if (chl_cluster != data.cluster) break;\n+                    auto par_cluster = m_entries[par].m_locator.cluster;\n+                    // Also filter out dependencies applying to a removed parent.\n+                    if (par_cluster != nullptr) an_deps.emplace_back(*deps_it, rep);\n+                }\n+                ++deps_it;\n+            }\n+        }\n+    }\n+\n+    // Sort both an_clusters and an_deps by representative of the partition they are in, grouping\n+    // all those applying to the same partition together.\n+    std::sort(an_deps.begin(), an_deps.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+    std::sort(an_clusters.begin(), an_clusters.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+\n+    // Translate the resulting cluster groups to the m_group_data structure.\n+    m_group_data = std::vector<GroupData>{};\n+    m_group_clusters.clear();\n+    m_group_clusters.reserve(an_clusters.size());\n+    m_deps_to_add.clear();\n+    m_deps_to_add.reserve(an_deps.size());\n+    auto an_deps_it = an_deps.begin();\n+    auto an_clusters_it = an_clusters.begin();\n+    while (an_deps_it != an_deps.end()) {\n+        auto rep = an_deps_it->second;\n+        // Create and initialize a new GroupData entry for the partition.\n+        auto& new_entry = m_group_data->emplace_back();\n+        new_entry.m_cluster_offset = m_group_clusters.size();\n+        new_entry.m_cluster_count = 0;\n+        new_entry.m_deps_offset = m_deps_to_add.size();\n+        new_entry.m_deps_count = 0;\n+        // Add all its clusters to it (copying those from an_clusters to m_group_clusters).\n+        while (an_clusters_it != an_clusters.end() && an_clusters_it->second == rep) {\n+            m_group_clusters.push_back(an_clusters_it->first);\n+            ++an_clusters_it;\n+            ++new_entry.m_cluster_count;\n+        }\n+        // Add all its dependencies to it (copying those back from an_deps to m_deps_to_add).\n+        while (an_deps_it != an_deps.end() && an_deps_it->second == rep) {\n+            m_deps_to_add.push_back(an_deps_it->first);\n+            ++an_deps_it;\n+            ++new_entry.m_deps_count;\n+        }\n+    }\n+    Assume(an_deps_it == an_deps.end());\n+    Assume(an_clusters_it == an_clusters.end());\n+}\n+\n+void TxGraphImpl::Merge(std::span<Cluster*> to_merge) noexcept\n+{\n+    Assume(!to_merge.empty());\n+    // Nothing to do if a group consists of just a single Cluster.\n+    if (to_merge.size() == 1) return;\n+\n+    // Move the largest Cluster to the front of to_merge. As all transactions in other to-be-merged\n+    // Clusters will be moved to that one, putting the largest one first minimizes the number of\n+    // moves.\n+    size_t max_size_pos{0};\n+    ClusterIndex max_size = to_merge[max_size_pos]->GetTxCount();\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        ClusterIndex size = to_merge[i]->GetTxCount();\n+        if (size > max_size) {\n+            max_size_pos = i;\n+            max_size = size;\n+        }\n+    }\n+    if (max_size_pos != 0) std::swap(to_merge[0], to_merge[max_size_pos]);\n+\n+    // Merge all further Clusters in the group into the first one, and delete them.\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        to_merge[0]->Merge(*this, *to_merge[i]);\n+        DeleteCluster(*to_merge[i]);\n+    }\n+}\n+\n+void TxGraphImpl::ApplyDependencies() noexcept\n+{\n+    // Compute the groups of to-be-merged Clusters (which also applies all removals, and splits).\n+    GroupClusters();\n+    Assume(m_group_data.has_value());\n+    // Nothing to do if there are no dependencies to be added.\n+    if (m_deps_to_add.empty()) return;\n+\n+    // For each group of to-be-merged Clusters.\n+    Assume(m_group_data.has_value());\n+    for (const auto& group_data : *m_group_data) {\n+        // Invoke Merge() to merge them into a single Cluster.\n+        auto cluster_span = std::span{m_group_clusters}\n+                                .subspan(group_data.m_cluster_offset, group_data.m_cluster_count);\n+        Merge(cluster_span);\n+        // Actually apply all to-be-added dependencies (for each, parent and child belong to the\n+        // same Cluster because of the merging above).\n+        auto deps_span = std::span{m_deps_to_add}\n+                             .subspan(group_data.m_deps_offset, group_data.m_deps_count);\n+        Assume(!deps_span.empty());\n+        const auto& loc = m_entries[deps_span[0].second].m_locator;\n+        Assume(loc.IsPresent());\n+        loc.cluster->ApplyDependencies(*this, deps_span);\n+    }\n+\n+    // Wipe the list of to-be-added dependencies now that they are applied.\n+    m_deps_to_add.clear();\n+    // Also no further Cluster mergings are needed (note that we clear, but don't set to\n+    // std::nullopt, as that would imply the groupings are unknown).\n+    m_group_data->clear();\n+    m_group_clusters.clear();\n+}\n+\n+void Cluster::Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept\n+{\n+    // We can only relinearize Clusters that do not need splitting.\n+    Assume(m_quality == QualityLevel::OPTIMAL || m_quality == QualityLevel::ACCEPTABLE ||\n+           m_quality == QualityLevel::NEEDS_RELINEARIZE);\n+    // No work is required for Clusters which are already optimally linearized.\n+    if (m_quality == QualityLevel::OPTIMAL) return;\n+    // Invoke the actual linearization algorithm (passing in the existing one).\n+    uint64_t rng_seed = graph.m_rng.rand64();\n+    auto [linearization, optimal] = Linearize(m_depgraph, max_iters, rng_seed, m_linearization);\n+    // Postlinearize if the result isn't optimal already. This guarantees (among other things)\n+    // that the chunks of the resulting linearization are all connected.\n+    if (!optimal) PostLinearize(m_depgraph, linearization);\n+    // Update the linearization.\n+    m_linearization = std::move(linearization);\n+    // Update the Cluster's quality.\n+    auto new_quality = optimal ? QualityLevel::OPTIMAL : QualityLevel::ACCEPTABLE;\n+    graph.SetClusterQuality(m_quality, m_setindex, new_quality);\n+    // Update the Entry objects.\n+    Updated(graph);\n+}\n+\n+void TxGraphImpl::MakeAcceptable(Cluster& cluster) noexcept\n+{\n+    // Relinearize the Cluster if needed.\n+    if (cluster.m_quality == QualityLevel::NEEDS_RELINEARIZE) {\n+        cluster.Relinearize(*this, 10000);\n+    }\n+}\n+\n+Cluster::Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept\n+{\n+    // Create a new transaction in the DepGraph, and remember its position in m_mapping.\n+    auto cluster_idx = m_depgraph.AddTransaction(feerate);\n+    m_mapping.push_back(graph_index);\n+    m_linearization.push_back(cluster_idx);\n+}\n+\n+TxGraph::Ref TxGraphImpl::AddTransaction(const FeeFrac& feerate) noexcept\n+{\n+    // Construct a new Ref.\n+    Ref ret;\n+    // Construct a new Entry, and link it with the Ref.\n+    auto idx = m_entries.size();\n+    m_entries.emplace_back();\n+    auto& entry = m_entries.back();\n+    entry.m_ref = &ret;\n+    GetRefGraph(ret) = this;\n+    GetRefIndex(ret) = idx;\n+    // Construct a new singleton Cluster (which is necessarily optimally linearized).\n+    auto cluster = std::make_unique<Cluster>(*this, feerate, idx);\n+    auto cluster_ptr = cluster.get();\n+    InsertCluster(std::move(cluster), QualityLevel::OPTIMAL);\n+    cluster_ptr->Updated(*this);\n+    ++m_txcount;\n+    // Return the Ref.\n+    return ret;\n+}\n+\n+void TxGraphImpl::RemoveTransaction(Ref& arg) noexcept\n+{\n+    // Don't do anything if the Ref is empty (which may be indicative of the transaction already\n+    // having been removed).\n+    if (GetRefGraph(arg) == nullptr) return;\n+    Assume(GetRefGraph(arg) == this);\n+    // Find the Cluster the transaction is in, and stop if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return;\n+    // Remember that the transaction is to be removed.\n+    m_to_remove.push_back(GetRefIndex(arg));\n+}\n+\n+void TxGraphImpl::AddDependency(Ref& parent, Ref& child) noexcept\n+{\n+    // Don't do anything if either Ref is empty (which may be indicative of it having already been\n+    // removed).\n+    if (GetRefGraph(parent) == nullptr || GetRefGraph(child) == nullptr) return;\n+    Assume(GetRefGraph(parent) == this && GetRefGraph(child) == this);\n+    // Find the Cluster the parent and child transaction are in, and stop if either appears to be\n+    // already removed.\n+    auto par_cluster = m_entries[GetRefIndex(parent)].m_locator.cluster;\n+    if (par_cluster == nullptr) return;\n+    auto chl_cluster = m_entries[GetRefIndex(child)].m_locator.cluster;\n+    if (chl_cluster == nullptr) return;\n+    // Wipe m_group_data (as it will need to be recomputed).\n+    m_group_data.reset();\n+    m_group_clusters.clear();\n+    // Remember that this dependency is to be applied.\n+    m_deps_to_add.emplace_back(GetRefIndex(parent), GetRefIndex(child));\n+}\n+\n+bool TxGraphImpl::Exists(const Ref& arg) noexcept\n+{\n+    if (GetRefGraph(arg) == nullptr) return false;\n+    Assume(GetRefGraph(arg) == this);\n+    // Make sure the transaction isn't scheduled for removal.\n+    ApplyRemovals();\n+    return m_entries[GetRefIndex(arg)].m_locator.IsPresent();\n+}\n+\n+std::vector<TxGraph::Ref*> Cluster::GetAncestorRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept\n+{\n+    std::vector<TxGraph::Ref*> ret;\n+    // Translate all ancestors (in arbitrary order) to Refs (if they have any), and return them.\n+    for (auto idx : m_depgraph.Ancestors(idx)) {\n+        const auto& entry = graph.m_entries[m_mapping[idx]];\n+        ret.push_back(entry.m_ref);\n+    }\n+    return ret;\n+}\n+\n+std::vector<TxGraph::Ref*> Cluster::GetDescendantRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept\n+{\n+    std::vector<TxGraph::Ref*> ret;\n+    // Translate all descendants (in arbitrary order) to Refs (if they have any), and return them.\n+    for (auto idx : m_depgraph.Descendants(idx)) {\n+        const auto& entry = graph.m_entries[m_mapping[idx]];\n+        ret.push_back(entry.m_ref);\n+    }\n+    return ret;\n+}\n+\n+std::vector<TxGraph::Ref*> Cluster::GetClusterRefs(const TxGraphImpl& graph) noexcept\n+{\n+    std::vector<TxGraph::Ref*> ret;\n+    // Translate all transactions in the Cluster (in linearization order) to Refs.\n+    for (auto idx : m_linearization) {\n+        const auto& entry = graph.m_entries[m_mapping[idx]];\n+        ret.push_back(entry.m_ref);\n+    }\n+    return ret;\n+}\n+\n+FeeFrac Cluster::GetIndividualFeerate(ClusterIndex idx) noexcept\n+{\n+    return m_depgraph.FeeRate(idx);\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetAncestors(const Ref& arg) noexcept\n+{\n+    // Return the empty vector if the Ref is empty (which may be indicative of the transaction\n+    // having been removed already.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all dependencies, as the result might be incorrect otherwise.\n+    ApplyDependencies();\n+    // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Dispatch to the Cluster.\n+    return cluster->GetAncestorRefs(*this, m_entries[GetRefIndex(arg)].m_locator.index);\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetDescendants(const Ref& arg) noexcept\n+{\n+    // Return the empty vector if the Ref is empty (which may be indicative of the transaction\n+    // having been removed already.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all dependencies, as the result might be incorrect otherwise.\n+    ApplyDependencies();\n+    // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Dispatch to the Cluster.\n+    return cluster->GetDescendantRefs(*this, m_entries[GetRefIndex(arg)].m_locator.index);\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetCluster(const Ref& arg) noexcept\n+{\n+    // Return the empty vector if the Ref is empty (which may be indicative of the transaction\n+    // having been removed already.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all dependencies, as the result might be incorrect otherwise.\n+    ApplyDependencies();\n+    // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Make sure the Cluster has an acceptable quality level, and then dispatch to it.\n+    MakeAcceptable(*cluster);\n+    return cluster->GetClusterRefs(*this);\n+}\n+\n+TxGraph::GraphIndex TxGraphImpl::GetTransactionCount() noexcept\n+{\n+    ApplyRemovals();\n+    return m_txcount;\n+}\n+\n+FeeFrac TxGraphImpl::GetIndividualFeerate(const Ref& arg) noexcept\n+{\n+    // Return the empty FeeFrac if the passed Ref is empty (which may be indicative of the\n+    // transaction having been removed already.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply removals, so that we can correctly report FeeFrac{} for non-existing transaction.\n+    ApplyRemovals();\n+    // Find the cluster the argument is in, and return the empty FeeFrac if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Dispatch to the Cluster.\n+    return cluster->GetIndividualFeerate(m_entries[GetRefIndex(arg)].m_locator.index);\n+}\n+\n+FeeFrac TxGraphImpl::GetChunkFeerate(const Ref& arg) noexcept\n+{\n+    // Return the empty FeeFrac if the passed Ref is empty (which may be indicative of the\n+    // transaction having been removed already.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all dependencies, as the result might be inaccurate otherwise.\n+    ApplyDependencies();\n+    // Find the cluster the argument is in, and return the empty FeeFrac if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Make sure the Cluster has an acceptable quality level, and then return the transaction's\n+    // chunk feerate.\n+    MakeAcceptable(*cluster);\n+    const auto& entry = m_entries[GetRefIndex(arg)];\n+    return entry.m_chunk_feerate;\n+}\n+\n+void Cluster::SetFee(TxGraphImpl& graph, ClusterIndex idx, int64_t fee) noexcept\n+{\n+    // Make sure the specified ClusterIndex exists in this Cluster.\n+    Assume(m_depgraph.Positions()[idx]);\n+    // Bail out if the fee isn't actually being changed.\n+    if (m_depgraph.FeeRate(idx).fee == fee) return;\n+    // Update the fee, remember that relinearization will be necessary, and update the Entries\n+    // in the same Cluster.\n+    m_depgraph.FeeRate(idx).fee = fee;\n+    if (m_quality != QualityLevel::NEEDS_SPLIT) {\n+        graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+    }\n+    Updated(graph);\n+}\n+\n+void TxGraphImpl::SetTransactionFee(Ref& ref, int64_t fee) noexcept\n+{\n+    // Return the empty FeeFrac if the passed Ref is empty (which may be indicative of the\n+    // transaction having been removed already.\n+    if (GetRefGraph(ref) == nullptr) return;\n+    Assume(GetRefGraph(ref) == this);\n+    // Find the entry, its locator, and inform its Cluster about the new feerate, if any.\n+    auto& entry = m_entries[GetRefIndex(ref)];\n+    auto& locator = entry.m_locator;\n+    if (locator.IsPresent()) {\n+        locator.cluster->SetFee(*this, locator.index, fee);\n+    }\n+}\n+\n+} // namespace\n+\n+TxGraph::Ref::~Ref()\n+{\n+    if (m_graph) {\n+        // Inform the TxGraph about the Ref being destroyed.\n+        m_graph->UnlinkRef(m_index);\n+        m_graph = nullptr;\n+    }\n+}\n+\n+TxGraph::Ref& TxGraph::Ref::operator=(Ref&& other) noexcept\n+{\n+    // Inform both TxGraphs about the Refs being swapped.",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 1172,
      "commit_id": "3744b8318d8f465603f0e6f9eb72e679d763c4ca",
      "original_commit_id": "0c8dc2323eb1ec34357a807f0860cf0a08a63a75",
      "in_reply_to_id": 1909293407,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> Why is this doing an effective swap? \r\n\r\nI think this is quite common, that move-construction is effectively performing a swap.\r\n\r\n> I would expect this to call `UnlinkRef` on the moved-from value and reset its `m_graph` and `m_index`\r\n\r\nThat's possible too, and slightly more efficient I guess.\r\n\r\n> Otherwise it wouldn't be unlinked until the moved-from variable goes out of scope, no?\r\n\r\nIndeed. I don't think that's a problem.\r\n\r\n",
      "created_at": "2025-01-09T20:38:36Z",
      "updated_at": "2025-01-09T20:38:36Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r1909403690",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909403690"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1172,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909458303",
      "pull_request_review_id": 2540971508,
      "id": 1909458303,
      "node_id": "PRRC_kwDOABII585x0AV_",
      "diff_hunk": "@@ -0,0 +1,1193 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a ClusterIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<ClusterIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(ClusterIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeeFrac GetIndividualFeerate(ClusterIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, ClusterIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Cleanup).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupData\n+    {\n+        /** Where the clusters to be merged start in m_group_clusters. */\n+        uint32_t m_cluster_offset;\n+        /** How many clusters to merge. */\n+        uint32_t m_cluster_count;\n+        /** Where the dependencies for this cluster group in m_deps_to_add start. */\n+        uint32_t m_deps_offset;\n+        /** How many dependencies to add. */\n+        uint32_t m_deps_count;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Which clusters are to be merged. GroupData::m_cluster_offset indexes into this. */\n+    std::vector<Cluster*> m_group_clusters;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupData>> m_group_data = std::vector<GroupData>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        ClusterIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, ClusterIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref;\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeeFrac m_chunk_feerate;\n+\n+        /** Check whether this Entry is not present in any Cluster. */\n+        bool IsWiped() const noexcept\n+        {\n+            return !m_locator.IsPresent();\n+        }\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries that have no IsPresent locators left, and need to be cleaned up. */\n+    std::vector<GraphIndex> m_wiped;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeeFrac& feerate) noexcept final;\n+    void RemoveTransaction(Ref& arg) noexcept final;\n+    void AddDependency(Ref& parent, Ref& child) noexcept final;\n+    void SetTransactionFee(Ref&, int64_t fee) noexcept final;\n+    std::vector<Ref*> Cleanup() noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeeFrac GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeeFrac GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (ClusterIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        while (true) {\n+            ClusterIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = chunk.feerate;\n+            chunk.transactions.Reset(idx);\n+            if (chunk.transactions.None()) break;\n+        }\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        if (entry.IsWiped()) graph.m_wiped.push_back(idx);\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, ClusterIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transaction go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), ClusterIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // ClusterIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<ClusterIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator.SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Sort the list of dependencies to apply by child, so those can be applied in batch.\n+    std::sort(to_apply.begin(), to_apply.end(), [](auto& a, auto& b) { return a.second < b.second; });\n+    // Iterate over groups of to-be-added dependencies with the same child.\n+    auto it = to_apply.begin();\n+    while (it != to_apply.end()) {\n+        auto& first_child = graph.m_entries[it->second].m_locator;\n+        ClusterIndex child_idx = first_child.index;\n+        // Iterate over all to-be-added dependencies within that same child, gather the relevant\n+        // parents.\n+        SetType parents;\n+        while (it != to_apply.end()) {\n+            auto& child = graph.m_entries[it->second].m_locator;\n+            auto& parent = graph.m_entries[it->first].m_locator;\n+            Assume(child.cluster == this && parent.cluster == this);\n+            if (child.index != child_idx) break;\n+            parents.Set(parent.index);\n+            ++it;\n+        }\n+        // Push all dependencies to the underlying DepGraph. Note that this is O(N) in the size of\n+        // the cluster, regardless of the number of parents being added, so batching them together\n+        // has a performance benefit.\n+        m_depgraph.AddDependencies(parents, child_idx);\n+    }\n+\n+    // Finally fix the linearization, as the new dependencies may have invalidated the\n+    // linearization, and post-linearize it to fix up the worst problems with it.\n+    FixLinearization(m_depgraph, m_linearization);\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Finally push the changes to graph.m_entries.\n+    Updated(graph);\n+}\n+\n+std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept\n+{\n+    Assume(quality != QualityLevel::NONE);\n+\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    Assume(setindex < quality_clusters.size());\n+\n+    // Extract the Cluster-owning unique_ptr.\n+    std::unique_ptr<Cluster> ret = std::move(quality_clusters[setindex]);\n+    ret->m_quality = QualityLevel::NONE;\n+    ret->m_setindex = ClusterSetIndex(-1);\n+\n+    // Clean up space in quality_cluster.\n+    auto max_setindex = quality_clusters.size() - 1;\n+    if (setindex != max_setindex) {\n+        // If the cluster was not the last element of quality_clusters, move that to take its place.\n+        quality_clusters.back()->m_quality = quality;\n+        quality_clusters.back()->m_setindex = setindex;\n+        quality_clusters[setindex] = std::move(quality_clusters.back());\n+    }\n+    // The last element of quality_clusters is now unused; drop it.\n+    quality_clusters.pop_back();\n+\n+    return ret;\n+}\n+\n+ClusterSetIndex TxGraphImpl::InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+{\n+    // Cannot insert with quality level NONE (as that would mean not inserted).\n+    Assume(quality != QualityLevel::NONE);\n+    // The passed-in Cluster must not currently be in the TxGraphImpl.\n+    Assume(cluster->m_quality == QualityLevel::NONE);\n+\n+    // Append it at the end of the relevant TxGraphImpl::m_cluster.\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    ClusterSetIndex ret = quality_clusters.size();\n+    cluster->m_quality = quality;\n+    cluster->m_setindex = ret;\n+    quality_clusters.push_back(std::move(cluster));\n+    return ret;\n+}\n+\n+void TxGraphImpl::SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+{\n+    Assume(new_quality != QualityLevel::NONE);\n+\n+    // Don't do anything if the quality did not change.\n+    if (old_quality == new_quality) return;\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(old_quality, old_index);\n+    // And re-insert it where it belongs.\n+    InsertCluster(std::move(cluster_ptr), new_quality);\n+}\n+\n+void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n+{\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(cluster.m_quality, cluster.m_setindex);\n+    // And throw it away.\n+    cluster_ptr.reset();\n+}\n+\n+void TxGraphImpl::ApplyRemovals() noexcept\n+{\n+    auto& to_remove = m_to_remove;\n+    // Skip if there is nothing to remove.\n+    if (to_remove.empty()) return;\n+    // Wipe cached m_group_data, as it may be invalidated by removals.\n+    m_group_data = std::nullopt;\n+    m_group_clusters.clear();\n+    // Group the set of to-be-removed entries by Cluster*.\n+    std::sort(m_to_remove.begin(), m_to_remove.end(), [&](GraphIndex a, GraphIndex b) noexcept {\n+        return std::less{}(m_entries[a].m_locator.cluster, m_entries[b].m_locator.cluster);\n+    });\n+    // Process per Cluster.\n+    std::span to_remove_span{m_to_remove};\n+    while (!to_remove_span.empty()) {\n+        Cluster* cluster = m_entries[to_remove_span.front()].m_locator.cluster;\n+        if (cluster != nullptr) {\n+            // If the first to_remove_span entry's Cluster exists, hand to_remove_span to it, so it\n+            // can pop off whatever applies to it.\n+            cluster->ApplyRemovals(*this, to_remove_span);\n+        } else {\n+            // Otherwise, skip this already-removed entry.\n+            to_remove_span = to_remove_span.subspan(1);\n+        }\n+    }\n+    m_to_remove.clear();\n+}\n+\n+void TxGraphImpl::SwapIndexes(GraphIndex a, GraphIndex b) noexcept\n+{\n+    Assume(a < m_entries.size());\n+    Assume(b < m_entries.size());\n+    // Swap the Entry objects.\n+    std::swap(m_entries[a], m_entries[b]);\n+    // Iterate over both objects.\n+    for (int i = 0; i < 2; ++i) {\n+        GraphIndex idx = i ? b : a;\n+        Entry& entry = m_entries[idx];\n+        // Update linked Ref.\n+        if (entry.m_ref) GetRefIndex(*entry.m_ref) = idx;\n+        // Update the locator. The rest of the Entry information will not change, so no need to\n+        // invoke Cluster::Updated().\n+        Locator& locator = entry.m_locator;\n+        if (locator.IsPresent()) {\n+            locator.cluster->UpdateMapping(locator.index, idx);\n+        }\n+    }\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::Cleanup() noexcept\n+{\n+    ApplyDependencies();\n+    std::vector<Ref*> ret;\n+    // Sort the GraphIndex that need to be cleaned up. This groups them (so duplicates can be\n+    // processed just once). They are sorted in reverse, so the last ones get processed first.\n+    // This means earlier-processed GraphIndexes will not move of later-processed ones (which\n+    // might invalidate them).\n+    std::sort(m_wiped.begin(), m_wiped.end(), std::greater{});\n+    GraphIndex last(-1);\n+    for (GraphIndex idx : m_wiped) {\n+        // m_wiped should never contain the same GraphIndex twice (the code below would fail\n+        // if so, because GraphIndexes get invalidated by removing them).\n+        Assume(idx != last);\n+        last = idx;\n+        Entry& entry = m_entries[idx];\n+        // Gather Ref pointers that are being unlinked.\n+        if (entry.m_ref != nullptr) {\n+            ret.push_back(entry.m_ref);\n+            GetRefGraph(*entry.m_ref) = nullptr;\n+            m_entries[idx].m_ref = nullptr;\n+        }\n+        // Verify removed entries don't have anything that could hold a reference back.\n+        Assume(!entry.m_locator.IsPresent());\n+        if (idx != m_entries.size() - 1) SwapIndexes(idx, m_entries.size() - 1);\n+        m_entries.pop_back();\n+    }\n+    m_wiped.clear();\n+    return ret;\n+}\n+\n+void TxGraphImpl::Split(Cluster& cluster) noexcept\n+{\n+    // To split a Cluster, first make sure all removals are applied (as we might need to split\n+    // again afterwards otherwise).\n+    ApplyRemovals();\n+    bool del = cluster.Split(*this);\n+    if (del) {\n+        // Cluster::Split reports whether the Cluster is to be deleted.\n+        DeleteCluster(cluster);\n+    }\n+}\n+\n+void TxGraphImpl::SplitAll() noexcept\n+{\n+    // Before splitting all Cluster, first make sure all removals are applied.\n+    ApplyRemovals();\n+    auto& queue = m_clusters[int(QualityLevel::NEEDS_SPLIT)];\n+    while (!queue.empty()) {\n+        Split(*queue.back().get());\n+    }\n+}\n+\n+void TxGraphImpl::GroupClusters() noexcept\n+{\n+    // Before computing which Clusters need to be merged together, first apply all removals and\n+    // split the Clusters into connected components. If we would group first, we might end up\n+    // with inefficient Clusters which just end up being split again anyway.\n+    SplitAll();\n+\n+    // If the groupings have been computed already, nothing is left to be done.\n+    if (m_group_data.has_value()) return;\n+\n+    /** Annotated clusters: an entry for each Cluster, together with the representative for the\n+     *  partition it is in if known, or with nullptr if not yet known. */\n+    std::vector<std::pair<Cluster*, Cluster*>> an_clusters;\n+    /** Annotated dependencies: an entry for each m_deps_to_apply entry (excluding ones that apply\n+     *  to removed transactions), together with the representative root of the partition of\n+     *  Clusters it applies to. */\n+    std::vector<std::pair<std::pair<GraphIndex, GraphIndex>, Cluster*>> an_deps;\n+\n+    // Construct a an_clusters entry for every parent and child in the to-be-applied dependencies.\n+    for (const auto& [par, chl] : m_deps_to_add) {\n+        auto par_cluster = m_entries[par].m_locator.cluster;\n+        auto chl_cluster = m_entries[chl].m_locator.cluster;\n+        // Skip dependencies for which the parent or child transaction is removed.\n+        if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+        an_clusters.emplace_back(par_cluster, nullptr);\n+        // Do not include a duplicate when parent and child are identical, as it'll be removed\n+        // below anyway.\n+        if (chl_cluster != par_cluster) an_clusters.emplace_back(chl_cluster, nullptr);\n+    }\n+    // Sort and deduplicate an_clusters, so we end up with a sorted list of all involved Clusters\n+    // to which dependencies apply.\n+    std::sort(an_clusters.begin(), an_clusters.end());\n+    an_clusters.erase(std::unique(an_clusters.begin(), an_clusters.end()), an_clusters.end());\n+\n+    // Sort the dependencies by child Cluster.\n+    std::sort(m_deps_to_add.begin(), m_deps_to_add.end(), [&](auto& a, auto& b) noexcept {\n+        auto [_a_par, a_chl] = a;\n+        auto [_b_par, b_chl] = b;\n+        auto a_chl_cluster = m_entries[a_chl].m_locator.cluster;\n+        auto b_chl_cluster = m_entries[b_chl].m_locator.cluster;\n+        return std::less{}(a_chl_cluster, b_chl_cluster);\n+    });\n+\n+    // Run the union-find algorithm to to find partitions of the input Clusters which need to be\n+    // grouped together. See https://en.wikipedia.org/wiki/Disjoint-set_data_structure.\n+    {\n+        /** Each PartitionData entry contains information about a single input Cluster. */\n+        struct PartitionData\n+        {\n+            /** The cluster this holds information for. */\n+            Cluster* cluster;\n+            /** All PartitionData entries belonging to the same partition are organized in a tree.\n+             *  Each element points to its parent, or to itself if it is the root. The root is then\n+             *  a representative for the entire tree, and can be found by walking upwards from any\n+             *  element. */\n+            PartitionData* parent;\n+            /** (only if this is a root, so when parent == this) An upper bound on the height of\n+             *  tree for this partition. */\n+            unsigned rank;\n+        };\n+        /** Information about each input Cluster. Sorted by Cluster* pointer. */\n+        std::vector<PartitionData> partition_data;\n+\n+        /** Given a Cluster, find its corresponding PartitionData. */\n+        auto locate_uf = [&](Cluster* arg) noexcept -> PartitionData* {\n+            auto it = std::lower_bound(partition_data.begin(), partition_data.end(), arg,\n+                                       [](auto& a, Cluster* ptr) noexcept { return a.cluster < ptr; });\n+            Assume(it != partition_data.end());\n+            Assume(it->cluster == arg);\n+            return &*it;\n+        };\n+\n+        /** Given a PartitionData, find the root of the tree it is in (its representative). */\n+        static constexpr auto find_uf = [](PartitionData* data) noexcept -> PartitionData* {\n+            while (data->parent != data) {\n+                // Replace pointers to parents with pointers to grandparents.\n+                // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Finding_set_representatives.\n+                auto par = data->parent;\n+                data->parent = par->parent;\n+                data = par;\n+            }\n+            return data;\n+        };\n+\n+        /** Given two PartitionDatas, union the partitions they are in, and return their\n+         *  representative. */\n+        static constexpr auto union_uf = [](PartitionData* arg1, PartitionData* arg2) noexcept {\n+            // Find the roots of the trees, and bail out if they are already equal (which would\n+            // mean they are in the same partition already).\n+            auto rep1 = find_uf(arg1);\n+            auto rep2 = find_uf(arg2);\n+            if (rep1 == rep2) return rep1;\n+            // Pick the lower-rank root to become a child of the higher-rank one.\n+            // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Union_by_rank.\n+            if (rep1->rank < rep2->rank) std::swap(rep1, rep2);\n+            rep2->parent = rep1;\n+            rep1->rank += (rep1->rank == rep2->rank);\n+            return rep1;\n+        };\n+\n+        // Start by initializing every Cluster as its own singleton partition.\n+        partition_data.resize(an_clusters.size());\n+        for (size_t i = 0; i < an_clusters.size(); ++i) {\n+            partition_data[i].cluster = an_clusters[i].first;\n+            partition_data[i].parent = &partition_data[i];\n+            partition_data[i].rank = 0;\n+        }\n+\n+        // Run through all parent/child pairs in m_deps_to_add, and union the\n+        // the partitions their Clusters are in.\n+        Cluster* last_chl_cluster{nullptr};\n+        PartitionData* last_partition{nullptr};\n+        for (const auto& [par, chl] : m_deps_to_add) {\n+            auto par_cluster = m_entries[par].m_locator.cluster;\n+            auto chl_cluster = m_entries[chl].m_locator.cluster;\n+            // Nothing to do if parent and child are in the same Cluster.\n+            if (par_cluster == chl_cluster) continue;\n+            // Nothing to do if either parent or child transaction is removed already.\n+            if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+            Assume(par != chl);\n+            if (chl_cluster == last_chl_cluster) {\n+                // If the child Clusters is the same as the previous iteration, union with the\n+                // tree they were in, avoiding the need for another lookup. Note that m_deps_to_add\n+                // is sorted by child Cluster, so batches with the same child are expected.\n+                last_partition = union_uf(locate_uf(par_cluster), last_partition);\n+            } else {\n+                last_chl_cluster = chl_cluster;\n+                last_partition = union_uf(locate_uf(par_cluster), locate_uf(chl_cluster));\n+            }\n+        }\n+\n+        // Populate the an_clusters and an_deps data structures with the list of input Clusters,\n+        // and the input dependencies, annotated with the representative of the Cluster partition\n+        // it applies to.\n+        an_deps.reserve(m_deps_to_add.size());\n+        auto deps_it = m_deps_to_add.begin();\n+        for (size_t i = 0; i < partition_data.size(); ++i) {\n+            auto& data = partition_data[i];\n+            // Find the representative of the partition Cluster i is in, and store it with the\n+            // Cluster.\n+            auto rep = find_uf(&data)->cluster;\n+            an_clusters[i].second = rep;\n+            // Find all dependencies whose child Cluster is Cluster i, and annotate them with rep.\n+            while (deps_it != m_deps_to_add.end()) {\n+                auto [par, chl] = *deps_it;\n+                auto chl_cluster = m_entries[chl].m_locator.cluster;\n+                // Skip dependencies that apply to earlier Clusters (those necessary are for\n+                // deleted transactions, as otherwise we'd have processed them already).\n+                if (!std::less{}(chl_cluster, data.cluster)) {\n+                    if (chl_cluster != data.cluster) break;\n+                    auto par_cluster = m_entries[par].m_locator.cluster;\n+                    // Also filter out dependencies applying to a removed parent.\n+                    if (par_cluster != nullptr) an_deps.emplace_back(*deps_it, rep);\n+                }\n+                ++deps_it;\n+            }\n+        }\n+    }\n+\n+    // Sort both an_clusters and an_deps by representative of the partition they are in, grouping\n+    // all those applying to the same partition together.\n+    std::sort(an_deps.begin(), an_deps.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+    std::sort(an_clusters.begin(), an_clusters.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+\n+    // Translate the resulting cluster groups to the m_group_data structure.\n+    m_group_data = std::vector<GroupData>{};\n+    m_group_clusters.clear();\n+    m_group_clusters.reserve(an_clusters.size());\n+    m_deps_to_add.clear();\n+    m_deps_to_add.reserve(an_deps.size());\n+    auto an_deps_it = an_deps.begin();\n+    auto an_clusters_it = an_clusters.begin();\n+    while (an_deps_it != an_deps.end()) {\n+        auto rep = an_deps_it->second;\n+        // Create and initialize a new GroupData entry for the partition.\n+        auto& new_entry = m_group_data->emplace_back();\n+        new_entry.m_cluster_offset = m_group_clusters.size();\n+        new_entry.m_cluster_count = 0;\n+        new_entry.m_deps_offset = m_deps_to_add.size();\n+        new_entry.m_deps_count = 0;\n+        // Add all its clusters to it (copying those from an_clusters to m_group_clusters).\n+        while (an_clusters_it != an_clusters.end() && an_clusters_it->second == rep) {\n+            m_group_clusters.push_back(an_clusters_it->first);\n+            ++an_clusters_it;\n+            ++new_entry.m_cluster_count;\n+        }\n+        // Add all its dependencies to it (copying those back from an_deps to m_deps_to_add).\n+        while (an_deps_it != an_deps.end() && an_deps_it->second == rep) {\n+            m_deps_to_add.push_back(an_deps_it->first);\n+            ++an_deps_it;\n+            ++new_entry.m_deps_count;\n+        }\n+    }\n+    Assume(an_deps_it == an_deps.end());\n+    Assume(an_clusters_it == an_clusters.end());\n+}\n+\n+void TxGraphImpl::Merge(std::span<Cluster*> to_merge) noexcept\n+{\n+    Assume(!to_merge.empty());\n+    // Nothing to do if a group consists of just a single Cluster.\n+    if (to_merge.size() == 1) return;\n+\n+    // Move the largest Cluster to the front of to_merge. As all transactions in other to-be-merged\n+    // Clusters will be moved to that one, putting the largest one first minimizes the number of\n+    // moves.\n+    size_t max_size_pos{0};\n+    ClusterIndex max_size = to_merge[max_size_pos]->GetTxCount();\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        ClusterIndex size = to_merge[i]->GetTxCount();\n+        if (size > max_size) {\n+            max_size_pos = i;\n+            max_size = size;\n+        }\n+    }\n+    if (max_size_pos != 0) std::swap(to_merge[0], to_merge[max_size_pos]);\n+\n+    // Merge all further Clusters in the group into the first one, and delete them.\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        to_merge[0]->Merge(*this, *to_merge[i]);\n+        DeleteCluster(*to_merge[i]);\n+    }\n+}\n+\n+void TxGraphImpl::ApplyDependencies() noexcept\n+{\n+    // Compute the groups of to-be-merged Clusters (which also applies all removals, and splits).\n+    GroupClusters();\n+    Assume(m_group_data.has_value());\n+    // Nothing to do if there are no dependencies to be added.\n+    if (m_deps_to_add.empty()) return;\n+\n+    // For each group of to-be-merged Clusters.\n+    Assume(m_group_data.has_value());\n+    for (const auto& group_data : *m_group_data) {\n+        // Invoke Merge() to merge them into a single Cluster.\n+        auto cluster_span = std::span{m_group_clusters}\n+                                .subspan(group_data.m_cluster_offset, group_data.m_cluster_count);\n+        Merge(cluster_span);\n+        // Actually apply all to-be-added dependencies (for each, parent and child belong to the\n+        // same Cluster because of the merging above).\n+        auto deps_span = std::span{m_deps_to_add}\n+                             .subspan(group_data.m_deps_offset, group_data.m_deps_count);\n+        Assume(!deps_span.empty());\n+        const auto& loc = m_entries[deps_span[0].second].m_locator;\n+        Assume(loc.IsPresent());\n+        loc.cluster->ApplyDependencies(*this, deps_span);\n+    }\n+\n+    // Wipe the list of to-be-added dependencies now that they are applied.\n+    m_deps_to_add.clear();\n+    // Also no further Cluster mergings are needed (note that we clear, but don't set to\n+    // std::nullopt, as that would imply the groupings are unknown).\n+    m_group_data->clear();\n+    m_group_clusters.clear();\n+}\n+\n+void Cluster::Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept\n+{\n+    // We can only relinearize Clusters that do not need splitting.\n+    Assume(m_quality == QualityLevel::OPTIMAL || m_quality == QualityLevel::ACCEPTABLE ||\n+           m_quality == QualityLevel::NEEDS_RELINEARIZE);\n+    // No work is required for Clusters which are already optimally linearized.\n+    if (m_quality == QualityLevel::OPTIMAL) return;\n+    // Invoke the actual linearization algorithm (passing in the existing one).\n+    uint64_t rng_seed = graph.m_rng.rand64();\n+    auto [linearization, optimal] = Linearize(m_depgraph, max_iters, rng_seed, m_linearization);\n+    // Postlinearize if the result isn't optimal already. This guarantees (among other things)\n+    // that the chunks of the resulting linearization are all connected.\n+    if (!optimal) PostLinearize(m_depgraph, linearization);\n+    // Update the linearization.\n+    m_linearization = std::move(linearization);\n+    // Update the Cluster's quality.\n+    auto new_quality = optimal ? QualityLevel::OPTIMAL : QualityLevel::ACCEPTABLE;\n+    graph.SetClusterQuality(m_quality, m_setindex, new_quality);\n+    // Update the Entry objects.\n+    Updated(graph);\n+}\n+\n+void TxGraphImpl::MakeAcceptable(Cluster& cluster) noexcept\n+{\n+    // Relinearize the Cluster if needed.\n+    if (cluster.m_quality == QualityLevel::NEEDS_RELINEARIZE) {\n+        cluster.Relinearize(*this, 10000);\n+    }\n+}\n+\n+Cluster::Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept\n+{\n+    // Create a new transaction in the DepGraph, and remember its position in m_mapping.\n+    auto cluster_idx = m_depgraph.AddTransaction(feerate);\n+    m_mapping.push_back(graph_index);\n+    m_linearization.push_back(cluster_idx);\n+}\n+\n+TxGraph::Ref TxGraphImpl::AddTransaction(const FeeFrac& feerate) noexcept\n+{\n+    // Construct a new Ref.\n+    Ref ret;\n+    // Construct a new Entry, and link it with the Ref.\n+    auto idx = m_entries.size();\n+    m_entries.emplace_back();\n+    auto& entry = m_entries.back();\n+    entry.m_ref = &ret;\n+    GetRefGraph(ret) = this;\n+    GetRefIndex(ret) = idx;\n+    // Construct a new singleton Cluster (which is necessarily optimally linearized).\n+    auto cluster = std::make_unique<Cluster>(*this, feerate, idx);\n+    auto cluster_ptr = cluster.get();\n+    InsertCluster(std::move(cluster), QualityLevel::OPTIMAL);\n+    cluster_ptr->Updated(*this);\n+    ++m_txcount;\n+    // Return the Ref.\n+    return ret;\n+}\n+\n+void TxGraphImpl::RemoveTransaction(Ref& arg) noexcept\n+{\n+    // Don't do anything if the Ref is empty (which may be indicative of the transaction already\n+    // having been removed).\n+    if (GetRefGraph(arg) == nullptr) return;\n+    Assume(GetRefGraph(arg) == this);\n+    // Find the Cluster the transaction is in, and stop if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return;\n+    // Remember that the transaction is to be removed.\n+    m_to_remove.push_back(GetRefIndex(arg));\n+}\n+\n+void TxGraphImpl::AddDependency(Ref& parent, Ref& child) noexcept\n+{\n+    // Don't do anything if either Ref is empty (which may be indicative of it having already been\n+    // removed).\n+    if (GetRefGraph(parent) == nullptr || GetRefGraph(child) == nullptr) return;\n+    Assume(GetRefGraph(parent) == this && GetRefGraph(child) == this);\n+    // Find the Cluster the parent and child transaction are in, and stop if either appears to be\n+    // already removed.\n+    auto par_cluster = m_entries[GetRefIndex(parent)].m_locator.cluster;\n+    if (par_cluster == nullptr) return;\n+    auto chl_cluster = m_entries[GetRefIndex(child)].m_locator.cluster;\n+    if (chl_cluster == nullptr) return;\n+    // Wipe m_group_data (as it will need to be recomputed).\n+    m_group_data.reset();\n+    m_group_clusters.clear();\n+    // Remember that this dependency is to be applied.\n+    m_deps_to_add.emplace_back(GetRefIndex(parent), GetRefIndex(child));\n+}\n+\n+bool TxGraphImpl::Exists(const Ref& arg) noexcept\n+{\n+    if (GetRefGraph(arg) == nullptr) return false;\n+    Assume(GetRefGraph(arg) == this);\n+    // Make sure the transaction isn't scheduled for removal.\n+    ApplyRemovals();\n+    return m_entries[GetRefIndex(arg)].m_locator.IsPresent();\n+}\n+\n+std::vector<TxGraph::Ref*> Cluster::GetAncestorRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept\n+{\n+    std::vector<TxGraph::Ref*> ret;\n+    // Translate all ancestors (in arbitrary order) to Refs (if they have any), and return them.\n+    for (auto idx : m_depgraph.Ancestors(idx)) {\n+        const auto& entry = graph.m_entries[m_mapping[idx]];\n+        ret.push_back(entry.m_ref);\n+    }\n+    return ret;\n+}\n+\n+std::vector<TxGraph::Ref*> Cluster::GetDescendantRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept\n+{\n+    std::vector<TxGraph::Ref*> ret;\n+    // Translate all descendants (in arbitrary order) to Refs (if they have any), and return them.\n+    for (auto idx : m_depgraph.Descendants(idx)) {\n+        const auto& entry = graph.m_entries[m_mapping[idx]];\n+        ret.push_back(entry.m_ref);\n+    }\n+    return ret;\n+}\n+\n+std::vector<TxGraph::Ref*> Cluster::GetClusterRefs(const TxGraphImpl& graph) noexcept\n+{\n+    std::vector<TxGraph::Ref*> ret;\n+    // Translate all transactions in the Cluster (in linearization order) to Refs.\n+    for (auto idx : m_linearization) {\n+        const auto& entry = graph.m_entries[m_mapping[idx]];\n+        ret.push_back(entry.m_ref);\n+    }\n+    return ret;\n+}\n+\n+FeeFrac Cluster::GetIndividualFeerate(ClusterIndex idx) noexcept\n+{\n+    return m_depgraph.FeeRate(idx);\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetAncestors(const Ref& arg) noexcept\n+{\n+    // Return the empty vector if the Ref is empty (which may be indicative of the transaction\n+    // having been removed already.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all dependencies, as the result might be incorrect otherwise.\n+    ApplyDependencies();\n+    // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Dispatch to the Cluster.\n+    return cluster->GetAncestorRefs(*this, m_entries[GetRefIndex(arg)].m_locator.index);\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetDescendants(const Ref& arg) noexcept\n+{\n+    // Return the empty vector if the Ref is empty (which may be indicative of the transaction\n+    // having been removed already.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all dependencies, as the result might be incorrect otherwise.\n+    ApplyDependencies();\n+    // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Dispatch to the Cluster.\n+    return cluster->GetDescendantRefs(*this, m_entries[GetRefIndex(arg)].m_locator.index);\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetCluster(const Ref& arg) noexcept\n+{\n+    // Return the empty vector if the Ref is empty (which may be indicative of the transaction\n+    // having been removed already.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all dependencies, as the result might be incorrect otherwise.\n+    ApplyDependencies();\n+    // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Make sure the Cluster has an acceptable quality level, and then dispatch to it.\n+    MakeAcceptable(*cluster);\n+    return cluster->GetClusterRefs(*this);\n+}\n+\n+TxGraph::GraphIndex TxGraphImpl::GetTransactionCount() noexcept\n+{\n+    ApplyRemovals();\n+    return m_txcount;\n+}\n+\n+FeeFrac TxGraphImpl::GetIndividualFeerate(const Ref& arg) noexcept\n+{\n+    // Return the empty FeeFrac if the passed Ref is empty (which may be indicative of the\n+    // transaction having been removed already.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply removals, so that we can correctly report FeeFrac{} for non-existing transaction.\n+    ApplyRemovals();\n+    // Find the cluster the argument is in, and return the empty FeeFrac if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Dispatch to the Cluster.\n+    return cluster->GetIndividualFeerate(m_entries[GetRefIndex(arg)].m_locator.index);\n+}\n+\n+FeeFrac TxGraphImpl::GetChunkFeerate(const Ref& arg) noexcept\n+{\n+    // Return the empty FeeFrac if the passed Ref is empty (which may be indicative of the\n+    // transaction having been removed already.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all dependencies, as the result might be inaccurate otherwise.\n+    ApplyDependencies();\n+    // Find the cluster the argument is in, and return the empty FeeFrac if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Make sure the Cluster has an acceptable quality level, and then return the transaction's\n+    // chunk feerate.\n+    MakeAcceptable(*cluster);\n+    const auto& entry = m_entries[GetRefIndex(arg)];\n+    return entry.m_chunk_feerate;\n+}\n+\n+void Cluster::SetFee(TxGraphImpl& graph, ClusterIndex idx, int64_t fee) noexcept\n+{\n+    // Make sure the specified ClusterIndex exists in this Cluster.\n+    Assume(m_depgraph.Positions()[idx]);\n+    // Bail out if the fee isn't actually being changed.\n+    if (m_depgraph.FeeRate(idx).fee == fee) return;\n+    // Update the fee, remember that relinearization will be necessary, and update the Entries\n+    // in the same Cluster.\n+    m_depgraph.FeeRate(idx).fee = fee;\n+    if (m_quality != QualityLevel::NEEDS_SPLIT) {\n+        graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+    }\n+    Updated(graph);\n+}\n+\n+void TxGraphImpl::SetTransactionFee(Ref& ref, int64_t fee) noexcept\n+{\n+    // Return the empty FeeFrac if the passed Ref is empty (which may be indicative of the\n+    // transaction having been removed already.\n+    if (GetRefGraph(ref) == nullptr) return;\n+    Assume(GetRefGraph(ref) == this);\n+    // Find the entry, its locator, and inform its Cluster about the new feerate, if any.\n+    auto& entry = m_entries[GetRefIndex(ref)];\n+    auto& locator = entry.m_locator;\n+    if (locator.IsPresent()) {\n+        locator.cluster->SetFee(*this, locator.index, fee);\n+    }\n+}\n+\n+} // namespace\n+\n+TxGraph::Ref::~Ref()\n+{\n+    if (m_graph) {\n+        // Inform the TxGraph about the Ref being destroyed.\n+        m_graph->UnlinkRef(m_index);\n+        m_graph = nullptr;\n+    }\n+}\n+\n+TxGraph::Ref& TxGraph::Ref::operator=(Ref&& other) noexcept\n+{\n+    // Inform both TxGraphs about the Refs being swapped.",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 1172,
      "commit_id": "3744b8318d8f465603f0e6f9eb72e679d763c4ca",
      "original_commit_id": "0c8dc2323eb1ec34357a807f0860cf0a08a63a75",
      "in_reply_to_id": 1909293407,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Anyway, done!",
      "created_at": "2025-01-09T21:34:51Z",
      "updated_at": "2025-01-09T21:34:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r1909458303",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909458303"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1172,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909458391",
      "pull_request_review_id": 2540971629,
      "id": 1909458391,
      "node_id": "PRRC_kwDOABII585x0AXX",
      "diff_hunk": "@@ -0,0 +1,1193 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a ClusterIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<ClusterIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(ClusterIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeeFrac GetIndividualFeerate(ClusterIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, ClusterIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Cleanup).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupData\n+    {\n+        /** Where the clusters to be merged start in m_group_clusters. */\n+        uint32_t m_cluster_offset;\n+        /** How many clusters to merge. */\n+        uint32_t m_cluster_count;\n+        /** Where the dependencies for this cluster group in m_deps_to_add start. */\n+        uint32_t m_deps_offset;\n+        /** How many dependencies to add. */\n+        uint32_t m_deps_count;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Which clusters are to be merged. GroupData::m_cluster_offset indexes into this. */\n+    std::vector<Cluster*> m_group_clusters;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupData>> m_group_data = std::vector<GroupData>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        ClusterIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, ClusterIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref;",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 188,
      "commit_id": "3744b8318d8f465603f0e6f9eb72e679d763c4ca",
      "original_commit_id": "0c8dc2323eb1ec34357a807f0860cf0a08a63a75",
      "in_reply_to_id": 1909295799,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-01-09T21:34:56Z",
      "updated_at": "2025-01-09T21:34:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r1909458391",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909458391"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 188,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909462275",
      "pull_request_review_id": 2540977582,
      "id": 1909462275,
      "node_id": "PRRC_kwDOABII585x0BUD",
      "diff_hunk": "@@ -0,0 +1,1193 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a ClusterIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<ClusterIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(ClusterIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeeFrac GetIndividualFeerate(ClusterIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, ClusterIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Cleanup).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupData\n+    {\n+        /** Where the clusters to be merged start in m_group_clusters. */\n+        uint32_t m_cluster_offset;\n+        /** How many clusters to merge. */\n+        uint32_t m_cluster_count;\n+        /** Where the dependencies for this cluster group in m_deps_to_add start. */\n+        uint32_t m_deps_offset;\n+        /** How many dependencies to add. */\n+        uint32_t m_deps_count;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Which clusters are to be merged. GroupData::m_cluster_offset indexes into this. */\n+    std::vector<Cluster*> m_group_clusters;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupData>> m_group_data = std::vector<GroupData>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        ClusterIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, ClusterIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref;\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeeFrac m_chunk_feerate;\n+\n+        /** Check whether this Entry is not present in any Cluster. */\n+        bool IsWiped() const noexcept\n+        {\n+            return !m_locator.IsPresent();\n+        }\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries that have no IsPresent locators left, and need to be cleaned up. */\n+    std::vector<GraphIndex> m_wiped;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeeFrac& feerate) noexcept final;\n+    void RemoveTransaction(Ref& arg) noexcept final;\n+    void AddDependency(Ref& parent, Ref& child) noexcept final;\n+    void SetTransactionFee(Ref&, int64_t fee) noexcept final;\n+    std::vector<Ref*> Cleanup() noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeeFrac GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeeFrac GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (ClusterIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        while (true) {",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 297,
      "commit_id": "3744b8318d8f465603f0e6f9eb72e679d763c4ca",
      "original_commit_id": "0c8dc2323eb1ec34357a807f0860cf0a08a63a75",
      "in_reply_to_id": 1909307659,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "It terminates because:\r\n* Every chunk contains at least one element (added an Assume for that)\r\n* In the inner loop, one element from that chunk is Reset() (added an Assume that it indeed resets a bit that was previously set).\r\n\r\nI've changed it to a `do {} while(chunk.transactions.Any());` loop in the first commits, though it reverts back to a `while (true) { ... }` loop later, when the loop becomes a bit more complex.",
      "created_at": "2025-01-09T21:39:12Z",
      "updated_at": "2025-01-09T21:39:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r1909462275",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909462275"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 297,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909463152",
      "pull_request_review_id": 2540978925,
      "id": 1909463152,
      "node_id": "PRRC_kwDOABII585x0Bhw",
      "diff_hunk": "@@ -0,0 +1,1193 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a ClusterIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<ClusterIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(ClusterIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeeFrac GetIndividualFeerate(ClusterIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, ClusterIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Cleanup).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupData\n+    {\n+        /** Where the clusters to be merged start in m_group_clusters. */\n+        uint32_t m_cluster_offset;\n+        /** How many clusters to merge. */\n+        uint32_t m_cluster_count;\n+        /** Where the dependencies for this cluster group in m_deps_to_add start. */\n+        uint32_t m_deps_offset;\n+        /** How many dependencies to add. */\n+        uint32_t m_deps_count;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Which clusters are to be merged. GroupData::m_cluster_offset indexes into this. */\n+    std::vector<Cluster*> m_group_clusters;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupData>> m_group_data = std::vector<GroupData>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        ClusterIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, ClusterIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref;\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeeFrac m_chunk_feerate;\n+\n+        /** Check whether this Entry is not present in any Cluster. */\n+        bool IsWiped() const noexcept\n+        {\n+            return !m_locator.IsPresent();\n+        }\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries that have no IsPresent locators left, and need to be cleaned up. */\n+    std::vector<GraphIndex> m_wiped;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeeFrac& feerate) noexcept final;\n+    void RemoveTransaction(Ref& arg) noexcept final;\n+    void AddDependency(Ref& parent, Ref& child) noexcept final;\n+    void SetTransactionFee(Ref&, int64_t fee) noexcept final;\n+    std::vector<Ref*> Cleanup() noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeeFrac GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeeFrac GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (ClusterIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        while (true) {\n+            ClusterIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = chunk.feerate;\n+            chunk.transactions.Reset(idx);\n+            if (chunk.transactions.None()) break;\n+        }\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    SetType todo;",
      "path": "src/txgraph.cpp",
      "position": 803,
      "original_position": 311,
      "commit_id": "3744b8318d8f465603f0e6f9eb72e679d763c4ca",
      "original_commit_id": "0c8dc2323eb1ec34357a807f0860cf0a08a63a75",
      "in_reply_to_id": 1909321579,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done. I've also added a comment to the `Cluster::ApplyRemovals()` function definition stating that at least one element from the front of `to_remove` must belong to `this` Cluster (which is really why that requirement exists).",
      "created_at": "2025-01-09T21:40:05Z",
      "updated_at": "2025-01-09T21:40:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r1909463152",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909463152"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 803,
      "original_line": 803,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909463444",
      "pull_request_review_id": 2540979340,
      "id": 1909463444,
      "node_id": "PRRC_kwDOABII585x0BmU",
      "diff_hunk": "@@ -0,0 +1,1193 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a ClusterIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<ClusterIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(ClusterIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeeFrac GetIndividualFeerate(ClusterIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, ClusterIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Cleanup).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupData\n+    {\n+        /** Where the clusters to be merged start in m_group_clusters. */\n+        uint32_t m_cluster_offset;\n+        /** How many clusters to merge. */\n+        uint32_t m_cluster_count;\n+        /** Where the dependencies for this cluster group in m_deps_to_add start. */\n+        uint32_t m_deps_offset;\n+        /** How many dependencies to add. */\n+        uint32_t m_deps_count;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Which clusters are to be merged. GroupData::m_cluster_offset indexes into this. */\n+    std::vector<Cluster*> m_group_clusters;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupData>> m_group_data = std::vector<GroupData>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        ClusterIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, ClusterIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref;\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeeFrac m_chunk_feerate;\n+\n+        /** Check whether this Entry is not present in any Cluster. */\n+        bool IsWiped() const noexcept\n+        {\n+            return !m_locator.IsPresent();\n+        }\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries that have no IsPresent locators left, and need to be cleaned up. */\n+    std::vector<GraphIndex> m_wiped;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeeFrac& feerate) noexcept final;\n+    void RemoveTransaction(Ref& arg) noexcept final;\n+    void AddDependency(Ref& parent, Ref& child) noexcept final;\n+    void SetTransactionFee(Ref&, int64_t fee) noexcept final;\n+    std::vector<Ref*> Cleanup() noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeeFrac GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeeFrac GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (ClusterIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        while (true) {\n+            ClusterIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = chunk.feerate;\n+            chunk.transactions.Reset(idx);\n+            if (chunk.transactions.None()) break;\n+        }\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        if (entry.IsWiped()) graph.m_wiped.push_back(idx);\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, ClusterIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transaction go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), ClusterIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // ClusterIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<ClusterIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator.SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Sort the list of dependencies to apply by child, so those can be applied in batch.\n+    std::sort(to_apply.begin(), to_apply.end(), [](auto& a, auto& b) { return a.second < b.second; });\n+    // Iterate over groups of to-be-added dependencies with the same child.\n+    auto it = to_apply.begin();\n+    while (it != to_apply.end()) {\n+        auto& first_child = graph.m_entries[it->second].m_locator;\n+        ClusterIndex child_idx = first_child.index;\n+        // Iterate over all to-be-added dependencies within that same child, gather the relevant\n+        // parents.\n+        SetType parents;\n+        while (it != to_apply.end()) {\n+            auto& child = graph.m_entries[it->second].m_locator;\n+            auto& parent = graph.m_entries[it->first].m_locator;\n+            Assume(child.cluster == this && parent.cluster == this);\n+            if (child.index != child_idx) break;\n+            parents.Set(parent.index);\n+            ++it;\n+        }\n+        // Push all dependencies to the underlying DepGraph. Note that this is O(N) in the size of\n+        // the cluster, regardless of the number of parents being added, so batching them together\n+        // has a performance benefit.\n+        m_depgraph.AddDependencies(parents, child_idx);\n+    }\n+\n+    // Finally fix the linearization, as the new dependencies may have invalidated the\n+    // linearization, and post-linearize it to fix up the worst problems with it.\n+    FixLinearization(m_depgraph, m_linearization);\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Finally push the changes to graph.m_entries.\n+    Updated(graph);\n+}\n+\n+std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept\n+{\n+    Assume(quality != QualityLevel::NONE);\n+\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    Assume(setindex < quality_clusters.size());\n+\n+    // Extract the Cluster-owning unique_ptr.\n+    std::unique_ptr<Cluster> ret = std::move(quality_clusters[setindex]);\n+    ret->m_quality = QualityLevel::NONE;\n+    ret->m_setindex = ClusterSetIndex(-1);\n+\n+    // Clean up space in quality_cluster.\n+    auto max_setindex = quality_clusters.size() - 1;\n+    if (setindex != max_setindex) {\n+        // If the cluster was not the last element of quality_clusters, move that to take its place.\n+        quality_clusters.back()->m_quality = quality;\n+        quality_clusters.back()->m_setindex = setindex;\n+        quality_clusters[setindex] = std::move(quality_clusters.back());\n+    }\n+    // The last element of quality_clusters is now unused; drop it.\n+    quality_clusters.pop_back();\n+\n+    return ret;\n+}\n+\n+ClusterSetIndex TxGraphImpl::InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+{\n+    // Cannot insert with quality level NONE (as that would mean not inserted).\n+    Assume(quality != QualityLevel::NONE);\n+    // The passed-in Cluster must not currently be in the TxGraphImpl.\n+    Assume(cluster->m_quality == QualityLevel::NONE);\n+\n+    // Append it at the end of the relevant TxGraphImpl::m_cluster.\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    ClusterSetIndex ret = quality_clusters.size();\n+    cluster->m_quality = quality;\n+    cluster->m_setindex = ret;\n+    quality_clusters.push_back(std::move(cluster));\n+    return ret;\n+}\n+\n+void TxGraphImpl::SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+{\n+    Assume(new_quality != QualityLevel::NONE);\n+\n+    // Don't do anything if the quality did not change.\n+    if (old_quality == new_quality) return;\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(old_quality, old_index);\n+    // And re-insert it where it belongs.\n+    InsertCluster(std::move(cluster_ptr), new_quality);\n+}\n+\n+void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n+{\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(cluster.m_quality, cluster.m_setindex);\n+    // And throw it away.\n+    cluster_ptr.reset();\n+}\n+\n+void TxGraphImpl::ApplyRemovals() noexcept\n+{\n+    auto& to_remove = m_to_remove;\n+    // Skip if there is nothing to remove.\n+    if (to_remove.empty()) return;\n+    // Wipe cached m_group_data, as it may be invalidated by removals.\n+    m_group_data = std::nullopt;\n+    m_group_clusters.clear();\n+    // Group the set of to-be-removed entries by Cluster*.\n+    std::sort(m_to_remove.begin(), m_to_remove.end(), [&](GraphIndex a, GraphIndex b) noexcept {\n+        return std::less{}(m_entries[a].m_locator.cluster, m_entries[b].m_locator.cluster);\n+    });\n+    // Process per Cluster.\n+    std::span to_remove_span{m_to_remove};\n+    while (!to_remove_span.empty()) {\n+        Cluster* cluster = m_entries[to_remove_span.front()].m_locator.cluster;\n+        if (cluster != nullptr) {\n+            // If the first to_remove_span entry's Cluster exists, hand to_remove_span to it, so it\n+            // can pop off whatever applies to it.\n+            cluster->ApplyRemovals(*this, to_remove_span);\n+        } else {\n+            // Otherwise, skip this already-removed entry.\n+            to_remove_span = to_remove_span.subspan(1);\n+        }\n+    }\n+    m_to_remove.clear();\n+}\n+\n+void TxGraphImpl::SwapIndexes(GraphIndex a, GraphIndex b) noexcept\n+{\n+    Assume(a < m_entries.size());\n+    Assume(b < m_entries.size());\n+    // Swap the Entry objects.\n+    std::swap(m_entries[a], m_entries[b]);\n+    // Iterate over both objects.\n+    for (int i = 0; i < 2; ++i) {\n+        GraphIndex idx = i ? b : a;\n+        Entry& entry = m_entries[idx];\n+        // Update linked Ref.\n+        if (entry.m_ref) GetRefIndex(*entry.m_ref) = idx;\n+        // Update the locator. The rest of the Entry information will not change, so no need to\n+        // invoke Cluster::Updated().\n+        Locator& locator = entry.m_locator;\n+        if (locator.IsPresent()) {\n+            locator.cluster->UpdateMapping(locator.index, idx);\n+        }\n+    }\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::Cleanup() noexcept\n+{\n+    ApplyDependencies();\n+    std::vector<Ref*> ret;\n+    // Sort the GraphIndex that need to be cleaned up. This groups them (so duplicates can be\n+    // processed just once). They are sorted in reverse, so the last ones get processed first.\n+    // This means earlier-processed GraphIndexes will not move of later-processed ones (which\n+    // might invalidate them).\n+    std::sort(m_wiped.begin(), m_wiped.end(), std::greater{});\n+    GraphIndex last(-1);\n+    for (GraphIndex idx : m_wiped) {\n+        // m_wiped should never contain the same GraphIndex twice (the code below would fail\n+        // if so, because GraphIndexes get invalidated by removing them).\n+        Assume(idx != last);\n+        last = idx;\n+        Entry& entry = m_entries[idx];\n+        // Gather Ref pointers that are being unlinked.\n+        if (entry.m_ref != nullptr) {\n+            ret.push_back(entry.m_ref);\n+            GetRefGraph(*entry.m_ref) = nullptr;\n+            m_entries[idx].m_ref = nullptr;\n+        }\n+        // Verify removed entries don't have anything that could hold a reference back.\n+        Assume(!entry.m_locator.IsPresent());\n+        if (idx != m_entries.size() - 1) SwapIndexes(idx, m_entries.size() - 1);\n+        m_entries.pop_back();\n+    }\n+    m_wiped.clear();\n+    return ret;\n+}\n+\n+void TxGraphImpl::Split(Cluster& cluster) noexcept\n+{\n+    // To split a Cluster, first make sure all removals are applied (as we might need to split\n+    // again afterwards otherwise).\n+    ApplyRemovals();\n+    bool del = cluster.Split(*this);\n+    if (del) {\n+        // Cluster::Split reports whether the Cluster is to be deleted.\n+        DeleteCluster(cluster);\n+    }\n+}\n+\n+void TxGraphImpl::SplitAll() noexcept\n+{\n+    // Before splitting all Cluster, first make sure all removals are applied.\n+    ApplyRemovals();\n+    auto& queue = m_clusters[int(QualityLevel::NEEDS_SPLIT)];\n+    while (!queue.empty()) {\n+        Split(*queue.back().get());\n+    }\n+}\n+\n+void TxGraphImpl::GroupClusters() noexcept\n+{\n+    // Before computing which Clusters need to be merged together, first apply all removals and\n+    // split the Clusters into connected components. If we would group first, we might end up\n+    // with inefficient Clusters which just end up being split again anyway.\n+    SplitAll();\n+\n+    // If the groupings have been computed already, nothing is left to be done.\n+    if (m_group_data.has_value()) return;\n+\n+    /** Annotated clusters: an entry for each Cluster, together with the representative for the\n+     *  partition it is in if known, or with nullptr if not yet known. */\n+    std::vector<std::pair<Cluster*, Cluster*>> an_clusters;\n+    /** Annotated dependencies: an entry for each m_deps_to_apply entry (excluding ones that apply\n+     *  to removed transactions), together with the representative root of the partition of\n+     *  Clusters it applies to. */\n+    std::vector<std::pair<std::pair<GraphIndex, GraphIndex>, Cluster*>> an_deps;\n+\n+    // Construct a an_clusters entry for every parent and child in the to-be-applied dependencies.\n+    for (const auto& [par, chl] : m_deps_to_add) {\n+        auto par_cluster = m_entries[par].m_locator.cluster;\n+        auto chl_cluster = m_entries[chl].m_locator.cluster;\n+        // Skip dependencies for which the parent or child transaction is removed.\n+        if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+        an_clusters.emplace_back(par_cluster, nullptr);\n+        // Do not include a duplicate when parent and child are identical, as it'll be removed\n+        // below anyway.\n+        if (chl_cluster != par_cluster) an_clusters.emplace_back(chl_cluster, nullptr);\n+    }\n+    // Sort and deduplicate an_clusters, so we end up with a sorted list of all involved Clusters\n+    // to which dependencies apply.\n+    std::sort(an_clusters.begin(), an_clusters.end());\n+    an_clusters.erase(std::unique(an_clusters.begin(), an_clusters.end()), an_clusters.end());\n+\n+    // Sort the dependencies by child Cluster.\n+    std::sort(m_deps_to_add.begin(), m_deps_to_add.end(), [&](auto& a, auto& b) noexcept {\n+        auto [_a_par, a_chl] = a;\n+        auto [_b_par, b_chl] = b;\n+        auto a_chl_cluster = m_entries[a_chl].m_locator.cluster;\n+        auto b_chl_cluster = m_entries[b_chl].m_locator.cluster;\n+        return std::less{}(a_chl_cluster, b_chl_cluster);\n+    });\n+\n+    // Run the union-find algorithm to to find partitions of the input Clusters which need to be\n+    // grouped together. See https://en.wikipedia.org/wiki/Disjoint-set_data_structure.\n+    {\n+        /** Each PartitionData entry contains information about a single input Cluster. */\n+        struct PartitionData\n+        {\n+            /** The cluster this holds information for. */\n+            Cluster* cluster;\n+            /** All PartitionData entries belonging to the same partition are organized in a tree.\n+             *  Each element points to its parent, or to itself if it is the root. The root is then\n+             *  a representative for the entire tree, and can be found by walking upwards from any\n+             *  element. */\n+            PartitionData* parent;\n+            /** (only if this is a root, so when parent == this) An upper bound on the height of\n+             *  tree for this partition. */\n+            unsigned rank;\n+        };\n+        /** Information about each input Cluster. Sorted by Cluster* pointer. */\n+        std::vector<PartitionData> partition_data;\n+\n+        /** Given a Cluster, find its corresponding PartitionData. */\n+        auto locate_uf = [&](Cluster* arg) noexcept -> PartitionData* {\n+            auto it = std::lower_bound(partition_data.begin(), partition_data.end(), arg,\n+                                       [](auto& a, Cluster* ptr) noexcept { return a.cluster < ptr; });\n+            Assume(it != partition_data.end());\n+            Assume(it->cluster == arg);\n+            return &*it;\n+        };\n+\n+        /** Given a PartitionData, find the root of the tree it is in (its representative). */\n+        static constexpr auto find_uf = [](PartitionData* data) noexcept -> PartitionData* {\n+            while (data->parent != data) {\n+                // Replace pointers to parents with pointers to grandparents.\n+                // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Finding_set_representatives.\n+                auto par = data->parent;\n+                data->parent = par->parent;\n+                data = par;\n+            }\n+            return data;\n+        };\n+\n+        /** Given two PartitionDatas, union the partitions they are in, and return their\n+         *  representative. */\n+        static constexpr auto union_uf = [](PartitionData* arg1, PartitionData* arg2) noexcept {\n+            // Find the roots of the trees, and bail out if they are already equal (which would\n+            // mean they are in the same partition already).\n+            auto rep1 = find_uf(arg1);\n+            auto rep2 = find_uf(arg2);\n+            if (rep1 == rep2) return rep1;\n+            // Pick the lower-rank root to become a child of the higher-rank one.\n+            // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Union_by_rank.\n+            if (rep1->rank < rep2->rank) std::swap(rep1, rep2);\n+            rep2->parent = rep1;\n+            rep1->rank += (rep1->rank == rep2->rank);\n+            return rep1;\n+        };\n+\n+        // Start by initializing every Cluster as its own singleton partition.\n+        partition_data.resize(an_clusters.size());\n+        for (size_t i = 0; i < an_clusters.size(); ++i) {\n+            partition_data[i].cluster = an_clusters[i].first;\n+            partition_data[i].parent = &partition_data[i];\n+            partition_data[i].rank = 0;\n+        }\n+\n+        // Run through all parent/child pairs in m_deps_to_add, and union the\n+        // the partitions their Clusters are in.\n+        Cluster* last_chl_cluster{nullptr};\n+        PartitionData* last_partition{nullptr};\n+        for (const auto& [par, chl] : m_deps_to_add) {\n+            auto par_cluster = m_entries[par].m_locator.cluster;\n+            auto chl_cluster = m_entries[chl].m_locator.cluster;\n+            // Nothing to do if parent and child are in the same Cluster.\n+            if (par_cluster == chl_cluster) continue;\n+            // Nothing to do if either parent or child transaction is removed already.\n+            if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+            Assume(par != chl);\n+            if (chl_cluster == last_chl_cluster) {\n+                // If the child Clusters is the same as the previous iteration, union with the\n+                // tree they were in, avoiding the need for another lookup. Note that m_deps_to_add\n+                // is sorted by child Cluster, so batches with the same child are expected.\n+                last_partition = union_uf(locate_uf(par_cluster), last_partition);\n+            } else {\n+                last_chl_cluster = chl_cluster;\n+                last_partition = union_uf(locate_uf(par_cluster), locate_uf(chl_cluster));\n+            }\n+        }\n+\n+        // Populate the an_clusters and an_deps data structures with the list of input Clusters,\n+        // and the input dependencies, annotated with the representative of the Cluster partition\n+        // it applies to.\n+        an_deps.reserve(m_deps_to_add.size());\n+        auto deps_it = m_deps_to_add.begin();\n+        for (size_t i = 0; i < partition_data.size(); ++i) {\n+            auto& data = partition_data[i];\n+            // Find the representative of the partition Cluster i is in, and store it with the\n+            // Cluster.\n+            auto rep = find_uf(&data)->cluster;\n+            an_clusters[i].second = rep;\n+            // Find all dependencies whose child Cluster is Cluster i, and annotate them with rep.\n+            while (deps_it != m_deps_to_add.end()) {\n+                auto [par, chl] = *deps_it;\n+                auto chl_cluster = m_entries[chl].m_locator.cluster;\n+                // Skip dependencies that apply to earlier Clusters (those necessary are for\n+                // deleted transactions, as otherwise we'd have processed them already).\n+                if (!std::less{}(chl_cluster, data.cluster)) {\n+                    if (chl_cluster != data.cluster) break;\n+                    auto par_cluster = m_entries[par].m_locator.cluster;\n+                    // Also filter out dependencies applying to a removed parent.\n+                    if (par_cluster != nullptr) an_deps.emplace_back(*deps_it, rep);\n+                }\n+                ++deps_it;\n+            }\n+        }\n+    }\n+\n+    // Sort both an_clusters and an_deps by representative of the partition they are in, grouping\n+    // all those applying to the same partition together.\n+    std::sort(an_deps.begin(), an_deps.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+    std::sort(an_clusters.begin(), an_clusters.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+\n+    // Translate the resulting cluster groups to the m_group_data structure.\n+    m_group_data = std::vector<GroupData>{};\n+    m_group_clusters.clear();\n+    m_group_clusters.reserve(an_clusters.size());\n+    m_deps_to_add.clear();\n+    m_deps_to_add.reserve(an_deps.size());\n+    auto an_deps_it = an_deps.begin();\n+    auto an_clusters_it = an_clusters.begin();\n+    while (an_deps_it != an_deps.end()) {\n+        auto rep = an_deps_it->second;\n+        // Create and initialize a new GroupData entry for the partition.\n+        auto& new_entry = m_group_data->emplace_back();\n+        new_entry.m_cluster_offset = m_group_clusters.size();\n+        new_entry.m_cluster_count = 0;\n+        new_entry.m_deps_offset = m_deps_to_add.size();\n+        new_entry.m_deps_count = 0;\n+        // Add all its clusters to it (copying those from an_clusters to m_group_clusters).\n+        while (an_clusters_it != an_clusters.end() && an_clusters_it->second == rep) {\n+            m_group_clusters.push_back(an_clusters_it->first);\n+            ++an_clusters_it;\n+            ++new_entry.m_cluster_count;\n+        }\n+        // Add all its dependencies to it (copying those back from an_deps to m_deps_to_add).\n+        while (an_deps_it != an_deps.end() && an_deps_it->second == rep) {\n+            m_deps_to_add.push_back(an_deps_it->first);\n+            ++an_deps_it;\n+            ++new_entry.m_deps_count;\n+        }\n+    }\n+    Assume(an_deps_it == an_deps.end());\n+    Assume(an_clusters_it == an_clusters.end());\n+}\n+\n+void TxGraphImpl::Merge(std::span<Cluster*> to_merge) noexcept\n+{\n+    Assume(!to_merge.empty());\n+    // Nothing to do if a group consists of just a single Cluster.\n+    if (to_merge.size() == 1) return;\n+\n+    // Move the largest Cluster to the front of to_merge. As all transactions in other to-be-merged\n+    // Clusters will be moved to that one, putting the largest one first minimizes the number of\n+    // moves.\n+    size_t max_size_pos{0};\n+    ClusterIndex max_size = to_merge[max_size_pos]->GetTxCount();\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        ClusterIndex size = to_merge[i]->GetTxCount();\n+        if (size > max_size) {\n+            max_size_pos = i;\n+            max_size = size;\n+        }\n+    }\n+    if (max_size_pos != 0) std::swap(to_merge[0], to_merge[max_size_pos]);\n+\n+    // Merge all further Clusters in the group into the first one, and delete them.\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        to_merge[0]->Merge(*this, *to_merge[i]);\n+        DeleteCluster(*to_merge[i]);\n+    }\n+}\n+\n+void TxGraphImpl::ApplyDependencies() noexcept\n+{\n+    // Compute the groups of to-be-merged Clusters (which also applies all removals, and splits).\n+    GroupClusters();\n+    Assume(m_group_data.has_value());\n+    // Nothing to do if there are no dependencies to be added.\n+    if (m_deps_to_add.empty()) return;\n+\n+    // For each group of to-be-merged Clusters.\n+    Assume(m_group_data.has_value());\n+    for (const auto& group_data : *m_group_data) {\n+        // Invoke Merge() to merge them into a single Cluster.\n+        auto cluster_span = std::span{m_group_clusters}\n+                                .subspan(group_data.m_cluster_offset, group_data.m_cluster_count);\n+        Merge(cluster_span);\n+        // Actually apply all to-be-added dependencies (for each, parent and child belong to the\n+        // same Cluster because of the merging above).\n+        auto deps_span = std::span{m_deps_to_add}\n+                             .subspan(group_data.m_deps_offset, group_data.m_deps_count);\n+        Assume(!deps_span.empty());\n+        const auto& loc = m_entries[deps_span[0].second].m_locator;\n+        Assume(loc.IsPresent());\n+        loc.cluster->ApplyDependencies(*this, deps_span);\n+    }\n+\n+    // Wipe the list of to-be-added dependencies now that they are applied.\n+    m_deps_to_add.clear();\n+    // Also no further Cluster mergings are needed (note that we clear, but don't set to\n+    // std::nullopt, as that would imply the groupings are unknown).\n+    m_group_data->clear();\n+    m_group_clusters.clear();\n+}\n+\n+void Cluster::Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept\n+{\n+    // We can only relinearize Clusters that do not need splitting.\n+    Assume(m_quality == QualityLevel::OPTIMAL || m_quality == QualityLevel::ACCEPTABLE ||\n+           m_quality == QualityLevel::NEEDS_RELINEARIZE);\n+    // No work is required for Clusters which are already optimally linearized.\n+    if (m_quality == QualityLevel::OPTIMAL) return;\n+    // Invoke the actual linearization algorithm (passing in the existing one).\n+    uint64_t rng_seed = graph.m_rng.rand64();\n+    auto [linearization, optimal] = Linearize(m_depgraph, max_iters, rng_seed, m_linearization);\n+    // Postlinearize if the result isn't optimal already. This guarantees (among other things)\n+    // that the chunks of the resulting linearization are all connected.\n+    if (!optimal) PostLinearize(m_depgraph, linearization);\n+    // Update the linearization.\n+    m_linearization = std::move(linearization);\n+    // Update the Cluster's quality.\n+    auto new_quality = optimal ? QualityLevel::OPTIMAL : QualityLevel::ACCEPTABLE;\n+    graph.SetClusterQuality(m_quality, m_setindex, new_quality);\n+    // Update the Entry objects.\n+    Updated(graph);\n+}\n+\n+void TxGraphImpl::MakeAcceptable(Cluster& cluster) noexcept\n+{\n+    // Relinearize the Cluster if needed.\n+    if (cluster.m_quality == QualityLevel::NEEDS_RELINEARIZE) {\n+        cluster.Relinearize(*this, 10000);\n+    }\n+}\n+\n+Cluster::Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept\n+{\n+    // Create a new transaction in the DepGraph, and remember its position in m_mapping.\n+    auto cluster_idx = m_depgraph.AddTransaction(feerate);\n+    m_mapping.push_back(graph_index);\n+    m_linearization.push_back(cluster_idx);\n+}\n+\n+TxGraph::Ref TxGraphImpl::AddTransaction(const FeeFrac& feerate) noexcept\n+{\n+    // Construct a new Ref.\n+    Ref ret;\n+    // Construct a new Entry, and link it with the Ref.\n+    auto idx = m_entries.size();\n+    m_entries.emplace_back();\n+    auto& entry = m_entries.back();\n+    entry.m_ref = &ret;\n+    GetRefGraph(ret) = this;\n+    GetRefIndex(ret) = idx;\n+    // Construct a new singleton Cluster (which is necessarily optimally linearized).\n+    auto cluster = std::make_unique<Cluster>(*this, feerate, idx);\n+    auto cluster_ptr = cluster.get();\n+    InsertCluster(std::move(cluster), QualityLevel::OPTIMAL);\n+    cluster_ptr->Updated(*this);\n+    ++m_txcount;\n+    // Return the Ref.\n+    return ret;\n+}\n+\n+void TxGraphImpl::RemoveTransaction(Ref& arg) noexcept\n+{\n+    // Don't do anything if the Ref is empty (which may be indicative of the transaction already\n+    // having been removed).\n+    if (GetRefGraph(arg) == nullptr) return;\n+    Assume(GetRefGraph(arg) == this);\n+    // Find the Cluster the transaction is in, and stop if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return;\n+    // Remember that the transaction is to be removed.\n+    m_to_remove.push_back(GetRefIndex(arg));\n+}\n+\n+void TxGraphImpl::AddDependency(Ref& parent, Ref& child) noexcept\n+{\n+    // Don't do anything if either Ref is empty (which may be indicative of it having already been\n+    // removed).\n+    if (GetRefGraph(parent) == nullptr || GetRefGraph(child) == nullptr) return;\n+    Assume(GetRefGraph(parent) == this && GetRefGraph(child) == this);\n+    // Find the Cluster the parent and child transaction are in, and stop if either appears to be\n+    // already removed.\n+    auto par_cluster = m_entries[GetRefIndex(parent)].m_locator.cluster;\n+    if (par_cluster == nullptr) return;\n+    auto chl_cluster = m_entries[GetRefIndex(child)].m_locator.cluster;\n+    if (chl_cluster == nullptr) return;\n+    // Wipe m_group_data (as it will need to be recomputed).\n+    m_group_data.reset();\n+    m_group_clusters.clear();\n+    // Remember that this dependency is to be applied.\n+    m_deps_to_add.emplace_back(GetRefIndex(parent), GetRefIndex(child));\n+}\n+\n+bool TxGraphImpl::Exists(const Ref& arg) noexcept\n+{\n+    if (GetRefGraph(arg) == nullptr) return false;\n+    Assume(GetRefGraph(arg) == this);\n+    // Make sure the transaction isn't scheduled for removal.\n+    ApplyRemovals();\n+    return m_entries[GetRefIndex(arg)].m_locator.IsPresent();\n+}\n+\n+std::vector<TxGraph::Ref*> Cluster::GetAncestorRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 1007,
      "commit_id": "3744b8318d8f465603f0e6f9eb72e679d763c4ca",
      "original_commit_id": "0c8dc2323eb1ec34357a807f0860cf0a08a63a75",
      "in_reply_to_id": 1909348870,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done. The third one disappears in a later commit, though.",
      "created_at": "2025-01-09T21:40:22Z",
      "updated_at": "2025-01-09T21:40:23Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r1909463444",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909463444"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1662,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909477090",
      "pull_request_review_id": 2541000748,
      "id": 1909477090,
      "node_id": "PRRC_kwDOABII585x0E7i",
      "diff_hunk": "@@ -0,0 +1,1193 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a ClusterIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<ClusterIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(ClusterIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeeFrac GetIndividualFeerate(ClusterIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, ClusterIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Cleanup).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupData\n+    {\n+        /** Where the clusters to be merged start in m_group_clusters. */\n+        uint32_t m_cluster_offset;\n+        /** How many clusters to merge. */\n+        uint32_t m_cluster_count;\n+        /** Where the dependencies for this cluster group in m_deps_to_add start. */\n+        uint32_t m_deps_offset;\n+        /** How many dependencies to add. */\n+        uint32_t m_deps_count;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Which clusters are to be merged. GroupData::m_cluster_offset indexes into this. */\n+    std::vector<Cluster*> m_group_clusters;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupData>> m_group_data = std::vector<GroupData>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        ClusterIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, ClusterIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref;\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeeFrac m_chunk_feerate;\n+\n+        /** Check whether this Entry is not present in any Cluster. */\n+        bool IsWiped() const noexcept\n+        {\n+            return !m_locator.IsPresent();\n+        }\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries that have no IsPresent locators left, and need to be cleaned up. */\n+    std::vector<GraphIndex> m_wiped;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeeFrac& feerate) noexcept final;\n+    void RemoveTransaction(Ref& arg) noexcept final;\n+    void AddDependency(Ref& parent, Ref& child) noexcept final;\n+    void SetTransactionFee(Ref&, int64_t fee) noexcept final;\n+    std::vector<Ref*> Cleanup() noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeeFrac GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeeFrac GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (ClusterIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        while (true) {\n+            ClusterIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = chunk.feerate;\n+            chunk.transactions.Reset(idx);\n+            if (chunk.transactions.None()) break;\n+        }\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        if (entry.IsWiped()) graph.m_wiped.push_back(idx);\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, ClusterIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transaction go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), ClusterIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // ClusterIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<ClusterIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator.SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Sort the list of dependencies to apply by child, so those can be applied in batch.\n+    std::sort(to_apply.begin(), to_apply.end(), [](auto& a, auto& b) { return a.second < b.second; });\n+    // Iterate over groups of to-be-added dependencies with the same child.\n+    auto it = to_apply.begin();\n+    while (it != to_apply.end()) {\n+        auto& first_child = graph.m_entries[it->second].m_locator;\n+        ClusterIndex child_idx = first_child.index;\n+        // Iterate over all to-be-added dependencies within that same child, gather the relevant\n+        // parents.\n+        SetType parents;\n+        while (it != to_apply.end()) {\n+            auto& child = graph.m_entries[it->second].m_locator;\n+            auto& parent = graph.m_entries[it->first].m_locator;\n+            Assume(child.cluster == this && parent.cluster == this);\n+            if (child.index != child_idx) break;\n+            parents.Set(parent.index);\n+            ++it;\n+        }\n+        // Push all dependencies to the underlying DepGraph. Note that this is O(N) in the size of\n+        // the cluster, regardless of the number of parents being added, so batching them together\n+        // has a performance benefit.\n+        m_depgraph.AddDependencies(parents, child_idx);\n+    }\n+\n+    // Finally fix the linearization, as the new dependencies may have invalidated the\n+    // linearization, and post-linearize it to fix up the worst problems with it.\n+    FixLinearization(m_depgraph, m_linearization);\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Finally push the changes to graph.m_entries.\n+    Updated(graph);\n+}\n+\n+std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept\n+{\n+    Assume(quality != QualityLevel::NONE);\n+\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    Assume(setindex < quality_clusters.size());\n+\n+    // Extract the Cluster-owning unique_ptr.\n+    std::unique_ptr<Cluster> ret = std::move(quality_clusters[setindex]);\n+    ret->m_quality = QualityLevel::NONE;\n+    ret->m_setindex = ClusterSetIndex(-1);\n+\n+    // Clean up space in quality_cluster.\n+    auto max_setindex = quality_clusters.size() - 1;\n+    if (setindex != max_setindex) {\n+        // If the cluster was not the last element of quality_clusters, move that to take its place.\n+        quality_clusters.back()->m_quality = quality;\n+        quality_clusters.back()->m_setindex = setindex;\n+        quality_clusters[setindex] = std::move(quality_clusters.back());\n+    }\n+    // The last element of quality_clusters is now unused; drop it.\n+    quality_clusters.pop_back();\n+\n+    return ret;\n+}\n+\n+ClusterSetIndex TxGraphImpl::InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+{\n+    // Cannot insert with quality level NONE (as that would mean not inserted).\n+    Assume(quality != QualityLevel::NONE);\n+    // The passed-in Cluster must not currently be in the TxGraphImpl.\n+    Assume(cluster->m_quality == QualityLevel::NONE);\n+\n+    // Append it at the end of the relevant TxGraphImpl::m_cluster.\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    ClusterSetIndex ret = quality_clusters.size();\n+    cluster->m_quality = quality;\n+    cluster->m_setindex = ret;\n+    quality_clusters.push_back(std::move(cluster));\n+    return ret;\n+}\n+\n+void TxGraphImpl::SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+{\n+    Assume(new_quality != QualityLevel::NONE);\n+\n+    // Don't do anything if the quality did not change.\n+    if (old_quality == new_quality) return;\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(old_quality, old_index);\n+    // And re-insert it where it belongs.\n+    InsertCluster(std::move(cluster_ptr), new_quality);\n+}\n+\n+void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n+{\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(cluster.m_quality, cluster.m_setindex);\n+    // And throw it away.\n+    cluster_ptr.reset();\n+}\n+\n+void TxGraphImpl::ApplyRemovals() noexcept\n+{\n+    auto& to_remove = m_to_remove;\n+    // Skip if there is nothing to remove.\n+    if (to_remove.empty()) return;\n+    // Wipe cached m_group_data, as it may be invalidated by removals.\n+    m_group_data = std::nullopt;\n+    m_group_clusters.clear();\n+    // Group the set of to-be-removed entries by Cluster*.\n+    std::sort(m_to_remove.begin(), m_to_remove.end(), [&](GraphIndex a, GraphIndex b) noexcept {\n+        return std::less{}(m_entries[a].m_locator.cluster, m_entries[b].m_locator.cluster);\n+    });\n+    // Process per Cluster.\n+    std::span to_remove_span{m_to_remove};\n+    while (!to_remove_span.empty()) {\n+        Cluster* cluster = m_entries[to_remove_span.front()].m_locator.cluster;\n+        if (cluster != nullptr) {\n+            // If the first to_remove_span entry's Cluster exists, hand to_remove_span to it, so it\n+            // can pop off whatever applies to it.\n+            cluster->ApplyRemovals(*this, to_remove_span);\n+        } else {\n+            // Otherwise, skip this already-removed entry.\n+            to_remove_span = to_remove_span.subspan(1);\n+        }\n+    }\n+    m_to_remove.clear();\n+}\n+\n+void TxGraphImpl::SwapIndexes(GraphIndex a, GraphIndex b) noexcept\n+{\n+    Assume(a < m_entries.size());\n+    Assume(b < m_entries.size());\n+    // Swap the Entry objects.\n+    std::swap(m_entries[a], m_entries[b]);\n+    // Iterate over both objects.\n+    for (int i = 0; i < 2; ++i) {\n+        GraphIndex idx = i ? b : a;\n+        Entry& entry = m_entries[idx];\n+        // Update linked Ref.\n+        if (entry.m_ref) GetRefIndex(*entry.m_ref) = idx;\n+        // Update the locator. The rest of the Entry information will not change, so no need to\n+        // invoke Cluster::Updated().\n+        Locator& locator = entry.m_locator;\n+        if (locator.IsPresent()) {\n+            locator.cluster->UpdateMapping(locator.index, idx);\n+        }\n+    }\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::Cleanup() noexcept\n+{\n+    ApplyDependencies();\n+    std::vector<Ref*> ret;\n+    // Sort the GraphIndex that need to be cleaned up. This groups them (so duplicates can be\n+    // processed just once). They are sorted in reverse, so the last ones get processed first.\n+    // This means earlier-processed GraphIndexes will not move of later-processed ones (which\n+    // might invalidate them).\n+    std::sort(m_wiped.begin(), m_wiped.end(), std::greater{});\n+    GraphIndex last(-1);\n+    for (GraphIndex idx : m_wiped) {\n+        // m_wiped should never contain the same GraphIndex twice (the code below would fail\n+        // if so, because GraphIndexes get invalidated by removing them).\n+        Assume(idx != last);\n+        last = idx;\n+        Entry& entry = m_entries[idx];\n+        // Gather Ref pointers that are being unlinked.\n+        if (entry.m_ref != nullptr) {\n+            ret.push_back(entry.m_ref);\n+            GetRefGraph(*entry.m_ref) = nullptr;\n+            m_entries[idx].m_ref = nullptr;\n+        }\n+        // Verify removed entries don't have anything that could hold a reference back.\n+        Assume(!entry.m_locator.IsPresent());\n+        if (idx != m_entries.size() - 1) SwapIndexes(idx, m_entries.size() - 1);\n+        m_entries.pop_back();\n+    }\n+    m_wiped.clear();\n+    return ret;\n+}\n+\n+void TxGraphImpl::Split(Cluster& cluster) noexcept\n+{\n+    // To split a Cluster, first make sure all removals are applied (as we might need to split\n+    // again afterwards otherwise).\n+    ApplyRemovals();\n+    bool del = cluster.Split(*this);\n+    if (del) {\n+        // Cluster::Split reports whether the Cluster is to be deleted.\n+        DeleteCluster(cluster);\n+    }\n+}\n+\n+void TxGraphImpl::SplitAll() noexcept\n+{\n+    // Before splitting all Cluster, first make sure all removals are applied.\n+    ApplyRemovals();\n+    auto& queue = m_clusters[int(QualityLevel::NEEDS_SPLIT)];\n+    while (!queue.empty()) {\n+        Split(*queue.back().get());\n+    }\n+}\n+\n+void TxGraphImpl::GroupClusters() noexcept\n+{\n+    // Before computing which Clusters need to be merged together, first apply all removals and\n+    // split the Clusters into connected components. If we would group first, we might end up\n+    // with inefficient Clusters which just end up being split again anyway.\n+    SplitAll();\n+\n+    // If the groupings have been computed already, nothing is left to be done.\n+    if (m_group_data.has_value()) return;\n+\n+    /** Annotated clusters: an entry for each Cluster, together with the representative for the\n+     *  partition it is in if known, or with nullptr if not yet known. */\n+    std::vector<std::pair<Cluster*, Cluster*>> an_clusters;\n+    /** Annotated dependencies: an entry for each m_deps_to_apply entry (excluding ones that apply\n+     *  to removed transactions), together with the representative root of the partition of\n+     *  Clusters it applies to. */\n+    std::vector<std::pair<std::pair<GraphIndex, GraphIndex>, Cluster*>> an_deps;\n+\n+    // Construct a an_clusters entry for every parent and child in the to-be-applied dependencies.\n+    for (const auto& [par, chl] : m_deps_to_add) {\n+        auto par_cluster = m_entries[par].m_locator.cluster;\n+        auto chl_cluster = m_entries[chl].m_locator.cluster;\n+        // Skip dependencies for which the parent or child transaction is removed.\n+        if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+        an_clusters.emplace_back(par_cluster, nullptr);\n+        // Do not include a duplicate when parent and child are identical, as it'll be removed\n+        // below anyway.\n+        if (chl_cluster != par_cluster) an_clusters.emplace_back(chl_cluster, nullptr);\n+    }\n+    // Sort and deduplicate an_clusters, so we end up with a sorted list of all involved Clusters\n+    // to which dependencies apply.\n+    std::sort(an_clusters.begin(), an_clusters.end());\n+    an_clusters.erase(std::unique(an_clusters.begin(), an_clusters.end()), an_clusters.end());\n+\n+    // Sort the dependencies by child Cluster.\n+    std::sort(m_deps_to_add.begin(), m_deps_to_add.end(), [&](auto& a, auto& b) noexcept {\n+        auto [_a_par, a_chl] = a;\n+        auto [_b_par, b_chl] = b;\n+        auto a_chl_cluster = m_entries[a_chl].m_locator.cluster;\n+        auto b_chl_cluster = m_entries[b_chl].m_locator.cluster;\n+        return std::less{}(a_chl_cluster, b_chl_cluster);\n+    });\n+\n+    // Run the union-find algorithm to to find partitions of the input Clusters which need to be\n+    // grouped together. See https://en.wikipedia.org/wiki/Disjoint-set_data_structure.\n+    {\n+        /** Each PartitionData entry contains information about a single input Cluster. */\n+        struct PartitionData\n+        {\n+            /** The cluster this holds information for. */\n+            Cluster* cluster;\n+            /** All PartitionData entries belonging to the same partition are organized in a tree.\n+             *  Each element points to its parent, or to itself if it is the root. The root is then\n+             *  a representative for the entire tree, and can be found by walking upwards from any\n+             *  element. */\n+            PartitionData* parent;\n+            /** (only if this is a root, so when parent == this) An upper bound on the height of\n+             *  tree for this partition. */\n+            unsigned rank;\n+        };\n+        /** Information about each input Cluster. Sorted by Cluster* pointer. */\n+        std::vector<PartitionData> partition_data;\n+\n+        /** Given a Cluster, find its corresponding PartitionData. */\n+        auto locate_uf = [&](Cluster* arg) noexcept -> PartitionData* {\n+            auto it = std::lower_bound(partition_data.begin(), partition_data.end(), arg,\n+                                       [](auto& a, Cluster* ptr) noexcept { return a.cluster < ptr; });\n+            Assume(it != partition_data.end());\n+            Assume(it->cluster == arg);\n+            return &*it;\n+        };\n+\n+        /** Given a PartitionData, find the root of the tree it is in (its representative). */\n+        static constexpr auto find_uf = [](PartitionData* data) noexcept -> PartitionData* {\n+            while (data->parent != data) {\n+                // Replace pointers to parents with pointers to grandparents.\n+                // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Finding_set_representatives.\n+                auto par = data->parent;\n+                data->parent = par->parent;\n+                data = par;\n+            }\n+            return data;\n+        };\n+\n+        /** Given two PartitionDatas, union the partitions they are in, and return their\n+         *  representative. */\n+        static constexpr auto union_uf = [](PartitionData* arg1, PartitionData* arg2) noexcept {\n+            // Find the roots of the trees, and bail out if they are already equal (which would\n+            // mean they are in the same partition already).\n+            auto rep1 = find_uf(arg1);\n+            auto rep2 = find_uf(arg2);\n+            if (rep1 == rep2) return rep1;\n+            // Pick the lower-rank root to become a child of the higher-rank one.\n+            // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Union_by_rank.\n+            if (rep1->rank < rep2->rank) std::swap(rep1, rep2);\n+            rep2->parent = rep1;\n+            rep1->rank += (rep1->rank == rep2->rank);\n+            return rep1;\n+        };\n+\n+        // Start by initializing every Cluster as its own singleton partition.\n+        partition_data.resize(an_clusters.size());\n+        for (size_t i = 0; i < an_clusters.size(); ++i) {\n+            partition_data[i].cluster = an_clusters[i].first;\n+            partition_data[i].parent = &partition_data[i];\n+            partition_data[i].rank = 0;\n+        }\n+\n+        // Run through all parent/child pairs in m_deps_to_add, and union the\n+        // the partitions their Clusters are in.\n+        Cluster* last_chl_cluster{nullptr};\n+        PartitionData* last_partition{nullptr};\n+        for (const auto& [par, chl] : m_deps_to_add) {\n+            auto par_cluster = m_entries[par].m_locator.cluster;\n+            auto chl_cluster = m_entries[chl].m_locator.cluster;\n+            // Nothing to do if parent and child are in the same Cluster.\n+            if (par_cluster == chl_cluster) continue;\n+            // Nothing to do if either parent or child transaction is removed already.\n+            if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+            Assume(par != chl);\n+            if (chl_cluster == last_chl_cluster) {\n+                // If the child Clusters is the same as the previous iteration, union with the\n+                // tree they were in, avoiding the need for another lookup. Note that m_deps_to_add\n+                // is sorted by child Cluster, so batches with the same child are expected.\n+                last_partition = union_uf(locate_uf(par_cluster), last_partition);\n+            } else {\n+                last_chl_cluster = chl_cluster;\n+                last_partition = union_uf(locate_uf(par_cluster), locate_uf(chl_cluster));\n+            }\n+        }\n+\n+        // Populate the an_clusters and an_deps data structures with the list of input Clusters,\n+        // and the input dependencies, annotated with the representative of the Cluster partition\n+        // it applies to.\n+        an_deps.reserve(m_deps_to_add.size());\n+        auto deps_it = m_deps_to_add.begin();\n+        for (size_t i = 0; i < partition_data.size(); ++i) {\n+            auto& data = partition_data[i];\n+            // Find the representative of the partition Cluster i is in, and store it with the\n+            // Cluster.\n+            auto rep = find_uf(&data)->cluster;\n+            an_clusters[i].second = rep;\n+            // Find all dependencies whose child Cluster is Cluster i, and annotate them with rep.\n+            while (deps_it != m_deps_to_add.end()) {\n+                auto [par, chl] = *deps_it;\n+                auto chl_cluster = m_entries[chl].m_locator.cluster;\n+                // Skip dependencies that apply to earlier Clusters (those necessary are for\n+                // deleted transactions, as otherwise we'd have processed them already).\n+                if (!std::less{}(chl_cluster, data.cluster)) {\n+                    if (chl_cluster != data.cluster) break;\n+                    auto par_cluster = m_entries[par].m_locator.cluster;\n+                    // Also filter out dependencies applying to a removed parent.\n+                    if (par_cluster != nullptr) an_deps.emplace_back(*deps_it, rep);\n+                }\n+                ++deps_it;\n+            }\n+        }\n+    }\n+\n+    // Sort both an_clusters and an_deps by representative of the partition they are in, grouping\n+    // all those applying to the same partition together.\n+    std::sort(an_deps.begin(), an_deps.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+    std::sort(an_clusters.begin(), an_clusters.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+\n+    // Translate the resulting cluster groups to the m_group_data structure.\n+    m_group_data = std::vector<GroupData>{};\n+    m_group_clusters.clear();\n+    m_group_clusters.reserve(an_clusters.size());\n+    m_deps_to_add.clear();\n+    m_deps_to_add.reserve(an_deps.size());\n+    auto an_deps_it = an_deps.begin();\n+    auto an_clusters_it = an_clusters.begin();\n+    while (an_deps_it != an_deps.end()) {\n+        auto rep = an_deps_it->second;\n+        // Create and initialize a new GroupData entry for the partition.\n+        auto& new_entry = m_group_data->emplace_back();\n+        new_entry.m_cluster_offset = m_group_clusters.size();\n+        new_entry.m_cluster_count = 0;\n+        new_entry.m_deps_offset = m_deps_to_add.size();\n+        new_entry.m_deps_count = 0;\n+        // Add all its clusters to it (copying those from an_clusters to m_group_clusters).\n+        while (an_clusters_it != an_clusters.end() && an_clusters_it->second == rep) {\n+            m_group_clusters.push_back(an_clusters_it->first);\n+            ++an_clusters_it;\n+            ++new_entry.m_cluster_count;\n+        }\n+        // Add all its dependencies to it (copying those back from an_deps to m_deps_to_add).\n+        while (an_deps_it != an_deps.end() && an_deps_it->second == rep) {\n+            m_deps_to_add.push_back(an_deps_it->first);\n+            ++an_deps_it;\n+            ++new_entry.m_deps_count;\n+        }\n+    }\n+    Assume(an_deps_it == an_deps.end());\n+    Assume(an_clusters_it == an_clusters.end());\n+}\n+\n+void TxGraphImpl::Merge(std::span<Cluster*> to_merge) noexcept\n+{\n+    Assume(!to_merge.empty());\n+    // Nothing to do if a group consists of just a single Cluster.\n+    if (to_merge.size() == 1) return;\n+\n+    // Move the largest Cluster to the front of to_merge. As all transactions in other to-be-merged\n+    // Clusters will be moved to that one, putting the largest one first minimizes the number of\n+    // moves.\n+    size_t max_size_pos{0};\n+    ClusterIndex max_size = to_merge[max_size_pos]->GetTxCount();\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        ClusterIndex size = to_merge[i]->GetTxCount();\n+        if (size > max_size) {\n+            max_size_pos = i;\n+            max_size = size;\n+        }\n+    }\n+    if (max_size_pos != 0) std::swap(to_merge[0], to_merge[max_size_pos]);\n+\n+    // Merge all further Clusters in the group into the first one, and delete them.\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        to_merge[0]->Merge(*this, *to_merge[i]);\n+        DeleteCluster(*to_merge[i]);\n+    }\n+}\n+\n+void TxGraphImpl::ApplyDependencies() noexcept\n+{\n+    // Compute the groups of to-be-merged Clusters (which also applies all removals, and splits).\n+    GroupClusters();\n+    Assume(m_group_data.has_value());\n+    // Nothing to do if there are no dependencies to be added.\n+    if (m_deps_to_add.empty()) return;\n+\n+    // For each group of to-be-merged Clusters.\n+    Assume(m_group_data.has_value());\n+    for (const auto& group_data : *m_group_data) {\n+        // Invoke Merge() to merge them into a single Cluster.\n+        auto cluster_span = std::span{m_group_clusters}\n+                                .subspan(group_data.m_cluster_offset, group_data.m_cluster_count);\n+        Merge(cluster_span);\n+        // Actually apply all to-be-added dependencies (for each, parent and child belong to the\n+        // same Cluster because of the merging above).\n+        auto deps_span = std::span{m_deps_to_add}\n+                             .subspan(group_data.m_deps_offset, group_data.m_deps_count);\n+        Assume(!deps_span.empty());\n+        const auto& loc = m_entries[deps_span[0].second].m_locator;\n+        Assume(loc.IsPresent());\n+        loc.cluster->ApplyDependencies(*this, deps_span);\n+    }\n+\n+    // Wipe the list of to-be-added dependencies now that they are applied.\n+    m_deps_to_add.clear();\n+    // Also no further Cluster mergings are needed (note that we clear, but don't set to\n+    // std::nullopt, as that would imply the groupings are unknown).\n+    m_group_data->clear();\n+    m_group_clusters.clear();\n+}\n+\n+void Cluster::Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept\n+{\n+    // We can only relinearize Clusters that do not need splitting.\n+    Assume(m_quality == QualityLevel::OPTIMAL || m_quality == QualityLevel::ACCEPTABLE ||\n+           m_quality == QualityLevel::NEEDS_RELINEARIZE);\n+    // No work is required for Clusters which are already optimally linearized.\n+    if (m_quality == QualityLevel::OPTIMAL) return;\n+    // Invoke the actual linearization algorithm (passing in the existing one).\n+    uint64_t rng_seed = graph.m_rng.rand64();\n+    auto [linearization, optimal] = Linearize(m_depgraph, max_iters, rng_seed, m_linearization);\n+    // Postlinearize if the result isn't optimal already. This guarantees (among other things)\n+    // that the chunks of the resulting linearization are all connected.\n+    if (!optimal) PostLinearize(m_depgraph, linearization);\n+    // Update the linearization.\n+    m_linearization = std::move(linearization);\n+    // Update the Cluster's quality.\n+    auto new_quality = optimal ? QualityLevel::OPTIMAL : QualityLevel::ACCEPTABLE;\n+    graph.SetClusterQuality(m_quality, m_setindex, new_quality);\n+    // Update the Entry objects.\n+    Updated(graph);\n+}\n+\n+void TxGraphImpl::MakeAcceptable(Cluster& cluster) noexcept\n+{\n+    // Relinearize the Cluster if needed.\n+    if (cluster.m_quality == QualityLevel::NEEDS_RELINEARIZE) {\n+        cluster.Relinearize(*this, 10000);\n+    }\n+}\n+\n+Cluster::Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept\n+{\n+    // Create a new transaction in the DepGraph, and remember its position in m_mapping.\n+    auto cluster_idx = m_depgraph.AddTransaction(feerate);\n+    m_mapping.push_back(graph_index);\n+    m_linearization.push_back(cluster_idx);\n+}\n+\n+TxGraph::Ref TxGraphImpl::AddTransaction(const FeeFrac& feerate) noexcept\n+{\n+    // Construct a new Ref.\n+    Ref ret;\n+    // Construct a new Entry, and link it with the Ref.\n+    auto idx = m_entries.size();\n+    m_entries.emplace_back();\n+    auto& entry = m_entries.back();\n+    entry.m_ref = &ret;\n+    GetRefGraph(ret) = this;\n+    GetRefIndex(ret) = idx;\n+    // Construct a new singleton Cluster (which is necessarily optimally linearized).\n+    auto cluster = std::make_unique<Cluster>(*this, feerate, idx);\n+    auto cluster_ptr = cluster.get();\n+    InsertCluster(std::move(cluster), QualityLevel::OPTIMAL);\n+    cluster_ptr->Updated(*this);\n+    ++m_txcount;\n+    // Return the Ref.\n+    return ret;\n+}\n+\n+void TxGraphImpl::RemoveTransaction(Ref& arg) noexcept\n+{\n+    // Don't do anything if the Ref is empty (which may be indicative of the transaction already\n+    // having been removed).\n+    if (GetRefGraph(arg) == nullptr) return;\n+    Assume(GetRefGraph(arg) == this);\n+    // Find the Cluster the transaction is in, and stop if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return;\n+    // Remember that the transaction is to be removed.\n+    m_to_remove.push_back(GetRefIndex(arg));\n+}\n+\n+void TxGraphImpl::AddDependency(Ref& parent, Ref& child) noexcept\n+{\n+    // Don't do anything if either Ref is empty (which may be indicative of it having already been\n+    // removed).\n+    if (GetRefGraph(parent) == nullptr || GetRefGraph(child) == nullptr) return;\n+    Assume(GetRefGraph(parent) == this && GetRefGraph(child) == this);\n+    // Find the Cluster the parent and child transaction are in, and stop if either appears to be\n+    // already removed.\n+    auto par_cluster = m_entries[GetRefIndex(parent)].m_locator.cluster;\n+    if (par_cluster == nullptr) return;\n+    auto chl_cluster = m_entries[GetRefIndex(child)].m_locator.cluster;\n+    if (chl_cluster == nullptr) return;\n+    // Wipe m_group_data (as it will need to be recomputed).\n+    m_group_data.reset();\n+    m_group_clusters.clear();\n+    // Remember that this dependency is to be applied.\n+    m_deps_to_add.emplace_back(GetRefIndex(parent), GetRefIndex(child));\n+}\n+\n+bool TxGraphImpl::Exists(const Ref& arg) noexcept\n+{\n+    if (GetRefGraph(arg) == nullptr) return false;\n+    Assume(GetRefGraph(arg) == this);\n+    // Make sure the transaction isn't scheduled for removal.\n+    ApplyRemovals();\n+    return m_entries[GetRefIndex(arg)].m_locator.IsPresent();\n+}\n+\n+std::vector<TxGraph::Ref*> Cluster::GetAncestorRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept\n+{\n+    std::vector<TxGraph::Ref*> ret;\n+    // Translate all ancestors (in arbitrary order) to Refs (if they have any), and return them.\n+    for (auto idx : m_depgraph.Ancestors(idx)) {\n+        const auto& entry = graph.m_entries[m_mapping[idx]];\n+        ret.push_back(entry.m_ref);\n+    }\n+    return ret;\n+}\n+\n+std::vector<TxGraph::Ref*> Cluster::GetDescendantRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept\n+{\n+    std::vector<TxGraph::Ref*> ret;\n+    // Translate all descendants (in arbitrary order) to Refs (if they have any), and return them.\n+    for (auto idx : m_depgraph.Descendants(idx)) {\n+        const auto& entry = graph.m_entries[m_mapping[idx]];\n+        ret.push_back(entry.m_ref);\n+    }\n+    return ret;\n+}\n+\n+std::vector<TxGraph::Ref*> Cluster::GetClusterRefs(const TxGraphImpl& graph) noexcept\n+{\n+    std::vector<TxGraph::Ref*> ret;\n+    // Translate all transactions in the Cluster (in linearization order) to Refs.\n+    for (auto idx : m_linearization) {\n+        const auto& entry = graph.m_entries[m_mapping[idx]];\n+        ret.push_back(entry.m_ref);\n+    }\n+    return ret;\n+}\n+\n+FeeFrac Cluster::GetIndividualFeerate(ClusterIndex idx) noexcept\n+{\n+    return m_depgraph.FeeRate(idx);\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetAncestors(const Ref& arg) noexcept\n+{\n+    // Return the empty vector if the Ref is empty (which may be indicative of the transaction\n+    // having been removed already.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all dependencies, as the result might be incorrect otherwise.\n+    ApplyDependencies();\n+    // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Dispatch to the Cluster.\n+    return cluster->GetAncestorRefs(*this, m_entries[GetRefIndex(arg)].m_locator.index);\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetDescendants(const Ref& arg) noexcept\n+{\n+    // Return the empty vector if the Ref is empty (which may be indicative of the transaction\n+    // having been removed already.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all dependencies, as the result might be incorrect otherwise.\n+    ApplyDependencies();\n+    // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Dispatch to the Cluster.\n+    return cluster->GetDescendantRefs(*this, m_entries[GetRefIndex(arg)].m_locator.index);\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetCluster(const Ref& arg) noexcept\n+{\n+    // Return the empty vector if the Ref is empty (which may be indicative of the transaction\n+    // having been removed already.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all dependencies, as the result might be incorrect otherwise.\n+    ApplyDependencies();\n+    // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Make sure the Cluster has an acceptable quality level, and then dispatch to it.\n+    MakeAcceptable(*cluster);\n+    return cluster->GetClusterRefs(*this);\n+}\n+\n+TxGraph::GraphIndex TxGraphImpl::GetTransactionCount() noexcept\n+{\n+    ApplyRemovals();\n+    return m_txcount;\n+}\n+\n+FeeFrac TxGraphImpl::GetIndividualFeerate(const Ref& arg) noexcept\n+{\n+    // Return the empty FeeFrac if the passed Ref is empty (which may be indicative of the\n+    // transaction having been removed already.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply removals, so that we can correctly report FeeFrac{} for non-existing transaction.\n+    ApplyRemovals();\n+    // Find the cluster the argument is in, and return the empty FeeFrac if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Dispatch to the Cluster.\n+    return cluster->GetIndividualFeerate(m_entries[GetRefIndex(arg)].m_locator.index);\n+}\n+\n+FeeFrac TxGraphImpl::GetChunkFeerate(const Ref& arg) noexcept\n+{\n+    // Return the empty FeeFrac if the passed Ref is empty (which may be indicative of the\n+    // transaction having been removed already.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all dependencies, as the result might be inaccurate otherwise.\n+    ApplyDependencies();\n+    // Find the cluster the argument is in, and return the empty FeeFrac if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Make sure the Cluster has an acceptable quality level, and then return the transaction's\n+    // chunk feerate.\n+    MakeAcceptable(*cluster);\n+    const auto& entry = m_entries[GetRefIndex(arg)];\n+    return entry.m_chunk_feerate;\n+}\n+\n+void Cluster::SetFee(TxGraphImpl& graph, ClusterIndex idx, int64_t fee) noexcept\n+{\n+    // Make sure the specified ClusterIndex exists in this Cluster.\n+    Assume(m_depgraph.Positions()[idx]);\n+    // Bail out if the fee isn't actually being changed.\n+    if (m_depgraph.FeeRate(idx).fee == fee) return;\n+    // Update the fee, remember that relinearization will be necessary, and update the Entries\n+    // in the same Cluster.\n+    m_depgraph.FeeRate(idx).fee = fee;\n+    if (m_quality != QualityLevel::NEEDS_SPLIT) {\n+        graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+    }\n+    Updated(graph);\n+}\n+\n+void TxGraphImpl::SetTransactionFee(Ref& ref, int64_t fee) noexcept\n+{\n+    // Return the empty FeeFrac if the passed Ref is empty (which may be indicative of the\n+    // transaction having been removed already.\n+    if (GetRefGraph(ref) == nullptr) return;\n+    Assume(GetRefGraph(ref) == this);\n+    // Find the entry, its locator, and inform its Cluster about the new feerate, if any.\n+    auto& entry = m_entries[GetRefIndex(ref)];\n+    auto& locator = entry.m_locator;\n+    if (locator.IsPresent()) {\n+        locator.cluster->SetFee(*this, locator.index, fee);\n+    }\n+}\n+\n+} // namespace\n+\n+TxGraph::Ref::~Ref()\n+{\n+    if (m_graph) {\n+        // Inform the TxGraph about the Ref being destroyed.\n+        m_graph->UnlinkRef(m_index);\n+        m_graph = nullptr;\n+    }\n+}\n+\n+TxGraph::Ref& TxGraph::Ref::operator=(Ref&& other) noexcept\n+{\n+    // Inform both TxGraphs about the Refs being swapped.",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 1172,
      "commit_id": "3744b8318d8f465603f0e6f9eb72e679d763c4ca",
      "original_commit_id": "0c8dc2323eb1ec34357a807f0860cf0a08a63a75",
      "in_reply_to_id": 1909293407,
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> > Why is this doing an effective swap?\r\n> \r\n> I think this is quite common, that move-construction is effectively performing a swap.\r\n> \r\n> > I would expect this to call `UnlinkRef` on the moved-from value and reset its `m_graph` and `m_index`\r\n> \r\n> That's possible too, and slightly more efficient I guess.\r\n> \r\n> > Otherwise it wouldn't be unlinked until the moved-from variable goes out of scope, no?\r\n> \r\n> Indeed. I don't think that's a problem.\r\n\r\nAfaik the move/swap idiom is only safe if the swapped-to value's dtor doesn't have any interesting ordering requirements or side-effects.\r\n\r\nAs a contrived example, a user may do something like:\r\n```c++\r\nstd::vector<TxGraph::Ref> vec;\r\n\r\nvec.push_back(txgraph->AddTransaction(fee));\r\nauto ref = txgraph->AddTransaction(fee2);\r\n...\r\nref = std::move(vec.back());\r\n```\r\nThe vector now holds the old ref and `UnlinkRef` will not be called until that element is removed. I realize it's allowed to be a \"valid but unspecified state\", but I wouldn't expect a ref to be hanging around.",
      "created_at": "2025-01-09T21:56:14Z",
      "updated_at": "2025-01-09T21:56:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r1909477090",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909477090"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1172,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909492867",
      "pull_request_review_id": 2541025670,
      "id": 1909492867,
      "node_id": "PRRC_kwDOABII585x0IyD",
      "diff_hunk": "@@ -0,0 +1,1193 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a ClusterIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<ClusterIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(ClusterIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeeFrac GetIndividualFeerate(ClusterIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, ClusterIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Cleanup).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupData\n+    {\n+        /** Where the clusters to be merged start in m_group_clusters. */\n+        uint32_t m_cluster_offset;\n+        /** How many clusters to merge. */\n+        uint32_t m_cluster_count;\n+        /** Where the dependencies for this cluster group in m_deps_to_add start. */\n+        uint32_t m_deps_offset;\n+        /** How many dependencies to add. */\n+        uint32_t m_deps_count;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Which clusters are to be merged. GroupData::m_cluster_offset indexes into this. */\n+    std::vector<Cluster*> m_group_clusters;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupData>> m_group_data = std::vector<GroupData>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        ClusterIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, ClusterIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref;\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeeFrac m_chunk_feerate;\n+\n+        /** Check whether this Entry is not present in any Cluster. */\n+        bool IsWiped() const noexcept\n+        {\n+            return !m_locator.IsPresent();\n+        }\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries that have no IsPresent locators left, and need to be cleaned up. */\n+    std::vector<GraphIndex> m_wiped;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeeFrac& feerate) noexcept final;\n+    void RemoveTransaction(Ref& arg) noexcept final;\n+    void AddDependency(Ref& parent, Ref& child) noexcept final;\n+    void SetTransactionFee(Ref&, int64_t fee) noexcept final;\n+    std::vector<Ref*> Cleanup() noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeeFrac GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeeFrac GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (ClusterIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        while (true) {\n+            ClusterIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = chunk.feerate;\n+            chunk.transactions.Reset(idx);\n+            if (chunk.transactions.None()) break;\n+        }\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        if (entry.IsWiped()) graph.m_wiped.push_back(idx);\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, ClusterIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transaction go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), ClusterIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // ClusterIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<ClusterIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator.SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Sort the list of dependencies to apply by child, so those can be applied in batch.\n+    std::sort(to_apply.begin(), to_apply.end(), [](auto& a, auto& b) { return a.second < b.second; });\n+    // Iterate over groups of to-be-added dependencies with the same child.\n+    auto it = to_apply.begin();\n+    while (it != to_apply.end()) {\n+        auto& first_child = graph.m_entries[it->second].m_locator;\n+        ClusterIndex child_idx = first_child.index;\n+        // Iterate over all to-be-added dependencies within that same child, gather the relevant\n+        // parents.\n+        SetType parents;\n+        while (it != to_apply.end()) {\n+            auto& child = graph.m_entries[it->second].m_locator;\n+            auto& parent = graph.m_entries[it->first].m_locator;\n+            Assume(child.cluster == this && parent.cluster == this);\n+            if (child.index != child_idx) break;\n+            parents.Set(parent.index);\n+            ++it;\n+        }\n+        // Push all dependencies to the underlying DepGraph. Note that this is O(N) in the size of\n+        // the cluster, regardless of the number of parents being added, so batching them together\n+        // has a performance benefit.\n+        m_depgraph.AddDependencies(parents, child_idx);\n+    }\n+\n+    // Finally fix the linearization, as the new dependencies may have invalidated the\n+    // linearization, and post-linearize it to fix up the worst problems with it.\n+    FixLinearization(m_depgraph, m_linearization);\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Finally push the changes to graph.m_entries.\n+    Updated(graph);\n+}\n+\n+std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept\n+{\n+    Assume(quality != QualityLevel::NONE);\n+\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    Assume(setindex < quality_clusters.size());\n+\n+    // Extract the Cluster-owning unique_ptr.\n+    std::unique_ptr<Cluster> ret = std::move(quality_clusters[setindex]);\n+    ret->m_quality = QualityLevel::NONE;\n+    ret->m_setindex = ClusterSetIndex(-1);\n+\n+    // Clean up space in quality_cluster.\n+    auto max_setindex = quality_clusters.size() - 1;\n+    if (setindex != max_setindex) {\n+        // If the cluster was not the last element of quality_clusters, move that to take its place.\n+        quality_clusters.back()->m_quality = quality;\n+        quality_clusters.back()->m_setindex = setindex;\n+        quality_clusters[setindex] = std::move(quality_clusters.back());\n+    }\n+    // The last element of quality_clusters is now unused; drop it.\n+    quality_clusters.pop_back();\n+\n+    return ret;\n+}\n+\n+ClusterSetIndex TxGraphImpl::InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+{\n+    // Cannot insert with quality level NONE (as that would mean not inserted).\n+    Assume(quality != QualityLevel::NONE);\n+    // The passed-in Cluster must not currently be in the TxGraphImpl.\n+    Assume(cluster->m_quality == QualityLevel::NONE);\n+\n+    // Append it at the end of the relevant TxGraphImpl::m_cluster.\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    ClusterSetIndex ret = quality_clusters.size();\n+    cluster->m_quality = quality;\n+    cluster->m_setindex = ret;\n+    quality_clusters.push_back(std::move(cluster));\n+    return ret;\n+}\n+\n+void TxGraphImpl::SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+{\n+    Assume(new_quality != QualityLevel::NONE);\n+\n+    // Don't do anything if the quality did not change.\n+    if (old_quality == new_quality) return;\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(old_quality, old_index);\n+    // And re-insert it where it belongs.\n+    InsertCluster(std::move(cluster_ptr), new_quality);\n+}\n+\n+void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n+{\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(cluster.m_quality, cluster.m_setindex);\n+    // And throw it away.\n+    cluster_ptr.reset();\n+}\n+\n+void TxGraphImpl::ApplyRemovals() noexcept\n+{\n+    auto& to_remove = m_to_remove;\n+    // Skip if there is nothing to remove.\n+    if (to_remove.empty()) return;\n+    // Wipe cached m_group_data, as it may be invalidated by removals.\n+    m_group_data = std::nullopt;\n+    m_group_clusters.clear();\n+    // Group the set of to-be-removed entries by Cluster*.\n+    std::sort(m_to_remove.begin(), m_to_remove.end(), [&](GraphIndex a, GraphIndex b) noexcept {\n+        return std::less{}(m_entries[a].m_locator.cluster, m_entries[b].m_locator.cluster);\n+    });\n+    // Process per Cluster.\n+    std::span to_remove_span{m_to_remove};\n+    while (!to_remove_span.empty()) {\n+        Cluster* cluster = m_entries[to_remove_span.front()].m_locator.cluster;\n+        if (cluster != nullptr) {\n+            // If the first to_remove_span entry's Cluster exists, hand to_remove_span to it, so it\n+            // can pop off whatever applies to it.\n+            cluster->ApplyRemovals(*this, to_remove_span);\n+        } else {\n+            // Otherwise, skip this already-removed entry.\n+            to_remove_span = to_remove_span.subspan(1);\n+        }\n+    }\n+    m_to_remove.clear();\n+}\n+\n+void TxGraphImpl::SwapIndexes(GraphIndex a, GraphIndex b) noexcept\n+{\n+    Assume(a < m_entries.size());\n+    Assume(b < m_entries.size());\n+    // Swap the Entry objects.\n+    std::swap(m_entries[a], m_entries[b]);\n+    // Iterate over both objects.\n+    for (int i = 0; i < 2; ++i) {\n+        GraphIndex idx = i ? b : a;\n+        Entry& entry = m_entries[idx];\n+        // Update linked Ref.\n+        if (entry.m_ref) GetRefIndex(*entry.m_ref) = idx;\n+        // Update the locator. The rest of the Entry information will not change, so no need to\n+        // invoke Cluster::Updated().\n+        Locator& locator = entry.m_locator;\n+        if (locator.IsPresent()) {\n+            locator.cluster->UpdateMapping(locator.index, idx);\n+        }\n+    }\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::Cleanup() noexcept\n+{\n+    ApplyDependencies();\n+    std::vector<Ref*> ret;\n+    // Sort the GraphIndex that need to be cleaned up. This groups them (so duplicates can be\n+    // processed just once). They are sorted in reverse, so the last ones get processed first.\n+    // This means earlier-processed GraphIndexes will not move of later-processed ones (which\n+    // might invalidate them).\n+    std::sort(m_wiped.begin(), m_wiped.end(), std::greater{});\n+    GraphIndex last(-1);\n+    for (GraphIndex idx : m_wiped) {\n+        // m_wiped should never contain the same GraphIndex twice (the code below would fail\n+        // if so, because GraphIndexes get invalidated by removing them).\n+        Assume(idx != last);\n+        last = idx;\n+        Entry& entry = m_entries[idx];\n+        // Gather Ref pointers that are being unlinked.\n+        if (entry.m_ref != nullptr) {\n+            ret.push_back(entry.m_ref);\n+            GetRefGraph(*entry.m_ref) = nullptr;\n+            m_entries[idx].m_ref = nullptr;\n+        }\n+        // Verify removed entries don't have anything that could hold a reference back.\n+        Assume(!entry.m_locator.IsPresent());\n+        if (idx != m_entries.size() - 1) SwapIndexes(idx, m_entries.size() - 1);\n+        m_entries.pop_back();\n+    }\n+    m_wiped.clear();\n+    return ret;\n+}\n+\n+void TxGraphImpl::Split(Cluster& cluster) noexcept\n+{\n+    // To split a Cluster, first make sure all removals are applied (as we might need to split\n+    // again afterwards otherwise).\n+    ApplyRemovals();\n+    bool del = cluster.Split(*this);\n+    if (del) {\n+        // Cluster::Split reports whether the Cluster is to be deleted.\n+        DeleteCluster(cluster);\n+    }\n+}\n+\n+void TxGraphImpl::SplitAll() noexcept\n+{\n+    // Before splitting all Cluster, first make sure all removals are applied.\n+    ApplyRemovals();\n+    auto& queue = m_clusters[int(QualityLevel::NEEDS_SPLIT)];\n+    while (!queue.empty()) {\n+        Split(*queue.back().get());\n+    }\n+}\n+\n+void TxGraphImpl::GroupClusters() noexcept\n+{\n+    // Before computing which Clusters need to be merged together, first apply all removals and\n+    // split the Clusters into connected components. If we would group first, we might end up\n+    // with inefficient Clusters which just end up being split again anyway.\n+    SplitAll();\n+\n+    // If the groupings have been computed already, nothing is left to be done.\n+    if (m_group_data.has_value()) return;\n+\n+    /** Annotated clusters: an entry for each Cluster, together with the representative for the\n+     *  partition it is in if known, or with nullptr if not yet known. */\n+    std::vector<std::pair<Cluster*, Cluster*>> an_clusters;\n+    /** Annotated dependencies: an entry for each m_deps_to_apply entry (excluding ones that apply\n+     *  to removed transactions), together with the representative root of the partition of\n+     *  Clusters it applies to. */\n+    std::vector<std::pair<std::pair<GraphIndex, GraphIndex>, Cluster*>> an_deps;\n+\n+    // Construct a an_clusters entry for every parent and child in the to-be-applied dependencies.\n+    for (const auto& [par, chl] : m_deps_to_add) {\n+        auto par_cluster = m_entries[par].m_locator.cluster;\n+        auto chl_cluster = m_entries[chl].m_locator.cluster;\n+        // Skip dependencies for which the parent or child transaction is removed.\n+        if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+        an_clusters.emplace_back(par_cluster, nullptr);\n+        // Do not include a duplicate when parent and child are identical, as it'll be removed\n+        // below anyway.\n+        if (chl_cluster != par_cluster) an_clusters.emplace_back(chl_cluster, nullptr);\n+    }\n+    // Sort and deduplicate an_clusters, so we end up with a sorted list of all involved Clusters\n+    // to which dependencies apply.\n+    std::sort(an_clusters.begin(), an_clusters.end());\n+    an_clusters.erase(std::unique(an_clusters.begin(), an_clusters.end()), an_clusters.end());\n+\n+    // Sort the dependencies by child Cluster.\n+    std::sort(m_deps_to_add.begin(), m_deps_to_add.end(), [&](auto& a, auto& b) noexcept {\n+        auto [_a_par, a_chl] = a;\n+        auto [_b_par, b_chl] = b;\n+        auto a_chl_cluster = m_entries[a_chl].m_locator.cluster;\n+        auto b_chl_cluster = m_entries[b_chl].m_locator.cluster;\n+        return std::less{}(a_chl_cluster, b_chl_cluster);\n+    });\n+\n+    // Run the union-find algorithm to to find partitions of the input Clusters which need to be\n+    // grouped together. See https://en.wikipedia.org/wiki/Disjoint-set_data_structure.\n+    {\n+        /** Each PartitionData entry contains information about a single input Cluster. */\n+        struct PartitionData\n+        {\n+            /** The cluster this holds information for. */\n+            Cluster* cluster;\n+            /** All PartitionData entries belonging to the same partition are organized in a tree.\n+             *  Each element points to its parent, or to itself if it is the root. The root is then\n+             *  a representative for the entire tree, and can be found by walking upwards from any\n+             *  element. */\n+            PartitionData* parent;\n+            /** (only if this is a root, so when parent == this) An upper bound on the height of\n+             *  tree for this partition. */\n+            unsigned rank;\n+        };\n+        /** Information about each input Cluster. Sorted by Cluster* pointer. */\n+        std::vector<PartitionData> partition_data;\n+\n+        /** Given a Cluster, find its corresponding PartitionData. */\n+        auto locate_uf = [&](Cluster* arg) noexcept -> PartitionData* {\n+            auto it = std::lower_bound(partition_data.begin(), partition_data.end(), arg,\n+                                       [](auto& a, Cluster* ptr) noexcept { return a.cluster < ptr; });\n+            Assume(it != partition_data.end());\n+            Assume(it->cluster == arg);\n+            return &*it;\n+        };\n+\n+        /** Given a PartitionData, find the root of the tree it is in (its representative). */\n+        static constexpr auto find_uf = [](PartitionData* data) noexcept -> PartitionData* {\n+            while (data->parent != data) {\n+                // Replace pointers to parents with pointers to grandparents.\n+                // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Finding_set_representatives.\n+                auto par = data->parent;\n+                data->parent = par->parent;\n+                data = par;\n+            }\n+            return data;\n+        };\n+\n+        /** Given two PartitionDatas, union the partitions they are in, and return their\n+         *  representative. */\n+        static constexpr auto union_uf = [](PartitionData* arg1, PartitionData* arg2) noexcept {\n+            // Find the roots of the trees, and bail out if they are already equal (which would\n+            // mean they are in the same partition already).\n+            auto rep1 = find_uf(arg1);\n+            auto rep2 = find_uf(arg2);\n+            if (rep1 == rep2) return rep1;\n+            // Pick the lower-rank root to become a child of the higher-rank one.\n+            // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Union_by_rank.\n+            if (rep1->rank < rep2->rank) std::swap(rep1, rep2);\n+            rep2->parent = rep1;\n+            rep1->rank += (rep1->rank == rep2->rank);\n+            return rep1;\n+        };\n+\n+        // Start by initializing every Cluster as its own singleton partition.\n+        partition_data.resize(an_clusters.size());\n+        for (size_t i = 0; i < an_clusters.size(); ++i) {\n+            partition_data[i].cluster = an_clusters[i].first;\n+            partition_data[i].parent = &partition_data[i];\n+            partition_data[i].rank = 0;\n+        }\n+\n+        // Run through all parent/child pairs in m_deps_to_add, and union the\n+        // the partitions their Clusters are in.\n+        Cluster* last_chl_cluster{nullptr};\n+        PartitionData* last_partition{nullptr};\n+        for (const auto& [par, chl] : m_deps_to_add) {\n+            auto par_cluster = m_entries[par].m_locator.cluster;\n+            auto chl_cluster = m_entries[chl].m_locator.cluster;\n+            // Nothing to do if parent and child are in the same Cluster.\n+            if (par_cluster == chl_cluster) continue;\n+            // Nothing to do if either parent or child transaction is removed already.\n+            if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+            Assume(par != chl);\n+            if (chl_cluster == last_chl_cluster) {\n+                // If the child Clusters is the same as the previous iteration, union with the\n+                // tree they were in, avoiding the need for another lookup. Note that m_deps_to_add\n+                // is sorted by child Cluster, so batches with the same child are expected.\n+                last_partition = union_uf(locate_uf(par_cluster), last_partition);\n+            } else {\n+                last_chl_cluster = chl_cluster;\n+                last_partition = union_uf(locate_uf(par_cluster), locate_uf(chl_cluster));\n+            }\n+        }\n+\n+        // Populate the an_clusters and an_deps data structures with the list of input Clusters,\n+        // and the input dependencies, annotated with the representative of the Cluster partition\n+        // it applies to.\n+        an_deps.reserve(m_deps_to_add.size());\n+        auto deps_it = m_deps_to_add.begin();\n+        for (size_t i = 0; i < partition_data.size(); ++i) {\n+            auto& data = partition_data[i];\n+            // Find the representative of the partition Cluster i is in, and store it with the\n+            // Cluster.\n+            auto rep = find_uf(&data)->cluster;\n+            an_clusters[i].second = rep;\n+            // Find all dependencies whose child Cluster is Cluster i, and annotate them with rep.\n+            while (deps_it != m_deps_to_add.end()) {\n+                auto [par, chl] = *deps_it;\n+                auto chl_cluster = m_entries[chl].m_locator.cluster;\n+                // Skip dependencies that apply to earlier Clusters (those necessary are for\n+                // deleted transactions, as otherwise we'd have processed them already).\n+                if (!std::less{}(chl_cluster, data.cluster)) {\n+                    if (chl_cluster != data.cluster) break;\n+                    auto par_cluster = m_entries[par].m_locator.cluster;\n+                    // Also filter out dependencies applying to a removed parent.\n+                    if (par_cluster != nullptr) an_deps.emplace_back(*deps_it, rep);\n+                }\n+                ++deps_it;\n+            }\n+        }\n+    }\n+\n+    // Sort both an_clusters and an_deps by representative of the partition they are in, grouping\n+    // all those applying to the same partition together.\n+    std::sort(an_deps.begin(), an_deps.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+    std::sort(an_clusters.begin(), an_clusters.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+\n+    // Translate the resulting cluster groups to the m_group_data structure.\n+    m_group_data = std::vector<GroupData>{};\n+    m_group_clusters.clear();\n+    m_group_clusters.reserve(an_clusters.size());\n+    m_deps_to_add.clear();\n+    m_deps_to_add.reserve(an_deps.size());\n+    auto an_deps_it = an_deps.begin();\n+    auto an_clusters_it = an_clusters.begin();\n+    while (an_deps_it != an_deps.end()) {\n+        auto rep = an_deps_it->second;\n+        // Create and initialize a new GroupData entry for the partition.\n+        auto& new_entry = m_group_data->emplace_back();\n+        new_entry.m_cluster_offset = m_group_clusters.size();\n+        new_entry.m_cluster_count = 0;\n+        new_entry.m_deps_offset = m_deps_to_add.size();\n+        new_entry.m_deps_count = 0;\n+        // Add all its clusters to it (copying those from an_clusters to m_group_clusters).\n+        while (an_clusters_it != an_clusters.end() && an_clusters_it->second == rep) {\n+            m_group_clusters.push_back(an_clusters_it->first);\n+            ++an_clusters_it;\n+            ++new_entry.m_cluster_count;\n+        }\n+        // Add all its dependencies to it (copying those back from an_deps to m_deps_to_add).\n+        while (an_deps_it != an_deps.end() && an_deps_it->second == rep) {\n+            m_deps_to_add.push_back(an_deps_it->first);\n+            ++an_deps_it;\n+            ++new_entry.m_deps_count;\n+        }\n+    }\n+    Assume(an_deps_it == an_deps.end());\n+    Assume(an_clusters_it == an_clusters.end());\n+}\n+\n+void TxGraphImpl::Merge(std::span<Cluster*> to_merge) noexcept\n+{\n+    Assume(!to_merge.empty());\n+    // Nothing to do if a group consists of just a single Cluster.\n+    if (to_merge.size() == 1) return;\n+\n+    // Move the largest Cluster to the front of to_merge. As all transactions in other to-be-merged\n+    // Clusters will be moved to that one, putting the largest one first minimizes the number of\n+    // moves.\n+    size_t max_size_pos{0};\n+    ClusterIndex max_size = to_merge[max_size_pos]->GetTxCount();\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        ClusterIndex size = to_merge[i]->GetTxCount();\n+        if (size > max_size) {\n+            max_size_pos = i;\n+            max_size = size;\n+        }\n+    }\n+    if (max_size_pos != 0) std::swap(to_merge[0], to_merge[max_size_pos]);\n+\n+    // Merge all further Clusters in the group into the first one, and delete them.\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        to_merge[0]->Merge(*this, *to_merge[i]);\n+        DeleteCluster(*to_merge[i]);\n+    }\n+}\n+\n+void TxGraphImpl::ApplyDependencies() noexcept\n+{\n+    // Compute the groups of to-be-merged Clusters (which also applies all removals, and splits).\n+    GroupClusters();\n+    Assume(m_group_data.has_value());\n+    // Nothing to do if there are no dependencies to be added.\n+    if (m_deps_to_add.empty()) return;\n+\n+    // For each group of to-be-merged Clusters.\n+    Assume(m_group_data.has_value());\n+    for (const auto& group_data : *m_group_data) {\n+        // Invoke Merge() to merge them into a single Cluster.\n+        auto cluster_span = std::span{m_group_clusters}\n+                                .subspan(group_data.m_cluster_offset, group_data.m_cluster_count);\n+        Merge(cluster_span);\n+        // Actually apply all to-be-added dependencies (for each, parent and child belong to the\n+        // same Cluster because of the merging above).\n+        auto deps_span = std::span{m_deps_to_add}\n+                             .subspan(group_data.m_deps_offset, group_data.m_deps_count);\n+        Assume(!deps_span.empty());\n+        const auto& loc = m_entries[deps_span[0].second].m_locator;\n+        Assume(loc.IsPresent());\n+        loc.cluster->ApplyDependencies(*this, deps_span);\n+    }\n+\n+    // Wipe the list of to-be-added dependencies now that they are applied.\n+    m_deps_to_add.clear();\n+    // Also no further Cluster mergings are needed (note that we clear, but don't set to\n+    // std::nullopt, as that would imply the groupings are unknown).\n+    m_group_data->clear();\n+    m_group_clusters.clear();\n+}\n+\n+void Cluster::Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept\n+{\n+    // We can only relinearize Clusters that do not need splitting.\n+    Assume(m_quality == QualityLevel::OPTIMAL || m_quality == QualityLevel::ACCEPTABLE ||\n+           m_quality == QualityLevel::NEEDS_RELINEARIZE);\n+    // No work is required for Clusters which are already optimally linearized.\n+    if (m_quality == QualityLevel::OPTIMAL) return;\n+    // Invoke the actual linearization algorithm (passing in the existing one).\n+    uint64_t rng_seed = graph.m_rng.rand64();\n+    auto [linearization, optimal] = Linearize(m_depgraph, max_iters, rng_seed, m_linearization);\n+    // Postlinearize if the result isn't optimal already. This guarantees (among other things)\n+    // that the chunks of the resulting linearization are all connected.\n+    if (!optimal) PostLinearize(m_depgraph, linearization);\n+    // Update the linearization.\n+    m_linearization = std::move(linearization);\n+    // Update the Cluster's quality.\n+    auto new_quality = optimal ? QualityLevel::OPTIMAL : QualityLevel::ACCEPTABLE;\n+    graph.SetClusterQuality(m_quality, m_setindex, new_quality);\n+    // Update the Entry objects.\n+    Updated(graph);\n+}\n+\n+void TxGraphImpl::MakeAcceptable(Cluster& cluster) noexcept\n+{\n+    // Relinearize the Cluster if needed.\n+    if (cluster.m_quality == QualityLevel::NEEDS_RELINEARIZE) {\n+        cluster.Relinearize(*this, 10000);\n+    }\n+}\n+\n+Cluster::Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept\n+{\n+    // Create a new transaction in the DepGraph, and remember its position in m_mapping.\n+    auto cluster_idx = m_depgraph.AddTransaction(feerate);\n+    m_mapping.push_back(graph_index);\n+    m_linearization.push_back(cluster_idx);\n+}\n+\n+TxGraph::Ref TxGraphImpl::AddTransaction(const FeeFrac& feerate) noexcept\n+{\n+    // Construct a new Ref.\n+    Ref ret;\n+    // Construct a new Entry, and link it with the Ref.\n+    auto idx = m_entries.size();\n+    m_entries.emplace_back();\n+    auto& entry = m_entries.back();\n+    entry.m_ref = &ret;",
      "path": "src/txgraph.cpp",
      "position": 1689,
      "original_position": 953,
      "commit_id": "3744b8318d8f465603f0e6f9eb72e679d763c4ca",
      "original_commit_id": "0c8dc2323eb1ec34357a807f0860cf0a08a63a75",
      "in_reply_to_id": 1909286865,
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Ah, right, I missed that the move ctor would handle the update. Thanks for explaining.",
      "created_at": "2025-01-09T22:15:14Z",
      "updated_at": "2025-01-09T22:15:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r1909492867",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909492867"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1689,
      "original_line": 1689,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1928741430",
      "pull_request_review_id": 2572752495,
      "id": 1928741430,
      "node_id": "PRRC_kwDOABII585y9kI2",
      "diff_hunk": "@@ -1449,6 +1465,7 @@ Cluster::Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_in\n TxGraph::Ref TxGraphImpl::AddTransaction(const FeeFrac& feerate) noexcept\n {\n     Assume(m_chunkindex_observers == 0 || m_clustersets.size() > 1);\n+    Assume(feerate.size > 0 && uint64_t(feerate.size) <= m_max_cluster_size);",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 73,
      "commit_id": "3744b8318d8f465603f0e6f9eb72e679d763c4ca",
      "original_commit_id": "6cb99b067cf9028777a2036a8a3240c2511a3caf",
      "in_reply_to_id": null,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "FYI -- in my rebase of #28676, I'm seeing `tx_pool` fuzz test failures due to this line. Not clear to me whether we should require the caller to enforce the policy requirement that a single tx be below the cluster size limit, or just let the caller discover a changeset is oversized and then reject?",
      "created_at": "2025-01-24T14:10:51Z",
      "updated_at": "2025-01-24T14:10:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r1928741430",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1928741430"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1548,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1928775309",
      "pull_request_review_id": 2572810863,
      "id": 1928775309,
      "node_id": "PRRC_kwDOABII585y9saN",
      "diff_hunk": "@@ -1449,6 +1465,7 @@ Cluster::Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_in\n TxGraph::Ref TxGraphImpl::AddTransaction(const FeeFrac& feerate) noexcept\n {\n     Assume(m_chunkindex_observers == 0 || m_clustersets.size() > 1);\n+    Assume(feerate.size > 0 && uint64_t(feerate.size) <= m_max_cluster_size);",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 73,
      "commit_id": "3744b8318d8f465603f0e6f9eb72e679d763c4ca",
      "original_commit_id": "6cb99b067cf9028777a2036a8a3240c2511a3caf",
      "in_reply_to_id": 1928741430,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Right. That rule exists because the alternative requires existing clusters to be oversized as AddTransaction constructs a singleton cluster instantly. All other forms of oversizedness happen as a result of applying dependencies, which are done lazily.\r\n\r\nI'll think about relaxing this.",
      "created_at": "2025-01-24T14:34:05Z",
      "updated_at": "2025-01-24T14:34:06Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r1928775309",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1928775309"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1548,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1929869292",
      "pull_request_review_id": 2574392651,
      "id": 1929869292,
      "node_id": "PRRC_kwDOABII585zB3fs",
      "diff_hunk": "@@ -1449,6 +1465,7 @@ Cluster::Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_in\n TxGraph::Ref TxGraphImpl::AddTransaction(const FeeFrac& feerate) noexcept\n {\n     Assume(m_chunkindex_observers == 0 || m_clustersets.size() > 1);\n+    Assume(feerate.size > 0 && uint64_t(feerate.size) <= m_max_cluster_size);",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 73,
      "commit_id": "3744b8318d8f465603f0e6f9eb72e679d763c4ca",
      "original_commit_id": "6cb99b067cf9028777a2036a8a3240c2511a3caf",
      "in_reply_to_id": 1928741430,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done, it is now allowed to have individually oversized transactions.",
      "created_at": "2025-01-26T20:45:43Z",
      "updated_at": "2025-01-26T20:45:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r1929869292",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1929869292"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1548,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1968497012",
      "pull_request_review_id": 2638575710,
      "id": 1968497012,
      "node_id": "PRRC_kwDOABII5851VOF0",
      "diff_hunk": "@@ -1336,6 +1347,38 @@ std::vector<ClusterIndex> MergeLinearizations(const DepGraph<SetType>& depgraph,\n     return ret;\n }\n \n+/** Make linearization topological, retaining its ordering where possible. */\n+template<typename SetType>\n+void FixLinearization(const DepGraph<SetType>& depgraph, Span<DepGraphIndex> linearization) noexcept\n+{\n+    // This algorithm can be summarized as moving every element in the linearization backwards\n+    // until it is placed after all its ancestors.\n+    SetType done;\n+    const auto len = linearization.size();\n+    // Iterate over the elements of linearization from back to front (i is distance from back).\n+    for (DepGraphIndex i = 0; i < len; ++i) {\n+        /** The element at that position. */\n+        DepGraphIndex elem = linearization[len - 1 - i];\n+        /** j represents how far from the back of the linearization elem should be placed. */\n+        DepGraphIndex j = i;\n+        // Figure out which elements need to be moved before elem.\n+        SetType place_before = done & depgraph.Ancestors(elem);\n+        // Find which position to place elem in (updating j), continuously moving the elements\n+        // in between forward.\n+        while (place_before.Any()) {\n+            // j cannot be 0 here; if it was, then there was necessarily nothing earlier which",
      "path": "src/cluster_linearize.h",
      "position": 469,
      "original_position": 469,
      "commit_id": "3744b8318d8f465603f0e6f9eb72e679d763c4ca",
      "original_commit_id": "e43f6ca3b80cff2e05f88223ee9de3e2fe014243",
      "in_reply_to_id": null,
      "user": {
        "login": "yancyribbens",
        "id": 817736,
        "node_id": "MDQ6VXNlcjgxNzczNg==",
        "avatar_url": "https://avatars.githubusercontent.com/u/817736?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yancyribbens",
        "html_url": "https://github.com/yancyribbens",
        "followers_url": "https://api.github.com/users/yancyribbens/followers",
        "following_url": "https://api.github.com/users/yancyribbens/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/yancyribbens/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/yancyribbens/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/yancyribbens/subscriptions",
        "organizations_url": "https://api.github.com/users/yancyribbens/orgs",
        "repos_url": "https://api.github.com/users/yancyribbens/repos",
        "events_url": "https://api.github.com/users/yancyribbens/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/yancyribbens/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n            // j cannot be 0 or less; if it was, then there was necessarily nothing earlier which\r\n```",
      "created_at": "2025-02-24T22:20:13Z",
      "updated_at": "2025-02-24T22:20:13Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r1968497012",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1968497012"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1369,
      "original_line": 1369,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1968500577",
      "pull_request_review_id": 2638581738,
      "id": 1968500577,
      "node_id": "PRRC_kwDOABII5851VO9h",
      "diff_hunk": "@@ -1336,6 +1347,38 @@ std::vector<ClusterIndex> MergeLinearizations(const DepGraph<SetType>& depgraph,\n     return ret;\n }\n \n+/** Make linearization topological, retaining its ordering where possible. */\n+template<typename SetType>\n+void FixLinearization(const DepGraph<SetType>& depgraph, Span<DepGraphIndex> linearization) noexcept\n+{\n+    // This algorithm can be summarized as moving every element in the linearization backwards\n+    // until it is placed after all its ancestors.\n+    SetType done;\n+    const auto len = linearization.size();\n+    // Iterate over the elements of linearization from back to front (i is distance from back).\n+    for (DepGraphIndex i = 0; i < len; ++i) {\n+        /** The element at that position. */\n+        DepGraphIndex elem = linearization[len - 1 - i];\n+        /** j represents how far from the back of the linearization elem should be placed. */\n+        DepGraphIndex j = i;\n+        // Figure out which elements need to be moved before elem.\n+        SetType place_before = done & depgraph.Ancestors(elem);\n+        // Find which position to place elem in (updating j), continuously moving the elements\n+        // in between forward.\n+        while (place_before.Any()) {\n+            // j cannot be 0 here; if it was, then there was necessarily nothing earlier which",
      "path": "src/cluster_linearize.h",
      "position": 469,
      "original_position": 469,
      "commit_id": "3744b8318d8f465603f0e6f9eb72e679d763c4ca",
      "original_commit_id": "e43f6ca3b80cff2e05f88223ee9de3e2fe014243",
      "in_reply_to_id": 1968497012,
      "user": {
        "login": "yancyribbens",
        "id": 817736,
        "node_id": "MDQ6VXNlcjgxNzczNg==",
        "avatar_url": "https://avatars.githubusercontent.com/u/817736?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yancyribbens",
        "html_url": "https://github.com/yancyribbens",
        "followers_url": "https://api.github.com/users/yancyribbens/followers",
        "following_url": "https://api.github.com/users/yancyribbens/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/yancyribbens/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/yancyribbens/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/yancyribbens/subscriptions",
        "organizations_url": "https://api.github.com/users/yancyribbens/orgs",
        "repos_url": "https://api.github.com/users/yancyribbens/repos",
        "events_url": "https://api.github.com/users/yancyribbens/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/yancyribbens/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```\r\nif it was, then there was necessarily nothing earlier which elem needs to be place before anymore, and place_before would be empty.\r\n```\r\nThis comment seems jumbled and hard to understand.  Is it possible to word this better?",
      "created_at": "2025-02-24T22:23:55Z",
      "updated_at": "2025-02-24T22:23:55Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r1968500577",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1968500577"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1369,
      "original_line": 1369,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1968529011",
      "pull_request_review_id": 2638627438,
      "id": 1968529011,
      "node_id": "PRRC_kwDOABII5851VV5z",
      "diff_hunk": "@@ -0,0 +1,2801 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+#include <util/vector.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <set>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+/** The maximum number of levels a TxGraph can have (0 = main, 1 = staging). */\n+static constexpr int MAX_LEVELS{2};\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::ClusterSet::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This is a singleton cluster consisting of a transaction that individually exceeds the\n+     *  cluster size limit. It cannot be merged with anything. */\n+    OVERSIZED,\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster may have multiple disconnected components, which are all ACCEPTABLE. */\n+    NEEDS_SPLIT_ACCEPTABLE,\n+    /** This cluster may have multiple disconnected components, which are all OPTIMAL. */\n+    NEEDS_SPLIT_OPTIMAL,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any ClusterSet::m_clusters.\n+     *  This must be the last entry in QualityLevel as ClusterSet::m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** Information about a transaction inside TxGraphImpl::Trim. */\n+struct TrimTxData\n+{\n+    /** Chunk feerate for this transaction. */\n+    FeePerWeight m_chunk_feerate;\n+    /** GraphIndex of the transaction. */\n+    TxGraph::GraphIndex m_index;\n+    /** Number of unmet dependencies this transaction has. -1 if the transaction is included. */\n+    uint32_t m_deps_left;\n+    /** Number of dependencies that apply to this transaction as child. */\n+    uint32_t m_parent_count;\n+    /** Where in deps_by_child those dependencies begin. */\n+    uint32_t m_parent_offset;\n+    /** Number of dependencies that apply to this transaction as parent. */\n+    uint32_t m_children_count;\n+    /** Where in deps_by_parent those dependencies begin. */\n+    uint32_t m_children_offset;\n+    /** Size of the transaction. */\n+    uint32_t m_tx_size;\n+\n+    // As transactions get processed, they get organized into trees which form partitions\n+    // representing the would-be clusters up to that point. The root of each tree is a\n+    // representative for that partition.\n+    // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure.\n+\n+    /** Pointer to another TrimTxData, towards the root of the tree. If this is a root, m_uf_parent\n+     *  is equal to this itself. */\n+    TrimTxData* m_uf_parent;\n+    /** If this is a root, the total number of transactions in the parition. */\n+    uint32_t m_uf_count;\n+    /** If this is a root, the total size of transactions in the partition. */\n+    uint64_t m_uf_size;\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl::ClusterSet. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<MAX_CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. Values for\n+     *  positions i that do not exist in m_depgraph shouldn't ever be accessed and thus don't\n+     *  matter. m_mapping.size() equals m_depgraph.PositionRange(). */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. m_linearization.size() equals\n+     *  m_depgraph.TxCount(). This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::ClusterSet::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+    /** Which level this Cluster is at in the graph (-1=not inserted, 0=main, 1=staging). */\n+    int m_level{-1};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and ClusterSet). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Whether the linearization of this Cluster can be exposed. */\n+    bool IsAcceptable(bool after_split = false) const noexcept\n+    {\n+        return m_quality == QualityLevel::ACCEPTABLE || m_quality == QualityLevel::OPTIMAL ||\n+               (after_split && (m_quality == QualityLevel::NEEDS_SPLIT_ACCEPTABLE ||\n+                                m_quality == QualityLevel::NEEDS_SPLIT_OPTIMAL));\n+    }\n+    /** Whether the linearization of this Cluster is optimal. */\n+    bool IsOptimal(bool after_split = false) const noexcept\n+    {\n+        return m_quality == QualityLevel::OPTIMAL ||\n+               (after_split && m_quality == QualityLevel::NEEDS_SPLIT_OPTIMAL);\n+    }\n+    /** Whether this cluster is oversized (just due to the size of its transaction(s), not due to\n+     *  dependencies that are yet to be added. */\n+    bool IsOversized() const noexcept { return m_quality == QualityLevel::OVERSIZED; }\n+    /** Whether this cluster requires splitting. */\n+    bool NeedsSplitting() const noexcept\n+    {\n+        return m_quality == QualityLevel::NEEDS_SPLIT ||\n+               m_quality == QualityLevel::NEEDS_SPLIT_OPTIMAL ||\n+               m_quality == QualityLevel::NEEDS_SPLIT_ACCEPTABLE;\n+    }\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Get the total size of the transactions in this Cluster. */\n+    uint64_t GetTxSize() const noexcept;\n+    /** Given a DepGraphIndex into this Cluster, find the corresponding GraphIndex. */\n+    GraphIndex GetClusterEntry(DepGraphIndex index) const noexcept { return m_mapping[index]; }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+    /** Create a copy of this Cluster, returning a pointer to it (used by PullIn). */\n+    Cluster* CopyTo(TxGraphImpl& graph, int to_level) const noexcept;\n+    /** Get the list of Clusters that conflict with this one (at the level below this Cluster). */\n+    void GetConflicts(const TxGraphImpl& graph, std::vector<Cluster*>& out) const noexcept;\n+    /** Mark all the Entry objects belonging to this Cluster as missing. The Cluster must be\n+     *  deleted immediately after. */\n+    void MakeTransactionsMissing(TxGraphImpl& graph) noexcept;\n+    /** Remove all transactions from a Cluster. */\n+    void Clear(TxGraphImpl& graph) noexcept;\n+    /** Change a Cluster's level from level to level-1. */\n+    void LevelDown(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply all removals from the front of to_remove that apply to this Cluster, popping them\n+     *  off. These must be at least one such entry. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster, apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+    /** For every chunk in the cluster, append its FeeFrac to ret. */\n+    void AppendChunkFeerates(std::vector<FeeFrac>& ret) const noexcept;\n+    /** Add a TrimTxData entry for every transaction in the Cluster to ret. Implicit dependencies\n+     *  between consecutive transactions in the linearization are added to deps. Return the\n+     *  Cluster's combined transaction size. */\n+    uint64_t AppendTrimData(std::vector<TrimTxData>& ret, std::vector<std::pair<GraphIndex, GraphIndex>>& deps) const noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Process elements from the front of args that apply to this cluster, and append Refs for the\n+     *  union of their ancestors to output. */\n+    void GetAncestorRefs(const TxGraphImpl& graph, std::span<std::pair<Cluster*, DepGraphIndex>>& args, std::vector<TxGraph::Ref*>& output) noexcept;\n+    /** Process elements from the front of args that apply to this cluster, and append Refs for the\n+     *  union of their descendants to output. */\n+    void GetDescendantRefs(const TxGraphImpl& graph, std::span<std::pair<Cluster*, DepGraphIndex>>& args, std::vector<TxGraph::Ref*>& output) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. Returns\n+     *  the range ends at the end of the cluster. */\n+    bool GetClusterRefs(TxGraphImpl& graph, std::span<TxGraph::Ref*> range, LinearizationIndex start_pos) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+\n+    // Debugging functions.\n+\n+    void SanityCheck(const TxGraphImpl& graph, int level) const;\n+};\n+\n+/** The transaction graph, including staged changes.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl::ClusterSet).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * The Clusters are kept in one or two ClusterSet objects, one for the \"main\" graph, and one for\n+ * the proposed changes (\"staging\"). If a transaction occurs in both, they share the same Entry,\n+ * but there will be a separate Cluster per graph.\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+    friend class BlockBuilderImpl;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+    /** This TxGraphImpl's maximum cluster count limit. */\n+    const DepGraphIndex m_max_cluster_count;\n+    /** This TxGraphImpl's maximum cluster size limit. */\n+    const uint64_t m_max_cluster_size;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Where the clusters to be merged start in m_group_clusters. */\n+        uint32_t m_cluster_offset;\n+        /** How many clusters to merge. */\n+        uint32_t m_cluster_count;\n+        /** Where the dependencies for this cluster group in m_deps_to_add start. */\n+        uint32_t m_deps_offset;\n+        /** How many dependencies to add. */\n+        uint32_t m_deps_count;\n+    };\n+\n+    /** Information about all groups of Clusters to be merged. */\n+    struct GroupData\n+    {\n+        /** The groups of Clusters to be merged. */\n+        std::vector<GroupEntry> m_groups;\n+        /** Which clusters are to be merged. GroupEntry::m_cluster_offset indexes into this. */\n+        std::vector<Cluster*> m_group_clusters;\n+        /** Whether at least one of the groups cannot be applied because it would result in a\n+         *  Cluster that violates the cluster count limit. */\n+        bool m_group_oversized;\n+    };\n+\n+    /** The collection of all Clusters in main or staged. */\n+    struct ClusterSet\n+    {\n+        /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+        std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+        /** Which removals have yet to be applied. */\n+        std::vector<GraphIndex> m_to_remove;\n+        /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+         *  into this. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+        /** Information about the merges to be performed, if known. */\n+        std::optional<GroupData> m_group_data = GroupData{};\n+        /** Which entries were removed in this ClusterSet (so they can be wiped on abort). */\n+        std::vector<GraphIndex> m_removed;\n+        /** Total number of transactions in this graph (sum of all transaction counts in all\n+         *  Clusters, and for staging also those inherited from the main ClusterSet). */\n+        GraphIndex m_txcount{0};\n+        /** Total number of individually oversized transactions in the graph. */\n+        GraphIndex m_txcount_oversized{0};\n+        /** Whether this graph is oversized (if known). This roughly matches\n+         *  m_group_data->m_group_oversized || (m_txcount_oversized > 0), but may be known even if\n+         *  m_group_data is not. */\n+        std::optional<bool> m_oversized{false};\n+    };\n+\n+    /** The ClusterSets in this TxGraphImpl. Has exactly 1 (main) or exactly 2 elements (main and staged). */\n+    std::vector<ClusterSet> m_clustersets;\n+\n+    /** Information about a chunk in the main graph. */\n+    struct ChunkData\n+    {\n+        /** The Entry which is the last transaction of the chunk. */\n+        mutable GraphIndex m_graph_index;\n+        /** How many transactions the chunk contains (-1 = singleton tail of cluster). */\n+        LinearizationIndex m_chunk_count;\n+\n+        ChunkData(GraphIndex graph_index, LinearizationIndex chunk_count) noexcept :\n+            m_graph_index{graph_index}, m_chunk_count{chunk_count} {}\n+    };\n+\n+    /** Comparator for ChunkData objects in mining order. */\n+    class ChunkOrder\n+    {\n+        const TxGraphImpl* const m_graph;\n+    public:\n+        explicit ChunkOrder(const TxGraphImpl* graph) : m_graph(graph) {}\n+\n+        bool operator()(const ChunkData& a, const ChunkData& b) const noexcept\n+        {\n+            const auto& a_entry = m_graph->m_entries[a.m_graph_index];\n+            const auto& b_entry = m_graph->m_entries[b.m_graph_index];\n+            // First sort from high feerate to low feerate.\n+            auto cmp_feerate = FeeRateCompare(a_entry.m_main_chunk_feerate, b_entry.m_main_chunk_feerate);\n+            if (cmp_feerate != 0) return cmp_feerate > 0;\n+            // Then sort by increasing Cluster pointer.\n+            Assume(a_entry.m_locator[0].IsPresent());\n+            Assume(b_entry.m_locator[0].IsPresent());\n+            if (a_entry.m_locator[0].cluster != b_entry.m_locator[0].cluster) {\n+                return std::less{}(a_entry.m_locator[0].cluster, b_entry.m_locator[0].cluster);\n+            }\n+            // Finally sort by position within the Cluster.\n+            return a_entry.m_main_lin_index < b_entry.m_main_lin_index;\n+        }\n+    };\n+\n+    /** Definition for the mining index type. */\n+    using ChunkIndex = std::set<ChunkData, ChunkOrder>;\n+\n+    /** Index of ChunkData objects. */\n+    ChunkIndex m_chunkindex;\n+    /** Number of index-observing objects in existence (BlockBuilderImpl). */\n+    size_t m_chunkindex_observers{0};\n+    /** Cache of discarded ChunkIndex node handles. */\n+    std::vector<ChunkIndex::node_type> m_chunkindex_discarded;\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears.\n+     *  Every Entry has MAX_LEVELS locators, as it may appear in one Cluster per level.\n+     *\n+     *  Each level of a Locator is in one of three states:\n+     *\n+     *  - (P)resent: actually occurs in a Cluster at that level.\n+     *\n+     *  - (M)issing:\n+     *    - In the main graph:    the transaction does not exist in main.\n+     *    - In the staging graph: the transaction's existence is the same as in main. If it doesn't\n+     *                            exist in main, (M) in staging means it does not exist there\n+     *                            either. If it does exist in main, (M) in staging means the\n+     *                            cluster it is in has not been modified in staging, and thus the\n+     *                            transaction implicitly exists in staging too (without explicit\n+     *                            Cluster object; see PullIn() to create it in staging too).\n+     *\n+     *  - (R)emoved: only possible in staging; it means the transaction exists in main, but is\n+     *               removed in staging.\n+     *\n+     * The following combinations are possible:\n+     * - (M,M): the transaction doesn't exist in either graph.\n+     * - (P,M): the transaction exists in both, but only exists explicitly in a Cluster object in\n+     *          main. Its existence in staging is inherited from main.\n+     * - (P,P): the transaction exists in both, and is materialized in both. Thus, the clusters\n+     *          and/or their linearizations may be different in main and staging.\n+     * - (M,P): the transaction is added in staging, and does not exist in main.\n+     * - (P,R): the transaction exists in main, but is removed in staging.\n+     *\n+     * When staging does not exist, only (M,M) and (P,M) are possible.\n+     */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (if cluster == nullptr: 0 = missing, -1 = removed). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing (= same as lower level, or non-existing if level 0). */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as removed (not allowed in level 0). */\n+        void SetRemoved() noexcept { cluster = nullptr; index = DepGraphIndex(-1); }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is missing. */\n+        bool IsMissing() const noexcept { return cluster == nullptr && index == 0; }\n+        /** Check if this Locator is removed. */\n+        bool IsRemoved() const noexcept { return cluster == nullptr && index == DepGraphIndex(-1); }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object if any, or nullptr if unlinked. */\n+        Ref* m_ref{nullptr};\n+        /** Iterator to the corresponding ChunkData, if any. */\n+        ChunkIndex::iterator m_chunkindex_iterator;\n+        /** Which Cluster and position therein this Entry appears in. ([0] = main, [1] = staged). */\n+        Locator m_locator[MAX_LEVELS];\n+        /** The chunk feerate of this transaction in main (if present in m_locator[0]). */\n+        FeePerWeight m_main_chunk_feerate;\n+        /** The position this transaction has in the main linearization (if present). */\n+        LinearizationIndex m_main_lin_index;\n+    };\n+\n+    /** The set of all transactions (in all levels combined). GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries which have no linked Ref anymore. */\n+    std::vector<GraphIndex> m_unlinked;\n+\n+public:\n+    /** Construct a new TxGraphImpl with the specified limits. */\n+    explicit TxGraphImpl(DepGraphIndex max_cluster_count, uint64_t max_cluster_size) noexcept :\n+        m_max_cluster_count(max_cluster_count),\n+        m_max_cluster_size(max_cluster_size),\n+        m_chunkindex(ChunkOrder(this))\n+    {\n+        Assume(max_cluster_count >= 1);\n+        Assume(max_cluster_count <= MAX_CLUSTER_COUNT_LIMIT);\n+        m_clustersets.reserve(MAX_LEVELS);\n+        m_clustersets.emplace_back();\n+    }\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** If idx exists in the specified level ClusterSet (explicitly, or in the level below and not\n+    *   removed), return the Cluster it is in. Otherwise, return nullptr. */\n+    Cluster* FindCluster(GraphIndex idx, int level) const noexcept;\n+    /** Extract a Cluster from its ClusterSet. */\n+    std::unique_ptr<Cluster> ExtractCluster(int level, QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster into its ClusterSet. */\n+    ClusterSetIndex InsertCluster(int level, std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(int level, QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+    /** Make a transaction not exist at a specified level. It must currently exist there. */\n+    void ClearLocator(int level, GraphIndex index, bool oversized_tx) noexcept;\n+    /** Find which Clusters conflict with the top level. */\n+    std::vector<Cluster*> GetConflicts() const noexcept;\n+    /** Clear an Entry's ChunkData. */\n+    void ClearChunkData(Entry& entry) noexcept;\n+    /** Give an Entry a ChunkData object. */\n+    void CreateChunkData(GraphIndex idx, LinearizationIndex chunk_count) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs, and Ref's move assignment. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        Assume(m_chunkindex_observers == 0 || !entry.m_locator[0].IsPresent());\n+        entry.m_ref = nullptr;\n+        // Mark the transaction as to be removed in all levels where it explicitly or implicitly\n+        // exists.\n+        bool exists_anywhere{false};\n+        bool exists{false};\n+        for (size_t level = 0; level < m_clustersets.size(); ++level) {\n+            if (entry.m_locator[level].IsPresent()) {\n+                exists_anywhere = true;\n+                exists = true;\n+            } else if (entry.m_locator[level].IsRemoved()) {\n+                exists = false;\n+            }\n+            if (exists) {\n+                m_clustersets[level].m_to_remove.push_back(idx);\n+                // Force recomputation of grouping data.\n+                m_clustersets[level].m_group_data = std::nullopt;\n+                // Do not wipe the oversized state of a lower level graph (main) if a higher level\n+                // one (staging) exists. The reason for this is that the alternative would mean that\n+                // cluster merges may need to be applied to a formerly-oversized main graph while\n+                // staging exists (to satisfy chunk feerate queries into main, for example), and such\n+                // merges could conflict with pulls of some of their constituents into staging.\n+                if (level == m_clustersets.size() - 1 && m_clustersets[level].m_oversized == true) {\n+                    m_clustersets[level].m_oversized = std::nullopt;\n+                }\n+            }\n+        }\n+        m_unlinked.push_back(idx);\n+        if (!exists_anywhere) Compact();\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Get rid of unlinked Entry objects in m_entries, if possible (this changes the GraphIndex\n+     *  values for remaining Entrys, so this only does something when no to-be-applied operations\n+     *  or staged removals referring to GraphIndexes remain). */\n+    void Compact() noexcept;\n+    /** If cluster is not in to_level, copy it there, and return a pointer to it. This has no\n+    *   effect if to_level is 0 (main), but for to_level=1 (staging) this modifies the locators of\n+    *   its transactions from inherited (P,M) to explicit (P,P). */\n+    Cluster* PullIn(Cluster* cluster, int to_level) noexcept;\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel) up to the specified level. */\n+    void ApplyRemovals(int up_to_level) noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting up to the specified level. */\n+    void SplitAll(int up_to_level) noexcept;\n+    /** Populate m_group_data based on m_deps_to_add in the specified level. */\n+    void GroupClusters(int level) noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters in the specified level. */\n+    void ApplyDependencies(int level) noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+    /** Make all Clusters at the specified level have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAllAcceptable(int level) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeePerWeight& feerate) noexcept final;\n+    void RemoveTransaction(const Ref& arg) noexcept final;\n+    void AddDependency(const Ref& parent, const Ref& child) noexcept final;\n+    void SetTransactionFee(const Ref&, int64_t fee) noexcept final;\n+\n+    void DoWork() noexcept final;\n+\n+    void StartStaging() noexcept final;\n+    void CommitStaging() noexcept final;\n+    void AbortStaging() noexcept final;\n+    bool HaveStaging() const noexcept final { return m_clustersets.size() > 1; }\n+\n+    bool Exists(const Ref& arg, bool main_only = false) noexcept final;\n+    FeePerWeight GetMainChunkFeerate(const Ref& arg) noexcept final;\n+    FeePerWeight GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg, bool main_only = false) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg, bool main_only = false) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg, bool main_only = false) noexcept final;\n+    std::vector<Ref*> GetAncestorsUnion(std::span<const Ref* const> args, bool main_only = false) noexcept final;\n+    std::vector<Ref*> GetDescendantsUnion(std::span<const Ref* const> args, bool main_only = false) noexcept final;\n+    GraphIndex GetTransactionCount(bool main_only = false) noexcept final;\n+    bool IsOversized(bool main_only = false) noexcept final;\n+    std::strong_ordering CompareMainOrder(const Ref& a, const Ref& b) noexcept final;\n+    GraphIndex CountDistinctClusters(std::span<const Ref* const> refs, bool main_only = false) noexcept final;\n+    std::pair<std::vector<FeeFrac>, std::vector<FeeFrac>> GetMainStagingDiagrams() noexcept final;\n+    std::vector<Ref*> Trim() noexcept final;\n+\n+    std::unique_ptr<BlockBuilder> GetBlockBuilder() noexcept final;\n+    std::pair<std::vector<Ref*>, FeePerWeight> GetWorstMainChunk() noexcept final;\n+\n+    void SanityCheck() const final;\n+};\n+\n+/** Implementation of the TxGraph::BlockBuilder interface. */\n+class BlockBuilderImpl final : public TxGraph::BlockBuilder\n+{\n+    /** Which TxGraphImpl this object is doing block building for. It will have its\n+     *  m_chunkindex_observers incremented as long as this BlockBuilderImpl exists. */\n+    TxGraphImpl* const m_graph;\n+    /** Vector for actual storage pointed to by TxGraph::BlockBuilder::m_current_chunk. */\n+    std::vector<TxGraph::Ref*> m_chunkdata;\n+    /** Which cluster the current chunk belongs to, so we can exclude further transaction from it\n+     *  when that chunk is skipped, or std::nullopt if we're at the end of the current cluster. */\n+    std::optional<Cluster*> m_remaining_cluster{nullptr};\n+    /** Clusters which we're not including further transactions from. */\n+    std::set<Cluster*> m_excluded_clusters;\n+    /** Iterator to the next chunk (after the current one) in the chunk index. end() if nothing\n+     *  further remains. */\n+    TxGraphImpl::ChunkIndex::const_iterator m_next_iter;\n+\n+    /** Fill in information about the current chunk in m_current_chunk, m_chunkdata,\n+     *  m_remaining_cluster, and update m_next_iter. */\n+    void Next() noexcept;\n+\n+public:\n+    /** Construct a new BlockBuilderImpl to build blocks for the provided graph. */\n+    BlockBuilderImpl(TxGraphImpl& graph) noexcept;\n+\n+    // Implement the public interface.\n+    ~BlockBuilderImpl() final;\n+    void Include() noexcept final;\n+    void Skip() noexcept final;\n+};\n+\n+void TxGraphImpl::ClearChunkData(Entry& entry) noexcept\n+{\n+    if (entry.m_chunkindex_iterator != m_chunkindex.end()) {\n+        Assume(m_chunkindex_observers == 0);\n+        // If the Entry has a non-empty m_chunkindex_iterator, extract it, and move the handle\n+        // to the cache of discarded chunkindex entries.\n+        m_chunkindex_discarded.emplace_back(m_chunkindex.extract(entry.m_chunkindex_iterator));\n+        entry.m_chunkindex_iterator = m_chunkindex.end();\n+    }\n+}\n+\n+void TxGraphImpl::CreateChunkData(GraphIndex idx, LinearizationIndex chunk_count) noexcept\n+{\n+    auto& entry = m_entries[idx];\n+    if (!m_chunkindex_discarded.empty()) {\n+        // Reuse an discarded node handle.",
      "path": "src/txgraph.cpp",
      "position": 645,
      "original_position": 620,
      "commit_id": "3744b8318d8f465603f0e6f9eb72e679d763c4ca",
      "original_commit_id": "e43f6ca3b80cff2e05f88223ee9de3e2fe014243",
      "in_reply_to_id": null,
      "user": {
        "login": "yancyribbens",
        "id": 817736,
        "node_id": "MDQ6VXNlcjgxNzczNg==",
        "avatar_url": "https://avatars.githubusercontent.com/u/817736?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yancyribbens",
        "html_url": "https://github.com/yancyribbens",
        "followers_url": "https://api.github.com/users/yancyribbens/followers",
        "following_url": "https://api.github.com/users/yancyribbens/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/yancyribbens/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/yancyribbens/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/yancyribbens/subscriptions",
        "organizations_url": "https://api.github.com/users/yancyribbens/orgs",
        "repos_url": "https://api.github.com/users/yancyribbens/repos",
        "events_url": "https://api.github.com/users/yancyribbens/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/yancyribbens/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n        // Reuse a discarded node handle.\r\n```",
      "created_at": "2025-02-24T22:48:56Z",
      "updated_at": "2025-02-24T22:48:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31553#discussion_r1968529011",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1968529011"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31553"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 645,
      "original_line": 645,
      "side": "RIGHT"
    }
  ]
}