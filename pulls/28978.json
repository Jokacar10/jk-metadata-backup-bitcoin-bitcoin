{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28978",
    "id": 1624492387,
    "node_id": "PR_kwDOABII585g08lj",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/28978",
    "diff_url": "https://github.com/bitcoin/bitcoin/pull/28978.diff",
    "patch_url": "https://github.com/bitcoin/bitcoin/pull/28978.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28978",
    "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28978/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28978/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28978/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/91dc48c14825a9075a57c1eefda202b83b6346ba",
    "number": 28978,
    "state": "closed",
    "locked": true,
    "maintainer_can_modify": false,
    "title": "doc: Add multiprocess design doc",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false,
      "patch_url": null
    },
    "body": "Add multiprocess design doc and existing multiprocess documentation into design and usage sections.\r\n\r\nLinks to rendered markdown:\r\n\r\nhttps://github.com/ryanofsky/bitcoin/blob/pr/ipcdoc/doc/design/multiprocess.md\r\nhttps://github.com/ryanofsky/bitcoin/blob/pr/ipcdoc/doc/multiprocess.md\r\n\r\n---\r\n\r\nThis PR is part of the [process separation project](https://github.com/bitcoin/bitcoin/issues/28722).",
    "labels": [
      {
        "id": 148216,
        "node_id": "MDU6TGFiZWwxNDgyMTY=",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Docs",
        "name": "Docs",
        "color": "02d7e1",
        "default": false
      }
    ],
    "created_at": "2023-11-30T21:26:57Z",
    "updated_at": "2025-01-10T07:24:02Z",
    "closed_at": "2024-01-02T15:45:29Z",
    "mergeable_state": "unknown",
    "merged_at": "2024-01-02T15:45:29Z",
    "merged_by": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false,
      "patch_url": null
    },
    "merge_commit_sha": "d036a868157202804bb7a29c115097b0fa3856c1",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "head": {
      "label": "ryanofsky:pr/ipcdoc",
      "ref": "pr/ipcdoc",
      "sha": "91dc48c14825a9075a57c1eefda202b83b6346ba",
      "user": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "repo": {
        "id": 69901633,
        "node_id": "MDEwOlJlcG9zaXRvcnk2OTkwMTYzMw==",
        "name": "bitcoin",
        "full_name": "ryanofsky/bitcoin",
        "owner": {
          "login": "ryanofsky",
          "id": 7133040,
          "node_id": "MDQ6VXNlcjcxMzMwNDA=",
          "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/ryanofsky",
          "html_url": "https://github.com/ryanofsky",
          "followers_url": "https://api.github.com/users/ryanofsky/followers",
          "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
          "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
          "repos_url": "https://api.github.com/users/ryanofsky/repos",
          "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
          "type": "User",
          "site_admin": false,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/ryanofsky/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": true,
        "url": "https://api.github.com/repos/ryanofsky/bitcoin",
        "archive_url": "https://api.github.com/repos/ryanofsky/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/ryanofsky/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/ryanofsky/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/ryanofsky/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/ryanofsky/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/ryanofsky/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/ryanofsky/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/ryanofsky/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/ryanofsky/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/ryanofsky/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/ryanofsky/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/ryanofsky/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/ryanofsky/bitcoin/events",
        "forks_url": "https://api.github.com/repos/ryanofsky/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/ryanofsky/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/ryanofsky/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/ryanofsky/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/ryanofsky/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/ryanofsky/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/ryanofsky/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/ryanofsky/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/ryanofsky/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/ryanofsky/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/ryanofsky/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/ryanofsky/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/ryanofsky/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/ryanofsky/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/ryanofsky/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/ryanofsky/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:ryanofsky/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/ryanofsky/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/ryanofsky/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/ryanofsky/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/ryanofsky/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/ryanofsky/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/ryanofsky/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/ryanofsky/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/ryanofsky/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/ryanofsky/bitcoin/hooks",
        "svn_url": "https://github.com/ryanofsky/bitcoin",
        "homepage": "https://bitcoin.org/en/download",
        "language": "C++",
        "forks_count": 9,
        "stargazers_count": 15,
        "watchers_count": 15,
        "size": 273167,
        "default_branch": "master",
        "open_issues_count": 3,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2025-01-07T02:02:40Z",
        "created_at": "2016-10-03T19:05:43Z",
        "updated_at": "2024-12-03T23:24:02Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "4b1196a9855dcd188a24f393aa2fa21e2d61f061",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false,
        "patch_url": null
      },
      "repo": {
        "id": 1181927,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTgxOTI3",
        "name": "bitcoin",
        "full_name": "bitcoin/bitcoin",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bitcoin",
        "archive_url": "https://api.github.com/repos/bitcoin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bitcoin/hooks",
        "svn_url": "https://github.com/bitcoin/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 36514,
        "stargazers_count": 81280,
        "watchers_count": 81280,
        "size": 274017,
        "default_branch": "master",
        "open_issues_count": 691,
        "is_template": false,
        "topics": [
          "bitcoin",
          "c-plus-plus",
          "cryptocurrency",
          "cryptography",
          "p2p"
        ],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2025-01-10T00:31:15Z",
        "created_at": "2010-12-19T15:16:43Z",
        "updated_at": "2025-01-10T06:04:22Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28978"
      }
    },
    "author_association": "CONTRIBUTOR",
    "draft": false,
    "additions": 285,
    "deletions": 59,
    "changed_files": 2,
    "commits": 1,
    "review_comments": 40,
    "comments": 4
  },
  "events": [
    {
      "event": "commented",
      "id": 1834586644,
      "node_id": "IC_kwDOABII585tWZIU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1834586644",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-30T21:27:00Z",
      "updated_at": "2024-01-02T15:43:39Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage\nFor detailed information about the code coverage, see the [test coverage report](https://corecheck.dev/bitcoin/bitcoin/pulls/28978).\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| ACK | [TheCharlatan](https://github.com/bitcoin/bitcoin/pull/28978#pullrequestreview-1796867156), [fjahr](https://github.com/bitcoin/bitcoin/pull/28978#issuecomment-1871465548), [stickies-v](https://github.com/bitcoin/bitcoin/pull/28978#pullrequestreview-1800375604), [achow101](https://github.com/bitcoin/bitcoin/pull/28978#issuecomment-1874192332) |\n\nIf your review is incorrectly listed, please react with 👎 to this comment and the bot will ignore it on the next update.\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28978#issuecomment-1834586644",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28978"
    },
    {
      "event": "labeled",
      "id": 11114243159,
      "node_id": "LE_lADOABII5854X6vgzwAAAAKWdeRX",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11114243159",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-30T21:27:03Z",
      "label": {
        "name": "Docs",
        "color": "02d7e1"
      }
    },
    {
      "event": "reviewed",
      "id": 1759247340,
      "node_id": "PRR_kwDOABII585o2_vs",
      "url": null,
      "actor": null,
      "commit_id": "66e19e7659dc19dac6b0cc2318efd00a4d2f5240",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28978#pullrequestreview-1759247340",
      "submitted_at": "2023-12-01T08:21:17Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28978"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 11127674453,
      "node_id": "HRFPE_lADOABII5854X6vgzwAAAAKXQtZV",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11127674453",
      "actor": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "f566245147003648099f961306be82ea32ea47ae",
      "commit_url": "https://api.github.com/repos/ryanofsky/bitcoin/commits/f566245147003648099f961306be82ea32ea47ae",
      "created_at": "2023-12-02T01:07:54Z"
    },
    {
      "event": "reviewed",
      "id": 1760730321,
      "node_id": "PRR_kwDOABII585o8pzR",
      "url": null,
      "actor": null,
      "commit_id": "66e19e7659dc19dac6b0cc2318efd00a4d2f5240",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Updated 66e19e7659dc19dac6b0cc2318efd00a4d2f5240 -> f566245147003648099f961306be82ea32ea47ae ([`pr/ipcdoc.6`](https://github.com/ryanofsky/bitcoin/commits/pr/ipcdoc.6) -> [`pr/ipcdoc.7`](https://github.com/ryanofsky/bitcoin/commits/pr/ipcdoc.7), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipcdoc.6..pr/ipcdoc.7)) fixing broken links and making small edits.",
      "user": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28978#pullrequestreview-1760730321",
      "submitted_at": "2023-12-02T01:08:10Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28978"
    },
    {
      "event": "reviewed",
      "id": 1761518850,
      "node_id": "PRR_kwDOABII585o_qUC",
      "url": null,
      "actor": null,
      "commit_id": "f566245147003648099f961306be82ea32ea47ae",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28978#pullrequestreview-1761518850",
      "submitted_at": "2023-12-04T02:53:56Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28978"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 11145443626,
      "node_id": "HRFPE_lADOABII5854X6vgzwAAAAKYUfkq",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11145443626",
      "actor": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "837c53d14f24924cdcb2cfd8b18915882dc3b620",
      "commit_url": "https://api.github.com/repos/ryanofsky/bitcoin/commits/837c53d14f24924cdcb2cfd8b18915882dc3b620",
      "created_at": "2023-12-04T22:41:06Z"
    },
    {
      "event": "reviewed",
      "id": 1763577959,
      "node_id": "PRR_kwDOABII585pHhBn",
      "url": null,
      "actor": null,
      "commit_id": "837c53d14f24924cdcb2cfd8b18915882dc3b620",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Updated f566245147003648099f961306be82ea32ea47ae -> 837c53d14f24924cdcb2cfd8b18915882dc3b620 ([`pr/ipcdoc.7`](https://github.com/ryanofsky/bitcoin/commits/pr/ipcdoc.7) -> [`pr/ipcdoc.8`](https://github.com/ryanofsky/bitcoin/commits/pr/ipcdoc.8), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipcdoc.7..pr/ipcdoc.8)) adding suggested future enhancement and making a few other tweaks\r\n",
      "user": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28978#pullrequestreview-1763577959",
      "submitted_at": "2023-12-04T22:45:36Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28978"
    },
    {
      "event": "reviewed",
      "id": 1777912181,
      "node_id": "PRR_kwDOABII585p-Ml1",
      "url": null,
      "actor": null,
      "commit_id": "837c53d14f24924cdcb2cfd8b18915882dc3b620",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Approach ACK. I'm still working on my understanding of multiprocess but this document was very helpful already in its current state, no major suggestions at this point.",
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28978#pullrequestreview-1777912181",
      "submitted_at": "2023-12-12T17:45:46Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28978"
    },
    {
      "event": "reviewed",
      "id": 1782842554,
      "node_id": "PRR_kwDOABII585qRAS6",
      "url": null,
      "actor": null,
      "commit_id": "837c53d14f24924cdcb2cfd8b18915882dc3b620",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "ACK 837c53d14f24924cdcb2cfd8b18915882dc3b620\r\n\r\nFor me this can already be merged as is but I also have a list of nits if you retouch. I have made myself familiar multiprocess a while ago but not looked at it recently. For me this was a nice refresher and I definitely think it's helpful for newcomers.\r\n\r\nA few more ideas of what might be interesting to add, but they are not essential and may also be done in a follow-up or just be ignored:\r\n- Could mention potential security implications (or lack thereof) of using `capnp` and `libmultiprocess` (at least as long as it's not maintained under the bitcoin-core org.\r\n- Similar to the usage example there could be an example of how a developer may go about changing something in the interfaces, mentioning common pitfalls etc.\r\n- If possible maybe a visualization/diagram how the pieces of the architecture fit together could be helpful to grasp the high level quicker. ",
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28978#pullrequestreview-1782842554",
      "submitted_at": "2023-12-15T16:48:44Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28978"
    },
    {
      "event": "review_requested",
      "id": 11261630239,
      "node_id": "RRE_lADOABII5854X6vgzwAAAAKfPtcf",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11261630239",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-12-15T16:48:48Z",
      "requested_reviewer": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 11292038905,
      "node_id": "HRFPE_lADOABII5854X6vgzwAAAAKhDtb5",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11292038905",
      "actor": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "fd98beea07b0488be6d3b6e7e09568331640785e",
      "commit_url": "https://api.github.com/repos/ryanofsky/bitcoin/commits/fd98beea07b0488be6d3b6e7e09568331640785e",
      "created_at": "2023-12-19T16:26:07Z"
    },
    {
      "event": "reviewed",
      "id": 1788797844,
      "node_id": "PRR_kwDOABII585qnuOU",
      "url": null,
      "actor": null,
      "commit_id": "fd98beea07b0488be6d3b6e7e09568331640785e",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Updated 837c53d14f24924cdcb2cfd8b18915882dc3b620 -> fd98beea07b0488be6d3b6e7e09568331640785e ([`pr/ipcdoc.8`](https://github.com/ryanofsky/bitcoin/commits/pr/ipcdoc.8) -> [`pr/ipcdoc.9`](https://github.com/ryanofsky/bitcoin/commits/pr/ipcdoc.9), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipcdoc.8..pr/ipcdoc.9)) with suggested changes.\r\nUpdated fd98beea07b0488be6d3b6e7e09568331640785e -> c80bd16c826d564086006cff67b7b9ade9b9f38c ([`pr/ipcdoc.9`](https://github.com/ryanofsky/bitcoin/commits/pr/ipcdoc.9) -> [`pr/ipcdoc.10`](https://github.com/ryanofsky/bitcoin/commits/pr/ipcdoc.10), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipcdoc.9..pr/ipcdoc.10)) with more edits and tweaks.\r\n\r\nre: https://github.com/bitcoin/bitcoin/pull/28978#pullrequestreview-1777912181\r\n\r\n> Approach ACK. I'm still working on my understanding of multiprocess but this document was very helpful already in its current state, no major suggestions at this point.\r\n\r\nThank you, applied your suggestions, and improved the example flow section based on your feedback.\r\n\r\nre: https://github.com/bitcoin/bitcoin/pull/28978#pullrequestreview-1782842554\r\n\r\n> ACK [837c53d](https://github.com/bitcoin/bitcoin/commit/837c53d14f24924cdcb2cfd8b18915882dc3b620)\r\n>\r\n> For me this can already be merged as is but I also have a list of nits if you retouch. I have made myself familiar multiprocess a while ago but not looked at it recently. For me this was a nice refresher and I definitely think it's helpful for newcomers.\r\n>\r\n> A few more ideas of what might be interesting to add, but they are not essential and may also be done in a follow-up or just be ignored:\r\n>\r\n>* Could mention potential security implications (or lack thereof) of using `capnp` and `libmultiprocess` (at least as long as it's not maintained under the bitcoin-core org.\r\n\r\nGreat idea, added security consideration section addressing these things.\r\n\r\n>* Similar to the usage example there could be an example of how a developer may go about changing something in the interfaces, mentioning common pitfalls etc.\r\n\r\nI think developer notes, particularly the [Internal interface guidelines](https://github.com/ryanofsky/bitcoin/blob/pr/ipcdoc/doc/developer-notes.md#internal-interface-guidelines) section will be a good place for this type of information. I added another link to it in the [Interface Definition Maintenance](https://github.com/ryanofsky/bitcoin/blob/pr/ipcdoc/doc/design/multiprocess.md#interface-definition-maintenance) section here. Probably the developer notes will need to have a little more information added, but that depends on more code being merged so should probably be left for future PRs.\r\n\r\n>* If possible maybe a visualization/diagram how the pieces of the architecture fit together could be helpful to grasp the high level quicker.\r\n\r\nYeah some visualizations would probably help. I added 3 simple diagrams, showing process/socket connections, code generation, and a call diagram, so hopefully these are helpful.\r\n",
      "user": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28978#pullrequestreview-1788797844",
      "submitted_at": "2023-12-19T16:29:03Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28978"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 11292267368,
      "node_id": "HRFPE_lADOABII5854X6vgzwAAAAKhElNo",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11292267368",
      "actor": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "c80bd16c826d564086006cff67b7b9ade9b9f38c",
      "commit_url": "https://api.github.com/repos/ryanofsky/bitcoin/commits/c80bd16c826d564086006cff67b7b9ade9b9f38c",
      "created_at": "2023-12-19T16:45:27Z"
    },
    {
      "event": "reviewed",
      "id": 1791543397,
      "node_id": "PRR_kwDOABII585qyMhl",
      "url": null,
      "actor": null,
      "commit_id": "c80bd16c826d564086006cff67b7b9ade9b9f38c",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "0xB10C",
        "id": 19157360,
        "node_id": "MDQ6VXNlcjE5MTU3MzYw",
        "avatar_url": "https://avatars.githubusercontent.com/u/19157360?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/0xB10C",
        "html_url": "https://github.com/0xB10C",
        "followers_url": "https://api.github.com/users/0xB10C/followers",
        "following_url": "https://api.github.com/users/0xB10C/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/0xB10C/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/0xB10C/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/0xB10C/subscriptions",
        "organizations_url": "https://api.github.com/users/0xB10C/orgs",
        "repos_url": "https://api.github.com/users/0xB10C/repos",
        "events_url": "https://api.github.com/users/0xB10C/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/0xB10C/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28978#pullrequestreview-1791543397",
      "submitted_at": "2023-12-20T19:36:41Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28978"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDkxZGM0OGMxNDgyNWE5MDc1YTU3YzFlZWZkYTIwMmI4M2I2MzQ2YmE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/91dc48c14825a9075a57c1eefda202b83b6346ba",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/91dc48c14825a9075a57c1eefda202b83b6346ba",
      "tree": {
        "sha": "04375dfe28778289e8e82db101129069a8f1a3f5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/04375dfe28778289e8e82db101129069a8f1a3f5"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ffb021612b8f581cbbaffacc80922d1bc5683706",
          "sha": "ffb021612b8f581cbbaffacc80922d1bc5683706",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/ffb021612b8f581cbbaffacc80922d1bc5683706"
        }
      ],
      "message": "doc: Add multiprocess design doc\n\nAlso split up existing multiprocess documentation into design and usage\nsections",
      "committer": {
        "name": "Ryan Ofsky",
        "email": "ryan@ofsky.org",
        "date": "2023-12-22T21:23:33Z"
      },
      "author": {
        "name": "Ryan Ofsky",
        "email": "ryan@ofsky.org",
        "date": "2023-11-30T20:33:50Z"
      },
      "sha": "91dc48c14825a9075a57c1eefda202b83b6346ba"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 11342241923,
      "node_id": "HRFPE_lADOABII5854X6vgzwAAAAKkDOCD",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11342241923",
      "actor": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "91dc48c14825a9075a57c1eefda202b83b6346ba",
      "commit_url": "https://api.github.com/repos/ryanofsky/bitcoin/commits/91dc48c14825a9075a57c1eefda202b83b6346ba",
      "created_at": "2023-12-27T04:23:21Z"
    },
    {
      "event": "reviewed",
      "id": 1796742782,
      "node_id": "PRR_kwDOABII585rGB5-",
      "url": null,
      "actor": null,
      "commit_id": "91dc48c14825a9075a57c1eefda202b83b6346ba",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Updated c80bd16c826d564086006cff67b7b9ade9b9f38c -> 91dc48c14825a9075a57c1eefda202b83b6346ba ([`pr/ipcdoc.10`](https://github.com/ryanofsky/bitcoin/commits/pr/ipcdoc.10) -> [`pr/ipcdoc.11`](https://github.com/ryanofsky/bitcoin/commits/pr/ipcdoc.11), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipcdoc.10..pr/ipcdoc.11)) fixing table tag and reference heading.\r\n\r\nI think this PR gets another ACK it could be merged to add the new documentation, and improvements could be implemented in a followup PR.",
      "user": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28978#pullrequestreview-1796742782",
      "submitted_at": "2023-12-27T04:33:00Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28978"
    },
    {
      "event": "reviewed",
      "id": 1796867156,
      "node_id": "PRR_kwDOABII585rGgRU",
      "url": null,
      "actor": null,
      "commit_id": "91dc48c14825a9075a57c1eefda202b83b6346ba",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "ACK 91dc48c14825a9075a57c1eefda202b83b6346ba",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28978#pullrequestreview-1796867156",
      "submitted_at": "2023-12-27T07:57:19Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28978"
    },
    {
      "event": "review_requested",
      "id": 11343100134,
      "node_id": "RRE_lADOABII5854X6vgzwAAAAKkGfjm",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11343100134",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-12-27T07:57:23Z",
      "requested_reviewer": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "commented",
      "id": 1871465548,
      "node_id": "IC_kwDOABII585vjExM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1871465548",
      "actor": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-12-28T20:19:31Z",
      "updated_at": "2023-12-28T20:19:31Z",
      "author_association": "CONTRIBUTOR",
      "body": "ACK 91dc48c14825a9075a57c1eefda202b83b6346ba",
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28978#issuecomment-1871465548",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28978"
    },
    {
      "event": "review_request_removed",
      "id": 11353040179,
      "node_id": "RRRE_lADOABII5854X6vgzwAAAAKksaUz",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11353040179",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-12-28T20:19:36Z",
      "requested_reviewer": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "reviewed",
      "id": 1800375604,
      "node_id": "PRR_kwDOABII585rT400",
      "url": null,
      "actor": null,
      "commit_id": "91dc48c14825a9075a57c1eefda202b83b6346ba",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "ACK 91dc48c14825a9075a57c1eefda202b83b6346ba - left a couple of improvements but agreed that iterating in future PRs is better.",
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28978#pullrequestreview-1800375604",
      "submitted_at": "2024-01-02T14:05:11Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28978"
    },
    {
      "event": "commented",
      "id": 1874192332,
      "node_id": "IC_kwDOABII585vtefM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1874192332",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-02T15:43:35Z",
      "updated_at": "2024-01-02T15:43:35Z",
      "author_association": "MEMBER",
      "body": "ACK 91dc48c14825a9075a57c1eefda202b83b6346ba",
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28978#issuecomment-1874192332",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28978"
    },
    {
      "event": "merged",
      "id": 11371486011,
      "node_id": "ME_lADOABII5854X6vgzwAAAAKlyxs7",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11371486011",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "d036a868157202804bb7a29c115097b0fa3856c1",
      "commit_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d036a868157202804bb7a29c115097b0fa3856c1",
      "created_at": "2024-01-02T15:45:29Z"
    },
    {
      "event": "closed",
      "id": 11371486037,
      "node_id": "CE_lADOABII5854X6vgzwAAAAKlyxtV",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11371486037",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-02T15:45:29Z"
    },
    {
      "event": "commented",
      "id": 1878878185,
      "node_id": "IC_kwDOABII585v_Wfp",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1878878185",
      "actor": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-05T15:48:25Z",
      "updated_at": "2024-01-05T15:48:25Z",
      "author_association": "CONTRIBUTOR",
      "body": "Post-merge ACK. This doc is very helpful, thanks @ryanofsky!",
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28978#issuecomment-1878878185",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28978"
    },
    {
      "event": "mentioned",
      "id": 11402611124,
      "node_id": "MEE_lADOABII5854X6vgzwAAAAKnpgm0",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11402611124",
      "actor": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-05T15:48:25Z"
    },
    {
      "event": "subscribed",
      "id": 11402611136,
      "node_id": "SE_lADOABII5854X6vgzwAAAAKnpgnA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11402611136",
      "actor": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-05T15:48:25Z"
    },
    {
      "event": "referenced",
      "id": 11462639887,
      "node_id": "REFE_lADOABII5854X6vgzwAAAAKrOgEP",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11462639887",
      "actor": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "ee4b9138c837f6dc6b8f063b0df27573736d6578",
      "commit_url": "https://api.github.com/repos/ryanofsky/bitcoin/commits/ee4b9138c837f6dc6b8f063b0df27573736d6578",
      "created_at": "2024-01-11T23:21:08Z"
    },
    {
      "event": "reviewed",
      "id": 1816915195,
      "node_id": "PRR_kwDOABII585sS-z7",
      "url": null,
      "actor": null,
      "commit_id": "91dc48c14825a9075a57c1eefda202b83b6346ba",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "re: https://github.com/bitcoin/bitcoin/pull/28978#pullrequestreview-1800375604\r\n\r\n> left a couple of improvements but agreed that iterating in future PRs is better.\r\n\r\nThanks for the close reading and suggestions. I implemented them for now in the combined PR #10102 commit https://github.com/bitcoin/bitcoin/pull/10102/commits/ee4b9138c837f6dc6b8f063b0df27573736d6578 and will split it out into another PR at some point.",
      "user": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28978#pullrequestreview-1816915195",
      "submitted_at": "2024-01-11T23:25:31Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28978"
    },
    {
      "event": "referenced",
      "id": 12610448223,
      "node_id": "REFE_lADOABII5854X6vgzwAAAALvpCtf",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12610448223",
      "actor": {
        "login": "willcl-ark",
        "id": 6606587,
        "node_id": "MDQ6VXNlcjY2MDY1ODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6606587?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/willcl-ark",
        "html_url": "https://github.com/willcl-ark",
        "followers_url": "https://api.github.com/users/willcl-ark/followers",
        "following_url": "https://api.github.com/users/willcl-ark/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/willcl-ark/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/willcl-ark/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/willcl-ark/subscriptions",
        "organizations_url": "https://api.github.com/users/willcl-ark/orgs",
        "repos_url": "https://api.github.com/users/willcl-ark/repos",
        "events_url": "https://api.github.com/users/willcl-ark/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/willcl-ark/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "c96a84679deac4357c868181fda9b824486f915f",
      "commit_url": "https://api.github.com/repos/willcl-ark/bitcoin/commits/c96a84679deac4357c868181fda9b824486f915f",
      "created_at": "2024-04-25T15:03:41Z"
    },
    {
      "event": "referenced",
      "id": 12671155391,
      "node_id": "REFE_lADOABII5854X6vgzwAAAALzQny_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12671155391",
      "actor": {
        "login": "willcl-ark",
        "id": 6606587,
        "node_id": "MDQ6VXNlcjY2MDY1ODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6606587?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/willcl-ark",
        "html_url": "https://github.com/willcl-ark",
        "followers_url": "https://api.github.com/users/willcl-ark/followers",
        "following_url": "https://api.github.com/users/willcl-ark/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/willcl-ark/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/willcl-ark/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/willcl-ark/subscriptions",
        "organizations_url": "https://api.github.com/users/willcl-ark/orgs",
        "repos_url": "https://api.github.com/users/willcl-ark/repos",
        "events_url": "https://api.github.com/users/willcl-ark/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/willcl-ark/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "8fbab4475a50510c667d2c9cbf0966d9bd393518",
      "commit_url": "https://api.github.com/repos/willcl-ark/bitcoin/commits/8fbab4475a50510c667d2c9cbf0966d9bd393518",
      "created_at": "2024-05-01T14:33:57Z"
    },
    {
      "event": "referenced",
      "id": 12680245291,
      "node_id": "REFE_lADOABII5854X6vgzwAAAALzzTAr",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12680245291",
      "actor": {
        "login": "willcl-ark",
        "id": 6606587,
        "node_id": "MDQ6VXNlcjY2MDY1ODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6606587?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/willcl-ark",
        "html_url": "https://github.com/willcl-ark",
        "followers_url": "https://api.github.com/users/willcl-ark/followers",
        "following_url": "https://api.github.com/users/willcl-ark/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/willcl-ark/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/willcl-ark/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/willcl-ark/subscriptions",
        "organizations_url": "https://api.github.com/users/willcl-ark/orgs",
        "repos_url": "https://api.github.com/users/willcl-ark/repos",
        "events_url": "https://api.github.com/users/willcl-ark/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/willcl-ark/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "bc87a774a56a4b9d0df181363ba7add695cc97ee",
      "commit_url": "https://api.github.com/repos/willcl-ark/bitcoin/commits/bc87a774a56a4b9d0df181363ba7add695cc97ee",
      "created_at": "2024-05-02T09:37:17Z"
    },
    {
      "event": "referenced",
      "id": 13109469544,
      "node_id": "REFE_lADOABII5854X6vgzwAAAAMNYqFo",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13109469544",
      "actor": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "5aaaef09b283303933cebf5e09f1689391c1e555",
      "commit_url": "https://api.github.com/repos/ryanofsky/bitcoin/commits/5aaaef09b283303933cebf5e09f1689391c1e555",
      "created_at": "2024-06-11T02:01:57Z"
    },
    {
      "event": "referenced",
      "id": 13109469593,
      "node_id": "REFE_lADOABII5854X6vgzwAAAAMNYqGZ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13109469593",
      "actor": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "ebcbba1a7d2303fe5b0ec9881f506caea3e97b78",
      "commit_url": "https://api.github.com/repos/ryanofsky/bitcoin/commits/ebcbba1a7d2303fe5b0ec9881f506caea3e97b78",
      "created_at": "2024-06-11T02:01:57Z"
    },
    {
      "event": "referenced",
      "id": 13122350077,
      "node_id": "REFE_lADOABII5854X6vgzwAAAAMOJyv9",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13122350077",
      "actor": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "b031746518c885c8bd390566a158035393d521c0",
      "commit_url": "https://api.github.com/repos/ryanofsky/bitcoin/commits/b031746518c885c8bd390566a158035393d521c0",
      "created_at": "2024-06-11T20:18:03Z"
    },
    {
      "event": "referenced",
      "id": 13122350133,
      "node_id": "REFE_lADOABII5854X6vgzwAAAAMOJyw1",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13122350133",
      "actor": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "95e6c68cc05c6233d3e6dc0507d4e9c87be7a0e2",
      "commit_url": "https://api.github.com/repos/ryanofsky/bitcoin/commits/95e6c68cc05c6233d3e6dc0507d4e9c87be7a0e2",
      "created_at": "2024-06-11T20:18:03Z"
    },
    {
      "event": "referenced",
      "id": 13478787845,
      "node_id": "REFE_lADOABII5854X6vgzwAAAAMjZfsF",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13478787845",
      "actor": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "10e17a0d297eb815d8b0e5ba58b54af3ed5880cb",
      "commit_url": "https://api.github.com/repos/ryanofsky/bitcoin/commits/10e17a0d297eb815d8b0e5ba58b54af3ed5880cb",
      "created_at": "2024-07-11T22:22:51Z"
    },
    {
      "event": "referenced",
      "id": 13664370673,
      "node_id": "REFE_lADOABII5854X6vgzwAAAAMudb_x",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13664370673",
      "actor": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "a82f438a267741eb497c5eb5a85c518664067e68",
      "commit_url": "https://api.github.com/repos/ryanofsky/bitcoin/commits/a82f438a267741eb497c5eb5a85c518664067e68",
      "created_at": "2024-07-26T18:05:46Z"
    },
    {
      "event": "referenced",
      "id": 13664370734,
      "node_id": "REFE_lADOABII5854X6vgzwAAAAMudcAu",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13664370734",
      "actor": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "dee0f699f12fe616a9d7eb043566eef7bdbce38d",
      "commit_url": "https://api.github.com/repos/ryanofsky/bitcoin/commits/dee0f699f12fe616a9d7eb043566eef7bdbce38d",
      "created_at": "2024-07-26T18:05:47Z"
    },
    {
      "event": "referenced",
      "id": 13793338179,
      "node_id": "REFE_lADOABII5854X6vgzwAAAAM2JaND",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13793338179",
      "actor": {
        "login": "willcl-ark",
        "id": 6606587,
        "node_id": "MDQ6VXNlcjY2MDY1ODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6606587?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/willcl-ark",
        "html_url": "https://github.com/willcl-ark",
        "followers_url": "https://api.github.com/users/willcl-ark/followers",
        "following_url": "https://api.github.com/users/willcl-ark/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/willcl-ark/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/willcl-ark/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/willcl-ark/subscriptions",
        "organizations_url": "https://api.github.com/users/willcl-ark/orgs",
        "repos_url": "https://api.github.com/users/willcl-ark/repos",
        "events_url": "https://api.github.com/users/willcl-ark/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/willcl-ark/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "44312a849e3852a4c9452f8199f84e3da93be144",
      "commit_url": "https://api.github.com/repos/willcl-ark/bitcoin/commits/44312a849e3852a4c9452f8199f84e3da93be144",
      "created_at": "2024-08-07T14:21:23Z"
    },
    {
      "event": "referenced",
      "id": 13810675364,
      "node_id": "REFE_lADOABII5854X6vgzwAAAAM3Li6k",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13810675364",
      "actor": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "c538ec69f266b51c893a374a4bb82796ede3d7cb",
      "commit_url": "https://api.github.com/repos/ryanofsky/bitcoin/commits/c538ec69f266b51c893a374a4bb82796ede3d7cb",
      "created_at": "2024-08-08T18:19:06Z"
    },
    {
      "event": "referenced",
      "id": 14163694039,
      "node_id": "REFE_lADOABII5854X6vgzwAAAANMONHX",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14163694039",
      "actor": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "51ebedab82bace66c352bef86ef58733491c7eea",
      "commit_url": "https://api.github.com/repos/ryanofsky/bitcoin/commits/51ebedab82bace66c352bef86ef58733491c7eea",
      "created_at": "2024-09-06T15:15:37Z"
    },
    {
      "event": "referenced",
      "id": 14163694130,
      "node_id": "REFE_lADOABII5854X6vgzwAAAANMONIy",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14163694130",
      "actor": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "083b886bc6b98fab53e2c6b7dc99a017daa9726e",
      "commit_url": "https://api.github.com/repos/ryanofsky/bitcoin/commits/083b886bc6b98fab53e2c6b7dc99a017daa9726e",
      "created_at": "2024-09-06T15:15:37Z"
    },
    {
      "event": "referenced",
      "id": 14188250028,
      "node_id": "REFE_lADOABII5854X6vgzwAAAANNr4Os",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14188250028",
      "actor": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "61c7ad56818888b2ee07db02134456aaf3e9aedc",
      "commit_url": "https://api.github.com/repos/ryanofsky/bitcoin/commits/61c7ad56818888b2ee07db02134456aaf3e9aedc",
      "created_at": "2024-09-09T19:08:35Z"
    },
    {
      "event": "referenced",
      "id": 14199024487,
      "node_id": "REFE_lADOABII5854X6vgzwAAAANOU-tn",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14199024487",
      "actor": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "a289a55102a1b6fcf9eedf6dce68657f9470aa04",
      "commit_url": "https://api.github.com/repos/ryanofsky/bitcoin/commits/a289a55102a1b6fcf9eedf6dce68657f9470aa04",
      "created_at": "2024-09-10T13:28:58Z"
    },
    {
      "event": "referenced",
      "id": 14199024875,
      "node_id": "REFE_lADOABII5854X6vgzwAAAANOU-zr",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14199024875",
      "actor": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "9c98c42a0166e9e201f6e9d32a0692fad5a185f0",
      "commit_url": "https://api.github.com/repos/ryanofsky/bitcoin/commits/9c98c42a0166e9e201f6e9d32a0692fad5a185f0",
      "created_at": "2024-09-10T13:28:59Z"
    },
    {
      "event": "referenced",
      "id": 14201709900,
      "node_id": "REFE_lADOABII5854X6vgzwAAAANOfOVM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14201709900",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "e4880f1c706c03fa89ad03bf9f590ef214d386e4",
      "commit_url": "https://api.github.com/repos/Sjors/bitcoin/commits/e4880f1c706c03fa89ad03bf9f590ef214d386e4",
      "created_at": "2024-09-10T16:15:03Z"
    },
    {
      "event": "referenced",
      "id": 14210299720,
      "node_id": "REFE_lADOABII5854X6vgzwAAAANO__dI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14210299720",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "a4ca632595816c3c295044d08fb55c589989513b",
      "commit_url": "https://api.github.com/repos/Sjors/bitcoin/commits/a4ca632595816c3c295044d08fb55c589989513b",
      "created_at": "2024-09-11T06:29:20Z"
    },
    {
      "event": "referenced",
      "id": 14210387088,
      "node_id": "REFE_lADOABII5854X6vgzwAAAANPAUyQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14210387088",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "e92d8d11118081d1fa5a667438a11a680aa8d79a",
      "commit_url": "https://api.github.com/repos/Sjors/bitcoin/commits/e92d8d11118081d1fa5a667438a11a680aa8d79a",
      "created_at": "2024-09-11T06:37:20Z"
    },
    {
      "event": "referenced",
      "id": 14236790753,
      "node_id": "REFE_lADOABII5854X6vgzwAAAANQlC_h",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14236790753",
      "actor": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "1be749c771cd9fd80361ebb69c87482920b25cd1",
      "commit_url": "https://api.github.com/repos/ryanofsky/bitcoin/commits/1be749c771cd9fd80361ebb69c87482920b25cd1",
      "created_at": "2024-09-12T17:50:02Z"
    },
    {
      "event": "referenced",
      "id": 14239081336,
      "node_id": "REFE_lADOABII5854X6vgzwAAAANQtyN4",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14239081336",
      "actor": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "b95bb2179610183d9398d50d8c8fd24b1450ad4d",
      "commit_url": "https://api.github.com/repos/ryanofsky/bitcoin/commits/b95bb2179610183d9398d50d8c8fd24b1450ad4d",
      "created_at": "2024-09-12T21:18:35Z"
    },
    {
      "event": "referenced",
      "id": 14293969991,
      "node_id": "REFE_lADOABII5854X6vgzwAAAANT_KxH",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14293969991",
      "actor": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "f9245e4bb880a6d76bbb994a6e1907c6f8c9f205",
      "commit_url": "https://api.github.com/repos/ryanofsky/bitcoin/commits/f9245e4bb880a6d76bbb994a6e1907c6f8c9f205",
      "created_at": "2024-09-17T16:15:49Z"
    },
    {
      "event": "referenced",
      "id": 14293970176,
      "node_id": "REFE_lADOABII5854X6vgzwAAAANT_K0A",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14293970176",
      "actor": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "56b4e675b6dfeb529ba6b0ec19f4380210196ac7",
      "commit_url": "https://api.github.com/repos/ryanofsky/bitcoin/commits/56b4e675b6dfeb529ba6b0ec19f4380210196ac7",
      "created_at": "2024-09-17T16:15:50Z"
    },
    {
      "event": "referenced",
      "id": 14319777662,
      "node_id": "REFE_lADOABII5854X6vgzwAAAANVhnd-",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14319777662",
      "actor": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "cf01bfacb3bc26c84ca4e6b7f9866f936f4584d0",
      "commit_url": "https://api.github.com/repos/ryanofsky/bitcoin/commits/cf01bfacb3bc26c84ca4e6b7f9866f936f4584d0",
      "created_at": "2024-09-19T08:12:58Z"
    },
    {
      "event": "referenced",
      "id": 14319777817,
      "node_id": "REFE_lADOABII5854X6vgzwAAAANVhngZ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14319777817",
      "actor": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "54611e99f5009def3a4559874823ed7fd91c9252",
      "commit_url": "https://api.github.com/repos/ryanofsky/bitcoin/commits/54611e99f5009def3a4559874823ed7fd91c9252",
      "created_at": "2024-09-19T08:12:59Z"
    },
    {
      "event": "referenced",
      "id": 14320579130,
      "node_id": "REFE_lADOABII5854X6vgzwAAAANVkrI6",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14320579130",
      "actor": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "d59f5a31a1b888051eb47e2f8a5fb8d901de1d10",
      "commit_url": "https://api.github.com/repos/ryanofsky/bitcoin/commits/d59f5a31a1b888051eb47e2f8a5fb8d901de1d10",
      "created_at": "2024-09-19T09:08:05Z"
    },
    {
      "event": "referenced",
      "id": 14322192623,
      "node_id": "REFE_lADOABII5854X6vgzwAAAANVq1Dv",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14322192623",
      "actor": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "db83545702b18a9d36d39c951730d05d6734f06c",
      "commit_url": "https://api.github.com/repos/ryanofsky/bitcoin/commits/db83545702b18a9d36d39c951730d05d6734f06c",
      "created_at": "2024-09-19T11:02:51Z"
    },
    {
      "event": "referenced",
      "id": 14327084851,
      "node_id": "REFE_lADOABII5854X6vgzwAAAANV9fcz",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14327084851",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "4184127bb7bab8aaba532c9ba2cf43828d4cf602",
      "commit_url": "https://api.github.com/repos/Sjors/bitcoin/commits/4184127bb7bab8aaba532c9ba2cf43828d4cf602",
      "created_at": "2024-09-19T16:23:04Z"
    },
    {
      "event": "referenced",
      "id": 14327656657,
      "node_id": "REFE_lADOABII5854X6vgzwAAAANV_rDR",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14327656657",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "542d3565ff7429d46e506703b1420b5783dc3933",
      "commit_url": "https://api.github.com/repos/Sjors/bitcoin/commits/542d3565ff7429d46e506703b1420b5783dc3933",
      "created_at": "2024-09-19T16:56:06Z"
    },
    {
      "event": "referenced",
      "id": 14343332867,
      "node_id": "REFE_lADOABII5854X6vgzwAAAANW7eQD",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14343332867",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "dcf681adb14745dacc58d562270478ad4b9babdc",
      "commit_url": "https://api.github.com/repos/Sjors/bitcoin/commits/dcf681adb14745dacc58d562270478ad4b9babdc",
      "created_at": "2024-09-20T17:22:22Z"
    },
    {
      "event": "referenced",
      "id": 14385249673,
      "node_id": "REFE_lADOABII5854X6vgzwAAAANZbX2J",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14385249673",
      "actor": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "44e7b856c3ceb782430692384890102c05b007db",
      "commit_url": "https://api.github.com/repos/ryanofsky/bitcoin/commits/44e7b856c3ceb782430692384890102c05b007db",
      "created_at": "2024-09-24T17:09:43Z"
    },
    {
      "event": "referenced",
      "id": 14385249834,
      "node_id": "REFE_lADOABII5854X6vgzwAAAANZbX4q",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14385249834",
      "actor": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "3499c2ca4ba5ae70cebe84614498cc105e208f3d",
      "commit_url": "https://api.github.com/repos/ryanofsky/bitcoin/commits/3499c2ca4ba5ae70cebe84614498cc105e208f3d",
      "created_at": "2024-09-24T17:09:43Z"
    },
    {
      "event": "referenced",
      "id": 14385526780,
      "node_id": "REFE_lADOABII5854X6vgzwAAAANZcbf8",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14385526780",
      "actor": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "fbed31494af9acf6bd543801143a12399b2c6a1a",
      "commit_url": "https://api.github.com/repos/ryanofsky/bitcoin/commits/fbed31494af9acf6bd543801143a12399b2c6a1a",
      "created_at": "2024-09-24T17:32:42Z"
    },
    {
      "event": "referenced",
      "id": 14386012684,
      "node_id": "REFE_lADOABII5854X6vgzwAAAANZeSIM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14386012684",
      "actor": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "1a332817665f77f55090fa166930fec0e5500727",
      "commit_url": "https://api.github.com/repos/ryanofsky/bitcoin/commits/1a332817665f77f55090fa166930fec0e5500727",
      "created_at": "2024-09-24T18:13:34Z"
    },
    {
      "event": "referenced",
      "id": 14504314423,
      "node_id": "REFE_lADOABII5854X6vgzwAAAANghkY3",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/14504314423",
      "actor": {
        "login": "m3dwards",
        "id": 1204616,
        "node_id": "MDQ6VXNlcjEyMDQ2MTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1204616?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/m3dwards",
        "html_url": "https://github.com/m3dwards",
        "followers_url": "https://api.github.com/users/m3dwards/followers",
        "following_url": "https://api.github.com/users/m3dwards/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/m3dwards/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/m3dwards/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/m3dwards/subscriptions",
        "organizations_url": "https://api.github.com/users/m3dwards/orgs",
        "repos_url": "https://api.github.com/users/m3dwards/repos",
        "events_url": "https://api.github.com/users/m3dwards/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/m3dwards/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "412cafb59eb4a9b74d5dca07dc9a6b49d74fec95",
      "commit_url": "https://api.github.com/repos/m3dwards/bitcoin/commits/412cafb59eb4a9b74d5dca07dc9a6b49d74fec95",
      "created_at": "2024-10-03T13:11:29Z"
    },
    {
      "event": "locked",
      "id": 15877782932,
      "node_id": "LOE_lADOABII5854X6vgzwAAAAOyY72U",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15877782932",
      "actor": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-10T07:24:02Z"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1411756653",
      "pull_request_review_id": 1759247340,
      "id": 1411756653,
      "node_id": "PRRC_kwDOABII585UJbJt",
      "diff_hunk": "@@ -0,0 +1,34 @@\n+# Multiprocess Bitcoin\n+\n+_This document describes usage of the multiprocess feature. For design information, see the [design/multiprocess.md](design/multiprocess.md) file._\n+\n+## Build Option\n+\n+On unix systems, the `--enable-multiprocess` build option can be passed to `./configure` to build new `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables alongside existing `bitcoind` and `bitcoin-qt` executables.\n+\n+## Debugging\n+\n+The `-debug=ipc` command line option can be used to see requests and responses between processes.\n+\n+## Installation\n+\n+The multiprocess feature requires [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) as dependencies. A simple way to get starting using it without installing these dependencies manually is to use the [depends system](../depends) with the `MULTIPROCESS=1` [dependency option](../depends#dependency-options) passed to make:\n+\n+```\n+cd <BITCOIN_SOURCE_DIRECTORY>\n+make -C depends NO_QT=1 MULTIPROCESS=1\n+CONFIG_SITE=$PWD/depends/x86_64-pc-linux-gnu/share/config.site ./configure\n+make\n+src/bitcoin-node -regtest -printtoconsole -debug=ipc\n+BITCOIND=bitcoin-node test/functional/test_runner.py\n+```\n+\n+The configure script will pick up settings and library locations from the depends directory, so there is no need to pass `--enable-multiprocess` as a separate flag when using the depends system (it's controlled by the `MULTIPROCESS=1` option).\n+\n+Alternately, you can install [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) packages on your system, and just run `./configure --enable-multiprocess` without using the depends system. The configure script will be able to locate the installed packages via [pkg-config](https://www.freedesktop.org/wiki/Software/pkg-config/). See [Installation](https://github.com/chaincodelabs/libmultiprocess/blob/master/doc/install.md) section of the libmultiprocess readme for install steps. See [build-unix.md](build-unix.md) and [build-osx.md](build-osx.md) for information about installing dependencies in general.\n+\n+## Usage\n+\n+`bitcoin-node` is a drop-in replacement for `bitcoind`, and `bitcoin-gui` is a drop-in replacement for `bitcoin-qt`, and there are no differences in use or external behavior between the new and old executables. But internally after [#10102](https://github.com/bitcoin/bitcoin/pull/10102), `bitcoin-gui` will spawn a `bitcoin-node` process to run P2P and RPC code, communicating with it across a socket pair, and `bitcoin-node` will spawn `bitcoin-wallet` to run wallet code, also communicating over a socket pair. This will let node, wallet, and GUI code run in separate address spaces for better isolation, and allow future improvements like being able to start and stop components independently on different machines and environments.\n+[#19160](https://github.com/bitcoin/bitcoin/pull/19160) adds a new `bitcoin-node` `-ipcbind` option and an `bitcoind-wallet` `-ipcconnect` option to allow new wallet processes to connect to an existing node process.",
      "path": "doc/multiprocess.md",
      "position": null,
      "original_position": 33,
      "commit_id": "91dc48c14825a9075a57c1eefda202b83b6346ba",
      "original_commit_id": "66e19e7659dc19dac6b0cc2318efd00a4d2f5240",
      "in_reply_to_id": null,
      "user": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n[#19160](https://github.com/bitcoin/bitcoin/pull/19160) added a new `bitcoin-node` `-ipcbind` option and an `bitcoind-wallet` `-ipcconnect` option to allow new wallet processes to connect to an existing node process.\r\n```\r\n\r\nThe pull is merged?",
      "created_at": "2023-12-01T08:17:27Z",
      "updated_at": "2023-12-01T08:21:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28978#discussion_r1411756653",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1411756653"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28978"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 33,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1411756818",
      "pull_request_review_id": 1759247340,
      "id": 1411756818,
      "node_id": "PRRC_kwDOABII585UJbMS",
      "diff_hunk": "@@ -0,0 +1,34 @@\n+# Multiprocess Bitcoin\n+\n+_This document describes usage of the multiprocess feature. For design information, see the [design/multiprocess.md](design/multiprocess.md) file._\n+\n+## Build Option\n+\n+On unix systems, the `--enable-multiprocess` build option can be passed to `./configure` to build new `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables alongside existing `bitcoind` and `bitcoin-qt` executables.\n+\n+## Debugging\n+\n+The `-debug=ipc` command line option can be used to see requests and responses between processes.\n+\n+## Installation\n+\n+The multiprocess feature requires [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) as dependencies. A simple way to get starting using it without installing these dependencies manually is to use the [depends system](../depends) with the `MULTIPROCESS=1` [dependency option](../depends#dependency-options) passed to make:\n+\n+```\n+cd <BITCOIN_SOURCE_DIRECTORY>\n+make -C depends NO_QT=1 MULTIPROCESS=1\n+CONFIG_SITE=$PWD/depends/x86_64-pc-linux-gnu/share/config.site ./configure\n+make\n+src/bitcoin-node -regtest -printtoconsole -debug=ipc\n+BITCOIND=bitcoin-node test/functional/test_runner.py\n+```\n+\n+The configure script will pick up settings and library locations from the depends directory, so there is no need to pass `--enable-multiprocess` as a separate flag when using the depends system (it's controlled by the `MULTIPROCESS=1` option).\n+\n+Alternately, you can install [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) packages on your system, and just run `./configure --enable-multiprocess` without using the depends system. The configure script will be able to locate the installed packages via [pkg-config](https://www.freedesktop.org/wiki/Software/pkg-config/). See [Installation](https://github.com/chaincodelabs/libmultiprocess/blob/master/doc/install.md) section of the libmultiprocess readme for install steps. See [build-unix.md](build-unix.md) and [build-osx.md](build-osx.md) for information about installing dependencies in general.\n+\n+## Usage\n+\n+`bitcoin-node` is a drop-in replacement for `bitcoind`, and `bitcoin-gui` is a drop-in replacement for `bitcoin-qt`, and there are no differences in use or external behavior between the new and old executables. But internally after [#10102](https://github.com/bitcoin/bitcoin/pull/10102), `bitcoin-gui` will spawn a `bitcoin-node` process to run P2P and RPC code, communicating with it across a socket pair, and `bitcoin-node` will spawn `bitcoin-wallet` to run wallet code, also communicating over a socket pair. This will let node, wallet, and GUI code run in separate address spaces for better isolation, and allow future improvements like being able to start and stop components independently on different machines and environments.\n+[#19160](https://github.com/bitcoin/bitcoin/pull/19160) adds a new `bitcoin-node` `-ipcbind` option and an `bitcoind-wallet` `-ipcconnect` option to allow new wallet processes to connect to an existing node process.\n+[#19161](https://github.com/bitcoin/bitcoin/pull/19161) adds a new `bitcoin-gui` `-ipcconnect` option to allow new GUI processes to connect to an existing node process.",
      "path": "doc/multiprocess.md",
      "position": null,
      "original_position": 34,
      "commit_id": "91dc48c14825a9075a57c1eefda202b83b6346ba",
      "original_commit_id": "66e19e7659dc19dac6b0cc2318efd00a4d2f5240",
      "in_reply_to_id": null,
      "user": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n[#19161](https://github.com/bitcoin/bitcoin/pull/???) adds a new `bitcoin-gui` `-ipcconnect` option to allow new GUI processes to connect to an existing node process.\r\n```\r\n\r\nwrong number?",
      "created_at": "2023-12-01T08:17:38Z",
      "updated_at": "2023-12-01T08:21:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28978#discussion_r1411756818",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1411756818"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28978"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 34,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1412680712",
      "pull_request_review_id": 1760730321,
      "id": 1412680712,
      "node_id": "PRRC_kwDOABII585UM8wI",
      "diff_hunk": "@@ -0,0 +1,34 @@\n+# Multiprocess Bitcoin\n+\n+_This document describes usage of the multiprocess feature. For design information, see the [design/multiprocess.md](design/multiprocess.md) file._\n+\n+## Build Option\n+\n+On unix systems, the `--enable-multiprocess` build option can be passed to `./configure` to build new `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables alongside existing `bitcoind` and `bitcoin-qt` executables.\n+\n+## Debugging\n+\n+The `-debug=ipc` command line option can be used to see requests and responses between processes.\n+\n+## Installation\n+\n+The multiprocess feature requires [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) as dependencies. A simple way to get starting using it without installing these dependencies manually is to use the [depends system](../depends) with the `MULTIPROCESS=1` [dependency option](../depends#dependency-options) passed to make:\n+\n+```\n+cd <BITCOIN_SOURCE_DIRECTORY>\n+make -C depends NO_QT=1 MULTIPROCESS=1\n+CONFIG_SITE=$PWD/depends/x86_64-pc-linux-gnu/share/config.site ./configure\n+make\n+src/bitcoin-node -regtest -printtoconsole -debug=ipc\n+BITCOIND=bitcoin-node test/functional/test_runner.py\n+```\n+\n+The configure script will pick up settings and library locations from the depends directory, so there is no need to pass `--enable-multiprocess` as a separate flag when using the depends system (it's controlled by the `MULTIPROCESS=1` option).\n+\n+Alternately, you can install [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) packages on your system, and just run `./configure --enable-multiprocess` without using the depends system. The configure script will be able to locate the installed packages via [pkg-config](https://www.freedesktop.org/wiki/Software/pkg-config/). See [Installation](https://github.com/chaincodelabs/libmultiprocess/blob/master/doc/install.md) section of the libmultiprocess readme for install steps. See [build-unix.md](build-unix.md) and [build-osx.md](build-osx.md) for information about installing dependencies in general.\n+\n+## Usage\n+\n+`bitcoin-node` is a drop-in replacement for `bitcoind`, and `bitcoin-gui` is a drop-in replacement for `bitcoin-qt`, and there are no differences in use or external behavior between the new and old executables. But internally after [#10102](https://github.com/bitcoin/bitcoin/pull/10102), `bitcoin-gui` will spawn a `bitcoin-node` process to run P2P and RPC code, communicating with it across a socket pair, and `bitcoin-node` will spawn `bitcoin-wallet` to run wallet code, also communicating over a socket pair. This will let node, wallet, and GUI code run in separate address spaces for better isolation, and allow future improvements like being able to start and stop components independently on different machines and environments.\n+[#19160](https://github.com/bitcoin/bitcoin/pull/19160) adds a new `bitcoin-node` `-ipcbind` option and an `bitcoind-wallet` `-ipcconnect` option to allow new wallet processes to connect to an existing node process.",
      "path": "doc/multiprocess.md",
      "position": null,
      "original_position": 33,
      "commit_id": "91dc48c14825a9075a57c1eefda202b83b6346ba",
      "original_commit_id": "66e19e7659dc19dac6b0cc2318efd00a4d2f5240",
      "in_reply_to_id": 1411756653,
      "user": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "re: https://github.com/bitcoin/bitcoin/pull/28978#discussion_r1411756653\r\n\r\n> The pull is merged?\r\n\r\nGood catch, this was supposed to point to #19460",
      "created_at": "2023-12-02T00:24:52Z",
      "updated_at": "2023-12-02T01:08:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28978#discussion_r1412680712",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1412680712"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28978"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 33,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1412680746",
      "pull_request_review_id": 1760730321,
      "id": 1412680746,
      "node_id": "PRRC_kwDOABII585UM8wq",
      "diff_hunk": "@@ -0,0 +1,34 @@\n+# Multiprocess Bitcoin\n+\n+_This document describes usage of the multiprocess feature. For design information, see the [design/multiprocess.md](design/multiprocess.md) file._\n+\n+## Build Option\n+\n+On unix systems, the `--enable-multiprocess` build option can be passed to `./configure` to build new `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables alongside existing `bitcoind` and `bitcoin-qt` executables.\n+\n+## Debugging\n+\n+The `-debug=ipc` command line option can be used to see requests and responses between processes.\n+\n+## Installation\n+\n+The multiprocess feature requires [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) as dependencies. A simple way to get starting using it without installing these dependencies manually is to use the [depends system](../depends) with the `MULTIPROCESS=1` [dependency option](../depends#dependency-options) passed to make:\n+\n+```\n+cd <BITCOIN_SOURCE_DIRECTORY>\n+make -C depends NO_QT=1 MULTIPROCESS=1\n+CONFIG_SITE=$PWD/depends/x86_64-pc-linux-gnu/share/config.site ./configure\n+make\n+src/bitcoin-node -regtest -printtoconsole -debug=ipc\n+BITCOIND=bitcoin-node test/functional/test_runner.py\n+```\n+\n+The configure script will pick up settings and library locations from the depends directory, so there is no need to pass `--enable-multiprocess` as a separate flag when using the depends system (it's controlled by the `MULTIPROCESS=1` option).\n+\n+Alternately, you can install [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) packages on your system, and just run `./configure --enable-multiprocess` without using the depends system. The configure script will be able to locate the installed packages via [pkg-config](https://www.freedesktop.org/wiki/Software/pkg-config/). See [Installation](https://github.com/chaincodelabs/libmultiprocess/blob/master/doc/install.md) section of the libmultiprocess readme for install steps. See [build-unix.md](build-unix.md) and [build-osx.md](build-osx.md) for information about installing dependencies in general.\n+\n+## Usage\n+\n+`bitcoin-node` is a drop-in replacement for `bitcoind`, and `bitcoin-gui` is a drop-in replacement for `bitcoin-qt`, and there are no differences in use or external behavior between the new and old executables. But internally after [#10102](https://github.com/bitcoin/bitcoin/pull/10102), `bitcoin-gui` will spawn a `bitcoin-node` process to run P2P and RPC code, communicating with it across a socket pair, and `bitcoin-node` will spawn `bitcoin-wallet` to run wallet code, also communicating over a socket pair. This will let node, wallet, and GUI code run in separate address spaces for better isolation, and allow future improvements like being able to start and stop components independently on different machines and environments.\n+[#19160](https://github.com/bitcoin/bitcoin/pull/19160) adds a new `bitcoin-node` `-ipcbind` option and an `bitcoind-wallet` `-ipcconnect` option to allow new wallet processes to connect to an existing node process.\n+[#19161](https://github.com/bitcoin/bitcoin/pull/19161) adds a new `bitcoin-gui` `-ipcconnect` option to allow new GUI processes to connect to an existing node process.",
      "path": "doc/multiprocess.md",
      "position": null,
      "original_position": 34,
      "commit_id": "91dc48c14825a9075a57c1eefda202b83b6346ba",
      "original_commit_id": "66e19e7659dc19dac6b0cc2318efd00a4d2f5240",
      "in_reply_to_id": 1411756818,
      "user": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "re: https://github.com/bitcoin/bitcoin/pull/28978#discussion_r1411756818\r\n\r\n> wrong number?\r\n\r\nThanks, this one was supposed to point to #19461",
      "created_at": "2023-12-02T00:24:56Z",
      "updated_at": "2023-12-02T01:08:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28978#discussion_r1412680746",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1412680746"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28978"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 34,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1413316233",
      "pull_request_review_id": 1761518850,
      "id": 1413316233,
      "node_id": "PRRC_kwDOABII585UPX6J",
      "diff_hunk": "@@ -1,72 +1,199 @@\n-# Multiprocess Bitcoin\n-\n-On unix systems, the `--enable-multiprocess` build option can be passed to `./configure` to build new `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables alongside existing `bitcoind` and `bitcoin-qt` executables.\n-\n-`bitcoin-node` is a drop-in replacement for `bitcoind`, and `bitcoin-gui` is a drop-in replacement for `bitcoin-qt`, and there are no differences in use or external behavior between the new and old executables. But internally (after [#10102](https://github.com/bitcoin/bitcoin/pull/10102)), `bitcoin-gui` will spawn a `bitcoin-node` process to run P2P and RPC code, communicating with it across a socket pair, and `bitcoin-node` will spawn `bitcoin-wallet` to run wallet code, also communicating over a socket pair. This will let node, wallet, and GUI code run in separate address spaces for better isolation, and allow future improvements like being able to start and stop components independently on different machines and environments.\n-\n-## Next steps\n-\n-Specific next steps after [#10102](https://github.com/bitcoin/bitcoin/pull/10102) will be:\n-\n-- [ ] Adding `-ipcbind` and `-ipcconnect` options to `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables so they can listen and connect to TCP ports and unix socket paths. This will allow separate processes to be started and stopped any time and connect to each other.\n-- [ ] Adding `-server` and `-rpcbind` options to the `bitcoin-wallet` executable so wallet processes can handle RPC requests directly without going through the node.\n-- [ ] Supporting windows, not just unix systems. The existing socket code is already cross-platform, so the only windows-specific code that needs to be written is code spawning a process and passing a socket descriptor. This can be implemented with `CreateProcess` and `WSADuplicateSocket`. Example: https://memset.wordpress.com/2010/10/13/win32-api-passing-socket-with-ipc-method/.\n-- [ ] Adding sandbox features, restricting subprocess access to resources and data. See [https://eklitzke.org/multiprocess-bitcoin](https://eklitzke.org/multiprocess-bitcoin).\n-\n-## Debugging\n-\n-The `-debug=ipc` command line option can be used to see requests and responses between processes.\n-\n-## Installation\n-\n-The multiprocess feature requires [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) as dependencies. A simple way to get starting using it without installing these dependencies manually is to use the [depends system](../../depends) with the `MULTIPROCESS=1` [dependency option](../../depends#dependency-options) passed to make:\n-\n-```\n-cd <BITCOIN_SOURCE_DIRECTORY>\n-make -C depends NO_QT=1 MULTIPROCESS=1\n-CONFIG_SITE=$PWD/depends/x86_64-pc-linux-gnu/share/config.site ./configure\n-make\n-src/bitcoin-node -regtest -printtoconsole -debug=ipc\n-BITCOIND=bitcoin-node test/functional/test_runner.py\n-```\n-\n-The configure script will pick up settings and library locations from the depends directory, so there is no need to pass `--enable-multiprocess` as a separate flag when using the depends system (it's controlled by the `MULTIPROCESS=1` option).\n-\n-Alternately, you can install [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) packages on your system, and just run `./configure --enable-multiprocess` without using the depends system. The configure script will be able to locate the installed packages via [pkg-config](https://www.freedesktop.org/wiki/Software/pkg-config/). See [Installation](https://github.com/chaincodelabs/libmultiprocess/blob/master/doc/install.md) section of the libmultiprocess readme for install steps. See [build-unix.md](../build-unix.md) and [build-osx.md](../build-osx.md) for information about installing dependencies in general.\n-\n-## IPC implementation details\n-\n-Cross process Node, Wallet, and Chain interfaces are defined in\n-[`src/interfaces/`](../../src/interfaces/). These are C++ classes which follow\n-[conventions](../developer-notes.md#internal-interface-guidelines), like passing\n-serializable arguments so they can be called from different processes, and\n-making methods pure virtual so they can have proxy implementations that forward\n-calls between processes.\n-\n-When Wallet, Node, and Chain code is running in the same process, calling any\n-interface method invokes the implementation directly. When code is running in\n-different processes, calling an interface method invokes a proxy interface\n-implementation that communicates with a remote process and invokes the real\n-implementation in the remote process. The\n-[libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) code\n-generation tool internally generates proxy client classes and proxy server\n-classes for this purpose that are thin wrappers around Cap'n Proto\n-[client](https://capnproto.org/cxxrpc.html#clients) and\n-[server](https://capnproto.org/cxxrpc.html#servers) classes, which handle the\n-actual serialization and socket communication.\n-\n-As much as possible, calls between processes are meant to work the same as\n-calls within a single process without adding limitations or requiring extra\n-implementation effort. Processes communicate with each other by calling regular\n-[C++ interface methods](../../src/interfaces/README.md). Method arguments and\n-return values are automatically serialized and sent between processes. Object\n-references and `std::function` arguments are automatically tracked and mapped\n-to allow invoked code to call back into invoking code at any time, and there is\n-a 1:1 threading model where any thread invoking a method in another process has\n-a corresponding thread in the invoked process responsible for executing all\n-method calls from the source thread, without blocking I/O or holding up another\n-call, and using the same thread local variables, locks, and callbacks between\n-calls. The forwarding, tracking, and threading is implemented inside the\n-[libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) library\n-which has the design goal of making calls between processes look like calls in\n-the same process to the extent possible.\n+# Multiprocess Bitcoin Design Document\n+\n+Guide to the design and architecture of the Bitcoin-Core multiprocess feature\n+\n+_This document describes the design of the multiprocess feature. For usage information, see the top-level [multiprocess.md](../multiprocess.md) file._\n+\n+## Table of contents\n+\n+- [Introduction](#introduction)\n+- [Current Architecture](#current-architecture)\n+- [Proposed Architecture](#proposed-architecture)\n+- [Component Overview: Navigating the IPC Framework](#component-overview-navigating-the-ipc-framework)\n+- [Design Considerations](#design-considerations)\n+  - [Selection of Cap’n Proto](#selection-of-capn-proto)\n+  - [Hiding IPC](#hiding-ipc)\n+  - [Interface Definition Maintenance](#interface-definition-maintenance)\n+  - [Interface Stability](#interface-stability)\n+- [Example Use Cases and Flows](#example-use-cases-and-flows)\n+  - [Retrieving a Block Hash](#retrieving-a-block-hash)\n+- [Future Enhancements](#future-enhancements)\n+- [Conclusion](#conclusion)\n+- [Appendices](#appendices)\n+  - [Glossary of Terms](#glossary-of-terms)\n+  - [References](#references)\n+- [Acknowledgements](#acknowledgements)\n+\n+## Introduction\n+\n+The Bitcoin Core software, central to the Bitcoin network, has historically employed a monolithic architecture. The existing design has integrated functionality like P2P network operations, wallet management, and a GUI into a single executable. While effective, it has limitations in flexibility, security, and scalability. This project introduces changes that transition Bitcoin Core to a more modular architecture. It aims to enhance security, improve usability, and facilitate maintenance and development of the software.\n+\n+## Current Architecture\n+\n+The current system features two primary executables: `bitcoind` and `bitcoin-qt`. `bitcoind` combines a Bitcoin P2P node with an integrated JSON-RPC server, wallet, and indexes. `bitcoin-qt` extends this by incorporating a Qt-based GUI. This monolithic structure, although robust, presents challenges such as limited operational flexibility and increased security risks due to the tight integration of components.\n+\n+## Proposed Architecture\n+\n+The new architecture divides the existing code into three specialized executables:\n+\n+- `bitcoin-node`: Manages the node, indexes, and JSON-RPC server.\n+- `bitcoin-wallet`: Handles all wallet functionality.\n+- `bitcoin-gui`: Provides a standalone Qt-based GUI.\n+\n+This modular approach is designed to enhance security through component isolation and improve usability by allowing independent operation of each module. This allows for new use-cases, such as running the node on a dedicated machine and operating wallets and GUIs on separate machines with the flexibility to start and stop them as needed.\n+\n+This subdivision could be extended in the future. For example, indexes could be removed from the `bitcoin-node` executable and run in separate executables. And JSON-RPC servers could be added to wallet and index executables, so they can listen and respond to RPC requests on their own ports, without needing to forward RPC requests through `bitcoin-node`.\n+\n+## Component Overview: Navigating the IPC Framework\n+\n+This section describes the major components of the Inter-Process Communication (IPC) framework covering the relevant source files, generated files, tools, and libraries.\n+\n+### Abstract C++ Classes in [`src/interfaces/`](../../src/interfaces/)\n+- The foundation of the IPC implementation lies in the abstract C++ classes within the [`src/interfaces/`](../../src/interfaces/) directory. These classes define pure virtual methods that code in [`src/node/`](../../src/node/), [`src/wallet/`](../../src/wallet/), and [`src/qt/`](../../src/qt/) directories call to interact with each other.\n+- Each abstract class in this directory represents a distinct interface that the different modules (node, wallet, GUI) implement and use for cross-process communication.\n+- The classes are written following conventions described in [Internal Interface\n+  Guidelines](../developer-notes.md#internal-interface-guidelines) to ensure\n+  compatibility with Cap'n Proto.\n+\n+### Cap’n Proto Files in [`src/ipc/capnp/`](../../src/ipc/capnp/)\n+- Corresponding to each abstract class, there are `.capnp` files within the [`src/ipc/capnp/`](../../src/ipc/capnp/) directory. These files are used as input to the `mpgen` tool (described below) to generate C++ code.\n+- These Cap’n Proto files ([learn more about Cap'n Proto RPC](https://capnproto.org/rpc.html)) define the structure and format of messages that are exchanged over IPC. They serve as blueprints for generating C++ code that bridges the gap between high-level C++ interfaces and low-level socket communication.\n+\n+### The `mpgen` Code Generation Tool\n+- A central component of the IPC framework is the `mpgen` tool which is part the [`libmultiprocess` project](https://github.com/chaincodelabs/libmultiprocess). This tool takes the `.capnp` files as input and generates C++ code.\n+- The generated code handles IPC communication, translating interface calls into socket reads and writes.\n+\n+### C++ Client Subclasses in Generated Code\n+- In the generated code, we have C++ client subclasses that inherit from the abstract classes in [`src/interfaces/`](../../src/interfaces/). These subclasses are the workhorses of the IPC mechanism.\n+- They implement all the methods of the interface, marshalling arguments into a structured format, sending them as requests to the IPC server via a UNIX socket, and handling the responses.\n+- These subclasses effectively mask the complexity of IPC, presenting a familiar C++ interface to developers.\n+- Internally, the client subclasses generated by the `mpgen` tool wrap [client classes generated by Cap'n Proto](https://capnproto.org/cxxrpc.html#clients), and use them to send IPC requests.\n+\n+### C++ Server Classes in Generated Code\n+- On the server side, corresponding generated C++ classes receive IPC requests. These server classes are responsible for unmarshalling method arguments, invoking the corresponding methods in the local [`src/interfaces/`](../../src/interfaces/) objects, and creating the IPC response.\n+- The server classes ensure that return values (including output argument values and thrown exceptions) are marshalled and sent back to the client, completing the communication cycle.\n+- Internally, the server subclasses generated by the `mpgen` tool inherit from [server classes generated by Cap'n Proto](https://capnproto.org/cxxrpc.html#servers), and use them to process IPC requests.\n+\n+### The `libmultiprocess` Runtime Library\n+- **Core Functionality**: The `libmultiprocess` runtime library's primary function is to instantiate the generated client and server classes as needed.\n+- **Bootstrapping IPC Connections**: It provides functions for starting new IPC connections, specifically binding generated client and server classes for an initial `interfaces::Init` interface (defined in [`src/interfaces/init.h`](../../src/interfaces/init.h)) to a UNIX socket. This initial interface has methods returning other interfaces that different Bitcoin-Core modules use to communicate after the bootstrapping phase.\n+- **Asynchronous I/O and Thread Management**: The library is also responsible for managing I/O and threading. Particularly, it ensures that IPC requests never block each other and that new threads on either side of a connection can always make client calls. It also manages worker threads on the server side of calls, ensuring that calls from the same client thread always execute on the same server thread (to avoid locking issues and support nested callbacks).\n+\n+### Type Hooks in [`src/ipc/capnp/*-types.h`](../../src/ipc/capnp/)\n+- **Custom Type Conversions**: In [`src/ipc/capnp/*-types.h`](../../src/ipc/capnp/), multiple function overloads of two `libmultiprocess` C++ functions, `mp::CustomReadField` and `mp::CustomBuildFields`, are defined. These functions are used for customizing the conversion of specific C++ types to and from Cap’n Proto types.\n+- **Handling Special Cases**: The `mpgen` tool and `libmultiprocess` library can convert most C++ types to and from Cap’n Proto types automatically, including interface types, primitive C++ types, standard C++ types like `std::vector`, `std::set`, `std::map`, `std::tuple`, and `std::function`, as well as simple C++ structs that consist of afforementioned types and whose fields correspond 1:1 with Cap’n Proto struct fields. For other types, `*-types.h` files provide custom code to convert between C++ and Cap’n Proto data representations.\n+\n+### Protocol-Agnostic IPC Code in [`src/ipc/`](../../src/ipc/)\n+- **Broad Applicability**: Unlike the Cap’n Proto-specific code in [`src/ipc/capnp/`](../../src/ipc/capnp/), the code in the [`src/ipc/`](../../src/ipc/) directory is protocol-agnostic. This enables potential support for other protocols, such as gRPC or a custom protocol in the future.\n+- **Process Management and Socket Operations**: The main purpose of this component is to provide functions for spawning new processes and creating and connecting to UNIX sockets.\n+- **ipc::Exception Class**: This code also defines an `ipc::Exception` class which is thrown from the generated C++ client class methods when there is an unexpected IPC error, such as a disconnection.\n+\n+## Design Considerations\n+\n+### Selection of Cap’n Proto\n+The choice to use [Cap’n Proto](https://capnproto.org/) for IPC was primarily influenced by its support for passing object references and managing object lifetimes, which would have to be implemented manually with a framework that only supported plain requests and responses like [gRPC](https://grpc.io/). The support is especially helpful for passing callback objects like `std::function` and supporting bidirectional communication.\n+\n+The choice to use an RPC framework at all instead of a custom protocol was neccesitated by the size of Bitcoin Core internal interfaces which consist of around 150 methods that pass complex data structures and are called in complicated ways (in parallel, from callbacks that can be nested and stored). Writing a custom protocol to wrap these complicated interfaces would be too much work, akin to writing a new RPC framework.\n+\n+### Hiding IPC\n+\n+The IPC mechanism is deliberately isolated from the rest of the codebase so less code has to be concerned with IPC.\n+\n+Building Bitcoin Core with IPC support is optional, and the same code can be compiled to either run in the same process or separate processes. The build system also ensures Cap’n Proto library headers can only be used within the [`src/ipc/capnp/`](../../src/ipc/capnp/) directory, not in other parts of the codebase.\n+\n+The libmultiprocess runtime is designed to place as few constraints as possible on IPC interfaces and make IPC calls act like normal function calls. Method arguments, return values, and exceptions are automatically serialized and sent between processes. Object references and `std::function` arguments are automatically tracked and mapped to allow invoked code to call back into invoking code at any time. And there is a 1:1 threading model where any every client thread has a corresponding server thread responsible for executing incoming calls from that thread (there can be multiple calls from the same thread due to callbacks), without blocking, and holding the same thread-local variables and locks so behavior is the same whether IPC is used or not.\n+\n+### Interface Definition Maintenance\n+\n+The choice to maintain interface definitions and C++ type mappings as `.capnp` files in the [`src/ipc/capnp/`](../../src/ipc/capnp/) was mostly done for convenience, and probably something that could be improved in the future.\n+\n+In the current design, class names, method names, and parameter names are duplicated between C++ interfaces in [`src/interfaces/`](../../src/interfaces/) and Cap’n Proto files in [`src/ipc/capnp/`](../../src/ipc/capnp/). While this keeps C++ interface headers simple and free of references to IPC, it is a maintence burden because it means inconsistencies between C++ declarations and Cap’n Proto declarations will result in compile errors. (Static type checking ensures these are not runtime errors.)\n+\n+An alternate approach could use custom [C++ Attributes](https://en.cppreference.com/w/cpp/language/attributes) embedded in interface declarations to automatically generate `.capnp` files directly from C++ headers. This has not been pursued because parsing C++ headers is a more complicated than parsing Cap’n Proto interface definitions, especially portably on multiple platforms.\n+\n+### Interface Stability\n+\n+The currently defined IPC interfaces are unstable, and can change freely with no backwards compatibility. The decision to allow this stems from the recognition that our current interfaces are still evolving and not yet ideal for external use. As these interfaces mature and become more refined, there may be an opportunity to declare them stable and use Cap’n Proto's support for protocol evolution ([Cap'n Proto - Evolving Your Protocol](https://capnproto.org/language.html#evolving-your-protocol)) to allow them to be extended while remaining backwards compatible. This could allow different versions of node, GUI, and wallet binaries to interoperate, and potentially open doors for external tools to utilize these interfaces, such as creating custom indexes through a stable indexing interface. However, for now, the priority is to improve the interfaces internally. Given their current state and the advantages of using JSON-RPC for most common tasks, it's more practical to focus on internal development rather than external applicability.\n+\n+## Example Use Cases and Flows\n+\n+### Retrieving a Block Hash\n+\n+Let’s walk through an example where the `bitcoin-wallet` process requests the hash of a block at a specific height from the `bitcoin-node` process. This example demonstrates the practical application of the IPC mechanism, specifically the interplay between C++ method calls and Cap’n Proto-generated RPC calls.\n+\n+1. **Initiation in bitcoin-wallet**\n+   - The wallet process calls the `getBlockHash` method on a `Chain` object. This method is defined as a virtual function in [`src/interfaces/chain.h`](../../src/interfaces/chain.h).\n+\n+2. **Translation to Cap’n Proto RPC**\n+   - The call to `getBlockHash` is translated into a Cap’n Proto RPC call. This translation is handled by code automatically generated by the `mpgen` tool, based on the [`chain.capnp`](../../src/ipc/capnp/chain.capnp)` file in [`src/ipc/capnp/`](../../src/ipc/capnp/).\n+\n+3. **Request Preparation and Dispatch**\n+   - The generated `Chain` subclass in `bitcoin-wallet` populates a Cap’n Proto request with the `height` parameter.\n+   - The request is sent to the `bitcoin-node` process.\n+\n+4. **Handling in bitcoin-node**\n+   - Upon receiving the request, the `bitcoin-node` process reads the `height` value from the request.\n+   - It then calls the `getBlockHash` method on its local `Chain` object with the provided `height`.\n+\n+5. **Response and Return**\n+   - The `bitcoin-node` process takes the `getBlockHash` return value, encapsulates it in a Cap’n Proto response, and sends it back to the `bitcoin-wallet` process.\n+   - The `bitcoin-wallet` process receives the response, extracts the block hash value, and returns it to the original caller.\n+\n+## Future Enhancements\n+\n+Further improvements are possible such as:\n+\n+- Separating indexes from `bitcoin-node`, and running indexing code in separate processes.\n+- Enabling wallet processes to listen for JSON-RPC requests on their own ports instead of needing the node process to listen and forward requests to them.\n+- Automatically generating `.capnp` files from C++ interface definitions (see [Interface Definition Maintenance](#interface-definition-maintenance))\n+- Simplifying and stabilizing interfaces (see [Interface Stability](#interface-stability))\n+- Adding sandbox features, restricting subprocess access to resources and data (see [https://eklitzke.org/multiprocess-bitcoin](https://eklitzke.org/multiprocess-bitcoin)).",
      "path": "doc/design/multiprocess.md",
      "position": 273,
      "original_position": 222,
      "commit_id": "91dc48c14825a9075a57c1eefda202b83b6346ba",
      "original_commit_id": "f566245147003648099f961306be82ea32ea47ae",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "- Generating server / client code in different langages (e.g C++ -> Rust or Rust -> C++) from a common set of `capnp` files and with compatible interfaces.\r\n\r\nTested capnp rust code generation a while back works well, though never been as a far as being able to bridge process written in different langages.",
      "created_at": "2023-12-04T02:53:51Z",
      "updated_at": "2023-12-04T02:55:18Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28978#discussion_r1413316233",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1413316233"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28978"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 214,
      "original_line": 214,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1414593514",
      "pull_request_review_id": 1763577959,
      "id": 1414593514,
      "node_id": "PRRC_kwDOABII585UUPvq",
      "diff_hunk": "@@ -1,72 +1,199 @@\n-# Multiprocess Bitcoin\n-\n-On unix systems, the `--enable-multiprocess` build option can be passed to `./configure` to build new `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables alongside existing `bitcoind` and `bitcoin-qt` executables.\n-\n-`bitcoin-node` is a drop-in replacement for `bitcoind`, and `bitcoin-gui` is a drop-in replacement for `bitcoin-qt`, and there are no differences in use or external behavior between the new and old executables. But internally (after [#10102](https://github.com/bitcoin/bitcoin/pull/10102)), `bitcoin-gui` will spawn a `bitcoin-node` process to run P2P and RPC code, communicating with it across a socket pair, and `bitcoin-node` will spawn `bitcoin-wallet` to run wallet code, also communicating over a socket pair. This will let node, wallet, and GUI code run in separate address spaces for better isolation, and allow future improvements like being able to start and stop components independently on different machines and environments.\n-\n-## Next steps\n-\n-Specific next steps after [#10102](https://github.com/bitcoin/bitcoin/pull/10102) will be:\n-\n-- [ ] Adding `-ipcbind` and `-ipcconnect` options to `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables so they can listen and connect to TCP ports and unix socket paths. This will allow separate processes to be started and stopped any time and connect to each other.\n-- [ ] Adding `-server` and `-rpcbind` options to the `bitcoin-wallet` executable so wallet processes can handle RPC requests directly without going through the node.\n-- [ ] Supporting windows, not just unix systems. The existing socket code is already cross-platform, so the only windows-specific code that needs to be written is code spawning a process and passing a socket descriptor. This can be implemented with `CreateProcess` and `WSADuplicateSocket`. Example: https://memset.wordpress.com/2010/10/13/win32-api-passing-socket-with-ipc-method/.\n-- [ ] Adding sandbox features, restricting subprocess access to resources and data. See [https://eklitzke.org/multiprocess-bitcoin](https://eklitzke.org/multiprocess-bitcoin).\n-\n-## Debugging\n-\n-The `-debug=ipc` command line option can be used to see requests and responses between processes.\n-\n-## Installation\n-\n-The multiprocess feature requires [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) as dependencies. A simple way to get starting using it without installing these dependencies manually is to use the [depends system](../../depends) with the `MULTIPROCESS=1` [dependency option](../../depends#dependency-options) passed to make:\n-\n-```\n-cd <BITCOIN_SOURCE_DIRECTORY>\n-make -C depends NO_QT=1 MULTIPROCESS=1\n-CONFIG_SITE=$PWD/depends/x86_64-pc-linux-gnu/share/config.site ./configure\n-make\n-src/bitcoin-node -regtest -printtoconsole -debug=ipc\n-BITCOIND=bitcoin-node test/functional/test_runner.py\n-```\n-\n-The configure script will pick up settings and library locations from the depends directory, so there is no need to pass `--enable-multiprocess` as a separate flag when using the depends system (it's controlled by the `MULTIPROCESS=1` option).\n-\n-Alternately, you can install [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) packages on your system, and just run `./configure --enable-multiprocess` without using the depends system. The configure script will be able to locate the installed packages via [pkg-config](https://www.freedesktop.org/wiki/Software/pkg-config/). See [Installation](https://github.com/chaincodelabs/libmultiprocess/blob/master/doc/install.md) section of the libmultiprocess readme for install steps. See [build-unix.md](../build-unix.md) and [build-osx.md](../build-osx.md) for information about installing dependencies in general.\n-\n-## IPC implementation details\n-\n-Cross process Node, Wallet, and Chain interfaces are defined in\n-[`src/interfaces/`](../../src/interfaces/). These are C++ classes which follow\n-[conventions](../developer-notes.md#internal-interface-guidelines), like passing\n-serializable arguments so they can be called from different processes, and\n-making methods pure virtual so they can have proxy implementations that forward\n-calls between processes.\n-\n-When Wallet, Node, and Chain code is running in the same process, calling any\n-interface method invokes the implementation directly. When code is running in\n-different processes, calling an interface method invokes a proxy interface\n-implementation that communicates with a remote process and invokes the real\n-implementation in the remote process. The\n-[libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) code\n-generation tool internally generates proxy client classes and proxy server\n-classes for this purpose that are thin wrappers around Cap'n Proto\n-[client](https://capnproto.org/cxxrpc.html#clients) and\n-[server](https://capnproto.org/cxxrpc.html#servers) classes, which handle the\n-actual serialization and socket communication.\n-\n-As much as possible, calls between processes are meant to work the same as\n-calls within a single process without adding limitations or requiring extra\n-implementation effort. Processes communicate with each other by calling regular\n-[C++ interface methods](../../src/interfaces/README.md). Method arguments and\n-return values are automatically serialized and sent between processes. Object\n-references and `std::function` arguments are automatically tracked and mapped\n-to allow invoked code to call back into invoking code at any time, and there is\n-a 1:1 threading model where any thread invoking a method in another process has\n-a corresponding thread in the invoked process responsible for executing all\n-method calls from the source thread, without blocking I/O or holding up another\n-call, and using the same thread local variables, locks, and callbacks between\n-calls. The forwarding, tracking, and threading is implemented inside the\n-[libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) library\n-which has the design goal of making calls between processes look like calls in\n-the same process to the extent possible.\n+# Multiprocess Bitcoin Design Document\n+\n+Guide to the design and architecture of the Bitcoin-Core multiprocess feature\n+\n+_This document describes the design of the multiprocess feature. For usage information, see the top-level [multiprocess.md](../multiprocess.md) file._\n+\n+## Table of contents\n+\n+- [Introduction](#introduction)\n+- [Current Architecture](#current-architecture)\n+- [Proposed Architecture](#proposed-architecture)\n+- [Component Overview: Navigating the IPC Framework](#component-overview-navigating-the-ipc-framework)\n+- [Design Considerations](#design-considerations)\n+  - [Selection of Cap’n Proto](#selection-of-capn-proto)\n+  - [Hiding IPC](#hiding-ipc)\n+  - [Interface Definition Maintenance](#interface-definition-maintenance)\n+  - [Interface Stability](#interface-stability)\n+- [Example Use Cases and Flows](#example-use-cases-and-flows)\n+  - [Retrieving a Block Hash](#retrieving-a-block-hash)\n+- [Future Enhancements](#future-enhancements)\n+- [Conclusion](#conclusion)\n+- [Appendices](#appendices)\n+  - [Glossary of Terms](#glossary-of-terms)\n+  - [References](#references)\n+- [Acknowledgements](#acknowledgements)\n+\n+## Introduction\n+\n+The Bitcoin Core software, central to the Bitcoin network, has historically employed a monolithic architecture. The existing design has integrated functionality like P2P network operations, wallet management, and a GUI into a single executable. While effective, it has limitations in flexibility, security, and scalability. This project introduces changes that transition Bitcoin Core to a more modular architecture. It aims to enhance security, improve usability, and facilitate maintenance and development of the software.\n+\n+## Current Architecture\n+\n+The current system features two primary executables: `bitcoind` and `bitcoin-qt`. `bitcoind` combines a Bitcoin P2P node with an integrated JSON-RPC server, wallet, and indexes. `bitcoin-qt` extends this by incorporating a Qt-based GUI. This monolithic structure, although robust, presents challenges such as limited operational flexibility and increased security risks due to the tight integration of components.\n+\n+## Proposed Architecture\n+\n+The new architecture divides the existing code into three specialized executables:\n+\n+- `bitcoin-node`: Manages the node, indexes, and JSON-RPC server.\n+- `bitcoin-wallet`: Handles all wallet functionality.\n+- `bitcoin-gui`: Provides a standalone Qt-based GUI.\n+\n+This modular approach is designed to enhance security through component isolation and improve usability by allowing independent operation of each module. This allows for new use-cases, such as running the node on a dedicated machine and operating wallets and GUIs on separate machines with the flexibility to start and stop them as needed.\n+\n+This subdivision could be extended in the future. For example, indexes could be removed from the `bitcoin-node` executable and run in separate executables. And JSON-RPC servers could be added to wallet and index executables, so they can listen and respond to RPC requests on their own ports, without needing to forward RPC requests through `bitcoin-node`.\n+\n+## Component Overview: Navigating the IPC Framework\n+\n+This section describes the major components of the Inter-Process Communication (IPC) framework covering the relevant source files, generated files, tools, and libraries.\n+\n+### Abstract C++ Classes in [`src/interfaces/`](../../src/interfaces/)\n+- The foundation of the IPC implementation lies in the abstract C++ classes within the [`src/interfaces/`](../../src/interfaces/) directory. These classes define pure virtual methods that code in [`src/node/`](../../src/node/), [`src/wallet/`](../../src/wallet/), and [`src/qt/`](../../src/qt/) directories call to interact with each other.\n+- Each abstract class in this directory represents a distinct interface that the different modules (node, wallet, GUI) implement and use for cross-process communication.\n+- The classes are written following conventions described in [Internal Interface\n+  Guidelines](../developer-notes.md#internal-interface-guidelines) to ensure\n+  compatibility with Cap'n Proto.\n+\n+### Cap’n Proto Files in [`src/ipc/capnp/`](../../src/ipc/capnp/)\n+- Corresponding to each abstract class, there are `.capnp` files within the [`src/ipc/capnp/`](../../src/ipc/capnp/) directory. These files are used as input to the `mpgen` tool (described below) to generate C++ code.\n+- These Cap’n Proto files ([learn more about Cap'n Proto RPC](https://capnproto.org/rpc.html)) define the structure and format of messages that are exchanged over IPC. They serve as blueprints for generating C++ code that bridges the gap between high-level C++ interfaces and low-level socket communication.\n+\n+### The `mpgen` Code Generation Tool\n+- A central component of the IPC framework is the `mpgen` tool which is part the [`libmultiprocess` project](https://github.com/chaincodelabs/libmultiprocess). This tool takes the `.capnp` files as input and generates C++ code.\n+- The generated code handles IPC communication, translating interface calls into socket reads and writes.\n+\n+### C++ Client Subclasses in Generated Code\n+- In the generated code, we have C++ client subclasses that inherit from the abstract classes in [`src/interfaces/`](../../src/interfaces/). These subclasses are the workhorses of the IPC mechanism.\n+- They implement all the methods of the interface, marshalling arguments into a structured format, sending them as requests to the IPC server via a UNIX socket, and handling the responses.\n+- These subclasses effectively mask the complexity of IPC, presenting a familiar C++ interface to developers.\n+- Internally, the client subclasses generated by the `mpgen` tool wrap [client classes generated by Cap'n Proto](https://capnproto.org/cxxrpc.html#clients), and use them to send IPC requests.\n+\n+### C++ Server Classes in Generated Code\n+- On the server side, corresponding generated C++ classes receive IPC requests. These server classes are responsible for unmarshalling method arguments, invoking the corresponding methods in the local [`src/interfaces/`](../../src/interfaces/) objects, and creating the IPC response.\n+- The server classes ensure that return values (including output argument values and thrown exceptions) are marshalled and sent back to the client, completing the communication cycle.\n+- Internally, the server subclasses generated by the `mpgen` tool inherit from [server classes generated by Cap'n Proto](https://capnproto.org/cxxrpc.html#servers), and use them to process IPC requests.\n+\n+### The `libmultiprocess` Runtime Library\n+- **Core Functionality**: The `libmultiprocess` runtime library's primary function is to instantiate the generated client and server classes as needed.\n+- **Bootstrapping IPC Connections**: It provides functions for starting new IPC connections, specifically binding generated client and server classes for an initial `interfaces::Init` interface (defined in [`src/interfaces/init.h`](../../src/interfaces/init.h)) to a UNIX socket. This initial interface has methods returning other interfaces that different Bitcoin-Core modules use to communicate after the bootstrapping phase.\n+- **Asynchronous I/O and Thread Management**: The library is also responsible for managing I/O and threading. Particularly, it ensures that IPC requests never block each other and that new threads on either side of a connection can always make client calls. It also manages worker threads on the server side of calls, ensuring that calls from the same client thread always execute on the same server thread (to avoid locking issues and support nested callbacks).\n+\n+### Type Hooks in [`src/ipc/capnp/*-types.h`](../../src/ipc/capnp/)\n+- **Custom Type Conversions**: In [`src/ipc/capnp/*-types.h`](../../src/ipc/capnp/), multiple function overloads of two `libmultiprocess` C++ functions, `mp::CustomReadField` and `mp::CustomBuildFields`, are defined. These functions are used for customizing the conversion of specific C++ types to and from Cap’n Proto types.\n+- **Handling Special Cases**: The `mpgen` tool and `libmultiprocess` library can convert most C++ types to and from Cap’n Proto types automatically, including interface types, primitive C++ types, standard C++ types like `std::vector`, `std::set`, `std::map`, `std::tuple`, and `std::function`, as well as simple C++ structs that consist of afforementioned types and whose fields correspond 1:1 with Cap’n Proto struct fields. For other types, `*-types.h` files provide custom code to convert between C++ and Cap’n Proto data representations.\n+\n+### Protocol-Agnostic IPC Code in [`src/ipc/`](../../src/ipc/)\n+- **Broad Applicability**: Unlike the Cap’n Proto-specific code in [`src/ipc/capnp/`](../../src/ipc/capnp/), the code in the [`src/ipc/`](../../src/ipc/) directory is protocol-agnostic. This enables potential support for other protocols, such as gRPC or a custom protocol in the future.\n+- **Process Management and Socket Operations**: The main purpose of this component is to provide functions for spawning new processes and creating and connecting to UNIX sockets.\n+- **ipc::Exception Class**: This code also defines an `ipc::Exception` class which is thrown from the generated C++ client class methods when there is an unexpected IPC error, such as a disconnection.\n+\n+## Design Considerations\n+\n+### Selection of Cap’n Proto\n+The choice to use [Cap’n Proto](https://capnproto.org/) for IPC was primarily influenced by its support for passing object references and managing object lifetimes, which would have to be implemented manually with a framework that only supported plain requests and responses like [gRPC](https://grpc.io/). The support is especially helpful for passing callback objects like `std::function` and supporting bidirectional communication.\n+\n+The choice to use an RPC framework at all instead of a custom protocol was neccesitated by the size of Bitcoin Core internal interfaces which consist of around 150 methods that pass complex data structures and are called in complicated ways (in parallel, from callbacks that can be nested and stored). Writing a custom protocol to wrap these complicated interfaces would be too much work, akin to writing a new RPC framework.\n+\n+### Hiding IPC\n+\n+The IPC mechanism is deliberately isolated from the rest of the codebase so less code has to be concerned with IPC.\n+\n+Building Bitcoin Core with IPC support is optional, and the same code can be compiled to either run in the same process or separate processes. The build system also ensures Cap’n Proto library headers can only be used within the [`src/ipc/capnp/`](../../src/ipc/capnp/) directory, not in other parts of the codebase.\n+\n+The libmultiprocess runtime is designed to place as few constraints as possible on IPC interfaces and make IPC calls act like normal function calls. Method arguments, return values, and exceptions are automatically serialized and sent between processes. Object references and `std::function` arguments are automatically tracked and mapped to allow invoked code to call back into invoking code at any time. And there is a 1:1 threading model where any every client thread has a corresponding server thread responsible for executing incoming calls from that thread (there can be multiple calls from the same thread due to callbacks), without blocking, and holding the same thread-local variables and locks so behavior is the same whether IPC is used or not.\n+\n+### Interface Definition Maintenance\n+\n+The choice to maintain interface definitions and C++ type mappings as `.capnp` files in the [`src/ipc/capnp/`](../../src/ipc/capnp/) was mostly done for convenience, and probably something that could be improved in the future.\n+\n+In the current design, class names, method names, and parameter names are duplicated between C++ interfaces in [`src/interfaces/`](../../src/interfaces/) and Cap’n Proto files in [`src/ipc/capnp/`](../../src/ipc/capnp/). While this keeps C++ interface headers simple and free of references to IPC, it is a maintence burden because it means inconsistencies between C++ declarations and Cap’n Proto declarations will result in compile errors. (Static type checking ensures these are not runtime errors.)\n+\n+An alternate approach could use custom [C++ Attributes](https://en.cppreference.com/w/cpp/language/attributes) embedded in interface declarations to automatically generate `.capnp` files directly from C++ headers. This has not been pursued because parsing C++ headers is a more complicated than parsing Cap’n Proto interface definitions, especially portably on multiple platforms.\n+\n+### Interface Stability\n+\n+The currently defined IPC interfaces are unstable, and can change freely with no backwards compatibility. The decision to allow this stems from the recognition that our current interfaces are still evolving and not yet ideal for external use. As these interfaces mature and become more refined, there may be an opportunity to declare them stable and use Cap’n Proto's support for protocol evolution ([Cap'n Proto - Evolving Your Protocol](https://capnproto.org/language.html#evolving-your-protocol)) to allow them to be extended while remaining backwards compatible. This could allow different versions of node, GUI, and wallet binaries to interoperate, and potentially open doors for external tools to utilize these interfaces, such as creating custom indexes through a stable indexing interface. However, for now, the priority is to improve the interfaces internally. Given their current state and the advantages of using JSON-RPC for most common tasks, it's more practical to focus on internal development rather than external applicability.\n+\n+## Example Use Cases and Flows\n+\n+### Retrieving a Block Hash\n+\n+Let’s walk through an example where the `bitcoin-wallet` process requests the hash of a block at a specific height from the `bitcoin-node` process. This example demonstrates the practical application of the IPC mechanism, specifically the interplay between C++ method calls and Cap’n Proto-generated RPC calls.\n+\n+1. **Initiation in bitcoin-wallet**\n+   - The wallet process calls the `getBlockHash` method on a `Chain` object. This method is defined as a virtual function in [`src/interfaces/chain.h`](../../src/interfaces/chain.h).\n+\n+2. **Translation to Cap’n Proto RPC**\n+   - The call to `getBlockHash` is translated into a Cap’n Proto RPC call. This translation is handled by code automatically generated by the `mpgen` tool, based on the [`chain.capnp`](../../src/ipc/capnp/chain.capnp)` file in [`src/ipc/capnp/`](../../src/ipc/capnp/).\n+\n+3. **Request Preparation and Dispatch**\n+   - The generated `Chain` subclass in `bitcoin-wallet` populates a Cap’n Proto request with the `height` parameter.\n+   - The request is sent to the `bitcoin-node` process.\n+\n+4. **Handling in bitcoin-node**\n+   - Upon receiving the request, the `bitcoin-node` process reads the `height` value from the request.\n+   - It then calls the `getBlockHash` method on its local `Chain` object with the provided `height`.\n+\n+5. **Response and Return**\n+   - The `bitcoin-node` process takes the `getBlockHash` return value, encapsulates it in a Cap’n Proto response, and sends it back to the `bitcoin-wallet` process.\n+   - The `bitcoin-wallet` process receives the response, extracts the block hash value, and returns it to the original caller.\n+\n+## Future Enhancements\n+\n+Further improvements are possible such as:\n+\n+- Separating indexes from `bitcoin-node`, and running indexing code in separate processes.\n+- Enabling wallet processes to listen for JSON-RPC requests on their own ports instead of needing the node process to listen and forward requests to them.\n+- Automatically generating `.capnp` files from C++ interface definitions (see [Interface Definition Maintenance](#interface-definition-maintenance))\n+- Simplifying and stabilizing interfaces (see [Interface Stability](#interface-stability))\n+- Adding sandbox features, restricting subprocess access to resources and data (see [https://eklitzke.org/multiprocess-bitcoin](https://eklitzke.org/multiprocess-bitcoin)).",
      "path": "doc/design/multiprocess.md",
      "position": 273,
      "original_position": 222,
      "commit_id": "91dc48c14825a9075a57c1eefda202b83b6346ba",
      "original_commit_id": "f566245147003648099f961306be82ea32ea47ae",
      "in_reply_to_id": 1413316233,
      "user": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "re: https://github.com/bitcoin/bitcoin/pull/28978#discussion_r1413316233\r\n\r\n> * Generating server / client code in different langages (e.g C++ -> Rust or Rust -> C++) from a common set of `capnp` files and with compatible interfaces.\r\n\r\nYes, this significant and worth mentioning. Added some information about this and a link the work you mentioned.",
      "created_at": "2023-12-04T22:41:48Z",
      "updated_at": "2023-12-04T22:45:36Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28978#discussion_r1414593514",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1414593514"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28978"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 214,
      "original_line": 214,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1424248273",
      "pull_request_review_id": 1777912181,
      "id": 1424248273,
      "node_id": "PRRC_kwDOABII585U5E3R",
      "diff_hunk": "@@ -1,72 +1,200 @@\n-# Multiprocess Bitcoin\n-\n-On unix systems, the `--enable-multiprocess` build option can be passed to `./configure` to build new `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables alongside existing `bitcoind` and `bitcoin-qt` executables.\n-\n-`bitcoin-node` is a drop-in replacement for `bitcoind`, and `bitcoin-gui` is a drop-in replacement for `bitcoin-qt`, and there are no differences in use or external behavior between the new and old executables. But internally (after [#10102](https://github.com/bitcoin/bitcoin/pull/10102)), `bitcoin-gui` will spawn a `bitcoin-node` process to run P2P and RPC code, communicating with it across a socket pair, and `bitcoin-node` will spawn `bitcoin-wallet` to run wallet code, also communicating over a socket pair. This will let node, wallet, and GUI code run in separate address spaces for better isolation, and allow future improvements like being able to start and stop components independently on different machines and environments.\n-\n-## Next steps\n-\n-Specific next steps after [#10102](https://github.com/bitcoin/bitcoin/pull/10102) will be:\n-\n-- [ ] Adding `-ipcbind` and `-ipcconnect` options to `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables so they can listen and connect to TCP ports and unix socket paths. This will allow separate processes to be started and stopped any time and connect to each other.\n-- [ ] Adding `-server` and `-rpcbind` options to the `bitcoin-wallet` executable so wallet processes can handle RPC requests directly without going through the node.\n-- [ ] Supporting windows, not just unix systems. The existing socket code is already cross-platform, so the only windows-specific code that needs to be written is code spawning a process and passing a socket descriptor. This can be implemented with `CreateProcess` and `WSADuplicateSocket`. Example: https://memset.wordpress.com/2010/10/13/win32-api-passing-socket-with-ipc-method/.\n-- [ ] Adding sandbox features, restricting subprocess access to resources and data. See [https://eklitzke.org/multiprocess-bitcoin](https://eklitzke.org/multiprocess-bitcoin).\n-\n-## Debugging\n-\n-The `-debug=ipc` command line option can be used to see requests and responses between processes.\n-\n-## Installation\n-\n-The multiprocess feature requires [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) as dependencies. A simple way to get starting using it without installing these dependencies manually is to use the [depends system](../../depends) with the `MULTIPROCESS=1` [dependency option](../../depends#dependency-options) passed to make:\n-\n-```\n-cd <BITCOIN_SOURCE_DIRECTORY>\n-make -C depends NO_QT=1 MULTIPROCESS=1\n-CONFIG_SITE=$PWD/depends/x86_64-pc-linux-gnu/share/config.site ./configure\n-make\n-src/bitcoin-node -regtest -printtoconsole -debug=ipc\n-BITCOIND=bitcoin-node test/functional/test_runner.py\n-```\n-\n-The configure script will pick up settings and library locations from the depends directory, so there is no need to pass `--enable-multiprocess` as a separate flag when using the depends system (it's controlled by the `MULTIPROCESS=1` option).\n-\n-Alternately, you can install [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) packages on your system, and just run `./configure --enable-multiprocess` without using the depends system. The configure script will be able to locate the installed packages via [pkg-config](https://www.freedesktop.org/wiki/Software/pkg-config/). See [Installation](https://github.com/chaincodelabs/libmultiprocess/blob/master/doc/install.md) section of the libmultiprocess readme for install steps. See [build-unix.md](../build-unix.md) and [build-osx.md](../build-osx.md) for information about installing dependencies in general.\n-\n-## IPC implementation details\n-\n-Cross process Node, Wallet, and Chain interfaces are defined in\n-[`src/interfaces/`](../../src/interfaces/). These are C++ classes which follow\n-[conventions](../developer-notes.md#internal-interface-guidelines), like passing\n-serializable arguments so they can be called from different processes, and\n-making methods pure virtual so they can have proxy implementations that forward\n-calls between processes.\n-\n-When Wallet, Node, and Chain code is running in the same process, calling any\n-interface method invokes the implementation directly. When code is running in\n-different processes, calling an interface method invokes a proxy interface\n-implementation that communicates with a remote process and invokes the real\n-implementation in the remote process. The\n-[libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) code\n-generation tool internally generates proxy client classes and proxy server\n-classes for this purpose that are thin wrappers around Cap'n Proto\n-[client](https://capnproto.org/cxxrpc.html#clients) and\n-[server](https://capnproto.org/cxxrpc.html#servers) classes, which handle the\n-actual serialization and socket communication.\n-\n-As much as possible, calls between processes are meant to work the same as\n-calls within a single process without adding limitations or requiring extra\n-implementation effort. Processes communicate with each other by calling regular\n-[C++ interface methods](../../src/interfaces/README.md). Method arguments and\n-return values are automatically serialized and sent between processes. Object\n-references and `std::function` arguments are automatically tracked and mapped\n-to allow invoked code to call back into invoking code at any time, and there is\n-a 1:1 threading model where any thread invoking a method in another process has\n-a corresponding thread in the invoked process responsible for executing all\n-method calls from the source thread, without blocking I/O or holding up another\n-call, and using the same thread local variables, locks, and callbacks between\n-calls. The forwarding, tracking, and threading is implemented inside the\n-[libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) library\n-which has the design goal of making calls between processes look like calls in\n-the same process to the extent possible.\n+# Multiprocess Bitcoin Design Document\n+\n+Guide to the design and architecture of the Bitcoin-Core multiprocess feature\n+\n+_This document describes the design of the multiprocess feature. For usage information, see the top-level [multiprocess.md](../multiprocess.md) file._\n+\n+## Table of contents\n+\n+- [Introduction](#introduction)\n+- [Current Architecture](#current-architecture)\n+- [Proposed Architecture](#proposed-architecture)\n+- [Component Overview: Navigating the IPC Framework](#component-overview-navigating-the-ipc-framework)\n+- [Design Considerations](#design-considerations)\n+  - [Selection of Cap’n Proto](#selection-of-capn-proto)\n+  - [Hiding IPC](#hiding-ipc)\n+  - [Interface Definition Maintenance](#interface-definition-maintenance)\n+  - [Interface Stability](#interface-stability)\n+- [Example Use Cases and Flows](#example-use-cases-and-flows)\n+  - [Retrieving a Block Hash](#retrieving-a-block-hash)\n+- [Future Enhancements](#future-enhancements)\n+- [Conclusion](#conclusion)\n+- [Appendices](#appendices)\n+  - [Glossary of Terms](#glossary-of-terms)\n+  - [References](#references)\n+- [Acknowledgements](#acknowledgements)\n+\n+## Introduction\n+\n+The Bitcoin Core software, central to the Bitcoin network, has historically employed a monolithic architecture. The existing design has integrated functionality like P2P network operations, wallet management, and a GUI into a single executable. While effective, it has limitations in flexibility, security, and scalability. This project introduces changes that transition Bitcoin Core to a more modular architecture. It aims to enhance security, improve usability, and facilitate maintenance and development of the software.\n+\n+## Current Architecture\n+\n+The current system features two primary executables: `bitcoind` and `bitcoin-qt`. `bitcoind` combines a Bitcoin P2P node with an integrated JSON-RPC server, wallet, and indexes. `bitcoin-qt` extends this by incorporating a Qt-based GUI. This monolithic structure, although robust, presents challenges such as limited operational flexibility and increased security risks due to the tight integration of components.\n+\n+## Proposed Architecture\n+\n+The new architecture divides the existing code into three specialized executables:\n+\n+- `bitcoin-node`: Manages the node, indexes, and JSON-RPC server.\n+- `bitcoin-wallet`: Handles all wallet functionality.\n+- `bitcoin-gui`: Provides a standalone Qt-based GUI.\n+\n+This modular approach is designed to enhance security through component isolation and improve usability by allowing independent operation of each module. This allows for new use-cases, such as running the node on a dedicated machine and operating wallets and GUIs on separate machines with the flexibility to start and stop them as needed.\n+\n+This subdivision could be extended in the future. For example, indexes could be removed from the `bitcoin-node` executable and run in separate executables. And JSON-RPC servers could be added to wallet and index executables, so they can listen and respond to RPC requests on their own ports, without needing to forward RPC requests through `bitcoin-node`.\n+\n+## Component Overview: Navigating the IPC Framework\n+\n+This section describes the major components of the Inter-Process Communication (IPC) framework covering the relevant source files, generated files, tools, and libraries.\n+\n+### Abstract C++ Classes in [`src/interfaces/`](../../src/interfaces/)\n+- The foundation of the IPC implementation lies in the abstract C++ classes within the [`src/interfaces/`](../../src/interfaces/) directory. These classes define pure virtual methods that code in [`src/node/`](../../src/node/), [`src/wallet/`](../../src/wallet/), and [`src/qt/`](../../src/qt/) directories call to interact with each other.\n+- Each abstract class in this directory represents a distinct interface that the different modules (node, wallet, GUI) implement and use for cross-process communication.\n+- The classes are written following conventions described in [Internal Interface\n+  Guidelines](../developer-notes.md#internal-interface-guidelines) to ensure\n+  compatibility with Cap'n Proto.\n+\n+### Cap’n Proto Files in [`src/ipc/capnp/`](../../src/ipc/capnp/)\n+- Corresponding to each abstract class, there are `.capnp` files within the [`src/ipc/capnp/`](../../src/ipc/capnp/) directory. These files are used as input to the `mpgen` tool (described below) to generate C++ code.\n+- These Cap’n Proto files ([learn more about Cap'n Proto RPC](https://capnproto.org/rpc.html)) define the structure and format of messages that are exchanged over IPC. They serve as blueprints for generating C++ code that bridges the gap between high-level C++ interfaces and low-level socket communication.\n+\n+### The `mpgen` Code Generation Tool\n+- A central component of the IPC framework is the `mpgen` tool which is part the [`libmultiprocess` project](https://github.com/chaincodelabs/libmultiprocess). This tool takes the `.capnp` files as input and generates C++ code.\n+- The generated code handles IPC communication, translating interface calls into socket reads and writes.\n+\n+### C++ Client Subclasses in Generated Code\n+- In the generated code, we have C++ client subclasses that inherit from the abstract classes in [`src/interfaces/`](../../src/interfaces/). These subclasses are the workhorses of the IPC mechanism.\n+- They implement all the methods of the interface, marshalling arguments into a structured format, sending them as requests to the IPC server via a UNIX socket, and handling the responses.\n+- These subclasses effectively mask the complexity of IPC, presenting a familiar C++ interface to developers.\n+- Internally, the client subclasses generated by the `mpgen` tool wrap [client classes generated by Cap'n Proto](https://capnproto.org/cxxrpc.html#clients), and use them to send IPC requests.\n+\n+### C++ Server Classes in Generated Code\n+- On the server side, corresponding generated C++ classes receive IPC requests. These server classes are responsible for unmarshalling method arguments, invoking the corresponding methods in the local [`src/interfaces/`](../../src/interfaces/) objects, and creating the IPC response.\n+- The server classes ensure that return values (including output argument values and thrown exceptions) are marshalled and sent back to the client, completing the communication cycle.\n+- Internally, the server subclasses generated by the `mpgen` tool inherit from [server classes generated by Cap'n Proto](https://capnproto.org/cxxrpc.html#servers), and use them to process IPC requests.\n+\n+### The `libmultiprocess` Runtime Library\n+- **Core Functionality**: The `libmultiprocess` runtime library's primary function is to instantiate the generated client and server classes as needed.\n+- **Bootstrapping IPC Connections**: It provides functions for starting new IPC connections, specifically binding generated client and server classes for an initial `interfaces::Init` interface (defined in [`src/interfaces/init.h`](../../src/interfaces/init.h)) to a UNIX socket. This initial interface has methods returning other interfaces that different Bitcoin-Core modules use to communicate after the bootstrapping phase.\n+- **Asynchronous I/O and Thread Management**: The library is also responsible for managing I/O and threading. Particularly, it ensures that IPC requests never block each other and that new threads on either side of a connection can always make client calls. It also manages worker threads on the server side of calls, ensuring that calls from the same client thread always execute on the same server thread (to avoid locking issues and support nested callbacks).\n+\n+### Type Hooks in [`src/ipc/capnp/*-types.h`](../../src/ipc/capnp/)\n+- **Custom Type Conversions**: In [`src/ipc/capnp/*-types.h`](../../src/ipc/capnp/), multiple function overloads of two `libmultiprocess` C++ functions, `mp::CustomReadField` and `mp::CustomBuildFields`, are defined. These functions are used for customizing the conversion of specific C++ types to and from Cap’n Proto types.\n+- **Handling Special Cases**: The `mpgen` tool and `libmultiprocess` library can convert most C++ types to and from Cap’n Proto types automatically, including interface types, primitive C++ types, standard C++ types like `std::vector`, `std::set`, `std::map`, `std::tuple`, and `std::function`, as well as simple C++ structs that consist of afforementioned types and whose fields correspond 1:1 with Cap’n Proto struct fields. For other types, `*-types.h` files provide custom code to convert between C++ and Cap’n Proto data representations.\n+\n+### Protocol-Agnostic IPC Code in [`src/ipc/`](../../src/ipc/)\n+- **Broad Applicability**: Unlike the Cap’n Proto-specific code in [`src/ipc/capnp/`](../../src/ipc/capnp/), the code in the [`src/ipc/`](../../src/ipc/) directory is protocol-agnostic. This enables potential support for other protocols, such as gRPC or a custom protocol in the future.\n+- **Process Management and Socket Operations**: The main purpose of this component is to provide functions for spawning new processes and creating and connecting to UNIX sockets.\n+- **ipc::Exception Class**: This code also defines an `ipc::Exception` class which is thrown from the generated C++ client class methods when there is an unexpected IPC error, such as a disconnection.\n+\n+## Design Considerations\n+\n+### Selection of Cap’n Proto\n+The choice to use [Cap’n Proto](https://capnproto.org/) for IPC was primarily influenced by its support for passing object references and managing object lifetimes, which would have to be implemented manually with a framework that only supported plain requests and responses like [gRPC](https://grpc.io/). The support is especially helpful for passing callback objects like `std::function` and supporting bidirectional communication.\n+\n+The choice to use an RPC framework at all instead of a custom protocol was neccesitated by the size of Bitcoin Core internal interfaces which consist of around 150 methods that pass complex data structures and are called in complicated ways (in parallel, from callbacks that can be nested and stored). Writing a custom protocol to wrap these complicated interfaces would be too much work, akin to writing a new RPC framework.",
      "path": "doc/design/multiprocess.md",
      "position": null,
      "original_position": 168,
      "commit_id": "91dc48c14825a9075a57c1eefda202b83b6346ba",
      "original_commit_id": "837c53d14f24924cdcb2cfd8b18915882dc3b620",
      "in_reply_to_id": null,
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "typo nit\r\n```suggestion\r\nThe choice to use an RPC framework at all instead of a custom protocol was necessitated by the size of Bitcoin Core internal interfaces which consist of around 150 methods that pass complex data structures and are called in complicated ways (in parallel, from callbacks that can be nested and stored). Writing a custom protocol to wrap these complicated interfaces would be too much work, akin to writing a new RPC framework.\r\n```",
      "created_at": "2023-12-12T16:17:17Z",
      "updated_at": "2023-12-12T17:45:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28978#discussion_r1424248273",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1424248273"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28978"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 96,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1424249827",
      "pull_request_review_id": 1777912181,
      "id": 1424249827,
      "node_id": "PRRC_kwDOABII585U5FPj",
      "diff_hunk": "@@ -1,72 +1,200 @@\n-# Multiprocess Bitcoin\n-\n-On unix systems, the `--enable-multiprocess` build option can be passed to `./configure` to build new `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables alongside existing `bitcoind` and `bitcoin-qt` executables.\n-\n-`bitcoin-node` is a drop-in replacement for `bitcoind`, and `bitcoin-gui` is a drop-in replacement for `bitcoin-qt`, and there are no differences in use or external behavior between the new and old executables. But internally (after [#10102](https://github.com/bitcoin/bitcoin/pull/10102)), `bitcoin-gui` will spawn a `bitcoin-node` process to run P2P and RPC code, communicating with it across a socket pair, and `bitcoin-node` will spawn `bitcoin-wallet` to run wallet code, also communicating over a socket pair. This will let node, wallet, and GUI code run in separate address spaces for better isolation, and allow future improvements like being able to start and stop components independently on different machines and environments.\n-\n-## Next steps\n-\n-Specific next steps after [#10102](https://github.com/bitcoin/bitcoin/pull/10102) will be:\n-\n-- [ ] Adding `-ipcbind` and `-ipcconnect` options to `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables so they can listen and connect to TCP ports and unix socket paths. This will allow separate processes to be started and stopped any time and connect to each other.\n-- [ ] Adding `-server` and `-rpcbind` options to the `bitcoin-wallet` executable so wallet processes can handle RPC requests directly without going through the node.\n-- [ ] Supporting windows, not just unix systems. The existing socket code is already cross-platform, so the only windows-specific code that needs to be written is code spawning a process and passing a socket descriptor. This can be implemented with `CreateProcess` and `WSADuplicateSocket`. Example: https://memset.wordpress.com/2010/10/13/win32-api-passing-socket-with-ipc-method/.\n-- [ ] Adding sandbox features, restricting subprocess access to resources and data. See [https://eklitzke.org/multiprocess-bitcoin](https://eklitzke.org/multiprocess-bitcoin).\n-\n-## Debugging\n-\n-The `-debug=ipc` command line option can be used to see requests and responses between processes.\n-\n-## Installation\n-\n-The multiprocess feature requires [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) as dependencies. A simple way to get starting using it without installing these dependencies manually is to use the [depends system](../../depends) with the `MULTIPROCESS=1` [dependency option](../../depends#dependency-options) passed to make:\n-\n-```\n-cd <BITCOIN_SOURCE_DIRECTORY>\n-make -C depends NO_QT=1 MULTIPROCESS=1\n-CONFIG_SITE=$PWD/depends/x86_64-pc-linux-gnu/share/config.site ./configure\n-make\n-src/bitcoin-node -regtest -printtoconsole -debug=ipc\n-BITCOIND=bitcoin-node test/functional/test_runner.py\n-```\n-\n-The configure script will pick up settings and library locations from the depends directory, so there is no need to pass `--enable-multiprocess` as a separate flag when using the depends system (it's controlled by the `MULTIPROCESS=1` option).\n-\n-Alternately, you can install [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) packages on your system, and just run `./configure --enable-multiprocess` without using the depends system. The configure script will be able to locate the installed packages via [pkg-config](https://www.freedesktop.org/wiki/Software/pkg-config/). See [Installation](https://github.com/chaincodelabs/libmultiprocess/blob/master/doc/install.md) section of the libmultiprocess readme for install steps. See [build-unix.md](../build-unix.md) and [build-osx.md](../build-osx.md) for information about installing dependencies in general.\n-\n-## IPC implementation details\n-\n-Cross process Node, Wallet, and Chain interfaces are defined in\n-[`src/interfaces/`](../../src/interfaces/). These are C++ classes which follow\n-[conventions](../developer-notes.md#internal-interface-guidelines), like passing\n-serializable arguments so they can be called from different processes, and\n-making methods pure virtual so they can have proxy implementations that forward\n-calls between processes.\n-\n-When Wallet, Node, and Chain code is running in the same process, calling any\n-interface method invokes the implementation directly. When code is running in\n-different processes, calling an interface method invokes a proxy interface\n-implementation that communicates with a remote process and invokes the real\n-implementation in the remote process. The\n-[libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) code\n-generation tool internally generates proxy client classes and proxy server\n-classes for this purpose that are thin wrappers around Cap'n Proto\n-[client](https://capnproto.org/cxxrpc.html#clients) and\n-[server](https://capnproto.org/cxxrpc.html#servers) classes, which handle the\n-actual serialization and socket communication.\n-\n-As much as possible, calls between processes are meant to work the same as\n-calls within a single process without adding limitations or requiring extra\n-implementation effort. Processes communicate with each other by calling regular\n-[C++ interface methods](../../src/interfaces/README.md). Method arguments and\n-return values are automatically serialized and sent between processes. Object\n-references and `std::function` arguments are automatically tracked and mapped\n-to allow invoked code to call back into invoking code at any time, and there is\n-a 1:1 threading model where any thread invoking a method in another process has\n-a corresponding thread in the invoked process responsible for executing all\n-method calls from the source thread, without blocking I/O or holding up another\n-call, and using the same thread local variables, locks, and callbacks between\n-calls. The forwarding, tracking, and threading is implemented inside the\n-[libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) library\n-which has the design goal of making calls between processes look like calls in\n-the same process to the extent possible.\n+# Multiprocess Bitcoin Design Document\n+\n+Guide to the design and architecture of the Bitcoin-Core multiprocess feature\n+\n+_This document describes the design of the multiprocess feature. For usage information, see the top-level [multiprocess.md](../multiprocess.md) file._\n+\n+## Table of contents\n+\n+- [Introduction](#introduction)\n+- [Current Architecture](#current-architecture)\n+- [Proposed Architecture](#proposed-architecture)\n+- [Component Overview: Navigating the IPC Framework](#component-overview-navigating-the-ipc-framework)\n+- [Design Considerations](#design-considerations)\n+  - [Selection of Cap’n Proto](#selection-of-capn-proto)\n+  - [Hiding IPC](#hiding-ipc)\n+  - [Interface Definition Maintenance](#interface-definition-maintenance)\n+  - [Interface Stability](#interface-stability)\n+- [Example Use Cases and Flows](#example-use-cases-and-flows)\n+  - [Retrieving a Block Hash](#retrieving-a-block-hash)\n+- [Future Enhancements](#future-enhancements)\n+- [Conclusion](#conclusion)\n+- [Appendices](#appendices)\n+  - [Glossary of Terms](#glossary-of-terms)\n+  - [References](#references)\n+- [Acknowledgements](#acknowledgements)\n+\n+## Introduction\n+\n+The Bitcoin Core software, central to the Bitcoin network, has historically employed a monolithic architecture. The existing design has integrated functionality like P2P network operations, wallet management, and a GUI into a single executable. While effective, it has limitations in flexibility, security, and scalability. This project introduces changes that transition Bitcoin Core to a more modular architecture. It aims to enhance security, improve usability, and facilitate maintenance and development of the software.\n+\n+## Current Architecture\n+\n+The current system features two primary executables: `bitcoind` and `bitcoin-qt`. `bitcoind` combines a Bitcoin P2P node with an integrated JSON-RPC server, wallet, and indexes. `bitcoin-qt` extends this by incorporating a Qt-based GUI. This monolithic structure, although robust, presents challenges such as limited operational flexibility and increased security risks due to the tight integration of components.\n+\n+## Proposed Architecture\n+\n+The new architecture divides the existing code into three specialized executables:\n+\n+- `bitcoin-node`: Manages the node, indexes, and JSON-RPC server.\n+- `bitcoin-wallet`: Handles all wallet functionality.\n+- `bitcoin-gui`: Provides a standalone Qt-based GUI.\n+\n+This modular approach is designed to enhance security through component isolation and improve usability by allowing independent operation of each module. This allows for new use-cases, such as running the node on a dedicated machine and operating wallets and GUIs on separate machines with the flexibility to start and stop them as needed.\n+\n+This subdivision could be extended in the future. For example, indexes could be removed from the `bitcoin-node` executable and run in separate executables. And JSON-RPC servers could be added to wallet and index executables, so they can listen and respond to RPC requests on their own ports, without needing to forward RPC requests through `bitcoin-node`.\n+\n+## Component Overview: Navigating the IPC Framework\n+\n+This section describes the major components of the Inter-Process Communication (IPC) framework covering the relevant source files, generated files, tools, and libraries.\n+\n+### Abstract C++ Classes in [`src/interfaces/`](../../src/interfaces/)\n+- The foundation of the IPC implementation lies in the abstract C++ classes within the [`src/interfaces/`](../../src/interfaces/) directory. These classes define pure virtual methods that code in [`src/node/`](../../src/node/), [`src/wallet/`](../../src/wallet/), and [`src/qt/`](../../src/qt/) directories call to interact with each other.\n+- Each abstract class in this directory represents a distinct interface that the different modules (node, wallet, GUI) implement and use for cross-process communication.\n+- The classes are written following conventions described in [Internal Interface\n+  Guidelines](../developer-notes.md#internal-interface-guidelines) to ensure\n+  compatibility with Cap'n Proto.\n+\n+### Cap’n Proto Files in [`src/ipc/capnp/`](../../src/ipc/capnp/)\n+- Corresponding to each abstract class, there are `.capnp` files within the [`src/ipc/capnp/`](../../src/ipc/capnp/) directory. These files are used as input to the `mpgen` tool (described below) to generate C++ code.\n+- These Cap’n Proto files ([learn more about Cap'n Proto RPC](https://capnproto.org/rpc.html)) define the structure and format of messages that are exchanged over IPC. They serve as blueprints for generating C++ code that bridges the gap between high-level C++ interfaces and low-level socket communication.\n+\n+### The `mpgen` Code Generation Tool\n+- A central component of the IPC framework is the `mpgen` tool which is part the [`libmultiprocess` project](https://github.com/chaincodelabs/libmultiprocess). This tool takes the `.capnp` files as input and generates C++ code.\n+- The generated code handles IPC communication, translating interface calls into socket reads and writes.\n+\n+### C++ Client Subclasses in Generated Code\n+- In the generated code, we have C++ client subclasses that inherit from the abstract classes in [`src/interfaces/`](../../src/interfaces/). These subclasses are the workhorses of the IPC mechanism.\n+- They implement all the methods of the interface, marshalling arguments into a structured format, sending them as requests to the IPC server via a UNIX socket, and handling the responses.\n+- These subclasses effectively mask the complexity of IPC, presenting a familiar C++ interface to developers.\n+- Internally, the client subclasses generated by the `mpgen` tool wrap [client classes generated by Cap'n Proto](https://capnproto.org/cxxrpc.html#clients), and use them to send IPC requests.\n+\n+### C++ Server Classes in Generated Code\n+- On the server side, corresponding generated C++ classes receive IPC requests. These server classes are responsible for unmarshalling method arguments, invoking the corresponding methods in the local [`src/interfaces/`](../../src/interfaces/) objects, and creating the IPC response.\n+- The server classes ensure that return values (including output argument values and thrown exceptions) are marshalled and sent back to the client, completing the communication cycle.\n+- Internally, the server subclasses generated by the `mpgen` tool inherit from [server classes generated by Cap'n Proto](https://capnproto.org/cxxrpc.html#servers), and use them to process IPC requests.\n+\n+### The `libmultiprocess` Runtime Library\n+- **Core Functionality**: The `libmultiprocess` runtime library's primary function is to instantiate the generated client and server classes as needed.\n+- **Bootstrapping IPC Connections**: It provides functions for starting new IPC connections, specifically binding generated client and server classes for an initial `interfaces::Init` interface (defined in [`src/interfaces/init.h`](../../src/interfaces/init.h)) to a UNIX socket. This initial interface has methods returning other interfaces that different Bitcoin-Core modules use to communicate after the bootstrapping phase.\n+- **Asynchronous I/O and Thread Management**: The library is also responsible for managing I/O and threading. Particularly, it ensures that IPC requests never block each other and that new threads on either side of a connection can always make client calls. It also manages worker threads on the server side of calls, ensuring that calls from the same client thread always execute on the same server thread (to avoid locking issues and support nested callbacks).\n+\n+### Type Hooks in [`src/ipc/capnp/*-types.h`](../../src/ipc/capnp/)\n+- **Custom Type Conversions**: In [`src/ipc/capnp/*-types.h`](../../src/ipc/capnp/), multiple function overloads of two `libmultiprocess` C++ functions, `mp::CustomReadField` and `mp::CustomBuildFields`, are defined. These functions are used for customizing the conversion of specific C++ types to and from Cap’n Proto types.\n+- **Handling Special Cases**: The `mpgen` tool and `libmultiprocess` library can convert most C++ types to and from Cap’n Proto types automatically, including interface types, primitive C++ types, standard C++ types like `std::vector`, `std::set`, `std::map`, `std::tuple`, and `std::function`, as well as simple C++ structs that consist of afforementioned types and whose fields correspond 1:1 with Cap’n Proto struct fields. For other types, `*-types.h` files provide custom code to convert between C++ and Cap’n Proto data representations.\n+\n+### Protocol-Agnostic IPC Code in [`src/ipc/`](../../src/ipc/)\n+- **Broad Applicability**: Unlike the Cap’n Proto-specific code in [`src/ipc/capnp/`](../../src/ipc/capnp/), the code in the [`src/ipc/`](../../src/ipc/) directory is protocol-agnostic. This enables potential support for other protocols, such as gRPC or a custom protocol in the future.\n+- **Process Management and Socket Operations**: The main purpose of this component is to provide functions for spawning new processes and creating and connecting to UNIX sockets.\n+- **ipc::Exception Class**: This code also defines an `ipc::Exception` class which is thrown from the generated C++ client class methods when there is an unexpected IPC error, such as a disconnection.\n+\n+## Design Considerations\n+\n+### Selection of Cap’n Proto\n+The choice to use [Cap’n Proto](https://capnproto.org/) for IPC was primarily influenced by its support for passing object references and managing object lifetimes, which would have to be implemented manually with a framework that only supported plain requests and responses like [gRPC](https://grpc.io/). The support is especially helpful for passing callback objects like `std::function` and supporting bidirectional communication.\n+\n+The choice to use an RPC framework at all instead of a custom protocol was neccesitated by the size of Bitcoin Core internal interfaces which consist of around 150 methods that pass complex data structures and are called in complicated ways (in parallel, from callbacks that can be nested and stored). Writing a custom protocol to wrap these complicated interfaces would be too much work, akin to writing a new RPC framework.\n+\n+### Hiding IPC\n+\n+The IPC mechanism is deliberately isolated from the rest of the codebase so less code has to be concerned with IPC.\n+\n+Building Bitcoin Core with IPC support is optional, and the same code can be compiled to either run in the same process or separate processes. The build system also ensures Cap’n Proto library headers can only be used within the [`src/ipc/capnp/`](../../src/ipc/capnp/) directory, not in other parts of the codebase.\n+\n+The libmultiprocess runtime is designed to place as few constraints as possible on IPC interfaces and make IPC calls act like normal function calls. Method arguments, return values, and exceptions are automatically serialized and sent between processes. Object references and `std::function` arguments are automatically tracked and mapped to allow invoked code to call back into invoking code at any time. And there is a 1:1 threading model where any every client thread has a corresponding server thread responsible for executing incoming calls from that thread (there can be multiple calls from the same thread due to callbacks), without blocking, and holding the same thread-local variables and locks so behavior is the same whether IPC is used or not.\n+\n+### Interface Definition Maintenance\n+\n+The choice to maintain interface definitions and C++ type mappings as `.capnp` files in the [`src/ipc/capnp/`](../../src/ipc/capnp/) was mostly done for convenience, and probably something that could be improved in the future.\n+\n+In the current design, class names, method names, and parameter names are duplicated between C++ interfaces in [`src/interfaces/`](../../src/interfaces/) and Cap’n Proto files in [`src/ipc/capnp/`](../../src/ipc/capnp/). While this keeps C++ interface headers simple and free of references to IPC, it is a maintence burden because it means inconsistencies between C++ declarations and Cap’n Proto declarations will result in compile errors. (Static type checking ensures these are not runtime errors.)\n+\n+An alternate approach could use custom [C++ Attributes](https://en.cppreference.com/w/cpp/language/attributes) embedded in interface declarations to automatically generate `.capnp` files directly from C++ headers. This has not been pursued because parsing C++ headers is more complicated than parsing Cap’n Proto interface definitions, especially portably on multiple platforms.\n+\n+### Interface Stability\n+\n+The currently defined IPC interfaces are unstable, and can change freely with no backwards compatibility. The decision to allow this stems from the recognition that our current interfaces are still evolving and not yet ideal for external use. As these interfaces mature and become more refined, there may be an opportunity to declare them stable and use Cap’n Proto's support for protocol evolution ([Cap'n Proto - Evolving Your Protocol](https://capnproto.org/language.html#evolving-your-protocol)) to allow them to be extended while remaining backwards compatible. This could allow different versions of node, GUI, and wallet binaries to interoperate, and potentially open doors for external tools to utilize these interfaces, such as creating custom indexes through a stable indexing interface. However, for now, the priority is to improve the interfaces internally. Given their current state and the advantages of using JSON-RPC for most common tasks, it's more practical to focus on internal development rather than external applicability.\n+\n+## Example Use Cases and Flows\n+\n+### Retrieving a Block Hash\n+\n+Let’s walk through an example where the `bitcoin-wallet` process requests the hash of a block at a specific height from the `bitcoin-node` process. This example demonstrates the practical application of the IPC mechanism, specifically the interplay between C++ method calls and Cap’n Proto-generated RPC calls.\n+\n+1. **Initiation in bitcoin-wallet**\n+   - The wallet process calls the `getBlockHash` method on a `Chain` object. This method is defined as a virtual function in [`src/interfaces/chain.h`](../../src/interfaces/chain.h).\n+\n+2. **Translation to Cap’n Proto RPC**\n+   - The call to `getBlockHash` is translated into a Cap’n Proto RPC call. This translation is handled by code automatically generated by the `mpgen` tool, based on the [`chain.capnp`](../../src/ipc/capnp/chain.capnp)` file in [`src/ipc/capnp/`](../../src/ipc/capnp/).",
      "path": "doc/design/multiprocess.md",
      "position": null,
      "original_position": 200,
      "commit_id": "91dc48c14825a9075a57c1eefda202b83b6346ba",
      "original_commit_id": "837c53d14f24924cdcb2cfd8b18915882dc3b620",
      "in_reply_to_id": null,
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: rogue backtick\r\n```suggestion\r\n   - The call to `getBlockHash` is translated into a Cap’n Proto RPC call. This translation is handled by code automatically generated by the `mpgen` tool, based on the [`chain.capnp`](../../src/ipc/capnp/chain.capnp) file in [`src/ipc/capnp/`](../../src/ipc/capnp/).\r\n```",
      "created_at": "2023-12-12T16:18:27Z",
      "updated_at": "2023-12-12T17:45:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28978#discussion_r1424249827",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1424249827"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28978"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 128,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1424253642",
      "pull_request_review_id": 1777912181,
      "id": 1424253642,
      "node_id": "PRRC_kwDOABII585U5GLK",
      "diff_hunk": "@@ -1,72 +1,200 @@\n-# Multiprocess Bitcoin\n-\n-On unix systems, the `--enable-multiprocess` build option can be passed to `./configure` to build new `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables alongside existing `bitcoind` and `bitcoin-qt` executables.\n-\n-`bitcoin-node` is a drop-in replacement for `bitcoind`, and `bitcoin-gui` is a drop-in replacement for `bitcoin-qt`, and there are no differences in use or external behavior between the new and old executables. But internally (after [#10102](https://github.com/bitcoin/bitcoin/pull/10102)), `bitcoin-gui` will spawn a `bitcoin-node` process to run P2P and RPC code, communicating with it across a socket pair, and `bitcoin-node` will spawn `bitcoin-wallet` to run wallet code, also communicating over a socket pair. This will let node, wallet, and GUI code run in separate address spaces for better isolation, and allow future improvements like being able to start and stop components independently on different machines and environments.\n-\n-## Next steps\n-\n-Specific next steps after [#10102](https://github.com/bitcoin/bitcoin/pull/10102) will be:\n-\n-- [ ] Adding `-ipcbind` and `-ipcconnect` options to `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables so they can listen and connect to TCP ports and unix socket paths. This will allow separate processes to be started and stopped any time and connect to each other.\n-- [ ] Adding `-server` and `-rpcbind` options to the `bitcoin-wallet` executable so wallet processes can handle RPC requests directly without going through the node.\n-- [ ] Supporting windows, not just unix systems. The existing socket code is already cross-platform, so the only windows-specific code that needs to be written is code spawning a process and passing a socket descriptor. This can be implemented with `CreateProcess` and `WSADuplicateSocket`. Example: https://memset.wordpress.com/2010/10/13/win32-api-passing-socket-with-ipc-method/.\n-- [ ] Adding sandbox features, restricting subprocess access to resources and data. See [https://eklitzke.org/multiprocess-bitcoin](https://eklitzke.org/multiprocess-bitcoin).\n-\n-## Debugging\n-\n-The `-debug=ipc` command line option can be used to see requests and responses between processes.\n-\n-## Installation\n-\n-The multiprocess feature requires [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) as dependencies. A simple way to get starting using it without installing these dependencies manually is to use the [depends system](../../depends) with the `MULTIPROCESS=1` [dependency option](../../depends#dependency-options) passed to make:\n-\n-```\n-cd <BITCOIN_SOURCE_DIRECTORY>\n-make -C depends NO_QT=1 MULTIPROCESS=1\n-CONFIG_SITE=$PWD/depends/x86_64-pc-linux-gnu/share/config.site ./configure\n-make\n-src/bitcoin-node -regtest -printtoconsole -debug=ipc\n-BITCOIND=bitcoin-node test/functional/test_runner.py\n-```\n-\n-The configure script will pick up settings and library locations from the depends directory, so there is no need to pass `--enable-multiprocess` as a separate flag when using the depends system (it's controlled by the `MULTIPROCESS=1` option).\n-\n-Alternately, you can install [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) packages on your system, and just run `./configure --enable-multiprocess` without using the depends system. The configure script will be able to locate the installed packages via [pkg-config](https://www.freedesktop.org/wiki/Software/pkg-config/). See [Installation](https://github.com/chaincodelabs/libmultiprocess/blob/master/doc/install.md) section of the libmultiprocess readme for install steps. See [build-unix.md](../build-unix.md) and [build-osx.md](../build-osx.md) for information about installing dependencies in general.\n-\n-## IPC implementation details\n-\n-Cross process Node, Wallet, and Chain interfaces are defined in\n-[`src/interfaces/`](../../src/interfaces/). These are C++ classes which follow\n-[conventions](../developer-notes.md#internal-interface-guidelines), like passing\n-serializable arguments so they can be called from different processes, and\n-making methods pure virtual so they can have proxy implementations that forward\n-calls between processes.\n-\n-When Wallet, Node, and Chain code is running in the same process, calling any\n-interface method invokes the implementation directly. When code is running in\n-different processes, calling an interface method invokes a proxy interface\n-implementation that communicates with a remote process and invokes the real\n-implementation in the remote process. The\n-[libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) code\n-generation tool internally generates proxy client classes and proxy server\n-classes for this purpose that are thin wrappers around Cap'n Proto\n-[client](https://capnproto.org/cxxrpc.html#clients) and\n-[server](https://capnproto.org/cxxrpc.html#servers) classes, which handle the\n-actual serialization and socket communication.\n-\n-As much as possible, calls between processes are meant to work the same as\n-calls within a single process without adding limitations or requiring extra\n-implementation effort. Processes communicate with each other by calling regular\n-[C++ interface methods](../../src/interfaces/README.md). Method arguments and\n-return values are automatically serialized and sent between processes. Object\n-references and `std::function` arguments are automatically tracked and mapped\n-to allow invoked code to call back into invoking code at any time, and there is\n-a 1:1 threading model where any thread invoking a method in another process has\n-a corresponding thread in the invoked process responsible for executing all\n-method calls from the source thread, without blocking I/O or holding up another\n-call, and using the same thread local variables, locks, and callbacks between\n-calls. The forwarding, tracking, and threading is implemented inside the\n-[libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) library\n-which has the design goal of making calls between processes look like calls in\n-the same process to the extent possible.\n+# Multiprocess Bitcoin Design Document\n+\n+Guide to the design and architecture of the Bitcoin-Core multiprocess feature\n+\n+_This document describes the design of the multiprocess feature. For usage information, see the top-level [multiprocess.md](../multiprocess.md) file._\n+\n+## Table of contents\n+\n+- [Introduction](#introduction)\n+- [Current Architecture](#current-architecture)\n+- [Proposed Architecture](#proposed-architecture)\n+- [Component Overview: Navigating the IPC Framework](#component-overview-navigating-the-ipc-framework)\n+- [Design Considerations](#design-considerations)\n+  - [Selection of Cap’n Proto](#selection-of-capn-proto)\n+  - [Hiding IPC](#hiding-ipc)\n+  - [Interface Definition Maintenance](#interface-definition-maintenance)\n+  - [Interface Stability](#interface-stability)\n+- [Example Use Cases and Flows](#example-use-cases-and-flows)\n+  - [Retrieving a Block Hash](#retrieving-a-block-hash)\n+- [Future Enhancements](#future-enhancements)\n+- [Conclusion](#conclusion)\n+- [Appendices](#appendices)\n+  - [Glossary of Terms](#glossary-of-terms)\n+  - [References](#references)\n+- [Acknowledgements](#acknowledgements)\n+\n+## Introduction\n+\n+The Bitcoin Core software, central to the Bitcoin network, has historically employed a monolithic architecture. The existing design has integrated functionality like P2P network operations, wallet management, and a GUI into a single executable. While effective, it has limitations in flexibility, security, and scalability. This project introduces changes that transition Bitcoin Core to a more modular architecture. It aims to enhance security, improve usability, and facilitate maintenance and development of the software.\n+\n+## Current Architecture\n+\n+The current system features two primary executables: `bitcoind` and `bitcoin-qt`. `bitcoind` combines a Bitcoin P2P node with an integrated JSON-RPC server, wallet, and indexes. `bitcoin-qt` extends this by incorporating a Qt-based GUI. This monolithic structure, although robust, presents challenges such as limited operational flexibility and increased security risks due to the tight integration of components.\n+\n+## Proposed Architecture\n+\n+The new architecture divides the existing code into three specialized executables:\n+\n+- `bitcoin-node`: Manages the node, indexes, and JSON-RPC server.\n+- `bitcoin-wallet`: Handles all wallet functionality.\n+- `bitcoin-gui`: Provides a standalone Qt-based GUI.\n+\n+This modular approach is designed to enhance security through component isolation and improve usability by allowing independent operation of each module. This allows for new use-cases, such as running the node on a dedicated machine and operating wallets and GUIs on separate machines with the flexibility to start and stop them as needed.\n+\n+This subdivision could be extended in the future. For example, indexes could be removed from the `bitcoin-node` executable and run in separate executables. And JSON-RPC servers could be added to wallet and index executables, so they can listen and respond to RPC requests on their own ports, without needing to forward RPC requests through `bitcoin-node`.\n+\n+## Component Overview: Navigating the IPC Framework\n+\n+This section describes the major components of the Inter-Process Communication (IPC) framework covering the relevant source files, generated files, tools, and libraries.\n+\n+### Abstract C++ Classes in [`src/interfaces/`](../../src/interfaces/)\n+- The foundation of the IPC implementation lies in the abstract C++ classes within the [`src/interfaces/`](../../src/interfaces/) directory. These classes define pure virtual methods that code in [`src/node/`](../../src/node/), [`src/wallet/`](../../src/wallet/), and [`src/qt/`](../../src/qt/) directories call to interact with each other.\n+- Each abstract class in this directory represents a distinct interface that the different modules (node, wallet, GUI) implement and use for cross-process communication.\n+- The classes are written following conventions described in [Internal Interface\n+  Guidelines](../developer-notes.md#internal-interface-guidelines) to ensure\n+  compatibility with Cap'n Proto.\n+\n+### Cap’n Proto Files in [`src/ipc/capnp/`](../../src/ipc/capnp/)\n+- Corresponding to each abstract class, there are `.capnp` files within the [`src/ipc/capnp/`](../../src/ipc/capnp/) directory. These files are used as input to the `mpgen` tool (described below) to generate C++ code.\n+- These Cap’n Proto files ([learn more about Cap'n Proto RPC](https://capnproto.org/rpc.html)) define the structure and format of messages that are exchanged over IPC. They serve as blueprints for generating C++ code that bridges the gap between high-level C++ interfaces and low-level socket communication.\n+\n+### The `mpgen` Code Generation Tool\n+- A central component of the IPC framework is the `mpgen` tool which is part the [`libmultiprocess` project](https://github.com/chaincodelabs/libmultiprocess). This tool takes the `.capnp` files as input and generates C++ code.\n+- The generated code handles IPC communication, translating interface calls into socket reads and writes.\n+\n+### C++ Client Subclasses in Generated Code\n+- In the generated code, we have C++ client subclasses that inherit from the abstract classes in [`src/interfaces/`](../../src/interfaces/). These subclasses are the workhorses of the IPC mechanism.\n+- They implement all the methods of the interface, marshalling arguments into a structured format, sending them as requests to the IPC server via a UNIX socket, and handling the responses.\n+- These subclasses effectively mask the complexity of IPC, presenting a familiar C++ interface to developers.\n+- Internally, the client subclasses generated by the `mpgen` tool wrap [client classes generated by Cap'n Proto](https://capnproto.org/cxxrpc.html#clients), and use them to send IPC requests.\n+\n+### C++ Server Classes in Generated Code\n+- On the server side, corresponding generated C++ classes receive IPC requests. These server classes are responsible for unmarshalling method arguments, invoking the corresponding methods in the local [`src/interfaces/`](../../src/interfaces/) objects, and creating the IPC response.\n+- The server classes ensure that return values (including output argument values and thrown exceptions) are marshalled and sent back to the client, completing the communication cycle.\n+- Internally, the server subclasses generated by the `mpgen` tool inherit from [server classes generated by Cap'n Proto](https://capnproto.org/cxxrpc.html#servers), and use them to process IPC requests.\n+\n+### The `libmultiprocess` Runtime Library\n+- **Core Functionality**: The `libmultiprocess` runtime library's primary function is to instantiate the generated client and server classes as needed.\n+- **Bootstrapping IPC Connections**: It provides functions for starting new IPC connections, specifically binding generated client and server classes for an initial `interfaces::Init` interface (defined in [`src/interfaces/init.h`](../../src/interfaces/init.h)) to a UNIX socket. This initial interface has methods returning other interfaces that different Bitcoin-Core modules use to communicate after the bootstrapping phase.\n+- **Asynchronous I/O and Thread Management**: The library is also responsible for managing I/O and threading. Particularly, it ensures that IPC requests never block each other and that new threads on either side of a connection can always make client calls. It also manages worker threads on the server side of calls, ensuring that calls from the same client thread always execute on the same server thread (to avoid locking issues and support nested callbacks).\n+\n+### Type Hooks in [`src/ipc/capnp/*-types.h`](../../src/ipc/capnp/)\n+- **Custom Type Conversions**: In [`src/ipc/capnp/*-types.h`](../../src/ipc/capnp/), multiple function overloads of two `libmultiprocess` C++ functions, `mp::CustomReadField` and `mp::CustomBuildFields`, are defined. These functions are used for customizing the conversion of specific C++ types to and from Cap’n Proto types.\n+- **Handling Special Cases**: The `mpgen` tool and `libmultiprocess` library can convert most C++ types to and from Cap’n Proto types automatically, including interface types, primitive C++ types, standard C++ types like `std::vector`, `std::set`, `std::map`, `std::tuple`, and `std::function`, as well as simple C++ structs that consist of afforementioned types and whose fields correspond 1:1 with Cap’n Proto struct fields. For other types, `*-types.h` files provide custom code to convert between C++ and Cap’n Proto data representations.\n+\n+### Protocol-Agnostic IPC Code in [`src/ipc/`](../../src/ipc/)\n+- **Broad Applicability**: Unlike the Cap’n Proto-specific code in [`src/ipc/capnp/`](../../src/ipc/capnp/), the code in the [`src/ipc/`](../../src/ipc/) directory is protocol-agnostic. This enables potential support for other protocols, such as gRPC or a custom protocol in the future.\n+- **Process Management and Socket Operations**: The main purpose of this component is to provide functions for spawning new processes and creating and connecting to UNIX sockets.\n+- **ipc::Exception Class**: This code also defines an `ipc::Exception` class which is thrown from the generated C++ client class methods when there is an unexpected IPC error, such as a disconnection.\n+\n+## Design Considerations\n+\n+### Selection of Cap’n Proto\n+The choice to use [Cap’n Proto](https://capnproto.org/) for IPC was primarily influenced by its support for passing object references and managing object lifetimes, which would have to be implemented manually with a framework that only supported plain requests and responses like [gRPC](https://grpc.io/). The support is especially helpful for passing callback objects like `std::function` and supporting bidirectional communication.\n+\n+The choice to use an RPC framework at all instead of a custom protocol was neccesitated by the size of Bitcoin Core internal interfaces which consist of around 150 methods that pass complex data structures and are called in complicated ways (in parallel, from callbacks that can be nested and stored). Writing a custom protocol to wrap these complicated interfaces would be too much work, akin to writing a new RPC framework.\n+\n+### Hiding IPC\n+\n+The IPC mechanism is deliberately isolated from the rest of the codebase so less code has to be concerned with IPC.\n+\n+Building Bitcoin Core with IPC support is optional, and the same code can be compiled to either run in the same process or separate processes. The build system also ensures Cap’n Proto library headers can only be used within the [`src/ipc/capnp/`](../../src/ipc/capnp/) directory, not in other parts of the codebase.\n+\n+The libmultiprocess runtime is designed to place as few constraints as possible on IPC interfaces and make IPC calls act like normal function calls. Method arguments, return values, and exceptions are automatically serialized and sent between processes. Object references and `std::function` arguments are automatically tracked and mapped to allow invoked code to call back into invoking code at any time. And there is a 1:1 threading model where any every client thread has a corresponding server thread responsible for executing incoming calls from that thread (there can be multiple calls from the same thread due to callbacks), without blocking, and holding the same thread-local variables and locks so behavior is the same whether IPC is used or not.\n+\n+### Interface Definition Maintenance\n+\n+The choice to maintain interface definitions and C++ type mappings as `.capnp` files in the [`src/ipc/capnp/`](../../src/ipc/capnp/) was mostly done for convenience, and probably something that could be improved in the future.\n+\n+In the current design, class names, method names, and parameter names are duplicated between C++ interfaces in [`src/interfaces/`](../../src/interfaces/) and Cap’n Proto files in [`src/ipc/capnp/`](../../src/ipc/capnp/). While this keeps C++ interface headers simple and free of references to IPC, it is a maintence burden because it means inconsistencies between C++ declarations and Cap’n Proto declarations will result in compile errors. (Static type checking ensures these are not runtime errors.)\n+\n+An alternate approach could use custom [C++ Attributes](https://en.cppreference.com/w/cpp/language/attributes) embedded in interface declarations to automatically generate `.capnp` files directly from C++ headers. This has not been pursued because parsing C++ headers is more complicated than parsing Cap’n Proto interface definitions, especially portably on multiple platforms.\n+\n+### Interface Stability\n+\n+The currently defined IPC interfaces are unstable, and can change freely with no backwards compatibility. The decision to allow this stems from the recognition that our current interfaces are still evolving and not yet ideal for external use. As these interfaces mature and become more refined, there may be an opportunity to declare them stable and use Cap’n Proto's support for protocol evolution ([Cap'n Proto - Evolving Your Protocol](https://capnproto.org/language.html#evolving-your-protocol)) to allow them to be extended while remaining backwards compatible. This could allow different versions of node, GUI, and wallet binaries to interoperate, and potentially open doors for external tools to utilize these interfaces, such as creating custom indexes through a stable indexing interface. However, for now, the priority is to improve the interfaces internally. Given their current state and the advantages of using JSON-RPC for most common tasks, it's more practical to focus on internal development rather than external applicability.\n+\n+## Example Use Cases and Flows\n+\n+### Retrieving a Block Hash\n+\n+Let’s walk through an example where the `bitcoin-wallet` process requests the hash of a block at a specific height from the `bitcoin-node` process. This example demonstrates the practical application of the IPC mechanism, specifically the interplay between C++ method calls and Cap’n Proto-generated RPC calls.\n+\n+1. **Initiation in bitcoin-wallet**\n+   - The wallet process calls the `getBlockHash` method on a `Chain` object. This method is defined as a virtual function in [`src/interfaces/chain.h`](../../src/interfaces/chain.h).\n+\n+2. **Translation to Cap’n Proto RPC**\n+   - The call to `getBlockHash` is translated into a Cap’n Proto RPC call. This translation is handled by code automatically generated by the `mpgen` tool, based on the [`chain.capnp`](../../src/ipc/capnp/chain.capnp)` file in [`src/ipc/capnp/`](../../src/ipc/capnp/).\n+\n+3. **Request Preparation and Dispatch**\n+   - The generated `Chain` subclass in `bitcoin-wallet` populates a Cap’n Proto request with the `height` parameter.\n+   - The request is sent to the `bitcoin-node` process.\n+\n+4. **Handling in bitcoin-node**\n+   - Upon receiving the request, the `bitcoin-node` process reads the `height` value from the request.\n+   - It then calls the `getBlockHash` method on its local `Chain` object with the provided `height`.",
      "path": "doc/design/multiprocess.md",
      "position": null,
      "original_position": 208,
      "commit_id": "91dc48c14825a9075a57c1eefda202b83b6346ba",
      "original_commit_id": "837c53d14f24924cdcb2cfd8b18915882dc3b620",
      "in_reply_to_id": null,
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Steps 2 and 3 highlight what's handled by generated code, for consistency that might be helpful in steps 4&5 too?",
      "created_at": "2023-12-12T16:21:08Z",
      "updated_at": "2023-12-12T17:45:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28978#discussion_r1424253642",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1424253642"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28978"
        }
      },
      "start_line": null,
      "original_start_line": 135,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 136,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1427363274",
      "pull_request_review_id": 1782842554,
      "id": 1427363274,
      "node_id": "PRRC_kwDOABII585VE9XK",
      "diff_hunk": "@@ -1,72 +1,200 @@\n-# Multiprocess Bitcoin\n-\n-On unix systems, the `--enable-multiprocess` build option can be passed to `./configure` to build new `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables alongside existing `bitcoind` and `bitcoin-qt` executables.\n-\n-`bitcoin-node` is a drop-in replacement for `bitcoind`, and `bitcoin-gui` is a drop-in replacement for `bitcoin-qt`, and there are no differences in use or external behavior between the new and old executables. But internally (after [#10102](https://github.com/bitcoin/bitcoin/pull/10102)), `bitcoin-gui` will spawn a `bitcoin-node` process to run P2P and RPC code, communicating with it across a socket pair, and `bitcoin-node` will spawn `bitcoin-wallet` to run wallet code, also communicating over a socket pair. This will let node, wallet, and GUI code run in separate address spaces for better isolation, and allow future improvements like being able to start and stop components independently on different machines and environments.\n-\n-## Next steps\n-\n-Specific next steps after [#10102](https://github.com/bitcoin/bitcoin/pull/10102) will be:\n-\n-- [ ] Adding `-ipcbind` and `-ipcconnect` options to `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables so they can listen and connect to TCP ports and unix socket paths. This will allow separate processes to be started and stopped any time and connect to each other.\n-- [ ] Adding `-server` and `-rpcbind` options to the `bitcoin-wallet` executable so wallet processes can handle RPC requests directly without going through the node.\n-- [ ] Supporting windows, not just unix systems. The existing socket code is already cross-platform, so the only windows-specific code that needs to be written is code spawning a process and passing a socket descriptor. This can be implemented with `CreateProcess` and `WSADuplicateSocket`. Example: https://memset.wordpress.com/2010/10/13/win32-api-passing-socket-with-ipc-method/.\n-- [ ] Adding sandbox features, restricting subprocess access to resources and data. See [https://eklitzke.org/multiprocess-bitcoin](https://eklitzke.org/multiprocess-bitcoin).\n-\n-## Debugging\n-\n-The `-debug=ipc` command line option can be used to see requests and responses between processes.\n-\n-## Installation\n-\n-The multiprocess feature requires [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) as dependencies. A simple way to get starting using it without installing these dependencies manually is to use the [depends system](../../depends) with the `MULTIPROCESS=1` [dependency option](../../depends#dependency-options) passed to make:\n-\n-```\n-cd <BITCOIN_SOURCE_DIRECTORY>\n-make -C depends NO_QT=1 MULTIPROCESS=1\n-CONFIG_SITE=$PWD/depends/x86_64-pc-linux-gnu/share/config.site ./configure\n-make\n-src/bitcoin-node -regtest -printtoconsole -debug=ipc\n-BITCOIND=bitcoin-node test/functional/test_runner.py\n-```\n-\n-The configure script will pick up settings and library locations from the depends directory, so there is no need to pass `--enable-multiprocess` as a separate flag when using the depends system (it's controlled by the `MULTIPROCESS=1` option).\n-\n-Alternately, you can install [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) packages on your system, and just run `./configure --enable-multiprocess` without using the depends system. The configure script will be able to locate the installed packages via [pkg-config](https://www.freedesktop.org/wiki/Software/pkg-config/). See [Installation](https://github.com/chaincodelabs/libmultiprocess/blob/master/doc/install.md) section of the libmultiprocess readme for install steps. See [build-unix.md](../build-unix.md) and [build-osx.md](../build-osx.md) for information about installing dependencies in general.\n-\n-## IPC implementation details\n-\n-Cross process Node, Wallet, and Chain interfaces are defined in\n-[`src/interfaces/`](../../src/interfaces/). These are C++ classes which follow\n-[conventions](../developer-notes.md#internal-interface-guidelines), like passing\n-serializable arguments so they can be called from different processes, and\n-making methods pure virtual so they can have proxy implementations that forward\n-calls between processes.\n-\n-When Wallet, Node, and Chain code is running in the same process, calling any\n-interface method invokes the implementation directly. When code is running in\n-different processes, calling an interface method invokes a proxy interface\n-implementation that communicates with a remote process and invokes the real\n-implementation in the remote process. The\n-[libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) code\n-generation tool internally generates proxy client classes and proxy server\n-classes for this purpose that are thin wrappers around Cap'n Proto\n-[client](https://capnproto.org/cxxrpc.html#clients) and\n-[server](https://capnproto.org/cxxrpc.html#servers) classes, which handle the\n-actual serialization and socket communication.\n-\n-As much as possible, calls between processes are meant to work the same as\n-calls within a single process without adding limitations or requiring extra\n-implementation effort. Processes communicate with each other by calling regular\n-[C++ interface methods](../../src/interfaces/README.md). Method arguments and\n-return values are automatically serialized and sent between processes. Object\n-references and `std::function` arguments are automatically tracked and mapped\n-to allow invoked code to call back into invoking code at any time, and there is\n-a 1:1 threading model where any thread invoking a method in another process has\n-a corresponding thread in the invoked process responsible for executing all\n-method calls from the source thread, without blocking I/O or holding up another\n-call, and using the same thread local variables, locks, and callbacks between\n-calls. The forwarding, tracking, and threading is implemented inside the\n-[libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) library\n-which has the design goal of making calls between processes look like calls in\n-the same process to the extent possible.\n+# Multiprocess Bitcoin Design Document\n+\n+Guide to the design and architecture of the Bitcoin-Core multiprocess feature\n+\n+_This document describes the design of the multiprocess feature. For usage information, see the top-level [multiprocess.md](../multiprocess.md) file._\n+\n+## Table of contents\n+\n+- [Introduction](#introduction)\n+- [Current Architecture](#current-architecture)\n+- [Proposed Architecture](#proposed-architecture)\n+- [Component Overview: Navigating the IPC Framework](#component-overview-navigating-the-ipc-framework)\n+- [Design Considerations](#design-considerations)\n+  - [Selection of Cap’n Proto](#selection-of-capn-proto)\n+  - [Hiding IPC](#hiding-ipc)\n+  - [Interface Definition Maintenance](#interface-definition-maintenance)\n+  - [Interface Stability](#interface-stability)\n+- [Example Use Cases and Flows](#example-use-cases-and-flows)\n+  - [Retrieving a Block Hash](#retrieving-a-block-hash)\n+- [Future Enhancements](#future-enhancements)\n+- [Conclusion](#conclusion)\n+- [Appendices](#appendices)\n+  - [Glossary of Terms](#glossary-of-terms)\n+  - [References](#references)\n+- [Acknowledgements](#acknowledgements)\n+\n+## Introduction\n+\n+The Bitcoin Core software, central to the Bitcoin network, has historically employed a monolithic architecture. The existing design has integrated functionality like P2P network operations, wallet management, and a GUI into a single executable. While effective, it has limitations in flexibility, security, and scalability. This project introduces changes that transition Bitcoin Core to a more modular architecture. It aims to enhance security, improve usability, and facilitate maintenance and development of the software.\n+\n+## Current Architecture\n+\n+The current system features two primary executables: `bitcoind` and `bitcoin-qt`. `bitcoind` combines a Bitcoin P2P node with an integrated JSON-RPC server, wallet, and indexes. `bitcoin-qt` extends this by incorporating a Qt-based GUI. This monolithic structure, although robust, presents challenges such as limited operational flexibility and increased security risks due to the tight integration of components.\n+\n+## Proposed Architecture\n+\n+The new architecture divides the existing code into three specialized executables:\n+\n+- `bitcoin-node`: Manages the node, indexes, and JSON-RPC server.",
      "path": "doc/design/multiprocess.md",
      "position": null,
      "original_position": 111,
      "commit_id": "91dc48c14825a9075a57c1eefda202b83b6346ba",
      "original_commit_id": "837c53d14f24924cdcb2cfd8b18915882dc3b620",
      "in_reply_to_id": null,
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit\r\n```suggestion\r\n- `bitcoin-node`: Manages the P2P node, indexes, and JSON-RPC server.\r\n```",
      "created_at": "2023-12-14T22:23:57Z",
      "updated_at": "2023-12-15T16:48:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28978#discussion_r1427363274",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1427363274"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28978"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 39,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1427365136",
      "pull_request_review_id": 1782842554,
      "id": 1427365136,
      "node_id": "PRRC_kwDOABII585VE90Q",
      "diff_hunk": "@@ -1,72 +1,200 @@\n-# Multiprocess Bitcoin\n-\n-On unix systems, the `--enable-multiprocess` build option can be passed to `./configure` to build new `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables alongside existing `bitcoind` and `bitcoin-qt` executables.\n-\n-`bitcoin-node` is a drop-in replacement for `bitcoind`, and `bitcoin-gui` is a drop-in replacement for `bitcoin-qt`, and there are no differences in use or external behavior between the new and old executables. But internally (after [#10102](https://github.com/bitcoin/bitcoin/pull/10102)), `bitcoin-gui` will spawn a `bitcoin-node` process to run P2P and RPC code, communicating with it across a socket pair, and `bitcoin-node` will spawn `bitcoin-wallet` to run wallet code, also communicating over a socket pair. This will let node, wallet, and GUI code run in separate address spaces for better isolation, and allow future improvements like being able to start and stop components independently on different machines and environments.\n-\n-## Next steps\n-\n-Specific next steps after [#10102](https://github.com/bitcoin/bitcoin/pull/10102) will be:\n-\n-- [ ] Adding `-ipcbind` and `-ipcconnect` options to `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables so they can listen and connect to TCP ports and unix socket paths. This will allow separate processes to be started and stopped any time and connect to each other.\n-- [ ] Adding `-server` and `-rpcbind` options to the `bitcoin-wallet` executable so wallet processes can handle RPC requests directly without going through the node.\n-- [ ] Supporting windows, not just unix systems. The existing socket code is already cross-platform, so the only windows-specific code that needs to be written is code spawning a process and passing a socket descriptor. This can be implemented with `CreateProcess` and `WSADuplicateSocket`. Example: https://memset.wordpress.com/2010/10/13/win32-api-passing-socket-with-ipc-method/.\n-- [ ] Adding sandbox features, restricting subprocess access to resources and data. See [https://eklitzke.org/multiprocess-bitcoin](https://eklitzke.org/multiprocess-bitcoin).\n-\n-## Debugging\n-\n-The `-debug=ipc` command line option can be used to see requests and responses between processes.\n-\n-## Installation\n-\n-The multiprocess feature requires [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) as dependencies. A simple way to get starting using it without installing these dependencies manually is to use the [depends system](../../depends) with the `MULTIPROCESS=1` [dependency option](../../depends#dependency-options) passed to make:\n-\n-```\n-cd <BITCOIN_SOURCE_DIRECTORY>\n-make -C depends NO_QT=1 MULTIPROCESS=1\n-CONFIG_SITE=$PWD/depends/x86_64-pc-linux-gnu/share/config.site ./configure\n-make\n-src/bitcoin-node -regtest -printtoconsole -debug=ipc\n-BITCOIND=bitcoin-node test/functional/test_runner.py\n-```\n-\n-The configure script will pick up settings and library locations from the depends directory, so there is no need to pass `--enable-multiprocess` as a separate flag when using the depends system (it's controlled by the `MULTIPROCESS=1` option).\n-\n-Alternately, you can install [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) packages on your system, and just run `./configure --enable-multiprocess` without using the depends system. The configure script will be able to locate the installed packages via [pkg-config](https://www.freedesktop.org/wiki/Software/pkg-config/). See [Installation](https://github.com/chaincodelabs/libmultiprocess/blob/master/doc/install.md) section of the libmultiprocess readme for install steps. See [build-unix.md](../build-unix.md) and [build-osx.md](../build-osx.md) for information about installing dependencies in general.\n-\n-## IPC implementation details\n-\n-Cross process Node, Wallet, and Chain interfaces are defined in\n-[`src/interfaces/`](../../src/interfaces/). These are C++ classes which follow\n-[conventions](../developer-notes.md#internal-interface-guidelines), like passing\n-serializable arguments so they can be called from different processes, and\n-making methods pure virtual so they can have proxy implementations that forward\n-calls between processes.\n-\n-When Wallet, Node, and Chain code is running in the same process, calling any\n-interface method invokes the implementation directly. When code is running in\n-different processes, calling an interface method invokes a proxy interface\n-implementation that communicates with a remote process and invokes the real\n-implementation in the remote process. The\n-[libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) code\n-generation tool internally generates proxy client classes and proxy server\n-classes for this purpose that are thin wrappers around Cap'n Proto\n-[client](https://capnproto.org/cxxrpc.html#clients) and\n-[server](https://capnproto.org/cxxrpc.html#servers) classes, which handle the\n-actual serialization and socket communication.\n-\n-As much as possible, calls between processes are meant to work the same as\n-calls within a single process without adding limitations or requiring extra\n-implementation effort. Processes communicate with each other by calling regular\n-[C++ interface methods](../../src/interfaces/README.md). Method arguments and\n-return values are automatically serialized and sent between processes. Object\n-references and `std::function` arguments are automatically tracked and mapped\n-to allow invoked code to call back into invoking code at any time, and there is\n-a 1:1 threading model where any thread invoking a method in another process has\n-a corresponding thread in the invoked process responsible for executing all\n-method calls from the source thread, without blocking I/O or holding up another\n-call, and using the same thread local variables, locks, and callbacks between\n-calls. The forwarding, tracking, and threading is implemented inside the\n-[libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) library\n-which has the design goal of making calls between processes look like calls in\n-the same process to the extent possible.\n+# Multiprocess Bitcoin Design Document\n+\n+Guide to the design and architecture of the Bitcoin-Core multiprocess feature\n+\n+_This document describes the design of the multiprocess feature. For usage information, see the top-level [multiprocess.md](../multiprocess.md) file._\n+\n+## Table of contents\n+\n+- [Introduction](#introduction)\n+- [Current Architecture](#current-architecture)\n+- [Proposed Architecture](#proposed-architecture)\n+- [Component Overview: Navigating the IPC Framework](#component-overview-navigating-the-ipc-framework)\n+- [Design Considerations](#design-considerations)\n+  - [Selection of Cap’n Proto](#selection-of-capn-proto)\n+  - [Hiding IPC](#hiding-ipc)\n+  - [Interface Definition Maintenance](#interface-definition-maintenance)\n+  - [Interface Stability](#interface-stability)\n+- [Example Use Cases and Flows](#example-use-cases-and-flows)\n+  - [Retrieving a Block Hash](#retrieving-a-block-hash)\n+- [Future Enhancements](#future-enhancements)\n+- [Conclusion](#conclusion)\n+- [Appendices](#appendices)\n+  - [Glossary of Terms](#glossary-of-terms)\n+  - [References](#references)\n+- [Acknowledgements](#acknowledgements)\n+\n+## Introduction\n+\n+The Bitcoin Core software, central to the Bitcoin network, has historically employed a monolithic architecture. The existing design has integrated functionality like P2P network operations, wallet management, and a GUI into a single executable. While effective, it has limitations in flexibility, security, and scalability. This project introduces changes that transition Bitcoin Core to a more modular architecture. It aims to enhance security, improve usability, and facilitate maintenance and development of the software.",
      "path": "doc/design/multiprocess.md",
      "position": null,
      "original_position": 101,
      "commit_id": "91dc48c14825a9075a57c1eefda202b83b6346ba",
      "original_commit_id": "837c53d14f24924cdcb2cfd8b18915882dc3b620",
      "in_reply_to_id": null,
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit suggestions:\r\n- 'central to the bitcoin network' isn't really relevant to this doc\r\n- I hear people complain that big changes are always a security risk in the short term all the time\r\n\r\n```suggestion\r\nThe Bitcoin Core software has historically employed a monolithic architecture. The existing design has integrated functionality like P2P network operations, wallet management, and a GUI into a single executable. While effective, it has limitations in flexibility, security, and scalability. This project introduces changes that transition Bitcoin Core to a more modular architecture. It aims to enhance security, improve usability, and facilitate maintenance and development of the software in the long run.\r\n```",
      "created_at": "2023-12-14T22:26:39Z",
      "updated_at": "2023-12-15T16:48:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28978#discussion_r1427365136",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1427365136"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28978"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 29,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1428154601",
      "pull_request_review_id": 1782842554,
      "id": 1428154601,
      "node_id": "PRRC_kwDOABII585VH-jp",
      "diff_hunk": "@@ -1,72 +1,200 @@\n-# Multiprocess Bitcoin\n-\n-On unix systems, the `--enable-multiprocess` build option can be passed to `./configure` to build new `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables alongside existing `bitcoind` and `bitcoin-qt` executables.\n-\n-`bitcoin-node` is a drop-in replacement for `bitcoind`, and `bitcoin-gui` is a drop-in replacement for `bitcoin-qt`, and there are no differences in use or external behavior between the new and old executables. But internally (after [#10102](https://github.com/bitcoin/bitcoin/pull/10102)), `bitcoin-gui` will spawn a `bitcoin-node` process to run P2P and RPC code, communicating with it across a socket pair, and `bitcoin-node` will spawn `bitcoin-wallet` to run wallet code, also communicating over a socket pair. This will let node, wallet, and GUI code run in separate address spaces for better isolation, and allow future improvements like being able to start and stop components independently on different machines and environments.\n-\n-## Next steps\n-\n-Specific next steps after [#10102](https://github.com/bitcoin/bitcoin/pull/10102) will be:\n-\n-- [ ] Adding `-ipcbind` and `-ipcconnect` options to `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables so they can listen and connect to TCP ports and unix socket paths. This will allow separate processes to be started and stopped any time and connect to each other.\n-- [ ] Adding `-server` and `-rpcbind` options to the `bitcoin-wallet` executable so wallet processes can handle RPC requests directly without going through the node.\n-- [ ] Supporting windows, not just unix systems. The existing socket code is already cross-platform, so the only windows-specific code that needs to be written is code spawning a process and passing a socket descriptor. This can be implemented with `CreateProcess` and `WSADuplicateSocket`. Example: https://memset.wordpress.com/2010/10/13/win32-api-passing-socket-with-ipc-method/.\n-- [ ] Adding sandbox features, restricting subprocess access to resources and data. See [https://eklitzke.org/multiprocess-bitcoin](https://eklitzke.org/multiprocess-bitcoin).\n-\n-## Debugging\n-\n-The `-debug=ipc` command line option can be used to see requests and responses between processes.\n-\n-## Installation\n-\n-The multiprocess feature requires [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) as dependencies. A simple way to get starting using it without installing these dependencies manually is to use the [depends system](../../depends) with the `MULTIPROCESS=1` [dependency option](../../depends#dependency-options) passed to make:\n-\n-```\n-cd <BITCOIN_SOURCE_DIRECTORY>\n-make -C depends NO_QT=1 MULTIPROCESS=1\n-CONFIG_SITE=$PWD/depends/x86_64-pc-linux-gnu/share/config.site ./configure\n-make\n-src/bitcoin-node -regtest -printtoconsole -debug=ipc\n-BITCOIND=bitcoin-node test/functional/test_runner.py\n-```\n-\n-The configure script will pick up settings and library locations from the depends directory, so there is no need to pass `--enable-multiprocess` as a separate flag when using the depends system (it's controlled by the `MULTIPROCESS=1` option).\n-\n-Alternately, you can install [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) packages on your system, and just run `./configure --enable-multiprocess` without using the depends system. The configure script will be able to locate the installed packages via [pkg-config](https://www.freedesktop.org/wiki/Software/pkg-config/). See [Installation](https://github.com/chaincodelabs/libmultiprocess/blob/master/doc/install.md) section of the libmultiprocess readme for install steps. See [build-unix.md](../build-unix.md) and [build-osx.md](../build-osx.md) for information about installing dependencies in general.\n-\n-## IPC implementation details\n-\n-Cross process Node, Wallet, and Chain interfaces are defined in\n-[`src/interfaces/`](../../src/interfaces/). These are C++ classes which follow\n-[conventions](../developer-notes.md#internal-interface-guidelines), like passing\n-serializable arguments so they can be called from different processes, and\n-making methods pure virtual so they can have proxy implementations that forward\n-calls between processes.\n-\n-When Wallet, Node, and Chain code is running in the same process, calling any\n-interface method invokes the implementation directly. When code is running in\n-different processes, calling an interface method invokes a proxy interface\n-implementation that communicates with a remote process and invokes the real\n-implementation in the remote process. The\n-[libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) code\n-generation tool internally generates proxy client classes and proxy server\n-classes for this purpose that are thin wrappers around Cap'n Proto\n-[client](https://capnproto.org/cxxrpc.html#clients) and\n-[server](https://capnproto.org/cxxrpc.html#servers) classes, which handle the\n-actual serialization and socket communication.\n-\n-As much as possible, calls between processes are meant to work the same as\n-calls within a single process without adding limitations or requiring extra\n-implementation effort. Processes communicate with each other by calling regular\n-[C++ interface methods](../../src/interfaces/README.md). Method arguments and\n-return values are automatically serialized and sent between processes. Object\n-references and `std::function` arguments are automatically tracked and mapped\n-to allow invoked code to call back into invoking code at any time, and there is\n-a 1:1 threading model where any thread invoking a method in another process has\n-a corresponding thread in the invoked process responsible for executing all\n-method calls from the source thread, without blocking I/O or holding up another\n-call, and using the same thread local variables, locks, and callbacks between\n-calls. The forwarding, tracking, and threading is implemented inside the\n-[libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) library\n-which has the design goal of making calls between processes look like calls in\n-the same process to the extent possible.\n+# Multiprocess Bitcoin Design Document\n+\n+Guide to the design and architecture of the Bitcoin-Core multiprocess feature\n+\n+_This document describes the design of the multiprocess feature. For usage information, see the top-level [multiprocess.md](../multiprocess.md) file._\n+\n+## Table of contents\n+\n+- [Introduction](#introduction)\n+- [Current Architecture](#current-architecture)\n+- [Proposed Architecture](#proposed-architecture)\n+- [Component Overview: Navigating the IPC Framework](#component-overview-navigating-the-ipc-framework)\n+- [Design Considerations](#design-considerations)\n+  - [Selection of Cap’n Proto](#selection-of-capn-proto)\n+  - [Hiding IPC](#hiding-ipc)\n+  - [Interface Definition Maintenance](#interface-definition-maintenance)\n+  - [Interface Stability](#interface-stability)\n+- [Example Use Cases and Flows](#example-use-cases-and-flows)\n+  - [Retrieving a Block Hash](#retrieving-a-block-hash)\n+- [Future Enhancements](#future-enhancements)\n+- [Conclusion](#conclusion)\n+- [Appendices](#appendices)\n+  - [Glossary of Terms](#glossary-of-terms)\n+  - [References](#references)\n+- [Acknowledgements](#acknowledgements)\n+\n+## Introduction\n+\n+The Bitcoin Core software, central to the Bitcoin network, has historically employed a monolithic architecture. The existing design has integrated functionality like P2P network operations, wallet management, and a GUI into a single executable. While effective, it has limitations in flexibility, security, and scalability. This project introduces changes that transition Bitcoin Core to a more modular architecture. It aims to enhance security, improve usability, and facilitate maintenance and development of the software.\n+\n+## Current Architecture\n+\n+The current system features two primary executables: `bitcoind` and `bitcoin-qt`. `bitcoind` combines a Bitcoin P2P node with an integrated JSON-RPC server, wallet, and indexes. `bitcoin-qt` extends this by incorporating a Qt-based GUI. This monolithic structure, although robust, presents challenges such as limited operational flexibility and increased security risks due to the tight integration of components.\n+\n+## Proposed Architecture\n+\n+The new architecture divides the existing code into three specialized executables:\n+\n+- `bitcoin-node`: Manages the node, indexes, and JSON-RPC server.\n+- `bitcoin-wallet`: Handles all wallet functionality.\n+- `bitcoin-gui`: Provides a standalone Qt-based GUI.\n+\n+This modular approach is designed to enhance security through component isolation and improve usability by allowing independent operation of each module. This allows for new use-cases, such as running the node on a dedicated machine and operating wallets and GUIs on separate machines with the flexibility to start and stop them as needed.\n+\n+This subdivision could be extended in the future. For example, indexes could be removed from the `bitcoin-node` executable and run in separate executables. And JSON-RPC servers could be added to wallet and index executables, so they can listen and respond to RPC requests on their own ports, without needing to forward RPC requests through `bitcoin-node`.\n+\n+## Component Overview: Navigating the IPC Framework\n+\n+This section describes the major components of the Inter-Process Communication (IPC) framework covering the relevant source files, generated files, tools, and libraries.\n+\n+### Abstract C++ Classes in [`src/interfaces/`](../../src/interfaces/)\n+- The foundation of the IPC implementation lies in the abstract C++ classes within the [`src/interfaces/`](../../src/interfaces/) directory. These classes define pure virtual methods that code in [`src/node/`](../../src/node/), [`src/wallet/`](../../src/wallet/), and [`src/qt/`](../../src/qt/) directories call to interact with each other.\n+- Each abstract class in this directory represents a distinct interface that the different modules (node, wallet, GUI) implement and use for cross-process communication.\n+- The classes are written following conventions described in [Internal Interface\n+  Guidelines](../developer-notes.md#internal-interface-guidelines) to ensure\n+  compatibility with Cap'n Proto.\n+\n+### Cap’n Proto Files in [`src/ipc/capnp/`](../../src/ipc/capnp/)\n+- Corresponding to each abstract class, there are `.capnp` files within the [`src/ipc/capnp/`](../../src/ipc/capnp/) directory. These files are used as input to the `mpgen` tool (described below) to generate C++ code.\n+- These Cap’n Proto files ([learn more about Cap'n Proto RPC](https://capnproto.org/rpc.html)) define the structure and format of messages that are exchanged over IPC. They serve as blueprints for generating C++ code that bridges the gap between high-level C++ interfaces and low-level socket communication.\n+\n+### The `mpgen` Code Generation Tool\n+- A central component of the IPC framework is the `mpgen` tool which is part the [`libmultiprocess` project](https://github.com/chaincodelabs/libmultiprocess). This tool takes the `.capnp` files as input and generates C++ code.\n+- The generated code handles IPC communication, translating interface calls into socket reads and writes.\n+\n+### C++ Client Subclasses in Generated Code\n+- In the generated code, we have C++ client subclasses that inherit from the abstract classes in [`src/interfaces/`](../../src/interfaces/). These subclasses are the workhorses of the IPC mechanism.\n+- They implement all the methods of the interface, marshalling arguments into a structured format, sending them as requests to the IPC server via a UNIX socket, and handling the responses.\n+- These subclasses effectively mask the complexity of IPC, presenting a familiar C++ interface to developers.\n+- Internally, the client subclasses generated by the `mpgen` tool wrap [client classes generated by Cap'n Proto](https://capnproto.org/cxxrpc.html#clients), and use them to send IPC requests.\n+\n+### C++ Server Classes in Generated Code\n+- On the server side, corresponding generated C++ classes receive IPC requests. These server classes are responsible for unmarshalling method arguments, invoking the corresponding methods in the local [`src/interfaces/`](../../src/interfaces/) objects, and creating the IPC response.\n+- The server classes ensure that return values (including output argument values and thrown exceptions) are marshalled and sent back to the client, completing the communication cycle.\n+- Internally, the server subclasses generated by the `mpgen` tool inherit from [server classes generated by Cap'n Proto](https://capnproto.org/cxxrpc.html#servers), and use them to process IPC requests.\n+\n+### The `libmultiprocess` Runtime Library\n+- **Core Functionality**: The `libmultiprocess` runtime library's primary function is to instantiate the generated client and server classes as needed.\n+- **Bootstrapping IPC Connections**: It provides functions for starting new IPC connections, specifically binding generated client and server classes for an initial `interfaces::Init` interface (defined in [`src/interfaces/init.h`](../../src/interfaces/init.h)) to a UNIX socket. This initial interface has methods returning other interfaces that different Bitcoin-Core modules use to communicate after the bootstrapping phase.\n+- **Asynchronous I/O and Thread Management**: The library is also responsible for managing I/O and threading. Particularly, it ensures that IPC requests never block each other and that new threads on either side of a connection can always make client calls. It also manages worker threads on the server side of calls, ensuring that calls from the same client thread always execute on the same server thread (to avoid locking issues and support nested callbacks).\n+\n+### Type Hooks in [`src/ipc/capnp/*-types.h`](../../src/ipc/capnp/)\n+- **Custom Type Conversions**: In [`src/ipc/capnp/*-types.h`](../../src/ipc/capnp/), multiple function overloads of two `libmultiprocess` C++ functions, `mp::CustomReadField` and `mp::CustomBuildFields`, are defined. These functions are used for customizing the conversion of specific C++ types to and from Cap’n Proto types.\n+- **Handling Special Cases**: The `mpgen` tool and `libmultiprocess` library can convert most C++ types to and from Cap’n Proto types automatically, including interface types, primitive C++ types, standard C++ types like `std::vector`, `std::set`, `std::map`, `std::tuple`, and `std::function`, as well as simple C++ structs that consist of afforementioned types and whose fields correspond 1:1 with Cap’n Proto struct fields. For other types, `*-types.h` files provide custom code to convert between C++ and Cap’n Proto data representations.\n+\n+### Protocol-Agnostic IPC Code in [`src/ipc/`](../../src/ipc/)\n+- **Broad Applicability**: Unlike the Cap’n Proto-specific code in [`src/ipc/capnp/`](../../src/ipc/capnp/), the code in the [`src/ipc/`](../../src/ipc/) directory is protocol-agnostic. This enables potential support for other protocols, such as gRPC or a custom protocol in the future.\n+- **Process Management and Socket Operations**: The main purpose of this component is to provide functions for spawning new processes and creating and connecting to UNIX sockets.\n+- **ipc::Exception Class**: This code also defines an `ipc::Exception` class which is thrown from the generated C++ client class methods when there is an unexpected IPC error, such as a disconnection.\n+\n+## Design Considerations\n+\n+### Selection of Cap’n Proto\n+The choice to use [Cap’n Proto](https://capnproto.org/) for IPC was primarily influenced by its support for passing object references and managing object lifetimes, which would have to be implemented manually with a framework that only supported plain requests and responses like [gRPC](https://grpc.io/). The support is especially helpful for passing callback objects like `std::function` and supporting bidirectional communication.\n+\n+The choice to use an RPC framework at all instead of a custom protocol was neccesitated by the size of Bitcoin Core internal interfaces which consist of around 150 methods that pass complex data structures and are called in complicated ways (in parallel, from callbacks that can be nested and stored). Writing a custom protocol to wrap these complicated interfaces would be too much work, akin to writing a new RPC framework.\n+\n+### Hiding IPC\n+\n+The IPC mechanism is deliberately isolated from the rest of the codebase so less code has to be concerned with IPC.\n+\n+Building Bitcoin Core with IPC support is optional, and the same code can be compiled to either run in the same process or separate processes. The build system also ensures Cap’n Proto library headers can only be used within the [`src/ipc/capnp/`](../../src/ipc/capnp/) directory, not in other parts of the codebase.\n+\n+The libmultiprocess runtime is designed to place as few constraints as possible on IPC interfaces and make IPC calls act like normal function calls. Method arguments, return values, and exceptions are automatically serialized and sent between processes. Object references and `std::function` arguments are automatically tracked and mapped to allow invoked code to call back into invoking code at any time. And there is a 1:1 threading model where any every client thread has a corresponding server thread responsible for executing incoming calls from that thread (there can be multiple calls from the same thread due to callbacks), without blocking, and holding the same thread-local variables and locks so behavior is the same whether IPC is used or not.\n+\n+### Interface Definition Maintenance\n+\n+The choice to maintain interface definitions and C++ type mappings as `.capnp` files in the [`src/ipc/capnp/`](../../src/ipc/capnp/) was mostly done for convenience, and probably something that could be improved in the future.\n+\n+In the current design, class names, method names, and parameter names are duplicated between C++ interfaces in [`src/interfaces/`](../../src/interfaces/) and Cap’n Proto files in [`src/ipc/capnp/`](../../src/ipc/capnp/). While this keeps C++ interface headers simple and free of references to IPC, it is a maintence burden because it means inconsistencies between C++ declarations and Cap’n Proto declarations will result in compile errors. (Static type checking ensures these are not runtime errors.)\n+\n+An alternate approach could use custom [C++ Attributes](https://en.cppreference.com/w/cpp/language/attributes) embedded in interface declarations to automatically generate `.capnp` files directly from C++ headers. This has not been pursued because parsing C++ headers is more complicated than parsing Cap’n Proto interface definitions, especially portably on multiple platforms.\n+\n+### Interface Stability\n+\n+The currently defined IPC interfaces are unstable, and can change freely with no backwards compatibility. The decision to allow this stems from the recognition that our current interfaces are still evolving and not yet ideal for external use. As these interfaces mature and become more refined, there may be an opportunity to declare them stable and use Cap’n Proto's support for protocol evolution ([Cap'n Proto - Evolving Your Protocol](https://capnproto.org/language.html#evolving-your-protocol)) to allow them to be extended while remaining backwards compatible. This could allow different versions of node, GUI, and wallet binaries to interoperate, and potentially open doors for external tools to utilize these interfaces, such as creating custom indexes through a stable indexing interface. However, for now, the priority is to improve the interfaces internally. Given their current state and the advantages of using JSON-RPC for most common tasks, it's more practical to focus on internal development rather than external applicability.\n+\n+## Example Use Cases and Flows\n+\n+### Retrieving a Block Hash\n+\n+Let’s walk through an example where the `bitcoin-wallet` process requests the hash of a block at a specific height from the `bitcoin-node` process. This example demonstrates the practical application of the IPC mechanism, specifically the interplay between C++ method calls and Cap’n Proto-generated RPC calls.\n+\n+1. **Initiation in bitcoin-wallet**\n+   - The wallet process calls the `getBlockHash` method on a `Chain` object. This method is defined as a virtual function in [`src/interfaces/chain.h`](../../src/interfaces/chain.h).\n+\n+2. **Translation to Cap’n Proto RPC**\n+   - The call to `getBlockHash` is translated into a Cap’n Proto RPC call. This translation is handled by code automatically generated by the `mpgen` tool, based on the [`chain.capnp`](../../src/ipc/capnp/chain.capnp)` file in [`src/ipc/capnp/`](../../src/ipc/capnp/).\n+\n+3. **Request Preparation and Dispatch**\n+   - The generated `Chain` subclass in `bitcoin-wallet` populates a Cap’n Proto request with the `height` parameter.\n+   - The request is sent to the `bitcoin-node` process.\n+\n+4. **Handling in bitcoin-node**\n+   - Upon receiving the request, the `bitcoin-node` process reads the `height` value from the request.\n+   - It then calls the `getBlockHash` method on its local `Chain` object with the provided `height`.\n+\n+5. **Response and Return**\n+   - The `bitcoin-node` process takes the `getBlockHash` return value, encapsulates it in a Cap’n Proto response, and sends it back to the `bitcoin-wallet` process.\n+   - The `bitcoin-wallet` process receives the response, extracts the block hash value, and returns it to the original caller.\n+\n+## Future Enhancements\n+\n+Further improvements are possible such as:\n+\n+- Separating indexes from `bitcoin-node`, and running indexing code in separate processes (see [indexes: Stop using node internal types #24230](https://github.com/bitcoin/bitcoin/pull/24230)).\n+- Enabling wallet processes to listen for JSON-RPC requests on their own ports instead of needing the node process to listen and forward requests to them.\n+- Automatically generating `.capnp` files from C++ interface definitions (see [Interface Definition Maintenance](#interface-definition-maintenance)).\n+- Simplifying and stabilizing interfaces (see [Interface Stability](#interface-stability)).\n+- Adding sandbox features, restricting subprocess access to resources and data (see [https://eklitzke.org/multiprocess-bitcoin](https://eklitzke.org/multiprocess-bitcoin)).\n+- Using Cap'n Proto's support for [other languages](https://capnproto.org/otherlang.html), such as [Rust](https://github.com/capnproto/capnproto-rust), to allow code written in other languages to call Bitcoin Core C++ code, and vice versa (see [How to rustify libmultiprocess? #56](https://github.com/chaincodelabs/libmultiprocess/issues/56)).\n+\n+## Conclusion",
      "path": "doc/design/multiprocess.md",
      "position": 276,
      "original_position": 225,
      "commit_id": "91dc48c14825a9075a57c1eefda202b83b6346ba",
      "original_commit_id": "837c53d14f24924cdcb2cfd8b18915882dc3b620",
      "in_reply_to_id": null,
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: This just repeats what is said in the Introduction part and isn't really needed for the purpose of this doc IMO",
      "created_at": "2023-12-15T16:09:29Z",
      "updated_at": "2023-12-15T16:48:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28978#discussion_r1428154601",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1428154601"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28978"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 217,
      "original_line": 217,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1428162298",
      "pull_request_review_id": 1782842554,
      "id": 1428162298,
      "node_id": "PRRC_kwDOABII585VIAb6",
      "diff_hunk": "@@ -1,72 +1,200 @@\n-# Multiprocess Bitcoin\n-\n-On unix systems, the `--enable-multiprocess` build option can be passed to `./configure` to build new `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables alongside existing `bitcoind` and `bitcoin-qt` executables.\n-\n-`bitcoin-node` is a drop-in replacement for `bitcoind`, and `bitcoin-gui` is a drop-in replacement for `bitcoin-qt`, and there are no differences in use or external behavior between the new and old executables. But internally (after [#10102](https://github.com/bitcoin/bitcoin/pull/10102)), `bitcoin-gui` will spawn a `bitcoin-node` process to run P2P and RPC code, communicating with it across a socket pair, and `bitcoin-node` will spawn `bitcoin-wallet` to run wallet code, also communicating over a socket pair. This will let node, wallet, and GUI code run in separate address spaces for better isolation, and allow future improvements like being able to start and stop components independently on different machines and environments.\n-\n-## Next steps\n-\n-Specific next steps after [#10102](https://github.com/bitcoin/bitcoin/pull/10102) will be:\n-\n-- [ ] Adding `-ipcbind` and `-ipcconnect` options to `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables so they can listen and connect to TCP ports and unix socket paths. This will allow separate processes to be started and stopped any time and connect to each other.\n-- [ ] Adding `-server` and `-rpcbind` options to the `bitcoin-wallet` executable so wallet processes can handle RPC requests directly without going through the node.\n-- [ ] Supporting windows, not just unix systems. The existing socket code is already cross-platform, so the only windows-specific code that needs to be written is code spawning a process and passing a socket descriptor. This can be implemented with `CreateProcess` and `WSADuplicateSocket`. Example: https://memset.wordpress.com/2010/10/13/win32-api-passing-socket-with-ipc-method/.\n-- [ ] Adding sandbox features, restricting subprocess access to resources and data. See [https://eklitzke.org/multiprocess-bitcoin](https://eklitzke.org/multiprocess-bitcoin).\n-\n-## Debugging\n-\n-The `-debug=ipc` command line option can be used to see requests and responses between processes.\n-\n-## Installation\n-\n-The multiprocess feature requires [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) as dependencies. A simple way to get starting using it without installing these dependencies manually is to use the [depends system](../../depends) with the `MULTIPROCESS=1` [dependency option](../../depends#dependency-options) passed to make:\n-\n-```\n-cd <BITCOIN_SOURCE_DIRECTORY>\n-make -C depends NO_QT=1 MULTIPROCESS=1\n-CONFIG_SITE=$PWD/depends/x86_64-pc-linux-gnu/share/config.site ./configure\n-make\n-src/bitcoin-node -regtest -printtoconsole -debug=ipc\n-BITCOIND=bitcoin-node test/functional/test_runner.py\n-```\n-\n-The configure script will pick up settings and library locations from the depends directory, so there is no need to pass `--enable-multiprocess` as a separate flag when using the depends system (it's controlled by the `MULTIPROCESS=1` option).\n-\n-Alternately, you can install [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) packages on your system, and just run `./configure --enable-multiprocess` without using the depends system. The configure script will be able to locate the installed packages via [pkg-config](https://www.freedesktop.org/wiki/Software/pkg-config/). See [Installation](https://github.com/chaincodelabs/libmultiprocess/blob/master/doc/install.md) section of the libmultiprocess readme for install steps. See [build-unix.md](../build-unix.md) and [build-osx.md](../build-osx.md) for information about installing dependencies in general.\n-\n-## IPC implementation details\n-\n-Cross process Node, Wallet, and Chain interfaces are defined in\n-[`src/interfaces/`](../../src/interfaces/). These are C++ classes which follow\n-[conventions](../developer-notes.md#internal-interface-guidelines), like passing\n-serializable arguments so they can be called from different processes, and\n-making methods pure virtual so they can have proxy implementations that forward\n-calls between processes.\n-\n-When Wallet, Node, and Chain code is running in the same process, calling any\n-interface method invokes the implementation directly. When code is running in\n-different processes, calling an interface method invokes a proxy interface\n-implementation that communicates with a remote process and invokes the real\n-implementation in the remote process. The\n-[libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) code\n-generation tool internally generates proxy client classes and proxy server\n-classes for this purpose that are thin wrappers around Cap'n Proto\n-[client](https://capnproto.org/cxxrpc.html#clients) and\n-[server](https://capnproto.org/cxxrpc.html#servers) classes, which handle the\n-actual serialization and socket communication.\n-\n-As much as possible, calls between processes are meant to work the same as\n-calls within a single process without adding limitations or requiring extra\n-implementation effort. Processes communicate with each other by calling regular\n-[C++ interface methods](../../src/interfaces/README.md). Method arguments and\n-return values are automatically serialized and sent between processes. Object\n-references and `std::function` arguments are automatically tracked and mapped\n-to allow invoked code to call back into invoking code at any time, and there is\n-a 1:1 threading model where any thread invoking a method in another process has\n-a corresponding thread in the invoked process responsible for executing all\n-method calls from the source thread, without blocking I/O or holding up another\n-call, and using the same thread local variables, locks, and callbacks between\n-calls. The forwarding, tracking, and threading is implemented inside the\n-[libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) library\n-which has the design goal of making calls between processes look like calls in\n-the same process to the extent possible.\n+# Multiprocess Bitcoin Design Document\n+\n+Guide to the design and architecture of the Bitcoin-Core multiprocess feature\n+\n+_This document describes the design of the multiprocess feature. For usage information, see the top-level [multiprocess.md](../multiprocess.md) file._\n+\n+## Table of contents\n+\n+- [Introduction](#introduction)\n+- [Current Architecture](#current-architecture)\n+- [Proposed Architecture](#proposed-architecture)\n+- [Component Overview: Navigating the IPC Framework](#component-overview-navigating-the-ipc-framework)\n+- [Design Considerations](#design-considerations)\n+  - [Selection of Cap’n Proto](#selection-of-capn-proto)\n+  - [Hiding IPC](#hiding-ipc)\n+  - [Interface Definition Maintenance](#interface-definition-maintenance)\n+  - [Interface Stability](#interface-stability)\n+- [Example Use Cases and Flows](#example-use-cases-and-flows)\n+  - [Retrieving a Block Hash](#retrieving-a-block-hash)\n+- [Future Enhancements](#future-enhancements)\n+- [Conclusion](#conclusion)\n+- [Appendices](#appendices)\n+  - [Glossary of Terms](#glossary-of-terms)\n+  - [References](#references)\n+- [Acknowledgements](#acknowledgements)\n+\n+## Introduction\n+\n+The Bitcoin Core software, central to the Bitcoin network, has historically employed a monolithic architecture. The existing design has integrated functionality like P2P network operations, wallet management, and a GUI into a single executable. While effective, it has limitations in flexibility, security, and scalability. This project introduces changes that transition Bitcoin Core to a more modular architecture. It aims to enhance security, improve usability, and facilitate maintenance and development of the software.\n+\n+## Current Architecture\n+\n+The current system features two primary executables: `bitcoind` and `bitcoin-qt`. `bitcoind` combines a Bitcoin P2P node with an integrated JSON-RPC server, wallet, and indexes. `bitcoin-qt` extends this by incorporating a Qt-based GUI. This monolithic structure, although robust, presents challenges such as limited operational flexibility and increased security risks due to the tight integration of components.\n+\n+## Proposed Architecture\n+\n+The new architecture divides the existing code into three specialized executables:\n+\n+- `bitcoin-node`: Manages the node, indexes, and JSON-RPC server.\n+- `bitcoin-wallet`: Handles all wallet functionality.\n+- `bitcoin-gui`: Provides a standalone Qt-based GUI.\n+\n+This modular approach is designed to enhance security through component isolation and improve usability by allowing independent operation of each module. This allows for new use-cases, such as running the node on a dedicated machine and operating wallets and GUIs on separate machines with the flexibility to start and stop them as needed.\n+\n+This subdivision could be extended in the future. For example, indexes could be removed from the `bitcoin-node` executable and run in separate executables. And JSON-RPC servers could be added to wallet and index executables, so they can listen and respond to RPC requests on their own ports, without needing to forward RPC requests through `bitcoin-node`.\n+\n+## Component Overview: Navigating the IPC Framework\n+\n+This section describes the major components of the Inter-Process Communication (IPC) framework covering the relevant source files, generated files, tools, and libraries.\n+\n+### Abstract C++ Classes in [`src/interfaces/`](../../src/interfaces/)\n+- The foundation of the IPC implementation lies in the abstract C++ classes within the [`src/interfaces/`](../../src/interfaces/) directory. These classes define pure virtual methods that code in [`src/node/`](../../src/node/), [`src/wallet/`](../../src/wallet/), and [`src/qt/`](../../src/qt/) directories call to interact with each other.\n+- Each abstract class in this directory represents a distinct interface that the different modules (node, wallet, GUI) implement and use for cross-process communication.\n+- The classes are written following conventions described in [Internal Interface\n+  Guidelines](../developer-notes.md#internal-interface-guidelines) to ensure\n+  compatibility with Cap'n Proto.\n+\n+### Cap’n Proto Files in [`src/ipc/capnp/`](../../src/ipc/capnp/)\n+- Corresponding to each abstract class, there are `.capnp` files within the [`src/ipc/capnp/`](../../src/ipc/capnp/) directory. These files are used as input to the `mpgen` tool (described below) to generate C++ code.\n+- These Cap’n Proto files ([learn more about Cap'n Proto RPC](https://capnproto.org/rpc.html)) define the structure and format of messages that are exchanged over IPC. They serve as blueprints for generating C++ code that bridges the gap between high-level C++ interfaces and low-level socket communication.\n+\n+### The `mpgen` Code Generation Tool\n+- A central component of the IPC framework is the `mpgen` tool which is part the [`libmultiprocess` project](https://github.com/chaincodelabs/libmultiprocess). This tool takes the `.capnp` files as input and generates C++ code.\n+- The generated code handles IPC communication, translating interface calls into socket reads and writes.\n+\n+### C++ Client Subclasses in Generated Code\n+- In the generated code, we have C++ client subclasses that inherit from the abstract classes in [`src/interfaces/`](../../src/interfaces/). These subclasses are the workhorses of the IPC mechanism.\n+- They implement all the methods of the interface, marshalling arguments into a structured format, sending them as requests to the IPC server via a UNIX socket, and handling the responses.\n+- These subclasses effectively mask the complexity of IPC, presenting a familiar C++ interface to developers.\n+- Internally, the client subclasses generated by the `mpgen` tool wrap [client classes generated by Cap'n Proto](https://capnproto.org/cxxrpc.html#clients), and use them to send IPC requests.\n+\n+### C++ Server Classes in Generated Code\n+- On the server side, corresponding generated C++ classes receive IPC requests. These server classes are responsible for unmarshalling method arguments, invoking the corresponding methods in the local [`src/interfaces/`](../../src/interfaces/) objects, and creating the IPC response.\n+- The server classes ensure that return values (including output argument values and thrown exceptions) are marshalled and sent back to the client, completing the communication cycle.\n+- Internally, the server subclasses generated by the `mpgen` tool inherit from [server classes generated by Cap'n Proto](https://capnproto.org/cxxrpc.html#servers), and use them to process IPC requests.\n+\n+### The `libmultiprocess` Runtime Library\n+- **Core Functionality**: The `libmultiprocess` runtime library's primary function is to instantiate the generated client and server classes as needed.\n+- **Bootstrapping IPC Connections**: It provides functions for starting new IPC connections, specifically binding generated client and server classes for an initial `interfaces::Init` interface (defined in [`src/interfaces/init.h`](../../src/interfaces/init.h)) to a UNIX socket. This initial interface has methods returning other interfaces that different Bitcoin-Core modules use to communicate after the bootstrapping phase.\n+- **Asynchronous I/O and Thread Management**: The library is also responsible for managing I/O and threading. Particularly, it ensures that IPC requests never block each other and that new threads on either side of a connection can always make client calls. It also manages worker threads on the server side of calls, ensuring that calls from the same client thread always execute on the same server thread (to avoid locking issues and support nested callbacks).\n+\n+### Type Hooks in [`src/ipc/capnp/*-types.h`](../../src/ipc/capnp/)\n+- **Custom Type Conversions**: In [`src/ipc/capnp/*-types.h`](../../src/ipc/capnp/), multiple function overloads of two `libmultiprocess` C++ functions, `mp::CustomReadField` and `mp::CustomBuildFields`, are defined. These functions are used for customizing the conversion of specific C++ types to and from Cap’n Proto types.\n+- **Handling Special Cases**: The `mpgen` tool and `libmultiprocess` library can convert most C++ types to and from Cap’n Proto types automatically, including interface types, primitive C++ types, standard C++ types like `std::vector`, `std::set`, `std::map`, `std::tuple`, and `std::function`, as well as simple C++ structs that consist of afforementioned types and whose fields correspond 1:1 with Cap’n Proto struct fields. For other types, `*-types.h` files provide custom code to convert between C++ and Cap’n Proto data representations.",
      "path": "doc/design/multiprocess.md",
      "position": null,
      "original_position": 156,
      "commit_id": "91dc48c14825a9075a57c1eefda202b83b6346ba",
      "original_commit_id": "837c53d14f24924cdcb2cfd8b18915882dc3b620",
      "in_reply_to_id": null,
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: typo\r\n```suggestion\r\n- **Handling Special Cases**: The `mpgen` tool and `libmultiprocess` library can convert most C++ types to and from Cap’n Proto types automatically, including interface types, primitive C++ types, standard C++ types like `std::vector`, `std::set`, `std::map`, `std::tuple`, and `std::function`, as well as simple C++ structs that consist of aforementioned types and whose fields correspond 1:1 with Cap’n Proto struct fields. For other types, `*-types.h` files provide custom code to convert between C++ and Cap’n Proto data representations.\r\n```",
      "created_at": "2023-12-15T16:16:16Z",
      "updated_at": "2023-12-15T16:48:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28978#discussion_r1428162298",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1428162298"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28978"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 84,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1428164608",
      "pull_request_review_id": 1782842554,
      "id": 1428164608,
      "node_id": "PRRC_kwDOABII585VIBAA",
      "diff_hunk": "@@ -1,72 +1,200 @@\n-# Multiprocess Bitcoin\n-\n-On unix systems, the `--enable-multiprocess` build option can be passed to `./configure` to build new `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables alongside existing `bitcoind` and `bitcoin-qt` executables.\n-\n-`bitcoin-node` is a drop-in replacement for `bitcoind`, and `bitcoin-gui` is a drop-in replacement for `bitcoin-qt`, and there are no differences in use or external behavior between the new and old executables. But internally (after [#10102](https://github.com/bitcoin/bitcoin/pull/10102)), `bitcoin-gui` will spawn a `bitcoin-node` process to run P2P and RPC code, communicating with it across a socket pair, and `bitcoin-node` will spawn `bitcoin-wallet` to run wallet code, also communicating over a socket pair. This will let node, wallet, and GUI code run in separate address spaces for better isolation, and allow future improvements like being able to start and stop components independently on different machines and environments.\n-\n-## Next steps\n-\n-Specific next steps after [#10102](https://github.com/bitcoin/bitcoin/pull/10102) will be:\n-\n-- [ ] Adding `-ipcbind` and `-ipcconnect` options to `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables so they can listen and connect to TCP ports and unix socket paths. This will allow separate processes to be started and stopped any time and connect to each other.\n-- [ ] Adding `-server` and `-rpcbind` options to the `bitcoin-wallet` executable so wallet processes can handle RPC requests directly without going through the node.\n-- [ ] Supporting windows, not just unix systems. The existing socket code is already cross-platform, so the only windows-specific code that needs to be written is code spawning a process and passing a socket descriptor. This can be implemented with `CreateProcess` and `WSADuplicateSocket`. Example: https://memset.wordpress.com/2010/10/13/win32-api-passing-socket-with-ipc-method/.\n-- [ ] Adding sandbox features, restricting subprocess access to resources and data. See [https://eklitzke.org/multiprocess-bitcoin](https://eklitzke.org/multiprocess-bitcoin).\n-\n-## Debugging\n-\n-The `-debug=ipc` command line option can be used to see requests and responses between processes.\n-\n-## Installation\n-\n-The multiprocess feature requires [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) as dependencies. A simple way to get starting using it without installing these dependencies manually is to use the [depends system](../../depends) with the `MULTIPROCESS=1` [dependency option](../../depends#dependency-options) passed to make:\n-\n-```\n-cd <BITCOIN_SOURCE_DIRECTORY>\n-make -C depends NO_QT=1 MULTIPROCESS=1\n-CONFIG_SITE=$PWD/depends/x86_64-pc-linux-gnu/share/config.site ./configure\n-make\n-src/bitcoin-node -regtest -printtoconsole -debug=ipc\n-BITCOIND=bitcoin-node test/functional/test_runner.py\n-```\n-\n-The configure script will pick up settings and library locations from the depends directory, so there is no need to pass `--enable-multiprocess` as a separate flag when using the depends system (it's controlled by the `MULTIPROCESS=1` option).\n-\n-Alternately, you can install [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) packages on your system, and just run `./configure --enable-multiprocess` without using the depends system. The configure script will be able to locate the installed packages via [pkg-config](https://www.freedesktop.org/wiki/Software/pkg-config/). See [Installation](https://github.com/chaincodelabs/libmultiprocess/blob/master/doc/install.md) section of the libmultiprocess readme for install steps. See [build-unix.md](../build-unix.md) and [build-osx.md](../build-osx.md) for information about installing dependencies in general.\n-\n-## IPC implementation details\n-\n-Cross process Node, Wallet, and Chain interfaces are defined in\n-[`src/interfaces/`](../../src/interfaces/). These are C++ classes which follow\n-[conventions](../developer-notes.md#internal-interface-guidelines), like passing\n-serializable arguments so they can be called from different processes, and\n-making methods pure virtual so they can have proxy implementations that forward\n-calls between processes.\n-\n-When Wallet, Node, and Chain code is running in the same process, calling any\n-interface method invokes the implementation directly. When code is running in\n-different processes, calling an interface method invokes a proxy interface\n-implementation that communicates with a remote process and invokes the real\n-implementation in the remote process. The\n-[libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) code\n-generation tool internally generates proxy client classes and proxy server\n-classes for this purpose that are thin wrappers around Cap'n Proto\n-[client](https://capnproto.org/cxxrpc.html#clients) and\n-[server](https://capnproto.org/cxxrpc.html#servers) classes, which handle the\n-actual serialization and socket communication.\n-\n-As much as possible, calls between processes are meant to work the same as\n-calls within a single process without adding limitations or requiring extra\n-implementation effort. Processes communicate with each other by calling regular\n-[C++ interface methods](../../src/interfaces/README.md). Method arguments and\n-return values are automatically serialized and sent between processes. Object\n-references and `std::function` arguments are automatically tracked and mapped\n-to allow invoked code to call back into invoking code at any time, and there is\n-a 1:1 threading model where any thread invoking a method in another process has\n-a corresponding thread in the invoked process responsible for executing all\n-method calls from the source thread, without blocking I/O or holding up another\n-call, and using the same thread local variables, locks, and callbacks between\n-calls. The forwarding, tracking, and threading is implemented inside the\n-[libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) library\n-which has the design goal of making calls between processes look like calls in\n-the same process to the extent possible.\n+# Multiprocess Bitcoin Design Document\n+\n+Guide to the design and architecture of the Bitcoin-Core multiprocess feature\n+\n+_This document describes the design of the multiprocess feature. For usage information, see the top-level [multiprocess.md](../multiprocess.md) file._\n+\n+## Table of contents\n+\n+- [Introduction](#introduction)\n+- [Current Architecture](#current-architecture)\n+- [Proposed Architecture](#proposed-architecture)\n+- [Component Overview: Navigating the IPC Framework](#component-overview-navigating-the-ipc-framework)\n+- [Design Considerations](#design-considerations)\n+  - [Selection of Cap’n Proto](#selection-of-capn-proto)\n+  - [Hiding IPC](#hiding-ipc)\n+  - [Interface Definition Maintenance](#interface-definition-maintenance)\n+  - [Interface Stability](#interface-stability)\n+- [Example Use Cases and Flows](#example-use-cases-and-flows)\n+  - [Retrieving a Block Hash](#retrieving-a-block-hash)\n+- [Future Enhancements](#future-enhancements)\n+- [Conclusion](#conclusion)\n+- [Appendices](#appendices)\n+  - [Glossary of Terms](#glossary-of-terms)\n+  - [References](#references)\n+- [Acknowledgements](#acknowledgements)\n+\n+## Introduction\n+\n+The Bitcoin Core software, central to the Bitcoin network, has historically employed a monolithic architecture. The existing design has integrated functionality like P2P network operations, wallet management, and a GUI into a single executable. While effective, it has limitations in flexibility, security, and scalability. This project introduces changes that transition Bitcoin Core to a more modular architecture. It aims to enhance security, improve usability, and facilitate maintenance and development of the software.\n+\n+## Current Architecture\n+\n+The current system features two primary executables: `bitcoind` and `bitcoin-qt`. `bitcoind` combines a Bitcoin P2P node with an integrated JSON-RPC server, wallet, and indexes. `bitcoin-qt` extends this by incorporating a Qt-based GUI. This monolithic structure, although robust, presents challenges such as limited operational flexibility and increased security risks due to the tight integration of components.\n+\n+## Proposed Architecture\n+\n+The new architecture divides the existing code into three specialized executables:\n+\n+- `bitcoin-node`: Manages the node, indexes, and JSON-RPC server.\n+- `bitcoin-wallet`: Handles all wallet functionality.\n+- `bitcoin-gui`: Provides a standalone Qt-based GUI.\n+\n+This modular approach is designed to enhance security through component isolation and improve usability by allowing independent operation of each module. This allows for new use-cases, such as running the node on a dedicated machine and operating wallets and GUIs on separate machines with the flexibility to start and stop them as needed.\n+\n+This subdivision could be extended in the future. For example, indexes could be removed from the `bitcoin-node` executable and run in separate executables. And JSON-RPC servers could be added to wallet and index executables, so they can listen and respond to RPC requests on their own ports, without needing to forward RPC requests through `bitcoin-node`.\n+\n+## Component Overview: Navigating the IPC Framework\n+\n+This section describes the major components of the Inter-Process Communication (IPC) framework covering the relevant source files, generated files, tools, and libraries.\n+\n+### Abstract C++ Classes in [`src/interfaces/`](../../src/interfaces/)\n+- The foundation of the IPC implementation lies in the abstract C++ classes within the [`src/interfaces/`](../../src/interfaces/) directory. These classes define pure virtual methods that code in [`src/node/`](../../src/node/), [`src/wallet/`](../../src/wallet/), and [`src/qt/`](../../src/qt/) directories call to interact with each other.\n+- Each abstract class in this directory represents a distinct interface that the different modules (node, wallet, GUI) implement and use for cross-process communication.\n+- The classes are written following conventions described in [Internal Interface\n+  Guidelines](../developer-notes.md#internal-interface-guidelines) to ensure\n+  compatibility with Cap'n Proto.\n+\n+### Cap’n Proto Files in [`src/ipc/capnp/`](../../src/ipc/capnp/)\n+- Corresponding to each abstract class, there are `.capnp` files within the [`src/ipc/capnp/`](../../src/ipc/capnp/) directory. These files are used as input to the `mpgen` tool (described below) to generate C++ code.\n+- These Cap’n Proto files ([learn more about Cap'n Proto RPC](https://capnproto.org/rpc.html)) define the structure and format of messages that are exchanged over IPC. They serve as blueprints for generating C++ code that bridges the gap between high-level C++ interfaces and low-level socket communication.\n+\n+### The `mpgen` Code Generation Tool\n+- A central component of the IPC framework is the `mpgen` tool which is part the [`libmultiprocess` project](https://github.com/chaincodelabs/libmultiprocess). This tool takes the `.capnp` files as input and generates C++ code.\n+- The generated code handles IPC communication, translating interface calls into socket reads and writes.\n+\n+### C++ Client Subclasses in Generated Code\n+- In the generated code, we have C++ client subclasses that inherit from the abstract classes in [`src/interfaces/`](../../src/interfaces/). These subclasses are the workhorses of the IPC mechanism.\n+- They implement all the methods of the interface, marshalling arguments into a structured format, sending them as requests to the IPC server via a UNIX socket, and handling the responses.\n+- These subclasses effectively mask the complexity of IPC, presenting a familiar C++ interface to developers.\n+- Internally, the client subclasses generated by the `mpgen` tool wrap [client classes generated by Cap'n Proto](https://capnproto.org/cxxrpc.html#clients), and use them to send IPC requests.\n+\n+### C++ Server Classes in Generated Code\n+- On the server side, corresponding generated C++ classes receive IPC requests. These server classes are responsible for unmarshalling method arguments, invoking the corresponding methods in the local [`src/interfaces/`](../../src/interfaces/) objects, and creating the IPC response.\n+- The server classes ensure that return values (including output argument values and thrown exceptions) are marshalled and sent back to the client, completing the communication cycle.\n+- Internally, the server subclasses generated by the `mpgen` tool inherit from [server classes generated by Cap'n Proto](https://capnproto.org/cxxrpc.html#servers), and use them to process IPC requests.\n+\n+### The `libmultiprocess` Runtime Library\n+- **Core Functionality**: The `libmultiprocess` runtime library's primary function is to instantiate the generated client and server classes as needed.\n+- **Bootstrapping IPC Connections**: It provides functions for starting new IPC connections, specifically binding generated client and server classes for an initial `interfaces::Init` interface (defined in [`src/interfaces/init.h`](../../src/interfaces/init.h)) to a UNIX socket. This initial interface has methods returning other interfaces that different Bitcoin-Core modules use to communicate after the bootstrapping phase.\n+- **Asynchronous I/O and Thread Management**: The library is also responsible for managing I/O and threading. Particularly, it ensures that IPC requests never block each other and that new threads on either side of a connection can always make client calls. It also manages worker threads on the server side of calls, ensuring that calls from the same client thread always execute on the same server thread (to avoid locking issues and support nested callbacks).\n+\n+### Type Hooks in [`src/ipc/capnp/*-types.h`](../../src/ipc/capnp/)\n+- **Custom Type Conversions**: In [`src/ipc/capnp/*-types.h`](../../src/ipc/capnp/), multiple function overloads of two `libmultiprocess` C++ functions, `mp::CustomReadField` and `mp::CustomBuildFields`, are defined. These functions are used for customizing the conversion of specific C++ types to and from Cap’n Proto types.\n+- **Handling Special Cases**: The `mpgen` tool and `libmultiprocess` library can convert most C++ types to and from Cap’n Proto types automatically, including interface types, primitive C++ types, standard C++ types like `std::vector`, `std::set`, `std::map`, `std::tuple`, and `std::function`, as well as simple C++ structs that consist of afforementioned types and whose fields correspond 1:1 with Cap’n Proto struct fields. For other types, `*-types.h` files provide custom code to convert between C++ and Cap’n Proto data representations.\n+\n+### Protocol-Agnostic IPC Code in [`src/ipc/`](../../src/ipc/)\n+- **Broad Applicability**: Unlike the Cap’n Proto-specific code in [`src/ipc/capnp/`](../../src/ipc/capnp/), the code in the [`src/ipc/`](../../src/ipc/) directory is protocol-agnostic. This enables potential support for other protocols, such as gRPC or a custom protocol in the future.\n+- **Process Management and Socket Operations**: The main purpose of this component is to provide functions for spawning new processes and creating and connecting to UNIX sockets.\n+- **ipc::Exception Class**: This code also defines an `ipc::Exception` class which is thrown from the generated C++ client class methods when there is an unexpected IPC error, such as a disconnection.\n+\n+## Design Considerations\n+\n+### Selection of Cap’n Proto\n+The choice to use [Cap’n Proto](https://capnproto.org/) for IPC was primarily influenced by its support for passing object references and managing object lifetimes, which would have to be implemented manually with a framework that only supported plain requests and responses like [gRPC](https://grpc.io/). The support is especially helpful for passing callback objects like `std::function` and supporting bidirectional communication.\n+\n+The choice to use an RPC framework at all instead of a custom protocol was neccesitated by the size of Bitcoin Core internal interfaces which consist of around 150 methods that pass complex data structures and are called in complicated ways (in parallel, from callbacks that can be nested and stored). Writing a custom protocol to wrap these complicated interfaces would be too much work, akin to writing a new RPC framework.\n+\n+### Hiding IPC\n+\n+The IPC mechanism is deliberately isolated from the rest of the codebase so less code has to be concerned with IPC.\n+\n+Building Bitcoin Core with IPC support is optional, and the same code can be compiled to either run in the same process or separate processes. The build system also ensures Cap’n Proto library headers can only be used within the [`src/ipc/capnp/`](../../src/ipc/capnp/) directory, not in other parts of the codebase.\n+\n+The libmultiprocess runtime is designed to place as few constraints as possible on IPC interfaces and make IPC calls act like normal function calls. Method arguments, return values, and exceptions are automatically serialized and sent between processes. Object references and `std::function` arguments are automatically tracked and mapped to allow invoked code to call back into invoking code at any time. And there is a 1:1 threading model where any every client thread has a corresponding server thread responsible for executing incoming calls from that thread (there can be multiple calls from the same thread due to callbacks), without blocking, and holding the same thread-local variables and locks so behavior is the same whether IPC is used or not.",
      "path": "doc/design/multiprocess.md",
      "position": null,
      "original_position": 176,
      "commit_id": "91dc48c14825a9075a57c1eefda202b83b6346ba",
      "original_commit_id": "837c53d14f24924cdcb2cfd8b18915882dc3b620",
      "in_reply_to_id": null,
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\nThe libmultiprocess runtime is designed to place as few constraints as possible on IPC interfaces and make IPC calls act like normal function calls. Method arguments, return values, and exceptions are automatically serialized and sent between processes. Object references and `std::function` arguments are automatically tracked and mapped to allow invoked code to call back into invoking code at any time. And there is a 1:1 threading model where every client thread has a corresponding server thread responsible for executing incoming calls from that thread (there can be multiple calls from the same thread due to callbacks), without blocking, and holding the same thread-local variables and locks so behavior is the same whether IPC is used or not.\r\n```",
      "created_at": "2023-12-15T16:18:12Z",
      "updated_at": "2023-12-15T16:48:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28978#discussion_r1428164608",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1428164608"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28978"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 104,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1428165515",
      "pull_request_review_id": 1782842554,
      "id": 1428165515,
      "node_id": "PRRC_kwDOABII585VIBOL",
      "diff_hunk": "@@ -1,72 +1,200 @@\n-# Multiprocess Bitcoin\n-\n-On unix systems, the `--enable-multiprocess` build option can be passed to `./configure` to build new `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables alongside existing `bitcoind` and `bitcoin-qt` executables.\n-\n-`bitcoin-node` is a drop-in replacement for `bitcoind`, and `bitcoin-gui` is a drop-in replacement for `bitcoin-qt`, and there are no differences in use or external behavior between the new and old executables. But internally (after [#10102](https://github.com/bitcoin/bitcoin/pull/10102)), `bitcoin-gui` will spawn a `bitcoin-node` process to run P2P and RPC code, communicating with it across a socket pair, and `bitcoin-node` will spawn `bitcoin-wallet` to run wallet code, also communicating over a socket pair. This will let node, wallet, and GUI code run in separate address spaces for better isolation, and allow future improvements like being able to start and stop components independently on different machines and environments.\n-\n-## Next steps\n-\n-Specific next steps after [#10102](https://github.com/bitcoin/bitcoin/pull/10102) will be:\n-\n-- [ ] Adding `-ipcbind` and `-ipcconnect` options to `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables so they can listen and connect to TCP ports and unix socket paths. This will allow separate processes to be started and stopped any time and connect to each other.\n-- [ ] Adding `-server` and `-rpcbind` options to the `bitcoin-wallet` executable so wallet processes can handle RPC requests directly without going through the node.\n-- [ ] Supporting windows, not just unix systems. The existing socket code is already cross-platform, so the only windows-specific code that needs to be written is code spawning a process and passing a socket descriptor. This can be implemented with `CreateProcess` and `WSADuplicateSocket`. Example: https://memset.wordpress.com/2010/10/13/win32-api-passing-socket-with-ipc-method/.\n-- [ ] Adding sandbox features, restricting subprocess access to resources and data. See [https://eklitzke.org/multiprocess-bitcoin](https://eklitzke.org/multiprocess-bitcoin).\n-\n-## Debugging\n-\n-The `-debug=ipc` command line option can be used to see requests and responses between processes.\n-\n-## Installation\n-\n-The multiprocess feature requires [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) as dependencies. A simple way to get starting using it without installing these dependencies manually is to use the [depends system](../../depends) with the `MULTIPROCESS=1` [dependency option](../../depends#dependency-options) passed to make:\n-\n-```\n-cd <BITCOIN_SOURCE_DIRECTORY>\n-make -C depends NO_QT=1 MULTIPROCESS=1\n-CONFIG_SITE=$PWD/depends/x86_64-pc-linux-gnu/share/config.site ./configure\n-make\n-src/bitcoin-node -regtest -printtoconsole -debug=ipc\n-BITCOIND=bitcoin-node test/functional/test_runner.py\n-```\n-\n-The configure script will pick up settings and library locations from the depends directory, so there is no need to pass `--enable-multiprocess` as a separate flag when using the depends system (it's controlled by the `MULTIPROCESS=1` option).\n-\n-Alternately, you can install [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) packages on your system, and just run `./configure --enable-multiprocess` without using the depends system. The configure script will be able to locate the installed packages via [pkg-config](https://www.freedesktop.org/wiki/Software/pkg-config/). See [Installation](https://github.com/chaincodelabs/libmultiprocess/blob/master/doc/install.md) section of the libmultiprocess readme for install steps. See [build-unix.md](../build-unix.md) and [build-osx.md](../build-osx.md) for information about installing dependencies in general.\n-\n-## IPC implementation details\n-\n-Cross process Node, Wallet, and Chain interfaces are defined in\n-[`src/interfaces/`](../../src/interfaces/). These are C++ classes which follow\n-[conventions](../developer-notes.md#internal-interface-guidelines), like passing\n-serializable arguments so they can be called from different processes, and\n-making methods pure virtual so they can have proxy implementations that forward\n-calls between processes.\n-\n-When Wallet, Node, and Chain code is running in the same process, calling any\n-interface method invokes the implementation directly. When code is running in\n-different processes, calling an interface method invokes a proxy interface\n-implementation that communicates with a remote process and invokes the real\n-implementation in the remote process. The\n-[libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) code\n-generation tool internally generates proxy client classes and proxy server\n-classes for this purpose that are thin wrappers around Cap'n Proto\n-[client](https://capnproto.org/cxxrpc.html#clients) and\n-[server](https://capnproto.org/cxxrpc.html#servers) classes, which handle the\n-actual serialization and socket communication.\n-\n-As much as possible, calls between processes are meant to work the same as\n-calls within a single process without adding limitations or requiring extra\n-implementation effort. Processes communicate with each other by calling regular\n-[C++ interface methods](../../src/interfaces/README.md). Method arguments and\n-return values are automatically serialized and sent between processes. Object\n-references and `std::function` arguments are automatically tracked and mapped\n-to allow invoked code to call back into invoking code at any time, and there is\n-a 1:1 threading model where any thread invoking a method in another process has\n-a corresponding thread in the invoked process responsible for executing all\n-method calls from the source thread, without blocking I/O or holding up another\n-call, and using the same thread local variables, locks, and callbacks between\n-calls. The forwarding, tracking, and threading is implemented inside the\n-[libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) library\n-which has the design goal of making calls between processes look like calls in\n-the same process to the extent possible.\n+# Multiprocess Bitcoin Design Document\n+\n+Guide to the design and architecture of the Bitcoin-Core multiprocess feature\n+\n+_This document describes the design of the multiprocess feature. For usage information, see the top-level [multiprocess.md](../multiprocess.md) file._\n+\n+## Table of contents\n+\n+- [Introduction](#introduction)\n+- [Current Architecture](#current-architecture)\n+- [Proposed Architecture](#proposed-architecture)\n+- [Component Overview: Navigating the IPC Framework](#component-overview-navigating-the-ipc-framework)\n+- [Design Considerations](#design-considerations)\n+  - [Selection of Cap’n Proto](#selection-of-capn-proto)\n+  - [Hiding IPC](#hiding-ipc)\n+  - [Interface Definition Maintenance](#interface-definition-maintenance)\n+  - [Interface Stability](#interface-stability)\n+- [Example Use Cases and Flows](#example-use-cases-and-flows)\n+  - [Retrieving a Block Hash](#retrieving-a-block-hash)\n+- [Future Enhancements](#future-enhancements)\n+- [Conclusion](#conclusion)\n+- [Appendices](#appendices)\n+  - [Glossary of Terms](#glossary-of-terms)\n+  - [References](#references)\n+- [Acknowledgements](#acknowledgements)\n+\n+## Introduction\n+\n+The Bitcoin Core software, central to the Bitcoin network, has historically employed a monolithic architecture. The existing design has integrated functionality like P2P network operations, wallet management, and a GUI into a single executable. While effective, it has limitations in flexibility, security, and scalability. This project introduces changes that transition Bitcoin Core to a more modular architecture. It aims to enhance security, improve usability, and facilitate maintenance and development of the software.\n+\n+## Current Architecture\n+\n+The current system features two primary executables: `bitcoind` and `bitcoin-qt`. `bitcoind` combines a Bitcoin P2P node with an integrated JSON-RPC server, wallet, and indexes. `bitcoin-qt` extends this by incorporating a Qt-based GUI. This monolithic structure, although robust, presents challenges such as limited operational flexibility and increased security risks due to the tight integration of components.\n+\n+## Proposed Architecture\n+\n+The new architecture divides the existing code into three specialized executables:\n+\n+- `bitcoin-node`: Manages the node, indexes, and JSON-RPC server.\n+- `bitcoin-wallet`: Handles all wallet functionality.\n+- `bitcoin-gui`: Provides a standalone Qt-based GUI.\n+\n+This modular approach is designed to enhance security through component isolation and improve usability by allowing independent operation of each module. This allows for new use-cases, such as running the node on a dedicated machine and operating wallets and GUIs on separate machines with the flexibility to start and stop them as needed.\n+\n+This subdivision could be extended in the future. For example, indexes could be removed from the `bitcoin-node` executable and run in separate executables. And JSON-RPC servers could be added to wallet and index executables, so they can listen and respond to RPC requests on their own ports, without needing to forward RPC requests through `bitcoin-node`.\n+\n+## Component Overview: Navigating the IPC Framework\n+\n+This section describes the major components of the Inter-Process Communication (IPC) framework covering the relevant source files, generated files, tools, and libraries.\n+\n+### Abstract C++ Classes in [`src/interfaces/`](../../src/interfaces/)\n+- The foundation of the IPC implementation lies in the abstract C++ classes within the [`src/interfaces/`](../../src/interfaces/) directory. These classes define pure virtual methods that code in [`src/node/`](../../src/node/), [`src/wallet/`](../../src/wallet/), and [`src/qt/`](../../src/qt/) directories call to interact with each other.\n+- Each abstract class in this directory represents a distinct interface that the different modules (node, wallet, GUI) implement and use for cross-process communication.\n+- The classes are written following conventions described in [Internal Interface\n+  Guidelines](../developer-notes.md#internal-interface-guidelines) to ensure\n+  compatibility with Cap'n Proto.\n+\n+### Cap’n Proto Files in [`src/ipc/capnp/`](../../src/ipc/capnp/)\n+- Corresponding to each abstract class, there are `.capnp` files within the [`src/ipc/capnp/`](../../src/ipc/capnp/) directory. These files are used as input to the `mpgen` tool (described below) to generate C++ code.\n+- These Cap’n Proto files ([learn more about Cap'n Proto RPC](https://capnproto.org/rpc.html)) define the structure and format of messages that are exchanged over IPC. They serve as blueprints for generating C++ code that bridges the gap between high-level C++ interfaces and low-level socket communication.\n+\n+### The `mpgen` Code Generation Tool\n+- A central component of the IPC framework is the `mpgen` tool which is part the [`libmultiprocess` project](https://github.com/chaincodelabs/libmultiprocess). This tool takes the `.capnp` files as input and generates C++ code.\n+- The generated code handles IPC communication, translating interface calls into socket reads and writes.\n+\n+### C++ Client Subclasses in Generated Code\n+- In the generated code, we have C++ client subclasses that inherit from the abstract classes in [`src/interfaces/`](../../src/interfaces/). These subclasses are the workhorses of the IPC mechanism.\n+- They implement all the methods of the interface, marshalling arguments into a structured format, sending them as requests to the IPC server via a UNIX socket, and handling the responses.\n+- These subclasses effectively mask the complexity of IPC, presenting a familiar C++ interface to developers.\n+- Internally, the client subclasses generated by the `mpgen` tool wrap [client classes generated by Cap'n Proto](https://capnproto.org/cxxrpc.html#clients), and use them to send IPC requests.\n+\n+### C++ Server Classes in Generated Code\n+- On the server side, corresponding generated C++ classes receive IPC requests. These server classes are responsible for unmarshalling method arguments, invoking the corresponding methods in the local [`src/interfaces/`](../../src/interfaces/) objects, and creating the IPC response.\n+- The server classes ensure that return values (including output argument values and thrown exceptions) are marshalled and sent back to the client, completing the communication cycle.\n+- Internally, the server subclasses generated by the `mpgen` tool inherit from [server classes generated by Cap'n Proto](https://capnproto.org/cxxrpc.html#servers), and use them to process IPC requests.\n+\n+### The `libmultiprocess` Runtime Library\n+- **Core Functionality**: The `libmultiprocess` runtime library's primary function is to instantiate the generated client and server classes as needed.\n+- **Bootstrapping IPC Connections**: It provides functions for starting new IPC connections, specifically binding generated client and server classes for an initial `interfaces::Init` interface (defined in [`src/interfaces/init.h`](../../src/interfaces/init.h)) to a UNIX socket. This initial interface has methods returning other interfaces that different Bitcoin-Core modules use to communicate after the bootstrapping phase.\n+- **Asynchronous I/O and Thread Management**: The library is also responsible for managing I/O and threading. Particularly, it ensures that IPC requests never block each other and that new threads on either side of a connection can always make client calls. It also manages worker threads on the server side of calls, ensuring that calls from the same client thread always execute on the same server thread (to avoid locking issues and support nested callbacks).\n+\n+### Type Hooks in [`src/ipc/capnp/*-types.h`](../../src/ipc/capnp/)\n+- **Custom Type Conversions**: In [`src/ipc/capnp/*-types.h`](../../src/ipc/capnp/), multiple function overloads of two `libmultiprocess` C++ functions, `mp::CustomReadField` and `mp::CustomBuildFields`, are defined. These functions are used for customizing the conversion of specific C++ types to and from Cap’n Proto types.\n+- **Handling Special Cases**: The `mpgen` tool and `libmultiprocess` library can convert most C++ types to and from Cap’n Proto types automatically, including interface types, primitive C++ types, standard C++ types like `std::vector`, `std::set`, `std::map`, `std::tuple`, and `std::function`, as well as simple C++ structs that consist of afforementioned types and whose fields correspond 1:1 with Cap’n Proto struct fields. For other types, `*-types.h` files provide custom code to convert between C++ and Cap’n Proto data representations.\n+\n+### Protocol-Agnostic IPC Code in [`src/ipc/`](../../src/ipc/)\n+- **Broad Applicability**: Unlike the Cap’n Proto-specific code in [`src/ipc/capnp/`](../../src/ipc/capnp/), the code in the [`src/ipc/`](../../src/ipc/) directory is protocol-agnostic. This enables potential support for other protocols, such as gRPC or a custom protocol in the future.\n+- **Process Management and Socket Operations**: The main purpose of this component is to provide functions for spawning new processes and creating and connecting to UNIX sockets.\n+- **ipc::Exception Class**: This code also defines an `ipc::Exception` class which is thrown from the generated C++ client class methods when there is an unexpected IPC error, such as a disconnection.\n+\n+## Design Considerations\n+\n+### Selection of Cap’n Proto\n+The choice to use [Cap’n Proto](https://capnproto.org/) for IPC was primarily influenced by its support for passing object references and managing object lifetimes, which would have to be implemented manually with a framework that only supported plain requests and responses like [gRPC](https://grpc.io/). The support is especially helpful for passing callback objects like `std::function` and supporting bidirectional communication.\n+\n+The choice to use an RPC framework at all instead of a custom protocol was neccesitated by the size of Bitcoin Core internal interfaces which consist of around 150 methods that pass complex data structures and are called in complicated ways (in parallel, from callbacks that can be nested and stored). Writing a custom protocol to wrap these complicated interfaces would be too much work, akin to writing a new RPC framework.\n+\n+### Hiding IPC\n+\n+The IPC mechanism is deliberately isolated from the rest of the codebase so less code has to be concerned with IPC.\n+\n+Building Bitcoin Core with IPC support is optional, and the same code can be compiled to either run in the same process or separate processes. The build system also ensures Cap’n Proto library headers can only be used within the [`src/ipc/capnp/`](../../src/ipc/capnp/) directory, not in other parts of the codebase.\n+\n+The libmultiprocess runtime is designed to place as few constraints as possible on IPC interfaces and make IPC calls act like normal function calls. Method arguments, return values, and exceptions are automatically serialized and sent between processes. Object references and `std::function` arguments are automatically tracked and mapped to allow invoked code to call back into invoking code at any time. And there is a 1:1 threading model where any every client thread has a corresponding server thread responsible for executing incoming calls from that thread (there can be multiple calls from the same thread due to callbacks), without blocking, and holding the same thread-local variables and locks so behavior is the same whether IPC is used or not.\n+\n+### Interface Definition Maintenance\n+\n+The choice to maintain interface definitions and C++ type mappings as `.capnp` files in the [`src/ipc/capnp/`](../../src/ipc/capnp/) was mostly done for convenience, and probably something that could be improved in the future.\n+\n+In the current design, class names, method names, and parameter names are duplicated between C++ interfaces in [`src/interfaces/`](../../src/interfaces/) and Cap’n Proto files in [`src/ipc/capnp/`](../../src/ipc/capnp/). While this keeps C++ interface headers simple and free of references to IPC, it is a maintence burden because it means inconsistencies between C++ declarations and Cap’n Proto declarations will result in compile errors. (Static type checking ensures these are not runtime errors.)",
      "path": "doc/design/multiprocess.md",
      "position": null,
      "original_position": 182,
      "commit_id": "91dc48c14825a9075a57c1eefda202b83b6346ba",
      "original_commit_id": "837c53d14f24924cdcb2cfd8b18915882dc3b620",
      "in_reply_to_id": null,
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\nIn the current design, class names, method names, and parameter names are duplicated between C++ interfaces in [`src/interfaces/`](../../src/interfaces/) and Cap’n Proto files in [`src/ipc/capnp/`](../../src/ipc/capnp/). While this keeps C++ interface headers simple and free of references to IPC, it is a maintenance burden because it means inconsistencies between C++ declarations and Cap’n Proto declarations will result in compile errors. (Static type checking ensures these are not runtime errors.)\r\n```",
      "created_at": "2023-12-15T16:18:57Z",
      "updated_at": "2023-12-15T16:48:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28978#discussion_r1428165515",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1428165515"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28978"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 110,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1428168964",
      "pull_request_review_id": 1782842554,
      "id": 1428168964,
      "node_id": "PRRC_kwDOABII585VICEE",
      "diff_hunk": "@@ -0,0 +1,34 @@\n+# Multiprocess Bitcoin\n+\n+_This document describes usage of the multiprocess feature. For design information, see the [design/multiprocess.md](design/multiprocess.md) file._\n+\n+## Build Option\n+\n+On unix systems, the `--enable-multiprocess` build option can be passed to `./configure` to build new `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables alongside existing `bitcoind` and `bitcoin-qt` executables.\n+\n+## Debugging\n+\n+The `-debug=ipc` command line option can be used to see requests and responses between processes.\n+\n+## Installation\n+\n+The multiprocess feature requires [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) as dependencies. A simple way to get starting using it without installing these dependencies manually is to use the [depends system](../depends) with the `MULTIPROCESS=1` [dependency option](../depends#dependency-options) passed to make:",
      "path": "doc/multiprocess.md",
      "position": null,
      "original_position": 15,
      "commit_id": "91dc48c14825a9075a57c1eefda202b83b6346ba",
      "original_commit_id": "837c53d14f24924cdcb2cfd8b18915882dc3b620",
      "in_reply_to_id": null,
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\nThe multiprocess feature requires [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) as dependencies. A simple way to get started using it without installing these dependencies manually is to use the [depends system](../depends) with the `MULTIPROCESS=1` [dependency option](../depends#dependency-options) passed to make:\r\n```",
      "created_at": "2023-12-15T16:21:43Z",
      "updated_at": "2023-12-15T16:48:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28978#discussion_r1428168964",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1428168964"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28978"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 15,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1428187716",
      "pull_request_review_id": 1782842554,
      "id": 1428187716,
      "node_id": "PRRC_kwDOABII585VIGpE",
      "diff_hunk": "@@ -1,72 +1,200 @@\n-# Multiprocess Bitcoin\n-\n-On unix systems, the `--enable-multiprocess` build option can be passed to `./configure` to build new `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables alongside existing `bitcoind` and `bitcoin-qt` executables.\n-\n-`bitcoin-node` is a drop-in replacement for `bitcoind`, and `bitcoin-gui` is a drop-in replacement for `bitcoin-qt`, and there are no differences in use or external behavior between the new and old executables. But internally (after [#10102](https://github.com/bitcoin/bitcoin/pull/10102)), `bitcoin-gui` will spawn a `bitcoin-node` process to run P2P and RPC code, communicating with it across a socket pair, and `bitcoin-node` will spawn `bitcoin-wallet` to run wallet code, also communicating over a socket pair. This will let node, wallet, and GUI code run in separate address spaces for better isolation, and allow future improvements like being able to start and stop components independently on different machines and environments.\n-\n-## Next steps\n-\n-Specific next steps after [#10102](https://github.com/bitcoin/bitcoin/pull/10102) will be:\n-\n-- [ ] Adding `-ipcbind` and `-ipcconnect` options to `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables so they can listen and connect to TCP ports and unix socket paths. This will allow separate processes to be started and stopped any time and connect to each other.\n-- [ ] Adding `-server` and `-rpcbind` options to the `bitcoin-wallet` executable so wallet processes can handle RPC requests directly without going through the node.\n-- [ ] Supporting windows, not just unix systems. The existing socket code is already cross-platform, so the only windows-specific code that needs to be written is code spawning a process and passing a socket descriptor. This can be implemented with `CreateProcess` and `WSADuplicateSocket`. Example: https://memset.wordpress.com/2010/10/13/win32-api-passing-socket-with-ipc-method/.\n-- [ ] Adding sandbox features, restricting subprocess access to resources and data. See [https://eklitzke.org/multiprocess-bitcoin](https://eklitzke.org/multiprocess-bitcoin).\n-\n-## Debugging\n-\n-The `-debug=ipc` command line option can be used to see requests and responses between processes.\n-\n-## Installation\n-\n-The multiprocess feature requires [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) as dependencies. A simple way to get starting using it without installing these dependencies manually is to use the [depends system](../../depends) with the `MULTIPROCESS=1` [dependency option](../../depends#dependency-options) passed to make:\n-\n-```\n-cd <BITCOIN_SOURCE_DIRECTORY>\n-make -C depends NO_QT=1 MULTIPROCESS=1\n-CONFIG_SITE=$PWD/depends/x86_64-pc-linux-gnu/share/config.site ./configure\n-make\n-src/bitcoin-node -regtest -printtoconsole -debug=ipc\n-BITCOIND=bitcoin-node test/functional/test_runner.py\n-```\n-\n-The configure script will pick up settings and library locations from the depends directory, so there is no need to pass `--enable-multiprocess` as a separate flag when using the depends system (it's controlled by the `MULTIPROCESS=1` option).\n-\n-Alternately, you can install [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) packages on your system, and just run `./configure --enable-multiprocess` without using the depends system. The configure script will be able to locate the installed packages via [pkg-config](https://www.freedesktop.org/wiki/Software/pkg-config/). See [Installation](https://github.com/chaincodelabs/libmultiprocess/blob/master/doc/install.md) section of the libmultiprocess readme for install steps. See [build-unix.md](../build-unix.md) and [build-osx.md](../build-osx.md) for information about installing dependencies in general.\n-\n-## IPC implementation details\n-\n-Cross process Node, Wallet, and Chain interfaces are defined in\n-[`src/interfaces/`](../../src/interfaces/). These are C++ classes which follow\n-[conventions](../developer-notes.md#internal-interface-guidelines), like passing\n-serializable arguments so they can be called from different processes, and\n-making methods pure virtual so they can have proxy implementations that forward\n-calls between processes.\n-\n-When Wallet, Node, and Chain code is running in the same process, calling any\n-interface method invokes the implementation directly. When code is running in\n-different processes, calling an interface method invokes a proxy interface\n-implementation that communicates with a remote process and invokes the real\n-implementation in the remote process. The\n-[libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) code\n-generation tool internally generates proxy client classes and proxy server\n-classes for this purpose that are thin wrappers around Cap'n Proto\n-[client](https://capnproto.org/cxxrpc.html#clients) and\n-[server](https://capnproto.org/cxxrpc.html#servers) classes, which handle the\n-actual serialization and socket communication.\n-\n-As much as possible, calls between processes are meant to work the same as\n-calls within a single process without adding limitations or requiring extra\n-implementation effort. Processes communicate with each other by calling regular\n-[C++ interface methods](../../src/interfaces/README.md). Method arguments and\n-return values are automatically serialized and sent between processes. Object\n-references and `std::function` arguments are automatically tracked and mapped\n-to allow invoked code to call back into invoking code at any time, and there is\n-a 1:1 threading model where any thread invoking a method in another process has\n-a corresponding thread in the invoked process responsible for executing all\n-method calls from the source thread, without blocking I/O or holding up another\n-call, and using the same thread local variables, locks, and callbacks between\n-calls. The forwarding, tracking, and threading is implemented inside the\n-[libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) library\n-which has the design goal of making calls between processes look like calls in\n-the same process to the extent possible.\n+# Multiprocess Bitcoin Design Document\n+\n+Guide to the design and architecture of the Bitcoin-Core multiprocess feature\n+\n+_This document describes the design of the multiprocess feature. For usage information, see the top-level [multiprocess.md](../multiprocess.md) file._\n+\n+## Table of contents\n+\n+- [Introduction](#introduction)\n+- [Current Architecture](#current-architecture)\n+- [Proposed Architecture](#proposed-architecture)\n+- [Component Overview: Navigating the IPC Framework](#component-overview-navigating-the-ipc-framework)\n+- [Design Considerations](#design-considerations)\n+  - [Selection of Cap’n Proto](#selection-of-capn-proto)\n+  - [Hiding IPC](#hiding-ipc)\n+  - [Interface Definition Maintenance](#interface-definition-maintenance)\n+  - [Interface Stability](#interface-stability)\n+- [Example Use Cases and Flows](#example-use-cases-and-flows)\n+  - [Retrieving a Block Hash](#retrieving-a-block-hash)\n+- [Future Enhancements](#future-enhancements)\n+- [Conclusion](#conclusion)\n+- [Appendices](#appendices)\n+  - [Glossary of Terms](#glossary-of-terms)\n+  - [References](#references)\n+- [Acknowledgements](#acknowledgements)\n+\n+## Introduction\n+\n+The Bitcoin Core software, central to the Bitcoin network, has historically employed a monolithic architecture. The existing design has integrated functionality like P2P network operations, wallet management, and a GUI into a single executable. While effective, it has limitations in flexibility, security, and scalability. This project introduces changes that transition Bitcoin Core to a more modular architecture. It aims to enhance security, improve usability, and facilitate maintenance and development of the software.\n+\n+## Current Architecture\n+\n+The current system features two primary executables: `bitcoind` and `bitcoin-qt`. `bitcoind` combines a Bitcoin P2P node with an integrated JSON-RPC server, wallet, and indexes. `bitcoin-qt` extends this by incorporating a Qt-based GUI. This monolithic structure, although robust, presents challenges such as limited operational flexibility and increased security risks due to the tight integration of components.\n+\n+## Proposed Architecture\n+\n+The new architecture divides the existing code into three specialized executables:\n+\n+- `bitcoin-node`: Manages the node, indexes, and JSON-RPC server.\n+- `bitcoin-wallet`: Handles all wallet functionality.\n+- `bitcoin-gui`: Provides a standalone Qt-based GUI.\n+\n+This modular approach is designed to enhance security through component isolation and improve usability by allowing independent operation of each module. This allows for new use-cases, such as running the node on a dedicated machine and operating wallets and GUIs on separate machines with the flexibility to start and stop them as needed.\n+\n+This subdivision could be extended in the future. For example, indexes could be removed from the `bitcoin-node` executable and run in separate executables. And JSON-RPC servers could be added to wallet and index executables, so they can listen and respond to RPC requests on their own ports, without needing to forward RPC requests through `bitcoin-node`.\n+\n+## Component Overview: Navigating the IPC Framework\n+\n+This section describes the major components of the Inter-Process Communication (IPC) framework covering the relevant source files, generated files, tools, and libraries.\n+\n+### Abstract C++ Classes in [`src/interfaces/`](../../src/interfaces/)\n+- The foundation of the IPC implementation lies in the abstract C++ classes within the [`src/interfaces/`](../../src/interfaces/) directory. These classes define pure virtual methods that code in [`src/node/`](../../src/node/), [`src/wallet/`](../../src/wallet/), and [`src/qt/`](../../src/qt/) directories call to interact with each other.\n+- Each abstract class in this directory represents a distinct interface that the different modules (node, wallet, GUI) implement and use for cross-process communication.\n+- The classes are written following conventions described in [Internal Interface\n+  Guidelines](../developer-notes.md#internal-interface-guidelines) to ensure\n+  compatibility with Cap'n Proto.\n+\n+### Cap’n Proto Files in [`src/ipc/capnp/`](../../src/ipc/capnp/)\n+- Corresponding to each abstract class, there are `.capnp` files within the [`src/ipc/capnp/`](../../src/ipc/capnp/) directory. These files are used as input to the `mpgen` tool (described below) to generate C++ code.\n+- These Cap’n Proto files ([learn more about Cap'n Proto RPC](https://capnproto.org/rpc.html)) define the structure and format of messages that are exchanged over IPC. They serve as blueprints for generating C++ code that bridges the gap between high-level C++ interfaces and low-level socket communication.\n+\n+### The `mpgen` Code Generation Tool\n+- A central component of the IPC framework is the `mpgen` tool which is part the [`libmultiprocess` project](https://github.com/chaincodelabs/libmultiprocess). This tool takes the `.capnp` files as input and generates C++ code.\n+- The generated code handles IPC communication, translating interface calls into socket reads and writes.\n+\n+### C++ Client Subclasses in Generated Code\n+- In the generated code, we have C++ client subclasses that inherit from the abstract classes in [`src/interfaces/`](../../src/interfaces/). These subclasses are the workhorses of the IPC mechanism.\n+- They implement all the methods of the interface, marshalling arguments into a structured format, sending them as requests to the IPC server via a UNIX socket, and handling the responses.\n+- These subclasses effectively mask the complexity of IPC, presenting a familiar C++ interface to developers.\n+- Internally, the client subclasses generated by the `mpgen` tool wrap [client classes generated by Cap'n Proto](https://capnproto.org/cxxrpc.html#clients), and use them to send IPC requests.\n+\n+### C++ Server Classes in Generated Code\n+- On the server side, corresponding generated C++ classes receive IPC requests. These server classes are responsible for unmarshalling method arguments, invoking the corresponding methods in the local [`src/interfaces/`](../../src/interfaces/) objects, and creating the IPC response.\n+- The server classes ensure that return values (including output argument values and thrown exceptions) are marshalled and sent back to the client, completing the communication cycle.\n+- Internally, the server subclasses generated by the `mpgen` tool inherit from [server classes generated by Cap'n Proto](https://capnproto.org/cxxrpc.html#servers), and use them to process IPC requests.\n+\n+### The `libmultiprocess` Runtime Library\n+- **Core Functionality**: The `libmultiprocess` runtime library's primary function is to instantiate the generated client and server classes as needed.\n+- **Bootstrapping IPC Connections**: It provides functions for starting new IPC connections, specifically binding generated client and server classes for an initial `interfaces::Init` interface (defined in [`src/interfaces/init.h`](../../src/interfaces/init.h)) to a UNIX socket. This initial interface has methods returning other interfaces that different Bitcoin-Core modules use to communicate after the bootstrapping phase.\n+- **Asynchronous I/O and Thread Management**: The library is also responsible for managing I/O and threading. Particularly, it ensures that IPC requests never block each other and that new threads on either side of a connection can always make client calls. It also manages worker threads on the server side of calls, ensuring that calls from the same client thread always execute on the same server thread (to avoid locking issues and support nested callbacks).\n+\n+### Type Hooks in [`src/ipc/capnp/*-types.h`](../../src/ipc/capnp/)\n+- **Custom Type Conversions**: In [`src/ipc/capnp/*-types.h`](../../src/ipc/capnp/), multiple function overloads of two `libmultiprocess` C++ functions, `mp::CustomReadField` and `mp::CustomBuildFields`, are defined. These functions are used for customizing the conversion of specific C++ types to and from Cap’n Proto types.\n+- **Handling Special Cases**: The `mpgen` tool and `libmultiprocess` library can convert most C++ types to and from Cap’n Proto types automatically, including interface types, primitive C++ types, standard C++ types like `std::vector`, `std::set`, `std::map`, `std::tuple`, and `std::function`, as well as simple C++ structs that consist of afforementioned types and whose fields correspond 1:1 with Cap’n Proto struct fields. For other types, `*-types.h` files provide custom code to convert between C++ and Cap’n Proto data representations.\n+\n+### Protocol-Agnostic IPC Code in [`src/ipc/`](../../src/ipc/)\n+- **Broad Applicability**: Unlike the Cap’n Proto-specific code in [`src/ipc/capnp/`](../../src/ipc/capnp/), the code in the [`src/ipc/`](../../src/ipc/) directory is protocol-agnostic. This enables potential support for other protocols, such as gRPC or a custom protocol in the future.\n+- **Process Management and Socket Operations**: The main purpose of this component is to provide functions for spawning new processes and creating and connecting to UNIX sockets.\n+- **ipc::Exception Class**: This code also defines an `ipc::Exception` class which is thrown from the generated C++ client class methods when there is an unexpected IPC error, such as a disconnection.\n+\n+## Design Considerations\n+\n+### Selection of Cap’n Proto\n+The choice to use [Cap’n Proto](https://capnproto.org/) for IPC was primarily influenced by its support for passing object references and managing object lifetimes, which would have to be implemented manually with a framework that only supported plain requests and responses like [gRPC](https://grpc.io/). The support is especially helpful for passing callback objects like `std::function` and supporting bidirectional communication.\n+\n+The choice to use an RPC framework at all instead of a custom protocol was neccesitated by the size of Bitcoin Core internal interfaces which consist of around 150 methods that pass complex data structures and are called in complicated ways (in parallel, from callbacks that can be nested and stored). Writing a custom protocol to wrap these complicated interfaces would be too much work, akin to writing a new RPC framework.\n+\n+### Hiding IPC\n+\n+The IPC mechanism is deliberately isolated from the rest of the codebase so less code has to be concerned with IPC.\n+\n+Building Bitcoin Core with IPC support is optional, and the same code can be compiled to either run in the same process or separate processes. The build system also ensures Cap’n Proto library headers can only be used within the [`src/ipc/capnp/`](../../src/ipc/capnp/) directory, not in other parts of the codebase.\n+\n+The libmultiprocess runtime is designed to place as few constraints as possible on IPC interfaces and make IPC calls act like normal function calls. Method arguments, return values, and exceptions are automatically serialized and sent between processes. Object references and `std::function` arguments are automatically tracked and mapped to allow invoked code to call back into invoking code at any time. And there is a 1:1 threading model where any every client thread has a corresponding server thread responsible for executing incoming calls from that thread (there can be multiple calls from the same thread due to callbacks), without blocking, and holding the same thread-local variables and locks so behavior is the same whether IPC is used or not.\n+\n+### Interface Definition Maintenance\n+\n+The choice to maintain interface definitions and C++ type mappings as `.capnp` files in the [`src/ipc/capnp/`](../../src/ipc/capnp/) was mostly done for convenience, and probably something that could be improved in the future.\n+\n+In the current design, class names, method names, and parameter names are duplicated between C++ interfaces in [`src/interfaces/`](../../src/interfaces/) and Cap’n Proto files in [`src/ipc/capnp/`](../../src/ipc/capnp/). While this keeps C++ interface headers simple and free of references to IPC, it is a maintence burden because it means inconsistencies between C++ declarations and Cap’n Proto declarations will result in compile errors. (Static type checking ensures these are not runtime errors.)\n+\n+An alternate approach could use custom [C++ Attributes](https://en.cppreference.com/w/cpp/language/attributes) embedded in interface declarations to automatically generate `.capnp` files directly from C++ headers. This has not been pursued because parsing C++ headers is more complicated than parsing Cap’n Proto interface definitions, especially portably on multiple platforms.\n+\n+### Interface Stability\n+\n+The currently defined IPC interfaces are unstable, and can change freely with no backwards compatibility. The decision to allow this stems from the recognition that our current interfaces are still evolving and not yet ideal for external use. As these interfaces mature and become more refined, there may be an opportunity to declare them stable and use Cap’n Proto's support for protocol evolution ([Cap'n Proto - Evolving Your Protocol](https://capnproto.org/language.html#evolving-your-protocol)) to allow them to be extended while remaining backwards compatible. This could allow different versions of node, GUI, and wallet binaries to interoperate, and potentially open doors for external tools to utilize these interfaces, such as creating custom indexes through a stable indexing interface. However, for now, the priority is to improve the interfaces internally. Given their current state and the advantages of using JSON-RPC for most common tasks, it's more practical to focus on internal development rather than external applicability.\n+\n+## Example Use Cases and Flows\n+\n+### Retrieving a Block Hash\n+\n+Let’s walk through an example where the `bitcoin-wallet` process requests the hash of a block at a specific height from the `bitcoin-node` process. This example demonstrates the practical application of the IPC mechanism, specifically the interplay between C++ method calls and Cap’n Proto-generated RPC calls.",
      "path": "doc/design/multiprocess.md",
      "position": 178,
      "original_position": 194,
      "commit_id": "91dc48c14825a9075a57c1eefda202b83b6346ba",
      "original_commit_id": "837c53d14f24924cdcb2cfd8b18915882dc3b620",
      "in_reply_to_id": null,
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Maybe mention that his is based on code that is not merged yet, for example `chain.capnp` is linked below but it doesn't exist on master yet.",
      "created_at": "2023-12-15T16:38:41Z",
      "updated_at": "2023-12-15T16:48:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28978#discussion_r1428187716",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1428187716"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28978"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 159,
      "original_line": 159,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1431360480",
      "pull_request_review_id": 1788797844,
      "id": 1431360480,
      "node_id": "PRRC_kwDOABII585VUNPg",
      "diff_hunk": "@@ -1,72 +1,200 @@\n-# Multiprocess Bitcoin\n-\n-On unix systems, the `--enable-multiprocess` build option can be passed to `./configure` to build new `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables alongside existing `bitcoind` and `bitcoin-qt` executables.\n-\n-`bitcoin-node` is a drop-in replacement for `bitcoind`, and `bitcoin-gui` is a drop-in replacement for `bitcoin-qt`, and there are no differences in use or external behavior between the new and old executables. But internally (after [#10102](https://github.com/bitcoin/bitcoin/pull/10102)), `bitcoin-gui` will spawn a `bitcoin-node` process to run P2P and RPC code, communicating with it across a socket pair, and `bitcoin-node` will spawn `bitcoin-wallet` to run wallet code, also communicating over a socket pair. This will let node, wallet, and GUI code run in separate address spaces for better isolation, and allow future improvements like being able to start and stop components independently on different machines and environments.\n-\n-## Next steps\n-\n-Specific next steps after [#10102](https://github.com/bitcoin/bitcoin/pull/10102) will be:\n-\n-- [ ] Adding `-ipcbind` and `-ipcconnect` options to `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables so they can listen and connect to TCP ports and unix socket paths. This will allow separate processes to be started and stopped any time and connect to each other.\n-- [ ] Adding `-server` and `-rpcbind` options to the `bitcoin-wallet` executable so wallet processes can handle RPC requests directly without going through the node.\n-- [ ] Supporting windows, not just unix systems. The existing socket code is already cross-platform, so the only windows-specific code that needs to be written is code spawning a process and passing a socket descriptor. This can be implemented with `CreateProcess` and `WSADuplicateSocket`. Example: https://memset.wordpress.com/2010/10/13/win32-api-passing-socket-with-ipc-method/.\n-- [ ] Adding sandbox features, restricting subprocess access to resources and data. See [https://eklitzke.org/multiprocess-bitcoin](https://eklitzke.org/multiprocess-bitcoin).\n-\n-## Debugging\n-\n-The `-debug=ipc` command line option can be used to see requests and responses between processes.\n-\n-## Installation\n-\n-The multiprocess feature requires [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) as dependencies. A simple way to get starting using it without installing these dependencies manually is to use the [depends system](../../depends) with the `MULTIPROCESS=1` [dependency option](../../depends#dependency-options) passed to make:\n-\n-```\n-cd <BITCOIN_SOURCE_DIRECTORY>\n-make -C depends NO_QT=1 MULTIPROCESS=1\n-CONFIG_SITE=$PWD/depends/x86_64-pc-linux-gnu/share/config.site ./configure\n-make\n-src/bitcoin-node -regtest -printtoconsole -debug=ipc\n-BITCOIND=bitcoin-node test/functional/test_runner.py\n-```\n-\n-The configure script will pick up settings and library locations from the depends directory, so there is no need to pass `--enable-multiprocess` as a separate flag when using the depends system (it's controlled by the `MULTIPROCESS=1` option).\n-\n-Alternately, you can install [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) packages on your system, and just run `./configure --enable-multiprocess` without using the depends system. The configure script will be able to locate the installed packages via [pkg-config](https://www.freedesktop.org/wiki/Software/pkg-config/). See [Installation](https://github.com/chaincodelabs/libmultiprocess/blob/master/doc/install.md) section of the libmultiprocess readme for install steps. See [build-unix.md](../build-unix.md) and [build-osx.md](../build-osx.md) for information about installing dependencies in general.\n-\n-## IPC implementation details\n-\n-Cross process Node, Wallet, and Chain interfaces are defined in\n-[`src/interfaces/`](../../src/interfaces/). These are C++ classes which follow\n-[conventions](../developer-notes.md#internal-interface-guidelines), like passing\n-serializable arguments so they can be called from different processes, and\n-making methods pure virtual so they can have proxy implementations that forward\n-calls between processes.\n-\n-When Wallet, Node, and Chain code is running in the same process, calling any\n-interface method invokes the implementation directly. When code is running in\n-different processes, calling an interface method invokes a proxy interface\n-implementation that communicates with a remote process and invokes the real\n-implementation in the remote process. The\n-[libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) code\n-generation tool internally generates proxy client classes and proxy server\n-classes for this purpose that are thin wrappers around Cap'n Proto\n-[client](https://capnproto.org/cxxrpc.html#clients) and\n-[server](https://capnproto.org/cxxrpc.html#servers) classes, which handle the\n-actual serialization and socket communication.\n-\n-As much as possible, calls between processes are meant to work the same as\n-calls within a single process without adding limitations or requiring extra\n-implementation effort. Processes communicate with each other by calling regular\n-[C++ interface methods](../../src/interfaces/README.md). Method arguments and\n-return values are automatically serialized and sent between processes. Object\n-references and `std::function` arguments are automatically tracked and mapped\n-to allow invoked code to call back into invoking code at any time, and there is\n-a 1:1 threading model where any thread invoking a method in another process has\n-a corresponding thread in the invoked process responsible for executing all\n-method calls from the source thread, without blocking I/O or holding up another\n-call, and using the same thread local variables, locks, and callbacks between\n-calls. The forwarding, tracking, and threading is implemented inside the\n-[libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) library\n-which has the design goal of making calls between processes look like calls in\n-the same process to the extent possible.\n+# Multiprocess Bitcoin Design Document\n+\n+Guide to the design and architecture of the Bitcoin-Core multiprocess feature\n+\n+_This document describes the design of the multiprocess feature. For usage information, see the top-level [multiprocess.md](../multiprocess.md) file._\n+\n+## Table of contents\n+\n+- [Introduction](#introduction)\n+- [Current Architecture](#current-architecture)\n+- [Proposed Architecture](#proposed-architecture)\n+- [Component Overview: Navigating the IPC Framework](#component-overview-navigating-the-ipc-framework)\n+- [Design Considerations](#design-considerations)\n+  - [Selection of Cap’n Proto](#selection-of-capn-proto)\n+  - [Hiding IPC](#hiding-ipc)\n+  - [Interface Definition Maintenance](#interface-definition-maintenance)\n+  - [Interface Stability](#interface-stability)\n+- [Example Use Cases and Flows](#example-use-cases-and-flows)\n+  - [Retrieving a Block Hash](#retrieving-a-block-hash)\n+- [Future Enhancements](#future-enhancements)\n+- [Conclusion](#conclusion)\n+- [Appendices](#appendices)\n+  - [Glossary of Terms](#glossary-of-terms)\n+  - [References](#references)\n+- [Acknowledgements](#acknowledgements)\n+\n+## Introduction\n+\n+The Bitcoin Core software, central to the Bitcoin network, has historically employed a monolithic architecture. The existing design has integrated functionality like P2P network operations, wallet management, and a GUI into a single executable. While effective, it has limitations in flexibility, security, and scalability. This project introduces changes that transition Bitcoin Core to a more modular architecture. It aims to enhance security, improve usability, and facilitate maintenance and development of the software.",
      "path": "doc/design/multiprocess.md",
      "position": null,
      "original_position": 101,
      "commit_id": "91dc48c14825a9075a57c1eefda202b83b6346ba",
      "original_commit_id": "837c53d14f24924cdcb2cfd8b18915882dc3b620",
      "in_reply_to_id": 1427365136,
      "user": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "re: https://github.com/bitcoin/bitcoin/pull/28978#discussion_r1427365136\r\n\r\n> nit suggestions:\r\n> \r\n>* 'central to the bitcoin network' isn't really relevant to this doc\r\n> \r\n>* I hear people complain that big changes are always a security risk in the short term all the time\r\n\r\nYes, definitely agree and took the suggestion.",
      "created_at": "2023-12-19T12:47:51Z",
      "updated_at": "2023-12-19T16:29:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28978#discussion_r1431360480",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1431360480"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28978"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 29,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1431360695",
      "pull_request_review_id": 1788797844,
      "id": 1431360695,
      "node_id": "PRRC_kwDOABII585VUNS3",
      "diff_hunk": "@@ -1,72 +1,200 @@\n-# Multiprocess Bitcoin\n-\n-On unix systems, the `--enable-multiprocess` build option can be passed to `./configure` to build new `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables alongside existing `bitcoind` and `bitcoin-qt` executables.\n-\n-`bitcoin-node` is a drop-in replacement for `bitcoind`, and `bitcoin-gui` is a drop-in replacement for `bitcoin-qt`, and there are no differences in use or external behavior between the new and old executables. But internally (after [#10102](https://github.com/bitcoin/bitcoin/pull/10102)), `bitcoin-gui` will spawn a `bitcoin-node` process to run P2P and RPC code, communicating with it across a socket pair, and `bitcoin-node` will spawn `bitcoin-wallet` to run wallet code, also communicating over a socket pair. This will let node, wallet, and GUI code run in separate address spaces for better isolation, and allow future improvements like being able to start and stop components independently on different machines and environments.\n-\n-## Next steps\n-\n-Specific next steps after [#10102](https://github.com/bitcoin/bitcoin/pull/10102) will be:\n-\n-- [ ] Adding `-ipcbind` and `-ipcconnect` options to `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables so they can listen and connect to TCP ports and unix socket paths. This will allow separate processes to be started and stopped any time and connect to each other.\n-- [ ] Adding `-server` and `-rpcbind` options to the `bitcoin-wallet` executable so wallet processes can handle RPC requests directly without going through the node.\n-- [ ] Supporting windows, not just unix systems. The existing socket code is already cross-platform, so the only windows-specific code that needs to be written is code spawning a process and passing a socket descriptor. This can be implemented with `CreateProcess` and `WSADuplicateSocket`. Example: https://memset.wordpress.com/2010/10/13/win32-api-passing-socket-with-ipc-method/.\n-- [ ] Adding sandbox features, restricting subprocess access to resources and data. See [https://eklitzke.org/multiprocess-bitcoin](https://eklitzke.org/multiprocess-bitcoin).\n-\n-## Debugging\n-\n-The `-debug=ipc` command line option can be used to see requests and responses between processes.\n-\n-## Installation\n-\n-The multiprocess feature requires [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) as dependencies. A simple way to get starting using it without installing these dependencies manually is to use the [depends system](../../depends) with the `MULTIPROCESS=1` [dependency option](../../depends#dependency-options) passed to make:\n-\n-```\n-cd <BITCOIN_SOURCE_DIRECTORY>\n-make -C depends NO_QT=1 MULTIPROCESS=1\n-CONFIG_SITE=$PWD/depends/x86_64-pc-linux-gnu/share/config.site ./configure\n-make\n-src/bitcoin-node -regtest -printtoconsole -debug=ipc\n-BITCOIND=bitcoin-node test/functional/test_runner.py\n-```\n-\n-The configure script will pick up settings and library locations from the depends directory, so there is no need to pass `--enable-multiprocess` as a separate flag when using the depends system (it's controlled by the `MULTIPROCESS=1` option).\n-\n-Alternately, you can install [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) packages on your system, and just run `./configure --enable-multiprocess` without using the depends system. The configure script will be able to locate the installed packages via [pkg-config](https://www.freedesktop.org/wiki/Software/pkg-config/). See [Installation](https://github.com/chaincodelabs/libmultiprocess/blob/master/doc/install.md) section of the libmultiprocess readme for install steps. See [build-unix.md](../build-unix.md) and [build-osx.md](../build-osx.md) for information about installing dependencies in general.\n-\n-## IPC implementation details\n-\n-Cross process Node, Wallet, and Chain interfaces are defined in\n-[`src/interfaces/`](../../src/interfaces/). These are C++ classes which follow\n-[conventions](../developer-notes.md#internal-interface-guidelines), like passing\n-serializable arguments so they can be called from different processes, and\n-making methods pure virtual so they can have proxy implementations that forward\n-calls between processes.\n-\n-When Wallet, Node, and Chain code is running in the same process, calling any\n-interface method invokes the implementation directly. When code is running in\n-different processes, calling an interface method invokes a proxy interface\n-implementation that communicates with a remote process and invokes the real\n-implementation in the remote process. The\n-[libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) code\n-generation tool internally generates proxy client classes and proxy server\n-classes for this purpose that are thin wrappers around Cap'n Proto\n-[client](https://capnproto.org/cxxrpc.html#clients) and\n-[server](https://capnproto.org/cxxrpc.html#servers) classes, which handle the\n-actual serialization and socket communication.\n-\n-As much as possible, calls between processes are meant to work the same as\n-calls within a single process without adding limitations or requiring extra\n-implementation effort. Processes communicate with each other by calling regular\n-[C++ interface methods](../../src/interfaces/README.md). Method arguments and\n-return values are automatically serialized and sent between processes. Object\n-references and `std::function` arguments are automatically tracked and mapped\n-to allow invoked code to call back into invoking code at any time, and there is\n-a 1:1 threading model where any thread invoking a method in another process has\n-a corresponding thread in the invoked process responsible for executing all\n-method calls from the source thread, without blocking I/O or holding up another\n-call, and using the same thread local variables, locks, and callbacks between\n-calls. The forwarding, tracking, and threading is implemented inside the\n-[libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) library\n-which has the design goal of making calls between processes look like calls in\n-the same process to the extent possible.\n+# Multiprocess Bitcoin Design Document\n+\n+Guide to the design and architecture of the Bitcoin-Core multiprocess feature\n+\n+_This document describes the design of the multiprocess feature. For usage information, see the top-level [multiprocess.md](../multiprocess.md) file._\n+\n+## Table of contents\n+\n+- [Introduction](#introduction)\n+- [Current Architecture](#current-architecture)\n+- [Proposed Architecture](#proposed-architecture)\n+- [Component Overview: Navigating the IPC Framework](#component-overview-navigating-the-ipc-framework)\n+- [Design Considerations](#design-considerations)\n+  - [Selection of Cap’n Proto](#selection-of-capn-proto)\n+  - [Hiding IPC](#hiding-ipc)\n+  - [Interface Definition Maintenance](#interface-definition-maintenance)\n+  - [Interface Stability](#interface-stability)\n+- [Example Use Cases and Flows](#example-use-cases-and-flows)\n+  - [Retrieving a Block Hash](#retrieving-a-block-hash)\n+- [Future Enhancements](#future-enhancements)\n+- [Conclusion](#conclusion)\n+- [Appendices](#appendices)\n+  - [Glossary of Terms](#glossary-of-terms)\n+  - [References](#references)\n+- [Acknowledgements](#acknowledgements)\n+\n+## Introduction\n+\n+The Bitcoin Core software, central to the Bitcoin network, has historically employed a monolithic architecture. The existing design has integrated functionality like P2P network operations, wallet management, and a GUI into a single executable. While effective, it has limitations in flexibility, security, and scalability. This project introduces changes that transition Bitcoin Core to a more modular architecture. It aims to enhance security, improve usability, and facilitate maintenance and development of the software.\n+\n+## Current Architecture\n+\n+The current system features two primary executables: `bitcoind` and `bitcoin-qt`. `bitcoind` combines a Bitcoin P2P node with an integrated JSON-RPC server, wallet, and indexes. `bitcoin-qt` extends this by incorporating a Qt-based GUI. This monolithic structure, although robust, presents challenges such as limited operational flexibility and increased security risks due to the tight integration of components.\n+\n+## Proposed Architecture\n+\n+The new architecture divides the existing code into three specialized executables:\n+\n+- `bitcoin-node`: Manages the node, indexes, and JSON-RPC server.",
      "path": "doc/design/multiprocess.md",
      "position": null,
      "original_position": 111,
      "commit_id": "91dc48c14825a9075a57c1eefda202b83b6346ba",
      "original_commit_id": "837c53d14f24924cdcb2cfd8b18915882dc3b620",
      "in_reply_to_id": 1427363274,
      "user": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "re: https://github.com/bitcoin/bitcoin/pull/28978#discussion_r1427363274\r\n\r\n> nit\r\n\r\nUseful clarification, added",
      "created_at": "2023-12-19T12:48:04Z",
      "updated_at": "2023-12-19T16:29:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28978#discussion_r1431360695",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1431360695"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28978"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 39,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1431360934",
      "pull_request_review_id": 1788797844,
      "id": 1431360934,
      "node_id": "PRRC_kwDOABII585VUNWm",
      "diff_hunk": "@@ -1,72 +1,200 @@\n-# Multiprocess Bitcoin\n-\n-On unix systems, the `--enable-multiprocess` build option can be passed to `./configure` to build new `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables alongside existing `bitcoind` and `bitcoin-qt` executables.\n-\n-`bitcoin-node` is a drop-in replacement for `bitcoind`, and `bitcoin-gui` is a drop-in replacement for `bitcoin-qt`, and there are no differences in use or external behavior between the new and old executables. But internally (after [#10102](https://github.com/bitcoin/bitcoin/pull/10102)), `bitcoin-gui` will spawn a `bitcoin-node` process to run P2P and RPC code, communicating with it across a socket pair, and `bitcoin-node` will spawn `bitcoin-wallet` to run wallet code, also communicating over a socket pair. This will let node, wallet, and GUI code run in separate address spaces for better isolation, and allow future improvements like being able to start and stop components independently on different machines and environments.\n-\n-## Next steps\n-\n-Specific next steps after [#10102](https://github.com/bitcoin/bitcoin/pull/10102) will be:\n-\n-- [ ] Adding `-ipcbind` and `-ipcconnect` options to `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables so they can listen and connect to TCP ports and unix socket paths. This will allow separate processes to be started and stopped any time and connect to each other.\n-- [ ] Adding `-server` and `-rpcbind` options to the `bitcoin-wallet` executable so wallet processes can handle RPC requests directly without going through the node.\n-- [ ] Supporting windows, not just unix systems. The existing socket code is already cross-platform, so the only windows-specific code that needs to be written is code spawning a process and passing a socket descriptor. This can be implemented with `CreateProcess` and `WSADuplicateSocket`. Example: https://memset.wordpress.com/2010/10/13/win32-api-passing-socket-with-ipc-method/.\n-- [ ] Adding sandbox features, restricting subprocess access to resources and data. See [https://eklitzke.org/multiprocess-bitcoin](https://eklitzke.org/multiprocess-bitcoin).\n-\n-## Debugging\n-\n-The `-debug=ipc` command line option can be used to see requests and responses between processes.\n-\n-## Installation\n-\n-The multiprocess feature requires [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) as dependencies. A simple way to get starting using it without installing these dependencies manually is to use the [depends system](../../depends) with the `MULTIPROCESS=1` [dependency option](../../depends#dependency-options) passed to make:\n-\n-```\n-cd <BITCOIN_SOURCE_DIRECTORY>\n-make -C depends NO_QT=1 MULTIPROCESS=1\n-CONFIG_SITE=$PWD/depends/x86_64-pc-linux-gnu/share/config.site ./configure\n-make\n-src/bitcoin-node -regtest -printtoconsole -debug=ipc\n-BITCOIND=bitcoin-node test/functional/test_runner.py\n-```\n-\n-The configure script will pick up settings and library locations from the depends directory, so there is no need to pass `--enable-multiprocess` as a separate flag when using the depends system (it's controlled by the `MULTIPROCESS=1` option).\n-\n-Alternately, you can install [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) packages on your system, and just run `./configure --enable-multiprocess` without using the depends system. The configure script will be able to locate the installed packages via [pkg-config](https://www.freedesktop.org/wiki/Software/pkg-config/). See [Installation](https://github.com/chaincodelabs/libmultiprocess/blob/master/doc/install.md) section of the libmultiprocess readme for install steps. See [build-unix.md](../build-unix.md) and [build-osx.md](../build-osx.md) for information about installing dependencies in general.\n-\n-## IPC implementation details\n-\n-Cross process Node, Wallet, and Chain interfaces are defined in\n-[`src/interfaces/`](../../src/interfaces/). These are C++ classes which follow\n-[conventions](../developer-notes.md#internal-interface-guidelines), like passing\n-serializable arguments so they can be called from different processes, and\n-making methods pure virtual so they can have proxy implementations that forward\n-calls between processes.\n-\n-When Wallet, Node, and Chain code is running in the same process, calling any\n-interface method invokes the implementation directly. When code is running in\n-different processes, calling an interface method invokes a proxy interface\n-implementation that communicates with a remote process and invokes the real\n-implementation in the remote process. The\n-[libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) code\n-generation tool internally generates proxy client classes and proxy server\n-classes for this purpose that are thin wrappers around Cap'n Proto\n-[client](https://capnproto.org/cxxrpc.html#clients) and\n-[server](https://capnproto.org/cxxrpc.html#servers) classes, which handle the\n-actual serialization and socket communication.\n-\n-As much as possible, calls between processes are meant to work the same as\n-calls within a single process without adding limitations or requiring extra\n-implementation effort. Processes communicate with each other by calling regular\n-[C++ interface methods](../../src/interfaces/README.md). Method arguments and\n-return values are automatically serialized and sent between processes. Object\n-references and `std::function` arguments are automatically tracked and mapped\n-to allow invoked code to call back into invoking code at any time, and there is\n-a 1:1 threading model where any thread invoking a method in another process has\n-a corresponding thread in the invoked process responsible for executing all\n-method calls from the source thread, without blocking I/O or holding up another\n-call, and using the same thread local variables, locks, and callbacks between\n-calls. The forwarding, tracking, and threading is implemented inside the\n-[libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) library\n-which has the design goal of making calls between processes look like calls in\n-the same process to the extent possible.\n+# Multiprocess Bitcoin Design Document\n+\n+Guide to the design and architecture of the Bitcoin-Core multiprocess feature\n+\n+_This document describes the design of the multiprocess feature. For usage information, see the top-level [multiprocess.md](../multiprocess.md) file._\n+\n+## Table of contents\n+\n+- [Introduction](#introduction)\n+- [Current Architecture](#current-architecture)\n+- [Proposed Architecture](#proposed-architecture)\n+- [Component Overview: Navigating the IPC Framework](#component-overview-navigating-the-ipc-framework)\n+- [Design Considerations](#design-considerations)\n+  - [Selection of Cap’n Proto](#selection-of-capn-proto)\n+  - [Hiding IPC](#hiding-ipc)\n+  - [Interface Definition Maintenance](#interface-definition-maintenance)\n+  - [Interface Stability](#interface-stability)\n+- [Example Use Cases and Flows](#example-use-cases-and-flows)\n+  - [Retrieving a Block Hash](#retrieving-a-block-hash)\n+- [Future Enhancements](#future-enhancements)\n+- [Conclusion](#conclusion)\n+- [Appendices](#appendices)\n+  - [Glossary of Terms](#glossary-of-terms)\n+  - [References](#references)\n+- [Acknowledgements](#acknowledgements)\n+\n+## Introduction\n+\n+The Bitcoin Core software, central to the Bitcoin network, has historically employed a monolithic architecture. The existing design has integrated functionality like P2P network operations, wallet management, and a GUI into a single executable. While effective, it has limitations in flexibility, security, and scalability. This project introduces changes that transition Bitcoin Core to a more modular architecture. It aims to enhance security, improve usability, and facilitate maintenance and development of the software.\n+\n+## Current Architecture\n+\n+The current system features two primary executables: `bitcoind` and `bitcoin-qt`. `bitcoind` combines a Bitcoin P2P node with an integrated JSON-RPC server, wallet, and indexes. `bitcoin-qt` extends this by incorporating a Qt-based GUI. This monolithic structure, although robust, presents challenges such as limited operational flexibility and increased security risks due to the tight integration of components.\n+\n+## Proposed Architecture\n+\n+The new architecture divides the existing code into three specialized executables:\n+\n+- `bitcoin-node`: Manages the node, indexes, and JSON-RPC server.\n+- `bitcoin-wallet`: Handles all wallet functionality.\n+- `bitcoin-gui`: Provides a standalone Qt-based GUI.\n+\n+This modular approach is designed to enhance security through component isolation and improve usability by allowing independent operation of each module. This allows for new use-cases, such as running the node on a dedicated machine and operating wallets and GUIs on separate machines with the flexibility to start and stop them as needed.\n+\n+This subdivision could be extended in the future. For example, indexes could be removed from the `bitcoin-node` executable and run in separate executables. And JSON-RPC servers could be added to wallet and index executables, so they can listen and respond to RPC requests on their own ports, without needing to forward RPC requests through `bitcoin-node`.\n+\n+## Component Overview: Navigating the IPC Framework\n+\n+This section describes the major components of the Inter-Process Communication (IPC) framework covering the relevant source files, generated files, tools, and libraries.\n+\n+### Abstract C++ Classes in [`src/interfaces/`](../../src/interfaces/)\n+- The foundation of the IPC implementation lies in the abstract C++ classes within the [`src/interfaces/`](../../src/interfaces/) directory. These classes define pure virtual methods that code in [`src/node/`](../../src/node/), [`src/wallet/`](../../src/wallet/), and [`src/qt/`](../../src/qt/) directories call to interact with each other.\n+- Each abstract class in this directory represents a distinct interface that the different modules (node, wallet, GUI) implement and use for cross-process communication.\n+- The classes are written following conventions described in [Internal Interface\n+  Guidelines](../developer-notes.md#internal-interface-guidelines) to ensure\n+  compatibility with Cap'n Proto.\n+\n+### Cap’n Proto Files in [`src/ipc/capnp/`](../../src/ipc/capnp/)\n+- Corresponding to each abstract class, there are `.capnp` files within the [`src/ipc/capnp/`](../../src/ipc/capnp/) directory. These files are used as input to the `mpgen` tool (described below) to generate C++ code.\n+- These Cap’n Proto files ([learn more about Cap'n Proto RPC](https://capnproto.org/rpc.html)) define the structure and format of messages that are exchanged over IPC. They serve as blueprints for generating C++ code that bridges the gap between high-level C++ interfaces and low-level socket communication.\n+\n+### The `mpgen` Code Generation Tool\n+- A central component of the IPC framework is the `mpgen` tool which is part the [`libmultiprocess` project](https://github.com/chaincodelabs/libmultiprocess). This tool takes the `.capnp` files as input and generates C++ code.\n+- The generated code handles IPC communication, translating interface calls into socket reads and writes.\n+\n+### C++ Client Subclasses in Generated Code\n+- In the generated code, we have C++ client subclasses that inherit from the abstract classes in [`src/interfaces/`](../../src/interfaces/). These subclasses are the workhorses of the IPC mechanism.\n+- They implement all the methods of the interface, marshalling arguments into a structured format, sending them as requests to the IPC server via a UNIX socket, and handling the responses.\n+- These subclasses effectively mask the complexity of IPC, presenting a familiar C++ interface to developers.\n+- Internally, the client subclasses generated by the `mpgen` tool wrap [client classes generated by Cap'n Proto](https://capnproto.org/cxxrpc.html#clients), and use them to send IPC requests.\n+\n+### C++ Server Classes in Generated Code\n+- On the server side, corresponding generated C++ classes receive IPC requests. These server classes are responsible for unmarshalling method arguments, invoking the corresponding methods in the local [`src/interfaces/`](../../src/interfaces/) objects, and creating the IPC response.\n+- The server classes ensure that return values (including output argument values and thrown exceptions) are marshalled and sent back to the client, completing the communication cycle.\n+- Internally, the server subclasses generated by the `mpgen` tool inherit from [server classes generated by Cap'n Proto](https://capnproto.org/cxxrpc.html#servers), and use them to process IPC requests.\n+\n+### The `libmultiprocess` Runtime Library\n+- **Core Functionality**: The `libmultiprocess` runtime library's primary function is to instantiate the generated client and server classes as needed.\n+- **Bootstrapping IPC Connections**: It provides functions for starting new IPC connections, specifically binding generated client and server classes for an initial `interfaces::Init` interface (defined in [`src/interfaces/init.h`](../../src/interfaces/init.h)) to a UNIX socket. This initial interface has methods returning other interfaces that different Bitcoin-Core modules use to communicate after the bootstrapping phase.\n+- **Asynchronous I/O and Thread Management**: The library is also responsible for managing I/O and threading. Particularly, it ensures that IPC requests never block each other and that new threads on either side of a connection can always make client calls. It also manages worker threads on the server side of calls, ensuring that calls from the same client thread always execute on the same server thread (to avoid locking issues and support nested callbacks).\n+\n+### Type Hooks in [`src/ipc/capnp/*-types.h`](../../src/ipc/capnp/)\n+- **Custom Type Conversions**: In [`src/ipc/capnp/*-types.h`](../../src/ipc/capnp/), multiple function overloads of two `libmultiprocess` C++ functions, `mp::CustomReadField` and `mp::CustomBuildFields`, are defined. These functions are used for customizing the conversion of specific C++ types to and from Cap’n Proto types.\n+- **Handling Special Cases**: The `mpgen` tool and `libmultiprocess` library can convert most C++ types to and from Cap’n Proto types automatically, including interface types, primitive C++ types, standard C++ types like `std::vector`, `std::set`, `std::map`, `std::tuple`, and `std::function`, as well as simple C++ structs that consist of afforementioned types and whose fields correspond 1:1 with Cap’n Proto struct fields. For other types, `*-types.h` files provide custom code to convert between C++ and Cap’n Proto data representations.",
      "path": "doc/design/multiprocess.md",
      "position": null,
      "original_position": 156,
      "commit_id": "91dc48c14825a9075a57c1eefda202b83b6346ba",
      "original_commit_id": "837c53d14f24924cdcb2cfd8b18915882dc3b620",
      "in_reply_to_id": 1428162298,
      "user": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "re: https://github.com/bitcoin/bitcoin/pull/28978#discussion_r1428162298\r\n\r\n> nit: typo\r\n\r\nThanks, fixed",
      "created_at": "2023-12-19T12:48:17Z",
      "updated_at": "2023-12-19T16:29:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28978#discussion_r1431360934",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1431360934"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28978"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 84,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1431361020",
      "pull_request_review_id": 1788797844,
      "id": 1431361020,
      "node_id": "PRRC_kwDOABII585VUNX8",
      "diff_hunk": "@@ -1,72 +1,200 @@\n-# Multiprocess Bitcoin\n-\n-On unix systems, the `--enable-multiprocess` build option can be passed to `./configure` to build new `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables alongside existing `bitcoind` and `bitcoin-qt` executables.\n-\n-`bitcoin-node` is a drop-in replacement for `bitcoind`, and `bitcoin-gui` is a drop-in replacement for `bitcoin-qt`, and there are no differences in use or external behavior between the new and old executables. But internally (after [#10102](https://github.com/bitcoin/bitcoin/pull/10102)), `bitcoin-gui` will spawn a `bitcoin-node` process to run P2P and RPC code, communicating with it across a socket pair, and `bitcoin-node` will spawn `bitcoin-wallet` to run wallet code, also communicating over a socket pair. This will let node, wallet, and GUI code run in separate address spaces for better isolation, and allow future improvements like being able to start and stop components independently on different machines and environments.\n-\n-## Next steps\n-\n-Specific next steps after [#10102](https://github.com/bitcoin/bitcoin/pull/10102) will be:\n-\n-- [ ] Adding `-ipcbind` and `-ipcconnect` options to `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables so they can listen and connect to TCP ports and unix socket paths. This will allow separate processes to be started and stopped any time and connect to each other.\n-- [ ] Adding `-server` and `-rpcbind` options to the `bitcoin-wallet` executable so wallet processes can handle RPC requests directly without going through the node.\n-- [ ] Supporting windows, not just unix systems. The existing socket code is already cross-platform, so the only windows-specific code that needs to be written is code spawning a process and passing a socket descriptor. This can be implemented with `CreateProcess` and `WSADuplicateSocket`. Example: https://memset.wordpress.com/2010/10/13/win32-api-passing-socket-with-ipc-method/.\n-- [ ] Adding sandbox features, restricting subprocess access to resources and data. See [https://eklitzke.org/multiprocess-bitcoin](https://eklitzke.org/multiprocess-bitcoin).\n-\n-## Debugging\n-\n-The `-debug=ipc` command line option can be used to see requests and responses between processes.\n-\n-## Installation\n-\n-The multiprocess feature requires [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) as dependencies. A simple way to get starting using it without installing these dependencies manually is to use the [depends system](../../depends) with the `MULTIPROCESS=1` [dependency option](../../depends#dependency-options) passed to make:\n-\n-```\n-cd <BITCOIN_SOURCE_DIRECTORY>\n-make -C depends NO_QT=1 MULTIPROCESS=1\n-CONFIG_SITE=$PWD/depends/x86_64-pc-linux-gnu/share/config.site ./configure\n-make\n-src/bitcoin-node -regtest -printtoconsole -debug=ipc\n-BITCOIND=bitcoin-node test/functional/test_runner.py\n-```\n-\n-The configure script will pick up settings and library locations from the depends directory, so there is no need to pass `--enable-multiprocess` as a separate flag when using the depends system (it's controlled by the `MULTIPROCESS=1` option).\n-\n-Alternately, you can install [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) packages on your system, and just run `./configure --enable-multiprocess` without using the depends system. The configure script will be able to locate the installed packages via [pkg-config](https://www.freedesktop.org/wiki/Software/pkg-config/). See [Installation](https://github.com/chaincodelabs/libmultiprocess/blob/master/doc/install.md) section of the libmultiprocess readme for install steps. See [build-unix.md](../build-unix.md) and [build-osx.md](../build-osx.md) for information about installing dependencies in general.\n-\n-## IPC implementation details\n-\n-Cross process Node, Wallet, and Chain interfaces are defined in\n-[`src/interfaces/`](../../src/interfaces/). These are C++ classes which follow\n-[conventions](../developer-notes.md#internal-interface-guidelines), like passing\n-serializable arguments so they can be called from different processes, and\n-making methods pure virtual so they can have proxy implementations that forward\n-calls between processes.\n-\n-When Wallet, Node, and Chain code is running in the same process, calling any\n-interface method invokes the implementation directly. When code is running in\n-different processes, calling an interface method invokes a proxy interface\n-implementation that communicates with a remote process and invokes the real\n-implementation in the remote process. The\n-[libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) code\n-generation tool internally generates proxy client classes and proxy server\n-classes for this purpose that are thin wrappers around Cap'n Proto\n-[client](https://capnproto.org/cxxrpc.html#clients) and\n-[server](https://capnproto.org/cxxrpc.html#servers) classes, which handle the\n-actual serialization and socket communication.\n-\n-As much as possible, calls between processes are meant to work the same as\n-calls within a single process without adding limitations or requiring extra\n-implementation effort. Processes communicate with each other by calling regular\n-[C++ interface methods](../../src/interfaces/README.md). Method arguments and\n-return values are automatically serialized and sent between processes. Object\n-references and `std::function` arguments are automatically tracked and mapped\n-to allow invoked code to call back into invoking code at any time, and there is\n-a 1:1 threading model where any thread invoking a method in another process has\n-a corresponding thread in the invoked process responsible for executing all\n-method calls from the source thread, without blocking I/O or holding up another\n-call, and using the same thread local variables, locks, and callbacks between\n-calls. The forwarding, tracking, and threading is implemented inside the\n-[libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) library\n-which has the design goal of making calls between processes look like calls in\n-the same process to the extent possible.\n+# Multiprocess Bitcoin Design Document\n+\n+Guide to the design and architecture of the Bitcoin-Core multiprocess feature\n+\n+_This document describes the design of the multiprocess feature. For usage information, see the top-level [multiprocess.md](../multiprocess.md) file._\n+\n+## Table of contents\n+\n+- [Introduction](#introduction)\n+- [Current Architecture](#current-architecture)\n+- [Proposed Architecture](#proposed-architecture)\n+- [Component Overview: Navigating the IPC Framework](#component-overview-navigating-the-ipc-framework)\n+- [Design Considerations](#design-considerations)\n+  - [Selection of Cap’n Proto](#selection-of-capn-proto)\n+  - [Hiding IPC](#hiding-ipc)\n+  - [Interface Definition Maintenance](#interface-definition-maintenance)\n+  - [Interface Stability](#interface-stability)\n+- [Example Use Cases and Flows](#example-use-cases-and-flows)\n+  - [Retrieving a Block Hash](#retrieving-a-block-hash)\n+- [Future Enhancements](#future-enhancements)\n+- [Conclusion](#conclusion)\n+- [Appendices](#appendices)\n+  - [Glossary of Terms](#glossary-of-terms)\n+  - [References](#references)\n+- [Acknowledgements](#acknowledgements)\n+\n+## Introduction\n+\n+The Bitcoin Core software, central to the Bitcoin network, has historically employed a monolithic architecture. The existing design has integrated functionality like P2P network operations, wallet management, and a GUI into a single executable. While effective, it has limitations in flexibility, security, and scalability. This project introduces changes that transition Bitcoin Core to a more modular architecture. It aims to enhance security, improve usability, and facilitate maintenance and development of the software.\n+\n+## Current Architecture\n+\n+The current system features two primary executables: `bitcoind` and `bitcoin-qt`. `bitcoind` combines a Bitcoin P2P node with an integrated JSON-RPC server, wallet, and indexes. `bitcoin-qt` extends this by incorporating a Qt-based GUI. This monolithic structure, although robust, presents challenges such as limited operational flexibility and increased security risks due to the tight integration of components.\n+\n+## Proposed Architecture\n+\n+The new architecture divides the existing code into three specialized executables:\n+\n+- `bitcoin-node`: Manages the node, indexes, and JSON-RPC server.\n+- `bitcoin-wallet`: Handles all wallet functionality.\n+- `bitcoin-gui`: Provides a standalone Qt-based GUI.\n+\n+This modular approach is designed to enhance security through component isolation and improve usability by allowing independent operation of each module. This allows for new use-cases, such as running the node on a dedicated machine and operating wallets and GUIs on separate machines with the flexibility to start and stop them as needed.\n+\n+This subdivision could be extended in the future. For example, indexes could be removed from the `bitcoin-node` executable and run in separate executables. And JSON-RPC servers could be added to wallet and index executables, so they can listen and respond to RPC requests on their own ports, without needing to forward RPC requests through `bitcoin-node`.\n+\n+## Component Overview: Navigating the IPC Framework\n+\n+This section describes the major components of the Inter-Process Communication (IPC) framework covering the relevant source files, generated files, tools, and libraries.\n+\n+### Abstract C++ Classes in [`src/interfaces/`](../../src/interfaces/)\n+- The foundation of the IPC implementation lies in the abstract C++ classes within the [`src/interfaces/`](../../src/interfaces/) directory. These classes define pure virtual methods that code in [`src/node/`](../../src/node/), [`src/wallet/`](../../src/wallet/), and [`src/qt/`](../../src/qt/) directories call to interact with each other.\n+- Each abstract class in this directory represents a distinct interface that the different modules (node, wallet, GUI) implement and use for cross-process communication.\n+- The classes are written following conventions described in [Internal Interface\n+  Guidelines](../developer-notes.md#internal-interface-guidelines) to ensure\n+  compatibility with Cap'n Proto.\n+\n+### Cap’n Proto Files in [`src/ipc/capnp/`](../../src/ipc/capnp/)\n+- Corresponding to each abstract class, there are `.capnp` files within the [`src/ipc/capnp/`](../../src/ipc/capnp/) directory. These files are used as input to the `mpgen` tool (described below) to generate C++ code.\n+- These Cap’n Proto files ([learn more about Cap'n Proto RPC](https://capnproto.org/rpc.html)) define the structure and format of messages that are exchanged over IPC. They serve as blueprints for generating C++ code that bridges the gap between high-level C++ interfaces and low-level socket communication.\n+\n+### The `mpgen` Code Generation Tool\n+- A central component of the IPC framework is the `mpgen` tool which is part the [`libmultiprocess` project](https://github.com/chaincodelabs/libmultiprocess). This tool takes the `.capnp` files as input and generates C++ code.\n+- The generated code handles IPC communication, translating interface calls into socket reads and writes.\n+\n+### C++ Client Subclasses in Generated Code\n+- In the generated code, we have C++ client subclasses that inherit from the abstract classes in [`src/interfaces/`](../../src/interfaces/). These subclasses are the workhorses of the IPC mechanism.\n+- They implement all the methods of the interface, marshalling arguments into a structured format, sending them as requests to the IPC server via a UNIX socket, and handling the responses.\n+- These subclasses effectively mask the complexity of IPC, presenting a familiar C++ interface to developers.\n+- Internally, the client subclasses generated by the `mpgen` tool wrap [client classes generated by Cap'n Proto](https://capnproto.org/cxxrpc.html#clients), and use them to send IPC requests.\n+\n+### C++ Server Classes in Generated Code\n+- On the server side, corresponding generated C++ classes receive IPC requests. These server classes are responsible for unmarshalling method arguments, invoking the corresponding methods in the local [`src/interfaces/`](../../src/interfaces/) objects, and creating the IPC response.\n+- The server classes ensure that return values (including output argument values and thrown exceptions) are marshalled and sent back to the client, completing the communication cycle.\n+- Internally, the server subclasses generated by the `mpgen` tool inherit from [server classes generated by Cap'n Proto](https://capnproto.org/cxxrpc.html#servers), and use them to process IPC requests.\n+\n+### The `libmultiprocess` Runtime Library\n+- **Core Functionality**: The `libmultiprocess` runtime library's primary function is to instantiate the generated client and server classes as needed.\n+- **Bootstrapping IPC Connections**: It provides functions for starting new IPC connections, specifically binding generated client and server classes for an initial `interfaces::Init` interface (defined in [`src/interfaces/init.h`](../../src/interfaces/init.h)) to a UNIX socket. This initial interface has methods returning other interfaces that different Bitcoin-Core modules use to communicate after the bootstrapping phase.\n+- **Asynchronous I/O and Thread Management**: The library is also responsible for managing I/O and threading. Particularly, it ensures that IPC requests never block each other and that new threads on either side of a connection can always make client calls. It also manages worker threads on the server side of calls, ensuring that calls from the same client thread always execute on the same server thread (to avoid locking issues and support nested callbacks).\n+\n+### Type Hooks in [`src/ipc/capnp/*-types.h`](../../src/ipc/capnp/)\n+- **Custom Type Conversions**: In [`src/ipc/capnp/*-types.h`](../../src/ipc/capnp/), multiple function overloads of two `libmultiprocess` C++ functions, `mp::CustomReadField` and `mp::CustomBuildFields`, are defined. These functions are used for customizing the conversion of specific C++ types to and from Cap’n Proto types.\n+- **Handling Special Cases**: The `mpgen` tool and `libmultiprocess` library can convert most C++ types to and from Cap’n Proto types automatically, including interface types, primitive C++ types, standard C++ types like `std::vector`, `std::set`, `std::map`, `std::tuple`, and `std::function`, as well as simple C++ structs that consist of afforementioned types and whose fields correspond 1:1 with Cap’n Proto struct fields. For other types, `*-types.h` files provide custom code to convert between C++ and Cap’n Proto data representations.\n+\n+### Protocol-Agnostic IPC Code in [`src/ipc/`](../../src/ipc/)\n+- **Broad Applicability**: Unlike the Cap’n Proto-specific code in [`src/ipc/capnp/`](../../src/ipc/capnp/), the code in the [`src/ipc/`](../../src/ipc/) directory is protocol-agnostic. This enables potential support for other protocols, such as gRPC or a custom protocol in the future.\n+- **Process Management and Socket Operations**: The main purpose of this component is to provide functions for spawning new processes and creating and connecting to UNIX sockets.\n+- **ipc::Exception Class**: This code also defines an `ipc::Exception` class which is thrown from the generated C++ client class methods when there is an unexpected IPC error, such as a disconnection.\n+\n+## Design Considerations\n+\n+### Selection of Cap’n Proto\n+The choice to use [Cap’n Proto](https://capnproto.org/) for IPC was primarily influenced by its support for passing object references and managing object lifetimes, which would have to be implemented manually with a framework that only supported plain requests and responses like [gRPC](https://grpc.io/). The support is especially helpful for passing callback objects like `std::function` and supporting bidirectional communication.\n+\n+The choice to use an RPC framework at all instead of a custom protocol was neccesitated by the size of Bitcoin Core internal interfaces which consist of around 150 methods that pass complex data structures and are called in complicated ways (in parallel, from callbacks that can be nested and stored). Writing a custom protocol to wrap these complicated interfaces would be too much work, akin to writing a new RPC framework.",
      "path": "doc/design/multiprocess.md",
      "position": null,
      "original_position": 168,
      "commit_id": "91dc48c14825a9075a57c1eefda202b83b6346ba",
      "original_commit_id": "837c53d14f24924cdcb2cfd8b18915882dc3b620",
      "in_reply_to_id": 1424248273,
      "user": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "re: https://github.com/bitcoin/bitcoin/pull/28978#discussion_r1424248273\r\n\r\n> typo nit\r\n\r\nThanks, fixed",
      "created_at": "2023-12-19T12:48:23Z",
      "updated_at": "2023-12-19T16:29:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28978#discussion_r1431361020",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1431361020"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28978"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 96,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1431361157",
      "pull_request_review_id": 1788797844,
      "id": 1431361157,
      "node_id": "PRRC_kwDOABII585VUNaF",
      "diff_hunk": "@@ -1,72 +1,200 @@\n-# Multiprocess Bitcoin\n-\n-On unix systems, the `--enable-multiprocess` build option can be passed to `./configure` to build new `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables alongside existing `bitcoind` and `bitcoin-qt` executables.\n-\n-`bitcoin-node` is a drop-in replacement for `bitcoind`, and `bitcoin-gui` is a drop-in replacement for `bitcoin-qt`, and there are no differences in use or external behavior between the new and old executables. But internally (after [#10102](https://github.com/bitcoin/bitcoin/pull/10102)), `bitcoin-gui` will spawn a `bitcoin-node` process to run P2P and RPC code, communicating with it across a socket pair, and `bitcoin-node` will spawn `bitcoin-wallet` to run wallet code, also communicating over a socket pair. This will let node, wallet, and GUI code run in separate address spaces for better isolation, and allow future improvements like being able to start and stop components independently on different machines and environments.\n-\n-## Next steps\n-\n-Specific next steps after [#10102](https://github.com/bitcoin/bitcoin/pull/10102) will be:\n-\n-- [ ] Adding `-ipcbind` and `-ipcconnect` options to `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables so they can listen and connect to TCP ports and unix socket paths. This will allow separate processes to be started and stopped any time and connect to each other.\n-- [ ] Adding `-server` and `-rpcbind` options to the `bitcoin-wallet` executable so wallet processes can handle RPC requests directly without going through the node.\n-- [ ] Supporting windows, not just unix systems. The existing socket code is already cross-platform, so the only windows-specific code that needs to be written is code spawning a process and passing a socket descriptor. This can be implemented with `CreateProcess` and `WSADuplicateSocket`. Example: https://memset.wordpress.com/2010/10/13/win32-api-passing-socket-with-ipc-method/.\n-- [ ] Adding sandbox features, restricting subprocess access to resources and data. See [https://eklitzke.org/multiprocess-bitcoin](https://eklitzke.org/multiprocess-bitcoin).\n-\n-## Debugging\n-\n-The `-debug=ipc` command line option can be used to see requests and responses between processes.\n-\n-## Installation\n-\n-The multiprocess feature requires [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) as dependencies. A simple way to get starting using it without installing these dependencies manually is to use the [depends system](../../depends) with the `MULTIPROCESS=1` [dependency option](../../depends#dependency-options) passed to make:\n-\n-```\n-cd <BITCOIN_SOURCE_DIRECTORY>\n-make -C depends NO_QT=1 MULTIPROCESS=1\n-CONFIG_SITE=$PWD/depends/x86_64-pc-linux-gnu/share/config.site ./configure\n-make\n-src/bitcoin-node -regtest -printtoconsole -debug=ipc\n-BITCOIND=bitcoin-node test/functional/test_runner.py\n-```\n-\n-The configure script will pick up settings and library locations from the depends directory, so there is no need to pass `--enable-multiprocess` as a separate flag when using the depends system (it's controlled by the `MULTIPROCESS=1` option).\n-\n-Alternately, you can install [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) packages on your system, and just run `./configure --enable-multiprocess` without using the depends system. The configure script will be able to locate the installed packages via [pkg-config](https://www.freedesktop.org/wiki/Software/pkg-config/). See [Installation](https://github.com/chaincodelabs/libmultiprocess/blob/master/doc/install.md) section of the libmultiprocess readme for install steps. See [build-unix.md](../build-unix.md) and [build-osx.md](../build-osx.md) for information about installing dependencies in general.\n-\n-## IPC implementation details\n-\n-Cross process Node, Wallet, and Chain interfaces are defined in\n-[`src/interfaces/`](../../src/interfaces/). These are C++ classes which follow\n-[conventions](../developer-notes.md#internal-interface-guidelines), like passing\n-serializable arguments so they can be called from different processes, and\n-making methods pure virtual so they can have proxy implementations that forward\n-calls between processes.\n-\n-When Wallet, Node, and Chain code is running in the same process, calling any\n-interface method invokes the implementation directly. When code is running in\n-different processes, calling an interface method invokes a proxy interface\n-implementation that communicates with a remote process and invokes the real\n-implementation in the remote process. The\n-[libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) code\n-generation tool internally generates proxy client classes and proxy server\n-classes for this purpose that are thin wrappers around Cap'n Proto\n-[client](https://capnproto.org/cxxrpc.html#clients) and\n-[server](https://capnproto.org/cxxrpc.html#servers) classes, which handle the\n-actual serialization and socket communication.\n-\n-As much as possible, calls between processes are meant to work the same as\n-calls within a single process without adding limitations or requiring extra\n-implementation effort. Processes communicate with each other by calling regular\n-[C++ interface methods](../../src/interfaces/README.md). Method arguments and\n-return values are automatically serialized and sent between processes. Object\n-references and `std::function` arguments are automatically tracked and mapped\n-to allow invoked code to call back into invoking code at any time, and there is\n-a 1:1 threading model where any thread invoking a method in another process has\n-a corresponding thread in the invoked process responsible for executing all\n-method calls from the source thread, without blocking I/O or holding up another\n-call, and using the same thread local variables, locks, and callbacks between\n-calls. The forwarding, tracking, and threading is implemented inside the\n-[libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) library\n-which has the design goal of making calls between processes look like calls in\n-the same process to the extent possible.\n+# Multiprocess Bitcoin Design Document\n+\n+Guide to the design and architecture of the Bitcoin-Core multiprocess feature\n+\n+_This document describes the design of the multiprocess feature. For usage information, see the top-level [multiprocess.md](../multiprocess.md) file._\n+\n+## Table of contents\n+\n+- [Introduction](#introduction)\n+- [Current Architecture](#current-architecture)\n+- [Proposed Architecture](#proposed-architecture)\n+- [Component Overview: Navigating the IPC Framework](#component-overview-navigating-the-ipc-framework)\n+- [Design Considerations](#design-considerations)\n+  - [Selection of Cap’n Proto](#selection-of-capn-proto)\n+  - [Hiding IPC](#hiding-ipc)\n+  - [Interface Definition Maintenance](#interface-definition-maintenance)\n+  - [Interface Stability](#interface-stability)\n+- [Example Use Cases and Flows](#example-use-cases-and-flows)\n+  - [Retrieving a Block Hash](#retrieving-a-block-hash)\n+- [Future Enhancements](#future-enhancements)\n+- [Conclusion](#conclusion)\n+- [Appendices](#appendices)\n+  - [Glossary of Terms](#glossary-of-terms)\n+  - [References](#references)\n+- [Acknowledgements](#acknowledgements)\n+\n+## Introduction\n+\n+The Bitcoin Core software, central to the Bitcoin network, has historically employed a monolithic architecture. The existing design has integrated functionality like P2P network operations, wallet management, and a GUI into a single executable. While effective, it has limitations in flexibility, security, and scalability. This project introduces changes that transition Bitcoin Core to a more modular architecture. It aims to enhance security, improve usability, and facilitate maintenance and development of the software.\n+\n+## Current Architecture\n+\n+The current system features two primary executables: `bitcoind` and `bitcoin-qt`. `bitcoind` combines a Bitcoin P2P node with an integrated JSON-RPC server, wallet, and indexes. `bitcoin-qt` extends this by incorporating a Qt-based GUI. This monolithic structure, although robust, presents challenges such as limited operational flexibility and increased security risks due to the tight integration of components.\n+\n+## Proposed Architecture\n+\n+The new architecture divides the existing code into three specialized executables:\n+\n+- `bitcoin-node`: Manages the node, indexes, and JSON-RPC server.\n+- `bitcoin-wallet`: Handles all wallet functionality.\n+- `bitcoin-gui`: Provides a standalone Qt-based GUI.\n+\n+This modular approach is designed to enhance security through component isolation and improve usability by allowing independent operation of each module. This allows for new use-cases, such as running the node on a dedicated machine and operating wallets and GUIs on separate machines with the flexibility to start and stop them as needed.\n+\n+This subdivision could be extended in the future. For example, indexes could be removed from the `bitcoin-node` executable and run in separate executables. And JSON-RPC servers could be added to wallet and index executables, so they can listen and respond to RPC requests on their own ports, without needing to forward RPC requests through `bitcoin-node`.\n+\n+## Component Overview: Navigating the IPC Framework\n+\n+This section describes the major components of the Inter-Process Communication (IPC) framework covering the relevant source files, generated files, tools, and libraries.\n+\n+### Abstract C++ Classes in [`src/interfaces/`](../../src/interfaces/)\n+- The foundation of the IPC implementation lies in the abstract C++ classes within the [`src/interfaces/`](../../src/interfaces/) directory. These classes define pure virtual methods that code in [`src/node/`](../../src/node/), [`src/wallet/`](../../src/wallet/), and [`src/qt/`](../../src/qt/) directories call to interact with each other.\n+- Each abstract class in this directory represents a distinct interface that the different modules (node, wallet, GUI) implement and use for cross-process communication.\n+- The classes are written following conventions described in [Internal Interface\n+  Guidelines](../developer-notes.md#internal-interface-guidelines) to ensure\n+  compatibility with Cap'n Proto.\n+\n+### Cap’n Proto Files in [`src/ipc/capnp/`](../../src/ipc/capnp/)\n+- Corresponding to each abstract class, there are `.capnp` files within the [`src/ipc/capnp/`](../../src/ipc/capnp/) directory. These files are used as input to the `mpgen` tool (described below) to generate C++ code.\n+- These Cap’n Proto files ([learn more about Cap'n Proto RPC](https://capnproto.org/rpc.html)) define the structure and format of messages that are exchanged over IPC. They serve as blueprints for generating C++ code that bridges the gap between high-level C++ interfaces and low-level socket communication.\n+\n+### The `mpgen` Code Generation Tool\n+- A central component of the IPC framework is the `mpgen` tool which is part the [`libmultiprocess` project](https://github.com/chaincodelabs/libmultiprocess). This tool takes the `.capnp` files as input and generates C++ code.\n+- The generated code handles IPC communication, translating interface calls into socket reads and writes.\n+\n+### C++ Client Subclasses in Generated Code\n+- In the generated code, we have C++ client subclasses that inherit from the abstract classes in [`src/interfaces/`](../../src/interfaces/). These subclasses are the workhorses of the IPC mechanism.\n+- They implement all the methods of the interface, marshalling arguments into a structured format, sending them as requests to the IPC server via a UNIX socket, and handling the responses.\n+- These subclasses effectively mask the complexity of IPC, presenting a familiar C++ interface to developers.\n+- Internally, the client subclasses generated by the `mpgen` tool wrap [client classes generated by Cap'n Proto](https://capnproto.org/cxxrpc.html#clients), and use them to send IPC requests.\n+\n+### C++ Server Classes in Generated Code\n+- On the server side, corresponding generated C++ classes receive IPC requests. These server classes are responsible for unmarshalling method arguments, invoking the corresponding methods in the local [`src/interfaces/`](../../src/interfaces/) objects, and creating the IPC response.\n+- The server classes ensure that return values (including output argument values and thrown exceptions) are marshalled and sent back to the client, completing the communication cycle.\n+- Internally, the server subclasses generated by the `mpgen` tool inherit from [server classes generated by Cap'n Proto](https://capnproto.org/cxxrpc.html#servers), and use them to process IPC requests.\n+\n+### The `libmultiprocess` Runtime Library\n+- **Core Functionality**: The `libmultiprocess` runtime library's primary function is to instantiate the generated client and server classes as needed.\n+- **Bootstrapping IPC Connections**: It provides functions for starting new IPC connections, specifically binding generated client and server classes for an initial `interfaces::Init` interface (defined in [`src/interfaces/init.h`](../../src/interfaces/init.h)) to a UNIX socket. This initial interface has methods returning other interfaces that different Bitcoin-Core modules use to communicate after the bootstrapping phase.\n+- **Asynchronous I/O and Thread Management**: The library is also responsible for managing I/O and threading. Particularly, it ensures that IPC requests never block each other and that new threads on either side of a connection can always make client calls. It also manages worker threads on the server side of calls, ensuring that calls from the same client thread always execute on the same server thread (to avoid locking issues and support nested callbacks).\n+\n+### Type Hooks in [`src/ipc/capnp/*-types.h`](../../src/ipc/capnp/)\n+- **Custom Type Conversions**: In [`src/ipc/capnp/*-types.h`](../../src/ipc/capnp/), multiple function overloads of two `libmultiprocess` C++ functions, `mp::CustomReadField` and `mp::CustomBuildFields`, are defined. These functions are used for customizing the conversion of specific C++ types to and from Cap’n Proto types.\n+- **Handling Special Cases**: The `mpgen` tool and `libmultiprocess` library can convert most C++ types to and from Cap’n Proto types automatically, including interface types, primitive C++ types, standard C++ types like `std::vector`, `std::set`, `std::map`, `std::tuple`, and `std::function`, as well as simple C++ structs that consist of afforementioned types and whose fields correspond 1:1 with Cap’n Proto struct fields. For other types, `*-types.h` files provide custom code to convert between C++ and Cap’n Proto data representations.\n+\n+### Protocol-Agnostic IPC Code in [`src/ipc/`](../../src/ipc/)\n+- **Broad Applicability**: Unlike the Cap’n Proto-specific code in [`src/ipc/capnp/`](../../src/ipc/capnp/), the code in the [`src/ipc/`](../../src/ipc/) directory is protocol-agnostic. This enables potential support for other protocols, such as gRPC or a custom protocol in the future.\n+- **Process Management and Socket Operations**: The main purpose of this component is to provide functions for spawning new processes and creating and connecting to UNIX sockets.\n+- **ipc::Exception Class**: This code also defines an `ipc::Exception` class which is thrown from the generated C++ client class methods when there is an unexpected IPC error, such as a disconnection.\n+\n+## Design Considerations\n+\n+### Selection of Cap’n Proto\n+The choice to use [Cap’n Proto](https://capnproto.org/) for IPC was primarily influenced by its support for passing object references and managing object lifetimes, which would have to be implemented manually with a framework that only supported plain requests and responses like [gRPC](https://grpc.io/). The support is especially helpful for passing callback objects like `std::function` and supporting bidirectional communication.\n+\n+The choice to use an RPC framework at all instead of a custom protocol was neccesitated by the size of Bitcoin Core internal interfaces which consist of around 150 methods that pass complex data structures and are called in complicated ways (in parallel, from callbacks that can be nested and stored). Writing a custom protocol to wrap these complicated interfaces would be too much work, akin to writing a new RPC framework.\n+\n+### Hiding IPC\n+\n+The IPC mechanism is deliberately isolated from the rest of the codebase so less code has to be concerned with IPC.\n+\n+Building Bitcoin Core with IPC support is optional, and the same code can be compiled to either run in the same process or separate processes. The build system also ensures Cap’n Proto library headers can only be used within the [`src/ipc/capnp/`](../../src/ipc/capnp/) directory, not in other parts of the codebase.\n+\n+The libmultiprocess runtime is designed to place as few constraints as possible on IPC interfaces and make IPC calls act like normal function calls. Method arguments, return values, and exceptions are automatically serialized and sent between processes. Object references and `std::function` arguments are automatically tracked and mapped to allow invoked code to call back into invoking code at any time. And there is a 1:1 threading model where any every client thread has a corresponding server thread responsible for executing incoming calls from that thread (there can be multiple calls from the same thread due to callbacks), without blocking, and holding the same thread-local variables and locks so behavior is the same whether IPC is used or not.",
      "path": "doc/design/multiprocess.md",
      "position": null,
      "original_position": 176,
      "commit_id": "91dc48c14825a9075a57c1eefda202b83b6346ba",
      "original_commit_id": "837c53d14f24924cdcb2cfd8b18915882dc3b620",
      "in_reply_to_id": 1428164608,
      "user": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "re: https://github.com/bitcoin/bitcoin/pull/28978#discussion_r1428164608\r\n\r\n> \r\n\r\nThanks, fixed",
      "created_at": "2023-12-19T12:48:30Z",
      "updated_at": "2023-12-19T16:29:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28978#discussion_r1431361157",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1431361157"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28978"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 104,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1431361251",
      "pull_request_review_id": 1788797844,
      "id": 1431361251,
      "node_id": "PRRC_kwDOABII585VUNbj",
      "diff_hunk": "@@ -1,72 +1,200 @@\n-# Multiprocess Bitcoin\n-\n-On unix systems, the `--enable-multiprocess` build option can be passed to `./configure` to build new `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables alongside existing `bitcoind` and `bitcoin-qt` executables.\n-\n-`bitcoin-node` is a drop-in replacement for `bitcoind`, and `bitcoin-gui` is a drop-in replacement for `bitcoin-qt`, and there are no differences in use or external behavior between the new and old executables. But internally (after [#10102](https://github.com/bitcoin/bitcoin/pull/10102)), `bitcoin-gui` will spawn a `bitcoin-node` process to run P2P and RPC code, communicating with it across a socket pair, and `bitcoin-node` will spawn `bitcoin-wallet` to run wallet code, also communicating over a socket pair. This will let node, wallet, and GUI code run in separate address spaces for better isolation, and allow future improvements like being able to start and stop components independently on different machines and environments.\n-\n-## Next steps\n-\n-Specific next steps after [#10102](https://github.com/bitcoin/bitcoin/pull/10102) will be:\n-\n-- [ ] Adding `-ipcbind` and `-ipcconnect` options to `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables so they can listen and connect to TCP ports and unix socket paths. This will allow separate processes to be started and stopped any time and connect to each other.\n-- [ ] Adding `-server` and `-rpcbind` options to the `bitcoin-wallet` executable so wallet processes can handle RPC requests directly without going through the node.\n-- [ ] Supporting windows, not just unix systems. The existing socket code is already cross-platform, so the only windows-specific code that needs to be written is code spawning a process and passing a socket descriptor. This can be implemented with `CreateProcess` and `WSADuplicateSocket`. Example: https://memset.wordpress.com/2010/10/13/win32-api-passing-socket-with-ipc-method/.\n-- [ ] Adding sandbox features, restricting subprocess access to resources and data. See [https://eklitzke.org/multiprocess-bitcoin](https://eklitzke.org/multiprocess-bitcoin).\n-\n-## Debugging\n-\n-The `-debug=ipc` command line option can be used to see requests and responses between processes.\n-\n-## Installation\n-\n-The multiprocess feature requires [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) as dependencies. A simple way to get starting using it without installing these dependencies manually is to use the [depends system](../../depends) with the `MULTIPROCESS=1` [dependency option](../../depends#dependency-options) passed to make:\n-\n-```\n-cd <BITCOIN_SOURCE_DIRECTORY>\n-make -C depends NO_QT=1 MULTIPROCESS=1\n-CONFIG_SITE=$PWD/depends/x86_64-pc-linux-gnu/share/config.site ./configure\n-make\n-src/bitcoin-node -regtest -printtoconsole -debug=ipc\n-BITCOIND=bitcoin-node test/functional/test_runner.py\n-```\n-\n-The configure script will pick up settings and library locations from the depends directory, so there is no need to pass `--enable-multiprocess` as a separate flag when using the depends system (it's controlled by the `MULTIPROCESS=1` option).\n-\n-Alternately, you can install [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) packages on your system, and just run `./configure --enable-multiprocess` without using the depends system. The configure script will be able to locate the installed packages via [pkg-config](https://www.freedesktop.org/wiki/Software/pkg-config/). See [Installation](https://github.com/chaincodelabs/libmultiprocess/blob/master/doc/install.md) section of the libmultiprocess readme for install steps. See [build-unix.md](../build-unix.md) and [build-osx.md](../build-osx.md) for information about installing dependencies in general.\n-\n-## IPC implementation details\n-\n-Cross process Node, Wallet, and Chain interfaces are defined in\n-[`src/interfaces/`](../../src/interfaces/). These are C++ classes which follow\n-[conventions](../developer-notes.md#internal-interface-guidelines), like passing\n-serializable arguments so they can be called from different processes, and\n-making methods pure virtual so they can have proxy implementations that forward\n-calls between processes.\n-\n-When Wallet, Node, and Chain code is running in the same process, calling any\n-interface method invokes the implementation directly. When code is running in\n-different processes, calling an interface method invokes a proxy interface\n-implementation that communicates with a remote process and invokes the real\n-implementation in the remote process. The\n-[libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) code\n-generation tool internally generates proxy client classes and proxy server\n-classes for this purpose that are thin wrappers around Cap'n Proto\n-[client](https://capnproto.org/cxxrpc.html#clients) and\n-[server](https://capnproto.org/cxxrpc.html#servers) classes, which handle the\n-actual serialization and socket communication.\n-\n-As much as possible, calls between processes are meant to work the same as\n-calls within a single process without adding limitations or requiring extra\n-implementation effort. Processes communicate with each other by calling regular\n-[C++ interface methods](../../src/interfaces/README.md). Method arguments and\n-return values are automatically serialized and sent between processes. Object\n-references and `std::function` arguments are automatically tracked and mapped\n-to allow invoked code to call back into invoking code at any time, and there is\n-a 1:1 threading model where any thread invoking a method in another process has\n-a corresponding thread in the invoked process responsible for executing all\n-method calls from the source thread, without blocking I/O or holding up another\n-call, and using the same thread local variables, locks, and callbacks between\n-calls. The forwarding, tracking, and threading is implemented inside the\n-[libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) library\n-which has the design goal of making calls between processes look like calls in\n-the same process to the extent possible.\n+# Multiprocess Bitcoin Design Document\n+\n+Guide to the design and architecture of the Bitcoin-Core multiprocess feature\n+\n+_This document describes the design of the multiprocess feature. For usage information, see the top-level [multiprocess.md](../multiprocess.md) file._\n+\n+## Table of contents\n+\n+- [Introduction](#introduction)\n+- [Current Architecture](#current-architecture)\n+- [Proposed Architecture](#proposed-architecture)\n+- [Component Overview: Navigating the IPC Framework](#component-overview-navigating-the-ipc-framework)\n+- [Design Considerations](#design-considerations)\n+  - [Selection of Cap’n Proto](#selection-of-capn-proto)\n+  - [Hiding IPC](#hiding-ipc)\n+  - [Interface Definition Maintenance](#interface-definition-maintenance)\n+  - [Interface Stability](#interface-stability)\n+- [Example Use Cases and Flows](#example-use-cases-and-flows)\n+  - [Retrieving a Block Hash](#retrieving-a-block-hash)\n+- [Future Enhancements](#future-enhancements)\n+- [Conclusion](#conclusion)\n+- [Appendices](#appendices)\n+  - [Glossary of Terms](#glossary-of-terms)\n+  - [References](#references)\n+- [Acknowledgements](#acknowledgements)\n+\n+## Introduction\n+\n+The Bitcoin Core software, central to the Bitcoin network, has historically employed a monolithic architecture. The existing design has integrated functionality like P2P network operations, wallet management, and a GUI into a single executable. While effective, it has limitations in flexibility, security, and scalability. This project introduces changes that transition Bitcoin Core to a more modular architecture. It aims to enhance security, improve usability, and facilitate maintenance and development of the software.\n+\n+## Current Architecture\n+\n+The current system features two primary executables: `bitcoind` and `bitcoin-qt`. `bitcoind` combines a Bitcoin P2P node with an integrated JSON-RPC server, wallet, and indexes. `bitcoin-qt` extends this by incorporating a Qt-based GUI. This monolithic structure, although robust, presents challenges such as limited operational flexibility and increased security risks due to the tight integration of components.\n+\n+## Proposed Architecture\n+\n+The new architecture divides the existing code into three specialized executables:\n+\n+- `bitcoin-node`: Manages the node, indexes, and JSON-RPC server.\n+- `bitcoin-wallet`: Handles all wallet functionality.\n+- `bitcoin-gui`: Provides a standalone Qt-based GUI.\n+\n+This modular approach is designed to enhance security through component isolation and improve usability by allowing independent operation of each module. This allows for new use-cases, such as running the node on a dedicated machine and operating wallets and GUIs on separate machines with the flexibility to start and stop them as needed.\n+\n+This subdivision could be extended in the future. For example, indexes could be removed from the `bitcoin-node` executable and run in separate executables. And JSON-RPC servers could be added to wallet and index executables, so they can listen and respond to RPC requests on their own ports, without needing to forward RPC requests through `bitcoin-node`.\n+\n+## Component Overview: Navigating the IPC Framework\n+\n+This section describes the major components of the Inter-Process Communication (IPC) framework covering the relevant source files, generated files, tools, and libraries.\n+\n+### Abstract C++ Classes in [`src/interfaces/`](../../src/interfaces/)\n+- The foundation of the IPC implementation lies in the abstract C++ classes within the [`src/interfaces/`](../../src/interfaces/) directory. These classes define pure virtual methods that code in [`src/node/`](../../src/node/), [`src/wallet/`](../../src/wallet/), and [`src/qt/`](../../src/qt/) directories call to interact with each other.\n+- Each abstract class in this directory represents a distinct interface that the different modules (node, wallet, GUI) implement and use for cross-process communication.\n+- The classes are written following conventions described in [Internal Interface\n+  Guidelines](../developer-notes.md#internal-interface-guidelines) to ensure\n+  compatibility with Cap'n Proto.\n+\n+### Cap’n Proto Files in [`src/ipc/capnp/`](../../src/ipc/capnp/)\n+- Corresponding to each abstract class, there are `.capnp` files within the [`src/ipc/capnp/`](../../src/ipc/capnp/) directory. These files are used as input to the `mpgen` tool (described below) to generate C++ code.\n+- These Cap’n Proto files ([learn more about Cap'n Proto RPC](https://capnproto.org/rpc.html)) define the structure and format of messages that are exchanged over IPC. They serve as blueprints for generating C++ code that bridges the gap between high-level C++ interfaces and low-level socket communication.\n+\n+### The `mpgen` Code Generation Tool\n+- A central component of the IPC framework is the `mpgen` tool which is part the [`libmultiprocess` project](https://github.com/chaincodelabs/libmultiprocess). This tool takes the `.capnp` files as input and generates C++ code.\n+- The generated code handles IPC communication, translating interface calls into socket reads and writes.\n+\n+### C++ Client Subclasses in Generated Code\n+- In the generated code, we have C++ client subclasses that inherit from the abstract classes in [`src/interfaces/`](../../src/interfaces/). These subclasses are the workhorses of the IPC mechanism.\n+- They implement all the methods of the interface, marshalling arguments into a structured format, sending them as requests to the IPC server via a UNIX socket, and handling the responses.\n+- These subclasses effectively mask the complexity of IPC, presenting a familiar C++ interface to developers.\n+- Internally, the client subclasses generated by the `mpgen` tool wrap [client classes generated by Cap'n Proto](https://capnproto.org/cxxrpc.html#clients), and use them to send IPC requests.\n+\n+### C++ Server Classes in Generated Code\n+- On the server side, corresponding generated C++ classes receive IPC requests. These server classes are responsible for unmarshalling method arguments, invoking the corresponding methods in the local [`src/interfaces/`](../../src/interfaces/) objects, and creating the IPC response.\n+- The server classes ensure that return values (including output argument values and thrown exceptions) are marshalled and sent back to the client, completing the communication cycle.\n+- Internally, the server subclasses generated by the `mpgen` tool inherit from [server classes generated by Cap'n Proto](https://capnproto.org/cxxrpc.html#servers), and use them to process IPC requests.\n+\n+### The `libmultiprocess` Runtime Library\n+- **Core Functionality**: The `libmultiprocess` runtime library's primary function is to instantiate the generated client and server classes as needed.\n+- **Bootstrapping IPC Connections**: It provides functions for starting new IPC connections, specifically binding generated client and server classes for an initial `interfaces::Init` interface (defined in [`src/interfaces/init.h`](../../src/interfaces/init.h)) to a UNIX socket. This initial interface has methods returning other interfaces that different Bitcoin-Core modules use to communicate after the bootstrapping phase.\n+- **Asynchronous I/O and Thread Management**: The library is also responsible for managing I/O and threading. Particularly, it ensures that IPC requests never block each other and that new threads on either side of a connection can always make client calls. It also manages worker threads on the server side of calls, ensuring that calls from the same client thread always execute on the same server thread (to avoid locking issues and support nested callbacks).\n+\n+### Type Hooks in [`src/ipc/capnp/*-types.h`](../../src/ipc/capnp/)\n+- **Custom Type Conversions**: In [`src/ipc/capnp/*-types.h`](../../src/ipc/capnp/), multiple function overloads of two `libmultiprocess` C++ functions, `mp::CustomReadField` and `mp::CustomBuildFields`, are defined. These functions are used for customizing the conversion of specific C++ types to and from Cap’n Proto types.\n+- **Handling Special Cases**: The `mpgen` tool and `libmultiprocess` library can convert most C++ types to and from Cap’n Proto types automatically, including interface types, primitive C++ types, standard C++ types like `std::vector`, `std::set`, `std::map`, `std::tuple`, and `std::function`, as well as simple C++ structs that consist of afforementioned types and whose fields correspond 1:1 with Cap’n Proto struct fields. For other types, `*-types.h` files provide custom code to convert between C++ and Cap’n Proto data representations.\n+\n+### Protocol-Agnostic IPC Code in [`src/ipc/`](../../src/ipc/)\n+- **Broad Applicability**: Unlike the Cap’n Proto-specific code in [`src/ipc/capnp/`](../../src/ipc/capnp/), the code in the [`src/ipc/`](../../src/ipc/) directory is protocol-agnostic. This enables potential support for other protocols, such as gRPC or a custom protocol in the future.\n+- **Process Management and Socket Operations**: The main purpose of this component is to provide functions for spawning new processes and creating and connecting to UNIX sockets.\n+- **ipc::Exception Class**: This code also defines an `ipc::Exception` class which is thrown from the generated C++ client class methods when there is an unexpected IPC error, such as a disconnection.\n+\n+## Design Considerations\n+\n+### Selection of Cap’n Proto\n+The choice to use [Cap’n Proto](https://capnproto.org/) for IPC was primarily influenced by its support for passing object references and managing object lifetimes, which would have to be implemented manually with a framework that only supported plain requests and responses like [gRPC](https://grpc.io/). The support is especially helpful for passing callback objects like `std::function` and supporting bidirectional communication.\n+\n+The choice to use an RPC framework at all instead of a custom protocol was neccesitated by the size of Bitcoin Core internal interfaces which consist of around 150 methods that pass complex data structures and are called in complicated ways (in parallel, from callbacks that can be nested and stored). Writing a custom protocol to wrap these complicated interfaces would be too much work, akin to writing a new RPC framework.\n+\n+### Hiding IPC\n+\n+The IPC mechanism is deliberately isolated from the rest of the codebase so less code has to be concerned with IPC.\n+\n+Building Bitcoin Core with IPC support is optional, and the same code can be compiled to either run in the same process or separate processes. The build system also ensures Cap’n Proto library headers can only be used within the [`src/ipc/capnp/`](../../src/ipc/capnp/) directory, not in other parts of the codebase.\n+\n+The libmultiprocess runtime is designed to place as few constraints as possible on IPC interfaces and make IPC calls act like normal function calls. Method arguments, return values, and exceptions are automatically serialized and sent between processes. Object references and `std::function` arguments are automatically tracked and mapped to allow invoked code to call back into invoking code at any time. And there is a 1:1 threading model where any every client thread has a corresponding server thread responsible for executing incoming calls from that thread (there can be multiple calls from the same thread due to callbacks), without blocking, and holding the same thread-local variables and locks so behavior is the same whether IPC is used or not.\n+\n+### Interface Definition Maintenance\n+\n+The choice to maintain interface definitions and C++ type mappings as `.capnp` files in the [`src/ipc/capnp/`](../../src/ipc/capnp/) was mostly done for convenience, and probably something that could be improved in the future.\n+\n+In the current design, class names, method names, and parameter names are duplicated between C++ interfaces in [`src/interfaces/`](../../src/interfaces/) and Cap’n Proto files in [`src/ipc/capnp/`](../../src/ipc/capnp/). While this keeps C++ interface headers simple and free of references to IPC, it is a maintence burden because it means inconsistencies between C++ declarations and Cap’n Proto declarations will result in compile errors. (Static type checking ensures these are not runtime errors.)",
      "path": "doc/design/multiprocess.md",
      "position": null,
      "original_position": 182,
      "commit_id": "91dc48c14825a9075a57c1eefda202b83b6346ba",
      "original_commit_id": "837c53d14f24924cdcb2cfd8b18915882dc3b620",
      "in_reply_to_id": 1428165515,
      "user": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "re: https://github.com/bitcoin/bitcoin/pull/28978#discussion_r1428165515\r\n> \r\n\r\nThanks, fixed",
      "created_at": "2023-12-19T12:48:35Z",
      "updated_at": "2023-12-19T16:29:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28978#discussion_r1431361251",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1431361251"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28978"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 110,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1431361433",
      "pull_request_review_id": 1788797844,
      "id": 1431361433,
      "node_id": "PRRC_kwDOABII585VUNeZ",
      "diff_hunk": "@@ -1,72 +1,200 @@\n-# Multiprocess Bitcoin\n-\n-On unix systems, the `--enable-multiprocess` build option can be passed to `./configure` to build new `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables alongside existing `bitcoind` and `bitcoin-qt` executables.\n-\n-`bitcoin-node` is a drop-in replacement for `bitcoind`, and `bitcoin-gui` is a drop-in replacement for `bitcoin-qt`, and there are no differences in use or external behavior between the new and old executables. But internally (after [#10102](https://github.com/bitcoin/bitcoin/pull/10102)), `bitcoin-gui` will spawn a `bitcoin-node` process to run P2P and RPC code, communicating with it across a socket pair, and `bitcoin-node` will spawn `bitcoin-wallet` to run wallet code, also communicating over a socket pair. This will let node, wallet, and GUI code run in separate address spaces for better isolation, and allow future improvements like being able to start and stop components independently on different machines and environments.\n-\n-## Next steps\n-\n-Specific next steps after [#10102](https://github.com/bitcoin/bitcoin/pull/10102) will be:\n-\n-- [ ] Adding `-ipcbind` and `-ipcconnect` options to `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables so they can listen and connect to TCP ports and unix socket paths. This will allow separate processes to be started and stopped any time and connect to each other.\n-- [ ] Adding `-server` and `-rpcbind` options to the `bitcoin-wallet` executable so wallet processes can handle RPC requests directly without going through the node.\n-- [ ] Supporting windows, not just unix systems. The existing socket code is already cross-platform, so the only windows-specific code that needs to be written is code spawning a process and passing a socket descriptor. This can be implemented with `CreateProcess` and `WSADuplicateSocket`. Example: https://memset.wordpress.com/2010/10/13/win32-api-passing-socket-with-ipc-method/.\n-- [ ] Adding sandbox features, restricting subprocess access to resources and data. See [https://eklitzke.org/multiprocess-bitcoin](https://eklitzke.org/multiprocess-bitcoin).\n-\n-## Debugging\n-\n-The `-debug=ipc` command line option can be used to see requests and responses between processes.\n-\n-## Installation\n-\n-The multiprocess feature requires [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) as dependencies. A simple way to get starting using it without installing these dependencies manually is to use the [depends system](../../depends) with the `MULTIPROCESS=1` [dependency option](../../depends#dependency-options) passed to make:\n-\n-```\n-cd <BITCOIN_SOURCE_DIRECTORY>\n-make -C depends NO_QT=1 MULTIPROCESS=1\n-CONFIG_SITE=$PWD/depends/x86_64-pc-linux-gnu/share/config.site ./configure\n-make\n-src/bitcoin-node -regtest -printtoconsole -debug=ipc\n-BITCOIND=bitcoin-node test/functional/test_runner.py\n-```\n-\n-The configure script will pick up settings and library locations from the depends directory, so there is no need to pass `--enable-multiprocess` as a separate flag when using the depends system (it's controlled by the `MULTIPROCESS=1` option).\n-\n-Alternately, you can install [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) packages on your system, and just run `./configure --enable-multiprocess` without using the depends system. The configure script will be able to locate the installed packages via [pkg-config](https://www.freedesktop.org/wiki/Software/pkg-config/). See [Installation](https://github.com/chaincodelabs/libmultiprocess/blob/master/doc/install.md) section of the libmultiprocess readme for install steps. See [build-unix.md](../build-unix.md) and [build-osx.md](../build-osx.md) for information about installing dependencies in general.\n-\n-## IPC implementation details\n-\n-Cross process Node, Wallet, and Chain interfaces are defined in\n-[`src/interfaces/`](../../src/interfaces/). These are C++ classes which follow\n-[conventions](../developer-notes.md#internal-interface-guidelines), like passing\n-serializable arguments so they can be called from different processes, and\n-making methods pure virtual so they can have proxy implementations that forward\n-calls between processes.\n-\n-When Wallet, Node, and Chain code is running in the same process, calling any\n-interface method invokes the implementation directly. When code is running in\n-different processes, calling an interface method invokes a proxy interface\n-implementation that communicates with a remote process and invokes the real\n-implementation in the remote process. The\n-[libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) code\n-generation tool internally generates proxy client classes and proxy server\n-classes for this purpose that are thin wrappers around Cap'n Proto\n-[client](https://capnproto.org/cxxrpc.html#clients) and\n-[server](https://capnproto.org/cxxrpc.html#servers) classes, which handle the\n-actual serialization and socket communication.\n-\n-As much as possible, calls between processes are meant to work the same as\n-calls within a single process without adding limitations or requiring extra\n-implementation effort. Processes communicate with each other by calling regular\n-[C++ interface methods](../../src/interfaces/README.md). Method arguments and\n-return values are automatically serialized and sent between processes. Object\n-references and `std::function` arguments are automatically tracked and mapped\n-to allow invoked code to call back into invoking code at any time, and there is\n-a 1:1 threading model where any thread invoking a method in another process has\n-a corresponding thread in the invoked process responsible for executing all\n-method calls from the source thread, without blocking I/O or holding up another\n-call, and using the same thread local variables, locks, and callbacks between\n-calls. The forwarding, tracking, and threading is implemented inside the\n-[libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) library\n-which has the design goal of making calls between processes look like calls in\n-the same process to the extent possible.\n+# Multiprocess Bitcoin Design Document\n+\n+Guide to the design and architecture of the Bitcoin-Core multiprocess feature\n+\n+_This document describes the design of the multiprocess feature. For usage information, see the top-level [multiprocess.md](../multiprocess.md) file._\n+\n+## Table of contents\n+\n+- [Introduction](#introduction)\n+- [Current Architecture](#current-architecture)\n+- [Proposed Architecture](#proposed-architecture)\n+- [Component Overview: Navigating the IPC Framework](#component-overview-navigating-the-ipc-framework)\n+- [Design Considerations](#design-considerations)\n+  - [Selection of Cap’n Proto](#selection-of-capn-proto)\n+  - [Hiding IPC](#hiding-ipc)\n+  - [Interface Definition Maintenance](#interface-definition-maintenance)\n+  - [Interface Stability](#interface-stability)\n+- [Example Use Cases and Flows](#example-use-cases-and-flows)\n+  - [Retrieving a Block Hash](#retrieving-a-block-hash)\n+- [Future Enhancements](#future-enhancements)\n+- [Conclusion](#conclusion)\n+- [Appendices](#appendices)\n+  - [Glossary of Terms](#glossary-of-terms)\n+  - [References](#references)\n+- [Acknowledgements](#acknowledgements)\n+\n+## Introduction\n+\n+The Bitcoin Core software, central to the Bitcoin network, has historically employed a monolithic architecture. The existing design has integrated functionality like P2P network operations, wallet management, and a GUI into a single executable. While effective, it has limitations in flexibility, security, and scalability. This project introduces changes that transition Bitcoin Core to a more modular architecture. It aims to enhance security, improve usability, and facilitate maintenance and development of the software.\n+\n+## Current Architecture\n+\n+The current system features two primary executables: `bitcoind` and `bitcoin-qt`. `bitcoind` combines a Bitcoin P2P node with an integrated JSON-RPC server, wallet, and indexes. `bitcoin-qt` extends this by incorporating a Qt-based GUI. This monolithic structure, although robust, presents challenges such as limited operational flexibility and increased security risks due to the tight integration of components.\n+\n+## Proposed Architecture\n+\n+The new architecture divides the existing code into three specialized executables:\n+\n+- `bitcoin-node`: Manages the node, indexes, and JSON-RPC server.\n+- `bitcoin-wallet`: Handles all wallet functionality.\n+- `bitcoin-gui`: Provides a standalone Qt-based GUI.\n+\n+This modular approach is designed to enhance security through component isolation and improve usability by allowing independent operation of each module. This allows for new use-cases, such as running the node on a dedicated machine and operating wallets and GUIs on separate machines with the flexibility to start and stop them as needed.\n+\n+This subdivision could be extended in the future. For example, indexes could be removed from the `bitcoin-node` executable and run in separate executables. And JSON-RPC servers could be added to wallet and index executables, so they can listen and respond to RPC requests on their own ports, without needing to forward RPC requests through `bitcoin-node`.\n+\n+## Component Overview: Navigating the IPC Framework\n+\n+This section describes the major components of the Inter-Process Communication (IPC) framework covering the relevant source files, generated files, tools, and libraries.\n+\n+### Abstract C++ Classes in [`src/interfaces/`](../../src/interfaces/)\n+- The foundation of the IPC implementation lies in the abstract C++ classes within the [`src/interfaces/`](../../src/interfaces/) directory. These classes define pure virtual methods that code in [`src/node/`](../../src/node/), [`src/wallet/`](../../src/wallet/), and [`src/qt/`](../../src/qt/) directories call to interact with each other.\n+- Each abstract class in this directory represents a distinct interface that the different modules (node, wallet, GUI) implement and use for cross-process communication.\n+- The classes are written following conventions described in [Internal Interface\n+  Guidelines](../developer-notes.md#internal-interface-guidelines) to ensure\n+  compatibility with Cap'n Proto.\n+\n+### Cap’n Proto Files in [`src/ipc/capnp/`](../../src/ipc/capnp/)\n+- Corresponding to each abstract class, there are `.capnp` files within the [`src/ipc/capnp/`](../../src/ipc/capnp/) directory. These files are used as input to the `mpgen` tool (described below) to generate C++ code.\n+- These Cap’n Proto files ([learn more about Cap'n Proto RPC](https://capnproto.org/rpc.html)) define the structure and format of messages that are exchanged over IPC. They serve as blueprints for generating C++ code that bridges the gap between high-level C++ interfaces and low-level socket communication.\n+\n+### The `mpgen` Code Generation Tool\n+- A central component of the IPC framework is the `mpgen` tool which is part the [`libmultiprocess` project](https://github.com/chaincodelabs/libmultiprocess). This tool takes the `.capnp` files as input and generates C++ code.\n+- The generated code handles IPC communication, translating interface calls into socket reads and writes.\n+\n+### C++ Client Subclasses in Generated Code\n+- In the generated code, we have C++ client subclasses that inherit from the abstract classes in [`src/interfaces/`](../../src/interfaces/). These subclasses are the workhorses of the IPC mechanism.\n+- They implement all the methods of the interface, marshalling arguments into a structured format, sending them as requests to the IPC server via a UNIX socket, and handling the responses.\n+- These subclasses effectively mask the complexity of IPC, presenting a familiar C++ interface to developers.\n+- Internally, the client subclasses generated by the `mpgen` tool wrap [client classes generated by Cap'n Proto](https://capnproto.org/cxxrpc.html#clients), and use them to send IPC requests.\n+\n+### C++ Server Classes in Generated Code\n+- On the server side, corresponding generated C++ classes receive IPC requests. These server classes are responsible for unmarshalling method arguments, invoking the corresponding methods in the local [`src/interfaces/`](../../src/interfaces/) objects, and creating the IPC response.\n+- The server classes ensure that return values (including output argument values and thrown exceptions) are marshalled and sent back to the client, completing the communication cycle.\n+- Internally, the server subclasses generated by the `mpgen` tool inherit from [server classes generated by Cap'n Proto](https://capnproto.org/cxxrpc.html#servers), and use them to process IPC requests.\n+\n+### The `libmultiprocess` Runtime Library\n+- **Core Functionality**: The `libmultiprocess` runtime library's primary function is to instantiate the generated client and server classes as needed.\n+- **Bootstrapping IPC Connections**: It provides functions for starting new IPC connections, specifically binding generated client and server classes for an initial `interfaces::Init` interface (defined in [`src/interfaces/init.h`](../../src/interfaces/init.h)) to a UNIX socket. This initial interface has methods returning other interfaces that different Bitcoin-Core modules use to communicate after the bootstrapping phase.\n+- **Asynchronous I/O and Thread Management**: The library is also responsible for managing I/O and threading. Particularly, it ensures that IPC requests never block each other and that new threads on either side of a connection can always make client calls. It also manages worker threads on the server side of calls, ensuring that calls from the same client thread always execute on the same server thread (to avoid locking issues and support nested callbacks).\n+\n+### Type Hooks in [`src/ipc/capnp/*-types.h`](../../src/ipc/capnp/)\n+- **Custom Type Conversions**: In [`src/ipc/capnp/*-types.h`](../../src/ipc/capnp/), multiple function overloads of two `libmultiprocess` C++ functions, `mp::CustomReadField` and `mp::CustomBuildFields`, are defined. These functions are used for customizing the conversion of specific C++ types to and from Cap’n Proto types.\n+- **Handling Special Cases**: The `mpgen` tool and `libmultiprocess` library can convert most C++ types to and from Cap’n Proto types automatically, including interface types, primitive C++ types, standard C++ types like `std::vector`, `std::set`, `std::map`, `std::tuple`, and `std::function`, as well as simple C++ structs that consist of afforementioned types and whose fields correspond 1:1 with Cap’n Proto struct fields. For other types, `*-types.h` files provide custom code to convert between C++ and Cap’n Proto data representations.\n+\n+### Protocol-Agnostic IPC Code in [`src/ipc/`](../../src/ipc/)\n+- **Broad Applicability**: Unlike the Cap’n Proto-specific code in [`src/ipc/capnp/`](../../src/ipc/capnp/), the code in the [`src/ipc/`](../../src/ipc/) directory is protocol-agnostic. This enables potential support for other protocols, such as gRPC or a custom protocol in the future.\n+- **Process Management and Socket Operations**: The main purpose of this component is to provide functions for spawning new processes and creating and connecting to UNIX sockets.\n+- **ipc::Exception Class**: This code also defines an `ipc::Exception` class which is thrown from the generated C++ client class methods when there is an unexpected IPC error, such as a disconnection.\n+\n+## Design Considerations\n+\n+### Selection of Cap’n Proto\n+The choice to use [Cap’n Proto](https://capnproto.org/) for IPC was primarily influenced by its support for passing object references and managing object lifetimes, which would have to be implemented manually with a framework that only supported plain requests and responses like [gRPC](https://grpc.io/). The support is especially helpful for passing callback objects like `std::function` and supporting bidirectional communication.\n+\n+The choice to use an RPC framework at all instead of a custom protocol was neccesitated by the size of Bitcoin Core internal interfaces which consist of around 150 methods that pass complex data structures and are called in complicated ways (in parallel, from callbacks that can be nested and stored). Writing a custom protocol to wrap these complicated interfaces would be too much work, akin to writing a new RPC framework.\n+\n+### Hiding IPC\n+\n+The IPC mechanism is deliberately isolated from the rest of the codebase so less code has to be concerned with IPC.\n+\n+Building Bitcoin Core with IPC support is optional, and the same code can be compiled to either run in the same process or separate processes. The build system also ensures Cap’n Proto library headers can only be used within the [`src/ipc/capnp/`](../../src/ipc/capnp/) directory, not in other parts of the codebase.\n+\n+The libmultiprocess runtime is designed to place as few constraints as possible on IPC interfaces and make IPC calls act like normal function calls. Method arguments, return values, and exceptions are automatically serialized and sent between processes. Object references and `std::function` arguments are automatically tracked and mapped to allow invoked code to call back into invoking code at any time. And there is a 1:1 threading model where any every client thread has a corresponding server thread responsible for executing incoming calls from that thread (there can be multiple calls from the same thread due to callbacks), without blocking, and holding the same thread-local variables and locks so behavior is the same whether IPC is used or not.\n+\n+### Interface Definition Maintenance\n+\n+The choice to maintain interface definitions and C++ type mappings as `.capnp` files in the [`src/ipc/capnp/`](../../src/ipc/capnp/) was mostly done for convenience, and probably something that could be improved in the future.\n+\n+In the current design, class names, method names, and parameter names are duplicated between C++ interfaces in [`src/interfaces/`](../../src/interfaces/) and Cap’n Proto files in [`src/ipc/capnp/`](../../src/ipc/capnp/). While this keeps C++ interface headers simple and free of references to IPC, it is a maintence burden because it means inconsistencies between C++ declarations and Cap’n Proto declarations will result in compile errors. (Static type checking ensures these are not runtime errors.)\n+\n+An alternate approach could use custom [C++ Attributes](https://en.cppreference.com/w/cpp/language/attributes) embedded in interface declarations to automatically generate `.capnp` files directly from C++ headers. This has not been pursued because parsing C++ headers is more complicated than parsing Cap’n Proto interface definitions, especially portably on multiple platforms.\n+\n+### Interface Stability\n+\n+The currently defined IPC interfaces are unstable, and can change freely with no backwards compatibility. The decision to allow this stems from the recognition that our current interfaces are still evolving and not yet ideal for external use. As these interfaces mature and become more refined, there may be an opportunity to declare them stable and use Cap’n Proto's support for protocol evolution ([Cap'n Proto - Evolving Your Protocol](https://capnproto.org/language.html#evolving-your-protocol)) to allow them to be extended while remaining backwards compatible. This could allow different versions of node, GUI, and wallet binaries to interoperate, and potentially open doors for external tools to utilize these interfaces, such as creating custom indexes through a stable indexing interface. However, for now, the priority is to improve the interfaces internally. Given their current state and the advantages of using JSON-RPC for most common tasks, it's more practical to focus on internal development rather than external applicability.\n+\n+## Example Use Cases and Flows\n+\n+### Retrieving a Block Hash\n+\n+Let’s walk through an example where the `bitcoin-wallet` process requests the hash of a block at a specific height from the `bitcoin-node` process. This example demonstrates the practical application of the IPC mechanism, specifically the interplay between C++ method calls and Cap’n Proto-generated RPC calls.",
      "path": "doc/design/multiprocess.md",
      "position": 178,
      "original_position": 194,
      "commit_id": "91dc48c14825a9075a57c1eefda202b83b6346ba",
      "original_commit_id": "837c53d14f24924cdcb2cfd8b18915882dc3b620",
      "in_reply_to_id": 1428187716,
      "user": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "re: https://github.com/bitcoin/bitcoin/pull/28978#discussion_r1428187716\r\n\r\n> Maybe mention that his is based on code that is not merged yet, for example `chain.capnp` is linked below but it doesn't exist on master yet.\r\n\r\nOops, this is not good. I changed the link to point to the branch version for now since I think seeing the interface definition can be helpful.",
      "created_at": "2023-12-19T12:48:46Z",
      "updated_at": "2023-12-19T16:29:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28978#discussion_r1431361433",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1431361433"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28978"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 159,
      "original_line": 159,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1431361546",
      "pull_request_review_id": 1788797844,
      "id": 1431361546,
      "node_id": "PRRC_kwDOABII585VUNgK",
      "diff_hunk": "@@ -1,72 +1,200 @@\n-# Multiprocess Bitcoin\n-\n-On unix systems, the `--enable-multiprocess` build option can be passed to `./configure` to build new `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables alongside existing `bitcoind` and `bitcoin-qt` executables.\n-\n-`bitcoin-node` is a drop-in replacement for `bitcoind`, and `bitcoin-gui` is a drop-in replacement for `bitcoin-qt`, and there are no differences in use or external behavior between the new and old executables. But internally (after [#10102](https://github.com/bitcoin/bitcoin/pull/10102)), `bitcoin-gui` will spawn a `bitcoin-node` process to run P2P and RPC code, communicating with it across a socket pair, and `bitcoin-node` will spawn `bitcoin-wallet` to run wallet code, also communicating over a socket pair. This will let node, wallet, and GUI code run in separate address spaces for better isolation, and allow future improvements like being able to start and stop components independently on different machines and environments.\n-\n-## Next steps\n-\n-Specific next steps after [#10102](https://github.com/bitcoin/bitcoin/pull/10102) will be:\n-\n-- [ ] Adding `-ipcbind` and `-ipcconnect` options to `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables so they can listen and connect to TCP ports and unix socket paths. This will allow separate processes to be started and stopped any time and connect to each other.\n-- [ ] Adding `-server` and `-rpcbind` options to the `bitcoin-wallet` executable so wallet processes can handle RPC requests directly without going through the node.\n-- [ ] Supporting windows, not just unix systems. The existing socket code is already cross-platform, so the only windows-specific code that needs to be written is code spawning a process and passing a socket descriptor. This can be implemented with `CreateProcess` and `WSADuplicateSocket`. Example: https://memset.wordpress.com/2010/10/13/win32-api-passing-socket-with-ipc-method/.\n-- [ ] Adding sandbox features, restricting subprocess access to resources and data. See [https://eklitzke.org/multiprocess-bitcoin](https://eklitzke.org/multiprocess-bitcoin).\n-\n-## Debugging\n-\n-The `-debug=ipc` command line option can be used to see requests and responses between processes.\n-\n-## Installation\n-\n-The multiprocess feature requires [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) as dependencies. A simple way to get starting using it without installing these dependencies manually is to use the [depends system](../../depends) with the `MULTIPROCESS=1` [dependency option](../../depends#dependency-options) passed to make:\n-\n-```\n-cd <BITCOIN_SOURCE_DIRECTORY>\n-make -C depends NO_QT=1 MULTIPROCESS=1\n-CONFIG_SITE=$PWD/depends/x86_64-pc-linux-gnu/share/config.site ./configure\n-make\n-src/bitcoin-node -regtest -printtoconsole -debug=ipc\n-BITCOIND=bitcoin-node test/functional/test_runner.py\n-```\n-\n-The configure script will pick up settings and library locations from the depends directory, so there is no need to pass `--enable-multiprocess` as a separate flag when using the depends system (it's controlled by the `MULTIPROCESS=1` option).\n-\n-Alternately, you can install [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) packages on your system, and just run `./configure --enable-multiprocess` without using the depends system. The configure script will be able to locate the installed packages via [pkg-config](https://www.freedesktop.org/wiki/Software/pkg-config/). See [Installation](https://github.com/chaincodelabs/libmultiprocess/blob/master/doc/install.md) section of the libmultiprocess readme for install steps. See [build-unix.md](../build-unix.md) and [build-osx.md](../build-osx.md) for information about installing dependencies in general.\n-\n-## IPC implementation details\n-\n-Cross process Node, Wallet, and Chain interfaces are defined in\n-[`src/interfaces/`](../../src/interfaces/). These are C++ classes which follow\n-[conventions](../developer-notes.md#internal-interface-guidelines), like passing\n-serializable arguments so they can be called from different processes, and\n-making methods pure virtual so they can have proxy implementations that forward\n-calls between processes.\n-\n-When Wallet, Node, and Chain code is running in the same process, calling any\n-interface method invokes the implementation directly. When code is running in\n-different processes, calling an interface method invokes a proxy interface\n-implementation that communicates with a remote process and invokes the real\n-implementation in the remote process. The\n-[libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) code\n-generation tool internally generates proxy client classes and proxy server\n-classes for this purpose that are thin wrappers around Cap'n Proto\n-[client](https://capnproto.org/cxxrpc.html#clients) and\n-[server](https://capnproto.org/cxxrpc.html#servers) classes, which handle the\n-actual serialization and socket communication.\n-\n-As much as possible, calls between processes are meant to work the same as\n-calls within a single process without adding limitations or requiring extra\n-implementation effort. Processes communicate with each other by calling regular\n-[C++ interface methods](../../src/interfaces/README.md). Method arguments and\n-return values are automatically serialized and sent between processes. Object\n-references and `std::function` arguments are automatically tracked and mapped\n-to allow invoked code to call back into invoking code at any time, and there is\n-a 1:1 threading model where any thread invoking a method in another process has\n-a corresponding thread in the invoked process responsible for executing all\n-method calls from the source thread, without blocking I/O or holding up another\n-call, and using the same thread local variables, locks, and callbacks between\n-calls. The forwarding, tracking, and threading is implemented inside the\n-[libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) library\n-which has the design goal of making calls between processes look like calls in\n-the same process to the extent possible.\n+# Multiprocess Bitcoin Design Document\n+\n+Guide to the design and architecture of the Bitcoin-Core multiprocess feature\n+\n+_This document describes the design of the multiprocess feature. For usage information, see the top-level [multiprocess.md](../multiprocess.md) file._\n+\n+## Table of contents\n+\n+- [Introduction](#introduction)\n+- [Current Architecture](#current-architecture)\n+- [Proposed Architecture](#proposed-architecture)\n+- [Component Overview: Navigating the IPC Framework](#component-overview-navigating-the-ipc-framework)\n+- [Design Considerations](#design-considerations)\n+  - [Selection of Cap’n Proto](#selection-of-capn-proto)\n+  - [Hiding IPC](#hiding-ipc)\n+  - [Interface Definition Maintenance](#interface-definition-maintenance)\n+  - [Interface Stability](#interface-stability)\n+- [Example Use Cases and Flows](#example-use-cases-and-flows)\n+  - [Retrieving a Block Hash](#retrieving-a-block-hash)\n+- [Future Enhancements](#future-enhancements)\n+- [Conclusion](#conclusion)\n+- [Appendices](#appendices)\n+  - [Glossary of Terms](#glossary-of-terms)\n+  - [References](#references)\n+- [Acknowledgements](#acknowledgements)\n+\n+## Introduction\n+\n+The Bitcoin Core software, central to the Bitcoin network, has historically employed a monolithic architecture. The existing design has integrated functionality like P2P network operations, wallet management, and a GUI into a single executable. While effective, it has limitations in flexibility, security, and scalability. This project introduces changes that transition Bitcoin Core to a more modular architecture. It aims to enhance security, improve usability, and facilitate maintenance and development of the software.\n+\n+## Current Architecture\n+\n+The current system features two primary executables: `bitcoind` and `bitcoin-qt`. `bitcoind` combines a Bitcoin P2P node with an integrated JSON-RPC server, wallet, and indexes. `bitcoin-qt` extends this by incorporating a Qt-based GUI. This monolithic structure, although robust, presents challenges such as limited operational flexibility and increased security risks due to the tight integration of components.\n+\n+## Proposed Architecture\n+\n+The new architecture divides the existing code into three specialized executables:\n+\n+- `bitcoin-node`: Manages the node, indexes, and JSON-RPC server.\n+- `bitcoin-wallet`: Handles all wallet functionality.\n+- `bitcoin-gui`: Provides a standalone Qt-based GUI.\n+\n+This modular approach is designed to enhance security through component isolation and improve usability by allowing independent operation of each module. This allows for new use-cases, such as running the node on a dedicated machine and operating wallets and GUIs on separate machines with the flexibility to start and stop them as needed.\n+\n+This subdivision could be extended in the future. For example, indexes could be removed from the `bitcoin-node` executable and run in separate executables. And JSON-RPC servers could be added to wallet and index executables, so they can listen and respond to RPC requests on their own ports, without needing to forward RPC requests through `bitcoin-node`.\n+\n+## Component Overview: Navigating the IPC Framework\n+\n+This section describes the major components of the Inter-Process Communication (IPC) framework covering the relevant source files, generated files, tools, and libraries.\n+\n+### Abstract C++ Classes in [`src/interfaces/`](../../src/interfaces/)\n+- The foundation of the IPC implementation lies in the abstract C++ classes within the [`src/interfaces/`](../../src/interfaces/) directory. These classes define pure virtual methods that code in [`src/node/`](../../src/node/), [`src/wallet/`](../../src/wallet/), and [`src/qt/`](../../src/qt/) directories call to interact with each other.\n+- Each abstract class in this directory represents a distinct interface that the different modules (node, wallet, GUI) implement and use for cross-process communication.\n+- The classes are written following conventions described in [Internal Interface\n+  Guidelines](../developer-notes.md#internal-interface-guidelines) to ensure\n+  compatibility with Cap'n Proto.\n+\n+### Cap’n Proto Files in [`src/ipc/capnp/`](../../src/ipc/capnp/)\n+- Corresponding to each abstract class, there are `.capnp` files within the [`src/ipc/capnp/`](../../src/ipc/capnp/) directory. These files are used as input to the `mpgen` tool (described below) to generate C++ code.\n+- These Cap’n Proto files ([learn more about Cap'n Proto RPC](https://capnproto.org/rpc.html)) define the structure and format of messages that are exchanged over IPC. They serve as blueprints for generating C++ code that bridges the gap between high-level C++ interfaces and low-level socket communication.\n+\n+### The `mpgen` Code Generation Tool\n+- A central component of the IPC framework is the `mpgen` tool which is part the [`libmultiprocess` project](https://github.com/chaincodelabs/libmultiprocess). This tool takes the `.capnp` files as input and generates C++ code.\n+- The generated code handles IPC communication, translating interface calls into socket reads and writes.\n+\n+### C++ Client Subclasses in Generated Code\n+- In the generated code, we have C++ client subclasses that inherit from the abstract classes in [`src/interfaces/`](../../src/interfaces/). These subclasses are the workhorses of the IPC mechanism.\n+- They implement all the methods of the interface, marshalling arguments into a structured format, sending them as requests to the IPC server via a UNIX socket, and handling the responses.\n+- These subclasses effectively mask the complexity of IPC, presenting a familiar C++ interface to developers.\n+- Internally, the client subclasses generated by the `mpgen` tool wrap [client classes generated by Cap'n Proto](https://capnproto.org/cxxrpc.html#clients), and use them to send IPC requests.\n+\n+### C++ Server Classes in Generated Code\n+- On the server side, corresponding generated C++ classes receive IPC requests. These server classes are responsible for unmarshalling method arguments, invoking the corresponding methods in the local [`src/interfaces/`](../../src/interfaces/) objects, and creating the IPC response.\n+- The server classes ensure that return values (including output argument values and thrown exceptions) are marshalled and sent back to the client, completing the communication cycle.\n+- Internally, the server subclasses generated by the `mpgen` tool inherit from [server classes generated by Cap'n Proto](https://capnproto.org/cxxrpc.html#servers), and use them to process IPC requests.\n+\n+### The `libmultiprocess` Runtime Library\n+- **Core Functionality**: The `libmultiprocess` runtime library's primary function is to instantiate the generated client and server classes as needed.\n+- **Bootstrapping IPC Connections**: It provides functions for starting new IPC connections, specifically binding generated client and server classes for an initial `interfaces::Init` interface (defined in [`src/interfaces/init.h`](../../src/interfaces/init.h)) to a UNIX socket. This initial interface has methods returning other interfaces that different Bitcoin-Core modules use to communicate after the bootstrapping phase.\n+- **Asynchronous I/O and Thread Management**: The library is also responsible for managing I/O and threading. Particularly, it ensures that IPC requests never block each other and that new threads on either side of a connection can always make client calls. It also manages worker threads on the server side of calls, ensuring that calls from the same client thread always execute on the same server thread (to avoid locking issues and support nested callbacks).\n+\n+### Type Hooks in [`src/ipc/capnp/*-types.h`](../../src/ipc/capnp/)\n+- **Custom Type Conversions**: In [`src/ipc/capnp/*-types.h`](../../src/ipc/capnp/), multiple function overloads of two `libmultiprocess` C++ functions, `mp::CustomReadField` and `mp::CustomBuildFields`, are defined. These functions are used for customizing the conversion of specific C++ types to and from Cap’n Proto types.\n+- **Handling Special Cases**: The `mpgen` tool and `libmultiprocess` library can convert most C++ types to and from Cap’n Proto types automatically, including interface types, primitive C++ types, standard C++ types like `std::vector`, `std::set`, `std::map`, `std::tuple`, and `std::function`, as well as simple C++ structs that consist of afforementioned types and whose fields correspond 1:1 with Cap’n Proto struct fields. For other types, `*-types.h` files provide custom code to convert between C++ and Cap’n Proto data representations.\n+\n+### Protocol-Agnostic IPC Code in [`src/ipc/`](../../src/ipc/)\n+- **Broad Applicability**: Unlike the Cap’n Proto-specific code in [`src/ipc/capnp/`](../../src/ipc/capnp/), the code in the [`src/ipc/`](../../src/ipc/) directory is protocol-agnostic. This enables potential support for other protocols, such as gRPC or a custom protocol in the future.\n+- **Process Management and Socket Operations**: The main purpose of this component is to provide functions for spawning new processes and creating and connecting to UNIX sockets.\n+- **ipc::Exception Class**: This code also defines an `ipc::Exception` class which is thrown from the generated C++ client class methods when there is an unexpected IPC error, such as a disconnection.\n+\n+## Design Considerations\n+\n+### Selection of Cap’n Proto\n+The choice to use [Cap’n Proto](https://capnproto.org/) for IPC was primarily influenced by its support for passing object references and managing object lifetimes, which would have to be implemented manually with a framework that only supported plain requests and responses like [gRPC](https://grpc.io/). The support is especially helpful for passing callback objects like `std::function` and supporting bidirectional communication.\n+\n+The choice to use an RPC framework at all instead of a custom protocol was neccesitated by the size of Bitcoin Core internal interfaces which consist of around 150 methods that pass complex data structures and are called in complicated ways (in parallel, from callbacks that can be nested and stored). Writing a custom protocol to wrap these complicated interfaces would be too much work, akin to writing a new RPC framework.\n+\n+### Hiding IPC\n+\n+The IPC mechanism is deliberately isolated from the rest of the codebase so less code has to be concerned with IPC.\n+\n+Building Bitcoin Core with IPC support is optional, and the same code can be compiled to either run in the same process or separate processes. The build system also ensures Cap’n Proto library headers can only be used within the [`src/ipc/capnp/`](../../src/ipc/capnp/) directory, not in other parts of the codebase.\n+\n+The libmultiprocess runtime is designed to place as few constraints as possible on IPC interfaces and make IPC calls act like normal function calls. Method arguments, return values, and exceptions are automatically serialized and sent between processes. Object references and `std::function` arguments are automatically tracked and mapped to allow invoked code to call back into invoking code at any time. And there is a 1:1 threading model where any every client thread has a corresponding server thread responsible for executing incoming calls from that thread (there can be multiple calls from the same thread due to callbacks), without blocking, and holding the same thread-local variables and locks so behavior is the same whether IPC is used or not.\n+\n+### Interface Definition Maintenance\n+\n+The choice to maintain interface definitions and C++ type mappings as `.capnp` files in the [`src/ipc/capnp/`](../../src/ipc/capnp/) was mostly done for convenience, and probably something that could be improved in the future.\n+\n+In the current design, class names, method names, and parameter names are duplicated between C++ interfaces in [`src/interfaces/`](../../src/interfaces/) and Cap’n Proto files in [`src/ipc/capnp/`](../../src/ipc/capnp/). While this keeps C++ interface headers simple and free of references to IPC, it is a maintence burden because it means inconsistencies between C++ declarations and Cap’n Proto declarations will result in compile errors. (Static type checking ensures these are not runtime errors.)\n+\n+An alternate approach could use custom [C++ Attributes](https://en.cppreference.com/w/cpp/language/attributes) embedded in interface declarations to automatically generate `.capnp` files directly from C++ headers. This has not been pursued because parsing C++ headers is more complicated than parsing Cap’n Proto interface definitions, especially portably on multiple platforms.\n+\n+### Interface Stability\n+\n+The currently defined IPC interfaces are unstable, and can change freely with no backwards compatibility. The decision to allow this stems from the recognition that our current interfaces are still evolving and not yet ideal for external use. As these interfaces mature and become more refined, there may be an opportunity to declare them stable and use Cap’n Proto's support for protocol evolution ([Cap'n Proto - Evolving Your Protocol](https://capnproto.org/language.html#evolving-your-protocol)) to allow them to be extended while remaining backwards compatible. This could allow different versions of node, GUI, and wallet binaries to interoperate, and potentially open doors for external tools to utilize these interfaces, such as creating custom indexes through a stable indexing interface. However, for now, the priority is to improve the interfaces internally. Given their current state and the advantages of using JSON-RPC for most common tasks, it's more practical to focus on internal development rather than external applicability.\n+\n+## Example Use Cases and Flows\n+\n+### Retrieving a Block Hash\n+\n+Let’s walk through an example where the `bitcoin-wallet` process requests the hash of a block at a specific height from the `bitcoin-node` process. This example demonstrates the practical application of the IPC mechanism, specifically the interplay between C++ method calls and Cap’n Proto-generated RPC calls.\n+\n+1. **Initiation in bitcoin-wallet**\n+   - The wallet process calls the `getBlockHash` method on a `Chain` object. This method is defined as a virtual function in [`src/interfaces/chain.h`](../../src/interfaces/chain.h).\n+\n+2. **Translation to Cap’n Proto RPC**\n+   - The call to `getBlockHash` is translated into a Cap’n Proto RPC call. This translation is handled by code automatically generated by the `mpgen` tool, based on the [`chain.capnp`](../../src/ipc/capnp/chain.capnp)` file in [`src/ipc/capnp/`](../../src/ipc/capnp/).",
      "path": "doc/design/multiprocess.md",
      "position": null,
      "original_position": 200,
      "commit_id": "91dc48c14825a9075a57c1eefda202b83b6346ba",
      "original_commit_id": "837c53d14f24924cdcb2cfd8b18915882dc3b620",
      "in_reply_to_id": 1424249827,
      "user": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "re: https://github.com/bitcoin/bitcoin/pull/28978#discussion_r1424249827\r\n\r\n> nit: rogue backtick\r\n\r\nThanks, fixed",
      "created_at": "2023-12-19T12:48:52Z",
      "updated_at": "2023-12-19T16:29:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28978#discussion_r1431361546",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1431361546"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28978"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 128,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1431361667",
      "pull_request_review_id": 1788797844,
      "id": 1431361667,
      "node_id": "PRRC_kwDOABII585VUNiD",
      "diff_hunk": "@@ -1,72 +1,200 @@\n-# Multiprocess Bitcoin\n-\n-On unix systems, the `--enable-multiprocess` build option can be passed to `./configure` to build new `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables alongside existing `bitcoind` and `bitcoin-qt` executables.\n-\n-`bitcoin-node` is a drop-in replacement for `bitcoind`, and `bitcoin-gui` is a drop-in replacement for `bitcoin-qt`, and there are no differences in use or external behavior between the new and old executables. But internally (after [#10102](https://github.com/bitcoin/bitcoin/pull/10102)), `bitcoin-gui` will spawn a `bitcoin-node` process to run P2P and RPC code, communicating with it across a socket pair, and `bitcoin-node` will spawn `bitcoin-wallet` to run wallet code, also communicating over a socket pair. This will let node, wallet, and GUI code run in separate address spaces for better isolation, and allow future improvements like being able to start and stop components independently on different machines and environments.\n-\n-## Next steps\n-\n-Specific next steps after [#10102](https://github.com/bitcoin/bitcoin/pull/10102) will be:\n-\n-- [ ] Adding `-ipcbind` and `-ipcconnect` options to `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables so they can listen and connect to TCP ports and unix socket paths. This will allow separate processes to be started and stopped any time and connect to each other.\n-- [ ] Adding `-server` and `-rpcbind` options to the `bitcoin-wallet` executable so wallet processes can handle RPC requests directly without going through the node.\n-- [ ] Supporting windows, not just unix systems. The existing socket code is already cross-platform, so the only windows-specific code that needs to be written is code spawning a process and passing a socket descriptor. This can be implemented with `CreateProcess` and `WSADuplicateSocket`. Example: https://memset.wordpress.com/2010/10/13/win32-api-passing-socket-with-ipc-method/.\n-- [ ] Adding sandbox features, restricting subprocess access to resources and data. See [https://eklitzke.org/multiprocess-bitcoin](https://eklitzke.org/multiprocess-bitcoin).\n-\n-## Debugging\n-\n-The `-debug=ipc` command line option can be used to see requests and responses between processes.\n-\n-## Installation\n-\n-The multiprocess feature requires [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) as dependencies. A simple way to get starting using it without installing these dependencies manually is to use the [depends system](../../depends) with the `MULTIPROCESS=1` [dependency option](../../depends#dependency-options) passed to make:\n-\n-```\n-cd <BITCOIN_SOURCE_DIRECTORY>\n-make -C depends NO_QT=1 MULTIPROCESS=1\n-CONFIG_SITE=$PWD/depends/x86_64-pc-linux-gnu/share/config.site ./configure\n-make\n-src/bitcoin-node -regtest -printtoconsole -debug=ipc\n-BITCOIND=bitcoin-node test/functional/test_runner.py\n-```\n-\n-The configure script will pick up settings and library locations from the depends directory, so there is no need to pass `--enable-multiprocess` as a separate flag when using the depends system (it's controlled by the `MULTIPROCESS=1` option).\n-\n-Alternately, you can install [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) packages on your system, and just run `./configure --enable-multiprocess` without using the depends system. The configure script will be able to locate the installed packages via [pkg-config](https://www.freedesktop.org/wiki/Software/pkg-config/). See [Installation](https://github.com/chaincodelabs/libmultiprocess/blob/master/doc/install.md) section of the libmultiprocess readme for install steps. See [build-unix.md](../build-unix.md) and [build-osx.md](../build-osx.md) for information about installing dependencies in general.\n-\n-## IPC implementation details\n-\n-Cross process Node, Wallet, and Chain interfaces are defined in\n-[`src/interfaces/`](../../src/interfaces/). These are C++ classes which follow\n-[conventions](../developer-notes.md#internal-interface-guidelines), like passing\n-serializable arguments so they can be called from different processes, and\n-making methods pure virtual so they can have proxy implementations that forward\n-calls between processes.\n-\n-When Wallet, Node, and Chain code is running in the same process, calling any\n-interface method invokes the implementation directly. When code is running in\n-different processes, calling an interface method invokes a proxy interface\n-implementation that communicates with a remote process and invokes the real\n-implementation in the remote process. The\n-[libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) code\n-generation tool internally generates proxy client classes and proxy server\n-classes for this purpose that are thin wrappers around Cap'n Proto\n-[client](https://capnproto.org/cxxrpc.html#clients) and\n-[server](https://capnproto.org/cxxrpc.html#servers) classes, which handle the\n-actual serialization and socket communication.\n-\n-As much as possible, calls between processes are meant to work the same as\n-calls within a single process without adding limitations or requiring extra\n-implementation effort. Processes communicate with each other by calling regular\n-[C++ interface methods](../../src/interfaces/README.md). Method arguments and\n-return values are automatically serialized and sent between processes. Object\n-references and `std::function` arguments are automatically tracked and mapped\n-to allow invoked code to call back into invoking code at any time, and there is\n-a 1:1 threading model where any thread invoking a method in another process has\n-a corresponding thread in the invoked process responsible for executing all\n-method calls from the source thread, without blocking I/O or holding up another\n-call, and using the same thread local variables, locks, and callbacks between\n-calls. The forwarding, tracking, and threading is implemented inside the\n-[libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) library\n-which has the design goal of making calls between processes look like calls in\n-the same process to the extent possible.\n+# Multiprocess Bitcoin Design Document\n+\n+Guide to the design and architecture of the Bitcoin-Core multiprocess feature\n+\n+_This document describes the design of the multiprocess feature. For usage information, see the top-level [multiprocess.md](../multiprocess.md) file._\n+\n+## Table of contents\n+\n+- [Introduction](#introduction)\n+- [Current Architecture](#current-architecture)\n+- [Proposed Architecture](#proposed-architecture)\n+- [Component Overview: Navigating the IPC Framework](#component-overview-navigating-the-ipc-framework)\n+- [Design Considerations](#design-considerations)\n+  - [Selection of Cap’n Proto](#selection-of-capn-proto)\n+  - [Hiding IPC](#hiding-ipc)\n+  - [Interface Definition Maintenance](#interface-definition-maintenance)\n+  - [Interface Stability](#interface-stability)\n+- [Example Use Cases and Flows](#example-use-cases-and-flows)\n+  - [Retrieving a Block Hash](#retrieving-a-block-hash)\n+- [Future Enhancements](#future-enhancements)\n+- [Conclusion](#conclusion)\n+- [Appendices](#appendices)\n+  - [Glossary of Terms](#glossary-of-terms)\n+  - [References](#references)\n+- [Acknowledgements](#acknowledgements)\n+\n+## Introduction\n+\n+The Bitcoin Core software, central to the Bitcoin network, has historically employed a monolithic architecture. The existing design has integrated functionality like P2P network operations, wallet management, and a GUI into a single executable. While effective, it has limitations in flexibility, security, and scalability. This project introduces changes that transition Bitcoin Core to a more modular architecture. It aims to enhance security, improve usability, and facilitate maintenance and development of the software.\n+\n+## Current Architecture\n+\n+The current system features two primary executables: `bitcoind` and `bitcoin-qt`. `bitcoind` combines a Bitcoin P2P node with an integrated JSON-RPC server, wallet, and indexes. `bitcoin-qt` extends this by incorporating a Qt-based GUI. This monolithic structure, although robust, presents challenges such as limited operational flexibility and increased security risks due to the tight integration of components.\n+\n+## Proposed Architecture\n+\n+The new architecture divides the existing code into three specialized executables:\n+\n+- `bitcoin-node`: Manages the node, indexes, and JSON-RPC server.\n+- `bitcoin-wallet`: Handles all wallet functionality.\n+- `bitcoin-gui`: Provides a standalone Qt-based GUI.\n+\n+This modular approach is designed to enhance security through component isolation and improve usability by allowing independent operation of each module. This allows for new use-cases, such as running the node on a dedicated machine and operating wallets and GUIs on separate machines with the flexibility to start and stop them as needed.\n+\n+This subdivision could be extended in the future. For example, indexes could be removed from the `bitcoin-node` executable and run in separate executables. And JSON-RPC servers could be added to wallet and index executables, so they can listen and respond to RPC requests on their own ports, without needing to forward RPC requests through `bitcoin-node`.\n+\n+## Component Overview: Navigating the IPC Framework\n+\n+This section describes the major components of the Inter-Process Communication (IPC) framework covering the relevant source files, generated files, tools, and libraries.\n+\n+### Abstract C++ Classes in [`src/interfaces/`](../../src/interfaces/)\n+- The foundation of the IPC implementation lies in the abstract C++ classes within the [`src/interfaces/`](../../src/interfaces/) directory. These classes define pure virtual methods that code in [`src/node/`](../../src/node/), [`src/wallet/`](../../src/wallet/), and [`src/qt/`](../../src/qt/) directories call to interact with each other.\n+- Each abstract class in this directory represents a distinct interface that the different modules (node, wallet, GUI) implement and use for cross-process communication.\n+- The classes are written following conventions described in [Internal Interface\n+  Guidelines](../developer-notes.md#internal-interface-guidelines) to ensure\n+  compatibility with Cap'n Proto.\n+\n+### Cap’n Proto Files in [`src/ipc/capnp/`](../../src/ipc/capnp/)\n+- Corresponding to each abstract class, there are `.capnp` files within the [`src/ipc/capnp/`](../../src/ipc/capnp/) directory. These files are used as input to the `mpgen` tool (described below) to generate C++ code.\n+- These Cap’n Proto files ([learn more about Cap'n Proto RPC](https://capnproto.org/rpc.html)) define the structure and format of messages that are exchanged over IPC. They serve as blueprints for generating C++ code that bridges the gap between high-level C++ interfaces and low-level socket communication.\n+\n+### The `mpgen` Code Generation Tool\n+- A central component of the IPC framework is the `mpgen` tool which is part the [`libmultiprocess` project](https://github.com/chaincodelabs/libmultiprocess). This tool takes the `.capnp` files as input and generates C++ code.\n+- The generated code handles IPC communication, translating interface calls into socket reads and writes.\n+\n+### C++ Client Subclasses in Generated Code\n+- In the generated code, we have C++ client subclasses that inherit from the abstract classes in [`src/interfaces/`](../../src/interfaces/). These subclasses are the workhorses of the IPC mechanism.\n+- They implement all the methods of the interface, marshalling arguments into a structured format, sending them as requests to the IPC server via a UNIX socket, and handling the responses.\n+- These subclasses effectively mask the complexity of IPC, presenting a familiar C++ interface to developers.\n+- Internally, the client subclasses generated by the `mpgen` tool wrap [client classes generated by Cap'n Proto](https://capnproto.org/cxxrpc.html#clients), and use them to send IPC requests.\n+\n+### C++ Server Classes in Generated Code\n+- On the server side, corresponding generated C++ classes receive IPC requests. These server classes are responsible for unmarshalling method arguments, invoking the corresponding methods in the local [`src/interfaces/`](../../src/interfaces/) objects, and creating the IPC response.\n+- The server classes ensure that return values (including output argument values and thrown exceptions) are marshalled and sent back to the client, completing the communication cycle.\n+- Internally, the server subclasses generated by the `mpgen` tool inherit from [server classes generated by Cap'n Proto](https://capnproto.org/cxxrpc.html#servers), and use them to process IPC requests.\n+\n+### The `libmultiprocess` Runtime Library\n+- **Core Functionality**: The `libmultiprocess` runtime library's primary function is to instantiate the generated client and server classes as needed.\n+- **Bootstrapping IPC Connections**: It provides functions for starting new IPC connections, specifically binding generated client and server classes for an initial `interfaces::Init` interface (defined in [`src/interfaces/init.h`](../../src/interfaces/init.h)) to a UNIX socket. This initial interface has methods returning other interfaces that different Bitcoin-Core modules use to communicate after the bootstrapping phase.\n+- **Asynchronous I/O and Thread Management**: The library is also responsible for managing I/O and threading. Particularly, it ensures that IPC requests never block each other and that new threads on either side of a connection can always make client calls. It also manages worker threads on the server side of calls, ensuring that calls from the same client thread always execute on the same server thread (to avoid locking issues and support nested callbacks).\n+\n+### Type Hooks in [`src/ipc/capnp/*-types.h`](../../src/ipc/capnp/)\n+- **Custom Type Conversions**: In [`src/ipc/capnp/*-types.h`](../../src/ipc/capnp/), multiple function overloads of two `libmultiprocess` C++ functions, `mp::CustomReadField` and `mp::CustomBuildFields`, are defined. These functions are used for customizing the conversion of specific C++ types to and from Cap’n Proto types.\n+- **Handling Special Cases**: The `mpgen` tool and `libmultiprocess` library can convert most C++ types to and from Cap’n Proto types automatically, including interface types, primitive C++ types, standard C++ types like `std::vector`, `std::set`, `std::map`, `std::tuple`, and `std::function`, as well as simple C++ structs that consist of afforementioned types and whose fields correspond 1:1 with Cap’n Proto struct fields. For other types, `*-types.h` files provide custom code to convert between C++ and Cap’n Proto data representations.\n+\n+### Protocol-Agnostic IPC Code in [`src/ipc/`](../../src/ipc/)\n+- **Broad Applicability**: Unlike the Cap’n Proto-specific code in [`src/ipc/capnp/`](../../src/ipc/capnp/), the code in the [`src/ipc/`](../../src/ipc/) directory is protocol-agnostic. This enables potential support for other protocols, such as gRPC or a custom protocol in the future.\n+- **Process Management and Socket Operations**: The main purpose of this component is to provide functions for spawning new processes and creating and connecting to UNIX sockets.\n+- **ipc::Exception Class**: This code also defines an `ipc::Exception` class which is thrown from the generated C++ client class methods when there is an unexpected IPC error, such as a disconnection.\n+\n+## Design Considerations\n+\n+### Selection of Cap’n Proto\n+The choice to use [Cap’n Proto](https://capnproto.org/) for IPC was primarily influenced by its support for passing object references and managing object lifetimes, which would have to be implemented manually with a framework that only supported plain requests and responses like [gRPC](https://grpc.io/). The support is especially helpful for passing callback objects like `std::function` and supporting bidirectional communication.\n+\n+The choice to use an RPC framework at all instead of a custom protocol was neccesitated by the size of Bitcoin Core internal interfaces which consist of around 150 methods that pass complex data structures and are called in complicated ways (in parallel, from callbacks that can be nested and stored). Writing a custom protocol to wrap these complicated interfaces would be too much work, akin to writing a new RPC framework.\n+\n+### Hiding IPC\n+\n+The IPC mechanism is deliberately isolated from the rest of the codebase so less code has to be concerned with IPC.\n+\n+Building Bitcoin Core with IPC support is optional, and the same code can be compiled to either run in the same process or separate processes. The build system also ensures Cap’n Proto library headers can only be used within the [`src/ipc/capnp/`](../../src/ipc/capnp/) directory, not in other parts of the codebase.\n+\n+The libmultiprocess runtime is designed to place as few constraints as possible on IPC interfaces and make IPC calls act like normal function calls. Method arguments, return values, and exceptions are automatically serialized and sent between processes. Object references and `std::function` arguments are automatically tracked and mapped to allow invoked code to call back into invoking code at any time. And there is a 1:1 threading model where any every client thread has a corresponding server thread responsible for executing incoming calls from that thread (there can be multiple calls from the same thread due to callbacks), without blocking, and holding the same thread-local variables and locks so behavior is the same whether IPC is used or not.\n+\n+### Interface Definition Maintenance\n+\n+The choice to maintain interface definitions and C++ type mappings as `.capnp` files in the [`src/ipc/capnp/`](../../src/ipc/capnp/) was mostly done for convenience, and probably something that could be improved in the future.\n+\n+In the current design, class names, method names, and parameter names are duplicated between C++ interfaces in [`src/interfaces/`](../../src/interfaces/) and Cap’n Proto files in [`src/ipc/capnp/`](../../src/ipc/capnp/). While this keeps C++ interface headers simple and free of references to IPC, it is a maintence burden because it means inconsistencies between C++ declarations and Cap’n Proto declarations will result in compile errors. (Static type checking ensures these are not runtime errors.)\n+\n+An alternate approach could use custom [C++ Attributes](https://en.cppreference.com/w/cpp/language/attributes) embedded in interface declarations to automatically generate `.capnp` files directly from C++ headers. This has not been pursued because parsing C++ headers is more complicated than parsing Cap’n Proto interface definitions, especially portably on multiple platforms.\n+\n+### Interface Stability\n+\n+The currently defined IPC interfaces are unstable, and can change freely with no backwards compatibility. The decision to allow this stems from the recognition that our current interfaces are still evolving and not yet ideal for external use. As these interfaces mature and become more refined, there may be an opportunity to declare them stable and use Cap’n Proto's support for protocol evolution ([Cap'n Proto - Evolving Your Protocol](https://capnproto.org/language.html#evolving-your-protocol)) to allow them to be extended while remaining backwards compatible. This could allow different versions of node, GUI, and wallet binaries to interoperate, and potentially open doors for external tools to utilize these interfaces, such as creating custom indexes through a stable indexing interface. However, for now, the priority is to improve the interfaces internally. Given their current state and the advantages of using JSON-RPC for most common tasks, it's more practical to focus on internal development rather than external applicability.\n+\n+## Example Use Cases and Flows\n+\n+### Retrieving a Block Hash\n+\n+Let’s walk through an example where the `bitcoin-wallet` process requests the hash of a block at a specific height from the `bitcoin-node` process. This example demonstrates the practical application of the IPC mechanism, specifically the interplay between C++ method calls and Cap’n Proto-generated RPC calls.\n+\n+1. **Initiation in bitcoin-wallet**\n+   - The wallet process calls the `getBlockHash` method on a `Chain` object. This method is defined as a virtual function in [`src/interfaces/chain.h`](../../src/interfaces/chain.h).\n+\n+2. **Translation to Cap’n Proto RPC**\n+   - The call to `getBlockHash` is translated into a Cap’n Proto RPC call. This translation is handled by code automatically generated by the `mpgen` tool, based on the [`chain.capnp`](../../src/ipc/capnp/chain.capnp)` file in [`src/ipc/capnp/`](../../src/ipc/capnp/).\n+\n+3. **Request Preparation and Dispatch**\n+   - The generated `Chain` subclass in `bitcoin-wallet` populates a Cap’n Proto request with the `height` parameter.\n+   - The request is sent to the `bitcoin-node` process.\n+\n+4. **Handling in bitcoin-node**\n+   - Upon receiving the request, the `bitcoin-node` process reads the `height` value from the request.\n+   - It then calls the `getBlockHash` method on its local `Chain` object with the provided `height`.",
      "path": "doc/design/multiprocess.md",
      "position": null,
      "original_position": 208,
      "commit_id": "91dc48c14825a9075a57c1eefda202b83b6346ba",
      "original_commit_id": "837c53d14f24924cdcb2cfd8b18915882dc3b620",
      "in_reply_to_id": 1424253642,
      "user": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "re: https://github.com/bitcoin/bitcoin/pull/28978#discussion_r1424253642\r\n\r\n> Steps 2 and 3 highlight what's handled by generated code, for consistency that might be helpful in steps 4&5 too?\r\n\r\nThanks, added more details to this section so it now mentions the generated client and server classes and references the generated code consistently.",
      "created_at": "2023-12-19T12:48:57Z",
      "updated_at": "2023-12-19T16:29:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28978#discussion_r1431361667",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1431361667"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28978"
        }
      },
      "start_line": null,
      "original_start_line": 135,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 136,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1431361778",
      "pull_request_review_id": 1788797844,
      "id": 1431361778,
      "node_id": "PRRC_kwDOABII585VUNjy",
      "diff_hunk": "@@ -1,72 +1,200 @@\n-# Multiprocess Bitcoin\n-\n-On unix systems, the `--enable-multiprocess` build option can be passed to `./configure` to build new `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables alongside existing `bitcoind` and `bitcoin-qt` executables.\n-\n-`bitcoin-node` is a drop-in replacement for `bitcoind`, and `bitcoin-gui` is a drop-in replacement for `bitcoin-qt`, and there are no differences in use or external behavior between the new and old executables. But internally (after [#10102](https://github.com/bitcoin/bitcoin/pull/10102)), `bitcoin-gui` will spawn a `bitcoin-node` process to run P2P and RPC code, communicating with it across a socket pair, and `bitcoin-node` will spawn `bitcoin-wallet` to run wallet code, also communicating over a socket pair. This will let node, wallet, and GUI code run in separate address spaces for better isolation, and allow future improvements like being able to start and stop components independently on different machines and environments.\n-\n-## Next steps\n-\n-Specific next steps after [#10102](https://github.com/bitcoin/bitcoin/pull/10102) will be:\n-\n-- [ ] Adding `-ipcbind` and `-ipcconnect` options to `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables so they can listen and connect to TCP ports and unix socket paths. This will allow separate processes to be started and stopped any time and connect to each other.\n-- [ ] Adding `-server` and `-rpcbind` options to the `bitcoin-wallet` executable so wallet processes can handle RPC requests directly without going through the node.\n-- [ ] Supporting windows, not just unix systems. The existing socket code is already cross-platform, so the only windows-specific code that needs to be written is code spawning a process and passing a socket descriptor. This can be implemented with `CreateProcess` and `WSADuplicateSocket`. Example: https://memset.wordpress.com/2010/10/13/win32-api-passing-socket-with-ipc-method/.\n-- [ ] Adding sandbox features, restricting subprocess access to resources and data. See [https://eklitzke.org/multiprocess-bitcoin](https://eklitzke.org/multiprocess-bitcoin).\n-\n-## Debugging\n-\n-The `-debug=ipc` command line option can be used to see requests and responses between processes.\n-\n-## Installation\n-\n-The multiprocess feature requires [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) as dependencies. A simple way to get starting using it without installing these dependencies manually is to use the [depends system](../../depends) with the `MULTIPROCESS=1` [dependency option](../../depends#dependency-options) passed to make:\n-\n-```\n-cd <BITCOIN_SOURCE_DIRECTORY>\n-make -C depends NO_QT=1 MULTIPROCESS=1\n-CONFIG_SITE=$PWD/depends/x86_64-pc-linux-gnu/share/config.site ./configure\n-make\n-src/bitcoin-node -regtest -printtoconsole -debug=ipc\n-BITCOIND=bitcoin-node test/functional/test_runner.py\n-```\n-\n-The configure script will pick up settings and library locations from the depends directory, so there is no need to pass `--enable-multiprocess` as a separate flag when using the depends system (it's controlled by the `MULTIPROCESS=1` option).\n-\n-Alternately, you can install [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) packages on your system, and just run `./configure --enable-multiprocess` without using the depends system. The configure script will be able to locate the installed packages via [pkg-config](https://www.freedesktop.org/wiki/Software/pkg-config/). See [Installation](https://github.com/chaincodelabs/libmultiprocess/blob/master/doc/install.md) section of the libmultiprocess readme for install steps. See [build-unix.md](../build-unix.md) and [build-osx.md](../build-osx.md) for information about installing dependencies in general.\n-\n-## IPC implementation details\n-\n-Cross process Node, Wallet, and Chain interfaces are defined in\n-[`src/interfaces/`](../../src/interfaces/). These are C++ classes which follow\n-[conventions](../developer-notes.md#internal-interface-guidelines), like passing\n-serializable arguments so they can be called from different processes, and\n-making methods pure virtual so they can have proxy implementations that forward\n-calls between processes.\n-\n-When Wallet, Node, and Chain code is running in the same process, calling any\n-interface method invokes the implementation directly. When code is running in\n-different processes, calling an interface method invokes a proxy interface\n-implementation that communicates with a remote process and invokes the real\n-implementation in the remote process. The\n-[libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) code\n-generation tool internally generates proxy client classes and proxy server\n-classes for this purpose that are thin wrappers around Cap'n Proto\n-[client](https://capnproto.org/cxxrpc.html#clients) and\n-[server](https://capnproto.org/cxxrpc.html#servers) classes, which handle the\n-actual serialization and socket communication.\n-\n-As much as possible, calls between processes are meant to work the same as\n-calls within a single process without adding limitations or requiring extra\n-implementation effort. Processes communicate with each other by calling regular\n-[C++ interface methods](../../src/interfaces/README.md). Method arguments and\n-return values are automatically serialized and sent between processes. Object\n-references and `std::function` arguments are automatically tracked and mapped\n-to allow invoked code to call back into invoking code at any time, and there is\n-a 1:1 threading model where any thread invoking a method in another process has\n-a corresponding thread in the invoked process responsible for executing all\n-method calls from the source thread, without blocking I/O or holding up another\n-call, and using the same thread local variables, locks, and callbacks between\n-calls. The forwarding, tracking, and threading is implemented inside the\n-[libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) library\n-which has the design goal of making calls between processes look like calls in\n-the same process to the extent possible.\n+# Multiprocess Bitcoin Design Document\n+\n+Guide to the design and architecture of the Bitcoin-Core multiprocess feature\n+\n+_This document describes the design of the multiprocess feature. For usage information, see the top-level [multiprocess.md](../multiprocess.md) file._\n+\n+## Table of contents\n+\n+- [Introduction](#introduction)\n+- [Current Architecture](#current-architecture)\n+- [Proposed Architecture](#proposed-architecture)\n+- [Component Overview: Navigating the IPC Framework](#component-overview-navigating-the-ipc-framework)\n+- [Design Considerations](#design-considerations)\n+  - [Selection of Cap’n Proto](#selection-of-capn-proto)\n+  - [Hiding IPC](#hiding-ipc)\n+  - [Interface Definition Maintenance](#interface-definition-maintenance)\n+  - [Interface Stability](#interface-stability)\n+- [Example Use Cases and Flows](#example-use-cases-and-flows)\n+  - [Retrieving a Block Hash](#retrieving-a-block-hash)\n+- [Future Enhancements](#future-enhancements)\n+- [Conclusion](#conclusion)\n+- [Appendices](#appendices)\n+  - [Glossary of Terms](#glossary-of-terms)\n+  - [References](#references)\n+- [Acknowledgements](#acknowledgements)\n+\n+## Introduction\n+\n+The Bitcoin Core software, central to the Bitcoin network, has historically employed a monolithic architecture. The existing design has integrated functionality like P2P network operations, wallet management, and a GUI into a single executable. While effective, it has limitations in flexibility, security, and scalability. This project introduces changes that transition Bitcoin Core to a more modular architecture. It aims to enhance security, improve usability, and facilitate maintenance and development of the software.\n+\n+## Current Architecture\n+\n+The current system features two primary executables: `bitcoind` and `bitcoin-qt`. `bitcoind` combines a Bitcoin P2P node with an integrated JSON-RPC server, wallet, and indexes. `bitcoin-qt` extends this by incorporating a Qt-based GUI. This monolithic structure, although robust, presents challenges such as limited operational flexibility and increased security risks due to the tight integration of components.\n+\n+## Proposed Architecture\n+\n+The new architecture divides the existing code into three specialized executables:\n+\n+- `bitcoin-node`: Manages the node, indexes, and JSON-RPC server.\n+- `bitcoin-wallet`: Handles all wallet functionality.\n+- `bitcoin-gui`: Provides a standalone Qt-based GUI.\n+\n+This modular approach is designed to enhance security through component isolation and improve usability by allowing independent operation of each module. This allows for new use-cases, such as running the node on a dedicated machine and operating wallets and GUIs on separate machines with the flexibility to start and stop them as needed.\n+\n+This subdivision could be extended in the future. For example, indexes could be removed from the `bitcoin-node` executable and run in separate executables. And JSON-RPC servers could be added to wallet and index executables, so they can listen and respond to RPC requests on their own ports, without needing to forward RPC requests through `bitcoin-node`.\n+\n+## Component Overview: Navigating the IPC Framework\n+\n+This section describes the major components of the Inter-Process Communication (IPC) framework covering the relevant source files, generated files, tools, and libraries.\n+\n+### Abstract C++ Classes in [`src/interfaces/`](../../src/interfaces/)\n+- The foundation of the IPC implementation lies in the abstract C++ classes within the [`src/interfaces/`](../../src/interfaces/) directory. These classes define pure virtual methods that code in [`src/node/`](../../src/node/), [`src/wallet/`](../../src/wallet/), and [`src/qt/`](../../src/qt/) directories call to interact with each other.\n+- Each abstract class in this directory represents a distinct interface that the different modules (node, wallet, GUI) implement and use for cross-process communication.\n+- The classes are written following conventions described in [Internal Interface\n+  Guidelines](../developer-notes.md#internal-interface-guidelines) to ensure\n+  compatibility with Cap'n Proto.\n+\n+### Cap’n Proto Files in [`src/ipc/capnp/`](../../src/ipc/capnp/)\n+- Corresponding to each abstract class, there are `.capnp` files within the [`src/ipc/capnp/`](../../src/ipc/capnp/) directory. These files are used as input to the `mpgen` tool (described below) to generate C++ code.\n+- These Cap’n Proto files ([learn more about Cap'n Proto RPC](https://capnproto.org/rpc.html)) define the structure and format of messages that are exchanged over IPC. They serve as blueprints for generating C++ code that bridges the gap between high-level C++ interfaces and low-level socket communication.\n+\n+### The `mpgen` Code Generation Tool\n+- A central component of the IPC framework is the `mpgen` tool which is part the [`libmultiprocess` project](https://github.com/chaincodelabs/libmultiprocess). This tool takes the `.capnp` files as input and generates C++ code.\n+- The generated code handles IPC communication, translating interface calls into socket reads and writes.\n+\n+### C++ Client Subclasses in Generated Code\n+- In the generated code, we have C++ client subclasses that inherit from the abstract classes in [`src/interfaces/`](../../src/interfaces/). These subclasses are the workhorses of the IPC mechanism.\n+- They implement all the methods of the interface, marshalling arguments into a structured format, sending them as requests to the IPC server via a UNIX socket, and handling the responses.\n+- These subclasses effectively mask the complexity of IPC, presenting a familiar C++ interface to developers.\n+- Internally, the client subclasses generated by the `mpgen` tool wrap [client classes generated by Cap'n Proto](https://capnproto.org/cxxrpc.html#clients), and use them to send IPC requests.\n+\n+### C++ Server Classes in Generated Code\n+- On the server side, corresponding generated C++ classes receive IPC requests. These server classes are responsible for unmarshalling method arguments, invoking the corresponding methods in the local [`src/interfaces/`](../../src/interfaces/) objects, and creating the IPC response.\n+- The server classes ensure that return values (including output argument values and thrown exceptions) are marshalled and sent back to the client, completing the communication cycle.\n+- Internally, the server subclasses generated by the `mpgen` tool inherit from [server classes generated by Cap'n Proto](https://capnproto.org/cxxrpc.html#servers), and use them to process IPC requests.\n+\n+### The `libmultiprocess` Runtime Library\n+- **Core Functionality**: The `libmultiprocess` runtime library's primary function is to instantiate the generated client and server classes as needed.\n+- **Bootstrapping IPC Connections**: It provides functions for starting new IPC connections, specifically binding generated client and server classes for an initial `interfaces::Init` interface (defined in [`src/interfaces/init.h`](../../src/interfaces/init.h)) to a UNIX socket. This initial interface has methods returning other interfaces that different Bitcoin-Core modules use to communicate after the bootstrapping phase.\n+- **Asynchronous I/O and Thread Management**: The library is also responsible for managing I/O and threading. Particularly, it ensures that IPC requests never block each other and that new threads on either side of a connection can always make client calls. It also manages worker threads on the server side of calls, ensuring that calls from the same client thread always execute on the same server thread (to avoid locking issues and support nested callbacks).\n+\n+### Type Hooks in [`src/ipc/capnp/*-types.h`](../../src/ipc/capnp/)\n+- **Custom Type Conversions**: In [`src/ipc/capnp/*-types.h`](../../src/ipc/capnp/), multiple function overloads of two `libmultiprocess` C++ functions, `mp::CustomReadField` and `mp::CustomBuildFields`, are defined. These functions are used for customizing the conversion of specific C++ types to and from Cap’n Proto types.\n+- **Handling Special Cases**: The `mpgen` tool and `libmultiprocess` library can convert most C++ types to and from Cap’n Proto types automatically, including interface types, primitive C++ types, standard C++ types like `std::vector`, `std::set`, `std::map`, `std::tuple`, and `std::function`, as well as simple C++ structs that consist of afforementioned types and whose fields correspond 1:1 with Cap’n Proto struct fields. For other types, `*-types.h` files provide custom code to convert between C++ and Cap’n Proto data representations.\n+\n+### Protocol-Agnostic IPC Code in [`src/ipc/`](../../src/ipc/)\n+- **Broad Applicability**: Unlike the Cap’n Proto-specific code in [`src/ipc/capnp/`](../../src/ipc/capnp/), the code in the [`src/ipc/`](../../src/ipc/) directory is protocol-agnostic. This enables potential support for other protocols, such as gRPC or a custom protocol in the future.\n+- **Process Management and Socket Operations**: The main purpose of this component is to provide functions for spawning new processes and creating and connecting to UNIX sockets.\n+- **ipc::Exception Class**: This code also defines an `ipc::Exception` class which is thrown from the generated C++ client class methods when there is an unexpected IPC error, such as a disconnection.\n+\n+## Design Considerations\n+\n+### Selection of Cap’n Proto\n+The choice to use [Cap’n Proto](https://capnproto.org/) for IPC was primarily influenced by its support for passing object references and managing object lifetimes, which would have to be implemented manually with a framework that only supported plain requests and responses like [gRPC](https://grpc.io/). The support is especially helpful for passing callback objects like `std::function` and supporting bidirectional communication.\n+\n+The choice to use an RPC framework at all instead of a custom protocol was neccesitated by the size of Bitcoin Core internal interfaces which consist of around 150 methods that pass complex data structures and are called in complicated ways (in parallel, from callbacks that can be nested and stored). Writing a custom protocol to wrap these complicated interfaces would be too much work, akin to writing a new RPC framework.\n+\n+### Hiding IPC\n+\n+The IPC mechanism is deliberately isolated from the rest of the codebase so less code has to be concerned with IPC.\n+\n+Building Bitcoin Core with IPC support is optional, and the same code can be compiled to either run in the same process or separate processes. The build system also ensures Cap’n Proto library headers can only be used within the [`src/ipc/capnp/`](../../src/ipc/capnp/) directory, not in other parts of the codebase.\n+\n+The libmultiprocess runtime is designed to place as few constraints as possible on IPC interfaces and make IPC calls act like normal function calls. Method arguments, return values, and exceptions are automatically serialized and sent between processes. Object references and `std::function` arguments are automatically tracked and mapped to allow invoked code to call back into invoking code at any time. And there is a 1:1 threading model where any every client thread has a corresponding server thread responsible for executing incoming calls from that thread (there can be multiple calls from the same thread due to callbacks), without blocking, and holding the same thread-local variables and locks so behavior is the same whether IPC is used or not.\n+\n+### Interface Definition Maintenance\n+\n+The choice to maintain interface definitions and C++ type mappings as `.capnp` files in the [`src/ipc/capnp/`](../../src/ipc/capnp/) was mostly done for convenience, and probably something that could be improved in the future.\n+\n+In the current design, class names, method names, and parameter names are duplicated between C++ interfaces in [`src/interfaces/`](../../src/interfaces/) and Cap’n Proto files in [`src/ipc/capnp/`](../../src/ipc/capnp/). While this keeps C++ interface headers simple and free of references to IPC, it is a maintence burden because it means inconsistencies between C++ declarations and Cap’n Proto declarations will result in compile errors. (Static type checking ensures these are not runtime errors.)\n+\n+An alternate approach could use custom [C++ Attributes](https://en.cppreference.com/w/cpp/language/attributes) embedded in interface declarations to automatically generate `.capnp` files directly from C++ headers. This has not been pursued because parsing C++ headers is more complicated than parsing Cap’n Proto interface definitions, especially portably on multiple platforms.\n+\n+### Interface Stability\n+\n+The currently defined IPC interfaces are unstable, and can change freely with no backwards compatibility. The decision to allow this stems from the recognition that our current interfaces are still evolving and not yet ideal for external use. As these interfaces mature and become more refined, there may be an opportunity to declare them stable and use Cap’n Proto's support for protocol evolution ([Cap'n Proto - Evolving Your Protocol](https://capnproto.org/language.html#evolving-your-protocol)) to allow them to be extended while remaining backwards compatible. This could allow different versions of node, GUI, and wallet binaries to interoperate, and potentially open doors for external tools to utilize these interfaces, such as creating custom indexes through a stable indexing interface. However, for now, the priority is to improve the interfaces internally. Given their current state and the advantages of using JSON-RPC for most common tasks, it's more practical to focus on internal development rather than external applicability.\n+\n+## Example Use Cases and Flows\n+\n+### Retrieving a Block Hash\n+\n+Let’s walk through an example where the `bitcoin-wallet` process requests the hash of a block at a specific height from the `bitcoin-node` process. This example demonstrates the practical application of the IPC mechanism, specifically the interplay between C++ method calls and Cap’n Proto-generated RPC calls.\n+\n+1. **Initiation in bitcoin-wallet**\n+   - The wallet process calls the `getBlockHash` method on a `Chain` object. This method is defined as a virtual function in [`src/interfaces/chain.h`](../../src/interfaces/chain.h).\n+\n+2. **Translation to Cap’n Proto RPC**\n+   - The call to `getBlockHash` is translated into a Cap’n Proto RPC call. This translation is handled by code automatically generated by the `mpgen` tool, based on the [`chain.capnp`](../../src/ipc/capnp/chain.capnp)` file in [`src/ipc/capnp/`](../../src/ipc/capnp/).\n+\n+3. **Request Preparation and Dispatch**\n+   - The generated `Chain` subclass in `bitcoin-wallet` populates a Cap’n Proto request with the `height` parameter.\n+   - The request is sent to the `bitcoin-node` process.\n+\n+4. **Handling in bitcoin-node**\n+   - Upon receiving the request, the `bitcoin-node` process reads the `height` value from the request.\n+   - It then calls the `getBlockHash` method on its local `Chain` object with the provided `height`.\n+\n+5. **Response and Return**\n+   - The `bitcoin-node` process takes the `getBlockHash` return value, encapsulates it in a Cap’n Proto response, and sends it back to the `bitcoin-wallet` process.\n+   - The `bitcoin-wallet` process receives the response, extracts the block hash value, and returns it to the original caller.\n+\n+## Future Enhancements\n+\n+Further improvements are possible such as:\n+\n+- Separating indexes from `bitcoin-node`, and running indexing code in separate processes (see [indexes: Stop using node internal types #24230](https://github.com/bitcoin/bitcoin/pull/24230)).\n+- Enabling wallet processes to listen for JSON-RPC requests on their own ports instead of needing the node process to listen and forward requests to them.\n+- Automatically generating `.capnp` files from C++ interface definitions (see [Interface Definition Maintenance](#interface-definition-maintenance)).\n+- Simplifying and stabilizing interfaces (see [Interface Stability](#interface-stability)).\n+- Adding sandbox features, restricting subprocess access to resources and data (see [https://eklitzke.org/multiprocess-bitcoin](https://eklitzke.org/multiprocess-bitcoin)).\n+- Using Cap'n Proto's support for [other languages](https://capnproto.org/otherlang.html), such as [Rust](https://github.com/capnproto/capnproto-rust), to allow code written in other languages to call Bitcoin Core C++ code, and vice versa (see [How to rustify libmultiprocess? #56](https://github.com/chaincodelabs/libmultiprocess/issues/56)).\n+\n+## Conclusion",
      "path": "doc/design/multiprocess.md",
      "position": 276,
      "original_position": 225,
      "commit_id": "91dc48c14825a9075a57c1eefda202b83b6346ba",
      "original_commit_id": "837c53d14f24924cdcb2cfd8b18915882dc3b620",
      "in_reply_to_id": 1428154601,
      "user": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "re: https://github.com/bitcoin/bitcoin/pull/28978#discussion_r1428154601\r\n\r\n> nit: This just repeats what is said in the Introduction part and isn't really needed for the purpose of this doc IMO\r\n\r\nAgree, cut it down. I do think having a 1 sentence summary is useful to provide a little orientation at the end so didn't remove it entirely.",
      "created_at": "2023-12-19T12:49:05Z",
      "updated_at": "2023-12-19T16:29:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28978#discussion_r1431361778",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1431361778"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28978"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 217,
      "original_line": 217,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1431362236",
      "pull_request_review_id": 1788797844,
      "id": 1431362236,
      "node_id": "PRRC_kwDOABII585VUNq8",
      "diff_hunk": "@@ -0,0 +1,34 @@\n+# Multiprocess Bitcoin\n+\n+_This document describes usage of the multiprocess feature. For design information, see the [design/multiprocess.md](design/multiprocess.md) file._\n+\n+## Build Option\n+\n+On unix systems, the `--enable-multiprocess` build option can be passed to `./configure` to build new `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables alongside existing `bitcoind` and `bitcoin-qt` executables.\n+\n+## Debugging\n+\n+The `-debug=ipc` command line option can be used to see requests and responses between processes.\n+\n+## Installation\n+\n+The multiprocess feature requires [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) as dependencies. A simple way to get starting using it without installing these dependencies manually is to use the [depends system](../depends) with the `MULTIPROCESS=1` [dependency option](../depends#dependency-options) passed to make:",
      "path": "doc/multiprocess.md",
      "position": null,
      "original_position": 15,
      "commit_id": "91dc48c14825a9075a57c1eefda202b83b6346ba",
      "original_commit_id": "837c53d14f24924cdcb2cfd8b18915882dc3b620",
      "in_reply_to_id": 1428168964,
      "user": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "re: https://github.com/bitcoin/bitcoin/pull/28978#discussion_r1428168964\r\n\r\nThanks, fixed",
      "created_at": "2023-12-19T12:49:30Z",
      "updated_at": "2023-12-19T16:29:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28978#discussion_r1431362236",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1431362236"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28978"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 15,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1433109875",
      "pull_request_review_id": 1791543397,
      "id": 1433109875,
      "node_id": "PRRC_kwDOABII585Va4Vz",
      "diff_hunk": "@@ -1,72 +1,264 @@\n-# Multiprocess Bitcoin\n+# Multiprocess Bitcoin Design Document\n \n-On unix systems, the `--enable-multiprocess` build option can be passed to `./configure` to build new `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables alongside existing `bitcoind` and `bitcoin-qt` executables.\n+Guide to the design and architecture of the Bitcoin Core multiprocess feature\n \n-`bitcoin-node` is a drop-in replacement for `bitcoind`, and `bitcoin-gui` is a drop-in replacement for `bitcoin-qt`, and there are no differences in use or external behavior between the new and old executables. But internally (after [#10102](https://github.com/bitcoin/bitcoin/pull/10102)), `bitcoin-gui` will spawn a `bitcoin-node` process to run P2P and RPC code, communicating with it across a socket pair, and `bitcoin-node` will spawn `bitcoin-wallet` to run wallet code, also communicating over a socket pair. This will let node, wallet, and GUI code run in separate address spaces for better isolation, and allow future improvements like being able to start and stop components independently on different machines and environments.\n+_This document describes the design of the multiprocess feature. For usage information, see the top-level [multiprocess.md](../multiprocess.md) file._\n \n-## Next steps\n+## Table of contents\n \n-Specific next steps after [#10102](https://github.com/bitcoin/bitcoin/pull/10102) will be:\n+- [Introduction](#introduction)\n+- [Current Architecture](#current-architecture)\n+- [Proposed Architecture](#proposed-architecture)\n+- [Component Overview: Navigating the IPC Framework](#component-overview-navigating-the-ipc-framework)\n+- [Design Considerations](#design-considerations)\n+  - [Selection of Cap’n Proto](#selection-of-capn-proto)\n+  - [Hiding IPC](#hiding-ipc)\n+  - [Interface Definition Maintenance](#interface-definition-maintenance)\n+  - [Interface Stability](#interface-stability)\n+- [Security Considerations](#security-considerations)\n+- [Example Use Cases and Flows](#example-use-cases-and-flows)\n+  - [Retrieving a Block Hash](#retrieving-a-block-hash)\n+- [Future Enhancements](#future-enhancements)\n+- [Conclusion](#conclusion)\n+- [Appendices](#appendices)\n+  - [Glossary of Terms](#glossary-of-terms)\n+  - [References](#references)\n+- [Acknowledgements](#acknowledgements)\n \n-- [ ] Adding `-ipcbind` and `-ipcconnect` options to `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables so they can listen and connect to TCP ports and unix socket paths. This will allow separate processes to be started and stopped any time and connect to each other.\n-- [ ] Adding `-server` and `-rpcbind` options to the `bitcoin-wallet` executable so wallet processes can handle RPC requests directly without going through the node.\n-- [ ] Supporting windows, not just unix systems. The existing socket code is already cross-platform, so the only windows-specific code that needs to be written is code spawning a process and passing a socket descriptor. This can be implemented with `CreateProcess` and `WSADuplicateSocket`. Example: https://memset.wordpress.com/2010/10/13/win32-api-passing-socket-with-ipc-method/.\n-- [ ] Adding sandbox features, restricting subprocess access to resources and data. See [https://eklitzke.org/multiprocess-bitcoin](https://eklitzke.org/multiprocess-bitcoin).\n+## Introduction\n \n-## Debugging\n+The Bitcoin Core software has historically employed a monolithic architecture. The existing design has integrated functionality like P2P network operations, wallet management, and a GUI into a single executable. While effective, it has limitations in flexibility, security, and scalability. This project introduces changes that transition Bitcoin Core to a more modular architecture. It aims to enhance security, improve usability, and facilitate maintenance and development of the software in the long run.\n \n-The `-debug=ipc` command line option can be used to see requests and responses between processes.\n+## Current Architecture\n \n-## Installation\n+The current system features two primary executables: `bitcoind` and `bitcoin-qt`. `bitcoind` combines a Bitcoin P2P node with an integrated JSON-RPC server, wallet, and indexes. `bitcoin-qt` extends this by incorporating a Qt-based GUI. This monolithic structure, although robust, presents challenges such as limited operational flexibility and increased security risks due to the tight integration of components.\n \n-The multiprocess feature requires [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) as dependencies. A simple way to get starting using it without installing these dependencies manually is to use the [depends system](../../depends) with the `MULTIPROCESS=1` [dependency option](../../depends#dependency-options) passed to make:\n+## Proposed Architecture\n \n+The new architecture divides the existing code into three specialized executables:\n+\n+- `bitcoin-node`: Manages the P2P node, indexes, and JSON-RPC server.\n+- `bitcoin-wallet`: Handles all wallet functionality.\n+- `bitcoin-gui`: Provides a standalone Qt-based GUI.\n+\n+This modular approach is designed to enhance security through component isolation and improve usability by allowing independent operation of each module. This allows for new use-cases, such as running the node on a dedicated machine and operating wallets and GUIs on separate machines with the flexibility to start and stop them as needed.\n+\n+This subdivision could be extended in the future. For example, indexes could be removed from the `bitcoin-node` executable and run in separate executables. And JSON-RPC servers could be added to wallet and index executables, so they can listen and respond to RPC requests on their own ports, without needing to forward RPC requests through `bitcoin-node`.\n+\n+<table><tr><td>\n+\n+```mermaid\n+flowchart LR\n+    node[bitcoin-node] -- listens on --> socket[\"&lt;datadir&gt;/node.sock\"]\n+    wallet[bitcoin-wallet] -- connects to --> socket\n+    gui[bitcoin-gui] -- connects to --> socket\n+```\n+\n+</td></tr><tr><td>\n+Processes and socket connection.\n+</td></tr></table>\n+\n+## Component Overview: Navigating the IPC Framework\n+\n+This section describes the major components of the Inter-Process Communication (IPC) framework covering the relevant source files, generated files, tools, and libraries.\n+\n+### Abstract C++ Classes in [`src/interfaces/`](../../src/interfaces/)\n+- The foundation of the IPC implementation lies in the abstract C++ classes within the [`src/interfaces/`](../../src/interfaces/) directory. These classes define pure virtual methods that code in [`src/node/`](../../src/node/), [`src/wallet/`](../../src/wallet/), and [`src/qt/`](../../src/qt/) directories call to interact with each other.\n+- Each abstract class in this directory represents a distinct interface that the different modules (node, wallet, GUI) implement and use for cross-process communication.\n+- The classes are written following conventions described in [Internal Interface\n+  Guidelines](../developer-notes.md#internal-interface-guidelines) to ensure\n+  compatibility with Cap'n Proto.\n+\n+### Cap’n Proto Files in [`src/ipc/capnp/`](../../src/ipc/capnp/)\n+- Corresponding to each abstract class, there are `.capnp` files within the [`src/ipc/capnp/`](../../src/ipc/capnp/) directory. These files are used as input to the `mpgen` tool (described below) to generate C++ code.\n+- These Cap’n Proto files ([learn more about Cap'n Proto RPC](https://capnproto.org/rpc.html)) define the structure and format of messages that are exchanged over IPC. They serve as blueprints for generating C++ code that bridges the gap between high-level C++ interfaces and low-level socket communication.\n+\n+### The `mpgen` Code Generation Tool\n+- A central component of the IPC framework is the `mpgen` tool which is part the [`libmultiprocess` project](https://github.com/chaincodelabs/libmultiprocess). This tool takes the `.capnp` files as input and generates C++ code.\n+- The generated code handles IPC communication, translating interface calls into socket reads and writes.\n+\n+### C++ Client Subclasses in Generated Code\n+- In the generated code, we have C++ client subclasses that inherit from the abstract classes in [`src/interfaces/`](../../src/interfaces/). These subclasses are the workhorses of the IPC mechanism.\n+- They implement all the methods of the interface, marshalling arguments into a structured format, sending them as requests to the IPC server via a UNIX socket, and handling the responses.\n+- These subclasses effectively mask the complexity of IPC, presenting a familiar C++ interface to developers.\n+- Internally, the client subclasses generated by the `mpgen` tool wrap [client classes generated by Cap'n Proto](https://capnproto.org/cxxrpc.html#clients), and use them to send IPC requests.\n+\n+### C++ Server Classes in Generated Code\n+- On the server side, corresponding generated C++ classes receive IPC requests. These server classes are responsible for unmarshalling method arguments, invoking the corresponding methods in the local [`src/interfaces/`](../../src/interfaces/) objects, and creating the IPC response.\n+- The server classes ensure that return values (including output argument values and thrown exceptions) are marshalled and sent back to the client, completing the communication cycle.\n+- Internally, the server subclasses generated by the `mpgen` tool inherit from [server classes generated by Cap'n Proto](https://capnproto.org/cxxrpc.html#servers), and use them to process IPC requests.\n+\n+### The `libmultiprocess` Runtime Library\n+- **Core Functionality**: The `libmultiprocess` runtime library's primary function is to instantiate the generated client and server classes as needed.\n+- **Bootstrapping IPC Connections**: It provides functions for starting new IPC connections, specifically binding generated client and server classes for an initial `interfaces::Init` interface (defined in [`src/interfaces/init.h`](../../src/interfaces/init.h)) to a UNIX socket. This initial interface has methods returning other interfaces that different Bitcoin Core modules use to communicate after the bootstrapping phase.\n+- **Asynchronous I/O and Thread Management**: The library is also responsible for managing I/O and threading. Particularly, it ensures that IPC requests never block each other and that new threads on either side of a connection can always make client calls. It also manages worker threads on the server side of calls, ensuring that calls from the same client thread always execute on the same server thread (to avoid locking issues and support nested callbacks).\n+\n+### Type Hooks in [`src/ipc/capnp/*-types.h`](../../src/ipc/capnp/)\n+- **Custom Type Conversions**: In [`src/ipc/capnp/*-types.h`](../../src/ipc/capnp/), function overloads of two `libmultiprocess` C++ functions, `mp::CustomReadField` and `mp::CustomBuildFields`, are defined. These overloads are used for customizing the conversion of specific C++ types to and from Cap’n Proto types.\n+- **Handling Special Cases**: The `mpgen` tool and `libmultiprocess` library can convert most C++ types to and from Cap’n Proto types automatically, including interface types, primitive C++ types, standard C++ types like `std::vector`, `std::set`, `std::map`, `std::tuple`, and `std::function`, as well as simple C++ structs that consist of aforementioned types and whose fields correspond 1:1 with Cap’n Proto struct fields. For other types, `*-types.h` files provide custom code to convert between C++ and Cap’n Proto data representations.\n+\n+### Protocol-Agnostic IPC Code in [`src/ipc/`](../../src/ipc/)\n+- **Broad Applicability**: Unlike the Cap’n Proto-specific code in [`src/ipc/capnp/`](../../src/ipc/capnp/), the code in the [`src/ipc/`](../../src/ipc/) directory is protocol-agnostic. This enables potential support for other protocols, such as gRPC or a custom protocol in the future.\n+- **Process Management and Socket Operations**: The main purpose of this component is to provide functions for spawning new processes and creating and connecting to UNIX sockets.\n+- **ipc::Exception Class**: This code also defines an `ipc::Exception` class which is thrown from the generated C++ client class methods when there is an unexpected IPC error, such as a disconnection.\n+\n+<table><tr><td>\n+\n+```mermaid\n+flowchart TD\n+    capnpFile[ipc/capnp/chain.capnp] -->|Input to| mpgenTool([mpgen Tool])\n+    mpgenTool -->|Generates| proxyTypesH[ipc/capnp/chain.capnp.proxy-types.h]\n+    mpgenTool --> proxyClientCpp[ipc/capnp/chain.capnp.proxy-client.c++]\n+    mpgenTool --> proxyServerCpp[ipc/capnp/chain.capnp.proxy-server.c++]\n+    proxyTypesH -.->|Includes| interfaces/chain.h\n+    proxyClientCpp -.-> interfaces/chain.h\n+    proxyServerCpp -.-> interfaces/chain.h\n ```\n-cd <BITCOIN_SOURCE_DIRECTORY>\n-make -C depends NO_QT=1 MULTIPROCESS=1\n-CONFIG_SITE=$PWD/depends/x86_64-pc-linux-gnu/share/config.site ./configure\n-make\n-src/bitcoin-node -regtest -printtoconsole -debug=ipc\n-BITCOIND=bitcoin-node test/functional/test_runner.py\n+\n+</td></tr><tr><td>\n+Diagram showing generated source files and includes.\n+</td></tr></table>\n+\n+## Design Considerations\n+\n+### Selection of Cap’n Proto\n+The choice to use [Cap’n Proto](https://capnproto.org/) for IPC was primarily influenced by its support for passing object references and managing object lifetimes, which would have to be implemented manually with a framework that only supported plain requests and responses like [gRPC](https://grpc.io/). The support is especially helpful for passing callback objects like `std::function` and enabling bidirectional calls between processes.\n+\n+The choice to use an RPC framework at all instead of a custom protocol was necessitated by the size of Bitcoin Core internal interfaces which consist of around 150 methods that pass complex data structures and are called in complicated ways (in parallel, and from callbacks that can be nested and stored). Writing a custom protocol to wrap these complicated interfaces would be a lot more work, akin to writing a new RPC framework.\n+\n+### Hiding IPC\n+\n+The IPC mechanism is deliberately isolated from the rest of the codebase so less code has to be concerned with IPC.\n+\n+Building Bitcoin Core with IPC support is optional, and node, wallet, and GUI code can be compiled to either run in the same process or separate processes. The build system also ensures Cap’n Proto library headers can only be used within the [`src/ipc/capnp/`](../../src/ipc/capnp/) directory, not in other parts of the codebase.\n+\n+The libmultiprocess runtime is designed to place as few constraints as possible on IPC interfaces and to make IPC calls act like normal function calls. Method arguments, return values, and exceptions are automatically serialized and sent between processes. Object references and `std::function` arguments are tracked to allow invoked code to call back into invoking code at any time. And there is a 1:1 threading model where every client thread has a corresponding server thread responsible for executing incoming calls from that thread (there can be multiple calls from the same thread due to callbacks) without blocking, and holding the same thread-local variables and locks so behavior is the same whether IPC is used or not.\n+\n+### Interface Definition Maintenance\n+\n+The choice to maintain interface definitions and C++ type mappings as `.capnp` files in the [`src/ipc/capnp/`](../../src/ipc/capnp/) was mostly done for convenience, and probably something that could be improved in the future.\n+\n+In the current design, class names, method names, and parameter names are duplicated between C++ interfaces in [`src/interfaces/`](../../src/interfaces/) and Cap’n Proto files in [`src/ipc/capnp/`](../../src/ipc/capnp/). While this keeps C++ interface headers simple and free of references to IPC, it is a maintenance burden because it means inconsistencies between C++ declarations and Cap’n Proto declarations will result in compile errors. (Static type checking ensures these are not runtime errors.)\n+\n+An alternate approach could use custom [C++ Attributes](https://en.cppreference.com/w/cpp/language/attributes) embedded in interface declarations to automatically generate `.capnp` files from C++ headers. This has not been pursued because parsing C++ headers is more complicated than parsing Cap’n Proto interface definitions, especially portably on multiple platforms.\n+\n+In the meantime, the developer guide [Internal interface guidelines](developer-notes.md#internal-interface-guidelines) can provide guidance on keeping interfaces consistent and functional and avoiding compile errors.\n+\n+### Interface Stability\n+\n+The currently defined IPC interfaces are unstable, and can change freely with no backwards compatibility. The decision to allow this stems from the recognition that our current interfaces are still evolving and not yet ideal for external use. As these interfaces mature and become more refined, there may be an opportunity to declare them stable and use Cap’n Proto's support for protocol evolution ([Cap'n Proto - Evolving Your Protocol](https://capnproto.org/language.html#evolving-your-protocol)) to allow them to be extended while remaining backwards compatible. This could allow different versions of node, GUI, and wallet binaries to interoperate, and potentially open doors for external tools to utilize these interfaces, such as creating custom indexes through a stable indexing interface. However, for now, the priority is to improve the interfaces internally. Given their current state and the advantages of using JSON-RPC for most common tasks, it's more practical to focus on internal development rather than external applicability.\n+\n+## Security Considerations\n+\n+The integration of [Cap’n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) into the Bitcoin Core architecture increases its potential attack surface. Cap’n Proto, being a complex and substantial new dependency, introduces potential sources of vulnerability, particularly through the creation of new UNIX sockets. The inclusion of libmultiprocess, while a smaller external dependency, also contributes to this risk. However, plans are underway to incorporate libmultiprocess as a git subtree, aligning it more closely with the project's well-reviewed internal libraries. While adopting these multiprocess features does introduce some risk, it's worth noting that they can be disabled, allowing builds without these new dependencies. This flexibility ensures that users can balance functionality with security considerations as needed.\n+\n+## Example Use Cases and Flows\n+\n+### Retrieving a Block Hash\n+\n+Let’s walk through an example where the `bitcoin-wallet` process requests the hash of a block at a specific height from the `bitcoin-node` process. This example demonstrates the practical application of the IPC mechanism, specifically the interplay between C++ method calls and Cap’n Proto-generated RPC calls.\n+\n+```mermaid\n+sequenceDiagram\n+    box \"bitcoin-wallet process\"\n+    participant WalletCode as Wallet code\n+    participant ChainClient as Generated Chain client class<br/>ProxyClient<messages::Chain>\n+    end\n+    box \"bitcoin-node process\"\n+    participant ChainServer as Generated Chain server class<br/>ProxyServer<messages::Chain>\n+    participant LocalChain as Chain object<br/>node::ChainImpl\n+    end\n+\n+    WalletCode->>ChainClient: getBlockHash(height)\n+    ChainClient->>ChainServer: Send RPC getBlockHash request\n+    ChainServer->>LocalChain: getBlockHash(height)\n+    LocalChain->>ChainServer: Return block hash\n+    ChainServer->>ChainClient: Send response with block hash\n+    ChainClient->>WalletCode: Return block hash\n ```\n \n-The configure script will pick up settings and library locations from the depends directory, so there is no need to pass `--enable-multiprocess` as a separate flag when using the depends system (it's controlled by the `MULTIPROCESS=1` option).\n-\n-Alternately, you can install [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) packages on your system, and just run `./configure --enable-multiprocess` without using the depends system. The configure script will be able to locate the installed packages via [pkg-config](https://www.freedesktop.org/wiki/Software/pkg-config/). See [Installation](https://github.com/chaincodelabs/libmultiprocess/blob/master/doc/install.md) section of the libmultiprocess readme for install steps. See [build-unix.md](../build-unix.md) and [build-osx.md](../build-osx.md) for information about installing dependencies in general.\n-\n-## IPC implementation details\n-\n-Cross process Node, Wallet, and Chain interfaces are defined in\n-[`src/interfaces/`](../../src/interfaces/). These are C++ classes which follow\n-[conventions](../developer-notes.md#internal-interface-guidelines), like passing\n-serializable arguments so they can be called from different processes, and\n-making methods pure virtual so they can have proxy implementations that forward\n-calls between processes.\n-\n-When Wallet, Node, and Chain code is running in the same process, calling any\n-interface method invokes the implementation directly. When code is running in\n-different processes, calling an interface method invokes a proxy interface\n-implementation that communicates with a remote process and invokes the real\n-implementation in the remote process. The\n-[libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) code\n-generation tool internally generates proxy client classes and proxy server\n-classes for this purpose that are thin wrappers around Cap'n Proto\n-[client](https://capnproto.org/cxxrpc.html#clients) and\n-[server](https://capnproto.org/cxxrpc.html#servers) classes, which handle the\n-actual serialization and socket communication.\n-\n-As much as possible, calls between processes are meant to work the same as\n-calls within a single process without adding limitations or requiring extra\n-implementation effort. Processes communicate with each other by calling regular\n-[C++ interface methods](../../src/interfaces/README.md). Method arguments and\n-return values are automatically serialized and sent between processes. Object\n-references and `std::function` arguments are automatically tracked and mapped\n-to allow invoked code to call back into invoking code at any time, and there is\n-a 1:1 threading model where any thread invoking a method in another process has\n-a corresponding thread in the invoked process responsible for executing all\n-method calls from the source thread, without blocking I/O or holding up another\n-call, and using the same thread local variables, locks, and callbacks between\n-calls. The forwarding, tracking, and threading is implemented inside the\n-[libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) library\n-which has the design goal of making calls between processes look like calls in\n-the same process to the extent possible.\n+</td></tr><tr><td>\n+<code>Chain::getBlockHash</code> call diagram\n+</td></tr></table>\n+\n+1. **Initiation in bitcoin-wallet**\n+   - The wallet process calls the `getBlockHash` method on a `Chain` object. This method is defined as a virtual method in [`src/interfaces/chain.h`](../../src/interfaces/chain.h).\n+\n+2. **Translation to Cap’n Proto RPC**\n+   - The `Chain::getBlockHash` virtual method is overridden by the `Chain` [client subclass](#c-client-subclasses-in-generated-code) to translate the method call into a Cap’n Proto RPC call.\n+   - The client subclass is automatically generated by the `mpgen` tool from the [`chain.capnp`](https://github.com/ryanofsky/bitcoin/blob/pr/ipc/src/ipc/capnp/chain.capnp) file in [`src/ipc/capnp/`](../../src/ipc/capnp/).\n+\n+3. **Request Preparation and Dispatch**\n+   - The `getBlockHash` method of the generated `Chain` client subclass in `bitcoin-wallet` populates a Cap’n Proto request with the `height` parameter, sends it to `bitcoin-node` process, and waits for a response.\n+\n+4. **Handling in bitcoin-node**\n+   - Upon receiving the request, the Cap'n Proto dispatching code in the `bitcoin-node` process calls the `getBlockHash` method of the `Chain` [server class](#c-server-classes-in-generated-code).\n+   - The server class is automatically generated by the `mpgen` tool from the [`chain.capnp`](https://github.com/ryanofsky/bitcoin/blob/pr/ipc/src/ipc/capnp/chain.capnp) file in [`src/ipc/capnp/`](../../src/ipc/capnp/).\n+   - The `getBlockHash` method of the generated `Chain` server subclass in `bitcoin-wallet` receives a Cap’n Proto request object with the `height` parameter, and calls the `getBlockHash` method on its local `Chain` object with the provided `height`.\n+   - When the call returns, it encapsulates the return value in a Cap’n Proto response, which it sends back to the `bitcoin-wallet` process,\n+\n+5. **Response and Return**\n+   - The `getBlockHash` method of the generated `Chain` client subclass in `bitcoin-wallet` which sent the request now receives the response.\n+   - It extracts the block hash value from the response, and returns it to the original caller.\n+\n+<table><tr><td>",
      "path": "doc/design/multiprocess.md",
      "position": null,
      "original_position": 263,
      "commit_id": "91dc48c14825a9075a57c1eefda202b83b6346ba",
      "original_commit_id": "c80bd16c826d564086006cff67b7b9ade9b9f38c",
      "in_reply_to_id": null,
      "user": {
        "login": "0xB10C",
        "id": 19157360,
        "node_id": "MDQ6VXNlcjE5MTU3MzYw",
        "avatar_url": "https://avatars.githubusercontent.com/u/19157360?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/0xB10C",
        "html_url": "https://github.com/0xB10C",
        "followers_url": "https://api.github.com/users/0xB10C/followers",
        "following_url": "https://api.github.com/users/0xB10C/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/0xB10C/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/0xB10C/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/0xB10C/subscriptions",
        "organizations_url": "https://api.github.com/users/0xB10C/orgs",
        "repos_url": "https://api.github.com/users/0xB10C/repos",
        "events_url": "https://api.github.com/users/0xB10C/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/0xB10C/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n</td></tr></table>\r\n```\r\n\r\nI think you meant to close/end the table here. Otherwise this looks a bit weird rendered on GitHub.",
      "created_at": "2023-12-20T19:36:40Z",
      "updated_at": "2023-12-20T19:37:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28978#discussion_r1433109875",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1433109875"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28978"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 204,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1436732897",
      "pull_request_review_id": 1796742782,
      "id": 1436732897,
      "node_id": "PRRC_kwDOABII585Vos3h",
      "diff_hunk": "@@ -1,72 +1,264 @@\n-# Multiprocess Bitcoin\n+# Multiprocess Bitcoin Design Document\n \n-On unix systems, the `--enable-multiprocess` build option can be passed to `./configure` to build new `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables alongside existing `bitcoind` and `bitcoin-qt` executables.\n+Guide to the design and architecture of the Bitcoin Core multiprocess feature\n \n-`bitcoin-node` is a drop-in replacement for `bitcoind`, and `bitcoin-gui` is a drop-in replacement for `bitcoin-qt`, and there are no differences in use or external behavior between the new and old executables. But internally (after [#10102](https://github.com/bitcoin/bitcoin/pull/10102)), `bitcoin-gui` will spawn a `bitcoin-node` process to run P2P and RPC code, communicating with it across a socket pair, and `bitcoin-node` will spawn `bitcoin-wallet` to run wallet code, also communicating over a socket pair. This will let node, wallet, and GUI code run in separate address spaces for better isolation, and allow future improvements like being able to start and stop components independently on different machines and environments.\n+_This document describes the design of the multiprocess feature. For usage information, see the top-level [multiprocess.md](../multiprocess.md) file._\n \n-## Next steps\n+## Table of contents\n \n-Specific next steps after [#10102](https://github.com/bitcoin/bitcoin/pull/10102) will be:\n+- [Introduction](#introduction)\n+- [Current Architecture](#current-architecture)\n+- [Proposed Architecture](#proposed-architecture)\n+- [Component Overview: Navigating the IPC Framework](#component-overview-navigating-the-ipc-framework)\n+- [Design Considerations](#design-considerations)\n+  - [Selection of Cap’n Proto](#selection-of-capn-proto)\n+  - [Hiding IPC](#hiding-ipc)\n+  - [Interface Definition Maintenance](#interface-definition-maintenance)\n+  - [Interface Stability](#interface-stability)\n+- [Security Considerations](#security-considerations)\n+- [Example Use Cases and Flows](#example-use-cases-and-flows)\n+  - [Retrieving a Block Hash](#retrieving-a-block-hash)\n+- [Future Enhancements](#future-enhancements)\n+- [Conclusion](#conclusion)\n+- [Appendices](#appendices)\n+  - [Glossary of Terms](#glossary-of-terms)\n+  - [References](#references)\n+- [Acknowledgements](#acknowledgements)\n \n-- [ ] Adding `-ipcbind` and `-ipcconnect` options to `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables so they can listen and connect to TCP ports and unix socket paths. This will allow separate processes to be started and stopped any time and connect to each other.\n-- [ ] Adding `-server` and `-rpcbind` options to the `bitcoin-wallet` executable so wallet processes can handle RPC requests directly without going through the node.\n-- [ ] Supporting windows, not just unix systems. The existing socket code is already cross-platform, so the only windows-specific code that needs to be written is code spawning a process and passing a socket descriptor. This can be implemented with `CreateProcess` and `WSADuplicateSocket`. Example: https://memset.wordpress.com/2010/10/13/win32-api-passing-socket-with-ipc-method/.\n-- [ ] Adding sandbox features, restricting subprocess access to resources and data. See [https://eklitzke.org/multiprocess-bitcoin](https://eklitzke.org/multiprocess-bitcoin).\n+## Introduction\n \n-## Debugging\n+The Bitcoin Core software has historically employed a monolithic architecture. The existing design has integrated functionality like P2P network operations, wallet management, and a GUI into a single executable. While effective, it has limitations in flexibility, security, and scalability. This project introduces changes that transition Bitcoin Core to a more modular architecture. It aims to enhance security, improve usability, and facilitate maintenance and development of the software in the long run.\n \n-The `-debug=ipc` command line option can be used to see requests and responses between processes.\n+## Current Architecture\n \n-## Installation\n+The current system features two primary executables: `bitcoind` and `bitcoin-qt`. `bitcoind` combines a Bitcoin P2P node with an integrated JSON-RPC server, wallet, and indexes. `bitcoin-qt` extends this by incorporating a Qt-based GUI. This monolithic structure, although robust, presents challenges such as limited operational flexibility and increased security risks due to the tight integration of components.\n \n-The multiprocess feature requires [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) as dependencies. A simple way to get starting using it without installing these dependencies manually is to use the [depends system](../../depends) with the `MULTIPROCESS=1` [dependency option](../../depends#dependency-options) passed to make:\n+## Proposed Architecture\n \n+The new architecture divides the existing code into three specialized executables:\n+\n+- `bitcoin-node`: Manages the P2P node, indexes, and JSON-RPC server.\n+- `bitcoin-wallet`: Handles all wallet functionality.\n+- `bitcoin-gui`: Provides a standalone Qt-based GUI.\n+\n+This modular approach is designed to enhance security through component isolation and improve usability by allowing independent operation of each module. This allows for new use-cases, such as running the node on a dedicated machine and operating wallets and GUIs on separate machines with the flexibility to start and stop them as needed.\n+\n+This subdivision could be extended in the future. For example, indexes could be removed from the `bitcoin-node` executable and run in separate executables. And JSON-RPC servers could be added to wallet and index executables, so they can listen and respond to RPC requests on their own ports, without needing to forward RPC requests through `bitcoin-node`.\n+\n+<table><tr><td>\n+\n+```mermaid\n+flowchart LR\n+    node[bitcoin-node] -- listens on --> socket[\"&lt;datadir&gt;/node.sock\"]\n+    wallet[bitcoin-wallet] -- connects to --> socket\n+    gui[bitcoin-gui] -- connects to --> socket\n+```\n+\n+</td></tr><tr><td>\n+Processes and socket connection.\n+</td></tr></table>\n+\n+## Component Overview: Navigating the IPC Framework\n+\n+This section describes the major components of the Inter-Process Communication (IPC) framework covering the relevant source files, generated files, tools, and libraries.\n+\n+### Abstract C++ Classes in [`src/interfaces/`](../../src/interfaces/)\n+- The foundation of the IPC implementation lies in the abstract C++ classes within the [`src/interfaces/`](../../src/interfaces/) directory. These classes define pure virtual methods that code in [`src/node/`](../../src/node/), [`src/wallet/`](../../src/wallet/), and [`src/qt/`](../../src/qt/) directories call to interact with each other.\n+- Each abstract class in this directory represents a distinct interface that the different modules (node, wallet, GUI) implement and use for cross-process communication.\n+- The classes are written following conventions described in [Internal Interface\n+  Guidelines](../developer-notes.md#internal-interface-guidelines) to ensure\n+  compatibility with Cap'n Proto.\n+\n+### Cap’n Proto Files in [`src/ipc/capnp/`](../../src/ipc/capnp/)\n+- Corresponding to each abstract class, there are `.capnp` files within the [`src/ipc/capnp/`](../../src/ipc/capnp/) directory. These files are used as input to the `mpgen` tool (described below) to generate C++ code.\n+- These Cap’n Proto files ([learn more about Cap'n Proto RPC](https://capnproto.org/rpc.html)) define the structure and format of messages that are exchanged over IPC. They serve as blueprints for generating C++ code that bridges the gap between high-level C++ interfaces and low-level socket communication.\n+\n+### The `mpgen` Code Generation Tool\n+- A central component of the IPC framework is the `mpgen` tool which is part the [`libmultiprocess` project](https://github.com/chaincodelabs/libmultiprocess). This tool takes the `.capnp` files as input and generates C++ code.\n+- The generated code handles IPC communication, translating interface calls into socket reads and writes.\n+\n+### C++ Client Subclasses in Generated Code\n+- In the generated code, we have C++ client subclasses that inherit from the abstract classes in [`src/interfaces/`](../../src/interfaces/). These subclasses are the workhorses of the IPC mechanism.\n+- They implement all the methods of the interface, marshalling arguments into a structured format, sending them as requests to the IPC server via a UNIX socket, and handling the responses.\n+- These subclasses effectively mask the complexity of IPC, presenting a familiar C++ interface to developers.\n+- Internally, the client subclasses generated by the `mpgen` tool wrap [client classes generated by Cap'n Proto](https://capnproto.org/cxxrpc.html#clients), and use them to send IPC requests.\n+\n+### C++ Server Classes in Generated Code\n+- On the server side, corresponding generated C++ classes receive IPC requests. These server classes are responsible for unmarshalling method arguments, invoking the corresponding methods in the local [`src/interfaces/`](../../src/interfaces/) objects, and creating the IPC response.\n+- The server classes ensure that return values (including output argument values and thrown exceptions) are marshalled and sent back to the client, completing the communication cycle.\n+- Internally, the server subclasses generated by the `mpgen` tool inherit from [server classes generated by Cap'n Proto](https://capnproto.org/cxxrpc.html#servers), and use them to process IPC requests.\n+\n+### The `libmultiprocess` Runtime Library\n+- **Core Functionality**: The `libmultiprocess` runtime library's primary function is to instantiate the generated client and server classes as needed.\n+- **Bootstrapping IPC Connections**: It provides functions for starting new IPC connections, specifically binding generated client and server classes for an initial `interfaces::Init` interface (defined in [`src/interfaces/init.h`](../../src/interfaces/init.h)) to a UNIX socket. This initial interface has methods returning other interfaces that different Bitcoin Core modules use to communicate after the bootstrapping phase.\n+- **Asynchronous I/O and Thread Management**: The library is also responsible for managing I/O and threading. Particularly, it ensures that IPC requests never block each other and that new threads on either side of a connection can always make client calls. It also manages worker threads on the server side of calls, ensuring that calls from the same client thread always execute on the same server thread (to avoid locking issues and support nested callbacks).\n+\n+### Type Hooks in [`src/ipc/capnp/*-types.h`](../../src/ipc/capnp/)\n+- **Custom Type Conversions**: In [`src/ipc/capnp/*-types.h`](../../src/ipc/capnp/), function overloads of two `libmultiprocess` C++ functions, `mp::CustomReadField` and `mp::CustomBuildFields`, are defined. These overloads are used for customizing the conversion of specific C++ types to and from Cap’n Proto types.\n+- **Handling Special Cases**: The `mpgen` tool and `libmultiprocess` library can convert most C++ types to and from Cap’n Proto types automatically, including interface types, primitive C++ types, standard C++ types like `std::vector`, `std::set`, `std::map`, `std::tuple`, and `std::function`, as well as simple C++ structs that consist of aforementioned types and whose fields correspond 1:1 with Cap’n Proto struct fields. For other types, `*-types.h` files provide custom code to convert between C++ and Cap’n Proto data representations.\n+\n+### Protocol-Agnostic IPC Code in [`src/ipc/`](../../src/ipc/)\n+- **Broad Applicability**: Unlike the Cap’n Proto-specific code in [`src/ipc/capnp/`](../../src/ipc/capnp/), the code in the [`src/ipc/`](../../src/ipc/) directory is protocol-agnostic. This enables potential support for other protocols, such as gRPC or a custom protocol in the future.\n+- **Process Management and Socket Operations**: The main purpose of this component is to provide functions for spawning new processes and creating and connecting to UNIX sockets.\n+- **ipc::Exception Class**: This code also defines an `ipc::Exception` class which is thrown from the generated C++ client class methods when there is an unexpected IPC error, such as a disconnection.\n+\n+<table><tr><td>\n+\n+```mermaid\n+flowchart TD\n+    capnpFile[ipc/capnp/chain.capnp] -->|Input to| mpgenTool([mpgen Tool])\n+    mpgenTool -->|Generates| proxyTypesH[ipc/capnp/chain.capnp.proxy-types.h]\n+    mpgenTool --> proxyClientCpp[ipc/capnp/chain.capnp.proxy-client.c++]\n+    mpgenTool --> proxyServerCpp[ipc/capnp/chain.capnp.proxy-server.c++]\n+    proxyTypesH -.->|Includes| interfaces/chain.h\n+    proxyClientCpp -.-> interfaces/chain.h\n+    proxyServerCpp -.-> interfaces/chain.h\n ```\n-cd <BITCOIN_SOURCE_DIRECTORY>\n-make -C depends NO_QT=1 MULTIPROCESS=1\n-CONFIG_SITE=$PWD/depends/x86_64-pc-linux-gnu/share/config.site ./configure\n-make\n-src/bitcoin-node -regtest -printtoconsole -debug=ipc\n-BITCOIND=bitcoin-node test/functional/test_runner.py\n+\n+</td></tr><tr><td>\n+Diagram showing generated source files and includes.\n+</td></tr></table>\n+\n+## Design Considerations\n+\n+### Selection of Cap’n Proto\n+The choice to use [Cap’n Proto](https://capnproto.org/) for IPC was primarily influenced by its support for passing object references and managing object lifetimes, which would have to be implemented manually with a framework that only supported plain requests and responses like [gRPC](https://grpc.io/). The support is especially helpful for passing callback objects like `std::function` and enabling bidirectional calls between processes.\n+\n+The choice to use an RPC framework at all instead of a custom protocol was necessitated by the size of Bitcoin Core internal interfaces which consist of around 150 methods that pass complex data structures and are called in complicated ways (in parallel, and from callbacks that can be nested and stored). Writing a custom protocol to wrap these complicated interfaces would be a lot more work, akin to writing a new RPC framework.\n+\n+### Hiding IPC\n+\n+The IPC mechanism is deliberately isolated from the rest of the codebase so less code has to be concerned with IPC.\n+\n+Building Bitcoin Core with IPC support is optional, and node, wallet, and GUI code can be compiled to either run in the same process or separate processes. The build system also ensures Cap’n Proto library headers can only be used within the [`src/ipc/capnp/`](../../src/ipc/capnp/) directory, not in other parts of the codebase.\n+\n+The libmultiprocess runtime is designed to place as few constraints as possible on IPC interfaces and to make IPC calls act like normal function calls. Method arguments, return values, and exceptions are automatically serialized and sent between processes. Object references and `std::function` arguments are tracked to allow invoked code to call back into invoking code at any time. And there is a 1:1 threading model where every client thread has a corresponding server thread responsible for executing incoming calls from that thread (there can be multiple calls from the same thread due to callbacks) without blocking, and holding the same thread-local variables and locks so behavior is the same whether IPC is used or not.\n+\n+### Interface Definition Maintenance\n+\n+The choice to maintain interface definitions and C++ type mappings as `.capnp` files in the [`src/ipc/capnp/`](../../src/ipc/capnp/) was mostly done for convenience, and probably something that could be improved in the future.\n+\n+In the current design, class names, method names, and parameter names are duplicated between C++ interfaces in [`src/interfaces/`](../../src/interfaces/) and Cap’n Proto files in [`src/ipc/capnp/`](../../src/ipc/capnp/). While this keeps C++ interface headers simple and free of references to IPC, it is a maintenance burden because it means inconsistencies between C++ declarations and Cap’n Proto declarations will result in compile errors. (Static type checking ensures these are not runtime errors.)\n+\n+An alternate approach could use custom [C++ Attributes](https://en.cppreference.com/w/cpp/language/attributes) embedded in interface declarations to automatically generate `.capnp` files from C++ headers. This has not been pursued because parsing C++ headers is more complicated than parsing Cap’n Proto interface definitions, especially portably on multiple platforms.\n+\n+In the meantime, the developer guide [Internal interface guidelines](developer-notes.md#internal-interface-guidelines) can provide guidance on keeping interfaces consistent and functional and avoiding compile errors.\n+\n+### Interface Stability\n+\n+The currently defined IPC interfaces are unstable, and can change freely with no backwards compatibility. The decision to allow this stems from the recognition that our current interfaces are still evolving and not yet ideal for external use. As these interfaces mature and become more refined, there may be an opportunity to declare them stable and use Cap’n Proto's support for protocol evolution ([Cap'n Proto - Evolving Your Protocol](https://capnproto.org/language.html#evolving-your-protocol)) to allow them to be extended while remaining backwards compatible. This could allow different versions of node, GUI, and wallet binaries to interoperate, and potentially open doors for external tools to utilize these interfaces, such as creating custom indexes through a stable indexing interface. However, for now, the priority is to improve the interfaces internally. Given their current state and the advantages of using JSON-RPC for most common tasks, it's more practical to focus on internal development rather than external applicability.\n+\n+## Security Considerations\n+\n+The integration of [Cap’n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) into the Bitcoin Core architecture increases its potential attack surface. Cap’n Proto, being a complex and substantial new dependency, introduces potential sources of vulnerability, particularly through the creation of new UNIX sockets. The inclusion of libmultiprocess, while a smaller external dependency, also contributes to this risk. However, plans are underway to incorporate libmultiprocess as a git subtree, aligning it more closely with the project's well-reviewed internal libraries. While adopting these multiprocess features does introduce some risk, it's worth noting that they can be disabled, allowing builds without these new dependencies. This flexibility ensures that users can balance functionality with security considerations as needed.\n+\n+## Example Use Cases and Flows\n+\n+### Retrieving a Block Hash\n+\n+Let’s walk through an example where the `bitcoin-wallet` process requests the hash of a block at a specific height from the `bitcoin-node` process. This example demonstrates the practical application of the IPC mechanism, specifically the interplay between C++ method calls and Cap’n Proto-generated RPC calls.\n+\n+```mermaid\n+sequenceDiagram\n+    box \"bitcoin-wallet process\"\n+    participant WalletCode as Wallet code\n+    participant ChainClient as Generated Chain client class<br/>ProxyClient<messages::Chain>\n+    end\n+    box \"bitcoin-node process\"\n+    participant ChainServer as Generated Chain server class<br/>ProxyServer<messages::Chain>\n+    participant LocalChain as Chain object<br/>node::ChainImpl\n+    end\n+\n+    WalletCode->>ChainClient: getBlockHash(height)\n+    ChainClient->>ChainServer: Send RPC getBlockHash request\n+    ChainServer->>LocalChain: getBlockHash(height)\n+    LocalChain->>ChainServer: Return block hash\n+    ChainServer->>ChainClient: Send response with block hash\n+    ChainClient->>WalletCode: Return block hash\n ```\n \n-The configure script will pick up settings and library locations from the depends directory, so there is no need to pass `--enable-multiprocess` as a separate flag when using the depends system (it's controlled by the `MULTIPROCESS=1` option).\n-\n-Alternately, you can install [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) packages on your system, and just run `./configure --enable-multiprocess` without using the depends system. The configure script will be able to locate the installed packages via [pkg-config](https://www.freedesktop.org/wiki/Software/pkg-config/). See [Installation](https://github.com/chaincodelabs/libmultiprocess/blob/master/doc/install.md) section of the libmultiprocess readme for install steps. See [build-unix.md](../build-unix.md) and [build-osx.md](../build-osx.md) for information about installing dependencies in general.\n-\n-## IPC implementation details\n-\n-Cross process Node, Wallet, and Chain interfaces are defined in\n-[`src/interfaces/`](../../src/interfaces/). These are C++ classes which follow\n-[conventions](../developer-notes.md#internal-interface-guidelines), like passing\n-serializable arguments so they can be called from different processes, and\n-making methods pure virtual so they can have proxy implementations that forward\n-calls between processes.\n-\n-When Wallet, Node, and Chain code is running in the same process, calling any\n-interface method invokes the implementation directly. When code is running in\n-different processes, calling an interface method invokes a proxy interface\n-implementation that communicates with a remote process and invokes the real\n-implementation in the remote process. The\n-[libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) code\n-generation tool internally generates proxy client classes and proxy server\n-classes for this purpose that are thin wrappers around Cap'n Proto\n-[client](https://capnproto.org/cxxrpc.html#clients) and\n-[server](https://capnproto.org/cxxrpc.html#servers) classes, which handle the\n-actual serialization and socket communication.\n-\n-As much as possible, calls between processes are meant to work the same as\n-calls within a single process without adding limitations or requiring extra\n-implementation effort. Processes communicate with each other by calling regular\n-[C++ interface methods](../../src/interfaces/README.md). Method arguments and\n-return values are automatically serialized and sent between processes. Object\n-references and `std::function` arguments are automatically tracked and mapped\n-to allow invoked code to call back into invoking code at any time, and there is\n-a 1:1 threading model where any thread invoking a method in another process has\n-a corresponding thread in the invoked process responsible for executing all\n-method calls from the source thread, without blocking I/O or holding up another\n-call, and using the same thread local variables, locks, and callbacks between\n-calls. The forwarding, tracking, and threading is implemented inside the\n-[libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) library\n-which has the design goal of making calls between processes look like calls in\n-the same process to the extent possible.\n+</td></tr><tr><td>\n+<code>Chain::getBlockHash</code> call diagram\n+</td></tr></table>\n+\n+1. **Initiation in bitcoin-wallet**\n+   - The wallet process calls the `getBlockHash` method on a `Chain` object. This method is defined as a virtual method in [`src/interfaces/chain.h`](../../src/interfaces/chain.h).\n+\n+2. **Translation to Cap’n Proto RPC**\n+   - The `Chain::getBlockHash` virtual method is overridden by the `Chain` [client subclass](#c-client-subclasses-in-generated-code) to translate the method call into a Cap’n Proto RPC call.\n+   - The client subclass is automatically generated by the `mpgen` tool from the [`chain.capnp`](https://github.com/ryanofsky/bitcoin/blob/pr/ipc/src/ipc/capnp/chain.capnp) file in [`src/ipc/capnp/`](../../src/ipc/capnp/).\n+\n+3. **Request Preparation and Dispatch**\n+   - The `getBlockHash` method of the generated `Chain` client subclass in `bitcoin-wallet` populates a Cap’n Proto request with the `height` parameter, sends it to `bitcoin-node` process, and waits for a response.\n+\n+4. **Handling in bitcoin-node**\n+   - Upon receiving the request, the Cap'n Proto dispatching code in the `bitcoin-node` process calls the `getBlockHash` method of the `Chain` [server class](#c-server-classes-in-generated-code).\n+   - The server class is automatically generated by the `mpgen` tool from the [`chain.capnp`](https://github.com/ryanofsky/bitcoin/blob/pr/ipc/src/ipc/capnp/chain.capnp) file in [`src/ipc/capnp/`](../../src/ipc/capnp/).\n+   - The `getBlockHash` method of the generated `Chain` server subclass in `bitcoin-wallet` receives a Cap’n Proto request object with the `height` parameter, and calls the `getBlockHash` method on its local `Chain` object with the provided `height`.\n+   - When the call returns, it encapsulates the return value in a Cap’n Proto response, which it sends back to the `bitcoin-wallet` process,\n+\n+5. **Response and Return**\n+   - The `getBlockHash` method of the generated `Chain` client subclass in `bitcoin-wallet` which sent the request now receives the response.\n+   - It extracts the block hash value from the response, and returns it to the original caller.\n+\n+<table><tr><td>",
      "path": "doc/design/multiprocess.md",
      "position": null,
      "original_position": 263,
      "commit_id": "91dc48c14825a9075a57c1eefda202b83b6346ba",
      "original_commit_id": "c80bd16c826d564086006cff67b7b9ade9b9f38c",
      "in_reply_to_id": 1433109875,
      "user": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> I think you meant to close/end the table here. Otherwise this looks a bit weird rendered on GitHub.\r\n\r\nGood catch should be fixed now",
      "created_at": "2023-12-27T04:20:45Z",
      "updated_at": "2023-12-27T04:33:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28978#discussion_r1436732897",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1436732897"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28978"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 204,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1439417050",
      "pull_request_review_id": 1800375604,
      "id": 1439417050,
      "node_id": "PRRC_kwDOABII585Vy8La",
      "diff_hunk": "@@ -0,0 +1,34 @@\n+# Multiprocess Bitcoin\n+\n+_This document describes usage of the multiprocess feature. For design information, see the [design/multiprocess.md](design/multiprocess.md) file._\n+\n+## Build Option\n+\n+On unix systems, the `--enable-multiprocess` build option can be passed to `./configure` to build new `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables alongside existing `bitcoind` and `bitcoin-qt` executables.\n+\n+## Debugging\n+\n+The `-debug=ipc` command line option can be used to see requests and responses between processes.\n+\n+## Installation\n+\n+The multiprocess feature requires [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) as dependencies. A simple way to get started using it without installing these dependencies manually is to use the [depends system](../depends) with the `MULTIPROCESS=1` [dependency option](../depends#dependency-options) passed to make:\n+\n+```\n+cd <BITCOIN_SOURCE_DIRECTORY>\n+make -C depends NO_QT=1 MULTIPROCESS=1\n+CONFIG_SITE=$PWD/depends/x86_64-pc-linux-gnu/share/config.site ./configure",
      "path": "doc/multiprocess.md",
      "position": 20,
      "original_position": 20,
      "commit_id": "91dc48c14825a9075a57c1eefda202b83b6346ba",
      "original_commit_id": "91dc48c14825a9075a57c1eefda202b83b6346ba",
      "in_reply_to_id": null,
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: Perhaps useful to parameterize the host platform to highlight it's configurable? E.g.\r\n\r\n```sh\r\nHOST_PLATFORM=\"x86_64-pc-linux-gnu\"\r\ncd <BITCOIN_SOURCE_DIRECTORY>\r\nmake -C depends NO_QT=1 MULTIPROCESS=1\r\nCONFIG_SITE=$PWD/depends/$HOST_PLATFORM/share/config.site ./configure\r\n```",
      "created_at": "2024-01-02T12:44:51Z",
      "updated_at": "2024-01-02T14:05:11Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28978#discussion_r1439417050",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1439417050"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28978"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 20,
      "original_line": 20,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1439431086",
      "pull_request_review_id": 1800375604,
      "id": 1439431086,
      "node_id": "PRRC_kwDOABII585Vy_mu",
      "diff_hunk": "@@ -1,72 +1,264 @@\n-# Multiprocess Bitcoin\n+# Multiprocess Bitcoin Design Document\n \n-On unix systems, the `--enable-multiprocess` build option can be passed to `./configure` to build new `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables alongside existing `bitcoind` and `bitcoin-qt` executables.\n+Guide to the design and architecture of the Bitcoin Core multiprocess feature\n \n-`bitcoin-node` is a drop-in replacement for `bitcoind`, and `bitcoin-gui` is a drop-in replacement for `bitcoin-qt`, and there are no differences in use or external behavior between the new and old executables. But internally (after [#10102](https://github.com/bitcoin/bitcoin/pull/10102)), `bitcoin-gui` will spawn a `bitcoin-node` process to run P2P and RPC code, communicating with it across a socket pair, and `bitcoin-node` will spawn `bitcoin-wallet` to run wallet code, also communicating over a socket pair. This will let node, wallet, and GUI code run in separate address spaces for better isolation, and allow future improvements like being able to start and stop components independently on different machines and environments.\n+_This document describes the design of the multiprocess feature. For usage information, see the top-level [multiprocess.md](../multiprocess.md) file._\n \n-## Next steps\n+## Table of contents\n \n-Specific next steps after [#10102](https://github.com/bitcoin/bitcoin/pull/10102) will be:\n+- [Introduction](#introduction)\n+- [Current Architecture](#current-architecture)\n+- [Proposed Architecture](#proposed-architecture)\n+- [Component Overview: Navigating the IPC Framework](#component-overview-navigating-the-ipc-framework)\n+- [Design Considerations](#design-considerations)\n+  - [Selection of Cap’n Proto](#selection-of-capn-proto)\n+  - [Hiding IPC](#hiding-ipc)\n+  - [Interface Definition Maintenance](#interface-definition-maintenance)\n+  - [Interface Stability](#interface-stability)\n+- [Security Considerations](#security-considerations)\n+- [Example Use Cases and Flows](#example-use-cases-and-flows)\n+  - [Retrieving a Block Hash](#retrieving-a-block-hash)\n+- [Future Enhancements](#future-enhancements)\n+- [Conclusion](#conclusion)\n+- [Appendices](#appendices)\n+  - [Glossary of Terms](#glossary-of-terms)\n+  - [References](#references)\n+- [Acknowledgements](#acknowledgements)\n \n-- [ ] Adding `-ipcbind` and `-ipcconnect` options to `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables so they can listen and connect to TCP ports and unix socket paths. This will allow separate processes to be started and stopped any time and connect to each other.\n-- [ ] Adding `-server` and `-rpcbind` options to the `bitcoin-wallet` executable so wallet processes can handle RPC requests directly without going through the node.\n-- [ ] Supporting windows, not just unix systems. The existing socket code is already cross-platform, so the only windows-specific code that needs to be written is code spawning a process and passing a socket descriptor. This can be implemented with `CreateProcess` and `WSADuplicateSocket`. Example: https://memset.wordpress.com/2010/10/13/win32-api-passing-socket-with-ipc-method/.\n-- [ ] Adding sandbox features, restricting subprocess access to resources and data. See [https://eklitzke.org/multiprocess-bitcoin](https://eklitzke.org/multiprocess-bitcoin).\n+## Introduction\n \n-## Debugging\n+The Bitcoin Core software has historically employed a monolithic architecture. The existing design has integrated functionality like P2P network operations, wallet management, and a GUI into a single executable. While effective, it has limitations in flexibility, security, and scalability. This project introduces changes that transition Bitcoin Core to a more modular architecture. It aims to enhance security, improve usability, and facilitate maintenance and development of the software in the long run.\n \n-The `-debug=ipc` command line option can be used to see requests and responses between processes.\n+## Current Architecture\n \n-## Installation\n+The current system features two primary executables: `bitcoind` and `bitcoin-qt`. `bitcoind` combines a Bitcoin P2P node with an integrated JSON-RPC server, wallet, and indexes. `bitcoin-qt` extends this by incorporating a Qt-based GUI. This monolithic structure, although robust, presents challenges such as limited operational flexibility and increased security risks due to the tight integration of components.\n \n-The multiprocess feature requires [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) as dependencies. A simple way to get starting using it without installing these dependencies manually is to use the [depends system](../../depends) with the `MULTIPROCESS=1` [dependency option](../../depends#dependency-options) passed to make:\n+## Proposed Architecture\n \n+The new architecture divides the existing code into three specialized executables:\n+\n+- `bitcoin-node`: Manages the P2P node, indexes, and JSON-RPC server.\n+- `bitcoin-wallet`: Handles all wallet functionality.\n+- `bitcoin-gui`: Provides a standalone Qt-based GUI.\n+\n+This modular approach is designed to enhance security through component isolation and improve usability by allowing independent operation of each module. This allows for new use-cases, such as running the node on a dedicated machine and operating wallets and GUIs on separate machines with the flexibility to start and stop them as needed.\n+\n+This subdivision could be extended in the future. For example, indexes could be removed from the `bitcoin-node` executable and run in separate executables. And JSON-RPC servers could be added to wallet and index executables, so they can listen and respond to RPC requests on their own ports, without needing to forward RPC requests through `bitcoin-node`.\n+\n+<table><tr><td>\n+\n+```mermaid\n+flowchart LR\n+    node[bitcoin-node] -- listens on --> socket[\"&lt;datadir&gt;/node.sock\"]\n+    wallet[bitcoin-wallet] -- connects to --> socket\n+    gui[bitcoin-gui] -- connects to --> socket\n+```\n+\n+</td></tr><tr><td>\n+Processes and socket connection.\n+</td></tr></table>\n+\n+## Component Overview: Navigating the IPC Framework\n+\n+This section describes the major components of the Inter-Process Communication (IPC) framework covering the relevant source files, generated files, tools, and libraries.\n+\n+### Abstract C++ Classes in [`src/interfaces/`](../../src/interfaces/)\n+- The foundation of the IPC implementation lies in the abstract C++ classes within the [`src/interfaces/`](../../src/interfaces/) directory. These classes define pure virtual methods that code in [`src/node/`](../../src/node/), [`src/wallet/`](../../src/wallet/), and [`src/qt/`](../../src/qt/) directories call to interact with each other.\n+- Each abstract class in this directory represents a distinct interface that the different modules (node, wallet, GUI) implement and use for cross-process communication.\n+- The classes are written following conventions described in [Internal Interface\n+  Guidelines](../developer-notes.md#internal-interface-guidelines) to ensure\n+  compatibility with Cap'n Proto.\n+\n+### Cap’n Proto Files in [`src/ipc/capnp/`](../../src/ipc/capnp/)\n+- Corresponding to each abstract class, there are `.capnp` files within the [`src/ipc/capnp/`](../../src/ipc/capnp/) directory. These files are used as input to the `mpgen` tool (described below) to generate C++ code.\n+- These Cap’n Proto files ([learn more about Cap'n Proto RPC](https://capnproto.org/rpc.html)) define the structure and format of messages that are exchanged over IPC. They serve as blueprints for generating C++ code that bridges the gap between high-level C++ interfaces and low-level socket communication.\n+\n+### The `mpgen` Code Generation Tool\n+- A central component of the IPC framework is the `mpgen` tool which is part the [`libmultiprocess` project](https://github.com/chaincodelabs/libmultiprocess). This tool takes the `.capnp` files as input and generates C++ code.\n+- The generated code handles IPC communication, translating interface calls into socket reads and writes.\n+\n+### C++ Client Subclasses in Generated Code\n+- In the generated code, we have C++ client subclasses that inherit from the abstract classes in [`src/interfaces/`](../../src/interfaces/). These subclasses are the workhorses of the IPC mechanism.\n+- They implement all the methods of the interface, marshalling arguments into a structured format, sending them as requests to the IPC server via a UNIX socket, and handling the responses.\n+- These subclasses effectively mask the complexity of IPC, presenting a familiar C++ interface to developers.\n+- Internally, the client subclasses generated by the `mpgen` tool wrap [client classes generated by Cap'n Proto](https://capnproto.org/cxxrpc.html#clients), and use them to send IPC requests.",
      "path": "doc/design/multiprocess.md",
      "position": 97,
      "original_position": 97,
      "commit_id": "91dc48c14825a9075a57c1eefda202b83b6346ba",
      "original_commit_id": "91dc48c14825a9075a57c1eefda202b83b6346ba",
      "in_reply_to_id": null,
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Perhaps useful to elaborate on what the `mpgen` wrapping adds to the Cap'n Proto output?",
      "created_at": "2024-01-02T13:03:43Z",
      "updated_at": "2024-01-02T14:05:11Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28978#discussion_r1439431086",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1439431086"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28978"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 84,
      "original_line": 84,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1439454381",
      "pull_request_review_id": 1800375604,
      "id": 1439454381,
      "node_id": "PRRC_kwDOABII585VzFSt",
      "diff_hunk": "@@ -1,72 +1,264 @@\n-# Multiprocess Bitcoin\n+# Multiprocess Bitcoin Design Document\n \n-On unix systems, the `--enable-multiprocess` build option can be passed to `./configure` to build new `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables alongside existing `bitcoind` and `bitcoin-qt` executables.\n+Guide to the design and architecture of the Bitcoin Core multiprocess feature\n \n-`bitcoin-node` is a drop-in replacement for `bitcoind`, and `bitcoin-gui` is a drop-in replacement for `bitcoin-qt`, and there are no differences in use or external behavior between the new and old executables. But internally (after [#10102](https://github.com/bitcoin/bitcoin/pull/10102)), `bitcoin-gui` will spawn a `bitcoin-node` process to run P2P and RPC code, communicating with it across a socket pair, and `bitcoin-node` will spawn `bitcoin-wallet` to run wallet code, also communicating over a socket pair. This will let node, wallet, and GUI code run in separate address spaces for better isolation, and allow future improvements like being able to start and stop components independently on different machines and environments.\n+_This document describes the design of the multiprocess feature. For usage information, see the top-level [multiprocess.md](../multiprocess.md) file._\n \n-## Next steps\n+## Table of contents\n \n-Specific next steps after [#10102](https://github.com/bitcoin/bitcoin/pull/10102) will be:\n+- [Introduction](#introduction)\n+- [Current Architecture](#current-architecture)\n+- [Proposed Architecture](#proposed-architecture)\n+- [Component Overview: Navigating the IPC Framework](#component-overview-navigating-the-ipc-framework)\n+- [Design Considerations](#design-considerations)\n+  - [Selection of Cap’n Proto](#selection-of-capn-proto)\n+  - [Hiding IPC](#hiding-ipc)\n+  - [Interface Definition Maintenance](#interface-definition-maintenance)\n+  - [Interface Stability](#interface-stability)\n+- [Security Considerations](#security-considerations)\n+- [Example Use Cases and Flows](#example-use-cases-and-flows)\n+  - [Retrieving a Block Hash](#retrieving-a-block-hash)\n+- [Future Enhancements](#future-enhancements)\n+- [Conclusion](#conclusion)\n+- [Appendices](#appendices)\n+  - [Glossary of Terms](#glossary-of-terms)\n+  - [References](#references)\n+- [Acknowledgements](#acknowledgements)\n \n-- [ ] Adding `-ipcbind` and `-ipcconnect` options to `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables so they can listen and connect to TCP ports and unix socket paths. This will allow separate processes to be started and stopped any time and connect to each other.\n-- [ ] Adding `-server` and `-rpcbind` options to the `bitcoin-wallet` executable so wallet processes can handle RPC requests directly without going through the node.\n-- [ ] Supporting windows, not just unix systems. The existing socket code is already cross-platform, so the only windows-specific code that needs to be written is code spawning a process and passing a socket descriptor. This can be implemented with `CreateProcess` and `WSADuplicateSocket`. Example: https://memset.wordpress.com/2010/10/13/win32-api-passing-socket-with-ipc-method/.\n-- [ ] Adding sandbox features, restricting subprocess access to resources and data. See [https://eklitzke.org/multiprocess-bitcoin](https://eklitzke.org/multiprocess-bitcoin).\n+## Introduction\n \n-## Debugging\n+The Bitcoin Core software has historically employed a monolithic architecture. The existing design has integrated functionality like P2P network operations, wallet management, and a GUI into a single executable. While effective, it has limitations in flexibility, security, and scalability. This project introduces changes that transition Bitcoin Core to a more modular architecture. It aims to enhance security, improve usability, and facilitate maintenance and development of the software in the long run.\n \n-The `-debug=ipc` command line option can be used to see requests and responses between processes.\n+## Current Architecture\n \n-## Installation\n+The current system features two primary executables: `bitcoind` and `bitcoin-qt`. `bitcoind` combines a Bitcoin P2P node with an integrated JSON-RPC server, wallet, and indexes. `bitcoin-qt` extends this by incorporating a Qt-based GUI. This monolithic structure, although robust, presents challenges such as limited operational flexibility and increased security risks due to the tight integration of components.\n \n-The multiprocess feature requires [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) as dependencies. A simple way to get starting using it without installing these dependencies manually is to use the [depends system](../../depends) with the `MULTIPROCESS=1` [dependency option](../../depends#dependency-options) passed to make:\n+## Proposed Architecture\n \n+The new architecture divides the existing code into three specialized executables:\n+\n+- `bitcoin-node`: Manages the P2P node, indexes, and JSON-RPC server.\n+- `bitcoin-wallet`: Handles all wallet functionality.\n+- `bitcoin-gui`: Provides a standalone Qt-based GUI.\n+\n+This modular approach is designed to enhance security through component isolation and improve usability by allowing independent operation of each module. This allows for new use-cases, such as running the node on a dedicated machine and operating wallets and GUIs on separate machines with the flexibility to start and stop them as needed.\n+\n+This subdivision could be extended in the future. For example, indexes could be removed from the `bitcoin-node` executable and run in separate executables. And JSON-RPC servers could be added to wallet and index executables, so they can listen and respond to RPC requests on their own ports, without needing to forward RPC requests through `bitcoin-node`.\n+\n+<table><tr><td>\n+\n+```mermaid\n+flowchart LR\n+    node[bitcoin-node] -- listens on --> socket[\"&lt;datadir&gt;/node.sock\"]\n+    wallet[bitcoin-wallet] -- connects to --> socket\n+    gui[bitcoin-gui] -- connects to --> socket\n+```\n+\n+</td></tr><tr><td>\n+Processes and socket connection.\n+</td></tr></table>\n+\n+## Component Overview: Navigating the IPC Framework\n+\n+This section describes the major components of the Inter-Process Communication (IPC) framework covering the relevant source files, generated files, tools, and libraries.\n+\n+### Abstract C++ Classes in [`src/interfaces/`](../../src/interfaces/)\n+- The foundation of the IPC implementation lies in the abstract C++ classes within the [`src/interfaces/`](../../src/interfaces/) directory. These classes define pure virtual methods that code in [`src/node/`](../../src/node/), [`src/wallet/`](../../src/wallet/), and [`src/qt/`](../../src/qt/) directories call to interact with each other.\n+- Each abstract class in this directory represents a distinct interface that the different modules (node, wallet, GUI) implement and use for cross-process communication.\n+- The classes are written following conventions described in [Internal Interface\n+  Guidelines](../developer-notes.md#internal-interface-guidelines) to ensure\n+  compatibility with Cap'n Proto.\n+\n+### Cap’n Proto Files in [`src/ipc/capnp/`](../../src/ipc/capnp/)\n+- Corresponding to each abstract class, there are `.capnp` files within the [`src/ipc/capnp/`](../../src/ipc/capnp/) directory. These files are used as input to the `mpgen` tool (described below) to generate C++ code.\n+- These Cap’n Proto files ([learn more about Cap'n Proto RPC](https://capnproto.org/rpc.html)) define the structure and format of messages that are exchanged over IPC. They serve as blueprints for generating C++ code that bridges the gap between high-level C++ interfaces and low-level socket communication.\n+\n+### The `mpgen` Code Generation Tool\n+- A central component of the IPC framework is the `mpgen` tool which is part the [`libmultiprocess` project](https://github.com/chaincodelabs/libmultiprocess). This tool takes the `.capnp` files as input and generates C++ code.\n+- The generated code handles IPC communication, translating interface calls into socket reads and writes.\n+\n+### C++ Client Subclasses in Generated Code\n+- In the generated code, we have C++ client subclasses that inherit from the abstract classes in [`src/interfaces/`](../../src/interfaces/). These subclasses are the workhorses of the IPC mechanism.\n+- They implement all the methods of the interface, marshalling arguments into a structured format, sending them as requests to the IPC server via a UNIX socket, and handling the responses.\n+- These subclasses effectively mask the complexity of IPC, presenting a familiar C++ interface to developers.\n+- Internally, the client subclasses generated by the `mpgen` tool wrap [client classes generated by Cap'n Proto](https://capnproto.org/cxxrpc.html#clients), and use them to send IPC requests.\n+\n+### C++ Server Classes in Generated Code\n+- On the server side, corresponding generated C++ classes receive IPC requests. These server classes are responsible for unmarshalling method arguments, invoking the corresponding methods in the local [`src/interfaces/`](../../src/interfaces/) objects, and creating the IPC response.\n+- The server classes ensure that return values (including output argument values and thrown exceptions) are marshalled and sent back to the client, completing the communication cycle.\n+- Internally, the server subclasses generated by the `mpgen` tool inherit from [server classes generated by Cap'n Proto](https://capnproto.org/cxxrpc.html#servers), and use them to process IPC requests.\n+\n+### The `libmultiprocess` Runtime Library\n+- **Core Functionality**: The `libmultiprocess` runtime library's primary function is to instantiate the generated client and server classes as needed.\n+- **Bootstrapping IPC Connections**: It provides functions for starting new IPC connections, specifically binding generated client and server classes for an initial `interfaces::Init` interface (defined in [`src/interfaces/init.h`](../../src/interfaces/init.h)) to a UNIX socket. This initial interface has methods returning other interfaces that different Bitcoin Core modules use to communicate after the bootstrapping phase.\n+- **Asynchronous I/O and Thread Management**: The library is also responsible for managing I/O and threading. Particularly, it ensures that IPC requests never block each other and that new threads on either side of a connection can always make client calls. It also manages worker threads on the server side of calls, ensuring that calls from the same client thread always execute on the same server thread (to avoid locking issues and support nested callbacks).\n+\n+### Type Hooks in [`src/ipc/capnp/*-types.h`](../../src/ipc/capnp/)\n+- **Custom Type Conversions**: In [`src/ipc/capnp/*-types.h`](../../src/ipc/capnp/), function overloads of two `libmultiprocess` C++ functions, `mp::CustomReadField` and `mp::CustomBuildFields`, are defined. These overloads are used for customizing the conversion of specific C++ types to and from Cap’n Proto types.\n+- **Handling Special Cases**: The `mpgen` tool and `libmultiprocess` library can convert most C++ types to and from Cap’n Proto types automatically, including interface types, primitive C++ types, standard C++ types like `std::vector`, `std::set`, `std::map`, `std::tuple`, and `std::function`, as well as simple C++ structs that consist of aforementioned types and whose fields correspond 1:1 with Cap’n Proto struct fields. For other types, `*-types.h` files provide custom code to convert between C++ and Cap’n Proto data representations.\n+\n+### Protocol-Agnostic IPC Code in [`src/ipc/`](../../src/ipc/)\n+- **Broad Applicability**: Unlike the Cap’n Proto-specific code in [`src/ipc/capnp/`](../../src/ipc/capnp/), the code in the [`src/ipc/`](../../src/ipc/) directory is protocol-agnostic. This enables potential support for other protocols, such as gRPC or a custom protocol in the future.\n+- **Process Management and Socket Operations**: The main purpose of this component is to provide functions for spawning new processes and creating and connecting to UNIX sockets.\n+- **ipc::Exception Class**: This code also defines an `ipc::Exception` class which is thrown from the generated C++ client class methods when there is an unexpected IPC error, such as a disconnection.\n+\n+<table><tr><td>\n+\n+```mermaid\n+flowchart TD\n+    capnpFile[ipc/capnp/chain.capnp] -->|Input to| mpgenTool([mpgen Tool])\n+    mpgenTool -->|Generates| proxyTypesH[ipc/capnp/chain.capnp.proxy-types.h]\n+    mpgenTool --> proxyClientCpp[ipc/capnp/chain.capnp.proxy-client.c++]\n+    mpgenTool --> proxyServerCpp[ipc/capnp/chain.capnp.proxy-server.c++]\n+    proxyTypesH -.->|Includes| interfaces/chain.h\n+    proxyClientCpp -.-> interfaces/chain.h\n+    proxyServerCpp -.-> interfaces/chain.h\n ```\n-cd <BITCOIN_SOURCE_DIRECTORY>\n-make -C depends NO_QT=1 MULTIPROCESS=1\n-CONFIG_SITE=$PWD/depends/x86_64-pc-linux-gnu/share/config.site ./configure\n-make\n-src/bitcoin-node -regtest -printtoconsole -debug=ipc\n-BITCOIND=bitcoin-node test/functional/test_runner.py\n+\n+</td></tr><tr><td>\n+Diagram showing generated source files and includes.\n+</td></tr></table>\n+\n+## Design Considerations\n+\n+### Selection of Cap’n Proto\n+The choice to use [Cap’n Proto](https://capnproto.org/) for IPC was primarily influenced by its support for passing object references and managing object lifetimes, which would have to be implemented manually with a framework that only supported plain requests and responses like [gRPC](https://grpc.io/). The support is especially helpful for passing callback objects like `std::function` and enabling bidirectional calls between processes.\n+\n+The choice to use an RPC framework at all instead of a custom protocol was necessitated by the size of Bitcoin Core internal interfaces which consist of around 150 methods that pass complex data structures and are called in complicated ways (in parallel, and from callbacks that can be nested and stored). Writing a custom protocol to wrap these complicated interfaces would be a lot more work, akin to writing a new RPC framework.\n+\n+### Hiding IPC\n+\n+The IPC mechanism is deliberately isolated from the rest of the codebase so less code has to be concerned with IPC.\n+\n+Building Bitcoin Core with IPC support is optional, and node, wallet, and GUI code can be compiled to either run in the same process or separate processes. The build system also ensures Cap’n Proto library headers can only be used within the [`src/ipc/capnp/`](../../src/ipc/capnp/) directory, not in other parts of the codebase.\n+\n+The libmultiprocess runtime is designed to place as few constraints as possible on IPC interfaces and to make IPC calls act like normal function calls. Method arguments, return values, and exceptions are automatically serialized and sent between processes. Object references and `std::function` arguments are tracked to allow invoked code to call back into invoking code at any time. And there is a 1:1 threading model where every client thread has a corresponding server thread responsible for executing incoming calls from that thread (there can be multiple calls from the same thread due to callbacks) without blocking, and holding the same thread-local variables and locks so behavior is the same whether IPC is used or not.\n+\n+### Interface Definition Maintenance\n+\n+The choice to maintain interface definitions and C++ type mappings as `.capnp` files in the [`src/ipc/capnp/`](../../src/ipc/capnp/) was mostly done for convenience, and probably something that could be improved in the future.\n+\n+In the current design, class names, method names, and parameter names are duplicated between C++ interfaces in [`src/interfaces/`](../../src/interfaces/) and Cap’n Proto files in [`src/ipc/capnp/`](../../src/ipc/capnp/). While this keeps C++ interface headers simple and free of references to IPC, it is a maintenance burden because it means inconsistencies between C++ declarations and Cap’n Proto declarations will result in compile errors. (Static type checking ensures these are not runtime errors.)\n+\n+An alternate approach could use custom [C++ Attributes](https://en.cppreference.com/w/cpp/language/attributes) embedded in interface declarations to automatically generate `.capnp` files from C++ headers. This has not been pursued because parsing C++ headers is more complicated than parsing Cap’n Proto interface definitions, especially portably on multiple platforms.\n+\n+In the meantime, the developer guide [Internal interface guidelines](developer-notes.md#internal-interface-guidelines) can provide guidance on keeping interfaces consistent and functional and avoiding compile errors.",
      "path": "doc/design/multiprocess.md",
      "position": 164,
      "original_position": 164,
      "commit_id": "91dc48c14825a9075a57c1eefda202b83b6346ba",
      "original_commit_id": "91dc48c14825a9075a57c1eefda202b83b6346ba",
      "in_reply_to_id": null,
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "dead link\r\n```suggestion\r\nIn the meantime, the developer guide [Internal interface guidelines](../developer-notes.md#internal-interface-guidelines) can provide guidance on keeping interfaces consistent and functional and avoiding compile errors.\r\n```",
      "created_at": "2024-01-02T13:34:54Z",
      "updated_at": "2024-01-02T14:05:11Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28978#discussion_r1439454381",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1439454381"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28978"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 145,
      "original_line": 145,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1439470004",
      "pull_request_review_id": 1800375604,
      "id": 1439470004,
      "node_id": "PRRC_kwDOABII585VzJG0",
      "diff_hunk": "@@ -1,72 +1,264 @@\n-# Multiprocess Bitcoin\n+# Multiprocess Bitcoin Design Document\n \n-On unix systems, the `--enable-multiprocess` build option can be passed to `./configure` to build new `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables alongside existing `bitcoind` and `bitcoin-qt` executables.\n+Guide to the design and architecture of the Bitcoin Core multiprocess feature\n \n-`bitcoin-node` is a drop-in replacement for `bitcoind`, and `bitcoin-gui` is a drop-in replacement for `bitcoin-qt`, and there are no differences in use or external behavior between the new and old executables. But internally (after [#10102](https://github.com/bitcoin/bitcoin/pull/10102)), `bitcoin-gui` will spawn a `bitcoin-node` process to run P2P and RPC code, communicating with it across a socket pair, and `bitcoin-node` will spawn `bitcoin-wallet` to run wallet code, also communicating over a socket pair. This will let node, wallet, and GUI code run in separate address spaces for better isolation, and allow future improvements like being able to start and stop components independently on different machines and environments.\n+_This document describes the design of the multiprocess feature. For usage information, see the top-level [multiprocess.md](../multiprocess.md) file._\n \n-## Next steps\n+## Table of contents\n \n-Specific next steps after [#10102](https://github.com/bitcoin/bitcoin/pull/10102) will be:\n+- [Introduction](#introduction)\n+- [Current Architecture](#current-architecture)\n+- [Proposed Architecture](#proposed-architecture)\n+- [Component Overview: Navigating the IPC Framework](#component-overview-navigating-the-ipc-framework)\n+- [Design Considerations](#design-considerations)\n+  - [Selection of Cap’n Proto](#selection-of-capn-proto)\n+  - [Hiding IPC](#hiding-ipc)\n+  - [Interface Definition Maintenance](#interface-definition-maintenance)\n+  - [Interface Stability](#interface-stability)\n+- [Security Considerations](#security-considerations)\n+- [Example Use Cases and Flows](#example-use-cases-and-flows)\n+  - [Retrieving a Block Hash](#retrieving-a-block-hash)\n+- [Future Enhancements](#future-enhancements)\n+- [Conclusion](#conclusion)\n+- [Appendices](#appendices)\n+  - [Glossary of Terms](#glossary-of-terms)\n+  - [References](#references)\n+- [Acknowledgements](#acknowledgements)\n \n-- [ ] Adding `-ipcbind` and `-ipcconnect` options to `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables so they can listen and connect to TCP ports and unix socket paths. This will allow separate processes to be started and stopped any time and connect to each other.\n-- [ ] Adding `-server` and `-rpcbind` options to the `bitcoin-wallet` executable so wallet processes can handle RPC requests directly without going through the node.\n-- [ ] Supporting windows, not just unix systems. The existing socket code is already cross-platform, so the only windows-specific code that needs to be written is code spawning a process and passing a socket descriptor. This can be implemented with `CreateProcess` and `WSADuplicateSocket`. Example: https://memset.wordpress.com/2010/10/13/win32-api-passing-socket-with-ipc-method/.\n-- [ ] Adding sandbox features, restricting subprocess access to resources and data. See [https://eklitzke.org/multiprocess-bitcoin](https://eklitzke.org/multiprocess-bitcoin).\n+## Introduction\n \n-## Debugging\n+The Bitcoin Core software has historically employed a monolithic architecture. The existing design has integrated functionality like P2P network operations, wallet management, and a GUI into a single executable. While effective, it has limitations in flexibility, security, and scalability. This project introduces changes that transition Bitcoin Core to a more modular architecture. It aims to enhance security, improve usability, and facilitate maintenance and development of the software in the long run.\n \n-The `-debug=ipc` command line option can be used to see requests and responses between processes.\n+## Current Architecture\n \n-## Installation\n+The current system features two primary executables: `bitcoind` and `bitcoin-qt`. `bitcoind` combines a Bitcoin P2P node with an integrated JSON-RPC server, wallet, and indexes. `bitcoin-qt` extends this by incorporating a Qt-based GUI. This monolithic structure, although robust, presents challenges such as limited operational flexibility and increased security risks due to the tight integration of components.\n \n-The multiprocess feature requires [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) as dependencies. A simple way to get starting using it without installing these dependencies manually is to use the [depends system](../../depends) with the `MULTIPROCESS=1` [dependency option](../../depends#dependency-options) passed to make:\n+## Proposed Architecture\n \n+The new architecture divides the existing code into three specialized executables:\n+\n+- `bitcoin-node`: Manages the P2P node, indexes, and JSON-RPC server.\n+- `bitcoin-wallet`: Handles all wallet functionality.\n+- `bitcoin-gui`: Provides a standalone Qt-based GUI.\n+\n+This modular approach is designed to enhance security through component isolation and improve usability by allowing independent operation of each module. This allows for new use-cases, such as running the node on a dedicated machine and operating wallets and GUIs on separate machines with the flexibility to start and stop them as needed.\n+\n+This subdivision could be extended in the future. For example, indexes could be removed from the `bitcoin-node` executable and run in separate executables. And JSON-RPC servers could be added to wallet and index executables, so they can listen and respond to RPC requests on their own ports, without needing to forward RPC requests through `bitcoin-node`.\n+\n+<table><tr><td>\n+\n+```mermaid\n+flowchart LR\n+    node[bitcoin-node] -- listens on --> socket[\"&lt;datadir&gt;/node.sock\"]\n+    wallet[bitcoin-wallet] -- connects to --> socket\n+    gui[bitcoin-gui] -- connects to --> socket\n+```\n+\n+</td></tr><tr><td>\n+Processes and socket connection.\n+</td></tr></table>\n+\n+## Component Overview: Navigating the IPC Framework\n+\n+This section describes the major components of the Inter-Process Communication (IPC) framework covering the relevant source files, generated files, tools, and libraries.\n+\n+### Abstract C++ Classes in [`src/interfaces/`](../../src/interfaces/)\n+- The foundation of the IPC implementation lies in the abstract C++ classes within the [`src/interfaces/`](../../src/interfaces/) directory. These classes define pure virtual methods that code in [`src/node/`](../../src/node/), [`src/wallet/`](../../src/wallet/), and [`src/qt/`](../../src/qt/) directories call to interact with each other.\n+- Each abstract class in this directory represents a distinct interface that the different modules (node, wallet, GUI) implement and use for cross-process communication.\n+- The classes are written following conventions described in [Internal Interface\n+  Guidelines](../developer-notes.md#internal-interface-guidelines) to ensure\n+  compatibility with Cap'n Proto.\n+\n+### Cap’n Proto Files in [`src/ipc/capnp/`](../../src/ipc/capnp/)\n+- Corresponding to each abstract class, there are `.capnp` files within the [`src/ipc/capnp/`](../../src/ipc/capnp/) directory. These files are used as input to the `mpgen` tool (described below) to generate C++ code.\n+- These Cap’n Proto files ([learn more about Cap'n Proto RPC](https://capnproto.org/rpc.html)) define the structure and format of messages that are exchanged over IPC. They serve as blueprints for generating C++ code that bridges the gap between high-level C++ interfaces and low-level socket communication.\n+\n+### The `mpgen` Code Generation Tool\n+- A central component of the IPC framework is the `mpgen` tool which is part the [`libmultiprocess` project](https://github.com/chaincodelabs/libmultiprocess). This tool takes the `.capnp` files as input and generates C++ code.\n+- The generated code handles IPC communication, translating interface calls into socket reads and writes.\n+\n+### C++ Client Subclasses in Generated Code\n+- In the generated code, we have C++ client subclasses that inherit from the abstract classes in [`src/interfaces/`](../../src/interfaces/). These subclasses are the workhorses of the IPC mechanism.\n+- They implement all the methods of the interface, marshalling arguments into a structured format, sending them as requests to the IPC server via a UNIX socket, and handling the responses.\n+- These subclasses effectively mask the complexity of IPC, presenting a familiar C++ interface to developers.\n+- Internally, the client subclasses generated by the `mpgen` tool wrap [client classes generated by Cap'n Proto](https://capnproto.org/cxxrpc.html#clients), and use them to send IPC requests.\n+\n+### C++ Server Classes in Generated Code\n+- On the server side, corresponding generated C++ classes receive IPC requests. These server classes are responsible for unmarshalling method arguments, invoking the corresponding methods in the local [`src/interfaces/`](../../src/interfaces/) objects, and creating the IPC response.\n+- The server classes ensure that return values (including output argument values and thrown exceptions) are marshalled and sent back to the client, completing the communication cycle.\n+- Internally, the server subclasses generated by the `mpgen` tool inherit from [server classes generated by Cap'n Proto](https://capnproto.org/cxxrpc.html#servers), and use them to process IPC requests.\n+\n+### The `libmultiprocess` Runtime Library\n+- **Core Functionality**: The `libmultiprocess` runtime library's primary function is to instantiate the generated client and server classes as needed.\n+- **Bootstrapping IPC Connections**: It provides functions for starting new IPC connections, specifically binding generated client and server classes for an initial `interfaces::Init` interface (defined in [`src/interfaces/init.h`](../../src/interfaces/init.h)) to a UNIX socket. This initial interface has methods returning other interfaces that different Bitcoin Core modules use to communicate after the bootstrapping phase.\n+- **Asynchronous I/O and Thread Management**: The library is also responsible for managing I/O and threading. Particularly, it ensures that IPC requests never block each other and that new threads on either side of a connection can always make client calls. It also manages worker threads on the server side of calls, ensuring that calls from the same client thread always execute on the same server thread (to avoid locking issues and support nested callbacks).\n+\n+### Type Hooks in [`src/ipc/capnp/*-types.h`](../../src/ipc/capnp/)\n+- **Custom Type Conversions**: In [`src/ipc/capnp/*-types.h`](../../src/ipc/capnp/), function overloads of two `libmultiprocess` C++ functions, `mp::CustomReadField` and `mp::CustomBuildFields`, are defined. These overloads are used for customizing the conversion of specific C++ types to and from Cap’n Proto types.\n+- **Handling Special Cases**: The `mpgen` tool and `libmultiprocess` library can convert most C++ types to and from Cap’n Proto types automatically, including interface types, primitive C++ types, standard C++ types like `std::vector`, `std::set`, `std::map`, `std::tuple`, and `std::function`, as well as simple C++ structs that consist of aforementioned types and whose fields correspond 1:1 with Cap’n Proto struct fields. For other types, `*-types.h` files provide custom code to convert between C++ and Cap’n Proto data representations.\n+\n+### Protocol-Agnostic IPC Code in [`src/ipc/`](../../src/ipc/)\n+- **Broad Applicability**: Unlike the Cap’n Proto-specific code in [`src/ipc/capnp/`](../../src/ipc/capnp/), the code in the [`src/ipc/`](../../src/ipc/) directory is protocol-agnostic. This enables potential support for other protocols, such as gRPC or a custom protocol in the future.\n+- **Process Management and Socket Operations**: The main purpose of this component is to provide functions for spawning new processes and creating and connecting to UNIX sockets.\n+- **ipc::Exception Class**: This code also defines an `ipc::Exception` class which is thrown from the generated C++ client class methods when there is an unexpected IPC error, such as a disconnection.\n+\n+<table><tr><td>\n+\n+```mermaid\n+flowchart TD\n+    capnpFile[ipc/capnp/chain.capnp] -->|Input to| mpgenTool([mpgen Tool])\n+    mpgenTool -->|Generates| proxyTypesH[ipc/capnp/chain.capnp.proxy-types.h]\n+    mpgenTool --> proxyClientCpp[ipc/capnp/chain.capnp.proxy-client.c++]\n+    mpgenTool --> proxyServerCpp[ipc/capnp/chain.capnp.proxy-server.c++]\n+    proxyTypesH -.->|Includes| interfaces/chain.h\n+    proxyClientCpp -.-> interfaces/chain.h\n+    proxyServerCpp -.-> interfaces/chain.h\n ```\n-cd <BITCOIN_SOURCE_DIRECTORY>\n-make -C depends NO_QT=1 MULTIPROCESS=1\n-CONFIG_SITE=$PWD/depends/x86_64-pc-linux-gnu/share/config.site ./configure\n-make\n-src/bitcoin-node -regtest -printtoconsole -debug=ipc\n-BITCOIND=bitcoin-node test/functional/test_runner.py\n+\n+</td></tr><tr><td>\n+Diagram showing generated source files and includes.\n+</td></tr></table>\n+\n+## Design Considerations\n+\n+### Selection of Cap’n Proto\n+The choice to use [Cap’n Proto](https://capnproto.org/) for IPC was primarily influenced by its support for passing object references and managing object lifetimes, which would have to be implemented manually with a framework that only supported plain requests and responses like [gRPC](https://grpc.io/). The support is especially helpful for passing callback objects like `std::function` and enabling bidirectional calls between processes.\n+\n+The choice to use an RPC framework at all instead of a custom protocol was necessitated by the size of Bitcoin Core internal interfaces which consist of around 150 methods that pass complex data structures and are called in complicated ways (in parallel, and from callbacks that can be nested and stored). Writing a custom protocol to wrap these complicated interfaces would be a lot more work, akin to writing a new RPC framework.\n+\n+### Hiding IPC\n+\n+The IPC mechanism is deliberately isolated from the rest of the codebase so less code has to be concerned with IPC.\n+\n+Building Bitcoin Core with IPC support is optional, and node, wallet, and GUI code can be compiled to either run in the same process or separate processes. The build system also ensures Cap’n Proto library headers can only be used within the [`src/ipc/capnp/`](../../src/ipc/capnp/) directory, not in other parts of the codebase.\n+\n+The libmultiprocess runtime is designed to place as few constraints as possible on IPC interfaces and to make IPC calls act like normal function calls. Method arguments, return values, and exceptions are automatically serialized and sent between processes. Object references and `std::function` arguments are tracked to allow invoked code to call back into invoking code at any time. And there is a 1:1 threading model where every client thread has a corresponding server thread responsible for executing incoming calls from that thread (there can be multiple calls from the same thread due to callbacks) without blocking, and holding the same thread-local variables and locks so behavior is the same whether IPC is used or not.\n+\n+### Interface Definition Maintenance\n+\n+The choice to maintain interface definitions and C++ type mappings as `.capnp` files in the [`src/ipc/capnp/`](../../src/ipc/capnp/) was mostly done for convenience, and probably something that could be improved in the future.\n+\n+In the current design, class names, method names, and parameter names are duplicated between C++ interfaces in [`src/interfaces/`](../../src/interfaces/) and Cap’n Proto files in [`src/ipc/capnp/`](../../src/ipc/capnp/). While this keeps C++ interface headers simple and free of references to IPC, it is a maintenance burden because it means inconsistencies between C++ declarations and Cap’n Proto declarations will result in compile errors. (Static type checking ensures these are not runtime errors.)\n+\n+An alternate approach could use custom [C++ Attributes](https://en.cppreference.com/w/cpp/language/attributes) embedded in interface declarations to automatically generate `.capnp` files from C++ headers. This has not been pursued because parsing C++ headers is more complicated than parsing Cap’n Proto interface definitions, especially portably on multiple platforms.\n+\n+In the meantime, the developer guide [Internal interface guidelines](developer-notes.md#internal-interface-guidelines) can provide guidance on keeping interfaces consistent and functional and avoiding compile errors.\n+\n+### Interface Stability\n+\n+The currently defined IPC interfaces are unstable, and can change freely with no backwards compatibility. The decision to allow this stems from the recognition that our current interfaces are still evolving and not yet ideal for external use. As these interfaces mature and become more refined, there may be an opportunity to declare them stable and use Cap’n Proto's support for protocol evolution ([Cap'n Proto - Evolving Your Protocol](https://capnproto.org/language.html#evolving-your-protocol)) to allow them to be extended while remaining backwards compatible. This could allow different versions of node, GUI, and wallet binaries to interoperate, and potentially open doors for external tools to utilize these interfaces, such as creating custom indexes through a stable indexing interface. However, for now, the priority is to improve the interfaces internally. Given their current state and the advantages of using JSON-RPC for most common tasks, it's more practical to focus on internal development rather than external applicability.\n+\n+## Security Considerations\n+\n+The integration of [Cap’n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) into the Bitcoin Core architecture increases its potential attack surface. Cap’n Proto, being a complex and substantial new dependency, introduces potential sources of vulnerability, particularly through the creation of new UNIX sockets. The inclusion of libmultiprocess, while a smaller external dependency, also contributes to this risk. However, plans are underway to incorporate libmultiprocess as a git subtree, aligning it more closely with the project's well-reviewed internal libraries. While adopting these multiprocess features does introduce some risk, it's worth noting that they can be disabled, allowing builds without these new dependencies. This flexibility ensures that users can balance functionality with security considerations as needed.\n+\n+## Example Use Cases and Flows\n+\n+### Retrieving a Block Hash\n+\n+Let’s walk through an example where the `bitcoin-wallet` process requests the hash of a block at a specific height from the `bitcoin-node` process. This example demonstrates the practical application of the IPC mechanism, specifically the interplay between C++ method calls and Cap’n Proto-generated RPC calls.\n+\n+<table><tr><td>\n+\n+```mermaid\n+sequenceDiagram\n+    box \"bitcoin-wallet process\"\n+    participant WalletCode as Wallet code\n+    participant ChainClient as Generated Chain client class<br/>ProxyClient<messages::Chain>\n+    end\n+    box \"bitcoin-node process\"\n+    participant ChainServer as Generated Chain server class<br/>ProxyServer<messages::Chain>\n+    participant LocalChain as Chain object<br/>node::ChainImpl\n+    end\n+\n+    WalletCode->>ChainClient: getBlockHash(height)\n+    ChainClient->>ChainServer: Send RPC getBlockHash request\n+    ChainServer->>LocalChain: getBlockHash(height)\n+    LocalChain->>ChainServer: Return block hash\n+    ChainServer->>ChainClient: Send response with block hash\n+    ChainClient->>WalletCode: Return block hash\n ```\n \n-The configure script will pick up settings and library locations from the depends directory, so there is no need to pass `--enable-multiprocess` as a separate flag when using the depends system (it's controlled by the `MULTIPROCESS=1` option).\n-\n-Alternately, you can install [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) packages on your system, and just run `./configure --enable-multiprocess` without using the depends system. The configure script will be able to locate the installed packages via [pkg-config](https://www.freedesktop.org/wiki/Software/pkg-config/). See [Installation](https://github.com/chaincodelabs/libmultiprocess/blob/master/doc/install.md) section of the libmultiprocess readme for install steps. See [build-unix.md](../build-unix.md) and [build-osx.md](../build-osx.md) for information about installing dependencies in general.\n-\n-## IPC implementation details\n-\n-Cross process Node, Wallet, and Chain interfaces are defined in\n-[`src/interfaces/`](../../src/interfaces/). These are C++ classes which follow\n-[conventions](../developer-notes.md#internal-interface-guidelines), like passing\n-serializable arguments so they can be called from different processes, and\n-making methods pure virtual so they can have proxy implementations that forward\n-calls between processes.\n-\n-When Wallet, Node, and Chain code is running in the same process, calling any\n-interface method invokes the implementation directly. When code is running in\n-different processes, calling an interface method invokes a proxy interface\n-implementation that communicates with a remote process and invokes the real\n-implementation in the remote process. The\n-[libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) code\n-generation tool internally generates proxy client classes and proxy server\n-classes for this purpose that are thin wrappers around Cap'n Proto\n-[client](https://capnproto.org/cxxrpc.html#clients) and\n-[server](https://capnproto.org/cxxrpc.html#servers) classes, which handle the\n-actual serialization and socket communication.\n-\n-As much as possible, calls between processes are meant to work the same as\n-calls within a single process without adding limitations or requiring extra\n-implementation effort. Processes communicate with each other by calling regular\n-[C++ interface methods](../../src/interfaces/README.md). Method arguments and\n-return values are automatically serialized and sent between processes. Object\n-references and `std::function` arguments are automatically tracked and mapped\n-to allow invoked code to call back into invoking code at any time, and there is\n-a 1:1 threading model where any thread invoking a method in another process has\n-a corresponding thread in the invoked process responsible for executing all\n-method calls from the source thread, without blocking I/O or holding up another\n-call, and using the same thread local variables, locks, and callbacks between\n-calls. The forwarding, tracking, and threading is implemented inside the\n-[libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) library\n-which has the design goal of making calls between processes look like calls in\n-the same process to the extent possible.\n+</td></tr><tr><td>\n+<code>Chain::getBlockHash</code> call diagram\n+</td></tr></table>\n+\n+1. **Initiation in bitcoin-wallet**\n+   - The wallet process calls the `getBlockHash` method on a `Chain` object. This method is defined as a virtual method in [`src/interfaces/chain.h`](../../src/interfaces/chain.h).\n+\n+2. **Translation to Cap’n Proto RPC**\n+   - The `Chain::getBlockHash` virtual method is overridden by the `Chain` [client subclass](#c-client-subclasses-in-generated-code) to translate the method call into a Cap’n Proto RPC call.\n+   - The client subclass is automatically generated by the `mpgen` tool from the [`chain.capnp`](https://github.com/ryanofsky/bitcoin/blob/pr/ipc/src/ipc/capnp/chain.capnp) file in [`src/ipc/capnp/`](../../src/ipc/capnp/).\n+\n+3. **Request Preparation and Dispatch**\n+   - The `getBlockHash` method of the generated `Chain` client subclass in `bitcoin-wallet` populates a Cap’n Proto request with the `height` parameter, sends it to `bitcoin-node` process, and waits for a response.\n+\n+4. **Handling in bitcoin-node**\n+   - Upon receiving the request, the Cap'n Proto dispatching code in the `bitcoin-node` process calls the `getBlockHash` method of the `Chain` [server class](#c-server-classes-in-generated-code).\n+   - The server class is automatically generated by the `mpgen` tool from the [`chain.capnp`](https://github.com/ryanofsky/bitcoin/blob/pr/ipc/src/ipc/capnp/chain.capnp) file in [`src/ipc/capnp/`](../../src/ipc/capnp/).\n+   - The `getBlockHash` method of the generated `Chain` server subclass in `bitcoin-wallet` receives a Cap’n Proto request object with the `height` parameter, and calls the `getBlockHash` method on its local `Chain` object with the provided `height`.\n+   - When the call returns, it encapsulates the return value in a Cap’n Proto response, which it sends back to the `bitcoin-wallet` process,",
      "path": "doc/design/multiprocess.md",
      "position": 259,
      "original_position": 259,
      "commit_id": "91dc48c14825a9075a57c1eefda202b83b6346ba",
      "original_commit_id": "91dc48c14825a9075a57c1eefda202b83b6346ba",
      "in_reply_to_id": null,
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n   - When the call returns, it encapsulates the return value in a Cap’n Proto response, which it sends back to the `bitcoin-wallet` process.\r\n```",
      "created_at": "2024-01-02T13:54:41Z",
      "updated_at": "2024-01-02T14:05:11Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28978#discussion_r1439470004",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1439470004"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28978"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 200,
      "original_line": 200,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1439476415",
      "pull_request_review_id": 1800375604,
      "id": 1439476415,
      "node_id": "PRRC_kwDOABII585VzKq_",
      "diff_hunk": "@@ -1,72 +1,264 @@\n-# Multiprocess Bitcoin\n+# Multiprocess Bitcoin Design Document\n \n-On unix systems, the `--enable-multiprocess` build option can be passed to `./configure` to build new `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables alongside existing `bitcoind` and `bitcoin-qt` executables.\n+Guide to the design and architecture of the Bitcoin Core multiprocess feature\n \n-`bitcoin-node` is a drop-in replacement for `bitcoind`, and `bitcoin-gui` is a drop-in replacement for `bitcoin-qt`, and there are no differences in use or external behavior between the new and old executables. But internally (after [#10102](https://github.com/bitcoin/bitcoin/pull/10102)), `bitcoin-gui` will spawn a `bitcoin-node` process to run P2P and RPC code, communicating with it across a socket pair, and `bitcoin-node` will spawn `bitcoin-wallet` to run wallet code, also communicating over a socket pair. This will let node, wallet, and GUI code run in separate address spaces for better isolation, and allow future improvements like being able to start and stop components independently on different machines and environments.\n+_This document describes the design of the multiprocess feature. For usage information, see the top-level [multiprocess.md](../multiprocess.md) file._\n \n-## Next steps\n+## Table of contents\n \n-Specific next steps after [#10102](https://github.com/bitcoin/bitcoin/pull/10102) will be:\n+- [Introduction](#introduction)\n+- [Current Architecture](#current-architecture)\n+- [Proposed Architecture](#proposed-architecture)\n+- [Component Overview: Navigating the IPC Framework](#component-overview-navigating-the-ipc-framework)\n+- [Design Considerations](#design-considerations)\n+  - [Selection of Cap’n Proto](#selection-of-capn-proto)\n+  - [Hiding IPC](#hiding-ipc)\n+  - [Interface Definition Maintenance](#interface-definition-maintenance)\n+  - [Interface Stability](#interface-stability)\n+- [Security Considerations](#security-considerations)\n+- [Example Use Cases and Flows](#example-use-cases-and-flows)\n+  - [Retrieving a Block Hash](#retrieving-a-block-hash)\n+- [Future Enhancements](#future-enhancements)\n+- [Conclusion](#conclusion)\n+- [Appendices](#appendices)\n+  - [Glossary of Terms](#glossary-of-terms)\n+  - [References](#references)\n+- [Acknowledgements](#acknowledgements)\n \n-- [ ] Adding `-ipcbind` and `-ipcconnect` options to `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables so they can listen and connect to TCP ports and unix socket paths. This will allow separate processes to be started and stopped any time and connect to each other.\n-- [ ] Adding `-server` and `-rpcbind` options to the `bitcoin-wallet` executable so wallet processes can handle RPC requests directly without going through the node.\n-- [ ] Supporting windows, not just unix systems. The existing socket code is already cross-platform, so the only windows-specific code that needs to be written is code spawning a process and passing a socket descriptor. This can be implemented with `CreateProcess` and `WSADuplicateSocket`. Example: https://memset.wordpress.com/2010/10/13/win32-api-passing-socket-with-ipc-method/.\n-- [ ] Adding sandbox features, restricting subprocess access to resources and data. See [https://eklitzke.org/multiprocess-bitcoin](https://eklitzke.org/multiprocess-bitcoin).\n+## Introduction\n \n-## Debugging\n+The Bitcoin Core software has historically employed a monolithic architecture. The existing design has integrated functionality like P2P network operations, wallet management, and a GUI into a single executable. While effective, it has limitations in flexibility, security, and scalability. This project introduces changes that transition Bitcoin Core to a more modular architecture. It aims to enhance security, improve usability, and facilitate maintenance and development of the software in the long run.\n \n-The `-debug=ipc` command line option can be used to see requests and responses between processes.\n+## Current Architecture\n \n-## Installation\n+The current system features two primary executables: `bitcoind` and `bitcoin-qt`. `bitcoind` combines a Bitcoin P2P node with an integrated JSON-RPC server, wallet, and indexes. `bitcoin-qt` extends this by incorporating a Qt-based GUI. This monolithic structure, although robust, presents challenges such as limited operational flexibility and increased security risks due to the tight integration of components.\n \n-The multiprocess feature requires [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) as dependencies. A simple way to get starting using it without installing these dependencies manually is to use the [depends system](../../depends) with the `MULTIPROCESS=1` [dependency option](../../depends#dependency-options) passed to make:\n+## Proposed Architecture\n \n+The new architecture divides the existing code into three specialized executables:\n+\n+- `bitcoin-node`: Manages the P2P node, indexes, and JSON-RPC server.\n+- `bitcoin-wallet`: Handles all wallet functionality.\n+- `bitcoin-gui`: Provides a standalone Qt-based GUI.\n+\n+This modular approach is designed to enhance security through component isolation and improve usability by allowing independent operation of each module. This allows for new use-cases, such as running the node on a dedicated machine and operating wallets and GUIs on separate machines with the flexibility to start and stop them as needed.\n+\n+This subdivision could be extended in the future. For example, indexes could be removed from the `bitcoin-node` executable and run in separate executables. And JSON-RPC servers could be added to wallet and index executables, so they can listen and respond to RPC requests on their own ports, without needing to forward RPC requests through `bitcoin-node`.\n+\n+<table><tr><td>\n+\n+```mermaid\n+flowchart LR\n+    node[bitcoin-node] -- listens on --> socket[\"&lt;datadir&gt;/node.sock\"]\n+    wallet[bitcoin-wallet] -- connects to --> socket\n+    gui[bitcoin-gui] -- connects to --> socket\n+```\n+\n+</td></tr><tr><td>\n+Processes and socket connection.\n+</td></tr></table>\n+\n+## Component Overview: Navigating the IPC Framework\n+\n+This section describes the major components of the Inter-Process Communication (IPC) framework covering the relevant source files, generated files, tools, and libraries.\n+\n+### Abstract C++ Classes in [`src/interfaces/`](../../src/interfaces/)\n+- The foundation of the IPC implementation lies in the abstract C++ classes within the [`src/interfaces/`](../../src/interfaces/) directory. These classes define pure virtual methods that code in [`src/node/`](../../src/node/), [`src/wallet/`](../../src/wallet/), and [`src/qt/`](../../src/qt/) directories call to interact with each other.\n+- Each abstract class in this directory represents a distinct interface that the different modules (node, wallet, GUI) implement and use for cross-process communication.\n+- The classes are written following conventions described in [Internal Interface\n+  Guidelines](../developer-notes.md#internal-interface-guidelines) to ensure\n+  compatibility with Cap'n Proto.\n+\n+### Cap’n Proto Files in [`src/ipc/capnp/`](../../src/ipc/capnp/)\n+- Corresponding to each abstract class, there are `.capnp` files within the [`src/ipc/capnp/`](../../src/ipc/capnp/) directory. These files are used as input to the `mpgen` tool (described below) to generate C++ code.\n+- These Cap’n Proto files ([learn more about Cap'n Proto RPC](https://capnproto.org/rpc.html)) define the structure and format of messages that are exchanged over IPC. They serve as blueprints for generating C++ code that bridges the gap between high-level C++ interfaces and low-level socket communication.\n+\n+### The `mpgen` Code Generation Tool\n+- A central component of the IPC framework is the `mpgen` tool which is part the [`libmultiprocess` project](https://github.com/chaincodelabs/libmultiprocess). This tool takes the `.capnp` files as input and generates C++ code.\n+- The generated code handles IPC communication, translating interface calls into socket reads and writes.\n+\n+### C++ Client Subclasses in Generated Code\n+- In the generated code, we have C++ client subclasses that inherit from the abstract classes in [`src/interfaces/`](../../src/interfaces/). These subclasses are the workhorses of the IPC mechanism.\n+- They implement all the methods of the interface, marshalling arguments into a structured format, sending them as requests to the IPC server via a UNIX socket, and handling the responses.\n+- These subclasses effectively mask the complexity of IPC, presenting a familiar C++ interface to developers.\n+- Internally, the client subclasses generated by the `mpgen` tool wrap [client classes generated by Cap'n Proto](https://capnproto.org/cxxrpc.html#clients), and use them to send IPC requests.\n+\n+### C++ Server Classes in Generated Code\n+- On the server side, corresponding generated C++ classes receive IPC requests. These server classes are responsible for unmarshalling method arguments, invoking the corresponding methods in the local [`src/interfaces/`](../../src/interfaces/) objects, and creating the IPC response.\n+- The server classes ensure that return values (including output argument values and thrown exceptions) are marshalled and sent back to the client, completing the communication cycle.\n+- Internally, the server subclasses generated by the `mpgen` tool inherit from [server classes generated by Cap'n Proto](https://capnproto.org/cxxrpc.html#servers), and use them to process IPC requests.\n+\n+### The `libmultiprocess` Runtime Library\n+- **Core Functionality**: The `libmultiprocess` runtime library's primary function is to instantiate the generated client and server classes as needed.\n+- **Bootstrapping IPC Connections**: It provides functions for starting new IPC connections, specifically binding generated client and server classes for an initial `interfaces::Init` interface (defined in [`src/interfaces/init.h`](../../src/interfaces/init.h)) to a UNIX socket. This initial interface has methods returning other interfaces that different Bitcoin Core modules use to communicate after the bootstrapping phase.\n+- **Asynchronous I/O and Thread Management**: The library is also responsible for managing I/O and threading. Particularly, it ensures that IPC requests never block each other and that new threads on either side of a connection can always make client calls. It also manages worker threads on the server side of calls, ensuring that calls from the same client thread always execute on the same server thread (to avoid locking issues and support nested callbacks).\n+\n+### Type Hooks in [`src/ipc/capnp/*-types.h`](../../src/ipc/capnp/)\n+- **Custom Type Conversions**: In [`src/ipc/capnp/*-types.h`](../../src/ipc/capnp/), function overloads of two `libmultiprocess` C++ functions, `mp::CustomReadField` and `mp::CustomBuildFields`, are defined. These overloads are used for customizing the conversion of specific C++ types to and from Cap’n Proto types.\n+- **Handling Special Cases**: The `mpgen` tool and `libmultiprocess` library can convert most C++ types to and from Cap’n Proto types automatically, including interface types, primitive C++ types, standard C++ types like `std::vector`, `std::set`, `std::map`, `std::tuple`, and `std::function`, as well as simple C++ structs that consist of aforementioned types and whose fields correspond 1:1 with Cap’n Proto struct fields. For other types, `*-types.h` files provide custom code to convert between C++ and Cap’n Proto data representations.\n+\n+### Protocol-Agnostic IPC Code in [`src/ipc/`](../../src/ipc/)\n+- **Broad Applicability**: Unlike the Cap’n Proto-specific code in [`src/ipc/capnp/`](../../src/ipc/capnp/), the code in the [`src/ipc/`](../../src/ipc/) directory is protocol-agnostic. This enables potential support for other protocols, such as gRPC or a custom protocol in the future.\n+- **Process Management and Socket Operations**: The main purpose of this component is to provide functions for spawning new processes and creating and connecting to UNIX sockets.\n+- **ipc::Exception Class**: This code also defines an `ipc::Exception` class which is thrown from the generated C++ client class methods when there is an unexpected IPC error, such as a disconnection.\n+\n+<table><tr><td>\n+\n+```mermaid\n+flowchart TD\n+    capnpFile[ipc/capnp/chain.capnp] -->|Input to| mpgenTool([mpgen Tool])\n+    mpgenTool -->|Generates| proxyTypesH[ipc/capnp/chain.capnp.proxy-types.h]\n+    mpgenTool --> proxyClientCpp[ipc/capnp/chain.capnp.proxy-client.c++]\n+    mpgenTool --> proxyServerCpp[ipc/capnp/chain.capnp.proxy-server.c++]\n+    proxyTypesH -.->|Includes| interfaces/chain.h\n+    proxyClientCpp -.-> interfaces/chain.h\n+    proxyServerCpp -.-> interfaces/chain.h\n ```\n-cd <BITCOIN_SOURCE_DIRECTORY>\n-make -C depends NO_QT=1 MULTIPROCESS=1\n-CONFIG_SITE=$PWD/depends/x86_64-pc-linux-gnu/share/config.site ./configure\n-make\n-src/bitcoin-node -regtest -printtoconsole -debug=ipc\n-BITCOIND=bitcoin-node test/functional/test_runner.py\n+\n+</td></tr><tr><td>\n+Diagram showing generated source files and includes.\n+</td></tr></table>\n+\n+## Design Considerations\n+\n+### Selection of Cap’n Proto\n+The choice to use [Cap’n Proto](https://capnproto.org/) for IPC was primarily influenced by its support for passing object references and managing object lifetimes, which would have to be implemented manually with a framework that only supported plain requests and responses like [gRPC](https://grpc.io/). The support is especially helpful for passing callback objects like `std::function` and enabling bidirectional calls between processes.\n+\n+The choice to use an RPC framework at all instead of a custom protocol was necessitated by the size of Bitcoin Core internal interfaces which consist of around 150 methods that pass complex data structures and are called in complicated ways (in parallel, and from callbacks that can be nested and stored). Writing a custom protocol to wrap these complicated interfaces would be a lot more work, akin to writing a new RPC framework.\n+\n+### Hiding IPC\n+\n+The IPC mechanism is deliberately isolated from the rest of the codebase so less code has to be concerned with IPC.\n+\n+Building Bitcoin Core with IPC support is optional, and node, wallet, and GUI code can be compiled to either run in the same process or separate processes. The build system also ensures Cap’n Proto library headers can only be used within the [`src/ipc/capnp/`](../../src/ipc/capnp/) directory, not in other parts of the codebase.\n+\n+The libmultiprocess runtime is designed to place as few constraints as possible on IPC interfaces and to make IPC calls act like normal function calls. Method arguments, return values, and exceptions are automatically serialized and sent between processes. Object references and `std::function` arguments are tracked to allow invoked code to call back into invoking code at any time. And there is a 1:1 threading model where every client thread has a corresponding server thread responsible for executing incoming calls from that thread (there can be multiple calls from the same thread due to callbacks) without blocking, and holding the same thread-local variables and locks so behavior is the same whether IPC is used or not.\n+\n+### Interface Definition Maintenance\n+\n+The choice to maintain interface definitions and C++ type mappings as `.capnp` files in the [`src/ipc/capnp/`](../../src/ipc/capnp/) was mostly done for convenience, and probably something that could be improved in the future.\n+\n+In the current design, class names, method names, and parameter names are duplicated between C++ interfaces in [`src/interfaces/`](../../src/interfaces/) and Cap’n Proto files in [`src/ipc/capnp/`](../../src/ipc/capnp/). While this keeps C++ interface headers simple and free of references to IPC, it is a maintenance burden because it means inconsistencies between C++ declarations and Cap’n Proto declarations will result in compile errors. (Static type checking ensures these are not runtime errors.)\n+\n+An alternate approach could use custom [C++ Attributes](https://en.cppreference.com/w/cpp/language/attributes) embedded in interface declarations to automatically generate `.capnp` files from C++ headers. This has not been pursued because parsing C++ headers is more complicated than parsing Cap’n Proto interface definitions, especially portably on multiple platforms.\n+\n+In the meantime, the developer guide [Internal interface guidelines](developer-notes.md#internal-interface-guidelines) can provide guidance on keeping interfaces consistent and functional and avoiding compile errors.\n+\n+### Interface Stability\n+\n+The currently defined IPC interfaces are unstable, and can change freely with no backwards compatibility. The decision to allow this stems from the recognition that our current interfaces are still evolving and not yet ideal for external use. As these interfaces mature and become more refined, there may be an opportunity to declare them stable and use Cap’n Proto's support for protocol evolution ([Cap'n Proto - Evolving Your Protocol](https://capnproto.org/language.html#evolving-your-protocol)) to allow them to be extended while remaining backwards compatible. This could allow different versions of node, GUI, and wallet binaries to interoperate, and potentially open doors for external tools to utilize these interfaces, such as creating custom indexes through a stable indexing interface. However, for now, the priority is to improve the interfaces internally. Given their current state and the advantages of using JSON-RPC for most common tasks, it's more practical to focus on internal development rather than external applicability.\n+\n+## Security Considerations\n+\n+The integration of [Cap’n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) into the Bitcoin Core architecture increases its potential attack surface. Cap’n Proto, being a complex and substantial new dependency, introduces potential sources of vulnerability, particularly through the creation of new UNIX sockets. The inclusion of libmultiprocess, while a smaller external dependency, also contributes to this risk. However, plans are underway to incorporate libmultiprocess as a git subtree, aligning it more closely with the project's well-reviewed internal libraries. While adopting these multiprocess features does introduce some risk, it's worth noting that they can be disabled, allowing builds without these new dependencies. This flexibility ensures that users can balance functionality with security considerations as needed.\n+\n+## Example Use Cases and Flows\n+\n+### Retrieving a Block Hash\n+\n+Let’s walk through an example where the `bitcoin-wallet` process requests the hash of a block at a specific height from the `bitcoin-node` process. This example demonstrates the practical application of the IPC mechanism, specifically the interplay between C++ method calls and Cap’n Proto-generated RPC calls.\n+\n+<table><tr><td>\n+\n+```mermaid\n+sequenceDiagram\n+    box \"bitcoin-wallet process\"\n+    participant WalletCode as Wallet code\n+    participant ChainClient as Generated Chain client class<br/>ProxyClient<messages::Chain>\n+    end\n+    box \"bitcoin-node process\"\n+    participant ChainServer as Generated Chain server class<br/>ProxyServer<messages::Chain>\n+    participant LocalChain as Chain object<br/>node::ChainImpl\n+    end\n+\n+    WalletCode->>ChainClient: getBlockHash(height)\n+    ChainClient->>ChainServer: Send RPC getBlockHash request\n+    ChainServer->>LocalChain: getBlockHash(height)\n+    LocalChain->>ChainServer: Return block hash\n+    ChainServer->>ChainClient: Send response with block hash\n+    ChainClient->>WalletCode: Return block hash\n ```\n \n-The configure script will pick up settings and library locations from the depends directory, so there is no need to pass `--enable-multiprocess` as a separate flag when using the depends system (it's controlled by the `MULTIPROCESS=1` option).\n-\n-Alternately, you can install [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) packages on your system, and just run `./configure --enable-multiprocess` without using the depends system. The configure script will be able to locate the installed packages via [pkg-config](https://www.freedesktop.org/wiki/Software/pkg-config/). See [Installation](https://github.com/chaincodelabs/libmultiprocess/blob/master/doc/install.md) section of the libmultiprocess readme for install steps. See [build-unix.md](../build-unix.md) and [build-osx.md](../build-osx.md) for information about installing dependencies in general.\n-\n-## IPC implementation details\n-\n-Cross process Node, Wallet, and Chain interfaces are defined in\n-[`src/interfaces/`](../../src/interfaces/). These are C++ classes which follow\n-[conventions](../developer-notes.md#internal-interface-guidelines), like passing\n-serializable arguments so they can be called from different processes, and\n-making methods pure virtual so they can have proxy implementations that forward\n-calls between processes.\n-\n-When Wallet, Node, and Chain code is running in the same process, calling any\n-interface method invokes the implementation directly. When code is running in\n-different processes, calling an interface method invokes a proxy interface\n-implementation that communicates with a remote process and invokes the real\n-implementation in the remote process. The\n-[libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) code\n-generation tool internally generates proxy client classes and proxy server\n-classes for this purpose that are thin wrappers around Cap'n Proto\n-[client](https://capnproto.org/cxxrpc.html#clients) and\n-[server](https://capnproto.org/cxxrpc.html#servers) classes, which handle the\n-actual serialization and socket communication.\n-\n-As much as possible, calls between processes are meant to work the same as\n-calls within a single process without adding limitations or requiring extra\n-implementation effort. Processes communicate with each other by calling regular\n-[C++ interface methods](../../src/interfaces/README.md). Method arguments and\n-return values are automatically serialized and sent between processes. Object\n-references and `std::function` arguments are automatically tracked and mapped\n-to allow invoked code to call back into invoking code at any time, and there is\n-a 1:1 threading model where any thread invoking a method in another process has\n-a corresponding thread in the invoked process responsible for executing all\n-method calls from the source thread, without blocking I/O or holding up another\n-call, and using the same thread local variables, locks, and callbacks between\n-calls. The forwarding, tracking, and threading is implemented inside the\n-[libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) library\n-which has the design goal of making calls between processes look like calls in\n-the same process to the extent possible.\n+</td></tr><tr><td>\n+<code>Chain::getBlockHash</code> call diagram\n+</td></tr></table>\n+\n+1. **Initiation in bitcoin-wallet**\n+   - The wallet process calls the `getBlockHash` method on a `Chain` object. This method is defined as a virtual method in [`src/interfaces/chain.h`](../../src/interfaces/chain.h).\n+\n+2. **Translation to Cap’n Proto RPC**\n+   - The `Chain::getBlockHash` virtual method is overridden by the `Chain` [client subclass](#c-client-subclasses-in-generated-code) to translate the method call into a Cap’n Proto RPC call.\n+   - The client subclass is automatically generated by the `mpgen` tool from the [`chain.capnp`](https://github.com/ryanofsky/bitcoin/blob/pr/ipc/src/ipc/capnp/chain.capnp) file in [`src/ipc/capnp/`](../../src/ipc/capnp/).\n+\n+3. **Request Preparation and Dispatch**\n+   - The `getBlockHash` method of the generated `Chain` client subclass in `bitcoin-wallet` populates a Cap’n Proto request with the `height` parameter, sends it to `bitcoin-node` process, and waits for a response.\n+\n+4. **Handling in bitcoin-node**\n+   - Upon receiving the request, the Cap'n Proto dispatching code in the `bitcoin-node` process calls the `getBlockHash` method of the `Chain` [server class](#c-server-classes-in-generated-code).\n+   - The server class is automatically generated by the `mpgen` tool from the [`chain.capnp`](https://github.com/ryanofsky/bitcoin/blob/pr/ipc/src/ipc/capnp/chain.capnp) file in [`src/ipc/capnp/`](../../src/ipc/capnp/).\n+   - The `getBlockHash` method of the generated `Chain` server subclass in `bitcoin-wallet` receives a Cap’n Proto request object with the `height` parameter, and calls the `getBlockHash` method on its local `Chain` object with the provided `height`.\n+   - When the call returns, it encapsulates the return value in a Cap’n Proto response, which it sends back to the `bitcoin-wallet` process,\n+\n+5. **Response and Return**\n+   - The `getBlockHash` method of the generated `Chain` client subclass in `bitcoin-wallet` which sent the request now receives the response.\n+   - It extracts the block hash value from the response, and returns it to the original caller.\n+\n+## Future Enhancements\n+\n+Further improvements are possible such as:\n+\n+- Separating indexes from `bitcoin-node`, and running indexing code in separate processes (see [indexes: Stop using node internal types #24230](https://github.com/bitcoin/bitcoin/pull/24230)).\n+- Enabling wallet processes to listen for JSON-RPC requests on their own ports instead of needing the node process to listen and forward requests to them.\n+- Automatically generating `.capnp` files from C++ interface definitions (see [Interface Definition Maintenance](#interface-definition-maintenance)).\n+- Simplifying and stabilizing interfaces (see [Interface Stability](#interface-stability)).\n+- Adding sandbox features, restricting subprocess access to resources and data (see [https://eklitzke.org/multiprocess-bitcoin](https://eklitzke.org/multiprocess-bitcoin)).\n+- Using Cap'n Proto's support for [other languages](https://capnproto.org/otherlang.html), such as [Rust](https://github.com/capnproto/capnproto-rust), to allow code written in other languages to call Bitcoin Core C++ code, and vice versa (see [How to rustify libmultiprocess? #56](https://github.com/chaincodelabs/libmultiprocess/issues/56)).\n+\n+## Conclusion\n+\n+This modularization represents an advancement in Bitcoin Core's architecture, offering enhanced security, flexibility, and maintainability. The project invites collaboration and feedback from the community.\n+\n+## Appendices\n+\n+### Glossary of Terms\n+\n+- **abstract class**: A class in C++ that consists of virtual functions. In the Bitcoin Core project, they define interfaces for inter-component communication.\n+\n+- **asynchronous I/O**: A form of input/output processing that allows a program to continue other operations while a transmission is in progress.\n+\n+- **Cap’n Proto**: A high-performance data serialization and RPC library, chosen for its support for object references and bidirectional communication.\n+\n+- **Cap’n Proto interface**: A set of methods defined in Cap’n Proto to facilitate structured communication between different software components.\n+\n+- **Cap’n Proto struct**: A structured data format used in Cap’n Proto, similar to structs in C++, for organizing and transporting data across different processes.\n+\n+- **client class (in generated code)**: A C++ class generated from a Cap’n Proto interface which inherits from a Bitcoin core abstract class, and implements each virtual method to send IPC requests to another process. (see also [components section](#c-client-subclasses-in-generated-code))",
      "path": "doc/design/multiprocess.md",
      "position": 294,
      "original_position": 294,
      "commit_id": "91dc48c14825a9075a57c1eefda202b83b6346ba",
      "original_commit_id": "91dc48c14825a9075a57c1eefda202b83b6346ba",
      "in_reply_to_id": null,
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit\r\n```suggestion\r\n- **client class (in generated code)**: A C++ class generated from a Cap’n Proto interface which inherits from a Bitcoin Core abstract class, and implements each virtual method to send IPC requests to another process. (see also [components section](#c-client-subclasses-in-generated-code))\r\n```",
      "created_at": "2024-01-02T14:02:05Z",
      "updated_at": "2024-01-02T14:05:11Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28978#discussion_r1439476415",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1439476415"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28978"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 235,
      "original_line": 235,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1449474015",
      "pull_request_review_id": 1816915195,
      "id": 1449474015,
      "node_id": "PRRC_kwDOABII585WZTff",
      "diff_hunk": "@@ -1,72 +1,264 @@\n-# Multiprocess Bitcoin\n+# Multiprocess Bitcoin Design Document\n \n-On unix systems, the `--enable-multiprocess` build option can be passed to `./configure` to build new `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables alongside existing `bitcoind` and `bitcoin-qt` executables.\n+Guide to the design and architecture of the Bitcoin Core multiprocess feature\n \n-`bitcoin-node` is a drop-in replacement for `bitcoind`, and `bitcoin-gui` is a drop-in replacement for `bitcoin-qt`, and there are no differences in use or external behavior between the new and old executables. But internally (after [#10102](https://github.com/bitcoin/bitcoin/pull/10102)), `bitcoin-gui` will spawn a `bitcoin-node` process to run P2P and RPC code, communicating with it across a socket pair, and `bitcoin-node` will spawn `bitcoin-wallet` to run wallet code, also communicating over a socket pair. This will let node, wallet, and GUI code run in separate address spaces for better isolation, and allow future improvements like being able to start and stop components independently on different machines and environments.\n+_This document describes the design of the multiprocess feature. For usage information, see the top-level [multiprocess.md](../multiprocess.md) file._\n \n-## Next steps\n+## Table of contents\n \n-Specific next steps after [#10102](https://github.com/bitcoin/bitcoin/pull/10102) will be:\n+- [Introduction](#introduction)\n+- [Current Architecture](#current-architecture)\n+- [Proposed Architecture](#proposed-architecture)\n+- [Component Overview: Navigating the IPC Framework](#component-overview-navigating-the-ipc-framework)\n+- [Design Considerations](#design-considerations)\n+  - [Selection of Cap’n Proto](#selection-of-capn-proto)\n+  - [Hiding IPC](#hiding-ipc)\n+  - [Interface Definition Maintenance](#interface-definition-maintenance)\n+  - [Interface Stability](#interface-stability)\n+- [Security Considerations](#security-considerations)\n+- [Example Use Cases and Flows](#example-use-cases-and-flows)\n+  - [Retrieving a Block Hash](#retrieving-a-block-hash)\n+- [Future Enhancements](#future-enhancements)\n+- [Conclusion](#conclusion)\n+- [Appendices](#appendices)\n+  - [Glossary of Terms](#glossary-of-terms)\n+  - [References](#references)\n+- [Acknowledgements](#acknowledgements)\n \n-- [ ] Adding `-ipcbind` and `-ipcconnect` options to `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables so they can listen and connect to TCP ports and unix socket paths. This will allow separate processes to be started and stopped any time and connect to each other.\n-- [ ] Adding `-server` and `-rpcbind` options to the `bitcoin-wallet` executable so wallet processes can handle RPC requests directly without going through the node.\n-- [ ] Supporting windows, not just unix systems. The existing socket code is already cross-platform, so the only windows-specific code that needs to be written is code spawning a process and passing a socket descriptor. This can be implemented with `CreateProcess` and `WSADuplicateSocket`. Example: https://memset.wordpress.com/2010/10/13/win32-api-passing-socket-with-ipc-method/.\n-- [ ] Adding sandbox features, restricting subprocess access to resources and data. See [https://eklitzke.org/multiprocess-bitcoin](https://eklitzke.org/multiprocess-bitcoin).\n+## Introduction\n \n-## Debugging\n+The Bitcoin Core software has historically employed a monolithic architecture. The existing design has integrated functionality like P2P network operations, wallet management, and a GUI into a single executable. While effective, it has limitations in flexibility, security, and scalability. This project introduces changes that transition Bitcoin Core to a more modular architecture. It aims to enhance security, improve usability, and facilitate maintenance and development of the software in the long run.\n \n-The `-debug=ipc` command line option can be used to see requests and responses between processes.\n+## Current Architecture\n \n-## Installation\n+The current system features two primary executables: `bitcoind` and `bitcoin-qt`. `bitcoind` combines a Bitcoin P2P node with an integrated JSON-RPC server, wallet, and indexes. `bitcoin-qt` extends this by incorporating a Qt-based GUI. This monolithic structure, although robust, presents challenges such as limited operational flexibility and increased security risks due to the tight integration of components.\n \n-The multiprocess feature requires [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) as dependencies. A simple way to get starting using it without installing these dependencies manually is to use the [depends system](../../depends) with the `MULTIPROCESS=1` [dependency option](../../depends#dependency-options) passed to make:\n+## Proposed Architecture\n \n+The new architecture divides the existing code into three specialized executables:\n+\n+- `bitcoin-node`: Manages the P2P node, indexes, and JSON-RPC server.\n+- `bitcoin-wallet`: Handles all wallet functionality.\n+- `bitcoin-gui`: Provides a standalone Qt-based GUI.\n+\n+This modular approach is designed to enhance security through component isolation and improve usability by allowing independent operation of each module. This allows for new use-cases, such as running the node on a dedicated machine and operating wallets and GUIs on separate machines with the flexibility to start and stop them as needed.\n+\n+This subdivision could be extended in the future. For example, indexes could be removed from the `bitcoin-node` executable and run in separate executables. And JSON-RPC servers could be added to wallet and index executables, so they can listen and respond to RPC requests on their own ports, without needing to forward RPC requests through `bitcoin-node`.\n+\n+<table><tr><td>\n+\n+```mermaid\n+flowchart LR\n+    node[bitcoin-node] -- listens on --> socket[\"&lt;datadir&gt;/node.sock\"]\n+    wallet[bitcoin-wallet] -- connects to --> socket\n+    gui[bitcoin-gui] -- connects to --> socket\n+```\n+\n+</td></tr><tr><td>\n+Processes and socket connection.\n+</td></tr></table>\n+\n+## Component Overview: Navigating the IPC Framework\n+\n+This section describes the major components of the Inter-Process Communication (IPC) framework covering the relevant source files, generated files, tools, and libraries.\n+\n+### Abstract C++ Classes in [`src/interfaces/`](../../src/interfaces/)\n+- The foundation of the IPC implementation lies in the abstract C++ classes within the [`src/interfaces/`](../../src/interfaces/) directory. These classes define pure virtual methods that code in [`src/node/`](../../src/node/), [`src/wallet/`](../../src/wallet/), and [`src/qt/`](../../src/qt/) directories call to interact with each other.\n+- Each abstract class in this directory represents a distinct interface that the different modules (node, wallet, GUI) implement and use for cross-process communication.\n+- The classes are written following conventions described in [Internal Interface\n+  Guidelines](../developer-notes.md#internal-interface-guidelines) to ensure\n+  compatibility with Cap'n Proto.\n+\n+### Cap’n Proto Files in [`src/ipc/capnp/`](../../src/ipc/capnp/)\n+- Corresponding to each abstract class, there are `.capnp` files within the [`src/ipc/capnp/`](../../src/ipc/capnp/) directory. These files are used as input to the `mpgen` tool (described below) to generate C++ code.\n+- These Cap’n Proto files ([learn more about Cap'n Proto RPC](https://capnproto.org/rpc.html)) define the structure and format of messages that are exchanged over IPC. They serve as blueprints for generating C++ code that bridges the gap between high-level C++ interfaces and low-level socket communication.\n+\n+### The `mpgen` Code Generation Tool\n+- A central component of the IPC framework is the `mpgen` tool which is part the [`libmultiprocess` project](https://github.com/chaincodelabs/libmultiprocess). This tool takes the `.capnp` files as input and generates C++ code.\n+- The generated code handles IPC communication, translating interface calls into socket reads and writes.\n+\n+### C++ Client Subclasses in Generated Code\n+- In the generated code, we have C++ client subclasses that inherit from the abstract classes in [`src/interfaces/`](../../src/interfaces/). These subclasses are the workhorses of the IPC mechanism.\n+- They implement all the methods of the interface, marshalling arguments into a structured format, sending them as requests to the IPC server via a UNIX socket, and handling the responses.\n+- These subclasses effectively mask the complexity of IPC, presenting a familiar C++ interface to developers.\n+- Internally, the client subclasses generated by the `mpgen` tool wrap [client classes generated by Cap'n Proto](https://capnproto.org/cxxrpc.html#clients), and use them to send IPC requests.",
      "path": "doc/design/multiprocess.md",
      "position": 97,
      "original_position": 97,
      "commit_id": "91dc48c14825a9075a57c1eefda202b83b6346ba",
      "original_commit_id": "91dc48c14825a9075a57c1eefda202b83b6346ba",
      "in_reply_to_id": 1439431086,
      "user": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "re: https://github.com/bitcoin/bitcoin/pull/28978#discussion_r1439431086\r\n\r\n> Perhaps useful to elaborate on what the `mpgen` wrapping adds to the Cap'n Proto output?\r\n\r\nGreat suggestion, done in #10102. The main difference is `mpgen` clients subclasses have a high-level blocking interface, while capnp client subclasses require you to do asynchronous and pass arguments and return values in capnp message format.",
      "created_at": "2024-01-11T22:30:11Z",
      "updated_at": "2024-01-11T23:25:31Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28978#discussion_r1449474015",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1449474015"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28978"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 84,
      "original_line": 84,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1449474151",
      "pull_request_review_id": 1816915195,
      "id": 1449474151,
      "node_id": "PRRC_kwDOABII585WZThn",
      "diff_hunk": "@@ -1,72 +1,264 @@\n-# Multiprocess Bitcoin\n+# Multiprocess Bitcoin Design Document\n \n-On unix systems, the `--enable-multiprocess` build option can be passed to `./configure` to build new `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables alongside existing `bitcoind` and `bitcoin-qt` executables.\n+Guide to the design and architecture of the Bitcoin Core multiprocess feature\n \n-`bitcoin-node` is a drop-in replacement for `bitcoind`, and `bitcoin-gui` is a drop-in replacement for `bitcoin-qt`, and there are no differences in use or external behavior between the new and old executables. But internally (after [#10102](https://github.com/bitcoin/bitcoin/pull/10102)), `bitcoin-gui` will spawn a `bitcoin-node` process to run P2P and RPC code, communicating with it across a socket pair, and `bitcoin-node` will spawn `bitcoin-wallet` to run wallet code, also communicating over a socket pair. This will let node, wallet, and GUI code run in separate address spaces for better isolation, and allow future improvements like being able to start and stop components independently on different machines and environments.\n+_This document describes the design of the multiprocess feature. For usage information, see the top-level [multiprocess.md](../multiprocess.md) file._\n \n-## Next steps\n+## Table of contents\n \n-Specific next steps after [#10102](https://github.com/bitcoin/bitcoin/pull/10102) will be:\n+- [Introduction](#introduction)\n+- [Current Architecture](#current-architecture)\n+- [Proposed Architecture](#proposed-architecture)\n+- [Component Overview: Navigating the IPC Framework](#component-overview-navigating-the-ipc-framework)\n+- [Design Considerations](#design-considerations)\n+  - [Selection of Cap’n Proto](#selection-of-capn-proto)\n+  - [Hiding IPC](#hiding-ipc)\n+  - [Interface Definition Maintenance](#interface-definition-maintenance)\n+  - [Interface Stability](#interface-stability)\n+- [Security Considerations](#security-considerations)\n+- [Example Use Cases and Flows](#example-use-cases-and-flows)\n+  - [Retrieving a Block Hash](#retrieving-a-block-hash)\n+- [Future Enhancements](#future-enhancements)\n+- [Conclusion](#conclusion)\n+- [Appendices](#appendices)\n+  - [Glossary of Terms](#glossary-of-terms)\n+  - [References](#references)\n+- [Acknowledgements](#acknowledgements)\n \n-- [ ] Adding `-ipcbind` and `-ipcconnect` options to `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables so they can listen and connect to TCP ports and unix socket paths. This will allow separate processes to be started and stopped any time and connect to each other.\n-- [ ] Adding `-server` and `-rpcbind` options to the `bitcoin-wallet` executable so wallet processes can handle RPC requests directly without going through the node.\n-- [ ] Supporting windows, not just unix systems. The existing socket code is already cross-platform, so the only windows-specific code that needs to be written is code spawning a process and passing a socket descriptor. This can be implemented with `CreateProcess` and `WSADuplicateSocket`. Example: https://memset.wordpress.com/2010/10/13/win32-api-passing-socket-with-ipc-method/.\n-- [ ] Adding sandbox features, restricting subprocess access to resources and data. See [https://eklitzke.org/multiprocess-bitcoin](https://eklitzke.org/multiprocess-bitcoin).\n+## Introduction\n \n-## Debugging\n+The Bitcoin Core software has historically employed a monolithic architecture. The existing design has integrated functionality like P2P network operations, wallet management, and a GUI into a single executable. While effective, it has limitations in flexibility, security, and scalability. This project introduces changes that transition Bitcoin Core to a more modular architecture. It aims to enhance security, improve usability, and facilitate maintenance and development of the software in the long run.\n \n-The `-debug=ipc` command line option can be used to see requests and responses between processes.\n+## Current Architecture\n \n-## Installation\n+The current system features two primary executables: `bitcoind` and `bitcoin-qt`. `bitcoind` combines a Bitcoin P2P node with an integrated JSON-RPC server, wallet, and indexes. `bitcoin-qt` extends this by incorporating a Qt-based GUI. This monolithic structure, although robust, presents challenges such as limited operational flexibility and increased security risks due to the tight integration of components.\n \n-The multiprocess feature requires [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) as dependencies. A simple way to get starting using it without installing these dependencies manually is to use the [depends system](../../depends) with the `MULTIPROCESS=1` [dependency option](../../depends#dependency-options) passed to make:\n+## Proposed Architecture\n \n+The new architecture divides the existing code into three specialized executables:\n+\n+- `bitcoin-node`: Manages the P2P node, indexes, and JSON-RPC server.\n+- `bitcoin-wallet`: Handles all wallet functionality.\n+- `bitcoin-gui`: Provides a standalone Qt-based GUI.\n+\n+This modular approach is designed to enhance security through component isolation and improve usability by allowing independent operation of each module. This allows for new use-cases, such as running the node on a dedicated machine and operating wallets and GUIs on separate machines with the flexibility to start and stop them as needed.\n+\n+This subdivision could be extended in the future. For example, indexes could be removed from the `bitcoin-node` executable and run in separate executables. And JSON-RPC servers could be added to wallet and index executables, so they can listen and respond to RPC requests on their own ports, without needing to forward RPC requests through `bitcoin-node`.\n+\n+<table><tr><td>\n+\n+```mermaid\n+flowchart LR\n+    node[bitcoin-node] -- listens on --> socket[\"&lt;datadir&gt;/node.sock\"]\n+    wallet[bitcoin-wallet] -- connects to --> socket\n+    gui[bitcoin-gui] -- connects to --> socket\n+```\n+\n+</td></tr><tr><td>\n+Processes and socket connection.\n+</td></tr></table>\n+\n+## Component Overview: Navigating the IPC Framework\n+\n+This section describes the major components of the Inter-Process Communication (IPC) framework covering the relevant source files, generated files, tools, and libraries.\n+\n+### Abstract C++ Classes in [`src/interfaces/`](../../src/interfaces/)\n+- The foundation of the IPC implementation lies in the abstract C++ classes within the [`src/interfaces/`](../../src/interfaces/) directory. These classes define pure virtual methods that code in [`src/node/`](../../src/node/), [`src/wallet/`](../../src/wallet/), and [`src/qt/`](../../src/qt/) directories call to interact with each other.\n+- Each abstract class in this directory represents a distinct interface that the different modules (node, wallet, GUI) implement and use for cross-process communication.\n+- The classes are written following conventions described in [Internal Interface\n+  Guidelines](../developer-notes.md#internal-interface-guidelines) to ensure\n+  compatibility with Cap'n Proto.\n+\n+### Cap’n Proto Files in [`src/ipc/capnp/`](../../src/ipc/capnp/)\n+- Corresponding to each abstract class, there are `.capnp` files within the [`src/ipc/capnp/`](../../src/ipc/capnp/) directory. These files are used as input to the `mpgen` tool (described below) to generate C++ code.\n+- These Cap’n Proto files ([learn more about Cap'n Proto RPC](https://capnproto.org/rpc.html)) define the structure and format of messages that are exchanged over IPC. They serve as blueprints for generating C++ code that bridges the gap between high-level C++ interfaces and low-level socket communication.\n+\n+### The `mpgen` Code Generation Tool\n+- A central component of the IPC framework is the `mpgen` tool which is part the [`libmultiprocess` project](https://github.com/chaincodelabs/libmultiprocess). This tool takes the `.capnp` files as input and generates C++ code.\n+- The generated code handles IPC communication, translating interface calls into socket reads and writes.\n+\n+### C++ Client Subclasses in Generated Code\n+- In the generated code, we have C++ client subclasses that inherit from the abstract classes in [`src/interfaces/`](../../src/interfaces/). These subclasses are the workhorses of the IPC mechanism.\n+- They implement all the methods of the interface, marshalling arguments into a structured format, sending them as requests to the IPC server via a UNIX socket, and handling the responses.\n+- These subclasses effectively mask the complexity of IPC, presenting a familiar C++ interface to developers.\n+- Internally, the client subclasses generated by the `mpgen` tool wrap [client classes generated by Cap'n Proto](https://capnproto.org/cxxrpc.html#clients), and use them to send IPC requests.\n+\n+### C++ Server Classes in Generated Code\n+- On the server side, corresponding generated C++ classes receive IPC requests. These server classes are responsible for unmarshalling method arguments, invoking the corresponding methods in the local [`src/interfaces/`](../../src/interfaces/) objects, and creating the IPC response.\n+- The server classes ensure that return values (including output argument values and thrown exceptions) are marshalled and sent back to the client, completing the communication cycle.\n+- Internally, the server subclasses generated by the `mpgen` tool inherit from [server classes generated by Cap'n Proto](https://capnproto.org/cxxrpc.html#servers), and use them to process IPC requests.\n+\n+### The `libmultiprocess` Runtime Library\n+- **Core Functionality**: The `libmultiprocess` runtime library's primary function is to instantiate the generated client and server classes as needed.\n+- **Bootstrapping IPC Connections**: It provides functions for starting new IPC connections, specifically binding generated client and server classes for an initial `interfaces::Init` interface (defined in [`src/interfaces/init.h`](../../src/interfaces/init.h)) to a UNIX socket. This initial interface has methods returning other interfaces that different Bitcoin Core modules use to communicate after the bootstrapping phase.\n+- **Asynchronous I/O and Thread Management**: The library is also responsible for managing I/O and threading. Particularly, it ensures that IPC requests never block each other and that new threads on either side of a connection can always make client calls. It also manages worker threads on the server side of calls, ensuring that calls from the same client thread always execute on the same server thread (to avoid locking issues and support nested callbacks).\n+\n+### Type Hooks in [`src/ipc/capnp/*-types.h`](../../src/ipc/capnp/)\n+- **Custom Type Conversions**: In [`src/ipc/capnp/*-types.h`](../../src/ipc/capnp/), function overloads of two `libmultiprocess` C++ functions, `mp::CustomReadField` and `mp::CustomBuildFields`, are defined. These overloads are used for customizing the conversion of specific C++ types to and from Cap’n Proto types.\n+- **Handling Special Cases**: The `mpgen` tool and `libmultiprocess` library can convert most C++ types to and from Cap’n Proto types automatically, including interface types, primitive C++ types, standard C++ types like `std::vector`, `std::set`, `std::map`, `std::tuple`, and `std::function`, as well as simple C++ structs that consist of aforementioned types and whose fields correspond 1:1 with Cap’n Proto struct fields. For other types, `*-types.h` files provide custom code to convert between C++ and Cap’n Proto data representations.\n+\n+### Protocol-Agnostic IPC Code in [`src/ipc/`](../../src/ipc/)\n+- **Broad Applicability**: Unlike the Cap’n Proto-specific code in [`src/ipc/capnp/`](../../src/ipc/capnp/), the code in the [`src/ipc/`](../../src/ipc/) directory is protocol-agnostic. This enables potential support for other protocols, such as gRPC or a custom protocol in the future.\n+- **Process Management and Socket Operations**: The main purpose of this component is to provide functions for spawning new processes and creating and connecting to UNIX sockets.\n+- **ipc::Exception Class**: This code also defines an `ipc::Exception` class which is thrown from the generated C++ client class methods when there is an unexpected IPC error, such as a disconnection.\n+\n+<table><tr><td>\n+\n+```mermaid\n+flowchart TD\n+    capnpFile[ipc/capnp/chain.capnp] -->|Input to| mpgenTool([mpgen Tool])\n+    mpgenTool -->|Generates| proxyTypesH[ipc/capnp/chain.capnp.proxy-types.h]\n+    mpgenTool --> proxyClientCpp[ipc/capnp/chain.capnp.proxy-client.c++]\n+    mpgenTool --> proxyServerCpp[ipc/capnp/chain.capnp.proxy-server.c++]\n+    proxyTypesH -.->|Includes| interfaces/chain.h\n+    proxyClientCpp -.-> interfaces/chain.h\n+    proxyServerCpp -.-> interfaces/chain.h\n ```\n-cd <BITCOIN_SOURCE_DIRECTORY>\n-make -C depends NO_QT=1 MULTIPROCESS=1\n-CONFIG_SITE=$PWD/depends/x86_64-pc-linux-gnu/share/config.site ./configure\n-make\n-src/bitcoin-node -regtest -printtoconsole -debug=ipc\n-BITCOIND=bitcoin-node test/functional/test_runner.py\n+\n+</td></tr><tr><td>\n+Diagram showing generated source files and includes.\n+</td></tr></table>\n+\n+## Design Considerations\n+\n+### Selection of Cap’n Proto\n+The choice to use [Cap’n Proto](https://capnproto.org/) for IPC was primarily influenced by its support for passing object references and managing object lifetimes, which would have to be implemented manually with a framework that only supported plain requests and responses like [gRPC](https://grpc.io/). The support is especially helpful for passing callback objects like `std::function` and enabling bidirectional calls between processes.\n+\n+The choice to use an RPC framework at all instead of a custom protocol was necessitated by the size of Bitcoin Core internal interfaces which consist of around 150 methods that pass complex data structures and are called in complicated ways (in parallel, and from callbacks that can be nested and stored). Writing a custom protocol to wrap these complicated interfaces would be a lot more work, akin to writing a new RPC framework.\n+\n+### Hiding IPC\n+\n+The IPC mechanism is deliberately isolated from the rest of the codebase so less code has to be concerned with IPC.\n+\n+Building Bitcoin Core with IPC support is optional, and node, wallet, and GUI code can be compiled to either run in the same process or separate processes. The build system also ensures Cap’n Proto library headers can only be used within the [`src/ipc/capnp/`](../../src/ipc/capnp/) directory, not in other parts of the codebase.\n+\n+The libmultiprocess runtime is designed to place as few constraints as possible on IPC interfaces and to make IPC calls act like normal function calls. Method arguments, return values, and exceptions are automatically serialized and sent between processes. Object references and `std::function` arguments are tracked to allow invoked code to call back into invoking code at any time. And there is a 1:1 threading model where every client thread has a corresponding server thread responsible for executing incoming calls from that thread (there can be multiple calls from the same thread due to callbacks) without blocking, and holding the same thread-local variables and locks so behavior is the same whether IPC is used or not.\n+\n+### Interface Definition Maintenance\n+\n+The choice to maintain interface definitions and C++ type mappings as `.capnp` files in the [`src/ipc/capnp/`](../../src/ipc/capnp/) was mostly done for convenience, and probably something that could be improved in the future.\n+\n+In the current design, class names, method names, and parameter names are duplicated between C++ interfaces in [`src/interfaces/`](../../src/interfaces/) and Cap’n Proto files in [`src/ipc/capnp/`](../../src/ipc/capnp/). While this keeps C++ interface headers simple and free of references to IPC, it is a maintenance burden because it means inconsistencies between C++ declarations and Cap’n Proto declarations will result in compile errors. (Static type checking ensures these are not runtime errors.)\n+\n+An alternate approach could use custom [C++ Attributes](https://en.cppreference.com/w/cpp/language/attributes) embedded in interface declarations to automatically generate `.capnp` files from C++ headers. This has not been pursued because parsing C++ headers is more complicated than parsing Cap’n Proto interface definitions, especially portably on multiple platforms.\n+\n+In the meantime, the developer guide [Internal interface guidelines](developer-notes.md#internal-interface-guidelines) can provide guidance on keeping interfaces consistent and functional and avoiding compile errors.",
      "path": "doc/design/multiprocess.md",
      "position": 164,
      "original_position": 164,
      "commit_id": "91dc48c14825a9075a57c1eefda202b83b6346ba",
      "original_commit_id": "91dc48c14825a9075a57c1eefda202b83b6346ba",
      "in_reply_to_id": 1439454381,
      "user": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "re: https://github.com/bitcoin/bitcoin/pull/28978#discussion_r1439454381\r\n\r\n> dead link\r\n\r\nThanks, fixed in #10102",
      "created_at": "2024-01-11T22:30:22Z",
      "updated_at": "2024-01-11T23:25:31Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28978#discussion_r1449474151",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1449474151"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28978"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 145,
      "original_line": 145,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1449474251",
      "pull_request_review_id": 1816915195,
      "id": 1449474251,
      "node_id": "PRRC_kwDOABII585WZTjL",
      "diff_hunk": "@@ -1,72 +1,264 @@\n-# Multiprocess Bitcoin\n+# Multiprocess Bitcoin Design Document\n \n-On unix systems, the `--enable-multiprocess` build option can be passed to `./configure` to build new `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables alongside existing `bitcoind` and `bitcoin-qt` executables.\n+Guide to the design and architecture of the Bitcoin Core multiprocess feature\n \n-`bitcoin-node` is a drop-in replacement for `bitcoind`, and `bitcoin-gui` is a drop-in replacement for `bitcoin-qt`, and there are no differences in use or external behavior between the new and old executables. But internally (after [#10102](https://github.com/bitcoin/bitcoin/pull/10102)), `bitcoin-gui` will spawn a `bitcoin-node` process to run P2P and RPC code, communicating with it across a socket pair, and `bitcoin-node` will spawn `bitcoin-wallet` to run wallet code, also communicating over a socket pair. This will let node, wallet, and GUI code run in separate address spaces for better isolation, and allow future improvements like being able to start and stop components independently on different machines and environments.\n+_This document describes the design of the multiprocess feature. For usage information, see the top-level [multiprocess.md](../multiprocess.md) file._\n \n-## Next steps\n+## Table of contents\n \n-Specific next steps after [#10102](https://github.com/bitcoin/bitcoin/pull/10102) will be:\n+- [Introduction](#introduction)\n+- [Current Architecture](#current-architecture)\n+- [Proposed Architecture](#proposed-architecture)\n+- [Component Overview: Navigating the IPC Framework](#component-overview-navigating-the-ipc-framework)\n+- [Design Considerations](#design-considerations)\n+  - [Selection of Cap’n Proto](#selection-of-capn-proto)\n+  - [Hiding IPC](#hiding-ipc)\n+  - [Interface Definition Maintenance](#interface-definition-maintenance)\n+  - [Interface Stability](#interface-stability)\n+- [Security Considerations](#security-considerations)\n+- [Example Use Cases and Flows](#example-use-cases-and-flows)\n+  - [Retrieving a Block Hash](#retrieving-a-block-hash)\n+- [Future Enhancements](#future-enhancements)\n+- [Conclusion](#conclusion)\n+- [Appendices](#appendices)\n+  - [Glossary of Terms](#glossary-of-terms)\n+  - [References](#references)\n+- [Acknowledgements](#acknowledgements)\n \n-- [ ] Adding `-ipcbind` and `-ipcconnect` options to `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables so they can listen and connect to TCP ports and unix socket paths. This will allow separate processes to be started and stopped any time and connect to each other.\n-- [ ] Adding `-server` and `-rpcbind` options to the `bitcoin-wallet` executable so wallet processes can handle RPC requests directly without going through the node.\n-- [ ] Supporting windows, not just unix systems. The existing socket code is already cross-platform, so the only windows-specific code that needs to be written is code spawning a process and passing a socket descriptor. This can be implemented with `CreateProcess` and `WSADuplicateSocket`. Example: https://memset.wordpress.com/2010/10/13/win32-api-passing-socket-with-ipc-method/.\n-- [ ] Adding sandbox features, restricting subprocess access to resources and data. See [https://eklitzke.org/multiprocess-bitcoin](https://eklitzke.org/multiprocess-bitcoin).\n+## Introduction\n \n-## Debugging\n+The Bitcoin Core software has historically employed a monolithic architecture. The existing design has integrated functionality like P2P network operations, wallet management, and a GUI into a single executable. While effective, it has limitations in flexibility, security, and scalability. This project introduces changes that transition Bitcoin Core to a more modular architecture. It aims to enhance security, improve usability, and facilitate maintenance and development of the software in the long run.\n \n-The `-debug=ipc` command line option can be used to see requests and responses between processes.\n+## Current Architecture\n \n-## Installation\n+The current system features two primary executables: `bitcoind` and `bitcoin-qt`. `bitcoind` combines a Bitcoin P2P node with an integrated JSON-RPC server, wallet, and indexes. `bitcoin-qt` extends this by incorporating a Qt-based GUI. This monolithic structure, although robust, presents challenges such as limited operational flexibility and increased security risks due to the tight integration of components.\n \n-The multiprocess feature requires [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) as dependencies. A simple way to get starting using it without installing these dependencies manually is to use the [depends system](../../depends) with the `MULTIPROCESS=1` [dependency option](../../depends#dependency-options) passed to make:\n+## Proposed Architecture\n \n+The new architecture divides the existing code into three specialized executables:\n+\n+- `bitcoin-node`: Manages the P2P node, indexes, and JSON-RPC server.\n+- `bitcoin-wallet`: Handles all wallet functionality.\n+- `bitcoin-gui`: Provides a standalone Qt-based GUI.\n+\n+This modular approach is designed to enhance security through component isolation and improve usability by allowing independent operation of each module. This allows for new use-cases, such as running the node on a dedicated machine and operating wallets and GUIs on separate machines with the flexibility to start and stop them as needed.\n+\n+This subdivision could be extended in the future. For example, indexes could be removed from the `bitcoin-node` executable and run in separate executables. And JSON-RPC servers could be added to wallet and index executables, so they can listen and respond to RPC requests on their own ports, without needing to forward RPC requests through `bitcoin-node`.\n+\n+<table><tr><td>\n+\n+```mermaid\n+flowchart LR\n+    node[bitcoin-node] -- listens on --> socket[\"&lt;datadir&gt;/node.sock\"]\n+    wallet[bitcoin-wallet] -- connects to --> socket\n+    gui[bitcoin-gui] -- connects to --> socket\n+```\n+\n+</td></tr><tr><td>\n+Processes and socket connection.\n+</td></tr></table>\n+\n+## Component Overview: Navigating the IPC Framework\n+\n+This section describes the major components of the Inter-Process Communication (IPC) framework covering the relevant source files, generated files, tools, and libraries.\n+\n+### Abstract C++ Classes in [`src/interfaces/`](../../src/interfaces/)\n+- The foundation of the IPC implementation lies in the abstract C++ classes within the [`src/interfaces/`](../../src/interfaces/) directory. These classes define pure virtual methods that code in [`src/node/`](../../src/node/), [`src/wallet/`](../../src/wallet/), and [`src/qt/`](../../src/qt/) directories call to interact with each other.\n+- Each abstract class in this directory represents a distinct interface that the different modules (node, wallet, GUI) implement and use for cross-process communication.\n+- The classes are written following conventions described in [Internal Interface\n+  Guidelines](../developer-notes.md#internal-interface-guidelines) to ensure\n+  compatibility with Cap'n Proto.\n+\n+### Cap’n Proto Files in [`src/ipc/capnp/`](../../src/ipc/capnp/)\n+- Corresponding to each abstract class, there are `.capnp` files within the [`src/ipc/capnp/`](../../src/ipc/capnp/) directory. These files are used as input to the `mpgen` tool (described below) to generate C++ code.\n+- These Cap’n Proto files ([learn more about Cap'n Proto RPC](https://capnproto.org/rpc.html)) define the structure and format of messages that are exchanged over IPC. They serve as blueprints for generating C++ code that bridges the gap between high-level C++ interfaces and low-level socket communication.\n+\n+### The `mpgen` Code Generation Tool\n+- A central component of the IPC framework is the `mpgen` tool which is part the [`libmultiprocess` project](https://github.com/chaincodelabs/libmultiprocess). This tool takes the `.capnp` files as input and generates C++ code.\n+- The generated code handles IPC communication, translating interface calls into socket reads and writes.\n+\n+### C++ Client Subclasses in Generated Code\n+- In the generated code, we have C++ client subclasses that inherit from the abstract classes in [`src/interfaces/`](../../src/interfaces/). These subclasses are the workhorses of the IPC mechanism.\n+- They implement all the methods of the interface, marshalling arguments into a structured format, sending them as requests to the IPC server via a UNIX socket, and handling the responses.\n+- These subclasses effectively mask the complexity of IPC, presenting a familiar C++ interface to developers.\n+- Internally, the client subclasses generated by the `mpgen` tool wrap [client classes generated by Cap'n Proto](https://capnproto.org/cxxrpc.html#clients), and use them to send IPC requests.\n+\n+### C++ Server Classes in Generated Code\n+- On the server side, corresponding generated C++ classes receive IPC requests. These server classes are responsible for unmarshalling method arguments, invoking the corresponding methods in the local [`src/interfaces/`](../../src/interfaces/) objects, and creating the IPC response.\n+- The server classes ensure that return values (including output argument values and thrown exceptions) are marshalled and sent back to the client, completing the communication cycle.\n+- Internally, the server subclasses generated by the `mpgen` tool inherit from [server classes generated by Cap'n Proto](https://capnproto.org/cxxrpc.html#servers), and use them to process IPC requests.\n+\n+### The `libmultiprocess` Runtime Library\n+- **Core Functionality**: The `libmultiprocess` runtime library's primary function is to instantiate the generated client and server classes as needed.\n+- **Bootstrapping IPC Connections**: It provides functions for starting new IPC connections, specifically binding generated client and server classes for an initial `interfaces::Init` interface (defined in [`src/interfaces/init.h`](../../src/interfaces/init.h)) to a UNIX socket. This initial interface has methods returning other interfaces that different Bitcoin Core modules use to communicate after the bootstrapping phase.\n+- **Asynchronous I/O and Thread Management**: The library is also responsible for managing I/O and threading. Particularly, it ensures that IPC requests never block each other and that new threads on either side of a connection can always make client calls. It also manages worker threads on the server side of calls, ensuring that calls from the same client thread always execute on the same server thread (to avoid locking issues and support nested callbacks).\n+\n+### Type Hooks in [`src/ipc/capnp/*-types.h`](../../src/ipc/capnp/)\n+- **Custom Type Conversions**: In [`src/ipc/capnp/*-types.h`](../../src/ipc/capnp/), function overloads of two `libmultiprocess` C++ functions, `mp::CustomReadField` and `mp::CustomBuildFields`, are defined. These overloads are used for customizing the conversion of specific C++ types to and from Cap’n Proto types.\n+- **Handling Special Cases**: The `mpgen` tool and `libmultiprocess` library can convert most C++ types to and from Cap’n Proto types automatically, including interface types, primitive C++ types, standard C++ types like `std::vector`, `std::set`, `std::map`, `std::tuple`, and `std::function`, as well as simple C++ structs that consist of aforementioned types and whose fields correspond 1:1 with Cap’n Proto struct fields. For other types, `*-types.h` files provide custom code to convert between C++ and Cap’n Proto data representations.\n+\n+### Protocol-Agnostic IPC Code in [`src/ipc/`](../../src/ipc/)\n+- **Broad Applicability**: Unlike the Cap’n Proto-specific code in [`src/ipc/capnp/`](../../src/ipc/capnp/), the code in the [`src/ipc/`](../../src/ipc/) directory is protocol-agnostic. This enables potential support for other protocols, such as gRPC or a custom protocol in the future.\n+- **Process Management and Socket Operations**: The main purpose of this component is to provide functions for spawning new processes and creating and connecting to UNIX sockets.\n+- **ipc::Exception Class**: This code also defines an `ipc::Exception` class which is thrown from the generated C++ client class methods when there is an unexpected IPC error, such as a disconnection.\n+\n+<table><tr><td>\n+\n+```mermaid\n+flowchart TD\n+    capnpFile[ipc/capnp/chain.capnp] -->|Input to| mpgenTool([mpgen Tool])\n+    mpgenTool -->|Generates| proxyTypesH[ipc/capnp/chain.capnp.proxy-types.h]\n+    mpgenTool --> proxyClientCpp[ipc/capnp/chain.capnp.proxy-client.c++]\n+    mpgenTool --> proxyServerCpp[ipc/capnp/chain.capnp.proxy-server.c++]\n+    proxyTypesH -.->|Includes| interfaces/chain.h\n+    proxyClientCpp -.-> interfaces/chain.h\n+    proxyServerCpp -.-> interfaces/chain.h\n ```\n-cd <BITCOIN_SOURCE_DIRECTORY>\n-make -C depends NO_QT=1 MULTIPROCESS=1\n-CONFIG_SITE=$PWD/depends/x86_64-pc-linux-gnu/share/config.site ./configure\n-make\n-src/bitcoin-node -regtest -printtoconsole -debug=ipc\n-BITCOIND=bitcoin-node test/functional/test_runner.py\n+\n+</td></tr><tr><td>\n+Diagram showing generated source files and includes.\n+</td></tr></table>\n+\n+## Design Considerations\n+\n+### Selection of Cap’n Proto\n+The choice to use [Cap’n Proto](https://capnproto.org/) for IPC was primarily influenced by its support for passing object references and managing object lifetimes, which would have to be implemented manually with a framework that only supported plain requests and responses like [gRPC](https://grpc.io/). The support is especially helpful for passing callback objects like `std::function` and enabling bidirectional calls between processes.\n+\n+The choice to use an RPC framework at all instead of a custom protocol was necessitated by the size of Bitcoin Core internal interfaces which consist of around 150 methods that pass complex data structures and are called in complicated ways (in parallel, and from callbacks that can be nested and stored). Writing a custom protocol to wrap these complicated interfaces would be a lot more work, akin to writing a new RPC framework.\n+\n+### Hiding IPC\n+\n+The IPC mechanism is deliberately isolated from the rest of the codebase so less code has to be concerned with IPC.\n+\n+Building Bitcoin Core with IPC support is optional, and node, wallet, and GUI code can be compiled to either run in the same process or separate processes. The build system also ensures Cap’n Proto library headers can only be used within the [`src/ipc/capnp/`](../../src/ipc/capnp/) directory, not in other parts of the codebase.\n+\n+The libmultiprocess runtime is designed to place as few constraints as possible on IPC interfaces and to make IPC calls act like normal function calls. Method arguments, return values, and exceptions are automatically serialized and sent between processes. Object references and `std::function` arguments are tracked to allow invoked code to call back into invoking code at any time. And there is a 1:1 threading model where every client thread has a corresponding server thread responsible for executing incoming calls from that thread (there can be multiple calls from the same thread due to callbacks) without blocking, and holding the same thread-local variables and locks so behavior is the same whether IPC is used or not.\n+\n+### Interface Definition Maintenance\n+\n+The choice to maintain interface definitions and C++ type mappings as `.capnp` files in the [`src/ipc/capnp/`](../../src/ipc/capnp/) was mostly done for convenience, and probably something that could be improved in the future.\n+\n+In the current design, class names, method names, and parameter names are duplicated between C++ interfaces in [`src/interfaces/`](../../src/interfaces/) and Cap’n Proto files in [`src/ipc/capnp/`](../../src/ipc/capnp/). While this keeps C++ interface headers simple and free of references to IPC, it is a maintenance burden because it means inconsistencies between C++ declarations and Cap’n Proto declarations will result in compile errors. (Static type checking ensures these are not runtime errors.)\n+\n+An alternate approach could use custom [C++ Attributes](https://en.cppreference.com/w/cpp/language/attributes) embedded in interface declarations to automatically generate `.capnp` files from C++ headers. This has not been pursued because parsing C++ headers is more complicated than parsing Cap’n Proto interface definitions, especially portably on multiple platforms.\n+\n+In the meantime, the developer guide [Internal interface guidelines](developer-notes.md#internal-interface-guidelines) can provide guidance on keeping interfaces consistent and functional and avoiding compile errors.\n+\n+### Interface Stability\n+\n+The currently defined IPC interfaces are unstable, and can change freely with no backwards compatibility. The decision to allow this stems from the recognition that our current interfaces are still evolving and not yet ideal for external use. As these interfaces mature and become more refined, there may be an opportunity to declare them stable and use Cap’n Proto's support for protocol evolution ([Cap'n Proto - Evolving Your Protocol](https://capnproto.org/language.html#evolving-your-protocol)) to allow them to be extended while remaining backwards compatible. This could allow different versions of node, GUI, and wallet binaries to interoperate, and potentially open doors for external tools to utilize these interfaces, such as creating custom indexes through a stable indexing interface. However, for now, the priority is to improve the interfaces internally. Given their current state and the advantages of using JSON-RPC for most common tasks, it's more practical to focus on internal development rather than external applicability.\n+\n+## Security Considerations\n+\n+The integration of [Cap’n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) into the Bitcoin Core architecture increases its potential attack surface. Cap’n Proto, being a complex and substantial new dependency, introduces potential sources of vulnerability, particularly through the creation of new UNIX sockets. The inclusion of libmultiprocess, while a smaller external dependency, also contributes to this risk. However, plans are underway to incorporate libmultiprocess as a git subtree, aligning it more closely with the project's well-reviewed internal libraries. While adopting these multiprocess features does introduce some risk, it's worth noting that they can be disabled, allowing builds without these new dependencies. This flexibility ensures that users can balance functionality with security considerations as needed.\n+\n+## Example Use Cases and Flows\n+\n+### Retrieving a Block Hash\n+\n+Let’s walk through an example where the `bitcoin-wallet` process requests the hash of a block at a specific height from the `bitcoin-node` process. This example demonstrates the practical application of the IPC mechanism, specifically the interplay between C++ method calls and Cap’n Proto-generated RPC calls.\n+\n+<table><tr><td>\n+\n+```mermaid\n+sequenceDiagram\n+    box \"bitcoin-wallet process\"\n+    participant WalletCode as Wallet code\n+    participant ChainClient as Generated Chain client class<br/>ProxyClient<messages::Chain>\n+    end\n+    box \"bitcoin-node process\"\n+    participant ChainServer as Generated Chain server class<br/>ProxyServer<messages::Chain>\n+    participant LocalChain as Chain object<br/>node::ChainImpl\n+    end\n+\n+    WalletCode->>ChainClient: getBlockHash(height)\n+    ChainClient->>ChainServer: Send RPC getBlockHash request\n+    ChainServer->>LocalChain: getBlockHash(height)\n+    LocalChain->>ChainServer: Return block hash\n+    ChainServer->>ChainClient: Send response with block hash\n+    ChainClient->>WalletCode: Return block hash\n ```\n \n-The configure script will pick up settings and library locations from the depends directory, so there is no need to pass `--enable-multiprocess` as a separate flag when using the depends system (it's controlled by the `MULTIPROCESS=1` option).\n-\n-Alternately, you can install [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) packages on your system, and just run `./configure --enable-multiprocess` without using the depends system. The configure script will be able to locate the installed packages via [pkg-config](https://www.freedesktop.org/wiki/Software/pkg-config/). See [Installation](https://github.com/chaincodelabs/libmultiprocess/blob/master/doc/install.md) section of the libmultiprocess readme for install steps. See [build-unix.md](../build-unix.md) and [build-osx.md](../build-osx.md) for information about installing dependencies in general.\n-\n-## IPC implementation details\n-\n-Cross process Node, Wallet, and Chain interfaces are defined in\n-[`src/interfaces/`](../../src/interfaces/). These are C++ classes which follow\n-[conventions](../developer-notes.md#internal-interface-guidelines), like passing\n-serializable arguments so they can be called from different processes, and\n-making methods pure virtual so they can have proxy implementations that forward\n-calls between processes.\n-\n-When Wallet, Node, and Chain code is running in the same process, calling any\n-interface method invokes the implementation directly. When code is running in\n-different processes, calling an interface method invokes a proxy interface\n-implementation that communicates with a remote process and invokes the real\n-implementation in the remote process. The\n-[libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) code\n-generation tool internally generates proxy client classes and proxy server\n-classes for this purpose that are thin wrappers around Cap'n Proto\n-[client](https://capnproto.org/cxxrpc.html#clients) and\n-[server](https://capnproto.org/cxxrpc.html#servers) classes, which handle the\n-actual serialization and socket communication.\n-\n-As much as possible, calls between processes are meant to work the same as\n-calls within a single process without adding limitations or requiring extra\n-implementation effort. Processes communicate with each other by calling regular\n-[C++ interface methods](../../src/interfaces/README.md). Method arguments and\n-return values are automatically serialized and sent between processes. Object\n-references and `std::function` arguments are automatically tracked and mapped\n-to allow invoked code to call back into invoking code at any time, and there is\n-a 1:1 threading model where any thread invoking a method in another process has\n-a corresponding thread in the invoked process responsible for executing all\n-method calls from the source thread, without blocking I/O or holding up another\n-call, and using the same thread local variables, locks, and callbacks between\n-calls. The forwarding, tracking, and threading is implemented inside the\n-[libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) library\n-which has the design goal of making calls between processes look like calls in\n-the same process to the extent possible.\n+</td></tr><tr><td>\n+<code>Chain::getBlockHash</code> call diagram\n+</td></tr></table>\n+\n+1. **Initiation in bitcoin-wallet**\n+   - The wallet process calls the `getBlockHash` method on a `Chain` object. This method is defined as a virtual method in [`src/interfaces/chain.h`](../../src/interfaces/chain.h).\n+\n+2. **Translation to Cap’n Proto RPC**\n+   - The `Chain::getBlockHash` virtual method is overridden by the `Chain` [client subclass](#c-client-subclasses-in-generated-code) to translate the method call into a Cap’n Proto RPC call.\n+   - The client subclass is automatically generated by the `mpgen` tool from the [`chain.capnp`](https://github.com/ryanofsky/bitcoin/blob/pr/ipc/src/ipc/capnp/chain.capnp) file in [`src/ipc/capnp/`](../../src/ipc/capnp/).\n+\n+3. **Request Preparation and Dispatch**\n+   - The `getBlockHash` method of the generated `Chain` client subclass in `bitcoin-wallet` populates a Cap’n Proto request with the `height` parameter, sends it to `bitcoin-node` process, and waits for a response.\n+\n+4. **Handling in bitcoin-node**\n+   - Upon receiving the request, the Cap'n Proto dispatching code in the `bitcoin-node` process calls the `getBlockHash` method of the `Chain` [server class](#c-server-classes-in-generated-code).\n+   - The server class is automatically generated by the `mpgen` tool from the [`chain.capnp`](https://github.com/ryanofsky/bitcoin/blob/pr/ipc/src/ipc/capnp/chain.capnp) file in [`src/ipc/capnp/`](../../src/ipc/capnp/).\n+   - The `getBlockHash` method of the generated `Chain` server subclass in `bitcoin-wallet` receives a Cap’n Proto request object with the `height` parameter, and calls the `getBlockHash` method on its local `Chain` object with the provided `height`.\n+   - When the call returns, it encapsulates the return value in a Cap’n Proto response, which it sends back to the `bitcoin-wallet` process,",
      "path": "doc/design/multiprocess.md",
      "position": 259,
      "original_position": 259,
      "commit_id": "91dc48c14825a9075a57c1eefda202b83b6346ba",
      "original_commit_id": "91dc48c14825a9075a57c1eefda202b83b6346ba",
      "in_reply_to_id": 1439470004,
      "user": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "re: https://github.com/bitcoin/bitcoin/pull/28978#discussion_r1439470004\r\n\r\n> \r\n\r\nThanks, fixed in #10102",
      "created_at": "2024-01-11T22:30:33Z",
      "updated_at": "2024-01-11T23:25:31Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28978#discussion_r1449474251",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1449474251"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28978"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 200,
      "original_line": 200,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1449474349",
      "pull_request_review_id": 1816915195,
      "id": 1449474349,
      "node_id": "PRRC_kwDOABII585WZTkt",
      "diff_hunk": "@@ -1,72 +1,264 @@\n-# Multiprocess Bitcoin\n+# Multiprocess Bitcoin Design Document\n \n-On unix systems, the `--enable-multiprocess` build option can be passed to `./configure` to build new `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables alongside existing `bitcoind` and `bitcoin-qt` executables.\n+Guide to the design and architecture of the Bitcoin Core multiprocess feature\n \n-`bitcoin-node` is a drop-in replacement for `bitcoind`, and `bitcoin-gui` is a drop-in replacement for `bitcoin-qt`, and there are no differences in use or external behavior between the new and old executables. But internally (after [#10102](https://github.com/bitcoin/bitcoin/pull/10102)), `bitcoin-gui` will spawn a `bitcoin-node` process to run P2P and RPC code, communicating with it across a socket pair, and `bitcoin-node` will spawn `bitcoin-wallet` to run wallet code, also communicating over a socket pair. This will let node, wallet, and GUI code run in separate address spaces for better isolation, and allow future improvements like being able to start and stop components independently on different machines and environments.\n+_This document describes the design of the multiprocess feature. For usage information, see the top-level [multiprocess.md](../multiprocess.md) file._\n \n-## Next steps\n+## Table of contents\n \n-Specific next steps after [#10102](https://github.com/bitcoin/bitcoin/pull/10102) will be:\n+- [Introduction](#introduction)\n+- [Current Architecture](#current-architecture)\n+- [Proposed Architecture](#proposed-architecture)\n+- [Component Overview: Navigating the IPC Framework](#component-overview-navigating-the-ipc-framework)\n+- [Design Considerations](#design-considerations)\n+  - [Selection of Cap’n Proto](#selection-of-capn-proto)\n+  - [Hiding IPC](#hiding-ipc)\n+  - [Interface Definition Maintenance](#interface-definition-maintenance)\n+  - [Interface Stability](#interface-stability)\n+- [Security Considerations](#security-considerations)\n+- [Example Use Cases and Flows](#example-use-cases-and-flows)\n+  - [Retrieving a Block Hash](#retrieving-a-block-hash)\n+- [Future Enhancements](#future-enhancements)\n+- [Conclusion](#conclusion)\n+- [Appendices](#appendices)\n+  - [Glossary of Terms](#glossary-of-terms)\n+  - [References](#references)\n+- [Acknowledgements](#acknowledgements)\n \n-- [ ] Adding `-ipcbind` and `-ipcconnect` options to `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables so they can listen and connect to TCP ports and unix socket paths. This will allow separate processes to be started and stopped any time and connect to each other.\n-- [ ] Adding `-server` and `-rpcbind` options to the `bitcoin-wallet` executable so wallet processes can handle RPC requests directly without going through the node.\n-- [ ] Supporting windows, not just unix systems. The existing socket code is already cross-platform, so the only windows-specific code that needs to be written is code spawning a process and passing a socket descriptor. This can be implemented with `CreateProcess` and `WSADuplicateSocket`. Example: https://memset.wordpress.com/2010/10/13/win32-api-passing-socket-with-ipc-method/.\n-- [ ] Adding sandbox features, restricting subprocess access to resources and data. See [https://eklitzke.org/multiprocess-bitcoin](https://eklitzke.org/multiprocess-bitcoin).\n+## Introduction\n \n-## Debugging\n+The Bitcoin Core software has historically employed a monolithic architecture. The existing design has integrated functionality like P2P network operations, wallet management, and a GUI into a single executable. While effective, it has limitations in flexibility, security, and scalability. This project introduces changes that transition Bitcoin Core to a more modular architecture. It aims to enhance security, improve usability, and facilitate maintenance and development of the software in the long run.\n \n-The `-debug=ipc` command line option can be used to see requests and responses between processes.\n+## Current Architecture\n \n-## Installation\n+The current system features two primary executables: `bitcoind` and `bitcoin-qt`. `bitcoind` combines a Bitcoin P2P node with an integrated JSON-RPC server, wallet, and indexes. `bitcoin-qt` extends this by incorporating a Qt-based GUI. This monolithic structure, although robust, presents challenges such as limited operational flexibility and increased security risks due to the tight integration of components.\n \n-The multiprocess feature requires [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) as dependencies. A simple way to get starting using it without installing these dependencies manually is to use the [depends system](../../depends) with the `MULTIPROCESS=1` [dependency option](../../depends#dependency-options) passed to make:\n+## Proposed Architecture\n \n+The new architecture divides the existing code into three specialized executables:\n+\n+- `bitcoin-node`: Manages the P2P node, indexes, and JSON-RPC server.\n+- `bitcoin-wallet`: Handles all wallet functionality.\n+- `bitcoin-gui`: Provides a standalone Qt-based GUI.\n+\n+This modular approach is designed to enhance security through component isolation and improve usability by allowing independent operation of each module. This allows for new use-cases, such as running the node on a dedicated machine and operating wallets and GUIs on separate machines with the flexibility to start and stop them as needed.\n+\n+This subdivision could be extended in the future. For example, indexes could be removed from the `bitcoin-node` executable and run in separate executables. And JSON-RPC servers could be added to wallet and index executables, so they can listen and respond to RPC requests on their own ports, without needing to forward RPC requests through `bitcoin-node`.\n+\n+<table><tr><td>\n+\n+```mermaid\n+flowchart LR\n+    node[bitcoin-node] -- listens on --> socket[\"&lt;datadir&gt;/node.sock\"]\n+    wallet[bitcoin-wallet] -- connects to --> socket\n+    gui[bitcoin-gui] -- connects to --> socket\n+```\n+\n+</td></tr><tr><td>\n+Processes and socket connection.\n+</td></tr></table>\n+\n+## Component Overview: Navigating the IPC Framework\n+\n+This section describes the major components of the Inter-Process Communication (IPC) framework covering the relevant source files, generated files, tools, and libraries.\n+\n+### Abstract C++ Classes in [`src/interfaces/`](../../src/interfaces/)\n+- The foundation of the IPC implementation lies in the abstract C++ classes within the [`src/interfaces/`](../../src/interfaces/) directory. These classes define pure virtual methods that code in [`src/node/`](../../src/node/), [`src/wallet/`](../../src/wallet/), and [`src/qt/`](../../src/qt/) directories call to interact with each other.\n+- Each abstract class in this directory represents a distinct interface that the different modules (node, wallet, GUI) implement and use for cross-process communication.\n+- The classes are written following conventions described in [Internal Interface\n+  Guidelines](../developer-notes.md#internal-interface-guidelines) to ensure\n+  compatibility with Cap'n Proto.\n+\n+### Cap’n Proto Files in [`src/ipc/capnp/`](../../src/ipc/capnp/)\n+- Corresponding to each abstract class, there are `.capnp` files within the [`src/ipc/capnp/`](../../src/ipc/capnp/) directory. These files are used as input to the `mpgen` tool (described below) to generate C++ code.\n+- These Cap’n Proto files ([learn more about Cap'n Proto RPC](https://capnproto.org/rpc.html)) define the structure and format of messages that are exchanged over IPC. They serve as blueprints for generating C++ code that bridges the gap between high-level C++ interfaces and low-level socket communication.\n+\n+### The `mpgen` Code Generation Tool\n+- A central component of the IPC framework is the `mpgen` tool which is part the [`libmultiprocess` project](https://github.com/chaincodelabs/libmultiprocess). This tool takes the `.capnp` files as input and generates C++ code.\n+- The generated code handles IPC communication, translating interface calls into socket reads and writes.\n+\n+### C++ Client Subclasses in Generated Code\n+- In the generated code, we have C++ client subclasses that inherit from the abstract classes in [`src/interfaces/`](../../src/interfaces/). These subclasses are the workhorses of the IPC mechanism.\n+- They implement all the methods of the interface, marshalling arguments into a structured format, sending them as requests to the IPC server via a UNIX socket, and handling the responses.\n+- These subclasses effectively mask the complexity of IPC, presenting a familiar C++ interface to developers.\n+- Internally, the client subclasses generated by the `mpgen` tool wrap [client classes generated by Cap'n Proto](https://capnproto.org/cxxrpc.html#clients), and use them to send IPC requests.\n+\n+### C++ Server Classes in Generated Code\n+- On the server side, corresponding generated C++ classes receive IPC requests. These server classes are responsible for unmarshalling method arguments, invoking the corresponding methods in the local [`src/interfaces/`](../../src/interfaces/) objects, and creating the IPC response.\n+- The server classes ensure that return values (including output argument values and thrown exceptions) are marshalled and sent back to the client, completing the communication cycle.\n+- Internally, the server subclasses generated by the `mpgen` tool inherit from [server classes generated by Cap'n Proto](https://capnproto.org/cxxrpc.html#servers), and use them to process IPC requests.\n+\n+### The `libmultiprocess` Runtime Library\n+- **Core Functionality**: The `libmultiprocess` runtime library's primary function is to instantiate the generated client and server classes as needed.\n+- **Bootstrapping IPC Connections**: It provides functions for starting new IPC connections, specifically binding generated client and server classes for an initial `interfaces::Init` interface (defined in [`src/interfaces/init.h`](../../src/interfaces/init.h)) to a UNIX socket. This initial interface has methods returning other interfaces that different Bitcoin Core modules use to communicate after the bootstrapping phase.\n+- **Asynchronous I/O and Thread Management**: The library is also responsible for managing I/O and threading. Particularly, it ensures that IPC requests never block each other and that new threads on either side of a connection can always make client calls. It also manages worker threads on the server side of calls, ensuring that calls from the same client thread always execute on the same server thread (to avoid locking issues and support nested callbacks).\n+\n+### Type Hooks in [`src/ipc/capnp/*-types.h`](../../src/ipc/capnp/)\n+- **Custom Type Conversions**: In [`src/ipc/capnp/*-types.h`](../../src/ipc/capnp/), function overloads of two `libmultiprocess` C++ functions, `mp::CustomReadField` and `mp::CustomBuildFields`, are defined. These overloads are used for customizing the conversion of specific C++ types to and from Cap’n Proto types.\n+- **Handling Special Cases**: The `mpgen` tool and `libmultiprocess` library can convert most C++ types to and from Cap’n Proto types automatically, including interface types, primitive C++ types, standard C++ types like `std::vector`, `std::set`, `std::map`, `std::tuple`, and `std::function`, as well as simple C++ structs that consist of aforementioned types and whose fields correspond 1:1 with Cap’n Proto struct fields. For other types, `*-types.h` files provide custom code to convert between C++ and Cap’n Proto data representations.\n+\n+### Protocol-Agnostic IPC Code in [`src/ipc/`](../../src/ipc/)\n+- **Broad Applicability**: Unlike the Cap’n Proto-specific code in [`src/ipc/capnp/`](../../src/ipc/capnp/), the code in the [`src/ipc/`](../../src/ipc/) directory is protocol-agnostic. This enables potential support for other protocols, such as gRPC or a custom protocol in the future.\n+- **Process Management and Socket Operations**: The main purpose of this component is to provide functions for spawning new processes and creating and connecting to UNIX sockets.\n+- **ipc::Exception Class**: This code also defines an `ipc::Exception` class which is thrown from the generated C++ client class methods when there is an unexpected IPC error, such as a disconnection.\n+\n+<table><tr><td>\n+\n+```mermaid\n+flowchart TD\n+    capnpFile[ipc/capnp/chain.capnp] -->|Input to| mpgenTool([mpgen Tool])\n+    mpgenTool -->|Generates| proxyTypesH[ipc/capnp/chain.capnp.proxy-types.h]\n+    mpgenTool --> proxyClientCpp[ipc/capnp/chain.capnp.proxy-client.c++]\n+    mpgenTool --> proxyServerCpp[ipc/capnp/chain.capnp.proxy-server.c++]\n+    proxyTypesH -.->|Includes| interfaces/chain.h\n+    proxyClientCpp -.-> interfaces/chain.h\n+    proxyServerCpp -.-> interfaces/chain.h\n ```\n-cd <BITCOIN_SOURCE_DIRECTORY>\n-make -C depends NO_QT=1 MULTIPROCESS=1\n-CONFIG_SITE=$PWD/depends/x86_64-pc-linux-gnu/share/config.site ./configure\n-make\n-src/bitcoin-node -regtest -printtoconsole -debug=ipc\n-BITCOIND=bitcoin-node test/functional/test_runner.py\n+\n+</td></tr><tr><td>\n+Diagram showing generated source files and includes.\n+</td></tr></table>\n+\n+## Design Considerations\n+\n+### Selection of Cap’n Proto\n+The choice to use [Cap’n Proto](https://capnproto.org/) for IPC was primarily influenced by its support for passing object references and managing object lifetimes, which would have to be implemented manually with a framework that only supported plain requests and responses like [gRPC](https://grpc.io/). The support is especially helpful for passing callback objects like `std::function` and enabling bidirectional calls between processes.\n+\n+The choice to use an RPC framework at all instead of a custom protocol was necessitated by the size of Bitcoin Core internal interfaces which consist of around 150 methods that pass complex data structures and are called in complicated ways (in parallel, and from callbacks that can be nested and stored). Writing a custom protocol to wrap these complicated interfaces would be a lot more work, akin to writing a new RPC framework.\n+\n+### Hiding IPC\n+\n+The IPC mechanism is deliberately isolated from the rest of the codebase so less code has to be concerned with IPC.\n+\n+Building Bitcoin Core with IPC support is optional, and node, wallet, and GUI code can be compiled to either run in the same process or separate processes. The build system also ensures Cap’n Proto library headers can only be used within the [`src/ipc/capnp/`](../../src/ipc/capnp/) directory, not in other parts of the codebase.\n+\n+The libmultiprocess runtime is designed to place as few constraints as possible on IPC interfaces and to make IPC calls act like normal function calls. Method arguments, return values, and exceptions are automatically serialized and sent between processes. Object references and `std::function` arguments are tracked to allow invoked code to call back into invoking code at any time. And there is a 1:1 threading model where every client thread has a corresponding server thread responsible for executing incoming calls from that thread (there can be multiple calls from the same thread due to callbacks) without blocking, and holding the same thread-local variables and locks so behavior is the same whether IPC is used or not.\n+\n+### Interface Definition Maintenance\n+\n+The choice to maintain interface definitions and C++ type mappings as `.capnp` files in the [`src/ipc/capnp/`](../../src/ipc/capnp/) was mostly done for convenience, and probably something that could be improved in the future.\n+\n+In the current design, class names, method names, and parameter names are duplicated between C++ interfaces in [`src/interfaces/`](../../src/interfaces/) and Cap’n Proto files in [`src/ipc/capnp/`](../../src/ipc/capnp/). While this keeps C++ interface headers simple and free of references to IPC, it is a maintenance burden because it means inconsistencies between C++ declarations and Cap’n Proto declarations will result in compile errors. (Static type checking ensures these are not runtime errors.)\n+\n+An alternate approach could use custom [C++ Attributes](https://en.cppreference.com/w/cpp/language/attributes) embedded in interface declarations to automatically generate `.capnp` files from C++ headers. This has not been pursued because parsing C++ headers is more complicated than parsing Cap’n Proto interface definitions, especially portably on multiple platforms.\n+\n+In the meantime, the developer guide [Internal interface guidelines](developer-notes.md#internal-interface-guidelines) can provide guidance on keeping interfaces consistent and functional and avoiding compile errors.\n+\n+### Interface Stability\n+\n+The currently defined IPC interfaces are unstable, and can change freely with no backwards compatibility. The decision to allow this stems from the recognition that our current interfaces are still evolving and not yet ideal for external use. As these interfaces mature and become more refined, there may be an opportunity to declare them stable and use Cap’n Proto's support for protocol evolution ([Cap'n Proto - Evolving Your Protocol](https://capnproto.org/language.html#evolving-your-protocol)) to allow them to be extended while remaining backwards compatible. This could allow different versions of node, GUI, and wallet binaries to interoperate, and potentially open doors for external tools to utilize these interfaces, such as creating custom indexes through a stable indexing interface. However, for now, the priority is to improve the interfaces internally. Given their current state and the advantages of using JSON-RPC for most common tasks, it's more practical to focus on internal development rather than external applicability.\n+\n+## Security Considerations\n+\n+The integration of [Cap’n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) into the Bitcoin Core architecture increases its potential attack surface. Cap’n Proto, being a complex and substantial new dependency, introduces potential sources of vulnerability, particularly through the creation of new UNIX sockets. The inclusion of libmultiprocess, while a smaller external dependency, also contributes to this risk. However, plans are underway to incorporate libmultiprocess as a git subtree, aligning it more closely with the project's well-reviewed internal libraries. While adopting these multiprocess features does introduce some risk, it's worth noting that they can be disabled, allowing builds without these new dependencies. This flexibility ensures that users can balance functionality with security considerations as needed.\n+\n+## Example Use Cases and Flows\n+\n+### Retrieving a Block Hash\n+\n+Let’s walk through an example where the `bitcoin-wallet` process requests the hash of a block at a specific height from the `bitcoin-node` process. This example demonstrates the practical application of the IPC mechanism, specifically the interplay between C++ method calls and Cap’n Proto-generated RPC calls.\n+\n+<table><tr><td>\n+\n+```mermaid\n+sequenceDiagram\n+    box \"bitcoin-wallet process\"\n+    participant WalletCode as Wallet code\n+    participant ChainClient as Generated Chain client class<br/>ProxyClient<messages::Chain>\n+    end\n+    box \"bitcoin-node process\"\n+    participant ChainServer as Generated Chain server class<br/>ProxyServer<messages::Chain>\n+    participant LocalChain as Chain object<br/>node::ChainImpl\n+    end\n+\n+    WalletCode->>ChainClient: getBlockHash(height)\n+    ChainClient->>ChainServer: Send RPC getBlockHash request\n+    ChainServer->>LocalChain: getBlockHash(height)\n+    LocalChain->>ChainServer: Return block hash\n+    ChainServer->>ChainClient: Send response with block hash\n+    ChainClient->>WalletCode: Return block hash\n ```\n \n-The configure script will pick up settings and library locations from the depends directory, so there is no need to pass `--enable-multiprocess` as a separate flag when using the depends system (it's controlled by the `MULTIPROCESS=1` option).\n-\n-Alternately, you can install [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) packages on your system, and just run `./configure --enable-multiprocess` without using the depends system. The configure script will be able to locate the installed packages via [pkg-config](https://www.freedesktop.org/wiki/Software/pkg-config/). See [Installation](https://github.com/chaincodelabs/libmultiprocess/blob/master/doc/install.md) section of the libmultiprocess readme for install steps. See [build-unix.md](../build-unix.md) and [build-osx.md](../build-osx.md) for information about installing dependencies in general.\n-\n-## IPC implementation details\n-\n-Cross process Node, Wallet, and Chain interfaces are defined in\n-[`src/interfaces/`](../../src/interfaces/). These are C++ classes which follow\n-[conventions](../developer-notes.md#internal-interface-guidelines), like passing\n-serializable arguments so they can be called from different processes, and\n-making methods pure virtual so they can have proxy implementations that forward\n-calls between processes.\n-\n-When Wallet, Node, and Chain code is running in the same process, calling any\n-interface method invokes the implementation directly. When code is running in\n-different processes, calling an interface method invokes a proxy interface\n-implementation that communicates with a remote process and invokes the real\n-implementation in the remote process. The\n-[libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) code\n-generation tool internally generates proxy client classes and proxy server\n-classes for this purpose that are thin wrappers around Cap'n Proto\n-[client](https://capnproto.org/cxxrpc.html#clients) and\n-[server](https://capnproto.org/cxxrpc.html#servers) classes, which handle the\n-actual serialization and socket communication.\n-\n-As much as possible, calls between processes are meant to work the same as\n-calls within a single process without adding limitations or requiring extra\n-implementation effort. Processes communicate with each other by calling regular\n-[C++ interface methods](../../src/interfaces/README.md). Method arguments and\n-return values are automatically serialized and sent between processes. Object\n-references and `std::function` arguments are automatically tracked and mapped\n-to allow invoked code to call back into invoking code at any time, and there is\n-a 1:1 threading model where any thread invoking a method in another process has\n-a corresponding thread in the invoked process responsible for executing all\n-method calls from the source thread, without blocking I/O or holding up another\n-call, and using the same thread local variables, locks, and callbacks between\n-calls. The forwarding, tracking, and threading is implemented inside the\n-[libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) library\n-which has the design goal of making calls between processes look like calls in\n-the same process to the extent possible.\n+</td></tr><tr><td>\n+<code>Chain::getBlockHash</code> call diagram\n+</td></tr></table>\n+\n+1. **Initiation in bitcoin-wallet**\n+   - The wallet process calls the `getBlockHash` method on a `Chain` object. This method is defined as a virtual method in [`src/interfaces/chain.h`](../../src/interfaces/chain.h).\n+\n+2. **Translation to Cap’n Proto RPC**\n+   - The `Chain::getBlockHash` virtual method is overridden by the `Chain` [client subclass](#c-client-subclasses-in-generated-code) to translate the method call into a Cap’n Proto RPC call.\n+   - The client subclass is automatically generated by the `mpgen` tool from the [`chain.capnp`](https://github.com/ryanofsky/bitcoin/blob/pr/ipc/src/ipc/capnp/chain.capnp) file in [`src/ipc/capnp/`](../../src/ipc/capnp/).\n+\n+3. **Request Preparation and Dispatch**\n+   - The `getBlockHash` method of the generated `Chain` client subclass in `bitcoin-wallet` populates a Cap’n Proto request with the `height` parameter, sends it to `bitcoin-node` process, and waits for a response.\n+\n+4. **Handling in bitcoin-node**\n+   - Upon receiving the request, the Cap'n Proto dispatching code in the `bitcoin-node` process calls the `getBlockHash` method of the `Chain` [server class](#c-server-classes-in-generated-code).\n+   - The server class is automatically generated by the `mpgen` tool from the [`chain.capnp`](https://github.com/ryanofsky/bitcoin/blob/pr/ipc/src/ipc/capnp/chain.capnp) file in [`src/ipc/capnp/`](../../src/ipc/capnp/).\n+   - The `getBlockHash` method of the generated `Chain` server subclass in `bitcoin-wallet` receives a Cap’n Proto request object with the `height` parameter, and calls the `getBlockHash` method on its local `Chain` object with the provided `height`.\n+   - When the call returns, it encapsulates the return value in a Cap’n Proto response, which it sends back to the `bitcoin-wallet` process,\n+\n+5. **Response and Return**\n+   - The `getBlockHash` method of the generated `Chain` client subclass in `bitcoin-wallet` which sent the request now receives the response.\n+   - It extracts the block hash value from the response, and returns it to the original caller.\n+\n+## Future Enhancements\n+\n+Further improvements are possible such as:\n+\n+- Separating indexes from `bitcoin-node`, and running indexing code in separate processes (see [indexes: Stop using node internal types #24230](https://github.com/bitcoin/bitcoin/pull/24230)).\n+- Enabling wallet processes to listen for JSON-RPC requests on their own ports instead of needing the node process to listen and forward requests to them.\n+- Automatically generating `.capnp` files from C++ interface definitions (see [Interface Definition Maintenance](#interface-definition-maintenance)).\n+- Simplifying and stabilizing interfaces (see [Interface Stability](#interface-stability)).\n+- Adding sandbox features, restricting subprocess access to resources and data (see [https://eklitzke.org/multiprocess-bitcoin](https://eklitzke.org/multiprocess-bitcoin)).\n+- Using Cap'n Proto's support for [other languages](https://capnproto.org/otherlang.html), such as [Rust](https://github.com/capnproto/capnproto-rust), to allow code written in other languages to call Bitcoin Core C++ code, and vice versa (see [How to rustify libmultiprocess? #56](https://github.com/chaincodelabs/libmultiprocess/issues/56)).\n+\n+## Conclusion\n+\n+This modularization represents an advancement in Bitcoin Core's architecture, offering enhanced security, flexibility, and maintainability. The project invites collaboration and feedback from the community.\n+\n+## Appendices\n+\n+### Glossary of Terms\n+\n+- **abstract class**: A class in C++ that consists of virtual functions. In the Bitcoin Core project, they define interfaces for inter-component communication.\n+\n+- **asynchronous I/O**: A form of input/output processing that allows a program to continue other operations while a transmission is in progress.\n+\n+- **Cap’n Proto**: A high-performance data serialization and RPC library, chosen for its support for object references and bidirectional communication.\n+\n+- **Cap’n Proto interface**: A set of methods defined in Cap’n Proto to facilitate structured communication between different software components.\n+\n+- **Cap’n Proto struct**: A structured data format used in Cap’n Proto, similar to structs in C++, for organizing and transporting data across different processes.\n+\n+- **client class (in generated code)**: A C++ class generated from a Cap’n Proto interface which inherits from a Bitcoin core abstract class, and implements each virtual method to send IPC requests to another process. (see also [components section](#c-client-subclasses-in-generated-code))",
      "path": "doc/design/multiprocess.md",
      "position": 294,
      "original_position": 294,
      "commit_id": "91dc48c14825a9075a57c1eefda202b83b6346ba",
      "original_commit_id": "91dc48c14825a9075a57c1eefda202b83b6346ba",
      "in_reply_to_id": 1439476415,
      "user": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "re: https://github.com/bitcoin/bitcoin/pull/28978#discussion_r1439476415\r\n\r\n> nit\r\n\r\nThanks, fixed in #10102",
      "created_at": "2024-01-11T22:30:40Z",
      "updated_at": "2024-01-11T23:25:31Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28978#discussion_r1449474349",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1449474349"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28978"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 235,
      "original_line": 235,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1449474426",
      "pull_request_review_id": 1816915195,
      "id": 1449474426,
      "node_id": "PRRC_kwDOABII585WZTl6",
      "diff_hunk": "@@ -0,0 +1,34 @@\n+# Multiprocess Bitcoin\n+\n+_This document describes usage of the multiprocess feature. For design information, see the [design/multiprocess.md](design/multiprocess.md) file._\n+\n+## Build Option\n+\n+On unix systems, the `--enable-multiprocess` build option can be passed to `./configure` to build new `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables alongside existing `bitcoind` and `bitcoin-qt` executables.\n+\n+## Debugging\n+\n+The `-debug=ipc` command line option can be used to see requests and responses between processes.\n+\n+## Installation\n+\n+The multiprocess feature requires [Cap'n Proto](https://capnproto.org/) and [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) as dependencies. A simple way to get started using it without installing these dependencies manually is to use the [depends system](../depends) with the `MULTIPROCESS=1` [dependency option](../depends#dependency-options) passed to make:\n+\n+```\n+cd <BITCOIN_SOURCE_DIRECTORY>\n+make -C depends NO_QT=1 MULTIPROCESS=1\n+CONFIG_SITE=$PWD/depends/x86_64-pc-linux-gnu/share/config.site ./configure",
      "path": "doc/multiprocess.md",
      "position": 20,
      "original_position": 20,
      "commit_id": "91dc48c14825a9075a57c1eefda202b83b6346ba",
      "original_commit_id": "91dc48c14825a9075a57c1eefda202b83b6346ba",
      "in_reply_to_id": 1439417050,
      "user": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "re: https://github.com/bitcoin/bitcoin/pull/28978#discussion_r1439417050\r\n\r\n> nit: Perhaps useful to parameterize the host platform to highlight it's configurable? E.g.\r\n\r\nThanks I split it into a separate variable and clarified how it could be set in #10102.",
      "created_at": "2024-01-11T22:30:48Z",
      "updated_at": "2024-01-11T23:25:31Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28978#discussion_r1449474426",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1449474426"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28978"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 20,
      "original_line": 20,
      "side": "RIGHT"
    }
  ]
}