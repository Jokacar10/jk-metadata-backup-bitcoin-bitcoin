{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970",
    "id": 1622183043,
    "node_id": "PR_kwDOABII585gsIyD",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/28970",
    "diff_url": "https://github.com/bitcoin/bitcoin/pull/28970.diff",
    "patch_url": "https://github.com/bitcoin/bitcoin/pull/28970.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28970",
    "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28970/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
    "number": 28970,
    "state": "closed",
    "locked": true,
    "maintainer_can_modify": false,
    "title": "p2p: opportunistically accept 1-parent-1-child packages",
    "user": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false,
      "patch_url": null
    },
    "body": "This enables 1p1c packages to propagate in the \"happy case\" (i.e. not reliable if there are adversaries) and contains a lot of package relay-related code. See https://github.com/bitcoin/bitcoin/issues/27463 for overall package relay tracking.\r\n\r\nRationale: This is \"non-robust 1-parent-1-child package relay\" which is immediately useful.\r\n- Relaying 1-parent-1-child CPFP when mempool min feerate is high would be a subset of all package relay use cases, but a pretty significant improvement over what we have today, where such transactions don't propagate at all. [1]\r\n- Today, a miner can run this with a normal/small maxmempool to get revenue from 1p1c CPFP'd transactions without losing out on the ones with parents below mempool minimum feerate.\r\n- The majority of this code is useful for building more featureful/robust package relay e.g. see the code in #27742.\r\n\r\nThe first 2 commits are followups from #29619:\r\n- https://github.com/bitcoin/bitcoin/pull/29619#discussion_r1523094034\r\n- https://github.com/bitcoin/bitcoin/pull/29619#discussion_r1519819257\r\n\r\nQ: What makes this short of a more full package relay feature?\r\n\r\n(1) it only supports packages in which 1 of the parents needs to be CPFP'd by the child. That includes 1-parent-1-child packages and situations in which the other parents already pay for themselves (and are thus in mempool already when the package is submitted). More general package relay is a future improvement that requires more engineering in mempool and validation - see #27463.\r\n\r\n(2) We rely on having kept the child in orphanage, and don't make any attempt to protect it while we wait to receive the parent. If we are experiencing a lot of orphanage churn (e.g. an adversary is purposefully sending us a lot of transactions with missing inputs), we will fail to submit packages. This limitation has been around for 12+ years, see #27742 which adds a token bucket scheme for protecting package-related orphans at a limited rate per peer.\r\n\r\n(3) Our orphan-handling logic is somewhat opportunistic; we don't make much effort to resolve an orphan beyond asking the child's sender for the parents. This means we may miss packages if the first sender fails to give us the parent (intentionally or unintentionally). To make this more robust, we need receiver-side logic to retry orphan resolution with multiple peers. This is also an existing problem which has a proposed solution in #28031.\r\n\r\n[1]: see this writeup and its links https://github.com/bitcoin/bips/blob/02ec218c7857ef60914e9a3d383b68caf987f70b/bip-0331.mediawiki#propagate-high-feerate-transactions",
    "labels": [
      {
        "id": 98298007,
        "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
        "name": "P2P",
        "color": "006b75",
        "default": false
      }
    ],
    "created_at": "2023-11-29T16:25:29Z",
    "updated_at": "2025-05-01T07:51:49Z",
    "closed_at": "2024-04-30T22:41:08Z",
    "mergeable_state": "unknown",
    "merged": true,
    "merged_at": "2024-04-30T22:41:08Z",
    "merged_by": {
      "login": "achow101",
      "id": 3782274,
      "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/achow101",
      "html_url": "https://github.com/achow101",
      "followers_url": "https://api.github.com/users/achow101/followers",
      "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
      "organizations_url": "https://api.github.com/users/achow101/orgs",
      "repos_url": "https://api.github.com/users/achow101/repos",
      "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/achow101/received_events",
      "type": "User",
      "site_admin": false,
      "patch_url": null
    },
    "merge_commit_sha": "d813ba1bc4b4da3ad1f3812b61ff125d1d664625",
    "assignees": [],
    "requested_reviewers": [
      {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    ],
    "requested_teams": [],
    "head": {
      "label": "glozow:2023-11-1p1c",
      "ref": "2023-11-1p1c",
      "sha": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "repo": {
        "id": 244262754,
        "node_id": "MDEwOlJlcG9zaXRvcnkyNDQyNjI3NTQ=",
        "name": "bitcoin",
        "full_name": "glozow/bitcoin",
        "owner": {
          "login": "glozow",
          "id": 25183001,
          "node_id": "MDQ6VXNlcjI1MTgzMDAx",
          "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/glozow",
          "html_url": "https://github.com/glozow",
          "followers_url": "https://api.github.com/users/glozow/followers",
          "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
          "organizations_url": "https://api.github.com/users/glozow/orgs",
          "repos_url": "https://api.github.com/users/glozow/repos",
          "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/glozow/received_events",
          "type": "User",
          "site_admin": false,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/glozow/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": true,
        "url": "https://api.github.com/repos/glozow/bitcoin",
        "archive_url": "https://api.github.com/repos/glozow/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/glozow/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/glozow/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/glozow/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/glozow/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/glozow/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/glozow/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/glozow/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/glozow/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/glozow/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/glozow/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/glozow/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/glozow/bitcoin/events",
        "forks_url": "https://api.github.com/repos/glozow/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/glozow/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/glozow/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/glozow/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/glozow/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/glozow/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/glozow/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/glozow/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/glozow/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/glozow/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/glozow/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/glozow/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/glozow/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/glozow/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/glozow/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/glozow/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:glozow/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/glozow/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/glozow/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/glozow/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/glozow/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/glozow/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/glozow/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/glozow/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/glozow/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/glozow/bitcoin/hooks",
        "svn_url": "https://github.com/glozow/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 4,
        "stargazers_count": 13,
        "watchers_count": 13,
        "size": 271423,
        "default_branch": "master",
        "open_issues_count": 0,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2025-04-28T21:04:55Z",
        "created_at": "2020-03-02T02:31:56Z",
        "updated_at": "2025-04-28T14:29:05Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "7973a670915632b75a6aa16f24f98b936865c48f",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false,
        "patch_url": null
      },
      "repo": {
        "id": 1181927,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTgxOTI3",
        "name": "bitcoin",
        "full_name": "bitcoin/bitcoin",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bitcoin",
        "archive_url": "https://api.github.com/repos/bitcoin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bitcoin/hooks",
        "svn_url": "https://github.com/bitcoin/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 37142,
        "stargazers_count": 83218,
        "watchers_count": 83218,
        "size": 280731,
        "default_branch": "master",
        "open_issues_count": 713,
        "is_template": false,
        "topics": [
          "bitcoin",
          "c-plus-plus",
          "cryptocurrency",
          "cryptography",
          "p2p"
        ],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2025-04-30T17:56:22Z",
        "created_at": "2010-12-19T15:16:43Z",
        "updated_at": "2025-05-01T07:39:03Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
      }
    },
    "author_association": "MEMBER",
    "draft": false,
    "additions": 1207,
    "deletions": 15,
    "changed_files": 11,
    "commits": 9,
    "review_comments": 286,
    "comments": 28
  },
  "events": [
    {
      "event": "labeled",
      "id": 11098739910,
      "node_id": "LE_lADOABII5854OHi1zwAAAAKViVTG",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11098739910",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-29T16:25:29Z",
      "label": {
        "name": "P2P",
        "color": "006b75"
      }
    },
    {
      "event": "commented",
      "id": 1832270655,
      "node_id": "IC_kwDOABII585tNjs_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1832270655",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-29T16:25:32Z",
      "updated_at": "2024-04-30T22:31:57Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage\nFor detailed information about the code coverage, see the [test coverage report](https://corecheck.dev/bitcoin/bitcoin/pulls/28970).\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| ACK | [instagibbs](https://github.com/bitcoin/bitcoin/pull/28970#pullrequestreview-2025023787), [sr-gi](https://github.com/bitcoin/bitcoin/pull/28970#issuecomment-2082822497), [theStack](https://github.com/bitcoin/bitcoin/pull/28970#pullrequestreview-2030612104), [dergoegge](https://github.com/bitcoin/bitcoin/pull/28970#pullrequestreview-2031444770), [achow101](https://github.com/bitcoin/bitcoin/pull/28970#pullrequestreview-2032571316) |\n| Concept ACK | [murchandamus](https://github.com/bitcoin/bitcoin/pull/28970#pullrequestreview-1977655865), [sdaftuar](https://github.com/bitcoin/bitcoin/pull/28970#pullrequestreview-2005939457) |\n\nIf your review is incorrectly listed, please react with 👎 to this comment and the bot will ignore it on the next update.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#29641](https://github.com/bitcoin/bitcoin/pull/29641) (scripted-diff: Use LogInfo/LogDebug over LogPrintf/LogPrint by maflcko)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#issuecomment-1832270655",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28970"
    },
    {
      "event": "renamed",
      "id": 11098760497,
      "node_id": "RTE_lADOABII5854OHi1zwAAAAKViaUx",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11098760497",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-29T16:27:12Z",
      "rename": {
        "from": "p2p: opportunistically accept 1-parent-1-child packages",
        "to": "[WIP] p2p: opportunistically accept 1-parent-1-child packages"
      }
    },
    {
      "event": "labeled",
      "id": 11100054509,
      "node_id": "LE_lADOABII5854OHi1zwAAAAKVnWPt",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11100054509",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-29T18:27:27Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "labeled",
      "id": 11210056927,
      "node_id": "LE_lADOABII5854OHi1zwAAAAKcK-Tf",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11210056927",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-12-11T12:53:58Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 11212029805,
      "node_id": "HRFPE_lADOABII5854OHi1zwAAAAKcSf9t",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11212029805",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "53513201cb94e24946a071029443b71d1aa7f446",
      "commit_url": "https://api.github.com/repos/glozow/bitcoin/commits/53513201cb94e24946a071029443b71d1aa7f446",
      "created_at": "2023-12-11T15:28:17Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 11212172220,
      "node_id": "HRFPE_lADOABII5854OHi1zwAAAAKcTCu8",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11212172220",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "8bbcc9204829575e6ef93d90f073ac9635032e22",
      "commit_url": "https://api.github.com/repos/glozow/bitcoin/commits/8bbcc9204829575e6ef93d90f073ac9635032e22",
      "created_at": "2023-12-11T15:39:23Z"
    },
    {
      "event": "unlabeled",
      "id": 11213318061,
      "node_id": "UNLE_lADOABII5854OHi1zwAAAAKcXaet",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11213318061",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-12-11T17:09:09Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "unlabeled",
      "id": 11213382508,
      "node_id": "UNLE_lADOABII5854OHi1zwAAAAKcXqNs",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11213382508",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-12-11T17:14:53Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 1850749413,
      "node_id": "IC_kwDOABII585uUDHl",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1850749413",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-12-11T19:31:03Z",
      "updated_at": "2023-12-11T19:31:03Z",
      "author_association": "MEMBER",
      "body": "Rebased and fixed CI. This is in draft because I'm focusing on v3 stuff, can be reviewed for its approach.",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#issuecomment-1850749413",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28970"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 11276598910,
      "node_id": "HRFPE_lADOABII5854OHi1zwAAAAKgIz5-",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11276598910",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "2237c6b9055c84ce8ca0a5d87b2eba503ea485e7",
      "commit_url": "https://api.github.com/repos/glozow/bitcoin/commits/2237c6b9055c84ce8ca0a5d87b2eba503ea485e7",
      "created_at": "2023-12-18T13:03:52Z"
    },
    {
      "event": "labeled",
      "id": 11499616344,
      "node_id": "LE_lADOABII5854OHi1zwAAAAKtbjhY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11499616344",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-16T14:23:45Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 1959598347,
      "node_id": "IC_kwDOABII5850zRkL",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1959598347",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-02-22T14:43:04Z",
      "updated_at": "2024-02-22T14:43:04Z",
      "author_association": "MEMBER",
      "body": "ready for un-draft?",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#issuecomment-1959598347",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28970"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 11894097234,
      "node_id": "HRFPE_lADOABII5854OHi1zwAAAALE8YVS",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11894097234",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "19015e3c9aed5709e776ef15bf9e73f126c7ea29",
      "commit_url": "https://api.github.com/repos/glozow/bitcoin/commits/19015e3c9aed5709e776ef15bf9e73f126c7ea29",
      "created_at": "2024-02-22T17:01:33Z"
    },
    {
      "event": "unlabeled",
      "id": 11895053507,
      "node_id": "UNLE_lADOABII5854OHi1zwAAAALFABzD",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11895053507",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-02-22T18:26:16Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "renamed",
      "id": 11906381144,
      "node_id": "RTE_lADOABII5854OHi1zwAAAALFrPVY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11906381144",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-02-23T17:28:47Z",
      "rename": {
        "from": "[WIP] p2p: opportunistically accept 1-parent-1-child packages",
        "to": "p2p: opportunistically accept 1-parent-1-child packages"
      }
    },
    {
      "event": "ready_for_review",
      "id": 11943052490,
      "node_id": "RFRE_lADOABII5854OHi1zwAAAALH3ITK",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/11943052490",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-02-27T20:57:03Z"
    },
    {
      "event": "reviewed",
      "id": 1906612532,
      "node_id": "PRR_kwDOABII585xpJk0",
      "url": null,
      "actor": null,
      "commit_id": "19015e3c9aed5709e776ef15bf9e73f126c7ea29",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "I focused on the first two refactoring commits. Might be helpful zeroing in on these since we probably need to justify each small behavior change or make sure we're aligning with old behavior.",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#pullrequestreview-1906612532",
      "submitted_at": "2024-03-04T15:25:42Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
    },
    {
      "event": "reviewed",
      "id": 1915025042,
      "node_id": "PRR_kwDOABII585yJPaS",
      "url": null,
      "actor": null,
      "commit_id": "19015e3c9aed5709e776ef15bf9e73f126c7ea29",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#pullrequestreview-1915025042",
      "submitted_at": "2024-03-04T18:36:26Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
    },
    {
      "event": "commented",
      "id": 1978540390,
      "node_id": "IC_kwDOABII58517iFm",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1978540390",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-03-05T11:24:37Z",
      "updated_at": "2024-03-05T11:24:37Z",
      "author_association": "MEMBER",
      "body": "Working on pulling the first 2 commits out into a separate PR.",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#issuecomment-1978540390",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28970"
    },
    {
      "event": "reviewed",
      "id": 1920028235,
      "node_id": "PRR_kwDOABII585ycU5L",
      "url": null,
      "actor": null,
      "commit_id": "3eddfb2147754c734c325e4ee0158872448a0a61",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#pullrequestreview-1920028235",
      "submitted_at": "2024-03-06T15:11:18Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12055804141,
      "node_id": "HRFPE_lADOABII5854OHi1zwAAAALOlPjt",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12055804141",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "0739b61bfcfec4ad620dc9fa12ca2ec52125cf9b",
      "commit_url": "https://api.github.com/repos/glozow/bitcoin/commits/0739b61bfcfec4ad620dc9fa12ca2ec52125cf9b",
      "created_at": "2024-03-08T13:32:40Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12056372483,
      "node_id": "HRFPE_lADOABII5854OHi1zwAAAALOnaUD",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12056372483",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "ec8f6acc9c596bab7acd86429d7c2624acec4bbd",
      "commit_url": "https://api.github.com/repos/glozow/bitcoin/commits/ec8f6acc9c596bab7acd86429d7c2624acec4bbd",
      "created_at": "2024-03-08T14:23:24Z"
    },
    {
      "event": "labeled",
      "id": 12056373431,
      "node_id": "LE_lADOABII5854OHi1zwAAAALOnai3",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12056373431",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-03-08T14:23:28Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 1985784443,
      "node_id": "IC_kwDOABII5852XKp7",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1985784443",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-03-08T14:23:29Z",
      "updated_at": "2024-03-08T14:23:29Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\n\n🚧 At least one of the CI tasks failed. Make sure to run all tests locally, according to the\ndocumentation.\n\nPossibly this is due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/22437958726</sub>",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#issuecomment-1985784443",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28970"
    },
    {
      "event": "unlabeled",
      "id": 12057273677,
      "node_id": "UNLE_lADOABII5854OHi1zwAAAALOq2VN",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12057273677",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-03-08T15:40:01Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 1988160421,
      "node_id": "IC_kwDOABII5852gOul",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1988160421",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-03-11T10:54:29Z",
      "updated_at": "2024-03-11T10:54:29Z",
      "author_association": "MEMBER",
      "body": "Opened #29619 for the first 2 commits, moving this to draft.",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#issuecomment-1988160421",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28970"
    },
    {
      "event": "convert_to_draft",
      "id": 12071725380,
      "node_id": "CTDE_lADOABII5854OHi1zwAAAALPh-lE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12071725380",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-03-11T10:54:40Z"
    },
    {
      "event": "referenced",
      "id": 12101977400,
      "node_id": "REFE_lADOABII5854OHi1zwAAAALRVYU4",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12101977400",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "264ca9db240158403f6b9076d2fd5ef2522c391b",
      "commit_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/264ca9db240158403f6b9076d2fd5ef2522c391b",
      "created_at": "2024-03-13T11:26:45Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12102330958,
      "node_id": "HRFPE_lADOABII5854OHi1zwAAAALRWupO",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12102330958",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "d1d7b12bc863d6959cfac2aff9f913eaa3b0ad39",
      "commit_url": "https://api.github.com/repos/glozow/bitcoin/commits/d1d7b12bc863d6959cfac2aff9f913eaa3b0ad39",
      "created_at": "2024-03-13T11:56:39Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12102366900,
      "node_id": "HRFPE_lADOABII5854OHi1zwAAAALRW3a0",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12102366900",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "5bf9a2739910da682b35a6a352d5c4f229bd36b7",
      "commit_url": "https://api.github.com/repos/glozow/bitcoin/commits/5bf9a2739910da682b35a6a352d5c4f229bd36b7",
      "created_at": "2024-03-13T11:59:49Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12102379711,
      "node_id": "HRFPE_lADOABII5854OHi1zwAAAALRW6i_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12102379711",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "2f25d2e0840e94bee1c6a8908d94baf076bf1567",
      "commit_url": "https://api.github.com/repos/glozow/bitcoin/commits/2f25d2e0840e94bee1c6a8908d94baf076bf1567",
      "created_at": "2024-03-13T12:00:50Z"
    },
    {
      "event": "commented",
      "id": 1994236318,
      "node_id": "IC_kwDOABII58523aGe",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1994236318",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-03-13T12:08:40Z",
      "updated_at": "2024-03-13T12:08:40Z",
      "author_association": "MEMBER",
      "body": "rebased and added followups from #29619",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#issuecomment-1994236318",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28970"
    },
    {
      "event": "ready_for_review",
      "id": 12102475680,
      "node_id": "RFRE_lADOABII5854OHi1zwAAAALRXR-g",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12102475680",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-03-13T12:08:43Z"
    },
    {
      "event": "reviewed",
      "id": 1935032934,
      "node_id": "PRR_kwDOABII585zVkJm",
      "url": null,
      "actor": null,
      "commit_id": "2f25d2e0840e94bee1c6a8908d94baf076bf1567",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "some comments, running patch on a listening node longer-term to test behavior",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#pullrequestreview-1935032934",
      "submitted_at": "2024-03-18T13:58:32Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12188895900,
      "node_id": "HRFPE_lADOABII5854OHi1zwAAAALWg8qc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12188895900",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "ebc0f8fa46a3bc26b1d3154b5da5289b00582aab",
      "commit_url": "https://api.github.com/repos/glozow/bitcoin/commits/ebc0f8fa46a3bc26b1d3154b5da5289b00582aab",
      "created_at": "2024-03-20T17:42:09Z"
    },
    {
      "event": "commented",
      "id": 2010264127,
      "node_id": "IC_kwDOABII58530jI_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2010264127",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-03-20T17:55:44Z",
      "updated_at": "2024-03-20T17:55:44Z",
      "author_association": "MEMBER",
      "body": "Rebased for silent conflict with #28950",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#issuecomment-2010264127",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28970"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12189125520,
      "node_id": "HRFPE_lADOABII5854OHi1zwAAAALWh0uQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12189125520",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "5405171740aa77e1eb1110fa8be97318edba380a",
      "commit_url": "https://api.github.com/repos/glozow/bitcoin/commits/5405171740aa77e1eb1110fa8be97318edba380a",
      "created_at": "2024-03-20T17:55:45Z"
    },
    {
      "event": "labeled",
      "id": 12189126293,
      "node_id": "LE_lADOABII5854OHi1zwAAAALWh06V",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12189126293",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-03-20T17:55:50Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2010264297,
      "node_id": "IC_kwDOABII58530jLp",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2010264297",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-03-20T17:55:51Z",
      "updated_at": "2024-03-20T17:55:51Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\n\n🚧 At least one of the CI tasks failed. Make sure to run all tests locally, according to the\ndocumentation.\n\nPossibly this is due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/22896614286</sub>",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#issuecomment-2010264297",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28970"
    },
    {
      "event": "unlabeled",
      "id": 12190000570,
      "node_id": "UNLE_lADOABII5854OHi1zwAAAALWlKW6",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12190000570",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-03-20T19:07:50Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2017881418,
      "node_id": "IC_kwDOABII5854Rm1K",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2017881418",
      "actor": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-03-25T12:21:02Z",
      "updated_at": "2024-03-25T12:21:02Z",
      "author_association": "MEMBER",
      "body": "> Enable 1-parent-1-child package relay 🚀 (just using the existing protocol messages).\r\n\r\nImo, this isn't really what this PR does because \"package relay\" (at least to me) is something that is robust and users can rely on. As you note yourself, there is more work required to make this robust. \r\n\r\n> To make this more robust, we need receiver-side logic to retry orphan resolution with multiple peers.\r\n> To make this robust, we need to make efforts to protect some amount of orphans from eviction.\r\n\r\nWhy are we not making things more robust in or before this PR?",
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#issuecomment-2017881418",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28970"
    },
    {
      "event": "commented",
      "id": 2017893531,
      "node_id": "IC_kwDOABII5854Rpyb",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2017893531",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-03-25T12:28:27Z",
      "updated_at": "2024-03-25T12:29:17Z",
      "author_association": "MEMBER",
      "body": "> Imo, this isn't really what this PR does because \"package relay\" (at least to me) is something that is robust and users can rely on. As you note yourself, there is more work required to make this robust.\r\n\r\nthat sounds like confusing semantic games to me? We can add \"non-robust\" to the title to be clearer if we think it can get merged...\r\n\r\n> Why are we not making things more robust in or before this PR?\r\n\r\nWhy would we tie up an improvement on relay on other improvements to relay? This feature is useful by itself in non-adversarial network conditions, which ends up being deliverable security and a bit of increased miner fee revenue.\r\n\r\nOf course, if we have a orphanage hardening PR ready for merge, we should merge that.",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#issuecomment-2017893531",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28970"
    },
    {
      "event": "commented",
      "id": 2017902903,
      "node_id": "IC_kwDOABII5854RsE3",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2017902903",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-03-25T12:33:58Z",
      "updated_at": "2024-03-25T12:33:58Z",
      "author_association": "MEMBER",
      "body": "> Why are we not making things more robust in or before this PR?\r\n\r\nWhy have we been okay with handling any transactions with missing parents despite all of these orphanage problems, for more than a decade? Clearly because it's useful even if not 100% reliable. There are various improvements we can make to relay. I have already implemented them, and decided I would prefer to propose the more impactful improvements before the less impactful ones.",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#issuecomment-2017902903",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28970"
    },
    {
      "event": "commented",
      "id": 2018034011,
      "node_id": "IC_kwDOABII5854SMFb",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2018034011",
      "actor": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-03-25T13:41:26Z",
      "updated_at": "2024-03-25T13:41:26Z",
      "author_association": "MEMBER",
      "body": "> that sounds like confusing semantic games to me? We can add \"non-robust\" to the title to be clearer if we think it can get merged...\r\n\r\nI think my issue is with the PR description and how this will be marketed, not the title. The title describes it quite well: we will sometimes accept 1p1c packages (although it could also mention that these packages are constructed from the orphanage). That is different from package relay (again, to me \"package relay\" implies a level of reliability).\r\n\r\n> This feature is useful by itself in non-adversarial network conditions, which ends up being deliverable security\r\n\r\n\"deliverable security\": Is this referring to the increased cost of having to mess with relay to prevent pkgs from relaying? as opposed to the current state where these pkgs just don't relay at all?\r\n\r\n> Why have we been okay with handling any transactions with missing parents despite all of these orphanage problems, for more than a decade?\r\n\r\nBecause it saves bandwidth in the honest case. Afaict, relay would be reliable without the orphanage, although much more bandwidth intensive.\r\n\r\n---\r\n\r\nI guess my wording was confusing? I have no problem with the approach in this PR nor was I suggesting to block this on other relay improvements. I was just commenting on the PR description and asking a question.\r\n\r\nThere clearly are good answers to my question but I don't appreciate the condescending tone after being asked to review this PR.",
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#issuecomment-2018034011",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28970"
    },
    {
      "event": "commented",
      "id": 2018046569,
      "node_id": "IC_kwDOABII5854SPJp",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2018046569",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-03-25T13:47:45Z",
      "updated_at": "2024-03-25T13:47:45Z",
      "author_association": "MEMBER",
      "body": "> \"deliverable security\": Is this referring to the increased cost of having to mess with relay to prevent pkgs from relaying? as opposed to the current state where these pkgs just don't relay at all?\r\n\r\nAssuming there's a path of nodes to a miner in which they are not having their orphanages aggressively churned by an adversary,  these size 2 packages should be able to propagate. So if say a LN node goes offline or refuses to sign an updated commitment transaction that raises the transaction fee, minfee rises, the counterparty can still go to chain. It raises the bar a bit for an adversary, and the more benign cases can be resolved in the average case, letting people deploy liquidity elsewhere.\r\n\r\nFWIW I ran this branch over the last week, and when my minfee wasn't 1 I was getting about one extra package relayed every half hour.",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#issuecomment-2018046569",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28970"
    },
    {
      "event": "commented",
      "id": 2018133461,
      "node_id": "IC_kwDOABII5854SkXV",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2018133461",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-03-25T14:28:36Z",
      "updated_at": "2024-03-25T14:28:36Z",
      "author_association": "MEMBER",
      "body": "I've updated the PR description to be more descriptive about what this PR does and doesn't do. The 1p1c \"package relay\" thing wasn't meant as false advertising; I added it to the PR description 1 month after opening because it seemed like people were underestimating how useful this is (someone was surprised when I said this PR propagates 1p1c packages).\r\n\r\nI apologize for the tone - the comment read to me like a blocking criticism since it wasn't accompanied by any other review comments. Hopefully the suggestion has been adequately addressed with the description update now.",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#issuecomment-2018133461",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28970"
    },
    {
      "event": "commented",
      "id": 2019146019,
      "node_id": "IC_kwDOABII5854Wbkj",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2019146019",
      "actor": {
        "login": "Roasbeef",
        "id": 998190,
        "node_id": "MDQ6VXNlcjk5ODE5MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/998190?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Roasbeef",
        "html_url": "https://github.com/Roasbeef",
        "followers_url": "https://api.github.com/users/Roasbeef/followers",
        "following_url": "https://api.github.com/users/Roasbeef/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Roasbeef/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Roasbeef/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Roasbeef/subscriptions",
        "organizations_url": "https://api.github.com/users/Roasbeef/orgs",
        "repos_url": "https://api.github.com/users/Roasbeef/repos",
        "events_url": "https://api.github.com/users/Roasbeef/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Roasbeef/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-03-26T00:19:14Z",
      "updated_at": "2024-03-26T00:21:49Z",
      "author_association": "NONE",
      "body": "Popping in here to mention that even w/ the limitations described above, this would be super useful for LN as is. \r\n\r\nToday we're able to use the anchor outputs on commitment transactions to CPFP a force close (* caveats re pinning, RBF, etc, etc). This works OK during calm mempool conditions, but if a rapid spike occurs that causes the bottom of the mempool to fall out, then CPFP no longer works as the parent has been evicted. During one of the recent more persistent fee spikes, we saw this happening rather frequently, which then led to cascading force closes (outgoing HTLC can't timeout due to non confirmation, incoming times out, repeat) and a lots of pain and user confusion (can only wait or use a transaction \"accelerator\"). \r\n\r\nIIUC, with this PR, upgraded peers will optimistically attempt to fetch the parent (the commitment txn) when they see a transaction that appears to be fee bumping it (anchor output spend). With this behavior, on a best effort basis, if we had another massive spike, then commitment transactions would be able to confirm as upgraded peers would fetch the parent to consider/propagate. I think this is very attractive as it doesn't necessarily require a new p2p upgrade to gain the benefits, instead as nodes start to progressively update, then more of these otherwise unrecognized packages will start to propagate. \r\n\r\nIf major LN node operators are made aware of this patch, and start to run it with the node backing their LN nodes, then assuming a relay path to miners (who seem to be willing to mine/relay just about anything these days), this would be a rather nice stop gap while the greater v3/cluster work proceeds in the background. ",
      "user": {
        "login": "Roasbeef",
        "id": 998190,
        "node_id": "MDQ6VXNlcjk5ODE5MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/998190?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Roasbeef",
        "html_url": "https://github.com/Roasbeef",
        "followers_url": "https://api.github.com/users/Roasbeef/followers",
        "following_url": "https://api.github.com/users/Roasbeef/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Roasbeef/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Roasbeef/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Roasbeef/subscriptions",
        "organizations_url": "https://api.github.com/users/Roasbeef/orgs",
        "repos_url": "https://api.github.com/users/Roasbeef/repos",
        "events_url": "https://api.github.com/users/Roasbeef/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Roasbeef/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#issuecomment-2019146019",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28970"
    },
    {
      "event": "reviewed",
      "id": 1960994723,
      "node_id": "PRR_kwDOABII58504mej",
      "url": null,
      "actor": null,
      "commit_id": "5405171740aa77e1eb1110fa8be97318edba380a",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "no issues running the patch so far, some more comments",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#pullrequestreview-1960994723",
      "submitted_at": "2024-03-26T20:12:55Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
    },
    {
      "event": "referenced",
      "id": 12258169321,
      "node_id": "REFE_lADOABII5854OHi1zwAAAALapNHp",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12258169321",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "a5212a2d0b1f770f9c8f897c5c0d5de33a4c6fb3",
      "commit_url": "https://api.github.com/repos/theStack/bitcoin/commits/a5212a2d0b1f770f9c8f897c5c0d5de33a4c6fb3",
      "created_at": "2024-03-27T00:35:14Z"
    },
    {
      "event": "reviewed",
      "id": 1966207399,
      "node_id": "PRR_kwDOABII5851MfGn",
      "url": null,
      "actor": null,
      "commit_id": "f4d8fe713a036c4d2c1e7c2329077c34f75c8608",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#pullrequestreview-1966207399",
      "submitted_at": "2024-03-28T13:19:39Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
    },
    {
      "event": "reviewed",
      "id": 1966215922,
      "node_id": "PRR_kwDOABII5851MhLy",
      "url": null,
      "actor": null,
      "commit_id": "5405171740aa77e1eb1110fa8be97318edba380a",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#pullrequestreview-1966215922",
      "submitted_at": "2024-03-28T13:23:18Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12285241641,
      "node_id": "HRFPE_lADOABII5854OHi1zwAAAALcQekp",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12285241641",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "5d7fa1f68402c0af08f58ac30522ce9511d218c3",
      "commit_url": "https://api.github.com/repos/glozow/bitcoin/commits/5d7fa1f68402c0af08f58ac30522ce9511d218c3",
      "created_at": "2024-03-28T17:37:44Z"
    },
    {
      "event": "commented",
      "id": 2025812846,
      "node_id": "IC_kwDOABII5854v3Nu",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2025812846",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-03-28T18:03:47Z",
      "updated_at": "2024-04-16T12:35:21Z",
      "author_association": "MEMBER",
      "body": "Thanks for the review, addressed comments and\r\n- fixed a bug in `GetChildren`\r\n- expanded + added more docs to the individual logic tests\r\n- got rid of the `assert_debug_log` lines in the functional tests. The only \"coverage\" that's lost is us skipping children with which we've already tried+failed the package submission. I have a [branch with them](https://github.com/glozow/bitcoin/blob/2024-03-28970-test-logs/test/functional/p2p_opportunistic_1p1c.py) if you want to use it to test the code, but log asserts didn't feel appropriate to have in the functional test.\r\n- added more logging, realized it was annoyingly hard to look up success/fail package evals while searching logs on my node\r\n\r\nfwiw running this on a `-maxmempool=150` node, for the past few days, on average:\r\n- 222 attempted package validations per day\r\n- 85 packages (so 170 txns) accepted per day\r\n- 57% of the package transactions accepted ended up in a block. These are all transactions that we would have otherwise rejected, so this logic is definitely useful at helping us maximize the fees in our limited mempool space.",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#issuecomment-2025812846",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28970"
    },
    {
      "event": "labeled",
      "id": 12286998441,
      "node_id": "LE_lADOABII5854OHi1zwAAAALcXLep",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12286998441",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-03-28T20:11:53Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2026028069,
      "node_id": "IC_kwDOABII5854wrwl",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2026028069",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-03-28T20:11:54Z",
      "updated_at": "2024-03-28T20:11:54Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\n\n🚧 At least one of the CI tasks failed. Make sure to run all tests locally, according to the\ndocumentation.\n\nPossibly this is due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/23211258926</sub>",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#issuecomment-2026028069",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28970"
    },
    {
      "event": "reviewed",
      "id": 1970039534,
      "node_id": "PRR_kwDOABII5851bGru",
      "url": null,
      "actor": null,
      "commit_id": "5d7fa1f68402c0af08f58ac30522ce9511d218c3",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Concept ACK\r\n\r\nFound some nitty stuff mostly in tests so far, planning to do another review round next week.",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#pullrequestreview-1970039534",
      "submitted_at": "2024-03-30T18:52:08Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12325877911,
      "node_id": "HRFPE_lADOABII5854OHi1zwAAAALerfiX",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12325877911",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "7cc42a482c563111ce9faa5d801f866af0222b22",
      "commit_url": "https://api.github.com/repos/glozow/bitcoin/commits/7cc42a482c563111ce9faa5d801f866af0222b22",
      "created_at": "2024-04-02T13:23:03Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12326266219,
      "node_id": "HRFPE_lADOABII5854OHi1zwAAAALes-Vr",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12326266219",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "c5e196b8e7b610cc9e6321b76fee4f0c45c1448e",
      "commit_url": "https://api.github.com/repos/glozow/bitcoin/commits/c5e196b8e7b610cc9e6321b76fee4f0c45c1448e",
      "created_at": "2024-04-02T13:45:12Z"
    },
    {
      "event": "reviewed",
      "id": 1977655865,
      "node_id": "PRR_kwDOABII58514KI5",
      "url": null,
      "actor": null,
      "commit_id": "c5e196b8e7b610cc9e6321b76fee4f0c45c1448e",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Did a quick pass. I am surprised we are able to get this big of an improvement without p2p changes, seems like a big win. Big Concept ACK, but I must admit this part of the codebase is a bit out of my wheelhouse.",
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#pullrequestreview-1977655865",
      "submitted_at": "2024-04-03T19:51:16Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
    },
    {
      "event": "reviewed",
      "id": 1976216428,
      "node_id": "PRR_kwDOABII5851yqts",
      "url": null,
      "actor": null,
      "commit_id": "c5e196b8e7b610cc9e6321b76fee4f0c45c1448e",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "reviewed through 81912ae6649fac5a0d671d2cabe344f787193997\r\n\r\nLGTM so far\r\n\r\nwill review tests",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#pullrequestreview-1976216428",
      "submitted_at": "2024-04-04T09:55:53Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
    },
    {
      "event": "reviewed",
      "id": 1979439672,
      "node_id": "PRR_kwDOABII5851-9o4",
      "url": null,
      "actor": null,
      "commit_id": "c5e196b8e7b610cc9e6321b76fee4f0c45c1448e",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#pullrequestreview-1979439672",
      "submitted_at": "2024-04-04T10:25:44Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
    },
    {
      "event": "commented",
      "id": 2036791219,
      "node_id": "IC_kwDOABII5855Zvez",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2036791219",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-04T10:27:05Z",
      "updated_at": "2024-04-04T10:27:05Z",
      "author_association": "MEMBER",
      "body": "reviewed through c5e196b8e7b610cc9e6321b76fee4f0c45c1448e",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#issuecomment-2036791219",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28970"
    },
    {
      "event": "unlabeled",
      "id": 12365177425,
      "node_id": "UNLE_lADOABII5854OHi1zwAAAALhBaJR",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12365177425",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-04T21:43:28Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12377130105,
      "node_id": "HRFPE_lADOABII5854OHi1zwAAAALhvAR5",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12377130105",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "a07272cbac05789c5b08fd546ea9ac6b79f9b749",
      "commit_url": "https://api.github.com/repos/glozow/bitcoin/commits/a07272cbac05789c5b08fd546ea9ac6b79f9b749",
      "created_at": "2024-04-05T16:57:45Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12377291614,
      "node_id": "HRFPE_lADOABII5854OHi1zwAAAALhvnte",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12377291614",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "fd5e770cd5ca3de4a7f8b63fb08e1ef87ef88313",
      "commit_url": "https://api.github.com/repos/glozow/bitcoin/commits/fd5e770cd5ca3de4a7f8b63fb08e1ef87ef88313",
      "created_at": "2024-04-05T17:16:18Z"
    },
    {
      "event": "labeled",
      "id": 12380260026,
      "node_id": "LE_lADOABII5854OHi1zwAAAALh68a6",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12380260026",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-06T00:29:33Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12402916036,
      "node_id": "HRFPE_lADOABII5854OHi1zwAAAALjRXrE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12402916036",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "e313001b1bf12f9fafeef1029d365af2c8f8126e",
      "commit_url": "https://api.github.com/repos/glozow/bitcoin/commits/e313001b1bf12f9fafeef1029d365af2c8f8126e",
      "created_at": "2024-04-09T08:15:19Z"
    },
    {
      "event": "reviewed",
      "id": 1988568046,
      "node_id": "PRR_kwDOABII5852hyPu",
      "url": null,
      "actor": null,
      "commit_id": "e313001b1bf12f9fafeef1029d365af2c8f8126e",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#pullrequestreview-1988568046",
      "submitted_at": "2024-04-10T07:27:52Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12436188522,
      "node_id": "HRFPE_lADOABII5854OHi1zwAAAALlQS1q",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12436188522",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "c6b1d20a8ef55475949efda1108b5966a45acc1c",
      "commit_url": "https://api.github.com/repos/glozow/bitcoin/commits/c6b1d20a8ef55475949efda1108b5966a45acc1c",
      "created_at": "2024-04-11T12:57:41Z"
    },
    {
      "event": "commented",
      "id": 2049639073,
      "node_id": "IC_kwDOABII5856KwKh",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2049639073",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-11T12:58:23Z",
      "updated_at": "2024-04-11T12:58:23Z",
      "author_association": "MEMBER",
      "body": "Rebased for #29735 and fixed failure.",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#issuecomment-2049639073",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28970"
    },
    {
      "event": "unlabeled",
      "id": 12438335013,
      "node_id": "UNLE_lADOABII5854OHi1zwAAAALlYe4l",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12438335013",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-11T15:30:20Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2056422724,
      "node_id": "IC_kwDOABII5856koVE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2056422724",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-15T09:55:01Z",
      "updated_at": "2024-04-15T09:55:01Z",
      "author_association": "MEMBER",
      "body": "Update since my last comment https://github.com/bitcoin/bitcoin/pull/28970#issuecomment-2025812846\r\nRunning for 20 days:\r\n- My node made 5218 package evaluation attempts (x2 = 10,436 transactions). That's ~260 attempts per day.\r\n- Of those attempts, 2260 were successful (x2 = 4520 transactions). That's ~43% acceptance rate.\r\n- Some were repeats. I have 4202 unique txids accepted through package evaluation. I don't know if they were repeated packages or not.\r\n- Of the accepted transactions, 3232 (77%) were later mined in a block.",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#issuecomment-2056422724",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28970"
    },
    {
      "event": "reviewed",
      "id": 2001371851,
      "node_id": "PRR_kwDOABII5853SoLL",
      "url": null,
      "actor": null,
      "commit_id": "c6b1d20a8ef55475949efda1108b5966a45acc1c",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Started reviewing - haven't looked at the tests yet.",
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#pullrequestreview-2001371851",
      "submitted_at": "2024-04-15T21:02:49Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDZmNGRhMTljYzNiMWI3Y2QyM2NiNGJlOTVhNmJiOWFjYjc5ZWIzYmY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6f4da19cc3b1b7cd23cb4be95a6bb9acb79eb3bf",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/6f4da19cc3b1b7cd23cb4be95a6bb9acb79eb3bf",
      "tree": {
        "sha": "ee6049fd4b0cd42c274baa231cca12f5be81f0e4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ee6049fd4b0cd42c274baa231cca12f5be81f0e4"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/bdb33ec51986570ea17406c83bad2c955ae23186",
          "sha": "bdb33ec51986570ea17406c83bad2c955ae23186",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/bdb33ec51986570ea17406c83bad2c955ae23186"
        }
      ],
      "message": "guard against MempoolAcceptResult::m_replaced_transactions\n\nIt should never be a nullopt when the transaction result is valid -\nAssume() this is the case. However, as a belt-and-suspenders just in\ncase it is nullopt, use an empty list.",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-04-16T09:09:45Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-03-13T11:25:24Z"
      },
      "sha": "6f4da19cc3b1b7cd23cb4be95a6bb9acb79eb3bf"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGMzYzFlMTU4MzFjNDYzZGY3OTY4YjAyOGE3N2U3ODdkYTdlNjI1NmQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c3c1e15831c463df7968b028a77e787da7e6256d",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/c3c1e15831c463df7968b028a77e787da7e6256d",
      "tree": {
        "sha": "08b0bcc78d548f1441959c2b12dd675a622d91c7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/08b0bcc78d548f1441959c2b12dd675a622d91c7"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6f4da19cc3b1b7cd23cb4be95a6bb9acb79eb3bf",
          "sha": "6f4da19cc3b1b7cd23cb4be95a6bb9acb79eb3bf",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/6f4da19cc3b1b7cd23cb4be95a6bb9acb79eb3bf"
        }
      ],
      "message": "[doc] restore comment about why we check if ptx HasWitness before caching rejected txid",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-04-16T09:11:01Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-03-13T11:45:33Z"
      },
      "sha": "c3c1e15831c463df7968b028a77e787da7e6256d"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12487611036,
      "node_id": "HRFPE_lADOABII5854OHi1zwAAAALoUdKc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12487611036",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "142d584dab3725081344520bec0a092d6b58d996",
      "commit_url": "https://api.github.com/repos/glozow/bitcoin/commits/142d584dab3725081344520bec0a092d6b58d996",
      "created_at": "2024-04-16T11:08:53Z"
    },
    {
      "event": "reviewed",
      "id": 2003285723,
      "node_id": "PRR_kwDOABII5853Z7bb",
      "url": null,
      "actor": null,
      "commit_id": "c6b1d20a8ef55475949efda1108b5966a45acc1c",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "thanks for the review @mzumsande!",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#pullrequestreview-2003285723",
      "submitted_at": "2024-04-16T11:09:21Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
    },
    {
      "event": "reviewed",
      "id": 1991298023,
      "node_id": "PRR_kwDOABII5852sMvn",
      "url": null,
      "actor": null,
      "commit_id": "142d584dab3725081344520bec0a092d6b58d996",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#pullrequestreview-1991298023",
      "submitted_at": "2024-04-16T11:42:24Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
    },
    {
      "event": "reviewed",
      "id": 2004232080,
      "node_id": "PRR_kwDOABII5853dieQ",
      "url": null,
      "actor": null,
      "commit_id": "142d584dab3725081344520bec0a092d6b58d996",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#pullrequestreview-2004232080",
      "submitted_at": "2024-04-16T17:48:56Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
    },
    {
      "event": "reviewed",
      "id": 2004307670,
      "node_id": "PRR_kwDOABII5853d07W",
      "url": null,
      "actor": null,
      "commit_id": "142d584dab3725081344520bec0a092d6b58d996",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#pullrequestreview-2004307670",
      "submitted_at": "2024-04-16T18:06:22Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
    },
    {
      "event": "reviewed",
      "id": 2006030894,
      "node_id": "PRR_kwDOABII5853kZou",
      "url": null,
      "actor": null,
      "commit_id": "142d584dab3725081344520bec0a092d6b58d996",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#pullrequestreview-2006030894",
      "submitted_at": "2024-04-17T13:20:27Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
    },
    {
      "event": "reviewed",
      "id": 2004484626,
      "node_id": "PRR_kwDOABII5853egIS",
      "url": null,
      "actor": null,
      "commit_id": "142d584dab3725081344520bec0a092d6b58d996",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "First pass. Reviewed up to 91f4efa420958a93f4620379f8830231f276b23b",
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#pullrequestreview-2004484626",
      "submitted_at": "2024-04-17T20:17:07Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
    },
    {
      "event": "reviewed",
      "id": 2008064624,
      "node_id": "PRR_kwDOABII5853sKJw",
      "url": null,
      "actor": null,
      "commit_id": "142d584dab3725081344520bec0a092d6b58d996",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#pullrequestreview-2008064624",
      "submitted_at": "2024-04-18T07:40:45Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12525800335,
      "node_id": "HRFPE_lADOABII5854OHi1zwAAAALqmIuP",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12525800335",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "0127ea79ca5c4b39e986cb3425edd48ac93ca76f",
      "commit_url": "https://api.github.com/repos/glozow/bitcoin/commits/0127ea79ca5c4b39e986cb3425edd48ac93ca76f",
      "created_at": "2024-04-18T15:59:28Z"
    },
    {
      "event": "reviewed",
      "id": 2009283703,
      "node_id": "PRR_kwDOABII5853wzx3",
      "url": null,
      "actor": null,
      "commit_id": "142d584dab3725081344520bec0a092d6b58d996",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Main changes:\r\n- Try same-peer orphanage children (most recent first) before different-peer ones (randomized). Replaced `GetChildren` with `GetChildrenFromSamePeer` and `GetChildrenFromDifferentPeer`.\r\n- Deleted `GetCombinedHash` because it's unused. Also deleted the tests for it\r\n- Changed `GetPackageHash` a bit. Using single-sha256 instead of double-sha256 and using just wtxids instead of serialized vector",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#pullrequestreview-2009283703",
      "submitted_at": "2024-04-18T16:02:17Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12526167603,
      "node_id": "HRFPE_lADOABII5854OHi1zwAAAALqniYz",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12526167603",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "9a00b09c53b30a453d2be9785858f62494869b75",
      "commit_url": "https://api.github.com/repos/glozow/bitcoin/commits/9a00b09c53b30a453d2be9785858f62494869b75",
      "created_at": "2024-04-18T16:29:45Z"
    },
    {
      "event": "commented",
      "id": 2064460626,
      "node_id": "IC_kwDOABII5857DStS",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2064460626",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-18T16:29:50Z",
      "updated_at": "2024-04-18T16:29:50Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\n\n🚧 At least one of the CI tasks failed. Make sure to run all tests locally, according to the\ndocumentation.\n\nPossibly this is due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/23986234746</sub>",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#issuecomment-2064460626",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28970"
    },
    {
      "event": "labeled",
      "id": 12526168447,
      "node_id": "LE_lADOABII5854OHi1zwAAAALqnil_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12526168447",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-18T16:29:50Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2066207955,
      "node_id": "IC_kwDOABII5857J9TT",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2066207955",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-19T09:40:20Z",
      "updated_at": "2024-04-19T09:40:20Z",
      "author_association": "MEMBER",
      "body": "debugging the p2p_opportunistic_1p1c.py failure. I think the wallet one is unrelated.",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#issuecomment-2066207955",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28970"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12536806405,
      "node_id": "HRFPE_lADOABII5854OHi1zwAAAALrQHwF",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12536806405",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "a053911cb9957797faff7f68dbd6deb6b6080578",
      "commit_url": "https://api.github.com/repos/glozow/bitcoin/commits/a053911cb9957797faff7f68dbd6deb6b6080578",
      "created_at": "2024-04-19T10:53:24Z"
    },
    {
      "event": "unlabeled",
      "id": 12537968995,
      "node_id": "UNLE_lADOABII5854OHi1zwAAAALrUjlj",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12537968995",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-19T12:23:35Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2066473350,
      "node_id": "IC_kwDOABII5857K-GG",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2066473350",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-19T12:32:21Z",
      "updated_at": "2024-04-19T12:32:21Z",
      "author_association": "MEMBER",
      "body": "Ok ready for review again.",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#issuecomment-2066473350",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28970"
    },
    {
      "event": "reviewed",
      "id": 2011541463,
      "node_id": "PRR_kwDOABII58535a_X",
      "url": null,
      "actor": null,
      "commit_id": "a053911cb9957797faff7f68dbd6deb6b6080578",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#pullrequestreview-2011541463",
      "submitted_at": "2024-04-19T14:08:56Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
    },
    {
      "event": "reviewed",
      "id": 2011658807,
      "node_id": "PRR_kwDOABII585353o3",
      "url": null,
      "actor": null,
      "commit_id": "a053911cb9957797faff7f68dbd6deb6b6080578",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#pullrequestreview-2011658807",
      "submitted_at": "2024-04-19T14:56:20Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
    },
    {
      "event": "referenced",
      "id": 12541628353,
      "node_id": "REFE_lADOABII5854OHi1zwAAAALrig_B",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12541628353",
      "actor": {
        "login": "Fabcien",
        "id": 44533924,
        "node_id": "MDQ6VXNlcjQ0NTMzOTI0",
        "avatar_url": "https://avatars.githubusercontent.com/u/44533924?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Fabcien",
        "html_url": "https://github.com/Fabcien",
        "followers_url": "https://api.github.com/users/Fabcien/followers",
        "following_url": "https://api.github.com/users/Fabcien/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Fabcien/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Fabcien/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Fabcien/subscriptions",
        "organizations_url": "https://api.github.com/users/Fabcien/orgs",
        "repos_url": "https://api.github.com/users/Fabcien/repos",
        "events_url": "https://api.github.com/users/Fabcien/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Fabcien/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "67c0d93982ad214f5e0c9509e9dc3d6d792ad97c",
      "commit_url": "https://api.github.com/repos/Fabcien/bitcoin/commits/67c0d93982ad214f5e0c9509e9dc3d6d792ad97c",
      "created_at": "2024-04-19T16:03:08Z"
    },
    {
      "event": "reviewed",
      "id": 2013113076,
      "node_id": "PRR_kwDOABII5853_ar0",
      "url": null,
      "actor": null,
      "commit_id": "a053911cb9957797faff7f68dbd6deb6b6080578",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Second pass (up to the same height: 42859548ab5aebf40da6089b85065f7c204b992a)\r\n\r\nLeft some additional comments on the updated approach.",
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#pullrequestreview-2013113076",
      "submitted_at": "2024-04-20T18:01:12Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12559020739,
      "node_id": "HRFPE_lADOABII5854OHi1zwAAAALsk3LD",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12559020739",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "7d220c6a5c0e0c5e8cfe79ebd2eae6e845d1d983",
      "commit_url": "https://api.github.com/repos/glozow/bitcoin/commits/7d220c6a5c0e0c5e8cfe79ebd2eae6e845d1d983",
      "created_at": "2024-04-22T12:25:29Z"
    },
    {
      "event": "reviewed",
      "id": 2015296846,
      "node_id": "PRR_kwDOABII5854Hv1O",
      "url": null,
      "actor": null,
      "commit_id": "7d220c6a5c0e0c5e8cfe79ebd2eae6e845d1d983",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "reviewed through 7d220c6a5c0e0c5e8cfe79ebd2eae6e845d1d983\r\n\r\ntested and confirmed fuzz coverage is hitting meaningful `GetChildrenFrom*` results\r\n\r\ncontinuing longer range testing\r\n\r\n",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#pullrequestreview-2015296846",
      "submitted_at": "2024-04-22T17:01:21Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
    },
    {
      "event": "reviewed",
      "id": 2005939457,
      "node_id": "PRR_kwDOABII5853kDUB",
      "url": null,
      "actor": null,
      "commit_id": "7d220c6a5c0e0c5e8cfe79ebd2eae6e845d1d983",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Code review ACK (apart from the tests, which I only skimmed).  Will test...",
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#pullrequestreview-2005939457",
      "submitted_at": "2024-04-22T22:38:06Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12572824226,
      "node_id": "HRFPE_lADOABII5854OHi1zwAAAALtZhKi",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12572824226",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "ea5a3b7ce79c6314f890f85176c4c14069aa94b5",
      "commit_url": "https://api.github.com/repos/glozow/bitcoin/commits/ea5a3b7ce79c6314f890f85176c4c14069aa94b5",
      "created_at": "2024-04-23T09:57:00Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12573860867,
      "node_id": "HRFPE_lADOABII5854OHi1zwAAAALtdeQD",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12573860867",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "4c343488e93b1e7088c349845ae520a8601b6e2b",
      "commit_url": "https://api.github.com/repos/glozow/bitcoin/commits/4c343488e93b1e7088c349845ae520a8601b6e2b",
      "created_at": "2024-04-23T11:16:51Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12574372173,
      "node_id": "HRFPE_lADOABII5854OHi1zwAAAALtfbFN",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12574372173",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "55b1280c52af81aa6ea0860799fa16da49f51447",
      "commit_url": "https://api.github.com/repos/glozow/bitcoin/commits/55b1280c52af81aa6ea0860799fa16da49f51447",
      "created_at": "2024-04-23T11:57:14Z"
    },
    {
      "event": "reviewed",
      "id": 2017100083,
      "node_id": "PRR_kwDOABII5854OoEz",
      "url": null,
      "actor": null,
      "commit_id": "bb3bf0a39c036fbd94b99ed7002db7d9bdf0a1d6",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#pullrequestreview-2017100083",
      "submitted_at": "2024-04-23T12:26:43Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
    },
    {
      "event": "reviewed",
      "id": 2017442665,
      "node_id": "PRR_kwDOABII5854P7tp",
      "url": null,
      "actor": null,
      "commit_id": "55b1280c52af81aa6ea0860799fa16da49f51447",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "reviewed through 55b1280c52af81aa6ea0860799fa16da49f51447\r\n\r\nLooks good, have a suggestion for a test catching the `Assume()` issue(which does actually get hit in mainnet pretty fast with debug on)",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#pullrequestreview-2017442665",
      "submitted_at": "2024-04-23T16:33:00Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12592585668,
      "node_id": "HRFPE_lADOABII5854OHi1zwAAAALuk5vE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12592585668",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "30c9e6bc4e9f8b8b606e55435dc3f743cb2dd670",
      "commit_url": "https://api.github.com/repos/glozow/bitcoin/commits/30c9e6bc4e9f8b8b606e55435dc3f743cb2dd670",
      "created_at": "2024-04-24T14:01:15Z"
    },
    {
      "event": "reviewed",
      "id": 2020006914,
      "node_id": "PRR_kwDOABII5854ZtwC",
      "url": null,
      "actor": null,
      "commit_id": "30c9e6bc4e9f8b8b606e55435dc3f743cb2dd670",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "ACK https://github.com/bitcoin/bitcoin/pull/28970/commits/30c9e6bc4e9f8b8b606e55435dc3f743cb2dd670\r\n\r\nChanges are test only, and new subtest causes a debug-build crash when the `PCKG_POLICY` change is reverted.",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#pullrequestreview-2020006914",
      "submitted_at": "2024-04-24T14:13:59Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
    },
    {
      "event": "review_requested",
      "id": 12592801047,
      "node_id": "RRE_lADOABII5854OHi1zwAAAALuluUX",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12592801047",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-24T14:14:06Z",
      "requested_reviewer": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "review_requested",
      "id": 12592801267,
      "node_id": "RRE_lADOABII5854OHi1zwAAAALuluXz",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12592801267",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-24T14:14:07Z",
      "requested_reviewer": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "review_requested",
      "id": 12592801492,
      "node_id": "RRE_lADOABII5854OHi1zwAAAALulubU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12592801492",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-24T14:14:08Z",
      "requested_reviewer": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "reviewed",
      "id": 2019874263,
      "node_id": "PRR_kwDOABII5854ZNXX",
      "url": null,
      "actor": null,
      "commit_id": "30c9e6bc4e9f8b8b606e55435dc3f743cb2dd670",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Another round through (modulo the fuzz commit), the code looks correct to me, just left a few nits below. Planning to do another review tomorrow with focus on the main commit bb3bf0a39c036fbd94b99ed7002db7d9bdf0a1d6, especially going through the `AlreadyHaveTx` call-sites and their `include_reconsiderable` values to check once more.",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#pullrequestreview-2019874263",
      "submitted_at": "2024-04-24T16:19:34Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
    },
    {
      "event": "review_requested",
      "id": 12594762136,
      "node_id": "RRE_lADOABII5854OHi1zwAAAALutNGY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12594762136",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-24T16:19:39Z",
      "requested_reviewer": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "reviewed",
      "id": 2015631578,
      "node_id": "PRR_kwDOABII5854JBja",
      "url": null,
      "actor": null,
      "commit_id": "30c9e6bc4e9f8b8b606e55435dc3f743cb2dd670",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Third pass, reviewing the changes of the first two, plus going all the way to 30c9e6bc4e9f8b8b606e55435dc3f743cb2dd670\r\n\r\nI think the code looks good overall, but I have some questions regarding some corner cases that I'm not completely sure about (see inline).\r\n\r\nFinally, something I've noticed: Given a `1p1c` whose parent we've seen already and we just received the child, the parent will be tried on its own twice before being considered as a package. This is because we will try it first when receiving it, another time when submitting it as a package, by splitting the package, and a third time alongside the child. My understanding of this is that we try to submit the smallest package that cannot make it on its own (I'm assuming to prevent some pathological cases). This makes sense in the general case, but not so much in the `1p1c`. I'm not sure having additional complexity to treat this specific case would be worth it though. ",
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#pullrequestreview-2015631578",
      "submitted_at": "2024-04-25T13:25:25Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDA5MmM5NzhhNDJlOGY0YTAyMjkxYjk5NDcxMzUwNWJhOGFhYzhiMjg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/092c978a42e8f4a02291b994713505ba8aac8b28",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/092c978a42e8f4a02291b994713505ba8aac8b28",
      "tree": {
        "sha": "7e267f6faf0fe2aae3eb9a30a472720cecac952d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7e267f6faf0fe2aae3eb9a30a472720cecac952d"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c3c1e15831c463df7968b028a77e787da7e6256d",
          "sha": "c3c1e15831c463df7968b028a77e787da7e6256d",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/c3c1e15831c463df7968b028a77e787da7e6256d"
        }
      ],
      "message": "[txpackages] add canonical way to get hash of package",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-04-26T09:28:27Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-04-16T10:58:25Z"
      },
      "sha": "092c978a42e8f4a02291b994713505ba8aac8b28"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDJmNTFjZDY4MGZiNDMyM2YxYzc5MmRhZTM3ZDRjNGUwZTBlMzU4MDQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2f51cd680fb4323f1c792dae37d4c4e0e0e35804",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/2f51cd680fb4323f1c792dae37d4c4e0e0e35804",
      "tree": {
        "sha": "e2c3e58a42fdd02acf0ab5ad1e63d64125c71f65",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e2c3e58a42fdd02acf0ab5ad1e63d64125c71f65"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/092c978a42e8f4a02291b994713505ba8aac8b28",
          "sha": "092c978a42e8f4a02291b994713505ba8aac8b28",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/092c978a42e8f4a02291b994713505ba8aac8b28"
        }
      ],
      "message": "[txorphanage] add method to get all orphans spending a tx",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-04-26T09:28:27Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-03-28T17:14:38Z"
      },
      "sha": "2f51cd680fb4323f1c792dae37d4c4e0e0e35804"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGQwOTUzMTZjMWMyM2U5NDYwZGZiZDlmZGJhZjI5MjA2M2FkY2QwODA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d095316c1c23e9460dfbd9fdbaf292063adcd080",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/d095316c1c23e9460dfbd9fdbaf292063adcd080",
      "tree": {
        "sha": "eed612dea4f438be20b033b452fca0cf6939ed57",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/eed612dea4f438be20b033b452fca0cf6939ed57"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2f51cd680fb4323f1c792dae37d4c4e0e0e35804",
          "sha": "2f51cd680fb4323f1c792dae37d4c4e0e0e35804",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/2f51cd680fb4323f1c792dae37d4c4e0e0e35804"
        }
      ],
      "message": "[unit test] TxOrphanage::GetChildrenFrom*",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-04-26T09:28:27Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-03-28T17:14:50Z"
      },
      "sha": "d095316c1c23e9460dfbd9fdbaf292063adcd080"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDQxMGViZDZlZmFmMjBmZTQ3MTVjOWI4MjUxMDNiNzRkYjY5ZjM1YWM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/410ebd6efaf20fe4715c9b825103b74db69f35ac",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/410ebd6efaf20fe4715c9b825103b74db69f35ac",
      "tree": {
        "sha": "95c849f56c4e6b3ae6bcd0b48dcd5a07a0078aa8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/95c849f56c4e6b3ae6bcd0b48dcd5a07a0078aa8"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d095316c1c23e9460dfbd9fdbaf292063adcd080",
          "sha": "d095316c1c23e9460dfbd9fdbaf292063adcd080",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/d095316c1c23e9460dfbd9fdbaf292063adcd080"
        }
      ],
      "message": "[fuzz] break out parent functions and add GetChildrenFrom* coverage\n\nIt's very hard to randomly construct a transaction that would be the\nparent of an existing orphanage tx. For functions like\nAddChildrenToWorkSet and GetChildren that take orphan parents, use a tx\nthat was previously constructed.",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-04-26T09:28:27Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-03-28T17:15:11Z"
      },
      "sha": "410ebd6efaf20fe4715c9b825103b74db69f35ac"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDZjNTFlMWQ3ZDAyMWVkNjUyMzEwN2E2ZGI4N2E4NjVhYWE4ZmM0Yzk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6c51e1d7d021ed6523107a6db87a865aaa8fc4c9",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/6c51e1d7d021ed6523107a6db87a865aaa8fc4c9",
      "tree": {
        "sha": "9f58bd0cc0fd3273fc8e4801c00d630dcd61510a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9f58bd0cc0fd3273fc8e4801c00d630dcd61510a"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/410ebd6efaf20fe4715c9b825103b74db69f35ac",
          "sha": "410ebd6efaf20fe4715c9b825103b74db69f35ac",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/410ebd6efaf20fe4715c9b825103b74db69f35ac"
        }
      ],
      "message": "[p2p] add separate rejections cache for reconsiderable txns",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-04-26T09:28:27Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2023-11-09T14:50:33Z"
      },
      "sha": "6c51e1d7d021ed6523107a6db87a865aaa8fc4c9"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12621631006,
      "node_id": "HRFPE_lADOABII5854OHi1zwAAAALwTs4e",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12621631006",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "6a00cad67216fb0aa57bb2dc1fcc6387ac45b160",
      "commit_url": "https://api.github.com/repos/glozow/bitcoin/commits/6a00cad67216fb0aa57bb2dc1fcc6387ac45b160",
      "created_at": "2024-04-26T10:10:16Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12621715279,
      "node_id": "HRFPE_lADOABII5854OHi1zwAAAALwUBdP",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12621715279",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "850a2fc96a0e607c875856a26501573653be70a4",
      "commit_url": "https://api.github.com/repos/glozow/bitcoin/commits/850a2fc96a0e607c875856a26501573653be70a4",
      "created_at": "2024-04-26T10:15:08Z"
    },
    {
      "event": "labeled",
      "id": 12621718645,
      "node_id": "LE_lADOABII5854OHi1zwAAAALwUCR1",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12621718645",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-26T10:15:14Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2079080689,
      "node_id": "IC_kwDOABII58577EDx",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2079080689",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-26T10:15:15Z",
      "updated_at": "2024-04-26T10:15:15Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\n\n🚧 At least one of the CI tasks failed. Make sure to run all tests locally, according to the\ndocumentation.\n\nPossibly this is due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/24292958143</sub>",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#issuecomment-2079080689",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28970"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDg3YzVjNTI0ZDYzYzgzM2NmNDkwYzdmMmY3M2Q3MjY5NWFkNDgwZGY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/87c5c524d63c833cf490c7f2f73d72695ad480df",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/87c5c524d63c833cf490c7f2f73d72695ad480df",
      "tree": {
        "sha": "3a40883181d5b5c65789e30ea999c76becc995f3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3a40883181d5b5c65789e30ea999c76becc995f3"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6c51e1d7d021ed6523107a6db87a865aaa8fc4c9",
          "sha": "6c51e1d7d021ed6523107a6db87a865aaa8fc4c9",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/6c51e1d7d021ed6523107a6db87a865aaa8fc4c9"
        }
      ],
      "message": "[p2p] opportunistically accept 1-parent-1-child packages",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-04-26T10:27:37Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-03-08T13:15:47Z"
      },
      "sha": "87c5c524d63c833cf490c7f2f73d72695ad480df"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGU1MThhOGJmOGFiZjNkN2I4M2M5MDEzZjU2ZDBkY2ExOGFlMDRkNmY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "tree": {
        "sha": "30c62ef1b13ea9f9781e5698efa87def5f3886b5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/30c62ef1b13ea9f9781e5698efa87def5f3886b5"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/87c5c524d63c833cf490c7f2f73d72695ad480df",
          "sha": "87c5c524d63c833cf490c7f2f73d72695ad480df",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/87c5c524d63c833cf490c7f2f73d72695ad480df"
        }
      ],
      "message": "[functional test] opportunistic 1p1c package submission",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-04-26T10:27:37Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2022-10-03T15:30:42Z"
      },
      "sha": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12622012951,
      "node_id": "HRFPE_lADOABII5854OHi1zwAAAALwVKIX",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12622012951",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "commit_url": "https://api.github.com/repos/glozow/bitcoin/commits/e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "created_at": "2024-04-26T10:28:07Z"
    },
    {
      "event": "commented",
      "id": 2079355204,
      "node_id": "IC_kwDOABII58578HFE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2079355204",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-26T13:02:40Z",
      "updated_at": "2024-04-26T13:02:40Z",
      "author_association": "MEMBER",
      "body": "Addressed @theStack and @sr-gi comments. Thanks!",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#issuecomment-2079355204",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28970"
    },
    {
      "event": "mentioned",
      "id": 12623598637,
      "node_id": "MEE_lADOABII5854OHi1zwAAAALwbNQt",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12623598637",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-26T13:02:42Z"
    },
    {
      "event": "subscribed",
      "id": 12623598655,
      "node_id": "SE_lADOABII5854OHi1zwAAAALwbNQ_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12623598655",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-26T13:02:42Z"
    },
    {
      "event": "mentioned",
      "id": 12623598668,
      "node_id": "MEE_lADOABII5854OHi1zwAAAALwbNRM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12623598668",
      "actor": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-26T13:02:42Z"
    },
    {
      "event": "subscribed",
      "id": 12623598682,
      "node_id": "SE_lADOABII5854OHi1zwAAAALwbNRa",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12623598682",
      "actor": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-26T13:02:42Z"
    },
    {
      "event": "reviewed",
      "id": 2025023787,
      "node_id": "PRR_kwDOABII5854s2kr",
      "url": null,
      "actor": null,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "reACK e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f\r\n\r\nnon-blocking comments\r\n\r\nreviewed via `git range-diff master 30c9e6b e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f`",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#pullrequestreview-2025023787",
      "submitted_at": "2024-04-26T14:00:10Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
    },
    {
      "event": "unlabeled",
      "id": 12625669328,
      "node_id": "UNLE_lADOABII5854OHi1zwAAAALwjGzQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12625669328",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-26T15:50:20Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2082822497,
      "node_id": "IC_kwDOABII5858JVlh",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2082822497",
      "actor": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-29T13:54:47Z",
      "updated_at": "2024-04-29T13:56:35Z",
      "author_association": "MEMBER",
      "body": "tACK e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f\r\n\r\nAll comments have been addressed/replied to. Tests are now passing even in this case: https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1578550174",
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#issuecomment-2082822497",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28970"
    },
    {
      "event": "reviewed",
      "id": 2030612104,
      "node_id": "PRR_kwDOABII5855CK6I",
      "url": null,
      "actor": null,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Code-review ACK e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f :package: ",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#pullrequestreview-2030612104",
      "submitted_at": "2024-04-30T08:36:33Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
    },
    {
      "event": "commented",
      "id": 2084765381,
      "node_id": "IC_kwDOABII5858Qv7F",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2084765381",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-30T08:59:40Z",
      "updated_at": "2024-04-30T14:12:36Z",
      "author_association": "MEMBER",
      "body": "Since there are a few ACKs now, listing followups. I plan to open a PR for the first two immediately:\r\n- redundant comment + pass `PackageToValidate` directly https://github.com/bitcoin/bitcoin/pull/28970#pullrequestreview-2025023787\r\n- make `MempoolAcceptResult::m_replaced_transactions` non-optional https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1568781077\r\n- (already in #29974) fix quirks in fuzz/txorphan.cpp https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1576401327\r\n- consider dropping requirement that all unconfirmed parents be present, allow package with other parent in mempool https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1576145432. This may conflict with #28984, so will hold off for now.\r\n- delete orphan if parents are rejected https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1511279226",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#issuecomment-2084765381",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28970"
    },
    {
      "event": "reviewed",
      "id": 2031463183,
      "node_id": "PRR_kwDOABII5855FasP",
      "url": null,
      "actor": null,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#pullrequestreview-2031463183",
      "submitted_at": "2024-04-30T13:59:18Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
    },
    {
      "event": "reviewed",
      "id": 2031444770,
      "node_id": "PRR_kwDOABII5855FWMi",
      "url": null,
      "actor": null,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "light Code review ACK e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#pullrequestreview-2031444770",
      "submitted_at": "2024-04-30T14:08:41Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
    },
    {
      "event": "reviewed",
      "id": 2032571316,
      "node_id": "PRR_kwDOABII5855JpO0",
      "url": null,
      "actor": null,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "ACK e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#pullrequestreview-2032571316",
      "submitted_at": "2024-04-30T22:31:52Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
    },
    {
      "event": "merged",
      "id": 12664780621,
      "node_id": "ME_lADOABII5854OHi1zwAAAALy4TdN",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12664780621",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "d813ba1bc4b4da3ad1f3812b61ff125d1d664625",
      "commit_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d813ba1bc4b4da3ad1f3812b61ff125d1d664625",
      "created_at": "2024-04-30T22:41:08Z"
    },
    {
      "event": "closed",
      "id": 12664780634,
      "node_id": "CE_lADOABII5854OHi1zwAAAALy4Tda",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12664780634",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-30T22:41:08Z"
    },
    {
      "event": "reviewed",
      "id": 2032696340,
      "node_id": "PRR_kwDOABII5855KHwU",
      "url": null,
      "actor": null,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Light ACK e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f\r\nI didn't review the functional tests in much detail, but the p2p code looks good to me.",
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#pullrequestreview-2032696340",
      "submitted_at": "2024-04-30T22:43:16Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
    },
    {
      "event": "head_ref_deleted",
      "id": 12668422996,
      "node_id": "HRDE_lADOABII5854OHi1zwAAAALzGMtU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12668422996",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-01T08:54:32Z"
    },
    {
      "event": "referenced",
      "id": 12692874612,
      "node_id": "REFE_lADOABII5854OHi1zwAAAAL0jeV0",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12692874612",
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "99d7538cdb2a0ab7a7a2116cd5f33b95fc52b00e",
      "commit_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/99d7538cdb2a0ab7a7a2116cd5f33b95fc52b00e",
      "created_at": "2024-05-03T07:31:14Z"
    },
    {
      "event": "referenced",
      "id": 12788939913,
      "node_id": "REFE_lADOABII5854OHi1zwAAAAL6R7yJ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12788939913",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "ff8c606cf1eaefd0eab9f144561120ae6c5a498f",
      "commit_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ff8c606cf1eaefd0eab9f144561120ae6c5a498f",
      "created_at": "2024-05-13T15:01:42Z"
    },
    {
      "event": "referenced",
      "id": 12818365229,
      "node_id": "REFE_lADOABII5854OHi1zwAAAAL8CLst",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12818365229",
      "actor": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "33303b2b296cdb21b6ade3e95663e9ed58c08753",
      "commit_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/33303b2b296cdb21b6ade3e95663e9ed58c08753",
      "created_at": "2024-05-15T13:56:26Z"
    },
    {
      "event": "referenced",
      "id": 13552409616,
      "node_id": "REFE_lADOABII5854OHi1zwAAAAMnyVwQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13552409616",
      "actor": {
        "login": "Fabcien",
        "id": 44533924,
        "node_id": "MDQ6VXNlcjQ0NTMzOTI0",
        "avatar_url": "https://avatars.githubusercontent.com/u/44533924?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Fabcien",
        "html_url": "https://github.com/Fabcien",
        "followers_url": "https://api.github.com/users/Fabcien/followers",
        "following_url": "https://api.github.com/users/Fabcien/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Fabcien/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Fabcien/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Fabcien/subscriptions",
        "organizations_url": "https://api.github.com/users/Fabcien/orgs",
        "repos_url": "https://api.github.com/users/Fabcien/repos",
        "events_url": "https://api.github.com/users/Fabcien/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Fabcien/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "39a2132c1e7c7f64e7ba7baf67d92d2fcf068f5c",
      "commit_url": "https://api.github.com/repos/Bitcoin-ABC/bitcoin-abc/commits/39a2132c1e7c7f64e7ba7baf67d92d2fcf068f5c",
      "created_at": "2024-07-18T09:08:23Z"
    },
    {
      "event": "referenced",
      "id": 13552409650,
      "node_id": "REFE_lADOABII5854OHi1zwAAAAMnyVwy",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13552409650",
      "actor": {
        "login": "Fabcien",
        "id": 44533924,
        "node_id": "MDQ6VXNlcjQ0NTMzOTI0",
        "avatar_url": "https://avatars.githubusercontent.com/u/44533924?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Fabcien",
        "html_url": "https://github.com/Fabcien",
        "followers_url": "https://api.github.com/users/Fabcien/followers",
        "following_url": "https://api.github.com/users/Fabcien/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Fabcien/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Fabcien/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Fabcien/subscriptions",
        "organizations_url": "https://api.github.com/users/Fabcien/orgs",
        "repos_url": "https://api.github.com/users/Fabcien/repos",
        "events_url": "https://api.github.com/users/Fabcien/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Fabcien/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "1f4999794394603b13704a6e29d897d5ba67c6c1",
      "commit_url": "https://api.github.com/repos/Bitcoin-ABC/bitcoin-abc/commits/1f4999794394603b13704a6e29d897d5ba67c6c1",
      "created_at": "2024-07-18T09:08:23Z"
    },
    {
      "event": "referenced",
      "id": 13555559992,
      "node_id": "REFE_lADOABII5854OHi1zwAAAAMn-W44",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13555559992",
      "actor": {
        "login": "Fabcien",
        "id": 44533924,
        "node_id": "MDQ6VXNlcjQ0NTMzOTI0",
        "avatar_url": "https://avatars.githubusercontent.com/u/44533924?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Fabcien",
        "html_url": "https://github.com/Fabcien",
        "followers_url": "https://api.github.com/users/Fabcien/followers",
        "following_url": "https://api.github.com/users/Fabcien/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Fabcien/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Fabcien/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Fabcien/subscriptions",
        "organizations_url": "https://api.github.com/users/Fabcien/orgs",
        "repos_url": "https://api.github.com/users/Fabcien/repos",
        "events_url": "https://api.github.com/users/Fabcien/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Fabcien/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "d0b3d2524b0676654d429f771059eb563c622203",
      "commit_url": "https://api.github.com/repos/Bitcoin-ABC/bitcoin-abc/commits/d0b3d2524b0676654d429f771059eb563c622203",
      "created_at": "2024-07-18T13:14:25Z"
    },
    {
      "event": "referenced",
      "id": 13730252628,
      "node_id": "REFE_lADOABII5854OHi1zwAAAAMyYwdU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13730252628",
      "actor": {
        "login": "roqqit",
        "id": 172419468,
        "node_id": "U_kgDOCkbpjA",
        "avatar_url": "https://avatars.githubusercontent.com/u/172419468?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/roqqit",
        "html_url": "https://github.com/roqqit",
        "followers_url": "https://api.github.com/users/roqqit/followers",
        "following_url": "https://api.github.com/users/roqqit/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/roqqit/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/roqqit/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/roqqit/subscriptions",
        "organizations_url": "https://api.github.com/users/roqqit/orgs",
        "repos_url": "https://api.github.com/users/roqqit/repos",
        "events_url": "https://api.github.com/users/roqqit/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/roqqit/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "e7de18784e595b1ac7f30481ad51ff3c2aae6838",
      "commit_url": "https://api.github.com/repos/doged-io/doged/commits/e7de18784e595b1ac7f30481ad51ff3c2aae6838",
      "created_at": "2024-08-01T18:26:09Z"
    },
    {
      "event": "referenced",
      "id": 13730252652,
      "node_id": "REFE_lADOABII5854OHi1zwAAAAMyYwds",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13730252652",
      "actor": {
        "login": "roqqit",
        "id": 172419468,
        "node_id": "U_kgDOCkbpjA",
        "avatar_url": "https://avatars.githubusercontent.com/u/172419468?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/roqqit",
        "html_url": "https://github.com/roqqit",
        "followers_url": "https://api.github.com/users/roqqit/followers",
        "following_url": "https://api.github.com/users/roqqit/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/roqqit/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/roqqit/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/roqqit/subscriptions",
        "organizations_url": "https://api.github.com/users/roqqit/orgs",
        "repos_url": "https://api.github.com/users/roqqit/repos",
        "events_url": "https://api.github.com/users/roqqit/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/roqqit/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "ee6180b751d48e3c1430d0e6f9bf56b2babd9d2f",
      "commit_url": "https://api.github.com/repos/doged-io/doged/commits/ee6180b751d48e3c1430d0e6f9bf56b2babd9d2f",
      "created_at": "2024-08-01T18:26:09Z"
    },
    {
      "event": "referenced",
      "id": 13730252687,
      "node_id": "REFE_lADOABII5854OHi1zwAAAAMyYweP",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/13730252687",
      "actor": {
        "login": "roqqit",
        "id": 172419468,
        "node_id": "U_kgDOCkbpjA",
        "avatar_url": "https://avatars.githubusercontent.com/u/172419468?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/roqqit",
        "html_url": "https://github.com/roqqit",
        "followers_url": "https://api.github.com/users/roqqit/followers",
        "following_url": "https://api.github.com/users/roqqit/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/roqqit/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/roqqit/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/roqqit/subscriptions",
        "organizations_url": "https://api.github.com/users/roqqit/orgs",
        "repos_url": "https://api.github.com/users/roqqit/repos",
        "events_url": "https://api.github.com/users/roqqit/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/roqqit/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "a005ee7527cce7fc3d5d1d810658bbb253e7d762",
      "commit_url": "https://api.github.com/repos/doged-io/doged/commits/a005ee7527cce7fc3d5d1d810658bbb253e7d762",
      "created_at": "2024-08-01T18:26:09Z"
    },
    {
      "event": "locked",
      "id": 17484878016,
      "node_id": "LOE_lADOABII5854OHi1zwAAAAQSLhDA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/17484878016",
      "actor": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-01T07:51:49Z"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1506244026",
      "pull_request_review_id": 1906612532,
      "id": 1506244026,
      "node_id": "PRRC_kwDOABII585Zx3W6",
      "diff_hunk": "@@ -3047,17 +3076,7 @@ bool PeerManagerImpl::ProcessOrphanTx(Peer& peer)\n \n         if (result.m_result_type == MempoolAcceptResult::ResultType::VALID) {\n             LogPrint(BCLog::TXPACKAGES, \"   accepted orphan tx %s (wtxid=%s)\\n\", orphanHash.ToString(), orphan_wtxid.ToString());\n-            LogPrint(BCLog::MEMPOOL, \"AcceptToMemoryPool: peer=%d: accepted %s (wtxid=%s) (poolsz %u txn, %u kB)\\n\",\n-                peer.m_id,\n-                orphanHash.ToString(),\n-                orphan_wtxid.ToString(),\n-                m_mempool.size(), m_mempool.DynamicMemoryUsage() / 1000);\n-            RelayTransaction(orphanHash, porphanTx->GetWitnessHash());\n-            m_orphanage.AddChildrenToWorkSet(*porphanTx);\n-            m_orphanage.EraseTx(orphanHash);\n-            for (const CTransactionRef& removedTx : result.m_replaced_transactions.value()) {\n-                AddToCompactExtraTransactions(removedTx);\n-            }\n+            ProcessValidTx(porphanTx, peer.m_id, result.m_replaced_transactions.value());",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 58,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "bbf1b836fa9e82142c534c6d7b07389326434bde",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I know it's populated due to this being accepted, but I think `Assume(result.m_replaced_transactions.has_value())` would be a good belt and suspenders to avoid UB in case of regression e.g., we redefined std::nulltopt mean no replacements",
      "created_at": "2024-02-28T16:26:15Z",
      "updated_at": "2024-03-04T15:25:42Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1506244026",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1506244026"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3079,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1506255820",
      "pull_request_review_id": 1906612532,
      "id": 1506255820,
      "node_id": "PRRC_kwDOABII585Zx6PM",
      "diff_hunk": "@@ -582,6 +582,15 @@ class PeerManagerImpl final : public PeerManager\n      */\n     bool MaybeDiscourageAndDisconnect(CNode& pnode, Peer& peer);\n \n+    enum class InvalidTxTask : uint8_t {\n+        NONE,\n+        ADD_ORPHAN,\n+    };\n+    /** Handle a transaction whose result was MempoolAcceptResult::ResultType::INVALID.\n+     * @returns true if this transaction is an orphan we should try to resolve. */",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 9,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "3eddfb2147754c734c325e4ee0158872448a0a61",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "this doesn't return a boolean",
      "created_at": "2024-02-28T16:34:41Z",
      "updated_at": "2024-03-04T15:25:42Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1506255820",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1506255820"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 590,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1506260613",
      "pull_request_review_id": 1906612532,
      "id": 1506260613,
      "node_id": "PRRC_kwDOABII585Zx7aF",
      "diff_hunk": "@@ -4297,28 +4373,22 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         if (result.m_result_type == MempoolAcceptResult::ResultType::VALID) {\n             ProcessValidTx(ptx, pfrom.GetId(), result.m_replaced_transactions.value());\n             pfrom.m_last_tx_time = GetTime<std::chrono::seconds>();\n-        }\n-        else if (state.GetResult() == TxValidationResult::TX_MISSING_INPUTS)\n-        {\n-            bool fRejectedParents = false; // It may be the case that the orphans parents have all been rejected\n-\n-            // Deduplicate parent txids, so that we don't have to loop over\n-            // the same parent txid more than once down below.\n-            std::vector<uint256> unique_parents;\n-            unique_parents.reserve(tx.vin.size());\n-            for (const CTxIn& txin : tx.vin) {\n-                // We start with all parents, and then remove duplicates below.\n-                unique_parents.push_back(txin.prevout.hash);\n+            for (const CTransactionRef& removedTx : result.m_replaced_transactions.value()) {\n+                AddToCompactExtraTransactions(removedTx);",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 210,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "3eddfb2147754c734c325e4ee0158872448a0a61",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "copy/paste error? isn't this already done in `ProcessValidTx` just above?",
      "created_at": "2024-02-28T16:38:15Z",
      "updated_at": "2024-03-04T15:25:42Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1506260613",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1506260613"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 4377,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1511275969",
      "pull_request_review_id": 1906612532,
      "id": 1511275969,
      "node_id": "PRRC_kwDOABII585aFD3B",
      "diff_hunk": "@@ -3078,54 +3193,15 @@ bool PeerManagerImpl::ProcessOrphanTx(Peer& peer)\n             LogPrint(BCLog::TXPACKAGES, \"   accepted orphan tx %s (wtxid=%s)\\n\", orphanHash.ToString(), orphan_wtxid.ToString());\n             ProcessValidTx(porphanTx, peer.m_id, result.m_replaced_transactions.value());\n             return true;\n-        } else if (state.GetResult() != TxValidationResult::TX_MISSING_INPUTS) {\n-            if (state.IsInvalid()) {\n-                LogPrint(BCLog::TXPACKAGES, \"   invalid orphan tx %s (wtxid=%s) from peer=%d. %s\\n\",\n-                    orphanHash.ToString(),\n-                    orphan_wtxid.ToString(),\n-                    peer.m_id,\n-                    state.ToString());\n-                LogPrint(BCLog::MEMPOOLREJ, \"%s (wtxid=%s) from peer=%d was not accepted: %s\\n\",\n-                    orphanHash.ToString(),\n-                    orphan_wtxid.ToString(),\n-                    peer.m_id,\n-                    state.ToString());\n-                // Maybe punish peer that gave us an invalid orphan tx\n-                MaybePunishNodeForTx(peer.m_id, state);\n-            }\n-            // Has inputs but not accepted to mempool\n-            // Probably non-standard or insufficient fee\n-            LogPrint(BCLog::TXPACKAGES, \"   removed orphan tx %s (wtxid=%s)\\n\", orphanHash.ToString(), orphan_wtxid.ToString());\n-            if (state.GetResult() != TxValidationResult::TX_WITNESS_STRIPPED) {\n-                // We can add the wtxid of this transaction to our reject filter.\n-                // Do not add txids of witness transactions or witness-stripped\n-                // transactions to the filter, as they can have been malleated;\n-                // adding such txids to the reject filter would potentially\n-                // interfere with relay of valid transactions from peers that\n-                // do not support wtxid-based relay. See\n-                // https://github.com/bitcoin/bitcoin/issues/8279 for details.\n-                // We can remove this restriction (and always add wtxids to\n-                // the filter even for witness stripped transactions) once\n-                // wtxid-based relay is broadly deployed.\n-                // See also comments in https://github.com/bitcoin/bitcoin/pull/18044#discussion_r443419034\n-                // for concerns around weakening security of unupgraded nodes\n-                // if we start doing this too early.\n-                m_recent_rejects.insert(porphanTx->GetWitnessHash().ToUint256());\n-                // If the transaction failed for TX_INPUTS_NOT_STANDARD,\n-                // then we know that the witness was irrelevant to the policy\n-                // failure, since this check depends only on the txid\n-                // (the scriptPubKey being spent is covered by the txid).\n-                // Add the txid to the reject filter to prevent repeated\n-                // processing of this transaction in the event that child\n-                // transactions are later received (resulting in\n-                // parent-fetching by txid via the orphan-handling logic).\n-                if (state.GetResult() == TxValidationResult::TX_INPUTS_NOT_STANDARD && porphanTx->HasWitness()) {\n-                    // We only add the txid if it differs from the wtxid, to\n-                    // avoid wasting entries in the rolling bloom filter.\n-                    m_recent_rejects.insert(porphanTx->GetHash().ToUint256());\n-                }\n-            }\n-            m_orphanage.EraseTx(orphanHash);",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 180,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "3eddfb2147754c734c325e4ee0158872448a0a61",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "previously `MISSING_INPUTS` would have resulted in a continuation of the loop. A side-effect of this change is that we will detect if the orphan was rejected due to `m_recent_rejects` entries of its parents, which seems like a strict improvement?",
      "created_at": "2024-03-04T14:43:38Z",
      "updated_at": "2024-03-04T15:25:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1511275969",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1511275969"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3109,
      "side": "LEFT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1511279226",
      "pull_request_review_id": 1906612532,
      "id": 1511279226,
      "node_id": "PRRC_kwDOABII585aFEp6",
      "diff_hunk": "@@ -3036,6 +3045,112 @@ void PeerManagerImpl::ProcessHeadersMessage(CNode& pfrom, Peer& peer,\n     return;\n }\n \n+PeerManagerImpl::InvalidTxTask PeerManagerImpl::ProcessInvalidTx(const CTransactionRef& tx, NodeId nodeid, const TxValidationState& state)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockNotHeld(m_peer_mutex);\n+    LogPrint(BCLog::MEMPOOLREJ, \"%s (wtxid=%s) from peer=%d was not accepted: %s\\n\",\n+             tx->GetHash().ToString(),\n+             tx->GetWitnessHash().ToString(),\n+             nodeid,\n+             state.ToString());\n+    // Maybe punish peer that gave us an tx\n+    MaybePunishNodeForTx(nodeid, state);\n+\n+    switch (state.GetResult()) {\n+    case TxValidationResult::TX_RESULT_UNSET:\n+    case TxValidationResult::TX_NO_MEMPOOL:\n+    {\n+        // This function should only be called when a transaction fails validation.\n+        Assume(false);\n+        return InvalidTxTask::NONE;\n+    }\n+    case TxValidationResult::TX_UNKNOWN:\n+    {\n+        // Transaction was not validated; we don't know that it is invalid. Do not add it to any\n+        // rejection caches or forget about it yet.\n+        return InvalidTxTask::NONE;\n+    }\n+    case TxValidationResult::TX_WITNESS_STRIPPED:\n+    {\n+        // Do not add txids of witness transactions or witness-stripped\n+        // transactions to the filter, as they can have been malleated;\n+        // adding such txids to the reject filter would potentially\n+        // interfere with relay of valid transactions from peers that\n+        // do not support wtxid-based relay. See\n+        // https://github.com/bitcoin/bitcoin/issues/8279 for details.\n+        // We can remove this restriction (and always add wtxids to\n+        // the filter even for witness stripped transactions) once\n+        // wtxid-based relay is broadly deployed.\n+        // See also comments in https://github.com/bitcoin/bitcoin/pull/18044#discussion_r443419034\n+        // for concerns around weakening security of unupgraded nodes\n+        // if we start doing this too early.\n+        return InvalidTxTask::NONE;\n+    }\n+    case TxValidationResult::TX_MISSING_INPUTS:\n+    {\n+        if (std::any_of(tx->vin.cbegin(), tx->vin.cend(),\n+            [&](const auto& input) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+            { return m_recent_rejects.contains(input.prevout.hash.ToUint256()); })) {\n+            LogPrint(BCLog::MEMPOOL, \"not keeping orphan with rejected parents %s (wtxid=%s)\\n\",\n+                     tx->GetHash().ToString(),\n+                     tx->GetWitnessHash().ToString());\n+            // We will continue to reject this tx since it has rejected\n+            // parents so avoid re-requesting it from other peers.\n+            // Here we add both the txid and the wtxid, as we know that\n+            // regardless of what witness is provided, we will not accept\n+            // this, so we don't need to allow for redownload of this txid\n+            // from any of our non-wtxidrelay peers.\n+            m_recent_rejects.insert(tx->GetHash().ToUint256());",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 76,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "3eddfb2147754c734c325e4ee0158872448a0a61",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "future work: might make sense to delete this transaction from the orphanage as well in this case if it exists so we don't try it with other peer?",
      "created_at": "2024-03-04T14:45:50Z",
      "updated_at": "2024-03-04T15:25:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1511279226",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1511279226"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3104,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1511306814",
      "pull_request_review_id": 1906612532,
      "id": 1511306814,
      "node_id": "PRRC_kwDOABII585aFLY-",
      "diff_hunk": "@@ -3036,6 +3045,112 @@ void PeerManagerImpl::ProcessHeadersMessage(CNode& pfrom, Peer& peer,\n     return;\n }\n \n+PeerManagerImpl::InvalidTxTask PeerManagerImpl::ProcessInvalidTx(const CTransactionRef& tx, NodeId nodeid, const TxValidationState& state)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockNotHeld(m_peer_mutex);\n+    LogPrint(BCLog::MEMPOOLREJ, \"%s (wtxid=%s) from peer=%d was not accepted: %s\\n\",\n+             tx->GetHash().ToString(),\n+             tx->GetWitnessHash().ToString(),\n+             nodeid,\n+             state.ToString());\n+    // Maybe punish peer that gave us an tx\n+    MaybePunishNodeForTx(nodeid, state);\n+\n+    switch (state.GetResult()) {",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 32,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "3eddfb2147754c734c325e4ee0158872448a0a61",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "we used to call `m_orphanage.EraseTx(orphanHash);` for each non-`TX_MISSING_INPUTS` possibility, but due to early return we don't. Can we sync this back up or justify each case this has changed for?",
      "created_at": "2024-03-04T15:02:59Z",
      "updated_at": "2024-03-04T15:25:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1511306814",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1511306814"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3060,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1511328011",
      "pull_request_review_id": 1906612532,
      "id": 1511328011,
      "node_id": "PRRC_kwDOABII585aFQkL",
      "diff_hunk": "@@ -4342,63 +4412,9 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n \n                 // DoS prevention: do not allow m_orphanage to grow unbounded (see CVE-2012-3789)\n                 m_orphanage.LimitOrphans(m_opts.max_orphan_txs, m_rng);\n-            } else {\n-                LogPrint(BCLog::MEMPOOL, \"not keeping orphan with rejected parents %s (wtxid=%s)\\n\",\n-                         tx.GetHash().ToString(),\n-                         tx.GetWitnessHash().ToString());\n-                // We will continue to reject this tx since it has rejected\n-                // parents so avoid re-requesting it from other peers.\n-                // Here we add both the txid and the wtxid, as we know that\n-                // regardless of what witness is provided, we will not accept\n-                // this, so we don't need to allow for redownload of this txid\n-                // from any of our non-wtxidrelay peers.\n-                m_recent_rejects.insert(tx.GetHash().ToUint256());\n-                m_recent_rejects.insert(tx.GetWitnessHash().ToUint256());\n-                m_txrequest.ForgetTxHash(tx.GetHash());\n-                m_txrequest.ForgetTxHash(tx.GetWitnessHash());\n+            } else if (RecursiveDynamicUsage(*ptx) < 100000) {",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 254,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "3eddfb2147754c734c325e4ee0158872448a0a61",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "with changes, we now add to extra txns even if witness stripped; seems wrong",
      "created_at": "2024-03-04T15:13:39Z",
      "updated_at": "2024-03-04T15:25:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1511328011",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1511328011"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 4415,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1511344657",
      "pull_request_review_id": 1906612532,
      "id": 1511344657,
      "node_id": "PRRC_kwDOABII585aFUoR",
      "diff_hunk": "@@ -0,0 +1,223 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test that package works successfully in a \"network\" of nodes. Send various packages from different\n+nodes on a network in which some nodes have already received some of the transactions (and submitted\n+them to mempool, kept them as orphans or rejected them as too-low-feerate transactions). The\n+packages should be received and accepted by all transactions on the network.\n+\"\"\"\n+\n+from decimal import Decimal\n+from test_framework.messages import (\n+    CInv,\n+    MSG_WTX,\n+    msg_inv,\n+    msg_tx,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    create_lots_of_big_transactions,\n+    gen_return_txouts,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 4\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+            \"-whitelist=noban@127.0.0.1\",  # immediate tx relay\n+        ]] * self.num_nodes\n+        self.supports_cli = False\n+\n+    def raise_network_minfee(self):\n+        filler_wallet = MiniWallet(self.nodes[0])\n+        relayfee = self.nodes[0].getnetworkinfo()['relayfee']\n+        num_big_transactions = 75\n+        # Generate coins to spend and wait for them to mature\n+        self.generate(filler_wallet, num_big_transactions)\n+        self.generate(filler_wallet, 100)\n+\n+        self.log.debug(\"Create a mempool tx that will be evicted\")\n+        tx_to_be_evicted_id = filler_wallet.send_self_transfer(from_node=self.nodes[1], fee_rate=relayfee)[\"txid\"]\n+\n+        # Increase the tx fee rate to give the subsequent transactions a higher priority in the mempool\n+        # The tx has an approx. vsize of 65k, i.e. multiplying the previous fee rate (in sats/kvB)\n+        # by 130 should result in a fee that corresponds to 2x of that fee rate\n+        base_fee = relayfee * 130\n+\n+        self.log.debug(\"Fill up the mempool with txs with higher fee rate\")\n+        txouts = gen_return_txouts()\n+        with self.nodes[0].assert_debug_log([\"rolling minimum fee bumped\"]):\n+            for batch_of_txid in range(num_big_transactions):\n+                fee = (batch_of_txid + 1) * base_fee\n+                create_lots_of_big_transactions(filler_wallet, self.nodes[0], fee, 1, txouts)\n+\n+        self.log.debug(\"Wait for the network to sync mempools\")\n+        self.sync_mempools()\n+        assert tx_to_be_evicted_id not in self.nodes[0].getrawmempool()\n+\n+        self.log.debug(\"Check that all nodes' mempool minimum feerate is above min relay feerate\")\n+        for node in self.nodes:\n+            assert_equal(node.getmempoolinfo()['minrelaytxfee'], FEERATE_1SAT_VB)\n+            assert_greater_than(node.getmempoolinfo()['mempoolminfee'], FEERATE_1SAT_VB)\n+\n+    def create_packages(self):\n+        # Basic 1-parent-1-child package\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+        package_hex_basic = [low_fee_parent[\"hex\"], high_fee_child[\"hex\"]]\n+        self.packages_to_submit.append(package_hex_basic)\n+        # Child should already be in orphanage\n+        self.transactions_to_presend[1] = [high_fee_child[\"tx\"]]\n+        # Parent would have been previously rejected\n+        self.transactions_to_presend[3] = [low_fee_parent[\"tx\"]]\n+\n+    def test_individual_logic(self):\n+        node = self.nodes[0]\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        low_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=2*FEERATE_1SAT_VB)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+\n+        peer1 = node.add_p2p_connection(P2PInterface())\n+        peer2 = node.add_p2p_connection(P2PInterface())\n+\n+        self.log.info(\"Check that tx caches low feerate rejections\")\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer1.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer1.wait_for_getdata([parent_wtxid_int])\n+        peer1.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer2, check that it is ignored\n+        with node.assert_debug_log([f\"got inv: wtx {low_fee_parent['wtxid']}  have\"]):\n+            peer2.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer2.last_message\n+\n+        self.log.info(\"Check that the node doesn't try to validate a failed package again\")\n+        # Send the (orphan) child that has a higher feerate but not enough to bump the parent\n+        low_child_wtxid_int = int(low_fee_child[\"tx\"].getwtxid(), 16)\n+        peer1.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        peer1.wait_for_getdata([low_child_wtxid_int])\n+        peer1.send_and_ping(msg_tx(low_fee_child[\"tx\"]))\n+        # Node should request the orphan's missing parent. It has seen this parent before, but only\n+        # cached the failure by wtxid, not txid.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer1.wait_for_getdata([parent_txid_int])\n+        failed_expected_logs_1p1c = []\n+        failed_expected_logs_1p1c.append(f\"found tx {low_fee_parent['txid']} (wtxid={low_fee_parent['wtxid']}) in reconsiderable rejects, looking for child in orphanage\")\n+        failed_expected_logs_1p1c.append(f\"found child {low_fee_child['txid']} (wtxid={low_fee_child['wtxid']}) of tx {low_fee_parent['txid']} (wtxid={low_fee_parent['wtxid']}) in orphanage, trying package evaluation\")\n+        failed_expected_logs_1p1c.append(f\"removed orphan tx {low_fee_child['txid']} (wtxid={low_fee_child['wtxid']})\")\n+\n+        with node.assert_debug_log(failed_expected_logs_1p1c):\n+            peer1.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        # The transactions do not get accepted due to low feerate\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+        assert low_fee_child[\"txid\"] not in node.getrawmempool()\n+\n+        # If peer2 announces the low feerate child, it should be ignored\n+        with node.assert_debug_log([f\"got inv: wtx {low_fee_child['wtxid']}  have\"]):\n+            peer2.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        assert \"getdata\" not in peer2.last_message\n+        # If either peer sends the parent again, package evaluation should not be attempted\n+        with node.assert_debug_log([f\"didn't evaluate package for {low_fee_parent['txid']} (wtxid={low_fee_parent['wtxid']}), no eligible child found\"]):\n+            peer1.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        with node.assert_debug_log([f\"didn't evaluate package for {low_fee_parent['txid']} (wtxid={low_fee_parent['wtxid']}), no eligible child found\"]):\n+            peer2.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        self.log.info(\"Check that the node groups a low-feerate tx with its single child in orphanage\")\n+        # Send the high feerate (orphan) child\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer1.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer1.wait_for_getdata([high_child_wtxid_int])\n+        peer1.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+        # Node should request the orphan's parent, even though it has already been rejected, both by\n+        # itself and with a child. This is necessary, otherwise high_fee_child can be censored.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer1.wait_for_getdata([parent_txid_int])\n+        expected_logs_1p1c = []\n+        expected_logs_1p1c.append(f\"found tx {low_fee_parent['txid']} (wtxid={low_fee_parent['wtxid']}) in reconsiderable rejects, looking for child in orphanage\")\n+        expected_logs_1p1c.append(f\"found child {high_fee_child['txid']} (wtxid={high_fee_child['wtxid']}) of tx {low_fee_parent['txid']} (wtxid={low_fee_parent['wtxid']}) in orphanage, trying package evaluation\")\n+        with node.assert_debug_log(expected_logs_1p1c):\n+            peer1.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # Both transactions should now be in mempool\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+        peer1.peer_disconnect()\n+        peer2.peer_disconnect()\n+        self.sync_all()\n+\n+    def run_test(self):\n+        self.ctr = 0\n+        self.wallet = MiniWallet(self.nodes[1])\n+        self.generate(self.wallet, 120)\n+\n+        self.log.info(\"Fill mempools with large transactions to raise mempool minimum feerates\")\n+        self.raise_network_minfee()\n+\n+        self.log.info(\"Check 1p1c validation logic on a single node\")\n+        self.test_individual_logic()\n+\n+        self.log.info(\"Check end-to-end package relay across multiple nodes\")\n+        self.packages_to_submit = []\n+        self.transactions_to_presend = [[]] * self.num_nodes\n+        self.replacement_packages = []",
      "path": "test/functional/p2p_1p1c_package_relay.py",
      "position": null,
      "original_position": 181,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "19015e3c9aed5709e776ef15bf9e73f126c7ea29",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "this is never set",
      "created_at": "2024-03-04T15:24:06Z",
      "updated_at": "2024-03-04T15:25:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1511344657",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1511344657"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 185,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1511599258",
      "pull_request_review_id": 1915025042,
      "id": 1511599258,
      "node_id": "PRRC_kwDOABII585aGSya",
      "diff_hunk": "@@ -0,0 +1,223 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test that package works successfully in a \"network\" of nodes. Send various packages from different\n+nodes on a network in which some nodes have already received some of the transactions (and submitted\n+them to mempool, kept them as orphans or rejected them as too-low-feerate transactions). The\n+packages should be received and accepted by all transactions on the network.\n+\"\"\"\n+\n+from decimal import Decimal\n+from test_framework.messages import (\n+    CInv,\n+    MSG_WTX,\n+    msg_inv,\n+    msg_tx,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    create_lots_of_big_transactions,\n+    gen_return_txouts,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 4",
      "path": "test/functional/p2p_1p1c_package_relay.py",
      "position": null,
      "original_position": 39,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "19015e3c9aed5709e776ef15bf9e73f126c7ea29",
      "in_reply_to_id": null,
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In 19015e3c9aed5709e776ef15bf9e73f126c7ea29: It seems to be using 3 nodes instead of 4. Or am I missing something?\r\n\r\nE.g.:\r\n\r\n```diff\r\ndiff --git a/test/functional/p2p_1p1c_package_relay.py b/test/functional/p2p_1p1c_package_relay.py\r\nindex 6a3ba7c3df..dda671dede 100755\r\n--- a/test/functional/p2p_1p1c_package_relay.py\r\n+++ b/test/functional/p2p_1p1c_package_relay.py\r\n@@ -36,7 +36,7 @@ FEERATE_1SAT_VB = Decimal(\"0.00001000\")\r\n class PackageRelayTest(BitcoinTestFramework):\r\n     def set_test_params(self):\r\n         self.setup_clean_chain = True\r\n-        self.num_nodes = 4\r\n+        self.num_nodes = 3\r\n         self.extra_args = [[\r\n             \"-datacarriersize=100000\",\r\n             \"-maxmempool=5\",\r\n@@ -85,7 +85,7 @@ class PackageRelayTest(BitcoinTestFramework):\r\n         # Child should already be in orphanage\r\n         self.transactions_to_presend[1] = [high_fee_child[\"tx\"]]\r\n         # Parent would have been previously rejected\r\n-        self.transactions_to_presend[3] = [low_fee_parent[\"tx\"]]\r\n+        self.transactions_to_presend[2] = [low_fee_parent[\"tx\"]]\r\n \r\n     def test_individual_logic(self):\r\n         node = self.nodes[0]\r\n@@ -213,7 +213,7 @@ class PackageRelayTest(BitcoinTestFramework):\r\n \r\n         self.log.info(\"Submit replacement package to node3\")\r\n         for package_hex in self.replacement_packages:\r\n-            self.nodes[3].submitpackage(package_hex)\r\n+            self.nodes[2].submitpackage(package_hex)\r\n \r\n         self.log.info(\"Wait for mempools to sync\")\r\n         self.sync_mempools(timeout=20)\r\n```",
      "created_at": "2024-03-04T18:36:26Z",
      "updated_at": "2024-03-04T18:36:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1511599258",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1511599258"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 40,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1512661556",
      "pull_request_review_id": 1916618959,
      "id": 1512661556,
      "node_id": "PRRC_kwDOABII585aKWI0",
      "diff_hunk": "@@ -0,0 +1,223 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test that package works successfully in a \"network\" of nodes. Send various packages from different\n+nodes on a network in which some nodes have already received some of the transactions (and submitted\n+them to mempool, kept them as orphans or rejected them as too-low-feerate transactions). The\n+packages should be received and accepted by all transactions on the network.\n+\"\"\"\n+\n+from decimal import Decimal\n+from test_framework.messages import (\n+    CInv,\n+    MSG_WTX,\n+    msg_inv,\n+    msg_tx,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    create_lots_of_big_transactions,\n+    gen_return_txouts,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 4",
      "path": "test/functional/p2p_1p1c_package_relay.py",
      "position": null,
      "original_position": 39,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "19015e3c9aed5709e776ef15bf9e73f126c7ea29",
      "in_reply_to_id": 1511599258,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "The idea is this is a \"network\" test to see that the package propagates across multiple hops. 1 node is the sender, 1 node pre-receives the parent, 1 node pre-receives the child, and 1 node pre-receives nothing.",
      "created_at": "2024-03-05T11:23:41Z",
      "updated_at": "2024-03-05T11:28:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1512661556",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1512661556"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 40,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1512689796",
      "pull_request_review_id": 1916664022,
      "id": 1512689796,
      "node_id": "PRRC_kwDOABII585aKdCE",
      "diff_hunk": "@@ -0,0 +1,223 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test that package works successfully in a \"network\" of nodes. Send various packages from different\n+nodes on a network in which some nodes have already received some of the transactions (and submitted\n+them to mempool, kept them as orphans or rejected them as too-low-feerate transactions). The\n+packages should be received and accepted by all transactions on the network.\n+\"\"\"\n+\n+from decimal import Decimal\n+from test_framework.messages import (\n+    CInv,\n+    MSG_WTX,\n+    msg_inv,\n+    msg_tx,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    create_lots_of_big_transactions,\n+    gen_return_txouts,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 4",
      "path": "test/functional/p2p_1p1c_package_relay.py",
      "position": null,
      "original_position": 39,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "19015e3c9aed5709e776ef15bf9e73f126c7ea29",
      "in_reply_to_id": 1511599258,
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Got it, thank you.",
      "created_at": "2024-03-05T11:48:03Z",
      "updated_at": "2024-03-05T11:48:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1512689796",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1512689796"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 40,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1514657717",
      "pull_request_review_id": 1920028235,
      "id": 1514657717,
      "node_id": "PRRC_kwDOABII585aR9e1",
      "diff_hunk": "@@ -3036,6 +3045,112 @@ void PeerManagerImpl::ProcessHeadersMessage(CNode& pfrom, Peer& peer,\n     return;\n }\n \n+PeerManagerImpl::InvalidTxTask PeerManagerImpl::ProcessInvalidTx(const CTransactionRef& tx, NodeId nodeid, const TxValidationState& state)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockNotHeld(m_peer_mutex);\n+    LogPrint(BCLog::MEMPOOLREJ, \"%s (wtxid=%s) from peer=%d was not accepted: %s\\n\",\n+             tx->GetHash().ToString(),\n+             tx->GetWitnessHash().ToString(),\n+             nodeid,\n+             state.ToString());\n+    // Maybe punish peer that gave us an tx\n+    MaybePunishNodeForTx(nodeid, state);\n+\n+    switch (state.GetResult()) {\n+    case TxValidationResult::TX_RESULT_UNSET:\n+    case TxValidationResult::TX_NO_MEMPOOL:\n+    {\n+        // This function should only be called when a transaction fails validation.\n+        Assume(false);\n+        return InvalidTxTask::NONE;\n+    }\n+    case TxValidationResult::TX_UNKNOWN:\n+    {\n+        // Transaction was not validated; we don't know that it is invalid. Do not add it to any\n+        // rejection caches or forget about it yet.\n+        return InvalidTxTask::NONE;\n+    }\n+    case TxValidationResult::TX_WITNESS_STRIPPED:\n+    {\n+        // Do not add txids of witness transactions or witness-stripped\n+        // transactions to the filter, as they can have been malleated;\n+        // adding such txids to the reject filter would potentially\n+        // interfere with relay of valid transactions from peers that\n+        // do not support wtxid-based relay. See\n+        // https://github.com/bitcoin/bitcoin/issues/8279 for details.",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 53,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "3eddfb2147754c734c325e4ee0158872448a0a61",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "@sdaftuar honestly this comment/link doesn't make sense to me. If it's witness-stripped, we can't add it to `m_recent_rejects` since that would blind us to any real version of the tx?",
      "created_at": "2024-03-06T15:11:18Z",
      "updated_at": "2024-03-06T15:11:18Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1514657717",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1514657717"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3168,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1514698744",
      "pull_request_review_id": 1920093386,
      "id": 1514698744,
      "node_id": "PRRC_kwDOABII585aSHf4",
      "diff_hunk": "@@ -3036,6 +3045,112 @@ void PeerManagerImpl::ProcessHeadersMessage(CNode& pfrom, Peer& peer,\n     return;\n }\n \n+PeerManagerImpl::InvalidTxTask PeerManagerImpl::ProcessInvalidTx(const CTransactionRef& tx, NodeId nodeid, const TxValidationState& state)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockNotHeld(m_peer_mutex);\n+    LogPrint(BCLog::MEMPOOLREJ, \"%s (wtxid=%s) from peer=%d was not accepted: %s\\n\",\n+             tx->GetHash().ToString(),\n+             tx->GetWitnessHash().ToString(),\n+             nodeid,\n+             state.ToString());\n+    // Maybe punish peer that gave us an tx\n+    MaybePunishNodeForTx(nodeid, state);\n+\n+    switch (state.GetResult()) {\n+    case TxValidationResult::TX_RESULT_UNSET:\n+    case TxValidationResult::TX_NO_MEMPOOL:\n+    {\n+        // This function should only be called when a transaction fails validation.\n+        Assume(false);\n+        return InvalidTxTask::NONE;\n+    }\n+    case TxValidationResult::TX_UNKNOWN:\n+    {\n+        // Transaction was not validated; we don't know that it is invalid. Do not add it to any\n+        // rejection caches or forget about it yet.\n+        return InvalidTxTask::NONE;\n+    }\n+    case TxValidationResult::TX_WITNESS_STRIPPED:\n+    {\n+        // Do not add txids of witness transactions or witness-stripped\n+        // transactions to the filter, as they can have been malleated;\n+        // adding such txids to the reject filter would potentially\n+        // interfere with relay of valid transactions from peers that\n+        // do not support wtxid-based relay. See\n+        // https://github.com/bitcoin/bitcoin/issues/8279 for details.",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 53,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "3eddfb2147754c734c325e4ee0158872448a0a61",
      "in_reply_to_id": 1514657717,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I had to remind myself of how this works, but the concern contemplated in that comment is that if the **only** copy of a non-witness-stripped version of a transaction is from a node that has not yet upgraded to wtxid-based-relay, then an adversary could blind us to that transaction by relaying a witness-stripped version of it (and then, since txid==wtxid for witness-stripped transactions, the hash that we'd use to fetch the transaction from the non-wtxid-relay peer who has the correct version would be in our `m_recent_rejects`, and we wouldn't ever request it).\r\n\r\nAt the time that I wrote that comment, I think I also said that once wtxid-based-relay is sufficiently deployed, that we could stop worrying about this...  I don't recall when wtxid-relay was deployed but maybe we're at that point already?\r\n\r\nThere's another link to a comment thread in the PR that implemented wtxid-relay which discusses the potential impact on downstream projects, so maybe if we were to make a behavior change we should communicate that in advance so that no one is surprised.",
      "created_at": "2024-03-06T15:34:20Z",
      "updated_at": "2024-03-06T15:34:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1514698744",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1514698744"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3168,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1514744423",
      "pull_request_review_id": 1920164662,
      "id": 1514744423,
      "node_id": "PRRC_kwDOABII585aSSpn",
      "diff_hunk": "@@ -3036,6 +3045,112 @@ void PeerManagerImpl::ProcessHeadersMessage(CNode& pfrom, Peer& peer,\n     return;\n }\n \n+PeerManagerImpl::InvalidTxTask PeerManagerImpl::ProcessInvalidTx(const CTransactionRef& tx, NodeId nodeid, const TxValidationState& state)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockNotHeld(m_peer_mutex);\n+    LogPrint(BCLog::MEMPOOLREJ, \"%s (wtxid=%s) from peer=%d was not accepted: %s\\n\",\n+             tx->GetHash().ToString(),\n+             tx->GetWitnessHash().ToString(),\n+             nodeid,\n+             state.ToString());\n+    // Maybe punish peer that gave us an tx\n+    MaybePunishNodeForTx(nodeid, state);\n+\n+    switch (state.GetResult()) {\n+    case TxValidationResult::TX_RESULT_UNSET:\n+    case TxValidationResult::TX_NO_MEMPOOL:\n+    {\n+        // This function should only be called when a transaction fails validation.\n+        Assume(false);\n+        return InvalidTxTask::NONE;\n+    }\n+    case TxValidationResult::TX_UNKNOWN:\n+    {\n+        // Transaction was not validated; we don't know that it is invalid. Do not add it to any\n+        // rejection caches or forget about it yet.\n+        return InvalidTxTask::NONE;\n+    }\n+    case TxValidationResult::TX_WITNESS_STRIPPED:\n+    {\n+        // Do not add txids of witness transactions or witness-stripped\n+        // transactions to the filter, as they can have been malleated;\n+        // adding such txids to the reject filter would potentially\n+        // interfere with relay of valid transactions from peers that\n+        // do not support wtxid-based relay. See\n+        // https://github.com/bitcoin/bitcoin/issues/8279 for details.",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 53,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "3eddfb2147754c734c325e4ee0158872448a0a61",
      "in_reply_to_id": 1514657717,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "It seems like the comment thread is concerned with what happens if:\r\n(1) the sender is using non-wtxidrelay (and thus only announces transactions by txid),\r\n(2) all of its peers are caching witness-stripped rejections by wtxid (i.e. txid),\r\n(3) there is an attacker trying to censor the sender's tx by sending witness-stripped versions of the tx ahead of the sender.\r\n\r\nThis isn't a problem if (1) isn't true, i.e. the sender is using wtxidrelay, e.g. any non-eol version of Bitcoin Core. If we see that the vast majority of nodes (that send transactions) are sending a `wtxidrelay` message, perhaps it would be safe to remove the special casing (with a message to downstream projects)?\r\n\r\nEdit: perhaps not, if btcd is an example of (1)? https://github.com/btcsuite/btcd/blob/a4f447006e7538f9e3d5ae90f54700c97fea9c3d/peer/peer.go#L2214",
      "created_at": "2024-03-06T16:00:50Z",
      "updated_at": "2024-03-06T16:18:06Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1514744423",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1514744423"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3168,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1517789807",
      "pull_request_review_id": 1925001479,
      "id": 1517789807,
      "node_id": "PRRC_kwDOABII585ad6Jv",
      "diff_hunk": "@@ -3078,54 +3193,15 @@ bool PeerManagerImpl::ProcessOrphanTx(Peer& peer)\n             LogPrint(BCLog::TXPACKAGES, \"   accepted orphan tx %s (wtxid=%s)\\n\", orphanHash.ToString(), orphan_wtxid.ToString());\n             ProcessValidTx(porphanTx, peer.m_id, result.m_replaced_transactions.value());\n             return true;\n-        } else if (state.GetResult() != TxValidationResult::TX_MISSING_INPUTS) {\n-            if (state.IsInvalid()) {\n-                LogPrint(BCLog::TXPACKAGES, \"   invalid orphan tx %s (wtxid=%s) from peer=%d. %s\\n\",\n-                    orphanHash.ToString(),\n-                    orphan_wtxid.ToString(),\n-                    peer.m_id,\n-                    state.ToString());\n-                LogPrint(BCLog::MEMPOOLREJ, \"%s (wtxid=%s) from peer=%d was not accepted: %s\\n\",\n-                    orphanHash.ToString(),\n-                    orphan_wtxid.ToString(),\n-                    peer.m_id,\n-                    state.ToString());\n-                // Maybe punish peer that gave us an invalid orphan tx\n-                MaybePunishNodeForTx(peer.m_id, state);\n-            }\n-            // Has inputs but not accepted to mempool\n-            // Probably non-standard or insufficient fee\n-            LogPrint(BCLog::TXPACKAGES, \"   removed orphan tx %s (wtxid=%s)\\n\", orphanHash.ToString(), orphan_wtxid.ToString());\n-            if (state.GetResult() != TxValidationResult::TX_WITNESS_STRIPPED) {\n-                // We can add the wtxid of this transaction to our reject filter.\n-                // Do not add txids of witness transactions or witness-stripped\n-                // transactions to the filter, as they can have been malleated;\n-                // adding such txids to the reject filter would potentially\n-                // interfere with relay of valid transactions from peers that\n-                // do not support wtxid-based relay. See\n-                // https://github.com/bitcoin/bitcoin/issues/8279 for details.\n-                // We can remove this restriction (and always add wtxids to\n-                // the filter even for witness stripped transactions) once\n-                // wtxid-based relay is broadly deployed.\n-                // See also comments in https://github.com/bitcoin/bitcoin/pull/18044#discussion_r443419034\n-                // for concerns around weakening security of unupgraded nodes\n-                // if we start doing this too early.\n-                m_recent_rejects.insert(porphanTx->GetWitnessHash().ToUint256());\n-                // If the transaction failed for TX_INPUTS_NOT_STANDARD,\n-                // then we know that the witness was irrelevant to the policy\n-                // failure, since this check depends only on the txid\n-                // (the scriptPubKey being spent is covered by the txid).\n-                // Add the txid to the reject filter to prevent repeated\n-                // processing of this transaction in the event that child\n-                // transactions are later received (resulting in\n-                // parent-fetching by txid via the orphan-handling logic).\n-                if (state.GetResult() == TxValidationResult::TX_INPUTS_NOT_STANDARD && porphanTx->HasWitness()) {\n-                    // We only add the txid if it differs from the wtxid, to\n-                    // avoid wasting entries in the rolling bloom filter.\n-                    m_recent_rejects.insert(porphanTx->GetHash().ToUint256());\n-                }\n-            }\n-            m_orphanage.EraseTx(orphanHash);",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 180,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "3eddfb2147754c734c325e4ee0158872448a0a61",
      "in_reply_to_id": 1511275969,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Rewrote to be more strict refactor to give reviewers less to think about. I do think it makes sense that if a parent has been rejected since the last time we looked at this orphan, we get rid of it, but I suppose we can think about that later.",
      "created_at": "2024-03-08T14:30:30Z",
      "updated_at": "2024-03-08T14:30:31Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1517789807",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1517789807"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3109,
      "side": "LEFT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1517790259",
      "pull_request_review_id": 1925002258,
      "id": 1517790259,
      "node_id": "PRRC_kwDOABII585ad6Qz",
      "diff_hunk": "@@ -3036,6 +3045,112 @@ void PeerManagerImpl::ProcessHeadersMessage(CNode& pfrom, Peer& peer,\n     return;\n }\n \n+PeerManagerImpl::InvalidTxTask PeerManagerImpl::ProcessInvalidTx(const CTransactionRef& tx, NodeId nodeid, const TxValidationState& state)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockNotHeld(m_peer_mutex);\n+    LogPrint(BCLog::MEMPOOLREJ, \"%s (wtxid=%s) from peer=%d was not accepted: %s\\n\",\n+             tx->GetHash().ToString(),\n+             tx->GetWitnessHash().ToString(),\n+             nodeid,\n+             state.ToString());\n+    // Maybe punish peer that gave us an tx\n+    MaybePunishNodeForTx(nodeid, state);\n+\n+    switch (state.GetResult()) {",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 32,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "3eddfb2147754c734c325e4ee0158872448a0a61",
      "in_reply_to_id": 1511306814,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Old behavior should be preserved now",
      "created_at": "2024-03-08T14:30:50Z",
      "updated_at": "2024-03-08T14:30:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1517790259",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1517790259"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3060,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1517791171",
      "pull_request_review_id": 1925003669,
      "id": 1517791171,
      "node_id": "PRRC_kwDOABII585ad6fD",
      "diff_hunk": "@@ -4342,63 +4412,9 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n \n                 // DoS prevention: do not allow m_orphanage to grow unbounded (see CVE-2012-3789)\n                 m_orphanage.LimitOrphans(m_opts.max_orphan_txs, m_rng);\n-            } else {\n-                LogPrint(BCLog::MEMPOOL, \"not keeping orphan with rejected parents %s (wtxid=%s)\\n\",\n-                         tx.GetHash().ToString(),\n-                         tx.GetWitnessHash().ToString());\n-                // We will continue to reject this tx since it has rejected\n-                // parents so avoid re-requesting it from other peers.\n-                // Here we add both the txid and the wtxid, as we know that\n-                // regardless of what witness is provided, we will not accept\n-                // this, so we don't need to allow for redownload of this txid\n-                // from any of our non-wtxidrelay peers.\n-                m_recent_rejects.insert(tx.GetHash().ToUint256());\n-                m_recent_rejects.insert(tx.GetWitnessHash().ToUint256());\n-                m_txrequest.ForgetTxHash(tx.GetHash());\n-                m_txrequest.ForgetTxHash(tx.GetWitnessHash());\n+            } else if (RecursiveDynamicUsage(*ptx) < 100000) {",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 254,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "3eddfb2147754c734c325e4ee0158872448a0a61",
      "in_reply_to_id": 1511328011,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "fixed",
      "created_at": "2024-03-08T14:31:34Z",
      "updated_at": "2024-03-08T14:31:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1517791171",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1517791171"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 4415,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1519481765",
      "pull_request_review_id": 1927446729,
      "id": 1519481765,
      "node_id": "PRRC_kwDOABII585akXOl",
      "diff_hunk": "@@ -4297,28 +4373,22 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         if (result.m_result_type == MempoolAcceptResult::ResultType::VALID) {\n             ProcessValidTx(ptx, pfrom.GetId(), result.m_replaced_transactions.value());\n             pfrom.m_last_tx_time = GetTime<std::chrono::seconds>();\n-        }\n-        else if (state.GetResult() == TxValidationResult::TX_MISSING_INPUTS)\n-        {\n-            bool fRejectedParents = false; // It may be the case that the orphans parents have all been rejected\n-\n-            // Deduplicate parent txids, so that we don't have to loop over\n-            // the same parent txid more than once down below.\n-            std::vector<uint256> unique_parents;\n-            unique_parents.reserve(tx.vin.size());\n-            for (const CTxIn& txin : tx.vin) {\n-                // We start with all parents, and then remove duplicates below.\n-                unique_parents.push_back(txin.prevout.hash);\n+            for (const CTransactionRef& removedTx : result.m_replaced_transactions.value()) {\n+                AddToCompactExtraTransactions(removedTx);",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 210,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "3eddfb2147754c734c325e4ee0158872448a0a61",
      "in_reply_to_id": 1506260613,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "fixed",
      "created_at": "2024-03-11T10:19:32Z",
      "updated_at": "2024-03-11T10:19:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1519481765",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1519481765"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 4377,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1523100228",
      "pull_request_review_id": 1933929927,
      "id": 1523100228,
      "node_id": "PRRC_kwDOABII585ayKpE",
      "diff_hunk": "@@ -0,0 +1,223 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test that package works successfully in a \"network\" of nodes. Send various packages from different\n+nodes on a network in which some nodes have already received some of the transactions (and submitted\n+them to mempool, kept them as orphans or rejected them as too-low-feerate transactions). The\n+packages should be received and accepted by all transactions on the network.\n+\"\"\"\n+\n+from decimal import Decimal\n+from test_framework.messages import (\n+    CInv,\n+    MSG_WTX,\n+    msg_inv,\n+    msg_tx,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    create_lots_of_big_transactions,\n+    gen_return_txouts,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 4\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+            \"-whitelist=noban@127.0.0.1\",  # immediate tx relay\n+        ]] * self.num_nodes\n+        self.supports_cli = False\n+\n+    def raise_network_minfee(self):\n+        filler_wallet = MiniWallet(self.nodes[0])\n+        relayfee = self.nodes[0].getnetworkinfo()['relayfee']\n+        num_big_transactions = 75\n+        # Generate coins to spend and wait for them to mature\n+        self.generate(filler_wallet, num_big_transactions)\n+        self.generate(filler_wallet, 100)\n+\n+        self.log.debug(\"Create a mempool tx that will be evicted\")\n+        tx_to_be_evicted_id = filler_wallet.send_self_transfer(from_node=self.nodes[1], fee_rate=relayfee)[\"txid\"]\n+\n+        # Increase the tx fee rate to give the subsequent transactions a higher priority in the mempool\n+        # The tx has an approx. vsize of 65k, i.e. multiplying the previous fee rate (in sats/kvB)\n+        # by 130 should result in a fee that corresponds to 2x of that fee rate\n+        base_fee = relayfee * 130\n+\n+        self.log.debug(\"Fill up the mempool with txs with higher fee rate\")\n+        txouts = gen_return_txouts()\n+        with self.nodes[0].assert_debug_log([\"rolling minimum fee bumped\"]):\n+            for batch_of_txid in range(num_big_transactions):\n+                fee = (batch_of_txid + 1) * base_fee\n+                create_lots_of_big_transactions(filler_wallet, self.nodes[0], fee, 1, txouts)\n+\n+        self.log.debug(\"Wait for the network to sync mempools\")\n+        self.sync_mempools()\n+        assert tx_to_be_evicted_id not in self.nodes[0].getrawmempool()\n+\n+        self.log.debug(\"Check that all nodes' mempool minimum feerate is above min relay feerate\")\n+        for node in self.nodes:\n+            assert_equal(node.getmempoolinfo()['minrelaytxfee'], FEERATE_1SAT_VB)\n+            assert_greater_than(node.getmempoolinfo()['mempoolminfee'], FEERATE_1SAT_VB)\n+\n+    def create_packages(self):\n+        # Basic 1-parent-1-child package\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+        package_hex_basic = [low_fee_parent[\"hex\"], high_fee_child[\"hex\"]]\n+        self.packages_to_submit.append(package_hex_basic)\n+        # Child should already be in orphanage\n+        self.transactions_to_presend[1] = [high_fee_child[\"tx\"]]\n+        # Parent would have been previously rejected\n+        self.transactions_to_presend[3] = [low_fee_parent[\"tx\"]]\n+\n+    def test_individual_logic(self):\n+        node = self.nodes[0]\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        low_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=2*FEERATE_1SAT_VB)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+\n+        peer1 = node.add_p2p_connection(P2PInterface())\n+        peer2 = node.add_p2p_connection(P2PInterface())\n+\n+        self.log.info(\"Check that tx caches low feerate rejections\")\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer1.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer1.wait_for_getdata([parent_wtxid_int])\n+        peer1.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer2, check that it is ignored\n+        with node.assert_debug_log([f\"got inv: wtx {low_fee_parent['wtxid']}  have\"]):\n+            peer2.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer2.last_message\n+\n+        self.log.info(\"Check that the node doesn't try to validate a failed package again\")\n+        # Send the (orphan) child that has a higher feerate but not enough to bump the parent\n+        low_child_wtxid_int = int(low_fee_child[\"tx\"].getwtxid(), 16)\n+        peer1.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        peer1.wait_for_getdata([low_child_wtxid_int])\n+        peer1.send_and_ping(msg_tx(low_fee_child[\"tx\"]))\n+        # Node should request the orphan's missing parent. It has seen this parent before, but only\n+        # cached the failure by wtxid, not txid.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer1.wait_for_getdata([parent_txid_int])\n+        failed_expected_logs_1p1c = []\n+        failed_expected_logs_1p1c.append(f\"found tx {low_fee_parent['txid']} (wtxid={low_fee_parent['wtxid']}) in reconsiderable rejects, looking for child in orphanage\")\n+        failed_expected_logs_1p1c.append(f\"found child {low_fee_child['txid']} (wtxid={low_fee_child['wtxid']}) of tx {low_fee_parent['txid']} (wtxid={low_fee_parent['wtxid']}) in orphanage, trying package evaluation\")\n+        failed_expected_logs_1p1c.append(f\"removed orphan tx {low_fee_child['txid']} (wtxid={low_fee_child['wtxid']})\")\n+\n+        with node.assert_debug_log(failed_expected_logs_1p1c):\n+            peer1.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        # The transactions do not get accepted due to low feerate\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+        assert low_fee_child[\"txid\"] not in node.getrawmempool()\n+\n+        # If peer2 announces the low feerate child, it should be ignored\n+        with node.assert_debug_log([f\"got inv: wtx {low_fee_child['wtxid']}  have\"]):\n+            peer2.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        assert \"getdata\" not in peer2.last_message\n+        # If either peer sends the parent again, package evaluation should not be attempted\n+        with node.assert_debug_log([f\"didn't evaluate package for {low_fee_parent['txid']} (wtxid={low_fee_parent['wtxid']}), no eligible child found\"]):\n+            peer1.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        with node.assert_debug_log([f\"didn't evaluate package for {low_fee_parent['txid']} (wtxid={low_fee_parent['wtxid']}), no eligible child found\"]):\n+            peer2.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        self.log.info(\"Check that the node groups a low-feerate tx with its single child in orphanage\")\n+        # Send the high feerate (orphan) child\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer1.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer1.wait_for_getdata([high_child_wtxid_int])\n+        peer1.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+        # Node should request the orphan's parent, even though it has already been rejected, both by\n+        # itself and with a child. This is necessary, otherwise high_fee_child can be censored.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer1.wait_for_getdata([parent_txid_int])\n+        expected_logs_1p1c = []\n+        expected_logs_1p1c.append(f\"found tx {low_fee_parent['txid']} (wtxid={low_fee_parent['wtxid']}) in reconsiderable rejects, looking for child in orphanage\")\n+        expected_logs_1p1c.append(f\"found child {high_fee_child['txid']} (wtxid={high_fee_child['wtxid']}) of tx {low_fee_parent['txid']} (wtxid={low_fee_parent['wtxid']}) in orphanage, trying package evaluation\")\n+        with node.assert_debug_log(expected_logs_1p1c):\n+            peer1.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # Both transactions should now be in mempool\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+        peer1.peer_disconnect()\n+        peer2.peer_disconnect()\n+        self.sync_all()\n+\n+    def run_test(self):\n+        self.ctr = 0\n+        self.wallet = MiniWallet(self.nodes[1])\n+        self.generate(self.wallet, 120)\n+\n+        self.log.info(\"Fill mempools with large transactions to raise mempool minimum feerates\")\n+        self.raise_network_minfee()\n+\n+        self.log.info(\"Check 1p1c validation logic on a single node\")\n+        self.test_individual_logic()\n+\n+        self.log.info(\"Check end-to-end package relay across multiple nodes\")\n+        self.packages_to_submit = []\n+        self.transactions_to_presend = [[]] * self.num_nodes\n+        self.replacement_packages = []",
      "path": "test/functional/p2p_1p1c_package_relay.py",
      "position": null,
      "original_position": 181,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "19015e3c9aed5709e776ef15bf9e73f126c7ea29",
      "in_reply_to_id": 1511344657,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Oops, forgot to delete from a package RBF test I built on top. Fixed",
      "created_at": "2024-03-13T12:01:38Z",
      "updated_at": "2024-03-13T12:01:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1523100228",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1523100228"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 185,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1523804572",
      "pull_request_review_id": 1935032934,
      "id": 1523804572,
      "node_id": "PRRC_kwDOABII585a02mc",
      "diff_hunk": "@@ -846,6 +846,23 @@ class PeerManagerImpl final : public PeerManager\n     CRollingBloomFilter m_recent_rejects GUARDED_BY(::cs_main){120'000, 0.000'001};\n     uint256 hashRecentRejectsChainTip GUARDED_BY(cs_main);\n \n+    /**\n+     * Filter for the wtxids of transactions that were recently rejected by the mempool but are\n+     * eligible for reconsideration if submitted with other transactions.\n+     *\n+     * When a transaction's error is TxValidationResult::TX_RECONSIDERABLE (in a package or by\n+     * itself), add its wtxid to this filter.\n+     *\n+     * Upon receiving an announcement for a transaction, if it exists in this filter, do not\n+     * download the txdata.\n+     *\n+     * Reset this filter when the chain tip changes.\n+     *\n+     * Parameters are picked to be the same false positive rate but half the capacity as",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 25,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "1435bfac51ae431b91c38c4db0b92ce9b7353125",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "there any science to these choices?",
      "created_at": "2024-03-13T19:20:47Z",
      "updated_at": "2024-03-18T13:58:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1523804572",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1523804572"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 861,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1523821142",
      "pull_request_review_id": 1935032934,
      "id": 1523821142,
      "node_id": "PRRC_kwDOABII585a06pW",
      "diff_hunk": "@@ -806,7 +806,7 @@ class PeerManagerImpl final : public PeerManager\n     /** Stalling timeout for blocks in IBD */\n     std::atomic<std::chrono::seconds> m_block_stalling_timeout{BLOCK_STALLING_TIMEOUT_DEFAULT};\n \n-    bool AlreadyHaveTx(const GenTxid& gtxid)\n+    bool AlreadyHaveTx(const GenTxid& gtxid, bool include_reconsiderable)",
      "path": "src/net_processing.cpp",
      "position": 69,
      "original_position": 5,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "1435bfac51ae431b91c38c4db0b92ce9b7353125",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "`include_reconsiderable` seems to be true on every call-site. Perhaps this is vestigial from \"real\" package relay PRs of times past? Might be worth noting/making it default true, or dropping altogether.",
      "created_at": "2024-03-13T19:36:08Z",
      "updated_at": "2024-03-18T13:58:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1523821142",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1523821142"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 857,
      "original_line": 857,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1523822569",
      "pull_request_review_id": 1935032934,
      "id": 1523822569,
      "node_id": "PRRC_kwDOABII585a06_p",
      "diff_hunk": "@@ -2209,6 +2226,8 @@ bool PeerManagerImpl::AlreadyHaveTx(const GenTxid& gtxid)\n \n     if (m_orphanage.HaveTx(gtxid)) return true;\n \n+    if (include_reconsiderable && m_recent_rejects_reconsiderable.contains(gtxid.GetHash())) return true;",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 46,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "1435bfac51ae431b91c38c4db0b92ce9b7353125",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```Suggestion\r\n    if (include_reconsiderable && m_recent_rejects_reconsiderable.contains(hash)) return true;\r\n```",
      "created_at": "2024-03-13T19:37:39Z",
      "updated_at": "2024-03-18T13:58:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1523822569",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1523822569"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2229,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1523824732",
      "pull_request_review_id": 1935032934,
      "id": 1523824732,
      "node_id": "PRRC_kwDOABII585a07hc",
      "diff_hunk": "@@ -596,6 +596,12 @@ class PeerManagerImpl final : public PeerManager\n     void ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, const std::list<CTransactionRef>& replaced_transactions)\n         EXCLUSIVE_LOCKS_REQUIRED(!m_peer_mutex, g_msgproc_mutex, cs_main);\n \n+    void ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, NodeId nodeid)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_peer_mutex, g_msgproc_mutex, cs_main);\n+\n+    void MaybeProcess1P1CPackage(const CTransactionRef& ptx, NodeId nodeid)",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 7,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "47efa940c4180e1cdc778fdaae5f086ad4085791",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "please give some documentation",
      "created_at": "2024-03-13T19:39:58Z",
      "updated_at": "2024-03-18T13:58:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1523824732",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1523824732"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 611,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1523824762",
      "pull_request_review_id": 1935032934,
      "id": 1523824762,
      "node_id": "PRRC_kwDOABII585a07h6",
      "diff_hunk": "@@ -596,6 +596,12 @@ class PeerManagerImpl final : public PeerManager\n     void ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, const std::list<CTransactionRef>& replaced_transactions)\n         EXCLUSIVE_LOCKS_REQUIRED(!m_peer_mutex, g_msgproc_mutex, cs_main);\n \n+    void ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, NodeId nodeid)",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 4,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "47efa940c4180e1cdc778fdaae5f086ad4085791",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "please give some documentation",
      "created_at": "2024-03-13T19:40:00Z",
      "updated_at": "2024-03-18T13:58:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1523824762",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1523824762"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 602,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1525341442",
      "pull_request_review_id": 1935032934,
      "id": 1525341442,
      "node_id": "PRRC_kwDOABII585a6t0C",
      "diff_hunk": "@@ -4450,6 +4552,15 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         if (state.IsInvalid()) {\n             ProcessInvalidTx(pfrom.GetId(), ptx, state, /*maybe_add_extra_compact_tx=*/true);\n         }\n+        if (state.GetResult() == TxValidationResult::TX_RECONSIDERABLE) {",
      "path": "src/net_processing.cpp",
      "position": 365,
      "original_position": 127,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "47efa940c4180e1cdc778fdaae5f086ad4085791",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```Suggestion\r\n        if (m_recent_rejects_reconsiderable.contains(wtxid)) {\r\n```\r\nthink this is the same check and would match other call of the function",
      "created_at": "2024-03-14T18:38:54Z",
      "updated_at": "2024-03-18T13:58:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1525341442",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1525341442"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 4651,
      "original_line": 4651,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1525375424",
      "pull_request_review_id": 1935032934,
      "id": 1525375424,
      "node_id": "PRRC_kwDOABII585a62HA",
      "diff_hunk": "@@ -4334,6 +4426,16 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         m_txrequest.ReceivedResponse(pfrom.GetId(), txid);\n         if (tx.HasWitness()) m_txrequest.ReceivedResponse(pfrom.GetId(), wtxid);\n \n+        // If we find this transaction in m_recent_rejects_reconsiderable, we shouldn't try it by",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 110,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "47efa940c4180e1cdc778fdaae5f086ad4085791",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Mention that this is \"merely\" an optimization(and also reduces the churn in the bloom filter as well)?",
      "created_at": "2024-03-14T19:13:00Z",
      "updated_at": "2024-03-18T13:58:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1525375424",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1525375424"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 4429,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1525396593",
      "pull_request_review_id": 1935032934,
      "id": 1525396593,
      "node_id": "PRRC_kwDOABII585a67Rx",
      "diff_hunk": "@@ -4334,6 +4426,16 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         m_txrequest.ReceivedResponse(pfrom.GetId(), txid);\n         if (tx.HasWitness()) m_txrequest.ReceivedResponse(pfrom.GetId(), wtxid);\n \n+        // If we find this transaction in m_recent_rejects_reconsiderable, we shouldn't try it by\n+        // itself again. However, look for a matching child in the orphanage and maybe submit it\n+        // again as a package.\n+        if (m_recent_rejects_reconsiderable.contains(wtxid)) {",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 113,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "47efa940c4180e1cdc778fdaae5f086ad4085791",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "if `MaybeProcess1P1CPackage` handles the (non)existence in the `m_recent_rejects_reconsiderable` filter, you could stick this inside the `AlreadyHaveTx` block, which would allow existing logging to continue happening, and seems pretty natural?",
      "created_at": "2024-03-14T19:31:59Z",
      "updated_at": "2024-03-18T13:58:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1525396593",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1525396593"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 4432,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1526235839",
      "pull_request_review_id": 1935032934,
      "id": 1526235839,
      "node_id": "PRRC_kwDOABII585a-IK_",
      "diff_hunk": "@@ -3181,6 +3187,92 @@ void PeerManagerImpl::ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, c\n     }\n }\n \n+void PeerManagerImpl::ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, NodeId nodeid)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    if (package_result.m_state.IsInvalid()) {\n+        m_recent_rejects_reconsiderable.insert(GetPackageHash(package));\n+    }\n+\n+    // Iterate backwards to erase in-package descendants from the orphanage before they become\n+    // relevant in AddChildrenToWorkSet.\n+    for (auto package_it = package.rbegin(); package_it != package.rend(); ++package_it) {\n+        const auto& tx = *package_it;\n+        const auto it_result{package_result.m_tx_results.find(tx->GetWitnessHash())};\n+        if (it_result != package_result.m_tx_results.end()) {\n+            const auto& tx_result = it_result->second;\n+            switch (tx_result.m_result_type) {\n+                case MempoolAcceptResult::ResultType::VALID:\n+                {\n+                    Assume(tx_result.m_replaced_transactions.has_value());\n+                    std::list<CTransactionRef> empty_replacement_list;\n+                    ProcessValidTx(nodeid, tx, tx_result.m_replaced_transactions.value_or(empty_replacement_list));\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::INVALID:\n+                case MempoolAcceptResult::ResultType::DIFFERENT_WITNESS:\n+                {\n+                    // Don't add to vExtraTxnForCompact, as these transactions would already be\n+                    // there as an orphan or too low feerate tx.\n+                    ProcessInvalidTx(nodeid, tx, tx_result.m_state, /*maybe_add_extra_compact_tx=*/false);\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::MEMPOOL_ENTRY:\n+                {\n+                    // AlreadyHaveTx() should be catching transactions that are already in mempool.\n+                    Assume(false);\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+void PeerManagerImpl::MaybeProcess1P1CPackage(const CTransactionRef& ptx, NodeId nodeid)",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 61,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "47efa940c4180e1cdc778fdaae5f086ad4085791",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```Suggestion\r\nvoid PeerManagerImpl::MaybeProcess1P1CPackage(const CTransactionRef& parent_ptx, NodeId nodeid)\r\n```",
      "created_at": "2024-03-15T12:44:04Z",
      "updated_at": "2024-03-18T13:58:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1526235839",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1526235839"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3271,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1526239102",
      "pull_request_review_id": 1935032934,
      "id": 1526239102,
      "node_id": "PRRC_kwDOABII585a-I9-",
      "diff_hunk": "@@ -3181,6 +3187,92 @@ void PeerManagerImpl::ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, c\n     }\n }\n \n+void PeerManagerImpl::ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, NodeId nodeid)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    if (package_result.m_state.IsInvalid()) {\n+        m_recent_rejects_reconsiderable.insert(GetPackageHash(package));\n+    }\n+\n+    // Iterate backwards to erase in-package descendants from the orphanage before they become\n+    // relevant in AddChildrenToWorkSet.\n+    for (auto package_it = package.rbegin(); package_it != package.rend(); ++package_it) {\n+        const auto& tx = *package_it;\n+        const auto it_result{package_result.m_tx_results.find(tx->GetWitnessHash())};\n+        if (it_result != package_result.m_tx_results.end()) {\n+            const auto& tx_result = it_result->second;\n+            switch (tx_result.m_result_type) {\n+                case MempoolAcceptResult::ResultType::VALID:\n+                {\n+                    Assume(tx_result.m_replaced_transactions.has_value());\n+                    std::list<CTransactionRef> empty_replacement_list;\n+                    ProcessValidTx(nodeid, tx, tx_result.m_replaced_transactions.value_or(empty_replacement_list));\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::INVALID:\n+                case MempoolAcceptResult::ResultType::DIFFERENT_WITNESS:\n+                {\n+                    // Don't add to vExtraTxnForCompact, as these transactions would already be\n+                    // there as an orphan or too low feerate tx.\n+                    ProcessInvalidTx(nodeid, tx, tx_result.m_state, /*maybe_add_extra_compact_tx=*/false);\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::MEMPOOL_ENTRY:\n+                {\n+                    // AlreadyHaveTx() should be catching transactions that are already in mempool.\n+                    Assume(false);\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+void PeerManagerImpl::MaybeProcess1P1CPackage(const CTransactionRef& ptx, NodeId nodeid)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    const auto cpfp_candidates{m_orphanage.GetChildren(ptx, nodeid)};\n+    bool tried_package_cpfp{false};\n+\n+    const auto& txid{ptx->GetHash()};",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 70,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "47efa940c4180e1cdc778fdaae5f086ad4085791",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```Suggestion\r\n    const auto& parent_txid{parent_ptx->GetHash()};\r\n```\r\nas well as wtxid just below",
      "created_at": "2024-03-15T12:46:48Z",
      "updated_at": "2024-03-18T13:58:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1526239102",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1526239102"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3243,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1526243536",
      "pull_request_review_id": 1935032934,
      "id": 1526243536,
      "node_id": "PRRC_kwDOABII585a-KDQ",
      "diff_hunk": "@@ -3181,6 +3187,92 @@ void PeerManagerImpl::ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, c\n     }\n }\n \n+void PeerManagerImpl::ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, NodeId nodeid)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    if (package_result.m_state.IsInvalid()) {\n+        m_recent_rejects_reconsiderable.insert(GetPackageHash(package));\n+    }\n+\n+    // Iterate backwards to erase in-package descendants from the orphanage before they become\n+    // relevant in AddChildrenToWorkSet.\n+    for (auto package_it = package.rbegin(); package_it != package.rend(); ++package_it) {\n+        const auto& tx = *package_it;\n+        const auto it_result{package_result.m_tx_results.find(tx->GetWitnessHash())};\n+        if (it_result != package_result.m_tx_results.end()) {\n+            const auto& tx_result = it_result->second;\n+            switch (tx_result.m_result_type) {\n+                case MempoolAcceptResult::ResultType::VALID:\n+                {\n+                    Assume(tx_result.m_replaced_transactions.has_value());\n+                    std::list<CTransactionRef> empty_replacement_list;\n+                    ProcessValidTx(nodeid, tx, tx_result.m_replaced_transactions.value_or(empty_replacement_list));\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::INVALID:\n+                case MempoolAcceptResult::ResultType::DIFFERENT_WITNESS:\n+                {\n+                    // Don't add to vExtraTxnForCompact, as these transactions would already be\n+                    // there as an orphan or too low feerate tx.\n+                    ProcessInvalidTx(nodeid, tx, tx_result.m_state, /*maybe_add_extra_compact_tx=*/false);\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::MEMPOOL_ENTRY:\n+                {\n+                    // AlreadyHaveTx() should be catching transactions that are already in mempool.\n+                    Assume(false);\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+void PeerManagerImpl::MaybeProcess1P1CPackage(const CTransactionRef& ptx, NodeId nodeid)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    const auto cpfp_candidates{m_orphanage.GetChildren(ptx, nodeid)};\n+    bool tried_package_cpfp{false};\n+\n+    const auto& txid{ptx->GetHash()};\n+    const auto& wtxid{ptx->GetWitnessHash()};\n+",
      "path": "src/net_processing.cpp",
      "position": 226,
      "original_position": 72,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "47efa940c4180e1cdc778fdaae5f086ad4085791",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```Suggestion\r\n\r\n    Assume(m_recent_rejects_reconsiderable.contains(parent_wtxid.ToUint256()));\r\n\r\n```",
      "created_at": "2024-03-15T12:50:44Z",
      "updated_at": "2024-03-18T13:58:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1526243536",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1526243536"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 3306,
      "original_line": 3306,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1526585888",
      "pull_request_review_id": 1935032934,
      "id": 1526585888,
      "node_id": "PRRC_kwDOABII585a_dog",
      "diff_hunk": "@@ -3181,6 +3187,92 @@ void PeerManagerImpl::ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, c\n     }\n }\n \n+void PeerManagerImpl::ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, NodeId nodeid)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    if (package_result.m_state.IsInvalid()) {\n+        m_recent_rejects_reconsiderable.insert(GetPackageHash(package));\n+    }\n+\n+    // Iterate backwards to erase in-package descendants from the orphanage before they become\n+    // relevant in AddChildrenToWorkSet.\n+    for (auto package_it = package.rbegin(); package_it != package.rend(); ++package_it) {\n+        const auto& tx = *package_it;\n+        const auto it_result{package_result.m_tx_results.find(tx->GetWitnessHash())};\n+        if (it_result != package_result.m_tx_results.end()) {",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 32,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "47efa940c4180e1cdc778fdaae5f086ad4085791",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```Suggestion\r\n        if (Assume(it_result != package_result.m_tx_results.end())) {\r\n```",
      "created_at": "2024-03-15T17:02:58Z",
      "updated_at": "2024-03-18T13:58:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1526585888",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1526585888"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3205,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1526656636",
      "pull_request_review_id": 1935032934,
      "id": 1526656636,
      "node_id": "PRRC_kwDOABII585a_u58",
      "diff_hunk": "@@ -3181,6 +3187,92 @@ void PeerManagerImpl::ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, c\n     }\n }\n \n+void PeerManagerImpl::ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, NodeId nodeid)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    if (package_result.m_state.IsInvalid()) {\n+        m_recent_rejects_reconsiderable.insert(GetPackageHash(package));\n+    }\n+\n+    // Iterate backwards to erase in-package descendants from the orphanage before they become\n+    // relevant in AddChildrenToWorkSet.\n+    for (auto package_it = package.rbegin(); package_it != package.rend(); ++package_it) {\n+        const auto& tx = *package_it;\n+        const auto it_result{package_result.m_tx_results.find(tx->GetWitnessHash())};\n+        if (it_result != package_result.m_tx_results.end()) {\n+            const auto& tx_result = it_result->second;\n+            switch (tx_result.m_result_type) {\n+                case MempoolAcceptResult::ResultType::VALID:\n+                {\n+                    Assume(tx_result.m_replaced_transactions.has_value());\n+                    std::list<CTransactionRef> empty_replacement_list;\n+                    ProcessValidTx(nodeid, tx, tx_result.m_replaced_transactions.value_or(empty_replacement_list));\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::INVALID:\n+                case MempoolAcceptResult::ResultType::DIFFERENT_WITNESS:\n+                {\n+                    // Don't add to vExtraTxnForCompact, as these transactions would already be\n+                    // there as an orphan or too low feerate tx.\n+                    ProcessInvalidTx(nodeid, tx, tx_result.m_state, /*maybe_add_extra_compact_tx=*/false);\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::MEMPOOL_ENTRY:",
      "path": "src/net_processing.cpp",
      "position": 204,
      "original_position": 50,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "47efa940c4180e1cdc778fdaae5f086ad4085791",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "have you considered moving this above `INVALID` and letting it fall through to call `ProcessInvalidTx` as well?",
      "created_at": "2024-03-15T18:08:41Z",
      "updated_at": "2024-03-18T13:58:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1526656636",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1526656636"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 3284,
      "original_line": 3284,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1526676597",
      "pull_request_review_id": 1935032934,
      "id": 1526676597,
      "node_id": "PRRC_kwDOABII585a_zx1",
      "diff_hunk": "@@ -3181,6 +3187,92 @@ void PeerManagerImpl::ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, c\n     }\n }\n \n+void PeerManagerImpl::ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, NodeId nodeid)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    if (package_result.m_state.IsInvalid()) {\n+        m_recent_rejects_reconsiderable.insert(GetPackageHash(package));\n+    }\n+\n+    // Iterate backwards to erase in-package descendants from the orphanage before they become\n+    // relevant in AddChildrenToWorkSet.\n+    for (auto package_it = package.rbegin(); package_it != package.rend(); ++package_it) {\n+        const auto& tx = *package_it;\n+        const auto it_result{package_result.m_tx_results.find(tx->GetWitnessHash())};\n+        if (it_result != package_result.m_tx_results.end()) {\n+            const auto& tx_result = it_result->second;\n+            switch (tx_result.m_result_type) {\n+                case MempoolAcceptResult::ResultType::VALID:\n+                {\n+                    Assume(tx_result.m_replaced_transactions.has_value());\n+                    std::list<CTransactionRef> empty_replacement_list;\n+                    ProcessValidTx(nodeid, tx, tx_result.m_replaced_transactions.value_or(empty_replacement_list));\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::INVALID:\n+                case MempoolAcceptResult::ResultType::DIFFERENT_WITNESS:\n+                {\n+                    // Don't add to vExtraTxnForCompact, as these transactions would already be",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 45,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "47efa940c4180e1cdc778fdaae5f086ad4085791",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "We don't add orphans to vExtraTxnForCompact though, just too low aka reconsiderable?\r\n\r\nmaybe something like:\r\n\r\n> // All packages currently considered are 1p1c, which means\r\n> // any entrants to be added in vExtraTxnForCompact have already been added",
      "created_at": "2024-03-15T18:25:36Z",
      "updated_at": "2024-03-18T13:58:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1526676597",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1526676597"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3218,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1526764674",
      "pull_request_review_id": 1935032934,
      "id": 1526764674,
      "node_id": "PRRC_kwDOABII585bAJSC",
      "diff_hunk": "@@ -0,0 +1,222 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test that package works successfully in a \"network\" of nodes. Send various packages from different\n+nodes on a network in which some nodes have already received some of the transactions (and submitted\n+them to mempool, kept them as orphans or rejected them as too-low-feerate transactions). The\n+packages should be received and accepted by all transactions on the network.\n+\"\"\"\n+\n+from decimal import Decimal\n+from test_framework.messages import (\n+    CInv,\n+    MSG_WTX,\n+    msg_inv,\n+    msg_tx,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    create_lots_of_big_transactions,\n+    gen_return_txouts,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 4\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+            \"-whitelist=noban@127.0.0.1\",  # immediate tx relay\n+        ]] * self.num_nodes\n+        self.supports_cli = False\n+\n+    def raise_network_minfee(self):\n+        filler_wallet = MiniWallet(self.nodes[0])\n+        relayfee = self.nodes[0].getnetworkinfo()['relayfee']\n+        num_big_transactions = 75\n+        # Generate coins to spend and wait for them to mature\n+        self.generate(filler_wallet, num_big_transactions)\n+        self.generate(filler_wallet, 100)\n+\n+        self.log.debug(\"Create a mempool tx that will be evicted\")\n+        tx_to_be_evicted_id = filler_wallet.send_self_transfer(from_node=self.nodes[1], fee_rate=relayfee)[\"txid\"]\n+\n+        # Increase the tx fee rate to give the subsequent transactions a higher priority in the mempool\n+        # The tx has an approx. vsize of 65k, i.e. multiplying the previous fee rate (in sats/kvB)\n+        # by 130 should result in a fee that corresponds to 2x of that fee rate\n+        base_fee = relayfee * 130\n+\n+        self.log.debug(\"Fill up the mempool with txs with higher fee rate\")\n+        txouts = gen_return_txouts()\n+        with self.nodes[0].assert_debug_log([\"rolling minimum fee bumped\"]):\n+            for batch_of_txid in range(num_big_transactions):\n+                fee = (batch_of_txid + 1) * base_fee\n+                create_lots_of_big_transactions(filler_wallet, self.nodes[0], fee, 1, txouts)\n+\n+        self.log.debug(\"Wait for the network to sync mempools\")\n+        self.sync_mempools()\n+        assert tx_to_be_evicted_id not in self.nodes[0].getrawmempool()\n+\n+        self.log.debug(\"Check that all nodes' mempool minimum feerate is above min relay feerate\")\n+        for node in self.nodes:\n+            assert_equal(node.getmempoolinfo()['minrelaytxfee'], FEERATE_1SAT_VB)\n+            assert_greater_than(node.getmempoolinfo()['mempoolminfee'], FEERATE_1SAT_VB)\n+\n+    def create_packages(self):\n+        # Basic 1-parent-1-child package\n+        # node0: sender\n+        # node1: pre-received the child (orphan)\n+        # node2: pre-received nothing\n+        # node3: pre-received the parent (too low fee)\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+        package_hex_basic = [low_fee_parent[\"hex\"], high_fee_child[\"hex\"]]\n+        self.packages_to_submit.append(package_hex_basic)\n+        # Child should already be in orphanage\n+        self.transactions_to_presend[1] = [high_fee_child[\"tx\"]]\n+        # Parent would have been previously rejected\n+        self.transactions_to_presend[3] = [low_fee_parent[\"tx\"]]\n+\n+    def test_individual_logic(self):\n+        node = self.nodes[0]\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        low_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=2*FEERATE_1SAT_VB)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+\n+        peer1 = node.add_p2p_connection(P2PInterface())\n+        peer2 = node.add_p2p_connection(P2PInterface())\n+\n+        self.log.info(\"Check that tx caches low feerate rejections\")\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer1.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer1.wait_for_getdata([parent_wtxid_int])\n+        peer1.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer2, check that it is ignored\n+        with node.assert_debug_log([f\"got inv: wtx {low_fee_parent['wtxid']}  have\"]):\n+            peer2.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer2.last_message\n+\n+        self.log.info(\"Check that the node doesn't try to validate a failed package again\")\n+        # Send the (orphan) child that has a higher feerate but not enough to bump the parent\n+        low_child_wtxid_int = int(low_fee_child[\"tx\"].getwtxid(), 16)\n+        peer1.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        peer1.wait_for_getdata([low_child_wtxid_int])\n+        peer1.send_and_ping(msg_tx(low_fee_child[\"tx\"]))\n+        # Node should request the orphan's missing parent. It has seen this parent before, but only\n+        # cached the failure by wtxid, not txid.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer1.wait_for_getdata([parent_txid_int])\n+        failed_expected_logs_1p1c = []\n+        failed_expected_logs_1p1c.append(f\"found tx {low_fee_parent['txid']} (wtxid={low_fee_parent['wtxid']}) in reconsiderable rejects, looking for child in orphanage\")\n+        failed_expected_logs_1p1c.append(f\"found child {low_fee_child['txid']} (wtxid={low_fee_child['wtxid']}) of tx {low_fee_parent['txid']} (wtxid={low_fee_parent['wtxid']}) in orphanage, trying package evaluation\")\n+        failed_expected_logs_1p1c.append(f\"removed orphan tx {low_fee_child['txid']} (wtxid={low_fee_child['wtxid']})\")\n+\n+        with node.assert_debug_log(failed_expected_logs_1p1c):\n+            peer1.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        # The transactions do not get accepted due to low feerate\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+        assert low_fee_child[\"txid\"] not in node.getrawmempool()\n+\n+        # If peer2 announces the low feerate child, it should be ignored\n+        with node.assert_debug_log([f\"got inv: wtx {low_fee_child['wtxid']}  have\"]):\n+            peer2.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        assert \"getdata\" not in peer2.last_message\n+        # If either peer sends the parent again, package evaluation should not be attempted\n+        with node.assert_debug_log([f\"didn't evaluate package for {low_fee_parent['txid']} (wtxid={low_fee_parent['wtxid']}), no eligible child found\"]):\n+            peer1.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        with node.assert_debug_log([f\"didn't evaluate package for {low_fee_parent['txid']} (wtxid={low_fee_parent['wtxid']}), no eligible child found\"]):\n+            peer2.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        self.log.info(\"Check that the node groups a low-feerate tx with its single child in orphanage\")\n+        # Send the high feerate (orphan) child\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer1.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer1.wait_for_getdata([high_child_wtxid_int])\n+        peer1.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+        # Node should request the orphan's parent, even though it has already been rejected, both by\n+        # itself and with a child. This is necessary, otherwise high_fee_child can be censored.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer1.wait_for_getdata([parent_txid_int])\n+        expected_logs_1p1c = []\n+        expected_logs_1p1c.append(f\"found tx {low_fee_parent['txid']} (wtxid={low_fee_parent['wtxid']}) in reconsiderable rejects, looking for child in orphanage\")\n+        expected_logs_1p1c.append(f\"found child {high_fee_child['txid']} (wtxid={high_fee_child['wtxid']}) of tx {low_fee_parent['txid']} (wtxid={low_fee_parent['wtxid']}) in orphanage, trying package evaluation\")\n+        with node.assert_debug_log(expected_logs_1p1c):\n+            peer1.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # Both transactions should now be in mempool\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+        peer1.peer_disconnect()\n+        peer2.peer_disconnect()\n+        self.sync_all()\n+\n+    def run_test(self):\n+        self.ctr = 0",
      "path": "test/functional/p2p_1p1c_package_relay.py",
      "position": null,
      "original_position": 172,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "2f25d2e0840e94bee1c6a8908d94baf076bf1567",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "unused",
      "created_at": "2024-03-15T19:45:49Z",
      "updated_at": "2024-03-18T13:58:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1526764674",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1526764674"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 172,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1526776259",
      "pull_request_review_id": 1935032934,
      "id": 1526776259,
      "node_id": "PRRC_kwDOABII585bAMHD",
      "diff_hunk": "@@ -0,0 +1,222 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test that package works successfully in a \"network\" of nodes. Send various packages from different\n+nodes on a network in which some nodes have already received some of the transactions (and submitted\n+them to mempool, kept them as orphans or rejected them as too-low-feerate transactions). The\n+packages should be received and accepted by all transactions on the network.\n+\"\"\"\n+\n+from decimal import Decimal\n+from test_framework.messages import (\n+    CInv,\n+    MSG_WTX,\n+    msg_inv,\n+    msg_tx,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    create_lots_of_big_transactions,\n+    gen_return_txouts,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 4\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+            \"-whitelist=noban@127.0.0.1\",  # immediate tx relay\n+        ]] * self.num_nodes\n+        self.supports_cli = False\n+\n+    def raise_network_minfee(self):\n+        filler_wallet = MiniWallet(self.nodes[0])\n+        relayfee = self.nodes[0].getnetworkinfo()['relayfee']\n+        num_big_transactions = 75\n+        # Generate coins to spend and wait for them to mature\n+        self.generate(filler_wallet, num_big_transactions)\n+        self.generate(filler_wallet, 100)\n+\n+        self.log.debug(\"Create a mempool tx that will be evicted\")\n+        tx_to_be_evicted_id = filler_wallet.send_self_transfer(from_node=self.nodes[1], fee_rate=relayfee)[\"txid\"]\n+\n+        # Increase the tx fee rate to give the subsequent transactions a higher priority in the mempool\n+        # The tx has an approx. vsize of 65k, i.e. multiplying the previous fee rate (in sats/kvB)\n+        # by 130 should result in a fee that corresponds to 2x of that fee rate\n+        base_fee = relayfee * 130\n+\n+        self.log.debug(\"Fill up the mempool with txs with higher fee rate\")\n+        txouts = gen_return_txouts()\n+        with self.nodes[0].assert_debug_log([\"rolling minimum fee bumped\"]):\n+            for batch_of_txid in range(num_big_transactions):\n+                fee = (batch_of_txid + 1) * base_fee\n+                create_lots_of_big_transactions(filler_wallet, self.nodes[0], fee, 1, txouts)\n+\n+        self.log.debug(\"Wait for the network to sync mempools\")\n+        self.sync_mempools()\n+        assert tx_to_be_evicted_id not in self.nodes[0].getrawmempool()\n+\n+        self.log.debug(\"Check that all nodes' mempool minimum feerate is above min relay feerate\")\n+        for node in self.nodes:\n+            assert_equal(node.getmempoolinfo()['minrelaytxfee'], FEERATE_1SAT_VB)\n+            assert_greater_than(node.getmempoolinfo()['mempoolminfee'], FEERATE_1SAT_VB)\n+\n+    def create_packages(self):\n+        # Basic 1-parent-1-child package\n+        # node0: sender\n+        # node1: pre-received the child (orphan)\n+        # node2: pre-received nothing\n+        # node3: pre-received the parent (too low fee)\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+        package_hex_basic = [low_fee_parent[\"hex\"], high_fee_child[\"hex\"]]\n+        self.packages_to_submit.append(package_hex_basic)\n+        # Child should already be in orphanage\n+        self.transactions_to_presend[1] = [high_fee_child[\"tx\"]]\n+        # Parent would have been previously rejected\n+        self.transactions_to_presend[3] = [low_fee_parent[\"tx\"]]\n+\n+    def test_individual_logic(self):\n+        node = self.nodes[0]\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        low_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=2*FEERATE_1SAT_VB)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+\n+        peer1 = node.add_p2p_connection(P2PInterface())\n+        peer2 = node.add_p2p_connection(P2PInterface())\n+\n+        self.log.info(\"Check that tx caches low feerate rejections\")\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer1.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer1.wait_for_getdata([parent_wtxid_int])\n+        peer1.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer2, check that it is ignored\n+        with node.assert_debug_log([f\"got inv: wtx {low_fee_parent['wtxid']}  have\"]):\n+            peer2.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer2.last_message\n+\n+        self.log.info(\"Check that the node doesn't try to validate a failed package again\")\n+        # Send the (orphan) child that has a higher feerate but not enough to bump the parent\n+        low_child_wtxid_int = int(low_fee_child[\"tx\"].getwtxid(), 16)\n+        peer1.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        peer1.wait_for_getdata([low_child_wtxid_int])\n+        peer1.send_and_ping(msg_tx(low_fee_child[\"tx\"]))\n+        # Node should request the orphan's missing parent. It has seen this parent before, but only\n+        # cached the failure by wtxid, not txid.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer1.wait_for_getdata([parent_txid_int])\n+        failed_expected_logs_1p1c = []\n+        failed_expected_logs_1p1c.append(f\"found tx {low_fee_parent['txid']} (wtxid={low_fee_parent['wtxid']}) in reconsiderable rejects, looking for child in orphanage\")\n+        failed_expected_logs_1p1c.append(f\"found child {low_fee_child['txid']} (wtxid={low_fee_child['wtxid']}) of tx {low_fee_parent['txid']} (wtxid={low_fee_parent['wtxid']}) in orphanage, trying package evaluation\")\n+        failed_expected_logs_1p1c.append(f\"removed orphan tx {low_fee_child['txid']} (wtxid={low_fee_child['wtxid']})\")\n+\n+        with node.assert_debug_log(failed_expected_logs_1p1c):\n+            peer1.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        # The transactions do not get accepted due to low feerate\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+        assert low_fee_child[\"txid\"] not in node.getrawmempool()\n+\n+        # If peer2 announces the low feerate child, it should be ignored\n+        with node.assert_debug_log([f\"got inv: wtx {low_fee_child['wtxid']}  have\"]):\n+            peer2.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        assert \"getdata\" not in peer2.last_message\n+        # If either peer sends the parent again, package evaluation should not be attempted\n+        with node.assert_debug_log([f\"didn't evaluate package for {low_fee_parent['txid']} (wtxid={low_fee_parent['wtxid']}), no eligible child found\"]):\n+            peer1.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        with node.assert_debug_log([f\"didn't evaluate package for {low_fee_parent['txid']} (wtxid={low_fee_parent['wtxid']}), no eligible child found\"]):\n+            peer2.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        self.log.info(\"Check that the node groups a low-feerate tx with its single child in orphanage\")\n+        # Send the high feerate (orphan) child\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer1.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer1.wait_for_getdata([high_child_wtxid_int])\n+        peer1.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+        # Node should request the orphan's parent, even though it has already been rejected, both by\n+        # itself and with a child. This is necessary, otherwise high_fee_child can be censored.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer1.wait_for_getdata([parent_txid_int])\n+        expected_logs_1p1c = []\n+        expected_logs_1p1c.append(f\"found tx {low_fee_parent['txid']} (wtxid={low_fee_parent['wtxid']}) in reconsiderable rejects, looking for child in orphanage\")\n+        expected_logs_1p1c.append(f\"found child {high_fee_child['txid']} (wtxid={high_fee_child['wtxid']}) of tx {low_fee_parent['txid']} (wtxid={low_fee_parent['wtxid']}) in orphanage, trying package evaluation\")\n+        with node.assert_debug_log(expected_logs_1p1c):\n+            peer1.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # Both transactions should now be in mempool\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+        peer1.peer_disconnect()\n+        peer2.peer_disconnect()\n+        self.sync_all()\n+\n+    def run_test(self):\n+        self.ctr = 0\n+        self.wallet = MiniWallet(self.nodes[1])\n+        self.generate(self.wallet, 120)\n+\n+        self.log.info(\"Fill mempools with large transactions to raise mempool minimum feerates\")\n+        self.raise_network_minfee()\n+\n+        self.log.info(\"Check 1p1c validation logic on a single node\")\n+        self.test_individual_logic()\n+\n+        self.log.info(\"Check end-to-end package relay across multiple nodes\")\n+        self.packages_to_submit = []\n+        self.transactions_to_presend = [[]] * self.num_nodes\n+\n+        self.log.info(\"Create transactions and then mature the coinbases\")\n+        self.wallet.rescan_utxos(include_mempool=True)\n+        self.create_packages()\n+\n+        self.peers = []\n+        for i in range(self.num_nodes):\n+            self.peers.append(self.nodes[i].add_outbound_p2p_connection(P2PInterface(), p2p_idx=i, connection_type=\"outbound-full-relay\"))\n+\n+        self.log.info(\"Pre-send some transactions to nodes\")\n+        for i in range(self.num_nodes):\n+            peer = self.peers[i]\n+            for tx in self.transactions_to_presend[i]:\n+                inv = CInv(t=MSG_WTX, h=int(tx.getwtxid(), 16))\n+                peer.send_and_ping(msg_inv([inv]))\n+                peer.wait_for_getdata([int(tx.getwtxid(), 16)])\n+                peer.send_and_ping(msg_tx(tx))\n+            # This disconnect removes any sent orphans from the orphanage (EraseForPeer) and times\n+            # out the in-flight requests.  It is currently required for the test to pass right now,\n+            # because the node will not (re)try requesting orphan parents from multiple peers if the\n+            # first one fails.\n+            # TODO: remove this and test that the node retries orphan resolution with other peers",
      "path": "test/functional/p2p_1p1c_package_relay.py",
      "position": null,
      "original_position": 206,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "2f25d2e0840e94bee1c6a8908d94baf076bf1567",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "unsure what the test is covering if it's being deleted on disconnect?",
      "created_at": "2024-03-15T19:57:52Z",
      "updated_at": "2024-03-18T13:58:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1526776259",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1526776259"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 204,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1526776377",
      "pull_request_review_id": 1935032934,
      "id": 1526776377,
      "node_id": "PRRC_kwDOABII585bAMI5",
      "diff_hunk": "@@ -0,0 +1,222 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test that package works successfully in a \"network\" of nodes. Send various packages from different\n+nodes on a network in which some nodes have already received some of the transactions (and submitted\n+them to mempool, kept them as orphans or rejected them as too-low-feerate transactions). The\n+packages should be received and accepted by all transactions on the network.\n+\"\"\"\n+\n+from decimal import Decimal\n+from test_framework.messages import (\n+    CInv,\n+    MSG_WTX,\n+    msg_inv,\n+    msg_tx,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    create_lots_of_big_transactions,\n+    gen_return_txouts,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 4\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+            \"-whitelist=noban@127.0.0.1\",  # immediate tx relay\n+        ]] * self.num_nodes\n+        self.supports_cli = False\n+\n+    def raise_network_minfee(self):\n+        filler_wallet = MiniWallet(self.nodes[0])\n+        relayfee = self.nodes[0].getnetworkinfo()['relayfee']\n+        num_big_transactions = 75\n+        # Generate coins to spend and wait for them to mature\n+        self.generate(filler_wallet, num_big_transactions)\n+        self.generate(filler_wallet, 100)\n+\n+        self.log.debug(\"Create a mempool tx that will be evicted\")\n+        tx_to_be_evicted_id = filler_wallet.send_self_transfer(from_node=self.nodes[1], fee_rate=relayfee)[\"txid\"]\n+\n+        # Increase the tx fee rate to give the subsequent transactions a higher priority in the mempool\n+        # The tx has an approx. vsize of 65k, i.e. multiplying the previous fee rate (in sats/kvB)\n+        # by 130 should result in a fee that corresponds to 2x of that fee rate\n+        base_fee = relayfee * 130\n+\n+        self.log.debug(\"Fill up the mempool with txs with higher fee rate\")\n+        txouts = gen_return_txouts()\n+        with self.nodes[0].assert_debug_log([\"rolling minimum fee bumped\"]):\n+            for batch_of_txid in range(num_big_transactions):\n+                fee = (batch_of_txid + 1) * base_fee\n+                create_lots_of_big_transactions(filler_wallet, self.nodes[0], fee, 1, txouts)\n+\n+        self.log.debug(\"Wait for the network to sync mempools\")\n+        self.sync_mempools()\n+        assert tx_to_be_evicted_id not in self.nodes[0].getrawmempool()\n+\n+        self.log.debug(\"Check that all nodes' mempool minimum feerate is above min relay feerate\")\n+        for node in self.nodes:\n+            assert_equal(node.getmempoolinfo()['minrelaytxfee'], FEERATE_1SAT_VB)\n+            assert_greater_than(node.getmempoolinfo()['mempoolminfee'], FEERATE_1SAT_VB)\n+\n+    def create_packages(self):\n+        # Basic 1-parent-1-child package\n+        # node0: sender\n+        # node1: pre-received the child (orphan)\n+        # node2: pre-received nothing\n+        # node3: pre-received the parent (too low fee)\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+        package_hex_basic = [low_fee_parent[\"hex\"], high_fee_child[\"hex\"]]\n+        self.packages_to_submit.append(package_hex_basic)\n+        # Child should already be in orphanage\n+        self.transactions_to_presend[1] = [high_fee_child[\"tx\"]]\n+        # Parent would have been previously rejected\n+        self.transactions_to_presend[3] = [low_fee_parent[\"tx\"]]\n+\n+    def test_individual_logic(self):\n+        node = self.nodes[0]\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        low_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=2*FEERATE_1SAT_VB)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+\n+        peer1 = node.add_p2p_connection(P2PInterface())\n+        peer2 = node.add_p2p_connection(P2PInterface())\n+\n+        self.log.info(\"Check that tx caches low feerate rejections\")\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer1.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer1.wait_for_getdata([parent_wtxid_int])\n+        peer1.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer2, check that it is ignored\n+        with node.assert_debug_log([f\"got inv: wtx {low_fee_parent['wtxid']}  have\"]):\n+            peer2.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer2.last_message\n+\n+        self.log.info(\"Check that the node doesn't try to validate a failed package again\")\n+        # Send the (orphan) child that has a higher feerate but not enough to bump the parent\n+        low_child_wtxid_int = int(low_fee_child[\"tx\"].getwtxid(), 16)\n+        peer1.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        peer1.wait_for_getdata([low_child_wtxid_int])\n+        peer1.send_and_ping(msg_tx(low_fee_child[\"tx\"]))\n+        # Node should request the orphan's missing parent. It has seen this parent before, but only\n+        # cached the failure by wtxid, not txid.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer1.wait_for_getdata([parent_txid_int])\n+        failed_expected_logs_1p1c = []\n+        failed_expected_logs_1p1c.append(f\"found tx {low_fee_parent['txid']} (wtxid={low_fee_parent['wtxid']}) in reconsiderable rejects, looking for child in orphanage\")\n+        failed_expected_logs_1p1c.append(f\"found child {low_fee_child['txid']} (wtxid={low_fee_child['wtxid']}) of tx {low_fee_parent['txid']} (wtxid={low_fee_parent['wtxid']}) in orphanage, trying package evaluation\")\n+        failed_expected_logs_1p1c.append(f\"removed orphan tx {low_fee_child['txid']} (wtxid={low_fee_child['wtxid']})\")\n+\n+        with node.assert_debug_log(failed_expected_logs_1p1c):\n+            peer1.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        # The transactions do not get accepted due to low feerate\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+        assert low_fee_child[\"txid\"] not in node.getrawmempool()\n+\n+        # If peer2 announces the low feerate child, it should be ignored\n+        with node.assert_debug_log([f\"got inv: wtx {low_fee_child['wtxid']}  have\"]):\n+            peer2.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        assert \"getdata\" not in peer2.last_message\n+        # If either peer sends the parent again, package evaluation should not be attempted\n+        with node.assert_debug_log([f\"didn't evaluate package for {low_fee_parent['txid']} (wtxid={low_fee_parent['wtxid']}), no eligible child found\"]):\n+            peer1.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        with node.assert_debug_log([f\"didn't evaluate package for {low_fee_parent['txid']} (wtxid={low_fee_parent['wtxid']}), no eligible child found\"]):\n+            peer2.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        self.log.info(\"Check that the node groups a low-feerate tx with its single child in orphanage\")\n+        # Send the high feerate (orphan) child\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer1.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer1.wait_for_getdata([high_child_wtxid_int])\n+        peer1.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+        # Node should request the orphan's parent, even though it has already been rejected, both by\n+        # itself and with a child. This is necessary, otherwise high_fee_child can be censored.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer1.wait_for_getdata([parent_txid_int])\n+        expected_logs_1p1c = []\n+        expected_logs_1p1c.append(f\"found tx {low_fee_parent['txid']} (wtxid={low_fee_parent['wtxid']}) in reconsiderable rejects, looking for child in orphanage\")\n+        expected_logs_1p1c.append(f\"found child {high_fee_child['txid']} (wtxid={high_fee_child['wtxid']}) of tx {low_fee_parent['txid']} (wtxid={low_fee_parent['wtxid']}) in orphanage, trying package evaluation\")\n+        with node.assert_debug_log(expected_logs_1p1c):\n+            peer1.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # Both transactions should now be in mempool\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+        peer1.peer_disconnect()\n+        peer2.peer_disconnect()\n+        self.sync_all()\n+\n+    def run_test(self):\n+        self.ctr = 0\n+        self.wallet = MiniWallet(self.nodes[1])\n+        self.generate(self.wallet, 120)\n+\n+        self.log.info(\"Fill mempools with large transactions to raise mempool minimum feerates\")\n+        self.raise_network_minfee()\n+\n+        self.log.info(\"Check 1p1c validation logic on a single node\")\n+        self.test_individual_logic()\n+\n+        self.log.info(\"Check end-to-end package relay across multiple nodes\")\n+        self.packages_to_submit = []\n+        self.transactions_to_presend = [[]] * self.num_nodes\n+\n+        self.log.info(\"Create transactions and then mature the coinbases\")\n+        self.wallet.rescan_utxos(include_mempool=True)\n+        self.create_packages()\n+\n+        self.peers = []\n+        for i in range(self.num_nodes):\n+            self.peers.append(self.nodes[i].add_outbound_p2p_connection(P2PInterface(), p2p_idx=i, connection_type=\"outbound-full-relay\"))\n+\n+        self.log.info(\"Pre-send some transactions to nodes\")\n+        for i in range(self.num_nodes):\n+            peer = self.peers[i]\n+            for tx in self.transactions_to_presend[i]:\n+                inv = CInv(t=MSG_WTX, h=int(tx.getwtxid(), 16))\n+                peer.send_and_ping(msg_inv([inv]))\n+                peer.wait_for_getdata([int(tx.getwtxid(), 16)])\n+                peer.send_and_ping(msg_tx(tx))\n+            # This disconnect removes any sent orphans from the orphanage (EraseForPeer) and times\n+            # out the in-flight requests.  It is currently required for the test to pass right now,\n+            # because the node will not (re)try requesting orphan parents from multiple peers if the\n+            # first one fails.\n+            # TODO: remove this and test that the node retries orphan resolution with other peers\n+            # when the first try fails.\n+            peer.peer_disconnect()\n+\n+        self.log.info(\"Submit full packages to node0\")\n+        for package_hex in self.packages_to_submit:\n+            self.nodes[0].submitpackage(package_hex)\n+\n+        self.log.info(\"Wait for mempools to sync\")\n+        self.sync_mempools(timeout=20)\n+\n+        self.log.info(\"Wait for mempools to sync\")",
      "path": "test/functional/p2p_1p1c_package_relay.py",
      "position": null,
      "original_position": 217,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "2f25d2e0840e94bee1c6a8908d94baf076bf1567",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "double-sync for what?",
      "created_at": "2024-03-15T19:58:01Z",
      "updated_at": "2024-03-18T13:58:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1526776377",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1526776377"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 217,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1526790462",
      "pull_request_review_id": 1935032934,
      "id": 1526790462,
      "node_id": "PRRC_kwDOABII585bAPk-",
      "diff_hunk": "@@ -0,0 +1,222 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test that package works successfully in a \"network\" of nodes. Send various packages from different\n+nodes on a network in which some nodes have already received some of the transactions (and submitted\n+them to mempool, kept them as orphans or rejected them as too-low-feerate transactions). The\n+packages should be received and accepted by all transactions on the network.\n+\"\"\"\n+\n+from decimal import Decimal\n+from test_framework.messages import (\n+    CInv,\n+    MSG_WTX,\n+    msg_inv,\n+    msg_tx,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    create_lots_of_big_transactions,\n+    gen_return_txouts,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 4\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+            \"-whitelist=noban@127.0.0.1\",  # immediate tx relay\n+        ]] * self.num_nodes\n+        self.supports_cli = False\n+\n+    def raise_network_minfee(self):\n+        filler_wallet = MiniWallet(self.nodes[0])\n+        relayfee = self.nodes[0].getnetworkinfo()['relayfee']\n+        num_big_transactions = 75\n+        # Generate coins to spend and wait for them to mature\n+        self.generate(filler_wallet, num_big_transactions)\n+        self.generate(filler_wallet, 100)\n+\n+        self.log.debug(\"Create a mempool tx that will be evicted\")\n+        tx_to_be_evicted_id = filler_wallet.send_self_transfer(from_node=self.nodes[1], fee_rate=relayfee)[\"txid\"]\n+\n+        # Increase the tx fee rate to give the subsequent transactions a higher priority in the mempool\n+        # The tx has an approx. vsize of 65k, i.e. multiplying the previous fee rate (in sats/kvB)\n+        # by 130 should result in a fee that corresponds to 2x of that fee rate\n+        base_fee = relayfee * 130\n+\n+        self.log.debug(\"Fill up the mempool with txs with higher fee rate\")\n+        txouts = gen_return_txouts()\n+        with self.nodes[0].assert_debug_log([\"rolling minimum fee bumped\"]):\n+            for batch_of_txid in range(num_big_transactions):\n+                fee = (batch_of_txid + 1) * base_fee\n+                create_lots_of_big_transactions(filler_wallet, self.nodes[0], fee, 1, txouts)\n+\n+        self.log.debug(\"Wait for the network to sync mempools\")\n+        self.sync_mempools()\n+        assert tx_to_be_evicted_id not in self.nodes[0].getrawmempool()\n+\n+        self.log.debug(\"Check that all nodes' mempool minimum feerate is above min relay feerate\")\n+        for node in self.nodes:\n+            assert_equal(node.getmempoolinfo()['minrelaytxfee'], FEERATE_1SAT_VB)\n+            assert_greater_than(node.getmempoolinfo()['mempoolminfee'], FEERATE_1SAT_VB)\n+\n+    def create_packages(self):\n+        # Basic 1-parent-1-child package\n+        # node0: sender\n+        # node1: pre-received the child (orphan)\n+        # node2: pre-received nothing\n+        # node3: pre-received the parent (too low fee)\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+        package_hex_basic = [low_fee_parent[\"hex\"], high_fee_child[\"hex\"]]\n+        self.packages_to_submit.append(package_hex_basic)\n+        # Child should already be in orphanage\n+        self.transactions_to_presend[1] = [high_fee_child[\"tx\"]]\n+        # Parent would have been previously rejected\n+        self.transactions_to_presend[3] = [low_fee_parent[\"tx\"]]\n+\n+    def test_individual_logic(self):\n+        node = self.nodes[0]\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        low_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=2*FEERATE_1SAT_VB)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+\n+        peer1 = node.add_p2p_connection(P2PInterface())\n+        peer2 = node.add_p2p_connection(P2PInterface())\n+\n+        self.log.info(\"Check that tx caches low feerate rejections\")\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer1.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer1.wait_for_getdata([parent_wtxid_int])",
      "path": "test/functional/p2p_1p1c_package_relay.py",
      "position": null,
      "original_position": 106,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "2f25d2e0840e94bee1c6a8908d94baf076bf1567",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "had this timeout locally once",
      "created_at": "2024-03-15T20:16:30Z",
      "updated_at": "2024-03-18T13:58:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1526790462",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1526790462"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 115,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1526791671",
      "pull_request_review_id": 1935032934,
      "id": 1526791671,
      "node_id": "PRRC_kwDOABII585bAP33",
      "diff_hunk": "@@ -0,0 +1,222 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test that package works successfully in a \"network\" of nodes. Send various packages from different\n+nodes on a network in which some nodes have already received some of the transactions (and submitted\n+them to mempool, kept them as orphans or rejected them as too-low-feerate transactions). The\n+packages should be received and accepted by all transactions on the network.\n+\"\"\"\n+\n+from decimal import Decimal\n+from test_framework.messages import (\n+    CInv,\n+    MSG_WTX,\n+    msg_inv,\n+    msg_tx,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    create_lots_of_big_transactions,\n+    gen_return_txouts,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 4\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+            \"-whitelist=noban@127.0.0.1\",  # immediate tx relay\n+        ]] * self.num_nodes\n+        self.supports_cli = False\n+\n+    def raise_network_minfee(self):\n+        filler_wallet = MiniWallet(self.nodes[0])\n+        relayfee = self.nodes[0].getnetworkinfo()['relayfee']\n+        num_big_transactions = 75\n+        # Generate coins to spend and wait for them to mature\n+        self.generate(filler_wallet, num_big_transactions)\n+        self.generate(filler_wallet, 100)\n+\n+        self.log.debug(\"Create a mempool tx that will be evicted\")\n+        tx_to_be_evicted_id = filler_wallet.send_self_transfer(from_node=self.nodes[1], fee_rate=relayfee)[\"txid\"]\n+\n+        # Increase the tx fee rate to give the subsequent transactions a higher priority in the mempool\n+        # The tx has an approx. vsize of 65k, i.e. multiplying the previous fee rate (in sats/kvB)\n+        # by 130 should result in a fee that corresponds to 2x of that fee rate\n+        base_fee = relayfee * 130\n+\n+        self.log.debug(\"Fill up the mempool with txs with higher fee rate\")\n+        txouts = gen_return_txouts()\n+        with self.nodes[0].assert_debug_log([\"rolling minimum fee bumped\"]):\n+            for batch_of_txid in range(num_big_transactions):\n+                fee = (batch_of_txid + 1) * base_fee\n+                create_lots_of_big_transactions(filler_wallet, self.nodes[0], fee, 1, txouts)\n+\n+        self.log.debug(\"Wait for the network to sync mempools\")\n+        self.sync_mempools()\n+        assert tx_to_be_evicted_id not in self.nodes[0].getrawmempool()\n+\n+        self.log.debug(\"Check that all nodes' mempool minimum feerate is above min relay feerate\")\n+        for node in self.nodes:\n+            assert_equal(node.getmempoolinfo()['minrelaytxfee'], FEERATE_1SAT_VB)\n+            assert_greater_than(node.getmempoolinfo()['mempoolminfee'], FEERATE_1SAT_VB)\n+\n+    def create_packages(self):\n+        # Basic 1-parent-1-child package\n+        # node0: sender\n+        # node1: pre-received the child (orphan)\n+        # node2: pre-received nothing\n+        # node3: pre-received the parent (too low fee)\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+        package_hex_basic = [low_fee_parent[\"hex\"], high_fee_child[\"hex\"]]\n+        self.packages_to_submit.append(package_hex_basic)\n+        # Child should already be in orphanage\n+        self.transactions_to_presend[1] = [high_fee_child[\"tx\"]]\n+        # Parent would have been previously rejected\n+        self.transactions_to_presend[3] = [low_fee_parent[\"tx\"]]\n+\n+    def test_individual_logic(self):\n+        node = self.nodes[0]\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        low_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=2*FEERATE_1SAT_VB)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+\n+        peer1 = node.add_p2p_connection(P2PInterface())\n+        peer2 = node.add_p2p_connection(P2PInterface())\n+\n+        self.log.info(\"Check that tx caches low feerate rejections\")\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer1.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer1.wait_for_getdata([parent_wtxid_int])\n+        peer1.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer2, check that it is ignored\n+        with node.assert_debug_log([f\"got inv: wtx {low_fee_parent['wtxid']}  have\"]):\n+            peer2.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer2.last_message\n+\n+        self.log.info(\"Check that the node doesn't try to validate a failed package again\")\n+        # Send the (orphan) child that has a higher feerate but not enough to bump the parent\n+        low_child_wtxid_int = int(low_fee_child[\"tx\"].getwtxid(), 16)\n+        peer1.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        peer1.wait_for_getdata([low_child_wtxid_int])\n+        peer1.send_and_ping(msg_tx(low_fee_child[\"tx\"]))\n+        # Node should request the orphan's missing parent. It has seen this parent before, but only\n+        # cached the failure by wtxid, not txid.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer1.wait_for_getdata([parent_txid_int])\n+        failed_expected_logs_1p1c = []\n+        failed_expected_logs_1p1c.append(f\"found tx {low_fee_parent['txid']} (wtxid={low_fee_parent['wtxid']}) in reconsiderable rejects, looking for child in orphanage\")\n+        failed_expected_logs_1p1c.append(f\"found child {low_fee_child['txid']} (wtxid={low_fee_child['wtxid']}) of tx {low_fee_parent['txid']} (wtxid={low_fee_parent['wtxid']}) in orphanage, trying package evaluation\")\n+        failed_expected_logs_1p1c.append(f\"removed orphan tx {low_fee_child['txid']} (wtxid={low_fee_child['wtxid']})\")\n+\n+        with node.assert_debug_log(failed_expected_logs_1p1c):\n+            peer1.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        # The transactions do not get accepted due to low feerate\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+        assert low_fee_child[\"txid\"] not in node.getrawmempool()\n+\n+        # If peer2 announces the low feerate child, it should be ignored\n+        with node.assert_debug_log([f\"got inv: wtx {low_fee_child['wtxid']}  have\"]):\n+            peer2.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        assert \"getdata\" not in peer2.last_message\n+        # If either peer sends the parent again, package evaluation should not be attempted\n+        with node.assert_debug_log([f\"didn't evaluate package for {low_fee_parent['txid']} (wtxid={low_fee_parent['wtxid']}), no eligible child found\"]):\n+            peer1.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        with node.assert_debug_log([f\"didn't evaluate package for {low_fee_parent['txid']} (wtxid={low_fee_parent['wtxid']}), no eligible child found\"]):\n+            peer2.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        self.log.info(\"Check that the node groups a low-feerate tx with its single child in orphanage\")\n+        # Send the high feerate (orphan) child\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer1.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer1.wait_for_getdata([high_child_wtxid_int])\n+        peer1.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+        # Node should request the orphan's parent, even though it has already been rejected, both by\n+        # itself and with a child. This is necessary, otherwise high_fee_child can be censored.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer1.wait_for_getdata([parent_txid_int])\n+        expected_logs_1p1c = []\n+        expected_logs_1p1c.append(f\"found tx {low_fee_parent['txid']} (wtxid={low_fee_parent['wtxid']}) in reconsiderable rejects, looking for child in orphanage\")\n+        expected_logs_1p1c.append(f\"found child {high_fee_child['txid']} (wtxid={high_fee_child['wtxid']}) of tx {low_fee_parent['txid']} (wtxid={low_fee_parent['wtxid']}) in orphanage, trying package evaluation\")\n+        with node.assert_debug_log(expected_logs_1p1c):\n+            peer1.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # Both transactions should now be in mempool\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+        peer1.peer_disconnect()\n+        peer2.peer_disconnect()\n+        self.sync_all()\n+\n+    def run_test(self):\n+        self.ctr = 0\n+        self.wallet = MiniWallet(self.nodes[1])\n+        self.generate(self.wallet, 120)\n+\n+        self.log.info(\"Fill mempools with large transactions to raise mempool minimum feerates\")\n+        self.raise_network_minfee()\n+\n+        self.log.info(\"Check 1p1c validation logic on a single node\")\n+        self.test_individual_logic()\n+\n+        self.log.info(\"Check end-to-end package relay across multiple nodes\")",
      "path": "test/functional/p2p_1p1c_package_relay.py",
      "position": null,
      "original_position": 182,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "2f25d2e0840e94bee1c6a8908d94baf076bf1567",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "could this subtest be in its own subroutine",
      "created_at": "2024-03-15T20:18:04Z",
      "updated_at": "2024-03-18T13:58:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1526791671",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1526791671"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 182,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1530008039",
      "pull_request_review_id": 1945627419,
      "id": 1530008039,
      "node_id": "PRRC_kwDOABII585bMhHn",
      "diff_hunk": "@@ -846,6 +846,23 @@ class PeerManagerImpl final : public PeerManager\n     CRollingBloomFilter m_recent_rejects GUARDED_BY(::cs_main){120'000, 0.000'001};\n     uint256 hashRecentRejectsChainTip GUARDED_BY(cs_main);\n \n+    /**\n+     * Filter for the wtxids of transactions that were recently rejected by the mempool but are\n+     * eligible for reconsideration if submitted with other transactions.\n+     *\n+     * When a transaction's error is TxValidationResult::TX_RECONSIDERABLE (in a package or by\n+     * itself), add its wtxid to this filter.\n+     *\n+     * Upon receiving an announcement for a transaction, if it exists in this filter, do not\n+     * download the txdata.\n+     *\n+     * Reset this filter when the chain tip changes.\n+     *\n+     * Parameters are picked to be the same false positive rate but half the capacity as",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 25,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "1435bfac51ae431b91c38c4db0b92ce9b7353125",
      "in_reply_to_id": 1523804572,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Not much science, no. It makes sense to me to use the same false positive rate. As for size, I'll run my node for a bit longer and maybe use the ratio of `m_recent_rejects` / `m_recent_rejects_reconsiderable` usage to give a more scientific number.",
      "created_at": "2024-03-19T09:26:15Z",
      "updated_at": "2024-03-19T09:26:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1530008039",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1530008039"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 861,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1530008886",
      "pull_request_review_id": 1945628865,
      "id": 1530008886,
      "node_id": "PRRC_kwDOABII585bMhU2",
      "diff_hunk": "@@ -806,7 +806,7 @@ class PeerManagerImpl final : public PeerManager\n     /** Stalling timeout for blocks in IBD */\n     std::atomic<std::chrono::seconds> m_block_stalling_timeout{BLOCK_STALLING_TIMEOUT_DEFAULT};\n \n-    bool AlreadyHaveTx(const GenTxid& gtxid)\n+    bool AlreadyHaveTx(const GenTxid& gtxid, bool include_reconsiderable)",
      "path": "src/net_processing.cpp",
      "position": 69,
      "original_position": 5,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "1435bfac51ae431b91c38c4db0b92ce9b7353125",
      "in_reply_to_id": 1523821142,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "~Vestigial from a previous iteration of this PR and future changes. Will drop~ EDIT: I forgot to flip some",
      "created_at": "2024-03-19T09:26:51Z",
      "updated_at": "2024-03-20T17:30:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1530008886",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1530008886"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 857,
      "original_line": 857,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1532216970",
      "pull_request_review_id": 1949112319,
      "id": 1532216970,
      "node_id": "PRRC_kwDOABII585bU8aK",
      "diff_hunk": "@@ -0,0 +1,223 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test that package works successfully in a \"network\" of nodes. Send various packages from different\n+nodes on a network in which some nodes have already received some of the transactions (and submitted\n+them to mempool, kept them as orphans or rejected them as too-low-feerate transactions). The\n+packages should be received and accepted by all transactions on the network.\n+\"\"\"\n+\n+from decimal import Decimal\n+from test_framework.messages import (\n+    CInv,\n+    MSG_WTX,\n+    msg_inv,\n+    msg_tx,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    create_lots_of_big_transactions,\n+    gen_return_txouts,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 4",
      "path": "test/functional/p2p_1p1c_package_relay.py",
      "position": null,
      "original_position": 39,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "19015e3c9aed5709e776ef15bf9e73f126c7ea29",
      "in_reply_to_id": 1511599258,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "added a comment on top of where the package is created",
      "created_at": "2024-03-20T14:45:33Z",
      "updated_at": "2024-03-20T17:42:18Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1532216970",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1532216970"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 40,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1532237608",
      "pull_request_review_id": 1949112319,
      "id": 1532237608,
      "node_id": "PRRC_kwDOABII585bVBco",
      "diff_hunk": "@@ -0,0 +1,222 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test that package works successfully in a \"network\" of nodes. Send various packages from different\n+nodes on a network in which some nodes have already received some of the transactions (and submitted\n+them to mempool, kept them as orphans or rejected them as too-low-feerate transactions). The\n+packages should be received and accepted by all transactions on the network.\n+\"\"\"\n+\n+from decimal import Decimal\n+from test_framework.messages import (\n+    CInv,\n+    MSG_WTX,\n+    msg_inv,\n+    msg_tx,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    create_lots_of_big_transactions,\n+    gen_return_txouts,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 4\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+            \"-whitelist=noban@127.0.0.1\",  # immediate tx relay\n+        ]] * self.num_nodes\n+        self.supports_cli = False\n+\n+    def raise_network_minfee(self):\n+        filler_wallet = MiniWallet(self.nodes[0])\n+        relayfee = self.nodes[0].getnetworkinfo()['relayfee']\n+        num_big_transactions = 75\n+        # Generate coins to spend and wait for them to mature\n+        self.generate(filler_wallet, num_big_transactions)\n+        self.generate(filler_wallet, 100)\n+\n+        self.log.debug(\"Create a mempool tx that will be evicted\")\n+        tx_to_be_evicted_id = filler_wallet.send_self_transfer(from_node=self.nodes[1], fee_rate=relayfee)[\"txid\"]\n+\n+        # Increase the tx fee rate to give the subsequent transactions a higher priority in the mempool\n+        # The tx has an approx. vsize of 65k, i.e. multiplying the previous fee rate (in sats/kvB)\n+        # by 130 should result in a fee that corresponds to 2x of that fee rate\n+        base_fee = relayfee * 130\n+\n+        self.log.debug(\"Fill up the mempool with txs with higher fee rate\")\n+        txouts = gen_return_txouts()\n+        with self.nodes[0].assert_debug_log([\"rolling minimum fee bumped\"]):\n+            for batch_of_txid in range(num_big_transactions):\n+                fee = (batch_of_txid + 1) * base_fee\n+                create_lots_of_big_transactions(filler_wallet, self.nodes[0], fee, 1, txouts)\n+\n+        self.log.debug(\"Wait for the network to sync mempools\")\n+        self.sync_mempools()\n+        assert tx_to_be_evicted_id not in self.nodes[0].getrawmempool()\n+\n+        self.log.debug(\"Check that all nodes' mempool minimum feerate is above min relay feerate\")\n+        for node in self.nodes:\n+            assert_equal(node.getmempoolinfo()['minrelaytxfee'], FEERATE_1SAT_VB)\n+            assert_greater_than(node.getmempoolinfo()['mempoolminfee'], FEERATE_1SAT_VB)\n+\n+    def create_packages(self):\n+        # Basic 1-parent-1-child package\n+        # node0: sender\n+        # node1: pre-received the child (orphan)\n+        # node2: pre-received nothing\n+        # node3: pre-received the parent (too low fee)\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+        package_hex_basic = [low_fee_parent[\"hex\"], high_fee_child[\"hex\"]]\n+        self.packages_to_submit.append(package_hex_basic)\n+        # Child should already be in orphanage\n+        self.transactions_to_presend[1] = [high_fee_child[\"tx\"]]\n+        # Parent would have been previously rejected\n+        self.transactions_to_presend[3] = [low_fee_parent[\"tx\"]]\n+\n+    def test_individual_logic(self):\n+        node = self.nodes[0]\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        low_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=2*FEERATE_1SAT_VB)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+\n+        peer1 = node.add_p2p_connection(P2PInterface())\n+        peer2 = node.add_p2p_connection(P2PInterface())\n+\n+        self.log.info(\"Check that tx caches low feerate rejections\")\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer1.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer1.wait_for_getdata([parent_wtxid_int])\n+        peer1.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer2, check that it is ignored\n+        with node.assert_debug_log([f\"got inv: wtx {low_fee_parent['wtxid']}  have\"]):\n+            peer2.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer2.last_message\n+\n+        self.log.info(\"Check that the node doesn't try to validate a failed package again\")\n+        # Send the (orphan) child that has a higher feerate but not enough to bump the parent\n+        low_child_wtxid_int = int(low_fee_child[\"tx\"].getwtxid(), 16)\n+        peer1.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        peer1.wait_for_getdata([low_child_wtxid_int])\n+        peer1.send_and_ping(msg_tx(low_fee_child[\"tx\"]))\n+        # Node should request the orphan's missing parent. It has seen this parent before, but only\n+        # cached the failure by wtxid, not txid.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer1.wait_for_getdata([parent_txid_int])\n+        failed_expected_logs_1p1c = []\n+        failed_expected_logs_1p1c.append(f\"found tx {low_fee_parent['txid']} (wtxid={low_fee_parent['wtxid']}) in reconsiderable rejects, looking for child in orphanage\")\n+        failed_expected_logs_1p1c.append(f\"found child {low_fee_child['txid']} (wtxid={low_fee_child['wtxid']}) of tx {low_fee_parent['txid']} (wtxid={low_fee_parent['wtxid']}) in orphanage, trying package evaluation\")\n+        failed_expected_logs_1p1c.append(f\"removed orphan tx {low_fee_child['txid']} (wtxid={low_fee_child['wtxid']})\")\n+\n+        with node.assert_debug_log(failed_expected_logs_1p1c):\n+            peer1.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        # The transactions do not get accepted due to low feerate\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+        assert low_fee_child[\"txid\"] not in node.getrawmempool()\n+\n+        # If peer2 announces the low feerate child, it should be ignored\n+        with node.assert_debug_log([f\"got inv: wtx {low_fee_child['wtxid']}  have\"]):\n+            peer2.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        assert \"getdata\" not in peer2.last_message\n+        # If either peer sends the parent again, package evaluation should not be attempted\n+        with node.assert_debug_log([f\"didn't evaluate package for {low_fee_parent['txid']} (wtxid={low_fee_parent['wtxid']}), no eligible child found\"]):\n+            peer1.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        with node.assert_debug_log([f\"didn't evaluate package for {low_fee_parent['txid']} (wtxid={low_fee_parent['wtxid']}), no eligible child found\"]):\n+            peer2.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        self.log.info(\"Check that the node groups a low-feerate tx with its single child in orphanage\")\n+        # Send the high feerate (orphan) child\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer1.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer1.wait_for_getdata([high_child_wtxid_int])\n+        peer1.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+        # Node should request the orphan's parent, even though it has already been rejected, both by\n+        # itself and with a child. This is necessary, otherwise high_fee_child can be censored.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer1.wait_for_getdata([parent_txid_int])\n+        expected_logs_1p1c = []\n+        expected_logs_1p1c.append(f\"found tx {low_fee_parent['txid']} (wtxid={low_fee_parent['wtxid']}) in reconsiderable rejects, looking for child in orphanage\")\n+        expected_logs_1p1c.append(f\"found child {high_fee_child['txid']} (wtxid={high_fee_child['wtxid']}) of tx {low_fee_parent['txid']} (wtxid={low_fee_parent['wtxid']}) in orphanage, trying package evaluation\")\n+        with node.assert_debug_log(expected_logs_1p1c):\n+            peer1.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # Both transactions should now be in mempool\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+        peer1.peer_disconnect()\n+        peer2.peer_disconnect()\n+        self.sync_all()\n+\n+    def run_test(self):\n+        self.ctr = 0\n+        self.wallet = MiniWallet(self.nodes[1])\n+        self.generate(self.wallet, 120)\n+\n+        self.log.info(\"Fill mempools with large transactions to raise mempool minimum feerates\")\n+        self.raise_network_minfee()\n+\n+        self.log.info(\"Check 1p1c validation logic on a single node\")\n+        self.test_individual_logic()\n+\n+        self.log.info(\"Check end-to-end package relay across multiple nodes\")\n+        self.packages_to_submit = []\n+        self.transactions_to_presend = [[]] * self.num_nodes\n+\n+        self.log.info(\"Create transactions and then mature the coinbases\")\n+        self.wallet.rescan_utxos(include_mempool=True)\n+        self.create_packages()\n+\n+        self.peers = []\n+        for i in range(self.num_nodes):\n+            self.peers.append(self.nodes[i].add_outbound_p2p_connection(P2PInterface(), p2p_idx=i, connection_type=\"outbound-full-relay\"))\n+\n+        self.log.info(\"Pre-send some transactions to nodes\")\n+        for i in range(self.num_nodes):\n+            peer = self.peers[i]\n+            for tx in self.transactions_to_presend[i]:\n+                inv = CInv(t=MSG_WTX, h=int(tx.getwtxid(), 16))\n+                peer.send_and_ping(msg_inv([inv]))\n+                peer.wait_for_getdata([int(tx.getwtxid(), 16)])\n+                peer.send_and_ping(msg_tx(tx))\n+            # This disconnect removes any sent orphans from the orphanage (EraseForPeer) and times\n+            # out the in-flight requests.  It is currently required for the test to pass right now,\n+            # because the node will not (re)try requesting orphan parents from multiple peers if the\n+            # first one fails.\n+            # TODO: remove this and test that the node retries orphan resolution with other peers\n+            # when the first try fails.\n+            peer.peer_disconnect()\n+\n+        self.log.info(\"Submit full packages to node0\")\n+        for package_hex in self.packages_to_submit:\n+            self.nodes[0].submitpackage(package_hex)\n+\n+        self.log.info(\"Wait for mempools to sync\")\n+        self.sync_mempools(timeout=20)\n+\n+        self.log.info(\"Wait for mempools to sync\")",
      "path": "test/functional/p2p_1p1c_package_relay.py",
      "position": null,
      "original_position": 217,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "2f25d2e0840e94bee1c6a8908d94baf076bf1567",
      "in_reply_to_id": 1526776377,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "(originally there was an original broadcast, then a package RBF broadcast) no reason, deleted",
      "created_at": "2024-03-20T14:57:25Z",
      "updated_at": "2024-03-20T17:42:18Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1532237608",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1532237608"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 217,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1532243418",
      "pull_request_review_id": 1949112319,
      "id": 1532243418,
      "node_id": "PRRC_kwDOABII585bVC3a",
      "diff_hunk": "@@ -4450,6 +4552,15 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         if (state.IsInvalid()) {\n             ProcessInvalidTx(pfrom.GetId(), ptx, state, /*maybe_add_extra_compact_tx=*/true);\n         }\n+        if (state.GetResult() == TxValidationResult::TX_RECONSIDERABLE) {",
      "path": "src/net_processing.cpp",
      "position": 365,
      "original_position": 127,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "47efa940c4180e1cdc778fdaae5f086ad4085791",
      "in_reply_to_id": 1525341442,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I prefer how it is right now as\r\n- it's clear that it's based on the result we just got from mempool validation\r\n- it doesn't require peerman having direct access to `m_recent_rejects_reconsiderable` (which I would want to move into txdownloadman module)",
      "created_at": "2024-03-20T15:00:18Z",
      "updated_at": "2024-03-20T17:42:18Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1532243418",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1532243418"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 4651,
      "original_line": 4651,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1532283818",
      "pull_request_review_id": 1949112319,
      "id": 1532283818,
      "node_id": "PRRC_kwDOABII585bVMuq",
      "diff_hunk": "@@ -4334,6 +4426,16 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         m_txrequest.ReceivedResponse(pfrom.GetId(), txid);\n         if (tx.HasWitness()) m_txrequest.ReceivedResponse(pfrom.GetId(), wtxid);\n \n+        // If we find this transaction in m_recent_rejects_reconsiderable, we shouldn't try it by",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 110,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "47efa940c4180e1cdc778fdaae5f086ad4085791",
      "in_reply_to_id": 1525375424,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "What do you mean by optimization? It's the same idea as `m_recent_rejects`, we don't want to waste bandwidth even though we are willing to retry low feerate things",
      "created_at": "2024-03-20T15:20:55Z",
      "updated_at": "2024-03-20T17:42:18Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1532283818",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1532283818"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 4429,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1532285661",
      "pull_request_review_id": 1949112319,
      "id": 1532285661,
      "node_id": "PRRC_kwDOABII585bVNLd",
      "diff_hunk": "@@ -4334,6 +4426,16 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         m_txrequest.ReceivedResponse(pfrom.GetId(), txid);\n         if (tx.HasWitness()) m_txrequest.ReceivedResponse(pfrom.GetId(), wtxid);\n \n+        // If we find this transaction in m_recent_rejects_reconsiderable, we shouldn't try it by\n+        // itself again. However, look for a matching child in the orphanage and maybe submit it\n+        // again as a package.\n+        if (m_recent_rejects_reconsiderable.contains(wtxid)) {",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 113,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "47efa940c4180e1cdc778fdaae5f086ad4085791",
      "in_reply_to_id": 1525396593,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Ah good point as I just realize the previous thing was breaking the forcerelay stuff for low feerate txns. Moved inside that block.",
      "created_at": "2024-03-20T15:21:51Z",
      "updated_at": "2024-03-20T17:42:18Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1532285661",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1532285661"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 4432,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1532366124",
      "pull_request_review_id": 1949112319,
      "id": 1532366124,
      "node_id": "PRRC_kwDOABII585bVg0s",
      "diff_hunk": "@@ -596,6 +596,12 @@ class PeerManagerImpl final : public PeerManager\n     void ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, const std::list<CTransactionRef>& replaced_transactions)\n         EXCLUSIVE_LOCKS_REQUIRED(!m_peer_mutex, g_msgproc_mutex, cs_main);\n \n+    void ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, NodeId nodeid)",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 4,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "47efa940c4180e1cdc778fdaae5f086ad4085791",
      "in_reply_to_id": 1523824762,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "added",
      "created_at": "2024-03-20T16:01:10Z",
      "updated_at": "2024-03-20T17:42:18Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1532366124",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1532366124"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 602,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1532366193",
      "pull_request_review_id": 1949112319,
      "id": 1532366193,
      "node_id": "PRRC_kwDOABII585bVg1x",
      "diff_hunk": "@@ -596,6 +596,12 @@ class PeerManagerImpl final : public PeerManager\n     void ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, const std::list<CTransactionRef>& replaced_transactions)\n         EXCLUSIVE_LOCKS_REQUIRED(!m_peer_mutex, g_msgproc_mutex, cs_main);\n \n+    void ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, NodeId nodeid)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_peer_mutex, g_msgproc_mutex, cs_main);\n+\n+    void MaybeProcess1P1CPackage(const CTransactionRef& ptx, NodeId nodeid)",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 7,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "47efa940c4180e1cdc778fdaae5f086ad4085791",
      "in_reply_to_id": 1523824732,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "added",
      "created_at": "2024-03-20T16:01:13Z",
      "updated_at": "2024-03-20T17:42:18Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1532366193",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1532366193"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 611,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1532453411",
      "pull_request_review_id": 1949112319,
      "id": 1532453411,
      "node_id": "PRRC_kwDOABII585bV2Ij",
      "diff_hunk": "@@ -846,6 +846,23 @@ class PeerManagerImpl final : public PeerManager\n     CRollingBloomFilter m_recent_rejects GUARDED_BY(::cs_main){120'000, 0.000'001};\n     uint256 hashRecentRejectsChainTip GUARDED_BY(cs_main);\n \n+    /**\n+     * Filter for the wtxids of transactions that were recently rejected by the mempool but are\n+     * eligible for reconsideration if submitted with other transactions.\n+     *\n+     * When a transaction's error is TxValidationResult::TX_RECONSIDERABLE (in a package or by\n+     * itself), add its wtxid to this filter.\n+     *\n+     * Upon receiving an announcement for a transaction, if it exists in this filter, do not\n+     * download the txdata.\n+     *\n+     * Reset this filter when the chain tip changes.\n+     *\n+     * Parameters are picked to be the same false positive rate but half the capacity as",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 25,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "1435bfac51ae431b91c38c4db0b92ce9b7353125",
      "in_reply_to_id": 1523804572,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Actually, rethinking this, if the capacity is informed by maximum churn, it should just be the same as `m_recent_rejects`.",
      "created_at": "2024-03-20T16:47:29Z",
      "updated_at": "2024-03-20T17:42:18Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1532453411",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1532453411"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 861,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1532491393",
      "pull_request_review_id": 1949112319,
      "id": 1532491393,
      "node_id": "PRRC_kwDOABII585bV_aB",
      "diff_hunk": "@@ -3181,6 +3187,92 @@ void PeerManagerImpl::ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, c\n     }\n }\n \n+void PeerManagerImpl::ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, NodeId nodeid)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    if (package_result.m_state.IsInvalid()) {\n+        m_recent_rejects_reconsiderable.insert(GetPackageHash(package));\n+    }\n+\n+    // Iterate backwards to erase in-package descendants from the orphanage before they become\n+    // relevant in AddChildrenToWorkSet.\n+    for (auto package_it = package.rbegin(); package_it != package.rend(); ++package_it) {\n+        const auto& tx = *package_it;\n+        const auto it_result{package_result.m_tx_results.find(tx->GetWitnessHash())};\n+        if (it_result != package_result.m_tx_results.end()) {\n+            const auto& tx_result = it_result->second;\n+            switch (tx_result.m_result_type) {\n+                case MempoolAcceptResult::ResultType::VALID:\n+                {\n+                    Assume(tx_result.m_replaced_transactions.has_value());\n+                    std::list<CTransactionRef> empty_replacement_list;\n+                    ProcessValidTx(nodeid, tx, tx_result.m_replaced_transactions.value_or(empty_replacement_list));\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::INVALID:\n+                case MempoolAcceptResult::ResultType::DIFFERENT_WITNESS:\n+                {\n+                    // Don't add to vExtraTxnForCompact, as these transactions would already be",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 45,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "47efa940c4180e1cdc778fdaae5f086ad4085791",
      "in_reply_to_id": 1526676597,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "we do add orphans to vExtraTxnForCompact though?",
      "created_at": "2024-03-20T17:11:31Z",
      "updated_at": "2024-03-20T17:42:18Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1532491393",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1532491393"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3218,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1532493851",
      "pull_request_review_id": 1949112319,
      "id": 1532493851,
      "node_id": "PRRC_kwDOABII585bWAAb",
      "diff_hunk": "@@ -3181,6 +3187,92 @@ void PeerManagerImpl::ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, c\n     }\n }\n \n+void PeerManagerImpl::ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, NodeId nodeid)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    if (package_result.m_state.IsInvalid()) {\n+        m_recent_rejects_reconsiderable.insert(GetPackageHash(package));\n+    }\n+\n+    // Iterate backwards to erase in-package descendants from the orphanage before they become\n+    // relevant in AddChildrenToWorkSet.\n+    for (auto package_it = package.rbegin(); package_it != package.rend(); ++package_it) {\n+        const auto& tx = *package_it;\n+        const auto it_result{package_result.m_tx_results.find(tx->GetWitnessHash())};\n+        if (it_result != package_result.m_tx_results.end()) {\n+            const auto& tx_result = it_result->second;\n+            switch (tx_result.m_result_type) {\n+                case MempoolAcceptResult::ResultType::VALID:\n+                {\n+                    Assume(tx_result.m_replaced_transactions.has_value());\n+                    std::list<CTransactionRef> empty_replacement_list;\n+                    ProcessValidTx(nodeid, tx, tx_result.m_replaced_transactions.value_or(empty_replacement_list));\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::INVALID:\n+                case MempoolAcceptResult::ResultType::DIFFERENT_WITNESS:\n+                {\n+                    // Don't add to vExtraTxnForCompact, as these transactions would already be\n+                    // there as an orphan or too low feerate tx.\n+                    ProcessInvalidTx(nodeid, tx, tx_result.m_state, /*maybe_add_extra_compact_tx=*/false);\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::MEMPOOL_ENTRY:",
      "path": "src/net_processing.cpp",
      "position": 204,
      "original_position": 50,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "47efa940c4180e1cdc778fdaae5f086ad4085791",
      "in_reply_to_id": 1526656636,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Why? There wouldn't be anything interesting in `state`",
      "created_at": "2024-03-20T17:13:02Z",
      "updated_at": "2024-03-20T17:42:18Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1532493851",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1532493851"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 3284,
      "original_line": 3284,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1532494577",
      "pull_request_review_id": 1949112319,
      "id": 1532494577,
      "node_id": "PRRC_kwDOABII585bWALx",
      "diff_hunk": "@@ -3181,6 +3187,92 @@ void PeerManagerImpl::ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, c\n     }\n }\n \n+void PeerManagerImpl::ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, NodeId nodeid)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    if (package_result.m_state.IsInvalid()) {\n+        m_recent_rejects_reconsiderable.insert(GetPackageHash(package));\n+    }\n+\n+    // Iterate backwards to erase in-package descendants from the orphanage before they become\n+    // relevant in AddChildrenToWorkSet.\n+    for (auto package_it = package.rbegin(); package_it != package.rend(); ++package_it) {\n+        const auto& tx = *package_it;\n+        const auto it_result{package_result.m_tx_results.find(tx->GetWitnessHash())};\n+        if (it_result != package_result.m_tx_results.end()) {\n+            const auto& tx_result = it_result->second;\n+            switch (tx_result.m_result_type) {\n+                case MempoolAcceptResult::ResultType::VALID:\n+                {\n+                    Assume(tx_result.m_replaced_transactions.has_value());\n+                    std::list<CTransactionRef> empty_replacement_list;\n+                    ProcessValidTx(nodeid, tx, tx_result.m_replaced_transactions.value_or(empty_replacement_list));\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::INVALID:\n+                case MempoolAcceptResult::ResultType::DIFFERENT_WITNESS:\n+                {\n+                    // Don't add to vExtraTxnForCompact, as these transactions would already be\n+                    // there as an orphan or too low feerate tx.\n+                    ProcessInvalidTx(nodeid, tx, tx_result.m_state, /*maybe_add_extra_compact_tx=*/false);\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::MEMPOOL_ENTRY:\n+                {\n+                    // AlreadyHaveTx() should be catching transactions that are already in mempool.\n+                    Assume(false);\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+void PeerManagerImpl::MaybeProcess1P1CPackage(const CTransactionRef& ptx, NodeId nodeid)",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 61,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "47efa940c4180e1cdc778fdaae5f086ad4085791",
      "in_reply_to_id": 1526235839,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Well, it might not be a parent :shrug: most likely it's just a low feerate transaction actually. I didn't change but don't feel strongly",
      "created_at": "2024-03-20T17:13:36Z",
      "updated_at": "2024-03-20T17:42:18Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1532494577",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1532494577"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3271,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1532517889",
      "pull_request_review_id": 1949112319,
      "id": 1532517889,
      "node_id": "PRRC_kwDOABII585bWF4B",
      "diff_hunk": "@@ -3181,6 +3187,92 @@ void PeerManagerImpl::ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, c\n     }\n }\n \n+void PeerManagerImpl::ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, NodeId nodeid)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    if (package_result.m_state.IsInvalid()) {\n+        m_recent_rejects_reconsiderable.insert(GetPackageHash(package));\n+    }\n+\n+    // Iterate backwards to erase in-package descendants from the orphanage before they become\n+    // relevant in AddChildrenToWorkSet.\n+    for (auto package_it = package.rbegin(); package_it != package.rend(); ++package_it) {\n+        const auto& tx = *package_it;\n+        const auto it_result{package_result.m_tx_results.find(tx->GetWitnessHash())};\n+        if (it_result != package_result.m_tx_results.end()) {\n+            const auto& tx_result = it_result->second;\n+            switch (tx_result.m_result_type) {\n+                case MempoolAcceptResult::ResultType::VALID:\n+                {\n+                    Assume(tx_result.m_replaced_transactions.has_value());\n+                    std::list<CTransactionRef> empty_replacement_list;\n+                    ProcessValidTx(nodeid, tx, tx_result.m_replaced_transactions.value_or(empty_replacement_list));\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::INVALID:\n+                case MempoolAcceptResult::ResultType::DIFFERENT_WITNESS:\n+                {\n+                    // Don't add to vExtraTxnForCompact, as these transactions would already be\n+                    // there as an orphan or too low feerate tx.\n+                    ProcessInvalidTx(nodeid, tx, tx_result.m_state, /*maybe_add_extra_compact_tx=*/false);\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::MEMPOOL_ENTRY:\n+                {\n+                    // AlreadyHaveTx() should be catching transactions that are already in mempool.\n+                    Assume(false);\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+void PeerManagerImpl::MaybeProcess1P1CPackage(const CTransactionRef& ptx, NodeId nodeid)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    const auto cpfp_candidates{m_orphanage.GetChildren(ptx, nodeid)};\n+    bool tried_package_cpfp{false};\n+\n+    const auto& txid{ptx->GetHash()};\n+    const auto& wtxid{ptx->GetWitnessHash()};\n+",
      "path": "src/net_processing.cpp",
      "position": 226,
      "original_position": 72,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "47efa940c4180e1cdc778fdaae5f086ad4085791",
      "in_reply_to_id": 1526243536,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "added",
      "created_at": "2024-03-20T17:29:58Z",
      "updated_at": "2024-03-20T17:42:18Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1532517889",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1532517889"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 3306,
      "original_line": 3306,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1532520860",
      "pull_request_review_id": 1949112319,
      "id": 1532520860,
      "node_id": "PRRC_kwDOABII585bWGmc",
      "diff_hunk": "@@ -806,7 +806,7 @@ class PeerManagerImpl final : public PeerManager\n     /** Stalling timeout for blocks in IBD */\n     std::atomic<std::chrono::seconds> m_block_stalling_timeout{BLOCK_STALLING_TIMEOUT_DEFAULT};\n \n-    bool AlreadyHaveTx(const GenTxid& gtxid)\n+    bool AlreadyHaveTx(const GenTxid& gtxid, bool include_reconsiderable)",
      "path": "src/net_processing.cpp",
      "position": 69,
      "original_position": 5,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "1435bfac51ae431b91c38c4db0b92ce9b7353125",
      "in_reply_to_id": 1523821142,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Turns out I actually just forgot to switch from true to false in a few places, and hadn't included a test for which these were important. I've added them back now and wrote a test (see \"package basic nonsegwit\"). Basically, we need to make sure we don't include reconsiderable when we're filtering for rejected parents on a `TX_MISSING_INPUTS` and when we're sending the GETDATAs, in case our parent was a low-feerate nonsegwit tx that we saw previously.",
      "created_at": "2024-03-20T17:32:15Z",
      "updated_at": "2024-03-20T17:42:18Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1532520860",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1532520860"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 857,
      "original_line": 857,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1532534695",
      "pull_request_review_id": 1949626446,
      "id": 1532534695,
      "node_id": "PRRC_kwDOABII585bWJ-n",
      "diff_hunk": "@@ -2209,6 +2226,8 @@ bool PeerManagerImpl::AlreadyHaveTx(const GenTxid& gtxid)\n \n     if (m_orphanage.HaveTx(gtxid)) return true;\n \n+    if (include_reconsiderable && m_recent_rejects_reconsiderable.contains(gtxid.GetHash())) return true;",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 46,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "1435bfac51ae431b91c38c4db0b92ce9b7353125",
      "in_reply_to_id": 1523822569,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "done",
      "created_at": "2024-03-20T17:42:56Z",
      "updated_at": "2024-03-20T17:42:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1532534695",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1532534695"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 2229,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1532535179",
      "pull_request_review_id": 1949627158,
      "id": 1532535179,
      "node_id": "PRRC_kwDOABII585bWKGL",
      "diff_hunk": "@@ -3181,6 +3187,92 @@ void PeerManagerImpl::ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, c\n     }\n }\n \n+void PeerManagerImpl::ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, NodeId nodeid)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    if (package_result.m_state.IsInvalid()) {\n+        m_recent_rejects_reconsiderable.insert(GetPackageHash(package));\n+    }\n+\n+    // Iterate backwards to erase in-package descendants from the orphanage before they become\n+    // relevant in AddChildrenToWorkSet.\n+    for (auto package_it = package.rbegin(); package_it != package.rend(); ++package_it) {\n+        const auto& tx = *package_it;\n+        const auto it_result{package_result.m_tx_results.find(tx->GetWitnessHash())};\n+        if (it_result != package_result.m_tx_results.end()) {\n+            const auto& tx_result = it_result->second;\n+            switch (tx_result.m_result_type) {\n+                case MempoolAcceptResult::ResultType::VALID:\n+                {\n+                    Assume(tx_result.m_replaced_transactions.has_value());\n+                    std::list<CTransactionRef> empty_replacement_list;\n+                    ProcessValidTx(nodeid, tx, tx_result.m_replaced_transactions.value_or(empty_replacement_list));\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::INVALID:\n+                case MempoolAcceptResult::ResultType::DIFFERENT_WITNESS:\n+                {\n+                    // Don't add to vExtraTxnForCompact, as these transactions would already be\n+                    // there as an orphan or too low feerate tx.\n+                    ProcessInvalidTx(nodeid, tx, tx_result.m_state, /*maybe_add_extra_compact_tx=*/false);\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::MEMPOOL_ENTRY:\n+                {\n+                    // AlreadyHaveTx() should be catching transactions that are already in mempool.\n+                    Assume(false);\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+void PeerManagerImpl::MaybeProcess1P1CPackage(const CTransactionRef& ptx, NodeId nodeid)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    const auto cpfp_candidates{m_orphanage.GetChildren(ptx, nodeid)};\n+    bool tried_package_cpfp{false};\n+\n+    const auto& txid{ptx->GetHash()};",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 70,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "47efa940c4180e1cdc778fdaae5f086ad4085791",
      "in_reply_to_id": 1526239102,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "done",
      "created_at": "2024-03-20T17:43:17Z",
      "updated_at": "2024-03-20T17:43:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1532535179",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1532535179"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3243,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1532538138",
      "pull_request_review_id": 1949631171,
      "id": 1532538138,
      "node_id": "PRRC_kwDOABII585bWK0a",
      "diff_hunk": "@@ -0,0 +1,222 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test that package works successfully in a \"network\" of nodes. Send various packages from different\n+nodes on a network in which some nodes have already received some of the transactions (and submitted\n+them to mempool, kept them as orphans or rejected them as too-low-feerate transactions). The\n+packages should be received and accepted by all transactions on the network.\n+\"\"\"\n+\n+from decimal import Decimal\n+from test_framework.messages import (\n+    CInv,\n+    MSG_WTX,\n+    msg_inv,\n+    msg_tx,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    create_lots_of_big_transactions,\n+    gen_return_txouts,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 4\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+            \"-whitelist=noban@127.0.0.1\",  # immediate tx relay\n+        ]] * self.num_nodes\n+        self.supports_cli = False\n+\n+    def raise_network_minfee(self):\n+        filler_wallet = MiniWallet(self.nodes[0])\n+        relayfee = self.nodes[0].getnetworkinfo()['relayfee']\n+        num_big_transactions = 75\n+        # Generate coins to spend and wait for them to mature\n+        self.generate(filler_wallet, num_big_transactions)\n+        self.generate(filler_wallet, 100)\n+\n+        self.log.debug(\"Create a mempool tx that will be evicted\")\n+        tx_to_be_evicted_id = filler_wallet.send_self_transfer(from_node=self.nodes[1], fee_rate=relayfee)[\"txid\"]\n+\n+        # Increase the tx fee rate to give the subsequent transactions a higher priority in the mempool\n+        # The tx has an approx. vsize of 65k, i.e. multiplying the previous fee rate (in sats/kvB)\n+        # by 130 should result in a fee that corresponds to 2x of that fee rate\n+        base_fee = relayfee * 130\n+\n+        self.log.debug(\"Fill up the mempool with txs with higher fee rate\")\n+        txouts = gen_return_txouts()\n+        with self.nodes[0].assert_debug_log([\"rolling minimum fee bumped\"]):\n+            for batch_of_txid in range(num_big_transactions):\n+                fee = (batch_of_txid + 1) * base_fee\n+                create_lots_of_big_transactions(filler_wallet, self.nodes[0], fee, 1, txouts)\n+\n+        self.log.debug(\"Wait for the network to sync mempools\")\n+        self.sync_mempools()\n+        assert tx_to_be_evicted_id not in self.nodes[0].getrawmempool()\n+\n+        self.log.debug(\"Check that all nodes' mempool minimum feerate is above min relay feerate\")\n+        for node in self.nodes:\n+            assert_equal(node.getmempoolinfo()['minrelaytxfee'], FEERATE_1SAT_VB)\n+            assert_greater_than(node.getmempoolinfo()['mempoolminfee'], FEERATE_1SAT_VB)\n+\n+    def create_packages(self):\n+        # Basic 1-parent-1-child package\n+        # node0: sender\n+        # node1: pre-received the child (orphan)\n+        # node2: pre-received nothing\n+        # node3: pre-received the parent (too low fee)\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+        package_hex_basic = [low_fee_parent[\"hex\"], high_fee_child[\"hex\"]]\n+        self.packages_to_submit.append(package_hex_basic)\n+        # Child should already be in orphanage\n+        self.transactions_to_presend[1] = [high_fee_child[\"tx\"]]\n+        # Parent would have been previously rejected\n+        self.transactions_to_presend[3] = [low_fee_parent[\"tx\"]]\n+\n+    def test_individual_logic(self):\n+        node = self.nodes[0]\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        low_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=2*FEERATE_1SAT_VB)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+\n+        peer1 = node.add_p2p_connection(P2PInterface())\n+        peer2 = node.add_p2p_connection(P2PInterface())\n+\n+        self.log.info(\"Check that tx caches low feerate rejections\")\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer1.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer1.wait_for_getdata([parent_wtxid_int])\n+        peer1.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer2, check that it is ignored\n+        with node.assert_debug_log([f\"got inv: wtx {low_fee_parent['wtxid']}  have\"]):\n+            peer2.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer2.last_message\n+\n+        self.log.info(\"Check that the node doesn't try to validate a failed package again\")\n+        # Send the (orphan) child that has a higher feerate but not enough to bump the parent\n+        low_child_wtxid_int = int(low_fee_child[\"tx\"].getwtxid(), 16)\n+        peer1.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        peer1.wait_for_getdata([low_child_wtxid_int])\n+        peer1.send_and_ping(msg_tx(low_fee_child[\"tx\"]))\n+        # Node should request the orphan's missing parent. It has seen this parent before, but only\n+        # cached the failure by wtxid, not txid.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer1.wait_for_getdata([parent_txid_int])\n+        failed_expected_logs_1p1c = []\n+        failed_expected_logs_1p1c.append(f\"found tx {low_fee_parent['txid']} (wtxid={low_fee_parent['wtxid']}) in reconsiderable rejects, looking for child in orphanage\")\n+        failed_expected_logs_1p1c.append(f\"found child {low_fee_child['txid']} (wtxid={low_fee_child['wtxid']}) of tx {low_fee_parent['txid']} (wtxid={low_fee_parent['wtxid']}) in orphanage, trying package evaluation\")\n+        failed_expected_logs_1p1c.append(f\"removed orphan tx {low_fee_child['txid']} (wtxid={low_fee_child['wtxid']})\")\n+\n+        with node.assert_debug_log(failed_expected_logs_1p1c):\n+            peer1.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        # The transactions do not get accepted due to low feerate\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+        assert low_fee_child[\"txid\"] not in node.getrawmempool()\n+\n+        # If peer2 announces the low feerate child, it should be ignored\n+        with node.assert_debug_log([f\"got inv: wtx {low_fee_child['wtxid']}  have\"]):\n+            peer2.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        assert \"getdata\" not in peer2.last_message\n+        # If either peer sends the parent again, package evaluation should not be attempted\n+        with node.assert_debug_log([f\"didn't evaluate package for {low_fee_parent['txid']} (wtxid={low_fee_parent['wtxid']}), no eligible child found\"]):\n+            peer1.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        with node.assert_debug_log([f\"didn't evaluate package for {low_fee_parent['txid']} (wtxid={low_fee_parent['wtxid']}), no eligible child found\"]):\n+            peer2.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        self.log.info(\"Check that the node groups a low-feerate tx with its single child in orphanage\")\n+        # Send the high feerate (orphan) child\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer1.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer1.wait_for_getdata([high_child_wtxid_int])\n+        peer1.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+        # Node should request the orphan's parent, even though it has already been rejected, both by\n+        # itself and with a child. This is necessary, otherwise high_fee_child can be censored.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer1.wait_for_getdata([parent_txid_int])\n+        expected_logs_1p1c = []\n+        expected_logs_1p1c.append(f\"found tx {low_fee_parent['txid']} (wtxid={low_fee_parent['wtxid']}) in reconsiderable rejects, looking for child in orphanage\")\n+        expected_logs_1p1c.append(f\"found child {high_fee_child['txid']} (wtxid={high_fee_child['wtxid']}) of tx {low_fee_parent['txid']} (wtxid={low_fee_parent['wtxid']}) in orphanage, trying package evaluation\")\n+        with node.assert_debug_log(expected_logs_1p1c):\n+            peer1.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # Both transactions should now be in mempool\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+        peer1.peer_disconnect()\n+        peer2.peer_disconnect()\n+        self.sync_all()\n+\n+    def run_test(self):\n+        self.ctr = 0\n+        self.wallet = MiniWallet(self.nodes[1])\n+        self.generate(self.wallet, 120)\n+\n+        self.log.info(\"Fill mempools with large transactions to raise mempool minimum feerates\")\n+        self.raise_network_minfee()\n+\n+        self.log.info(\"Check 1p1c validation logic on a single node\")\n+        self.test_individual_logic()\n+\n+        self.log.info(\"Check end-to-end package relay across multiple nodes\")\n+        self.packages_to_submit = []\n+        self.transactions_to_presend = [[]] * self.num_nodes\n+\n+        self.log.info(\"Create transactions and then mature the coinbases\")\n+        self.wallet.rescan_utxos(include_mempool=True)\n+        self.create_packages()\n+\n+        self.peers = []\n+        for i in range(self.num_nodes):\n+            self.peers.append(self.nodes[i].add_outbound_p2p_connection(P2PInterface(), p2p_idx=i, connection_type=\"outbound-full-relay\"))\n+\n+        self.log.info(\"Pre-send some transactions to nodes\")\n+        for i in range(self.num_nodes):\n+            peer = self.peers[i]\n+            for tx in self.transactions_to_presend[i]:\n+                inv = CInv(t=MSG_WTX, h=int(tx.getwtxid(), 16))\n+                peer.send_and_ping(msg_inv([inv]))\n+                peer.wait_for_getdata([int(tx.getwtxid(), 16)])\n+                peer.send_and_ping(msg_tx(tx))\n+            # This disconnect removes any sent orphans from the orphanage (EraseForPeer) and times\n+            # out the in-flight requests.  It is currently required for the test to pass right now,\n+            # because the node will not (re)try requesting orphan parents from multiple peers if the\n+            # first one fails.\n+            # TODO: remove this and test that the node retries orphan resolution with other peers",
      "path": "test/functional/p2p_1p1c_package_relay.py",
      "position": null,
      "original_position": 206,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "2f25d2e0840e94bee1c6a8908d94baf076bf1567",
      "in_reply_to_id": 1526776259,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I guess not a lot. But it is worth checking that it having seen (and rejected) the child before shouldn't impact its acceptance of the package later?",
      "created_at": "2024-03-20T17:44:25Z",
      "updated_at": "2024-03-20T17:44:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1532538138",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1532538138"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 204,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1533624515",
      "pull_request_review_id": 1951714713,
      "id": 1533624515,
      "node_id": "PRRC_kwDOABII585baUDD",
      "diff_hunk": "@@ -0,0 +1,222 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test that package works successfully in a \"network\" of nodes. Send various packages from different\n+nodes on a network in which some nodes have already received some of the transactions (and submitted\n+them to mempool, kept them as orphans or rejected them as too-low-feerate transactions). The\n+packages should be received and accepted by all transactions on the network.\n+\"\"\"\n+\n+from decimal import Decimal\n+from test_framework.messages import (\n+    CInv,\n+    MSG_WTX,\n+    msg_inv,\n+    msg_tx,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    create_lots_of_big_transactions,\n+    gen_return_txouts,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 4\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+            \"-whitelist=noban@127.0.0.1\",  # immediate tx relay\n+        ]] * self.num_nodes\n+        self.supports_cli = False\n+\n+    def raise_network_minfee(self):\n+        filler_wallet = MiniWallet(self.nodes[0])\n+        relayfee = self.nodes[0].getnetworkinfo()['relayfee']\n+        num_big_transactions = 75\n+        # Generate coins to spend and wait for them to mature\n+        self.generate(filler_wallet, num_big_transactions)\n+        self.generate(filler_wallet, 100)\n+\n+        self.log.debug(\"Create a mempool tx that will be evicted\")\n+        tx_to_be_evicted_id = filler_wallet.send_self_transfer(from_node=self.nodes[1], fee_rate=relayfee)[\"txid\"]\n+\n+        # Increase the tx fee rate to give the subsequent transactions a higher priority in the mempool\n+        # The tx has an approx. vsize of 65k, i.e. multiplying the previous fee rate (in sats/kvB)\n+        # by 130 should result in a fee that corresponds to 2x of that fee rate\n+        base_fee = relayfee * 130\n+\n+        self.log.debug(\"Fill up the mempool with txs with higher fee rate\")\n+        txouts = gen_return_txouts()\n+        with self.nodes[0].assert_debug_log([\"rolling minimum fee bumped\"]):\n+            for batch_of_txid in range(num_big_transactions):\n+                fee = (batch_of_txid + 1) * base_fee\n+                create_lots_of_big_transactions(filler_wallet, self.nodes[0], fee, 1, txouts)\n+\n+        self.log.debug(\"Wait for the network to sync mempools\")\n+        self.sync_mempools()\n+        assert tx_to_be_evicted_id not in self.nodes[0].getrawmempool()\n+\n+        self.log.debug(\"Check that all nodes' mempool minimum feerate is above min relay feerate\")\n+        for node in self.nodes:\n+            assert_equal(node.getmempoolinfo()['minrelaytxfee'], FEERATE_1SAT_VB)\n+            assert_greater_than(node.getmempoolinfo()['mempoolminfee'], FEERATE_1SAT_VB)\n+\n+    def create_packages(self):\n+        # Basic 1-parent-1-child package\n+        # node0: sender\n+        # node1: pre-received the child (orphan)\n+        # node2: pre-received nothing\n+        # node3: pre-received the parent (too low fee)\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+        package_hex_basic = [low_fee_parent[\"hex\"], high_fee_child[\"hex\"]]\n+        self.packages_to_submit.append(package_hex_basic)\n+        # Child should already be in orphanage\n+        self.transactions_to_presend[1] = [high_fee_child[\"tx\"]]\n+        # Parent would have been previously rejected\n+        self.transactions_to_presend[3] = [low_fee_parent[\"tx\"]]\n+\n+    def test_individual_logic(self):\n+        node = self.nodes[0]\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        low_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=2*FEERATE_1SAT_VB)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+\n+        peer1 = node.add_p2p_connection(P2PInterface())\n+        peer2 = node.add_p2p_connection(P2PInterface())\n+\n+        self.log.info(\"Check that tx caches low feerate rejections\")\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer1.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer1.wait_for_getdata([parent_wtxid_int])\n+        peer1.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer2, check that it is ignored\n+        with node.assert_debug_log([f\"got inv: wtx {low_fee_parent['wtxid']}  have\"]):\n+            peer2.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer2.last_message\n+\n+        self.log.info(\"Check that the node doesn't try to validate a failed package again\")\n+        # Send the (orphan) child that has a higher feerate but not enough to bump the parent\n+        low_child_wtxid_int = int(low_fee_child[\"tx\"].getwtxid(), 16)\n+        peer1.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        peer1.wait_for_getdata([low_child_wtxid_int])\n+        peer1.send_and_ping(msg_tx(low_fee_child[\"tx\"]))\n+        # Node should request the orphan's missing parent. It has seen this parent before, but only\n+        # cached the failure by wtxid, not txid.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer1.wait_for_getdata([parent_txid_int])\n+        failed_expected_logs_1p1c = []\n+        failed_expected_logs_1p1c.append(f\"found tx {low_fee_parent['txid']} (wtxid={low_fee_parent['wtxid']}) in reconsiderable rejects, looking for child in orphanage\")\n+        failed_expected_logs_1p1c.append(f\"found child {low_fee_child['txid']} (wtxid={low_fee_child['wtxid']}) of tx {low_fee_parent['txid']} (wtxid={low_fee_parent['wtxid']}) in orphanage, trying package evaluation\")\n+        failed_expected_logs_1p1c.append(f\"removed orphan tx {low_fee_child['txid']} (wtxid={low_fee_child['wtxid']})\")\n+\n+        with node.assert_debug_log(failed_expected_logs_1p1c):\n+            peer1.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        # The transactions do not get accepted due to low feerate\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+        assert low_fee_child[\"txid\"] not in node.getrawmempool()\n+\n+        # If peer2 announces the low feerate child, it should be ignored\n+        with node.assert_debug_log([f\"got inv: wtx {low_fee_child['wtxid']}  have\"]):\n+            peer2.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        assert \"getdata\" not in peer2.last_message\n+        # If either peer sends the parent again, package evaluation should not be attempted\n+        with node.assert_debug_log([f\"didn't evaluate package for {low_fee_parent['txid']} (wtxid={low_fee_parent['wtxid']}), no eligible child found\"]):\n+            peer1.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        with node.assert_debug_log([f\"didn't evaluate package for {low_fee_parent['txid']} (wtxid={low_fee_parent['wtxid']}), no eligible child found\"]):\n+            peer2.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        self.log.info(\"Check that the node groups a low-feerate tx with its single child in orphanage\")\n+        # Send the high feerate (orphan) child\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer1.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer1.wait_for_getdata([high_child_wtxid_int])\n+        peer1.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+        # Node should request the orphan's parent, even though it has already been rejected, both by\n+        # itself and with a child. This is necessary, otherwise high_fee_child can be censored.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer1.wait_for_getdata([parent_txid_int])\n+        expected_logs_1p1c = []\n+        expected_logs_1p1c.append(f\"found tx {low_fee_parent['txid']} (wtxid={low_fee_parent['wtxid']}) in reconsiderable rejects, looking for child in orphanage\")\n+        expected_logs_1p1c.append(f\"found child {high_fee_child['txid']} (wtxid={high_fee_child['wtxid']}) of tx {low_fee_parent['txid']} (wtxid={low_fee_parent['wtxid']}) in orphanage, trying package evaluation\")\n+        with node.assert_debug_log(expected_logs_1p1c):\n+            peer1.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # Both transactions should now be in mempool\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+        peer1.peer_disconnect()\n+        peer2.peer_disconnect()\n+        self.sync_all()\n+\n+    def run_test(self):\n+        self.ctr = 0\n+        self.wallet = MiniWallet(self.nodes[1])\n+        self.generate(self.wallet, 120)\n+\n+        self.log.info(\"Fill mempools with large transactions to raise mempool minimum feerates\")\n+        self.raise_network_minfee()\n+\n+        self.log.info(\"Check 1p1c validation logic on a single node\")\n+        self.test_individual_logic()\n+\n+        self.log.info(\"Check end-to-end package relay across multiple nodes\")",
      "path": "test/functional/p2p_1p1c_package_relay.py",
      "position": null,
      "original_position": 182,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "2f25d2e0840e94bee1c6a8908d94baf076bf1567",
      "in_reply_to_id": 1526791671,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "done",
      "created_at": "2024-03-21T10:38:50Z",
      "updated_at": "2024-03-21T10:38:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1533624515",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1533624515"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 182,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1533631857",
      "pull_request_review_id": 1951731467,
      "id": 1533631857,
      "node_id": "PRRC_kwDOABII585baV1x",
      "diff_hunk": "@@ -3036,6 +3045,112 @@ void PeerManagerImpl::ProcessHeadersMessage(CNode& pfrom, Peer& peer,\n     return;\n }\n \n+PeerManagerImpl::InvalidTxTask PeerManagerImpl::ProcessInvalidTx(const CTransactionRef& tx, NodeId nodeid, const TxValidationState& state)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockNotHeld(m_peer_mutex);\n+    LogPrint(BCLog::MEMPOOLREJ, \"%s (wtxid=%s) from peer=%d was not accepted: %s\\n\",\n+             tx->GetHash().ToString(),\n+             tx->GetWitnessHash().ToString(),\n+             nodeid,\n+             state.ToString());\n+    // Maybe punish peer that gave us an tx\n+    MaybePunishNodeForTx(nodeid, state);\n+\n+    switch (state.GetResult()) {\n+    case TxValidationResult::TX_RESULT_UNSET:\n+    case TxValidationResult::TX_NO_MEMPOOL:\n+    {\n+        // This function should only be called when a transaction fails validation.\n+        Assume(false);\n+        return InvalidTxTask::NONE;\n+    }\n+    case TxValidationResult::TX_UNKNOWN:\n+    {\n+        // Transaction was not validated; we don't know that it is invalid. Do not add it to any\n+        // rejection caches or forget about it yet.\n+        return InvalidTxTask::NONE;\n+    }\n+    case TxValidationResult::TX_WITNESS_STRIPPED:\n+    {\n+        // Do not add txids of witness transactions or witness-stripped\n+        // transactions to the filter, as they can have been malleated;\n+        // adding such txids to the reject filter would potentially\n+        // interfere with relay of valid transactions from peers that\n+        // do not support wtxid-based relay. See\n+        // https://github.com/bitcoin/bitcoin/issues/8279 for details.",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 53,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "3eddfb2147754c734c325e4ee0158872448a0a61",
      "in_reply_to_id": 1514657717,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Resolving as out of scope for this PR. Also fwiw, btcd doing announcements by txid seems to be a reason to keep it for now...",
      "created_at": "2024-03-21T10:42:16Z",
      "updated_at": "2024-03-21T10:42:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1533631857",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1533631857"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3168,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1539621687",
      "pull_request_review_id": 1960994723,
      "id": 1539621687,
      "node_id": "PRRC_kwDOABII585bxMM3",
      "diff_hunk": "@@ -0,0 +1,232 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test that package works successfully in a \"network\" of nodes. Send various packages from different\n+nodes on a network in which some nodes have already received some of the transactions (and submitted\n+them to mempool, kept them as orphans or rejected them as too-low-feerate transactions). The\n+packages should be received and accepted by all transactions on the network.\n+\"\"\"\n+\n+from decimal import Decimal\n+from test_framework.messages import (\n+    CInv,\n+    MSG_WTX,\n+    msg_inv,\n+    msg_tx,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    create_lots_of_big_transactions,\n+    gen_return_txouts,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 4\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+            \"-whitelist=noban@127.0.0.1\",  # immediate tx relay\n+        ]] * self.num_nodes\n+        self.supports_cli = False\n+\n+    def raise_network_minfee(self):\n+        filler_wallet = MiniWallet(self.nodes[0])\n+        relayfee = self.nodes[0].getnetworkinfo()['relayfee']\n+        num_big_transactions = 75\n+        # Generate coins to spend and wait for them to mature\n+        self.generate(filler_wallet, num_big_transactions)\n+        self.generate(filler_wallet, 100)\n+\n+        self.log.debug(\"Create a mempool tx that will be evicted\")\n+        tx_to_be_evicted_id = filler_wallet.send_self_transfer(from_node=self.nodes[1], fee_rate=relayfee)[\"txid\"]\n+\n+        # Increase the tx fee rate to give the subsequent transactions a higher priority in the mempool\n+        # The tx has an approx. vsize of 65k, i.e. multiplying the previous fee rate (in sats/kvB)\n+        # by 130 should result in a fee that corresponds to 2x of that fee rate\n+        base_fee = relayfee * 130\n+\n+        self.log.debug(\"Fill up the mempool with txs with higher fee rate\")\n+        txouts = gen_return_txouts()\n+        with self.nodes[0].assert_debug_log([\"rolling minimum fee bumped\"]):\n+            for batch_of_txid in range(num_big_transactions):\n+                fee = (batch_of_txid + 1) * base_fee\n+                create_lots_of_big_transactions(filler_wallet, self.nodes[0], fee, 1, txouts)\n+\n+        self.log.debug(\"Wait for the network to sync mempools\")\n+        self.sync_mempools()\n+        assert tx_to_be_evicted_id not in self.nodes[0].getrawmempool()\n+\n+        self.log.debug(\"Check that all nodes' mempool minimum feerate is above min relay feerate\")\n+        for node in self.nodes:\n+            assert_equal(node.getmempoolinfo()['minrelaytxfee'], FEERATE_1SAT_VB)\n+            assert_greater_than(node.getmempoolinfo()['mempoolminfee'], FEERATE_1SAT_VB)\n+\n+    def create_packages(self):",
      "path": "test/functional/p2p_1p1c_package_relay.py",
      "position": null,
      "original_position": 80,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "5405171740aa77e1eb1110fa8be97318edba380a",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: I'd rather this return the packages then spookily populate them",
      "created_at": "2024-03-26T16:20:08Z",
      "updated_at": "2024-03-26T20:12:55Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1539621687",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1539621687"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 80,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1539811636",
      "pull_request_review_id": 1960994723,
      "id": 1539811636,
      "node_id": "PRRC_kwDOABII585bx6k0",
      "diff_hunk": "@@ -0,0 +1,222 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test that package works successfully in a \"network\" of nodes. Send various packages from different\n+nodes on a network in which some nodes have already received some of the transactions (and submitted\n+them to mempool, kept them as orphans or rejected them as too-low-feerate transactions). The\n+packages should be received and accepted by all transactions on the network.\n+\"\"\"\n+\n+from decimal import Decimal\n+from test_framework.messages import (\n+    CInv,\n+    MSG_WTX,\n+    msg_inv,\n+    msg_tx,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    create_lots_of_big_transactions,\n+    gen_return_txouts,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 4\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+            \"-whitelist=noban@127.0.0.1\",  # immediate tx relay\n+        ]] * self.num_nodes\n+        self.supports_cli = False\n+\n+    def raise_network_minfee(self):\n+        filler_wallet = MiniWallet(self.nodes[0])\n+        relayfee = self.nodes[0].getnetworkinfo()['relayfee']\n+        num_big_transactions = 75\n+        # Generate coins to spend and wait for them to mature\n+        self.generate(filler_wallet, num_big_transactions)\n+        self.generate(filler_wallet, 100)\n+\n+        self.log.debug(\"Create a mempool tx that will be evicted\")\n+        tx_to_be_evicted_id = filler_wallet.send_self_transfer(from_node=self.nodes[1], fee_rate=relayfee)[\"txid\"]\n+\n+        # Increase the tx fee rate to give the subsequent transactions a higher priority in the mempool\n+        # The tx has an approx. vsize of 65k, i.e. multiplying the previous fee rate (in sats/kvB)\n+        # by 130 should result in a fee that corresponds to 2x of that fee rate\n+        base_fee = relayfee * 130\n+\n+        self.log.debug(\"Fill up the mempool with txs with higher fee rate\")\n+        txouts = gen_return_txouts()\n+        with self.nodes[0].assert_debug_log([\"rolling minimum fee bumped\"]):\n+            for batch_of_txid in range(num_big_transactions):\n+                fee = (batch_of_txid + 1) * base_fee\n+                create_lots_of_big_transactions(filler_wallet, self.nodes[0], fee, 1, txouts)\n+\n+        self.log.debug(\"Wait for the network to sync mempools\")\n+        self.sync_mempools()\n+        assert tx_to_be_evicted_id not in self.nodes[0].getrawmempool()\n+\n+        self.log.debug(\"Check that all nodes' mempool minimum feerate is above min relay feerate\")\n+        for node in self.nodes:\n+            assert_equal(node.getmempoolinfo()['minrelaytxfee'], FEERATE_1SAT_VB)\n+            assert_greater_than(node.getmempoolinfo()['mempoolminfee'], FEERATE_1SAT_VB)\n+\n+    def create_packages(self):\n+        # Basic 1-parent-1-child package\n+        # node0: sender\n+        # node1: pre-received the child (orphan)\n+        # node2: pre-received nothing\n+        # node3: pre-received the parent (too low fee)\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+        package_hex_basic = [low_fee_parent[\"hex\"], high_fee_child[\"hex\"]]\n+        self.packages_to_submit.append(package_hex_basic)\n+        # Child should already be in orphanage\n+        self.transactions_to_presend[1] = [high_fee_child[\"tx\"]]\n+        # Parent would have been previously rejected\n+        self.transactions_to_presend[3] = [low_fee_parent[\"tx\"]]\n+\n+    def test_individual_logic(self):\n+        node = self.nodes[0]\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        low_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=2*FEERATE_1SAT_VB)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+\n+        peer1 = node.add_p2p_connection(P2PInterface())\n+        peer2 = node.add_p2p_connection(P2PInterface())\n+\n+        self.log.info(\"Check that tx caches low feerate rejections\")\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer1.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer1.wait_for_getdata([parent_wtxid_int])",
      "path": "test/functional/p2p_1p1c_package_relay.py",
      "position": null,
      "original_position": 106,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "2f25d2e0840e94bee1c6a8908d94baf076bf1567",
      "in_reply_to_id": 1526790462,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "can't seem to recreate anymore :shrug: ",
      "created_at": "2024-03-26T17:44:48Z",
      "updated_at": "2024-03-26T20:12:55Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1539811636",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1539811636"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 115,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1539990420",
      "pull_request_review_id": 1960994723,
      "id": 1539990420,
      "node_id": "PRRC_kwDOABII585bymOU",
      "diff_hunk": "@@ -241,3 +241,19 @@ void TxOrphanage::EraseForBlock(const CBlock& block)\n         LogPrint(BCLog::TXPACKAGES, \"Erased %d orphan tx included or conflicted by block\\n\", nErased);\n     }\n }\n+\n+std::vector<CTransactionRef> TxOrphanage::GetChildren(const CTransactionRef& parent, NodeId peer) const\n+{\n+    LOCK(m_mutex);\n+    std::vector<CTransactionRef> children_found;\n+\n+    for (unsigned int i = 0; i < parent->vout.size(); i++) {\n+        const auto it_by_prev = m_outpoint_to_orphan_it.find(COutPoint(parent->GetHash(), i));\n+        if (it_by_prev != m_outpoint_to_orphan_it.end()) {\n+            for (const auto& elem : it_by_prev->second) {",
      "path": "src/txorphanage.cpp",
      "position": 17,
      "original_position": 13,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "f4d8fe713a036c4d2c1e7c2329077c34f75c8608",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "to be clear we may have multiple orphans per outpoint lookup, yes?",
      "created_at": "2024-03-26T19:39:35Z",
      "updated_at": "2024-03-26T20:12:55Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1539990420",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1539990420"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 257,
      "original_line": 257,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1539991084",
      "pull_request_review_id": 1960994723,
      "id": 1539991084,
      "node_id": "PRRC_kwDOABII585bymYs",
      "diff_hunk": "@@ -51,6 +51,10 @@ class TxOrphanage {\n     /** Does this peer have any work to do? */\n     bool HaveTxToReconsider(NodeId peer) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex);;\n \n+    /** Get all children of this parent. */\n+    std::vector<CTransactionRef> GetChildren(const CTransactionRef& parent, NodeId peer) const",
      "path": "src/txorphanage.h",
      "position": null,
      "original_position": 5,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "f4d8fe713a036c4d2c1e7c2329077c34f75c8608",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "could stand a unit test and some basic fuzz coverage",
      "created_at": "2024-03-26T19:39:59Z",
      "updated_at": "2024-03-26T20:12:55Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1539991084",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1539991084"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 55,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1539998787",
      "pull_request_review_id": 1960994723,
      "id": 1539998787,
      "node_id": "PRRC_kwDOABII585byoRD",
      "diff_hunk": "@@ -3181,6 +3187,92 @@ void PeerManagerImpl::ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, c\n     }\n }\n \n+void PeerManagerImpl::ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, NodeId nodeid)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    if (package_result.m_state.IsInvalid()) {\n+        m_recent_rejects_reconsiderable.insert(GetPackageHash(package));\n+    }\n+\n+    // Iterate backwards to erase in-package descendants from the orphanage before they become\n+    // relevant in AddChildrenToWorkSet.\n+    for (auto package_it = package.rbegin(); package_it != package.rend(); ++package_it) {\n+        const auto& tx = *package_it;\n+        const auto it_result{package_result.m_tx_results.find(tx->GetWitnessHash())};\n+        if (it_result != package_result.m_tx_results.end()) {\n+            const auto& tx_result = it_result->second;\n+            switch (tx_result.m_result_type) {\n+                case MempoolAcceptResult::ResultType::VALID:\n+                {\n+                    Assume(tx_result.m_replaced_transactions.has_value());\n+                    std::list<CTransactionRef> empty_replacement_list;\n+                    ProcessValidTx(nodeid, tx, tx_result.m_replaced_transactions.value_or(empty_replacement_list));\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::INVALID:\n+                case MempoolAcceptResult::ResultType::DIFFERENT_WITNESS:\n+                {\n+                    // Don't add to vExtraTxnForCompact, as these transactions would already be\n+                    // there as an orphan or too low feerate tx.\n+                    ProcessInvalidTx(nodeid, tx, tx_result.m_state, /*maybe_add_extra_compact_tx=*/false);\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::MEMPOOL_ENTRY:",
      "path": "src/net_processing.cpp",
      "position": 204,
      "original_position": 50,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "47efa940c4180e1cdc778fdaae5f086ad4085791",
      "in_reply_to_id": 1526656636,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "slight readability preference, feel free to ignore",
      "created_at": "2024-03-26T19:44:12Z",
      "updated_at": "2024-03-26T20:12:55Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1539998787",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1539998787"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 3284,
      "original_line": 3284,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1539999774",
      "pull_request_review_id": 1960994723,
      "id": 1539999774,
      "node_id": "PRRC_kwDOABII585byoge",
      "diff_hunk": "@@ -4450,6 +4552,15 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         if (state.IsInvalid()) {\n             ProcessInvalidTx(pfrom.GetId(), ptx, state, /*maybe_add_extra_compact_tx=*/true);\n         }\n+        if (state.GetResult() == TxValidationResult::TX_RECONSIDERABLE) {",
      "path": "src/net_processing.cpp",
      "position": 365,
      "original_position": 127,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "47efa940c4180e1cdc778fdaae5f086ad4085791",
      "in_reply_to_id": 1525341442,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "with the added `Assume()` in `MaybeProcess1P1CPackage` I think it's ok now from this reader's standpoint, thanks",
      "created_at": "2024-03-26T19:44:53Z",
      "updated_at": "2024-03-26T20:12:55Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1539999774",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1539999774"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 4651,
      "original_line": 4651,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1540027738",
      "pull_request_review_id": 1960994723,
      "id": 1540027738,
      "node_id": "PRRC_kwDOABII585byvVa",
      "diff_hunk": "@@ -4420,7 +4532,10 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                     // protocol for getting all unconfirmed parents.\n                     const auto gtxid{GenTxid::Txid(parent_txid)};\n                     AddKnownTx(*peer, parent_txid);\n-                    if (!AlreadyHaveTx(gtxid, /*include_reconsiderable=*/true)) AddTxAnnouncement(pfrom, gtxid, current_time);\n+                    // Skip m_recent_rejects_reconsiderable because the missing parent may have been\n+                    // previously rejected for being too low feerate, and this orphan may be able to\n+                    // CPFP it if we consider them as a package.",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 158,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "774f6d0ff515802d16cc0cfeb9319c11e860d84d",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "this change also only matters for the non-segwit case since we're checking via txid, correct?",
      "created_at": "2024-03-26T20:05:51Z",
      "updated_at": "2024-03-26T20:12:55Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1540027738",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1540027738"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 4539,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1540031628",
      "pull_request_review_id": 1960994723,
      "id": 1540031628,
      "node_id": "PRRC_kwDOABII585bywSM",
      "diff_hunk": "@@ -4378,6 +4482,14 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             // peer simply for relaying a tx that our m_recent_rejects has caught,\n             // regardless of false positives.\n             return;\n+        } else if (m_recent_rejects_reconsiderable.contains(wtxid)) {",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 140,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "774f6d0ff515802d16cc0cfeb9319c11e860d84d",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "tiny preference for putting this case first",
      "created_at": "2024-03-26T20:09:02Z",
      "updated_at": "2024-03-26T20:12:55Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1540031628",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1540031628"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 4485,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1540306836",
      "pull_request_review_id": 1962043659,
      "id": 1540306836,
      "node_id": "PRRC_kwDOABII585bzzeU",
      "diff_hunk": "@@ -0,0 +1,222 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test that package works successfully in a \"network\" of nodes. Send various packages from different\n+nodes on a network in which some nodes have already received some of the transactions (and submitted\n+them to mempool, kept them as orphans or rejected them as too-low-feerate transactions). The\n+packages should be received and accepted by all transactions on the network.\n+\"\"\"\n+\n+from decimal import Decimal\n+from test_framework.messages import (\n+    CInv,\n+    MSG_WTX,\n+    msg_inv,\n+    msg_tx,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    create_lots_of_big_transactions,\n+    gen_return_txouts,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 4\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+            \"-whitelist=noban@127.0.0.1\",  # immediate tx relay\n+        ]] * self.num_nodes\n+        self.supports_cli = False\n+\n+    def raise_network_minfee(self):\n+        filler_wallet = MiniWallet(self.nodes[0])\n+        relayfee = self.nodes[0].getnetworkinfo()['relayfee']\n+        num_big_transactions = 75\n+        # Generate coins to spend and wait for them to mature\n+        self.generate(filler_wallet, num_big_transactions)\n+        self.generate(filler_wallet, 100)\n+\n+        self.log.debug(\"Create a mempool tx that will be evicted\")\n+        tx_to_be_evicted_id = filler_wallet.send_self_transfer(from_node=self.nodes[1], fee_rate=relayfee)[\"txid\"]\n+\n+        # Increase the tx fee rate to give the subsequent transactions a higher priority in the mempool\n+        # The tx has an approx. vsize of 65k, i.e. multiplying the previous fee rate (in sats/kvB)\n+        # by 130 should result in a fee that corresponds to 2x of that fee rate\n+        base_fee = relayfee * 130\n+\n+        self.log.debug(\"Fill up the mempool with txs with higher fee rate\")\n+        txouts = gen_return_txouts()\n+        with self.nodes[0].assert_debug_log([\"rolling minimum fee bumped\"]):\n+            for batch_of_txid in range(num_big_transactions):\n+                fee = (batch_of_txid + 1) * base_fee\n+                create_lots_of_big_transactions(filler_wallet, self.nodes[0], fee, 1, txouts)\n+\n+        self.log.debug(\"Wait for the network to sync mempools\")\n+        self.sync_mempools()\n+        assert tx_to_be_evicted_id not in self.nodes[0].getrawmempool()\n+\n+        self.log.debug(\"Check that all nodes' mempool minimum feerate is above min relay feerate\")\n+        for node in self.nodes:\n+            assert_equal(node.getmempoolinfo()['minrelaytxfee'], FEERATE_1SAT_VB)\n+            assert_greater_than(node.getmempoolinfo()['mempoolminfee'], FEERATE_1SAT_VB)\n+\n+    def create_packages(self):\n+        # Basic 1-parent-1-child package\n+        # node0: sender\n+        # node1: pre-received the child (orphan)\n+        # node2: pre-received nothing\n+        # node3: pre-received the parent (too low fee)\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+        package_hex_basic = [low_fee_parent[\"hex\"], high_fee_child[\"hex\"]]\n+        self.packages_to_submit.append(package_hex_basic)\n+        # Child should already be in orphanage\n+        self.transactions_to_presend[1] = [high_fee_child[\"tx\"]]\n+        # Parent would have been previously rejected\n+        self.transactions_to_presend[3] = [low_fee_parent[\"tx\"]]\n+\n+    def test_individual_logic(self):\n+        node = self.nodes[0]\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        low_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=2*FEERATE_1SAT_VB)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+\n+        peer1 = node.add_p2p_connection(P2PInterface())\n+        peer2 = node.add_p2p_connection(P2PInterface())\n+\n+        self.log.info(\"Check that tx caches low feerate rejections\")\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer1.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer1.wait_for_getdata([parent_wtxid_int])",
      "path": "test/functional/p2p_1p1c_package_relay.py",
      "position": null,
      "original_position": 106,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "2f25d2e0840e94bee1c6a8908d94baf076bf1567",
      "in_reply_to_id": 1526790462,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Seems I had beginner's luck, got the timeout on this line after a few runs on my machine. Here is the compressed dir of the failed test run: https://github.com/theStack/bitcoin/raw/pr28970_failed_testrun/pr28970_waitforgetdata_timeout.tar.gz\r\n\r\nApparently the node has seen the wtx in the inv already before (see node0/regtest/debug.log:11237) :eyes: . I guess this is could be caused by a different MiniWallet instance spending the same UTXO in an earlier sub-test, resulting in the same transaction?",
      "created_at": "2024-03-27T00:55:10Z",
      "updated_at": "2024-03-27T00:55:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1540306836",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1540306836"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 115,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1540843445",
      "pull_request_review_id": 1962910982,
      "id": 1540843445,
      "node_id": "PRRC_kwDOABII585b12e1",
      "diff_hunk": "@@ -4420,7 +4532,10 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                     // protocol for getting all unconfirmed parents.\n                     const auto gtxid{GenTxid::Txid(parent_txid)};\n                     AddKnownTx(*peer, parent_txid);\n-                    if (!AlreadyHaveTx(gtxid, /*include_reconsiderable=*/true)) AddTxAnnouncement(pfrom, gtxid, current_time);\n+                    // Skip m_recent_rejects_reconsiderable because the missing parent may have been\n+                    // previously rejected for being too low feerate, and this orphan may be able to\n+                    // CPFP it if we consider them as a package.",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 158,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "774f6d0ff515802d16cc0cfeb9319c11e860d84d",
      "in_reply_to_id": 1540027738,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Correct. If it's a witness tx, we would have cached the error by wtxid but the request is by txid, so this would miss it.",
      "created_at": "2024-03-27T10:32:25Z",
      "updated_at": "2024-03-27T10:32:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1540843445",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1540843445"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 4539,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1540857362",
      "pull_request_review_id": 1962931592,
      "id": 1540857362,
      "node_id": "PRRC_kwDOABII585b154S",
      "diff_hunk": "@@ -241,3 +241,19 @@ void TxOrphanage::EraseForBlock(const CBlock& block)\n         LogPrint(BCLog::TXPACKAGES, \"Erased %d orphan tx included or conflicted by block\\n\", nErased);\n     }\n }\n+\n+std::vector<CTransactionRef> TxOrphanage::GetChildren(const CTransactionRef& parent, NodeId peer) const\n+{\n+    LOCK(m_mutex);\n+    std::vector<CTransactionRef> children_found;\n+\n+    for (unsigned int i = 0; i < parent->vout.size(); i++) {\n+        const auto it_by_prev = m_outpoint_to_orphan_it.find(COutPoint(parent->GetHash(), i));\n+        if (it_by_prev != m_outpoint_to_orphan_it.end()) {\n+            for (const auto& elem : it_by_prev->second) {",
      "path": "src/txorphanage.cpp",
      "position": 17,
      "original_position": 13,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "f4d8fe713a036c4d2c1e7c2329077c34f75c8608",
      "in_reply_to_id": 1539990420,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Yep, we can have conflicting orphans. Should not break here if we find one.",
      "created_at": "2024-03-27T10:42:05Z",
      "updated_at": "2024-03-28T17:38:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1540857362",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1540857362"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 257,
      "original_line": 257,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1540869399",
      "pull_request_review_id": 1962931592,
      "id": 1540869399,
      "node_id": "PRRC_kwDOABII585b180X",
      "diff_hunk": "@@ -0,0 +1,222 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test that package works successfully in a \"network\" of nodes. Send various packages from different\n+nodes on a network in which some nodes have already received some of the transactions (and submitted\n+them to mempool, kept them as orphans or rejected them as too-low-feerate transactions). The\n+packages should be received and accepted by all transactions on the network.\n+\"\"\"\n+\n+from decimal import Decimal\n+from test_framework.messages import (\n+    CInv,\n+    MSG_WTX,\n+    msg_inv,\n+    msg_tx,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    create_lots_of_big_transactions,\n+    gen_return_txouts,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 4\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+            \"-whitelist=noban@127.0.0.1\",  # immediate tx relay\n+        ]] * self.num_nodes\n+        self.supports_cli = False\n+\n+    def raise_network_minfee(self):\n+        filler_wallet = MiniWallet(self.nodes[0])\n+        relayfee = self.nodes[0].getnetworkinfo()['relayfee']\n+        num_big_transactions = 75\n+        # Generate coins to spend and wait for them to mature\n+        self.generate(filler_wallet, num_big_transactions)\n+        self.generate(filler_wallet, 100)\n+\n+        self.log.debug(\"Create a mempool tx that will be evicted\")\n+        tx_to_be_evicted_id = filler_wallet.send_self_transfer(from_node=self.nodes[1], fee_rate=relayfee)[\"txid\"]\n+\n+        # Increase the tx fee rate to give the subsequent transactions a higher priority in the mempool\n+        # The tx has an approx. vsize of 65k, i.e. multiplying the previous fee rate (in sats/kvB)\n+        # by 130 should result in a fee that corresponds to 2x of that fee rate\n+        base_fee = relayfee * 130\n+\n+        self.log.debug(\"Fill up the mempool with txs with higher fee rate\")\n+        txouts = gen_return_txouts()\n+        with self.nodes[0].assert_debug_log([\"rolling minimum fee bumped\"]):\n+            for batch_of_txid in range(num_big_transactions):\n+                fee = (batch_of_txid + 1) * base_fee\n+                create_lots_of_big_transactions(filler_wallet, self.nodes[0], fee, 1, txouts)\n+\n+        self.log.debug(\"Wait for the network to sync mempools\")\n+        self.sync_mempools()\n+        assert tx_to_be_evicted_id not in self.nodes[0].getrawmempool()\n+\n+        self.log.debug(\"Check that all nodes' mempool minimum feerate is above min relay feerate\")\n+        for node in self.nodes:\n+            assert_equal(node.getmempoolinfo()['minrelaytxfee'], FEERATE_1SAT_VB)\n+            assert_greater_than(node.getmempoolinfo()['mempoolminfee'], FEERATE_1SAT_VB)\n+\n+    def create_packages(self):\n+        # Basic 1-parent-1-child package\n+        # node0: sender\n+        # node1: pre-received the child (orphan)\n+        # node2: pre-received nothing\n+        # node3: pre-received the parent (too low fee)\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+        package_hex_basic = [low_fee_parent[\"hex\"], high_fee_child[\"hex\"]]\n+        self.packages_to_submit.append(package_hex_basic)\n+        # Child should already be in orphanage\n+        self.transactions_to_presend[1] = [high_fee_child[\"tx\"]]\n+        # Parent would have been previously rejected\n+        self.transactions_to_presend[3] = [low_fee_parent[\"tx\"]]\n+\n+    def test_individual_logic(self):\n+        node = self.nodes[0]\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        low_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=2*FEERATE_1SAT_VB)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+\n+        peer1 = node.add_p2p_connection(P2PInterface())\n+        peer2 = node.add_p2p_connection(P2PInterface())\n+\n+        self.log.info(\"Check that tx caches low feerate rejections\")\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer1.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer1.wait_for_getdata([parent_wtxid_int])",
      "path": "test/functional/p2p_1p1c_package_relay.py",
      "position": null,
      "original_position": 106,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "2f25d2e0840e94bee1c6a8908d94baf076bf1567",
      "in_reply_to_id": 1526790462,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Nice @theStack :D I was having trouble recreating it, duplicate tx sounds most plausible to me.\r\n\r\nI split the 4 node test and 1 node test into separate files (grabbed commit from #29735 to reuse setup) which hopefully gets rid of this.",
      "created_at": "2024-03-27T10:47:11Z",
      "updated_at": "2024-03-28T17:38:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1540869399",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1540869399"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 115,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1541080914",
      "pull_request_review_id": 1963281981,
      "id": 1541080914,
      "node_id": "PRRC_kwDOABII585b2wdS",
      "diff_hunk": "@@ -806,7 +806,7 @@ class PeerManagerImpl final : public PeerManager\n     /** Stalling timeout for blocks in IBD */\n     std::atomic<std::chrono::seconds> m_block_stalling_timeout{BLOCK_STALLING_TIMEOUT_DEFAULT};\n \n-    bool AlreadyHaveTx(const GenTxid& gtxid)\n+    bool AlreadyHaveTx(const GenTxid& gtxid, bool include_reconsiderable)",
      "path": "src/net_processing.cpp",
      "position": 69,
      "original_position": 5,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "1435bfac51ae431b91c38c4db0b92ce9b7353125",
      "in_reply_to_id": 1523821142,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "can confirm, changes seem logical, and there's test coverage for each `AlreadyHaveTx` instance",
      "created_at": "2024-03-27T13:11:13Z",
      "updated_at": "2024-03-27T13:11:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1541080914",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1541080914"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 857,
      "original_line": 857,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1542964936",
      "pull_request_review_id": 1966207399,
      "id": 1542964936,
      "node_id": "PRRC_kwDOABII585b98bI",
      "diff_hunk": "@@ -241,3 +241,19 @@ void TxOrphanage::EraseForBlock(const CBlock& block)\n         LogPrint(BCLog::TXPACKAGES, \"Erased %d orphan tx included or conflicted by block\\n\", nErased);\n     }\n }\n+\n+std::vector<CTransactionRef> TxOrphanage::GetChildren(const CTransactionRef& parent, NodeId peer) const",
      "path": "src/txorphanage.cpp",
      "position": null,
      "original_position": 5,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "f4d8fe713a036c4d2c1e7c2329077c34f75c8608",
      "in_reply_to_id": null,
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In f4d8fe713a036c4d2c1e7c2329077c34f75c8608: It seems `NodeId peer` is not used in `GetChildren`.",
      "created_at": "2024-03-28T13:19:39Z",
      "updated_at": "2024-03-28T13:19:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1542964936",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1542964936"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 245,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1542971452",
      "pull_request_review_id": 1966215922,
      "id": 1542971452,
      "node_id": "PRRC_kwDOABII585b9-A8",
      "diff_hunk": "@@ -0,0 +1,232 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test that package works successfully in a \"network\" of nodes. Send various packages from different\n+nodes on a network in which some nodes have already received some of the transactions (and submitted\n+them to mempool, kept them as orphans or rejected them as too-low-feerate transactions). The\n+packages should be received and accepted by all transactions on the network.\n+\"\"\"\n+\n+from decimal import Decimal\n+from test_framework.messages import (\n+    CInv,\n+    MSG_WTX,\n+    msg_inv,\n+    msg_tx,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    create_lots_of_big_transactions,\n+    gen_return_txouts,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 4\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+            \"-whitelist=noban@127.0.0.1\",  # immediate tx relay",
      "path": "test/functional/p2p_1p1c_package_relay.py",
      "position": null,
      "original_position": 44,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "5405171740aa77e1eb1110fa8be97318edba380a",
      "in_reply_to_id": null,
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In 5405171740aa77e1eb1110fa8be97318edba380a: nit: could set `noban_tx_relay`",
      "created_at": "2024-03-28T13:23:17Z",
      "updated_at": "2024-03-28T13:23:18Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1542971452",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1542971452"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 44,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1543239954",
      "pull_request_review_id": 1962931592,
      "id": 1543239954,
      "node_id": "PRRC_kwDOABII585b-_kS",
      "diff_hunk": "@@ -4378,6 +4482,14 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             // peer simply for relaying a tx that our m_recent_rejects has caught,\n             // regardless of false positives.\n             return;\n+        } else if (m_recent_rejects_reconsiderable.contains(wtxid)) {",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 140,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "774f6d0ff515802d16cc0cfeb9319c11e860d84d",
      "in_reply_to_id": 1540031628,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Ok. I've actually ended up nesting it inside the `AlreadyHave` to preserve the ForceRelay behavior... wanted to avoid a behavior change in the case\r\n1. tx is low feerate (goes into `m_recent_rejects_reconsiderable`)\r\n2. tx is later accepted (e.g. due to 1p1c)\r\n3. forcrelay peer sends it to us again -> we should `RelayTransaction`",
      "created_at": "2024-03-28T16:10:10Z",
      "updated_at": "2024-03-28T17:38:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1543239954",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1543239954"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 4485,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1543279142",
      "pull_request_review_id": 1962931592,
      "id": 1543279142,
      "node_id": "PRRC_kwDOABII585b_JIm",
      "diff_hunk": "@@ -241,3 +241,19 @@ void TxOrphanage::EraseForBlock(const CBlock& block)\n         LogPrint(BCLog::TXPACKAGES, \"Erased %d orphan tx included or conflicted by block\\n\", nErased);\n     }\n }\n+\n+std::vector<CTransactionRef> TxOrphanage::GetChildren(const CTransactionRef& parent, NodeId peer) const",
      "path": "src/txorphanage.cpp",
      "position": null,
      "original_position": 5,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "f4d8fe713a036c4d2c1e7c2329077c34f75c8608",
      "in_reply_to_id": 1542964936,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "removed",
      "created_at": "2024-03-28T16:33:51Z",
      "updated_at": "2024-03-28T17:38:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1543279142",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1543279142"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 245,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1543350220",
      "pull_request_review_id": 1962931592,
      "id": 1543350220,
      "node_id": "PRRC_kwDOABII585b_afM",
      "diff_hunk": "@@ -0,0 +1,232 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test that package works successfully in a \"network\" of nodes. Send various packages from different\n+nodes on a network in which some nodes have already received some of the transactions (and submitted\n+them to mempool, kept them as orphans or rejected them as too-low-feerate transactions). The\n+packages should be received and accepted by all transactions on the network.\n+\"\"\"\n+\n+from decimal import Decimal\n+from test_framework.messages import (\n+    CInv,\n+    MSG_WTX,\n+    msg_inv,\n+    msg_tx,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    create_lots_of_big_transactions,\n+    gen_return_txouts,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 4\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+            \"-whitelist=noban@127.0.0.1\",  # immediate tx relay",
      "path": "test/functional/p2p_1p1c_package_relay.py",
      "position": null,
      "original_position": 44,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "5405171740aa77e1eb1110fa8be97318edba380a",
      "in_reply_to_id": 1542971452,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "done",
      "created_at": "2024-03-28T17:18:51Z",
      "updated_at": "2024-03-28T17:38:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1543350220",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1543350220"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 44,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1543357734",
      "pull_request_review_id": 1962931592,
      "id": 1543357734,
      "node_id": "PRRC_kwDOABII585b_cUm",
      "diff_hunk": "@@ -0,0 +1,232 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test that package works successfully in a \"network\" of nodes. Send various packages from different\n+nodes on a network in which some nodes have already received some of the transactions (and submitted\n+them to mempool, kept them as orphans or rejected them as too-low-feerate transactions). The\n+packages should be received and accepted by all transactions on the network.\n+\"\"\"\n+\n+from decimal import Decimal\n+from test_framework.messages import (\n+    CInv,\n+    MSG_WTX,\n+    msg_inv,\n+    msg_tx,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    create_lots_of_big_transactions,\n+    gen_return_txouts,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 4\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+            \"-whitelist=noban@127.0.0.1\",  # immediate tx relay\n+        ]] * self.num_nodes\n+        self.supports_cli = False\n+\n+    def raise_network_minfee(self):\n+        filler_wallet = MiniWallet(self.nodes[0])\n+        relayfee = self.nodes[0].getnetworkinfo()['relayfee']\n+        num_big_transactions = 75\n+        # Generate coins to spend and wait for them to mature\n+        self.generate(filler_wallet, num_big_transactions)\n+        self.generate(filler_wallet, 100)\n+\n+        self.log.debug(\"Create a mempool tx that will be evicted\")\n+        tx_to_be_evicted_id = filler_wallet.send_self_transfer(from_node=self.nodes[1], fee_rate=relayfee)[\"txid\"]\n+\n+        # Increase the tx fee rate to give the subsequent transactions a higher priority in the mempool\n+        # The tx has an approx. vsize of 65k, i.e. multiplying the previous fee rate (in sats/kvB)\n+        # by 130 should result in a fee that corresponds to 2x of that fee rate\n+        base_fee = relayfee * 130\n+\n+        self.log.debug(\"Fill up the mempool with txs with higher fee rate\")\n+        txouts = gen_return_txouts()\n+        with self.nodes[0].assert_debug_log([\"rolling minimum fee bumped\"]):\n+            for batch_of_txid in range(num_big_transactions):\n+                fee = (batch_of_txid + 1) * base_fee\n+                create_lots_of_big_transactions(filler_wallet, self.nodes[0], fee, 1, txouts)\n+\n+        self.log.debug(\"Wait for the network to sync mempools\")\n+        self.sync_mempools()\n+        assert tx_to_be_evicted_id not in self.nodes[0].getrawmempool()\n+\n+        self.log.debug(\"Check that all nodes' mempool minimum feerate is above min relay feerate\")\n+        for node in self.nodes:\n+            assert_equal(node.getmempoolinfo()['minrelaytxfee'], FEERATE_1SAT_VB)\n+            assert_greater_than(node.getmempoolinfo()['mempoolminfee'], FEERATE_1SAT_VB)\n+\n+    def create_packages(self):",
      "path": "test/functional/p2p_1p1c_package_relay.py",
      "position": null,
      "original_position": 80,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "5405171740aa77e1eb1110fa8be97318edba380a",
      "in_reply_to_id": 1539621687,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "not sure if I achieved spooky, but I'm having it return the lists now :ghost: ",
      "created_at": "2024-03-28T17:23:11Z",
      "updated_at": "2024-03-28T17:38:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1543357734",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1543357734"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 80,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1543376895",
      "pull_request_review_id": 1962931592,
      "id": 1543376895,
      "node_id": "PRRC_kwDOABII585b_g__",
      "diff_hunk": "@@ -51,6 +51,10 @@ class TxOrphanage {\n     /** Does this peer have any work to do? */\n     bool HaveTxToReconsider(NodeId peer) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex);;\n \n+    /** Get all children of this parent. */\n+    std::vector<CTransactionRef> GetChildren(const CTransactionRef& parent, NodeId peer) const",
      "path": "src/txorphanage.h",
      "position": null,
      "original_position": 5,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "f4d8fe713a036c4d2c1e7c2329077c34f75c8608",
      "in_reply_to_id": 1539991084,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "added unit tests and fuzz coverage",
      "created_at": "2024-03-28T17:38:11Z",
      "updated_at": "2024-03-28T17:38:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1543376895",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1543376895"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 55,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1545475564",
      "pull_request_review_id": 1970039534,
      "id": 1545475564,
      "node_id": "PRRC_kwDOABII585cHhXs",
      "diff_hunk": "@@ -0,0 +1,215 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test opportunistic 1p1c package submission logic.\n+\"\"\"\n+\n+from decimal import Decimal\n+from test_framework.messages import (\n+    CInv,\n+    MSG_WTX,\n+    msg_inv,\n+    msg_tx,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    fill_mempool,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+        self.noban_tx_relay = True\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+        ]]\n+        self.supports_cli = False\n+\n+    def raise_network_minfee(self):",
      "path": "test/functional/p2p_opportunistic_1p1c.py",
      "position": null,
      "original_position": 44,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "5d7fa1f68402c0af08f58ac30522ce9511d218c3",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: `raise_network_minfee` is unused in this file, can be removed",
      "created_at": "2024-03-30T18:37:18Z",
      "updated_at": "2024-03-30T18:52:08Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1545475564",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1545475564"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 44,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1545476664",
      "pull_request_review_id": 1970039534,
      "id": 1545476664,
      "node_id": "PRRC_kwDOABII585cHho4",
      "diff_hunk": "@@ -0,0 +1,215 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test opportunistic 1p1c package submission logic.\n+\"\"\"\n+\n+from decimal import Decimal\n+from test_framework.messages import (\n+    CInv,\n+    MSG_WTX,\n+    msg_inv,\n+    msg_tx,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    fill_mempool,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+        self.noban_tx_relay = True\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+        ]]\n+        self.supports_cli = False\n+\n+    def raise_network_minfee(self):\n+\n+        self.log.debug(\"Wait for the network to sync mempools\")\n+        self.sync_mempools()\n+\n+        self.log.debug(\"Check that all nodes' mempool minimum feerates are above min relay feerate\")\n+        for node in self.nodes:\n+            assert_equal(node.getmempoolinfo()['minrelaytxfee'], FEERATE_1SAT_VB)\n+            assert_greater_than(node.getmempoolinfo()['mempoolminfee'], FEERATE_1SAT_VB)\n+\n+    def test_basic_child_then_parent(self):\n+        node = self.nodes[0]\n+        self.log.info(\"Check that opportunistic 1p1c logic works when child is received before parent\")\n+\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=1, connection_type=\"outbound-full-relay\")",
      "path": "test/functional/p2p_opportunistic_1p1c.py",
      "position": null,
      "original_position": 61,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "5d7fa1f68402c0af08f58ac30522ce9511d218c3",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: could create the peers as inbound connections instead, here and in other instances:\r\n\r\n```suggestion\r\n        peer_sender = node.add_p2p_connection(P2PInterface())\r\n```\r\n\r\n(it doesn't really matter though, the code would just be a bit shorter)",
      "created_at": "2024-03-30T18:42:24Z",
      "updated_at": "2024-03-30T18:52:08Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1545476664",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1545476664"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 61,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1545477172",
      "pull_request_review_id": 1970039534,
      "id": 1545477172,
      "node_id": "PRRC_kwDOABII585cHhw0",
      "diff_hunk": "@@ -138,4 +162,49 @@ BOOST_AUTO_TEST_CASE(DoS_mapOrphans)\n     BOOST_CHECK(orphanage.CountOrphans() == 0);\n }\n \n+BOOST_AUTO_TEST_CASE(get_children)\n+{\n+    FastRandomContext det_rand{true};\n+    TxOrphanage orphanage;\n+    const NodeId node{0};\n+    std::vector<COutPoint> empty_outpoints;\n+\n+    auto parent1 = MakeTransactionSpending(empty_outpoints, det_rand);\n+    auto parent2 = MakeTransactionSpending(empty_outpoints, det_rand);\n+    auto parent3 = MakeTransactionSpending(empty_outpoints, det_rand);",
      "path": "src/test/orphanage_tests.cpp",
      "position": null,
      "original_position": 54,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "3842f9a8842397ec15b5e3c5ae25935e9a8ee67c",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: parent3 is unused, can remove this line and the two comparisons below",
      "created_at": "2024-03-30T18:45:09Z",
      "updated_at": "2024-03-30T18:52:08Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1545477172",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1545477172"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 174,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1545477551",
      "pull_request_review_id": 1970039534,
      "id": 1545477551,
      "node_id": "PRRC_kwDOABII585cHh2v",
      "diff_hunk": "@@ -2228,7 +2241,7 @@ bool PeerManagerImpl::AlreadyHaveTx(const GenTxid& gtxid, bool include_reconside\n \n     if (m_orphanage.HaveTx(gtxid)) return true;\n \n-    if (include_reconsiderable && m_recent_rejects_reconsiderable.contains(gtxid.GetHash())) return true;\n+    if (include_reconsiderable && m_recent_rejects_reconsiderable.contains(hash)) return true;",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 25,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "97e16c20ca344b49652a2bce558c5404e7ab22dd",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: could use `hash` directly in the previous commit where this line is introduced (edea2269416ad2bcd017e1d6ee9ae30bd225c1e9), for smaller diff",
      "created_at": "2024-03-30T18:48:17Z",
      "updated_at": "2024-03-30T18:52:08Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1545477551",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1545477551"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": 2231,
      "start_side": "LEFT",
      "line": null,
      "original_line": 2285,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1547822651",
      "pull_request_review_id": 1973715466,
      "id": 1547822651,
      "node_id": "PRRC_kwDOABII585cQeY7",
      "diff_hunk": "@@ -138,4 +162,49 @@ BOOST_AUTO_TEST_CASE(DoS_mapOrphans)\n     BOOST_CHECK(orphanage.CountOrphans() == 0);\n }\n \n+BOOST_AUTO_TEST_CASE(get_children)\n+{\n+    FastRandomContext det_rand{true};\n+    TxOrphanage orphanage;\n+    const NodeId node{0};\n+    std::vector<COutPoint> empty_outpoints;\n+\n+    auto parent1 = MakeTransactionSpending(empty_outpoints, det_rand);\n+    auto parent2 = MakeTransactionSpending(empty_outpoints, det_rand);\n+    auto parent3 = MakeTransactionSpending(empty_outpoints, det_rand);",
      "path": "src/test/orphanage_tests.cpp",
      "position": null,
      "original_position": 54,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "3842f9a8842397ec15b5e3c5ae25935e9a8ee67c",
      "in_reply_to_id": 1545477172,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "fixed",
      "created_at": "2024-04-02T12:52:31Z",
      "updated_at": "2024-04-02T13:45:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1547822651",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1547822651"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 174,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1547823286",
      "pull_request_review_id": 1973715466,
      "id": 1547823286,
      "node_id": "PRRC_kwDOABII585cQei2",
      "diff_hunk": "@@ -0,0 +1,215 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test opportunistic 1p1c package submission logic.\n+\"\"\"\n+\n+from decimal import Decimal\n+from test_framework.messages import (\n+    CInv,\n+    MSG_WTX,\n+    msg_inv,\n+    msg_tx,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    fill_mempool,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+        self.noban_tx_relay = True\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+        ]]\n+        self.supports_cli = False\n+\n+    def raise_network_minfee(self):",
      "path": "test/functional/p2p_opportunistic_1p1c.py",
      "position": null,
      "original_position": 44,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "5d7fa1f68402c0af08f58ac30522ce9511d218c3",
      "in_reply_to_id": 1545475564,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "removed, thanks",
      "created_at": "2024-04-02T12:53:00Z",
      "updated_at": "2024-04-02T13:45:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1547823286",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1547823286"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 44,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1547829705",
      "pull_request_review_id": 1973715466,
      "id": 1547829705,
      "node_id": "PRRC_kwDOABII585cQgHJ",
      "diff_hunk": "@@ -0,0 +1,215 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test opportunistic 1p1c package submission logic.\n+\"\"\"\n+\n+from decimal import Decimal\n+from test_framework.messages import (\n+    CInv,\n+    MSG_WTX,\n+    msg_inv,\n+    msg_tx,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    fill_mempool,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+        self.noban_tx_relay = True\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+        ]]\n+        self.supports_cli = False\n+\n+    def raise_network_minfee(self):\n+\n+        self.log.debug(\"Wait for the network to sync mempools\")\n+        self.sync_mempools()\n+\n+        self.log.debug(\"Check that all nodes' mempool minimum feerates are above min relay feerate\")\n+        for node in self.nodes:\n+            assert_equal(node.getmempoolinfo()['minrelaytxfee'], FEERATE_1SAT_VB)\n+            assert_greater_than(node.getmempoolinfo()['mempoolminfee'], FEERATE_1SAT_VB)\n+\n+    def test_basic_child_then_parent(self):\n+        node = self.nodes[0]\n+        self.log.info(\"Check that opportunistic 1p1c logic works when child is received before parent\")\n+\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=1, connection_type=\"outbound-full-relay\")",
      "path": "test/functional/p2p_opportunistic_1p1c.py",
      "position": null,
      "original_position": 61,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "5d7fa1f68402c0af08f58ac30522ce9511d218c3",
      "in_reply_to_id": 1545476664,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Changed thanks. Before I added noban, I was using it to make tests run faster.",
      "created_at": "2024-04-02T12:57:17Z",
      "updated_at": "2024-04-02T13:45:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1547829705",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1547829705"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 61,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1549143563",
      "pull_request_review_id": 1975876919,
      "id": 1549143563,
      "node_id": "PRRC_kwDOABII585cVg4L",
      "diff_hunk": "@@ -2228,7 +2241,7 @@ bool PeerManagerImpl::AlreadyHaveTx(const GenTxid& gtxid, bool include_reconside\n \n     if (m_orphanage.HaveTx(gtxid)) return true;\n \n-    if (include_reconsiderable && m_recent_rejects_reconsiderable.contains(gtxid.GetHash())) return true;\n+    if (include_reconsiderable && m_recent_rejects_reconsiderable.contains(hash)) return true;",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 25,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "97e16c20ca344b49652a2bce558c5404e7ab22dd",
      "in_reply_to_id": 1545477551,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "done",
      "created_at": "2024-04-03T08:01:00Z",
      "updated_at": "2024-04-03T08:01:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1549143563",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1549143563"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": 2231,
      "start_side": "LEFT",
      "line": null,
      "original_line": 2285,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1549376386",
      "pull_request_review_id": 1976216428,
      "id": 1549376386,
      "node_id": "PRRC_kwDOABII585cWZuC",
      "diff_hunk": "@@ -241,3 +241,28 @@ void TxOrphanage::EraseForBlock(const CBlock& block)\n         LogPrint(BCLog::TXPACKAGES, \"Erased %d orphan tx included or conflicted by block\\n\", nErased);\n     }\n }\n+\n+std::vector<CTransactionRef> TxOrphanage::GetChildren(const CTransactionRef& parent) const\n+{\n+    LOCK(m_mutex);\n+\n+    // First construct a set of iterators to ensure we do not return duplicates of the same tx.\n+    std::set<OrphanMap::iterator, IteratorComparator> set_child_iterators;\n+\n+    // For each input, get all entries spending this prevout.",
      "path": "src/txorphanage.cpp",
      "position": null,
      "original_position": 12,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "d3d7dcf00439655a921f3be4624d01814de2e346",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```Suggestion\r\n    // For each output, get all entries spending this prevout.\r\n```",
      "created_at": "2024-04-03T09:47:55Z",
      "updated_at": "2024-04-04T09:55:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1549376386",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1549376386"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 252,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1549395161",
      "pull_request_review_id": 1976216428,
      "id": 1549395161,
      "node_id": "PRRC_kwDOABII585cWeTZ",
      "diff_hunk": "@@ -138,4 +162,46 @@ BOOST_AUTO_TEST_CASE(DoS_mapOrphans)\n     BOOST_CHECK(orphanage.CountOrphans() == 0);\n }\n \n+BOOST_AUTO_TEST_CASE(get_children)\n+{\n+    FastRandomContext det_rand{true};\n+    TxOrphanage orphanage;\n+    const NodeId node{0};\n+    std::vector<COutPoint> empty_outpoints;\n+\n+    auto parent1 = MakeTransactionSpending(empty_outpoints, det_rand);\n+    auto parent2 = MakeTransactionSpending(empty_outpoints, det_rand);\n+\n+    // Make sure these parents have different txids otherwise this test won't make sense.\n+    BOOST_CHECK(parent1->GetHash() != parent2->GetHash());",
      "path": "src/test/orphanage_tests.cpp",
      "position": null,
      "original_position": 56,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "b49b634556388ff5ec3c48fd05d628f77f6126a0",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "probably better to have it while loop making tx until this is true, rather than fail randomly",
      "created_at": "2024-04-03T09:59:21Z",
      "updated_at": "2024-04-04T09:55:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1549395161",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1549395161"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 176,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1549404732",
      "pull_request_review_id": 1976216428,
      "id": 1549404732,
      "node_id": "PRRC_kwDOABII585cWgo8",
      "diff_hunk": "@@ -138,4 +162,46 @@ BOOST_AUTO_TEST_CASE(DoS_mapOrphans)\n     BOOST_CHECK(orphanage.CountOrphans() == 0);\n }\n \n+BOOST_AUTO_TEST_CASE(get_children)\n+{\n+    FastRandomContext det_rand{true};\n+    TxOrphanage orphanage;\n+    const NodeId node{0};\n+    std::vector<COutPoint> empty_outpoints;\n+\n+    auto parent1 = MakeTransactionSpending(empty_outpoints, det_rand);\n+    auto parent2 = MakeTransactionSpending(empty_outpoints, det_rand);\n+\n+    // Make sure these parents have different txids otherwise this test won't make sense.\n+    BOOST_CHECK(parent1->GetHash() != parent2->GetHash());\n+\n+    // Create children to go into orphanage.\n+    auto child_p1n0 = MakeTransactionSpending({{parent1->GetHash(), 0}}, det_rand);\n+    auto child_p2n1 = MakeTransactionSpending({{parent2->GetHash(), 1}}, det_rand);\n+    // Spends the same tx twice. Should not cause duplicates in GetChildren.\n+    auto child_p1n0_p1n1 = MakeTransactionSpending({{parent1->GetHash(), 0}, {parent1->GetHash(), 1}}, det_rand);\n+    // Spends the same outpoint as previous tx. Should still be returned; don't assume outpoints are unique.\n+    auto child_p1n0_p2n0 = MakeTransactionSpending({{parent1->GetHash(), 0}, {parent2->GetHash(), 0}}, det_rand);\n+\n+    BOOST_CHECK(orphanage.AddTx(child_p1n0, node));\n+    BOOST_CHECK(orphanage.AddTx(child_p2n1, node));\n+    BOOST_CHECK(orphanage.AddTx(child_p1n0_p1n1, node));\n+    BOOST_CHECK(orphanage.AddTx(child_p1n0_p2n0, node));\n+\n+    // Check that GetChildren returns what is expected.\n+    std::set<Wtxid> expected_parent1_children{child_p1n0->GetWitnessHash(), child_p1n0_p2n0->GetWitnessHash(), child_p1n0_p1n1->GetWitnessHash()};\n+    std::set<Wtxid> expected_parent2_children{child_p2n1->GetWitnessHash(), child_p1n0_p2n0->GetWitnessHash()};\n+\n+    auto parent1_children{orphanage.GetChildren(parent1)};\n+    BOOST_CHECK_EQUAL(parent1_children.size(), expected_parent1_children.size());\n+    for (const auto& child : parent1_children) {\n+        BOOST_CHECK(expected_parent1_children.count(child->GetWitnessHash()) > 0);\n+    }\n+    auto parent2_children{orphanage.GetChildren(parent2)};\n+    BOOST_CHECK_EQUAL(parent2_children.size(), expected_parent2_children.size());\n+    for (const auto& child : parent2_children) {\n+        BOOST_CHECK(expected_parent2_children.count(child->GetWitnessHash()) > 0);\n+    }",
      "path": "src/test/orphanage_tests.cpp",
      "position": 113,
      "original_position": 84,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "b49b634556388ff5ec3c48fd05d628f77f6126a0",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "quick test case that returns empty would be good too",
      "created_at": "2024-04-03T10:04:55Z",
      "updated_at": "2024-04-04T09:55:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1549404732",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1549404732"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 233,
      "original_line": 233,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1549414682",
      "pull_request_review_id": 1976216428,
      "id": 1549414682,
      "node_id": "PRRC_kwDOABII585cWjEa",
      "diff_hunk": "@@ -806,7 +806,7 @@ class PeerManagerImpl final : public PeerManager\n     /** Stalling timeout for blocks in IBD */\n     std::atomic<std::chrono::seconds> m_block_stalling_timeout{BLOCK_STALLING_TIMEOUT_DEFAULT};\n \n-    bool AlreadyHaveTx(const GenTxid& gtxid)\n+    bool AlreadyHaveTx(const GenTxid& gtxid, bool include_reconsiderable)",
      "path": "src/net_processing.cpp",
      "position": 69,
      "original_position": 5,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "826b31b5a3bef4adb3d1d9145d1452b8e91fda46",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Good time to add documentation to this function",
      "created_at": "2024-04-03T10:12:47Z",
      "updated_at": "2024-04-04T09:55:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1549414682",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1549414682"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 857,
      "original_line": 857,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1550260907",
      "pull_request_review_id": 1977655865,
      "id": 1550260907,
      "node_id": "PRRC_kwDOABII585cZxqr",
      "diff_hunk": "@@ -4354,7 +4354,9 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         const TxValidationState& state = result.m_state;\n \n         if (result.m_result_type == MempoolAcceptResult::ResultType::VALID) {\n-            ProcessValidTx(pfrom.GetId(), ptx, result.m_replaced_transactions.value());\n+            Assume(result.m_replaced_transactions.has_value());\n+            std::list<CTransactionRef> empty_replacement_list;\n+            ProcessValidTx(pfrom.GetId(), ptx, result.m_replaced_transactions.value_or(empty_replacement_list));",
      "path": "src/net_processing.cpp",
      "position": 320,
      "original_position": 7,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "53f1e65f30a0a6b931e97743113e0227748680df",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In  guard against MempoolAcceptResult::m_replaced_transactions  (53f1e65f30a0a6b931e97743113e0227748680df):\r\nI am not well-acquainted with `net_processing.cpp`, but I figured I could still mention that it is unclear to me from the commit message and the code change how this change fits in the context. Were we previously assuming that we would always have a non-empty list for `m_replaced_transactions` in the context of this call?",
      "created_at": "2024-04-03T18:31:10Z",
      "updated_at": "2024-04-03T19:51:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1550260907",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1550260907"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": 4357,
      "original_start_line": 4357,
      "start_side": "LEFT",
      "line": 4568,
      "original_line": 4568,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1550334355",
      "pull_request_review_id": 1977655865,
      "id": 1550334355,
      "node_id": "PRRC_kwDOABII585caDmT",
      "diff_hunk": "@@ -138,4 +162,46 @@ BOOST_AUTO_TEST_CASE(DoS_mapOrphans)\n     BOOST_CHECK(orphanage.CountOrphans() == 0);\n }\n \n+BOOST_AUTO_TEST_CASE(get_children)\n+{\n+    FastRandomContext det_rand{true};\n+    TxOrphanage orphanage;\n+    const NodeId node{0};\n+    std::vector<COutPoint> empty_outpoints;\n+\n+    auto parent1 = MakeTransactionSpending(empty_outpoints, det_rand);\n+    auto parent2 = MakeTransactionSpending(empty_outpoints, det_rand);\n+\n+    // Make sure these parents have different txids otherwise this test won't make sense.\n+    BOOST_CHECK(parent1->GetHash() != parent2->GetHash());\n+\n+    // Create children to go into orphanage.\n+    auto child_p1n0 = MakeTransactionSpending({{parent1->GetHash(), 0}}, det_rand);\n+    auto child_p2n1 = MakeTransactionSpending({{parent2->GetHash(), 1}}, det_rand);\n+    // Spends the same tx twice. Should not cause duplicates in GetChildren.\n+    auto child_p1n0_p1n1 = MakeTransactionSpending({{parent1->GetHash(), 0}, {parent1->GetHash(), 1}}, det_rand);\n+    // Spends the same outpoint as previous tx. Should still be returned; don't assume outpoints are unique.\n+    auto child_p1n0_p2n0 = MakeTransactionSpending({{parent1->GetHash(), 0}, {parent2->GetHash(), 0}}, det_rand);\n+\n+    BOOST_CHECK(orphanage.AddTx(child_p1n0, node));\n+    BOOST_CHECK(orphanage.AddTx(child_p2n1, node));\n+    BOOST_CHECK(orphanage.AddTx(child_p1n0_p1n1, node));\n+    BOOST_CHECK(orphanage.AddTx(child_p1n0_p2n0, node));\n+\n+    // Check that GetChildren returns what is expected.\n+    std::set<Wtxid> expected_parent1_children{child_p1n0->GetWitnessHash(), child_p1n0_p2n0->GetWitnessHash(), child_p1n0_p1n1->GetWitnessHash()};\n+    std::set<Wtxid> expected_parent2_children{child_p2n1->GetWitnessHash(), child_p1n0_p2n0->GetWitnessHash()};\n+\n+    auto parent1_children{orphanage.GetChildren(parent1)};\n+    BOOST_CHECK_EQUAL(parent1_children.size(), expected_parent1_children.size());\n+    for (const auto& child : parent1_children) {\n+        BOOST_CHECK(expected_parent1_children.count(child->GetWitnessHash()) > 0);",
      "path": "src/test/orphanage_tests.cpp",
      "position": null,
      "original_position": 78,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "b49b634556388ff5ec3c48fd05d628f77f6126a0",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Nit: Could use [`std::set::contains`](https://en.cppreference.com/w/cpp/container/set/contains) here and below\r\n```suggestion\r\n        BOOST_CHECK(expected_parent1_children.contains(child->GetWitnessHash()));\r\n```",
      "created_at": "2024-04-03T19:28:27Z",
      "updated_at": "2024-04-03T19:51:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1550334355",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1550334355"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 198,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1550398421",
      "pull_request_review_id": 1977876327,
      "id": 1550398421,
      "node_id": "PRRC_kwDOABII585caTPV",
      "diff_hunk": "@@ -4354,7 +4354,9 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         const TxValidationState& state = result.m_state;\n \n         if (result.m_result_type == MempoolAcceptResult::ResultType::VALID) {\n-            ProcessValidTx(pfrom.GetId(), ptx, result.m_replaced_transactions.value());\n+            Assume(result.m_replaced_transactions.has_value());\n+            std::list<CTransactionRef> empty_replacement_list;\n+            ProcessValidTx(pfrom.GetId(), ptx, result.m_replaced_transactions.value_or(empty_replacement_list));",
      "path": "src/net_processing.cpp",
      "position": 320,
      "original_position": 7,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "53f1e65f30a0a6b931e97743113e0227748680df",
      "in_reply_to_id": 1550260907,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "@murchandamus: I was asking myself the same a few days ago and started with some review notes for each commit. The one for 53f1e65f30a0a6b931e97743113e0227748680df might fit to your question (note that it's not about empty vs. non-empty, but more about set-to-nothing vs. set-to-something, since it's an std::optional):\r\n```\r\nThe only way to create an ATMP result of type `MempoolAcceptResult::ResultType::VALID` is using the\r\nstatic method `MempoolAccepptResult::Success`, which in turn calls the private successful case constructor of\r\n`MempoolAcceptResult`. This one always sets `m_replaced_transactions`, therefore\r\n`result.m_replaced_transactions.has_value()` in the modified code path should always be true.\r\n```\r\n(maybe it makes sense to include it in the commit message, if that is correct)\r\nThe same three lines of code are introduced in `PeerManagerImpl::ProcessPackageResult` (commit d6df19000118768678c7afd4b9330b4604bb37ce), I assume that this is the reason to also do it on the other place in the code for consistency.",
      "created_at": "2024-04-03T20:16:28Z",
      "updated_at": "2024-04-03T20:16:28Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1550398421",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1550398421"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": 4357,
      "original_start_line": 4357,
      "start_side": "LEFT",
      "line": 4568,
      "original_line": 4568,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1550445308",
      "pull_request_review_id": 1977957595,
      "id": 1550445308,
      "node_id": "PRRC_kwDOABII585caer8",
      "diff_hunk": "@@ -4354,7 +4354,9 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         const TxValidationState& state = result.m_state;\n \n         if (result.m_result_type == MempoolAcceptResult::ResultType::VALID) {\n-            ProcessValidTx(pfrom.GetId(), ptx, result.m_replaced_transactions.value());\n+            Assume(result.m_replaced_transactions.has_value());\n+            std::list<CTransactionRef> empty_replacement_list;\n+            ProcessValidTx(pfrom.GetId(), ptx, result.m_replaced_transactions.value_or(empty_replacement_list));",
      "path": "src/net_processing.cpp",
      "position": 320,
      "original_position": 7,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "53f1e65f30a0a6b931e97743113e0227748680df",
      "in_reply_to_id": 1550260907,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> it is unclear to me from the commit message and the code change how this change fits in the context.\r\n\r\n(Note that this commit is a followup from #29619, I've now linked to the comments in the PR description)\r\n\r\nYes, it should always have a value when the result is VALID. This is just adding a belt-and-suspenders juuust in case.",
      "created_at": "2024-04-03T20:42:45Z",
      "updated_at": "2024-04-03T20:43:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1550445308",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1550445308"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": 4357,
      "original_start_line": 4357,
      "start_side": "LEFT",
      "line": 4568,
      "original_line": 4568,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1550494056",
      "pull_request_review_id": 1978040928,
      "id": 1550494056,
      "node_id": "PRRC_kwDOABII585caqlo",
      "diff_hunk": "@@ -4354,7 +4354,9 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         const TxValidationState& state = result.m_state;\n \n         if (result.m_result_type == MempoolAcceptResult::ResultType::VALID) {\n-            ProcessValidTx(pfrom.GetId(), ptx, result.m_replaced_transactions.value());\n+            Assume(result.m_replaced_transactions.has_value());\n+            std::list<CTransactionRef> empty_replacement_list;\n+            ProcessValidTx(pfrom.GetId(), ptx, result.m_replaced_transactions.value_or(empty_replacement_list));",
      "path": "src/net_processing.cpp",
      "position": 320,
      "original_position": 7,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "53f1e65f30a0a6b931e97743113e0227748680df",
      "in_reply_to_id": 1550260907,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Thanks! Great, I’ll attempt another more thorough review at a later time.",
      "created_at": "2024-04-03T21:01:00Z",
      "updated_at": "2024-04-03T21:01:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1550494056",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1550494056"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": 4357,
      "original_start_line": 4357,
      "start_side": "LEFT",
      "line": 4568,
      "original_line": 4568,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1551287725",
      "pull_request_review_id": 1976216428,
      "id": 1551287725,
      "node_id": "PRRC_kwDOABII585cdsWt",
      "diff_hunk": "@@ -6061,7 +6186,9 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                 entry.second.GetHash().ToString(), entry.first);\n         }\n         for (const GenTxid& gtxid : requestable) {\n-            if (!AlreadyHaveTx(gtxid, /*include_reconsiderable=*/true)) {\n+            // Skip m_recent_rejects_reconsiderable because we may be requesting a missing parent",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 167,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "d6df19000118768678c7afd4b9330b4604bb37ce",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I have to admit I'm struggling on these \"skip\" comments and cases. Every time I read this I have trouble re-deriving the logic. ",
      "created_at": "2024-04-04T09:07:17Z",
      "updated_at": "2024-04-04T09:55:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1551287725",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1551287725"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 6189,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1551410174",
      "pull_request_review_id": 1979439672,
      "id": 1551410174,
      "node_id": "PRRC_kwDOABII585ceKP-",
      "diff_hunk": "@@ -0,0 +1,203 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test opportunistic 1p1c package submission logic.\n+\"\"\"\n+\n+from decimal import Decimal\n+from test_framework.messages import (\n+    CInv,\n+    MSG_WTX,\n+    msg_inv,\n+    msg_tx,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    fill_mempool,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+        self.noban_tx_relay = True\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+        ]]\n+        self.supports_cli = False\n+\n+    def test_basic_child_then_parent(self):\n+        node = self.nodes[0]\n+        self.log.info(\"Check that opportunistic 1p1c logic works when child is received before parent\")\n+\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first (perhaps the low feerate parent didn't meet feefilter or the requests were sent to different nodes). It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. Sender relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 4. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+        node.disconnect_p2ps()\n+\n+    def test_basic_parent_then_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=1, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=2, connection_type=\"outbound-full-relay\")\n+\n+        # 1. Parent is relayed first. It is too low feerate.\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer_sender.wait_for_getdata([parent_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer_ignored, check that it is ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+\n+        # 2. Child is relayed next. It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 3. Node requests the missing parent by txid.\n+        # It should do so even if it has previously rejected that parent for being too low feerate.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 4. Sender re-relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 5. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+        node.disconnect_p2ps()\n+\n+    def test_low_and_high_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        low_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=2*FEERATE_1SAT_VB)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=3, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=4, connection_type=\"outbound-full-relay\")\n+\n+        self.log.info(\"Check that tx caches low fee parent + low fee child package rejections\")\n+\n+        # 1. Send parent, rejected for being low feerate.\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer_sender.wait_for_getdata([parent_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer_ignored, check that it is ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+\n+        # 2. Send an (orphan) child that has a higher feerate, but not enough to bump the parent.\n+        low_child_wtxid_int = int(low_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([low_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_child[\"tx\"]))\n+\n+        # 3. Node requests the orphan's missing parent.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 4. The low parent + low child are submitted as a package. They are not accepted due to low package feerate.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+        assert low_fee_child[\"txid\"] not in node.getrawmempool()\n+\n+        # If peer_ignored announces the low feerate child, it should be ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+        # If either peer sends the parent again, package evaluation should not be attempted\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        peer_ignored.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 5. Send the high feerate (orphan) child\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 6. Node requests the orphan's parent, even though it has already been rejected, both by\n+        # itself and with a child. This is necessary, otherwise high_fee_child can be censored.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 7. The low feerate parent + high feerate child are submitted as a package.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 8. Both transactions should now be in mempool\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+        node.disconnect_p2ps()\n+\n+    def run_test(self):",
      "path": "test/functional/p2p_opportunistic_1p1c.py",
      "position": 377,
      "original_position": 177,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "c5e196b8e7b610cc9e6321b76fee4f0c45c1448e",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "add a case where:\r\n1) CONSENSUS-invalid child is propagated to peer\r\n2) low_fee parent is given\r\n3) package evaluation is attempted\r\n4) peer is disconnected\r\n\r\nto ensure we're handling invalid tx properly",
      "created_at": "2024-04-04T10:25:44Z",
      "updated_at": "2024-04-04T10:25:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1551410174",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1551410174"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 377,
      "original_line": 377,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1553911167",
      "pull_request_review_id": 1983578881,
      "id": 1553911167,
      "node_id": "PRRC_kwDOABII585cns1_",
      "diff_hunk": "@@ -806,7 +806,7 @@ class PeerManagerImpl final : public PeerManager\n     /** Stalling timeout for blocks in IBD */\n     std::atomic<std::chrono::seconds> m_block_stalling_timeout{BLOCK_STALLING_TIMEOUT_DEFAULT};\n \n-    bool AlreadyHaveTx(const GenTxid& gtxid)\n+    bool AlreadyHaveTx(const GenTxid& gtxid, bool include_reconsiderable)",
      "path": "src/net_processing.cpp",
      "position": 69,
      "original_position": 5,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "826b31b5a3bef4adb3d1d9145d1452b8e91fda46",
      "in_reply_to_id": 1549414682,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Added. Also WOW, I realized we somehow lost the line where `m_recent_rejects_reconsiderable` is reset. Fixed that.",
      "created_at": "2024-04-05T15:43:51Z",
      "updated_at": "2024-04-05T16:21:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1553911167",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1553911167"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 857,
      "original_line": 857,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1553914428",
      "pull_request_review_id": 1983578881,
      "id": 1553914428,
      "node_id": "PRRC_kwDOABII585cnto8",
      "diff_hunk": "@@ -6061,7 +6186,9 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                 entry.second.GetHash().ToString(), entry.first);\n         }\n         for (const GenTxid& gtxid : requestable) {\n-            if (!AlreadyHaveTx(gtxid, /*include_reconsiderable=*/true)) {\n+            // Skip m_recent_rejects_reconsiderable because we may be requesting a missing parent",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 167,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "d6df19000118768678c7afd4b9330b4604bb37ce",
      "in_reply_to_id": 1551287725,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Ok hm. I've simplified the wording a bit. Maybe that helps?",
      "created_at": "2024-04-05T15:46:38Z",
      "updated_at": "2024-04-05T16:21:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1553914428",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1553914428"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 6189,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1553914606",
      "pull_request_review_id": 1983578881,
      "id": 1553914606,
      "node_id": "PRRC_kwDOABII585cntru",
      "diff_hunk": "@@ -138,4 +162,46 @@ BOOST_AUTO_TEST_CASE(DoS_mapOrphans)\n     BOOST_CHECK(orphanage.CountOrphans() == 0);\n }\n \n+BOOST_AUTO_TEST_CASE(get_children)\n+{\n+    FastRandomContext det_rand{true};\n+    TxOrphanage orphanage;\n+    const NodeId node{0};\n+    std::vector<COutPoint> empty_outpoints;\n+\n+    auto parent1 = MakeTransactionSpending(empty_outpoints, det_rand);\n+    auto parent2 = MakeTransactionSpending(empty_outpoints, det_rand);\n+\n+    // Make sure these parents have different txids otherwise this test won't make sense.\n+    BOOST_CHECK(parent1->GetHash() != parent2->GetHash());",
      "path": "src/test/orphanage_tests.cpp",
      "position": null,
      "original_position": 56,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "b49b634556388ff5ec3c48fd05d628f77f6126a0",
      "in_reply_to_id": 1549395161,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "done",
      "created_at": "2024-04-05T15:46:47Z",
      "updated_at": "2024-04-05T16:21:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1553914606",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1553914606"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 176,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1553914701",
      "pull_request_review_id": 1983578881,
      "id": 1553914701,
      "node_id": "PRRC_kwDOABII585cnttN",
      "diff_hunk": "@@ -138,4 +162,46 @@ BOOST_AUTO_TEST_CASE(DoS_mapOrphans)\n     BOOST_CHECK(orphanage.CountOrphans() == 0);\n }\n \n+BOOST_AUTO_TEST_CASE(get_children)\n+{\n+    FastRandomContext det_rand{true};\n+    TxOrphanage orphanage;\n+    const NodeId node{0};\n+    std::vector<COutPoint> empty_outpoints;\n+\n+    auto parent1 = MakeTransactionSpending(empty_outpoints, det_rand);\n+    auto parent2 = MakeTransactionSpending(empty_outpoints, det_rand);\n+\n+    // Make sure these parents have different txids otherwise this test won't make sense.\n+    BOOST_CHECK(parent1->GetHash() != parent2->GetHash());\n+\n+    // Create children to go into orphanage.\n+    auto child_p1n0 = MakeTransactionSpending({{parent1->GetHash(), 0}}, det_rand);\n+    auto child_p2n1 = MakeTransactionSpending({{parent2->GetHash(), 1}}, det_rand);\n+    // Spends the same tx twice. Should not cause duplicates in GetChildren.\n+    auto child_p1n0_p1n1 = MakeTransactionSpending({{parent1->GetHash(), 0}, {parent1->GetHash(), 1}}, det_rand);\n+    // Spends the same outpoint as previous tx. Should still be returned; don't assume outpoints are unique.\n+    auto child_p1n0_p2n0 = MakeTransactionSpending({{parent1->GetHash(), 0}, {parent2->GetHash(), 0}}, det_rand);\n+\n+    BOOST_CHECK(orphanage.AddTx(child_p1n0, node));\n+    BOOST_CHECK(orphanage.AddTx(child_p2n1, node));\n+    BOOST_CHECK(orphanage.AddTx(child_p1n0_p1n1, node));\n+    BOOST_CHECK(orphanage.AddTx(child_p1n0_p2n0, node));\n+\n+    // Check that GetChildren returns what is expected.\n+    std::set<Wtxid> expected_parent1_children{child_p1n0->GetWitnessHash(), child_p1n0_p2n0->GetWitnessHash(), child_p1n0_p1n1->GetWitnessHash()};\n+    std::set<Wtxid> expected_parent2_children{child_p2n1->GetWitnessHash(), child_p1n0_p2n0->GetWitnessHash()};\n+\n+    auto parent1_children{orphanage.GetChildren(parent1)};\n+    BOOST_CHECK_EQUAL(parent1_children.size(), expected_parent1_children.size());\n+    for (const auto& child : parent1_children) {\n+        BOOST_CHECK(expected_parent1_children.count(child->GetWitnessHash()) > 0);",
      "path": "src/test/orphanage_tests.cpp",
      "position": null,
      "original_position": 78,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "b49b634556388ff5ec3c48fd05d628f77f6126a0",
      "in_reply_to_id": 1550334355,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "done, yay for 20",
      "created_at": "2024-04-05T15:46:53Z",
      "updated_at": "2024-04-05T16:21:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1553914701",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1553914701"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 198,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1553914777",
      "pull_request_review_id": 1983578881,
      "id": 1553914777,
      "node_id": "PRRC_kwDOABII585cntuZ",
      "diff_hunk": "@@ -138,4 +162,46 @@ BOOST_AUTO_TEST_CASE(DoS_mapOrphans)\n     BOOST_CHECK(orphanage.CountOrphans() == 0);\n }\n \n+BOOST_AUTO_TEST_CASE(get_children)\n+{\n+    FastRandomContext det_rand{true};\n+    TxOrphanage orphanage;\n+    const NodeId node{0};\n+    std::vector<COutPoint> empty_outpoints;\n+\n+    auto parent1 = MakeTransactionSpending(empty_outpoints, det_rand);\n+    auto parent2 = MakeTransactionSpending(empty_outpoints, det_rand);\n+\n+    // Make sure these parents have different txids otherwise this test won't make sense.\n+    BOOST_CHECK(parent1->GetHash() != parent2->GetHash());\n+\n+    // Create children to go into orphanage.\n+    auto child_p1n0 = MakeTransactionSpending({{parent1->GetHash(), 0}}, det_rand);\n+    auto child_p2n1 = MakeTransactionSpending({{parent2->GetHash(), 1}}, det_rand);\n+    // Spends the same tx twice. Should not cause duplicates in GetChildren.\n+    auto child_p1n0_p1n1 = MakeTransactionSpending({{parent1->GetHash(), 0}, {parent1->GetHash(), 1}}, det_rand);\n+    // Spends the same outpoint as previous tx. Should still be returned; don't assume outpoints are unique.\n+    auto child_p1n0_p2n0 = MakeTransactionSpending({{parent1->GetHash(), 0}, {parent2->GetHash(), 0}}, det_rand);\n+\n+    BOOST_CHECK(orphanage.AddTx(child_p1n0, node));\n+    BOOST_CHECK(orphanage.AddTx(child_p2n1, node));\n+    BOOST_CHECK(orphanage.AddTx(child_p1n0_p1n1, node));\n+    BOOST_CHECK(orphanage.AddTx(child_p1n0_p2n0, node));\n+\n+    // Check that GetChildren returns what is expected.\n+    std::set<Wtxid> expected_parent1_children{child_p1n0->GetWitnessHash(), child_p1n0_p2n0->GetWitnessHash(), child_p1n0_p1n1->GetWitnessHash()};\n+    std::set<Wtxid> expected_parent2_children{child_p2n1->GetWitnessHash(), child_p1n0_p2n0->GetWitnessHash()};\n+\n+    auto parent1_children{orphanage.GetChildren(parent1)};\n+    BOOST_CHECK_EQUAL(parent1_children.size(), expected_parent1_children.size());\n+    for (const auto& child : parent1_children) {\n+        BOOST_CHECK(expected_parent1_children.count(child->GetWitnessHash()) > 0);\n+    }\n+    auto parent2_children{orphanage.GetChildren(parent2)};\n+    BOOST_CHECK_EQUAL(parent2_children.size(), expected_parent2_children.size());\n+    for (const auto& child : parent2_children) {\n+        BOOST_CHECK(expected_parent2_children.count(child->GetWitnessHash()) > 0);\n+    }",
      "path": "src/test/orphanage_tests.cpp",
      "position": 113,
      "original_position": 84,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "b49b634556388ff5ec3c48fd05d628f77f6126a0",
      "in_reply_to_id": 1549404732,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "added",
      "created_at": "2024-04-05T15:46:57Z",
      "updated_at": "2024-04-05T16:21:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1553914777",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1553914777"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 233,
      "original_line": 233,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1553914876",
      "pull_request_review_id": 1983578881,
      "id": 1553914876,
      "node_id": "PRRC_kwDOABII585cntv8",
      "diff_hunk": "@@ -241,3 +241,28 @@ void TxOrphanage::EraseForBlock(const CBlock& block)\n         LogPrint(BCLog::TXPACKAGES, \"Erased %d orphan tx included or conflicted by block\\n\", nErased);\n     }\n }\n+\n+std::vector<CTransactionRef> TxOrphanage::GetChildren(const CTransactionRef& parent) const\n+{\n+    LOCK(m_mutex);\n+\n+    // First construct a set of iterators to ensure we do not return duplicates of the same tx.\n+    std::set<OrphanMap::iterator, IteratorComparator> set_child_iterators;\n+\n+    // For each input, get all entries spending this prevout.",
      "path": "src/txorphanage.cpp",
      "position": null,
      "original_position": 12,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "d3d7dcf00439655a921f3be4624d01814de2e346",
      "in_reply_to_id": 1549376386,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "done",
      "created_at": "2024-04-05T15:47:02Z",
      "updated_at": "2024-04-05T16:21:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1553914876",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1553914876"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 252,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1553965998",
      "pull_request_review_id": 1983578881,
      "id": 1553965998,
      "node_id": "PRRC_kwDOABII585cn6Ou",
      "diff_hunk": "@@ -0,0 +1,203 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test opportunistic 1p1c package submission logic.\n+\"\"\"\n+\n+from decimal import Decimal\n+from test_framework.messages import (\n+    CInv,\n+    MSG_WTX,\n+    msg_inv,\n+    msg_tx,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    fill_mempool,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+        self.noban_tx_relay = True\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+        ]]\n+        self.supports_cli = False\n+\n+    def test_basic_child_then_parent(self):\n+        node = self.nodes[0]\n+        self.log.info(\"Check that opportunistic 1p1c logic works when child is received before parent\")\n+\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first (perhaps the low feerate parent didn't meet feefilter or the requests were sent to different nodes). It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. Sender relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 4. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+        node.disconnect_p2ps()\n+\n+    def test_basic_parent_then_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=1, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=2, connection_type=\"outbound-full-relay\")\n+\n+        # 1. Parent is relayed first. It is too low feerate.\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer_sender.wait_for_getdata([parent_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer_ignored, check that it is ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+\n+        # 2. Child is relayed next. It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 3. Node requests the missing parent by txid.\n+        # It should do so even if it has previously rejected that parent for being too low feerate.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 4. Sender re-relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 5. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+        node.disconnect_p2ps()\n+\n+    def test_low_and_high_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        low_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=2*FEERATE_1SAT_VB)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=3, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=4, connection_type=\"outbound-full-relay\")\n+\n+        self.log.info(\"Check that tx caches low fee parent + low fee child package rejections\")\n+\n+        # 1. Send parent, rejected for being low feerate.\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer_sender.wait_for_getdata([parent_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer_ignored, check that it is ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+\n+        # 2. Send an (orphan) child that has a higher feerate, but not enough to bump the parent.\n+        low_child_wtxid_int = int(low_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([low_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_child[\"tx\"]))\n+\n+        # 3. Node requests the orphan's missing parent.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 4. The low parent + low child are submitted as a package. They are not accepted due to low package feerate.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+        assert low_fee_child[\"txid\"] not in node.getrawmempool()\n+\n+        # If peer_ignored announces the low feerate child, it should be ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+        # If either peer sends the parent again, package evaluation should not be attempted\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        peer_ignored.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 5. Send the high feerate (orphan) child\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 6. Node requests the orphan's parent, even though it has already been rejected, both by\n+        # itself and with a child. This is necessary, otherwise high_fee_child can be censored.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 7. The low feerate parent + high feerate child are submitted as a package.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 8. Both transactions should now be in mempool\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+        node.disconnect_p2ps()\n+\n+    def run_test(self):",
      "path": "test/functional/p2p_opportunistic_1p1c.py",
      "position": 377,
      "original_position": 177,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "c5e196b8e7b610cc9e6321b76fee4f0c45c1448e",
      "in_reply_to_id": 1551410174,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Wait oof, we don't require the orphanage child to be provided by the same peer who sent the low-feerate tx. I think this would mean you can get other people disconnected by sending a bogus child of the package they're sending.",
      "created_at": "2024-04-05T16:21:34Z",
      "updated_at": "2024-04-05T16:21:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1553965998",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1553965998"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 377,
      "original_line": 377,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1553982455",
      "pull_request_review_id": 1983689499,
      "id": 1553982455,
      "node_id": "PRRC_kwDOABII585cn-P3",
      "diff_hunk": "@@ -6061,7 +6186,9 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                 entry.second.GetHash().ToString(), entry.first);\n         }\n         for (const GenTxid& gtxid : requestable) {\n-            if (!AlreadyHaveTx(gtxid, /*include_reconsiderable=*/true)) {\n+            // Skip m_recent_rejects_reconsiderable because we may be requesting a missing parent",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 167,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "d6df19000118768678c7afd4b9330b4604bb37ce",
      "in_reply_to_id": 1551287725,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "think you forgot to push?",
      "created_at": "2024-04-05T16:37:36Z",
      "updated_at": "2024-04-05T16:37:36Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1553982455",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1553982455"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 6189,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1553982697",
      "pull_request_review_id": 1983689912,
      "id": 1553982697,
      "node_id": "PRRC_kwDOABII585cn-Tp",
      "diff_hunk": "@@ -806,7 +806,7 @@ class PeerManagerImpl final : public PeerManager\n     /** Stalling timeout for blocks in IBD */\n     std::atomic<std::chrono::seconds> m_block_stalling_timeout{BLOCK_STALLING_TIMEOUT_DEFAULT};\n \n-    bool AlreadyHaveTx(const GenTxid& gtxid)\n+    bool AlreadyHaveTx(const GenTxid& gtxid, bool include_reconsiderable)",
      "path": "src/net_processing.cpp",
      "position": 69,
      "original_position": 5,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "826b31b5a3bef4adb3d1d9145d1452b8e91fda46",
      "in_reply_to_id": 1549414682,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "we should have tests(in master?) for this I hope. \r\n\r\nsomething below minfee is rejected, block comes in, node should respond to an INV for the same thing again",
      "created_at": "2024-04-05T16:37:52Z",
      "updated_at": "2024-04-05T16:37:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1553982697",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1553982697"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 857,
      "original_line": 857,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1553992489",
      "pull_request_review_id": 1983705498,
      "id": 1553992489,
      "node_id": "PRRC_kwDOABII585coAsp",
      "diff_hunk": "@@ -0,0 +1,203 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test opportunistic 1p1c package submission logic.\n+\"\"\"\n+\n+from decimal import Decimal\n+from test_framework.messages import (\n+    CInv,\n+    MSG_WTX,\n+    msg_inv,\n+    msg_tx,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    fill_mempool,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+        self.noban_tx_relay = True\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+        ]]\n+        self.supports_cli = False\n+\n+    def test_basic_child_then_parent(self):\n+        node = self.nodes[0]\n+        self.log.info(\"Check that opportunistic 1p1c logic works when child is received before parent\")\n+\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first (perhaps the low feerate parent didn't meet feefilter or the requests were sent to different nodes). It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. Sender relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 4. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+        node.disconnect_p2ps()\n+\n+    def test_basic_parent_then_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=1, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=2, connection_type=\"outbound-full-relay\")\n+\n+        # 1. Parent is relayed first. It is too low feerate.\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer_sender.wait_for_getdata([parent_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer_ignored, check that it is ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+\n+        # 2. Child is relayed next. It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 3. Node requests the missing parent by txid.\n+        # It should do so even if it has previously rejected that parent for being too low feerate.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 4. Sender re-relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 5. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+        node.disconnect_p2ps()\n+\n+    def test_low_and_high_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        low_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=2*FEERATE_1SAT_VB)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=3, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=4, connection_type=\"outbound-full-relay\")\n+\n+        self.log.info(\"Check that tx caches low fee parent + low fee child package rejections\")\n+\n+        # 1. Send parent, rejected for being low feerate.\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer_sender.wait_for_getdata([parent_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer_ignored, check that it is ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+\n+        # 2. Send an (orphan) child that has a higher feerate, but not enough to bump the parent.\n+        low_child_wtxid_int = int(low_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([low_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_child[\"tx\"]))\n+\n+        # 3. Node requests the orphan's missing parent.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 4. The low parent + low child are submitted as a package. They are not accepted due to low package feerate.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+        assert low_fee_child[\"txid\"] not in node.getrawmempool()\n+\n+        # If peer_ignored announces the low feerate child, it should be ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+        # If either peer sends the parent again, package evaluation should not be attempted\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        peer_ignored.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 5. Send the high feerate (orphan) child\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 6. Node requests the orphan's parent, even though it has already been rejected, both by\n+        # itself and with a child. This is necessary, otherwise high_fee_child can be censored.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 7. The low feerate parent + high feerate child are submitted as a package.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 8. Both transactions should now be in mempool\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+        node.disconnect_p2ps()\n+\n+    def run_test(self):",
      "path": "test/functional/p2p_opportunistic_1p1c.py",
      "position": 377,
      "original_position": 177,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "c5e196b8e7b610cc9e6321b76fee4f0c45c1448e",
      "in_reply_to_id": 1551410174,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "looks like peer id needs to be used again: https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1542964936",
      "created_at": "2024-04-05T16:45:50Z",
      "updated_at": "2024-04-05T16:45:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1553992489",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1553992489"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 377,
      "original_line": 377,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1553996459",
      "pull_request_review_id": 1983711619,
      "id": 1553996459,
      "node_id": "PRRC_kwDOABII585coBqr",
      "diff_hunk": "@@ -6061,7 +6186,9 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                 entry.second.GetHash().ToString(), entry.first);\n         }\n         for (const GenTxid& gtxid : requestable) {\n-            if (!AlreadyHaveTx(gtxid, /*include_reconsiderable=*/true)) {\n+            // Skip m_recent_rejects_reconsiderable because we may be requesting a missing parent",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 167,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "d6df19000118768678c7afd4b9330b4604bb37ce",
      "in_reply_to_id": 1551287725,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> think you forgot to push?\r\n\r\nGithub published everything instead of adding my comment to the group -_- yes, pushing in a second.",
      "created_at": "2024-04-05T16:49:47Z",
      "updated_at": "2024-04-05T16:49:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1553996459",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1553996459"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 6189,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1554000244",
      "pull_request_review_id": 1983717342,
      "id": 1554000244,
      "node_id": "PRRC_kwDOABII585coCl0",
      "diff_hunk": "@@ -806,7 +806,7 @@ class PeerManagerImpl final : public PeerManager\n     /** Stalling timeout for blocks in IBD */\n     std::atomic<std::chrono::seconds> m_block_stalling_timeout{BLOCK_STALLING_TIMEOUT_DEFAULT};\n \n-    bool AlreadyHaveTx(const GenTxid& gtxid)\n+    bool AlreadyHaveTx(const GenTxid& gtxid, bool include_reconsiderable)",
      "path": "src/net_processing.cpp",
      "position": 69,
      "original_position": 5,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "826b31b5a3bef4adb3d1d9145d1452b8e91fda46",
      "in_reply_to_id": 1549414682,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> we should have tests(in master?) for this I hope.\r\n\r\napparently not?",
      "created_at": "2024-04-05T16:53:39Z",
      "updated_at": "2024-04-05T16:53:39Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1554000244",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1554000244"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 857,
      "original_line": 857,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1554004259",
      "pull_request_review_id": 1983723249,
      "id": 1554004259,
      "node_id": "PRRC_kwDOABII585coDkj",
      "diff_hunk": "@@ -0,0 +1,203 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test opportunistic 1p1c package submission logic.\n+\"\"\"\n+\n+from decimal import Decimal\n+from test_framework.messages import (\n+    CInv,\n+    MSG_WTX,\n+    msg_inv,\n+    msg_tx,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    fill_mempool,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+        self.noban_tx_relay = True\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+        ]]\n+        self.supports_cli = False\n+\n+    def test_basic_child_then_parent(self):\n+        node = self.nodes[0]\n+        self.log.info(\"Check that opportunistic 1p1c logic works when child is received before parent\")\n+\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first (perhaps the low feerate parent didn't meet feefilter or the requests were sent to different nodes). It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. Sender relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 4. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+        node.disconnect_p2ps()\n+\n+    def test_basic_parent_then_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=1, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=2, connection_type=\"outbound-full-relay\")\n+\n+        # 1. Parent is relayed first. It is too low feerate.\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer_sender.wait_for_getdata([parent_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer_ignored, check that it is ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+\n+        # 2. Child is relayed next. It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 3. Node requests the missing parent by txid.\n+        # It should do so even if it has previously rejected that parent for being too low feerate.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 4. Sender re-relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 5. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+        node.disconnect_p2ps()\n+\n+    def test_low_and_high_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        low_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=2*FEERATE_1SAT_VB)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=3, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=4, connection_type=\"outbound-full-relay\")\n+\n+        self.log.info(\"Check that tx caches low fee parent + low fee child package rejections\")\n+\n+        # 1. Send parent, rejected for being low feerate.\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer_sender.wait_for_getdata([parent_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer_ignored, check that it is ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+\n+        # 2. Send an (orphan) child that has a higher feerate, but not enough to bump the parent.\n+        low_child_wtxid_int = int(low_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([low_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_child[\"tx\"]))\n+\n+        # 3. Node requests the orphan's missing parent.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 4. The low parent + low child are submitted as a package. They are not accepted due to low package feerate.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+        assert low_fee_child[\"txid\"] not in node.getrawmempool()\n+\n+        # If peer_ignored announces the low feerate child, it should be ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+        # If either peer sends the parent again, package evaluation should not be attempted\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        peer_ignored.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 5. Send the high feerate (orphan) child\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 6. Node requests the orphan's parent, even though it has already been rejected, both by\n+        # itself and with a child. This is necessary, otherwise high_fee_child can be censored.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 7. The low feerate parent + high feerate child are submitted as a package.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 8. Both transactions should now be in mempool\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+        node.disconnect_p2ps()\n+\n+    def run_test(self):",
      "path": "test/functional/p2p_opportunistic_1p1c.py",
      "position": 377,
      "original_position": 177,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "c5e196b8e7b610cc9e6321b76fee4f0c45c1448e",
      "in_reply_to_id": 1551410174,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Hm no, I think we should return pairs of tx and the `fromPeer`, and just attribute the error to the right peer. If we restrict it to same sender, then we can also block packages by sending the children fast and refusing to send the parent.",
      "created_at": "2024-04-05T16:57:22Z",
      "updated_at": "2024-04-05T16:57:23Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1554004259",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1554004259"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 377,
      "original_line": 377,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1554024570",
      "pull_request_review_id": 1983753486,
      "id": 1554024570,
      "node_id": "PRRC_kwDOABII585coIh6",
      "diff_hunk": "@@ -0,0 +1,203 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test opportunistic 1p1c package submission logic.\n+\"\"\"\n+\n+from decimal import Decimal\n+from test_framework.messages import (\n+    CInv,\n+    MSG_WTX,\n+    msg_inv,\n+    msg_tx,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    fill_mempool,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+        self.noban_tx_relay = True\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+        ]]\n+        self.supports_cli = False\n+\n+    def test_basic_child_then_parent(self):\n+        node = self.nodes[0]\n+        self.log.info(\"Check that opportunistic 1p1c logic works when child is received before parent\")\n+\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first (perhaps the low feerate parent didn't meet feefilter or the requests were sent to different nodes). It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. Sender relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 4. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+        node.disconnect_p2ps()\n+\n+    def test_basic_parent_then_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=1, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=2, connection_type=\"outbound-full-relay\")\n+\n+        # 1. Parent is relayed first. It is too low feerate.\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer_sender.wait_for_getdata([parent_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer_ignored, check that it is ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+\n+        # 2. Child is relayed next. It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 3. Node requests the missing parent by txid.\n+        # It should do so even if it has previously rejected that parent for being too low feerate.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 4. Sender re-relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 5. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+        node.disconnect_p2ps()\n+\n+    def test_low_and_high_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        low_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=2*FEERATE_1SAT_VB)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=3, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=4, connection_type=\"outbound-full-relay\")\n+\n+        self.log.info(\"Check that tx caches low fee parent + low fee child package rejections\")\n+\n+        # 1. Send parent, rejected for being low feerate.\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer_sender.wait_for_getdata([parent_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer_ignored, check that it is ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+\n+        # 2. Send an (orphan) child that has a higher feerate, but not enough to bump the parent.\n+        low_child_wtxid_int = int(low_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([low_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_child[\"tx\"]))\n+\n+        # 3. Node requests the orphan's missing parent.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 4. The low parent + low child are submitted as a package. They are not accepted due to low package feerate.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+        assert low_fee_child[\"txid\"] not in node.getrawmempool()\n+\n+        # If peer_ignored announces the low feerate child, it should be ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+        # If either peer sends the parent again, package evaluation should not be attempted\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        peer_ignored.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 5. Send the high feerate (orphan) child\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 6. Node requests the orphan's parent, even though it has already been rejected, both by\n+        # itself and with a child. This is necessary, otherwise high_fee_child can be censored.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 7. The low feerate parent + high feerate child are submitted as a package.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 8. Both transactions should now be in mempool\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+        node.disconnect_p2ps()\n+\n+    def run_test(self):",
      "path": "test/functional/p2p_opportunistic_1p1c.py",
      "position": 377,
      "original_position": 177,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "c5e196b8e7b610cc9e6321b76fee4f0c45c1448e",
      "in_reply_to_id": 1551410174,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Last push should fix this with the above approach. Still need to write a test case for the peers being different.",
      "created_at": "2024-04-05T17:17:05Z",
      "updated_at": "2024-04-05T17:17:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1554024570",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1554024570"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 377,
      "original_line": 377,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1557310808",
      "pull_request_review_id": 1988568046,
      "id": 1557310808,
      "node_id": "PRRC_kwDOABII585c0q1Y",
      "diff_hunk": "@@ -596,6 +596,19 @@ class PeerManagerImpl final : public PeerManager\n     void ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, const std::list<CTransactionRef>& replaced_transactions)\n         EXCLUSIVE_LOCKS_REQUIRED(!m_peer_mutex, g_msgproc_mutex, cs_main);\n \n+    /** Handle the results of package validation: calls ProcessValidTx and ProcessInvalidTx for\n+     * individual transactions, and caches rejection for the package as a group.\n+     *   */",
      "path": "src/net_processing.cpp",
      "position": 17,
      "original_position": 6,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "e313001b1bf12f9fafeef1029d365af2c8f8126e",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n     * The senders arg should be populated in same order as individual transactions\r\n     * in the package_result argument.\r\n     */\r\n```",
      "created_at": "2024-04-09T09:28:38Z",
      "updated_at": "2024-04-10T07:27:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1557310808",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1557310808"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 603,
      "original_line": 603,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1558971541",
      "pull_request_review_id": 1988568046,
      "id": 1558971541,
      "node_id": "PRRC_kwDOABII585c7ASV",
      "diff_hunk": "@@ -3153,6 +3208,103 @@ void PeerManagerImpl::ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, c\n     }\n }\n \n+void PeerManagerImpl::ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, const std::vector<NodeId>& senders)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    if (package_result.m_state.IsInvalid()) {\n+        m_recent_rejects_reconsiderable.insert(GetPackageHash(package));\n+    }\n+    if (!Assume(!package.empty())) return;\n+\n+    // Iterate backwards to erase in-package descendants from the orphanage before they become\n+    // relevant in AddChildrenToWorkSet.\n+    for (auto i{package.size() - 1}; i >= 0; --i) {",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 135,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "e313001b1bf12f9fafeef1029d365af2c8f8126e",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```\r\nnet_processing.cpp:3224:40: warning: comparison of unsigned expression in ‘>= 0’ is always true [-Wtype-limits]\r\n 3224 |     for (auto i{package.size() - 1}; i >= 0; --i) {\r\n      |            \r\n```",
      "created_at": "2024-04-10T07:20:03Z",
      "updated_at": "2024-04-10T07:27:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1558971541",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1558971541"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3224,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1558979841",
      "pull_request_review_id": 1988568046,
      "id": 1558979841,
      "node_id": "PRRC_kwDOABII585c7CUB",
      "diff_hunk": "@@ -3153,6 +3208,103 @@ void PeerManagerImpl::ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, c\n     }\n }\n \n+void PeerManagerImpl::ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, const std::vector<NodeId>& senders)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    if (package_result.m_state.IsInvalid()) {\n+        m_recent_rejects_reconsiderable.insert(GetPackageHash(package));\n+    }\n+    if (!Assume(!package.empty())) return;\n+\n+    // Iterate backwards to erase in-package descendants from the orphanage before they become\n+    // relevant in AddChildrenToWorkSet.\n+    for (auto i{package.size() - 1}; i >= 0; --i) {",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 135,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "e313001b1bf12f9fafeef1029d365af2c8f8126e",
      "in_reply_to_id": 1558971541,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "this is also causing the sanitizer run failure",
      "created_at": "2024-04-10T07:27:21Z",
      "updated_at": "2024-04-10T07:27:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1558979841",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1558979841"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3224,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1559187981",
      "pull_request_review_id": 1991298023,
      "id": 1559187981,
      "node_id": "PRRC_kwDOABII585c71IN",
      "diff_hunk": "@@ -147,3 +147,17 @@ bool IsChildWithParentsTree(const Package& package)\n         return true;\n     });\n }\n+\n+uint256 GetCombinedHash(const std::vector<Wtxid>& wtxids)\n+{\n+    std::vector<Wtxid> wtxids_copy(wtxids.cbegin(), wtxids.cend());\n+    std::sort(wtxids_copy.begin(), wtxids_copy.end());\n+    return (HashWriter() << wtxids_copy).GetHash();\n+}",
      "path": "src/policy/packages.cpp",
      "position": null,
      "original_position": 10,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "c502734fa50104c18790ba0a5b63744552113110",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "newline?",
      "created_at": "2024-04-10T10:10:47Z",
      "updated_at": "2024-04-16T11:42:24Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1559187981",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1559187981"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 156,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1559188232",
      "pull_request_review_id": 1991298023,
      "id": 1559188232,
      "node_id": "PRRC_kwDOABII585c71MI",
      "diff_hunk": "@@ -88,4 +88,10 @@ bool IsChildWithParents(const Package& package);\n  * other (the package is a \"tree\").\n  */\n bool IsChildWithParentsTree(const Package& package);\n+\n+/** Get the hash of these wtxids, concatenated in lexicographical order. */\n+uint256 GetCombinedHash(const std::vector<Wtxid>& wtxids);\n+/** Get the hash of these transactions' wtxids, concatenated in lexicographical order. */",
      "path": "src/policy/packages.h",
      "position": null,
      "original_position": 7,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "c502734fa50104c18790ba0a5b63744552113110",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "newline?",
      "created_at": "2024-04-10T10:11:02Z",
      "updated_at": "2024-04-16T11:42:24Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1559188232",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1559188232"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 94,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1559354990",
      "pull_request_review_id": 1991563785,
      "id": 1559354990,
      "node_id": "PRRC_kwDOABII585c8d5u",
      "diff_hunk": "@@ -3153,6 +3208,103 @@ void PeerManagerImpl::ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, c\n     }\n }\n \n+void PeerManagerImpl::ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, const std::vector<NodeId>& senders)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    if (package_result.m_state.IsInvalid()) {\n+        m_recent_rejects_reconsiderable.insert(GetPackageHash(package));\n+    }\n+    if (!Assume(!package.empty())) return;\n+\n+    // Iterate backwards to erase in-package descendants from the orphanage before they become\n+    // relevant in AddChildrenToWorkSet.\n+    for (auto i{package.size() - 1}; i >= 0; --i) {",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 135,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "e313001b1bf12f9fafeef1029d365af2c8f8126e",
      "in_reply_to_id": 1558971541,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Woops yes will fix",
      "created_at": "2024-04-10T12:34:05Z",
      "updated_at": "2024-04-10T12:34:06Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1559354990",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1559354990"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3224,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1560983729",
      "pull_request_review_id": 1994122936,
      "id": 1560983729,
      "node_id": "PRRC_kwDOABII585dCrix",
      "diff_hunk": "@@ -596,6 +596,19 @@ class PeerManagerImpl final : public PeerManager\n     void ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, const std::list<CTransactionRef>& replaced_transactions)\n         EXCLUSIVE_LOCKS_REQUIRED(!m_peer_mutex, g_msgproc_mutex, cs_main);\n \n+    /** Handle the results of package validation: calls ProcessValidTx and ProcessInvalidTx for\n+     * individual transactions, and caches rejection for the package as a group.\n+     *   */",
      "path": "src/net_processing.cpp",
      "position": 17,
      "original_position": 6,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "e313001b1bf12f9fafeef1029d365af2c8f8126e",
      "in_reply_to_id": 1557310808,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "added something similar",
      "created_at": "2024-04-11T12:57:56Z",
      "updated_at": "2024-04-11T12:57:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1560983729",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1560983729"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 603,
      "original_line": 603,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1565949969",
      "pull_request_review_id": 2001371851,
      "id": 1565949969,
      "node_id": "PRRC_kwDOABII585dVoAR",
      "diff_hunk": "@@ -4354,7 +4354,9 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         const TxValidationState& state = result.m_state;\n \n         if (result.m_result_type == MempoolAcceptResult::ResultType::VALID) {\n-            ProcessValidTx(pfrom.GetId(), ptx, result.m_replaced_transactions.value());\n+            Assume(result.m_replaced_transactions.has_value());\n+            std::list<CTransactionRef> empty_replacement_list;\n+            ProcessValidTx(pfrom.GetId(), ptx, result.m_replaced_transactions.value_or(empty_replacement_list));",
      "path": "src/net_processing.cpp",
      "position": 320,
      "original_position": 7,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "53f1e65f30a0a6b931e97743113e0227748680df",
      "in_reply_to_id": 1550260907,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I asked myself the same question, found this discussion too late. I also think it would be good to mention this in the commit message (so it becomes clear that it has nothing to do with whether `m_replaced_transactions` has entries or is empty).",
      "created_at": "2024-04-15T15:04:37Z",
      "updated_at": "2024-04-15T21:02:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1565949969",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1565949969"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": 4357,
      "original_start_line": 4357,
      "start_side": "LEFT",
      "line": 4568,
      "original_line": 4568,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1566025027",
      "pull_request_review_id": 2001371851,
      "id": 1566025027,
      "node_id": "PRRC_kwDOABII585dV6VD",
      "diff_hunk": "@@ -88,4 +88,10 @@ bool IsChildWithParents(const Package& package);\n  * other (the package is a \"tree\").\n  */\n bool IsChildWithParentsTree(const Package& package);\n+\n+/** Get the hash of these wtxids, concatenated in lexicographical order. */",
      "path": "src/policy/packages.h",
      "position": null,
      "original_position": 5,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "75855a4d337d8eb1c432acd54b7b507a61232b48",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I think that they are sorted by internal order, not reversed-byte order (because they are sorted by `Wtxid` / `uint256`, not by `uint256.GetHex()`). Is that on purpose? In any case, maybe it would be useful to specify in the doc which order is used to avoid possbile confusion.\r\n\r\nAlso, the tests added in this commit only test for relative order between multiple transactions but not if they are actually sorted in lexicographical order, so that could also be done.",
      "created_at": "2024-04-15T15:59:17Z",
      "updated_at": "2024-04-15T21:03:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1566025027",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1566025027"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 92,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1566233731",
      "pull_request_review_id": 2001371851,
      "id": 1566233731,
      "node_id": "PRRC_kwDOABII585dWtSD",
      "diff_hunk": "@@ -3097,7 +3130,14 @@ void PeerManagerImpl::ProcessInvalidTx(NodeId nodeid, const CTransactionRef& ptx\n         // See also comments in https://github.com/bitcoin/bitcoin/pull/18044#discussion_r443419034\n         // for concerns around weakening security of unupgraded nodes\n         // if we start doing this too early.\n-        m_recent_rejects.insert(ptx->GetWitnessHash().ToUint256());\n+        if (state.GetResult() == TxValidationResult::TX_RECONSIDERABLE) {\n+            // If the result is TX_RECONSIDERABLE, add it to m_recent_rejects_reconsiderable\n+            // because we should not download or submit this transaction by itself again, but may\n+            // submit it as part of a package later.\n+            m_recent_rejects_reconsiderable.insert(ptx->GetWitnessHash().ToUint256());",
      "path": "src/net_processing.cpp",
      "position": 140,
      "original_position": 82,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "35351159736d71222eb358c21003881947215f3a",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Should update `ProcessInvalidTx` doc above too (it lists all member variables that the function updates). ",
      "created_at": "2024-04-15T17:56:58Z",
      "updated_at": "2024-04-15T21:02:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1566233731",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1566233731"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 3179,
      "original_line": 3179,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1566300445",
      "pull_request_review_id": 2001371851,
      "id": 1566300445,
      "node_id": "PRRC_kwDOABII585dW9kd",
      "diff_hunk": "@@ -3195,6 +3210,108 @@ void PeerManagerImpl::ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, c\n     }\n }\n \n+void PeerManagerImpl::ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, const std::vector<NodeId>& senders)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    if (package_result.m_state.IsInvalid()) {\n+        m_recent_rejects_reconsiderable.insert(GetPackageHash(package));\n+    }\n+    if (!Assume(!package.empty())) return;\n+\n+    // Iterate backwards to erase in-package descendants from the orphanage before they become\n+    // relevant in AddChildrenToWorkSet.\n+    auto package_iter = package.rbegin();\n+    auto senders_iter = senders.rbegin();\n+    while (package_iter != package.rend()) {\n+        const auto& tx = *package_iter;\n+        const NodeId nodeid = *senders_iter;\n+        const auto it_result{package_result.m_tx_results.find(tx->GetWitnessHash())};\n+        if (Assume(it_result != package_result.m_tx_results.end())) {\n+            const auto& tx_result = it_result->second;\n+            switch (tx_result.m_result_type) {\n+                case MempoolAcceptResult::ResultType::VALID:\n+                {\n+                    Assume(tx_result.m_replaced_transactions.has_value());\n+                    std::list<CTransactionRef> empty_replacement_list;\n+                    ProcessValidTx(nodeid, tx, tx_result.m_replaced_transactions.value_or(empty_replacement_list));\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::INVALID:\n+                case MempoolAcceptResult::ResultType::DIFFERENT_WITNESS:\n+                {\n+                    // Don't add to vExtraTxnForCompact, as these transactions should have already been\n+                    // added there when added to the orphanage or rejected for TX_RECONSIDERABLE.\n+                    // This should be updated if package submission is ever used for transactions\n+                    // that haven't already been validated before.\n+                    ProcessInvalidTx(nodeid, tx, tx_result.m_state, /*maybe_add_extra_compact_tx=*/false);\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::MEMPOOL_ENTRY:\n+                {\n+                    // AlreadyHaveTx() should be catching transactions that are already in mempool.\n+                    Assume(false);\n+                    break;\n+                }\n+            }\n+        }\n+        package_iter++;\n+        // There should be a sender for each tx, but fall back to the last one otherwise.\n+        if (Assume(senders_iter != senders.rend())) senders_iter++;\n+    }\n+}\n+\n+void PeerManagerImpl::MaybeProcess1P1CPackage(const CTransactionRef& ptx, NodeId nodeid)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    const auto cpfp_candidates{m_orphanage.GetChildren(ptx)};",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 85,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "f5989537e7969c14d41c451bbc1f962e498eb0e0",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "have you considered returning early here if `cpfp_candidates` is empty? It should work regardless, but seems conceptually simpler than checking all the steps below can handle that case (and may be slightly faster too).",
      "created_at": "2024-04-15T18:59:24Z",
      "updated_at": "2024-04-15T21:02:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1566300445",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1566300445"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3272,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1566329125",
      "pull_request_review_id": 2001371851,
      "id": 1566329125,
      "node_id": "PRRC_kwDOABII585dXEkl",
      "diff_hunk": "@@ -3195,6 +3210,108 @@ void PeerManagerImpl::ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, c\n     }\n }\n \n+void PeerManagerImpl::ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, const std::vector<NodeId>& senders)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    if (package_result.m_state.IsInvalid()) {\n+        m_recent_rejects_reconsiderable.insert(GetPackageHash(package));\n+    }\n+    if (!Assume(!package.empty())) return;",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 35,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "f5989537e7969c14d41c451bbc1f962e498eb0e0",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Could we assume more strictly here that the package size is 2 (for now)?",
      "created_at": "2024-04-15T19:27:21Z",
      "updated_at": "2024-04-15T21:02:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1566329125",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1566329125"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3222,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1566378431",
      "pull_request_review_id": 2001371851,
      "id": 1566378431,
      "node_id": "PRRC_kwDOABII585dXQm_",
      "diff_hunk": "@@ -3195,6 +3210,108 @@ void PeerManagerImpl::ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, c\n     }\n }\n \n+void PeerManagerImpl::ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, const std::vector<NodeId>& senders)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    if (package_result.m_state.IsInvalid()) {\n+        m_recent_rejects_reconsiderable.insert(GetPackageHash(package));\n+    }\n+    if (!Assume(!package.empty())) return;\n+\n+    // Iterate backwards to erase in-package descendants from the orphanage before they become\n+    // relevant in AddChildrenToWorkSet.\n+    auto package_iter = package.rbegin();\n+    auto senders_iter = senders.rbegin();\n+    while (package_iter != package.rend()) {\n+        const auto& tx = *package_iter;\n+        const NodeId nodeid = *senders_iter;\n+        const auto it_result{package_result.m_tx_results.find(tx->GetWitnessHash())};\n+        if (Assume(it_result != package_result.m_tx_results.end())) {\n+            const auto& tx_result = it_result->second;\n+            switch (tx_result.m_result_type) {\n+                case MempoolAcceptResult::ResultType::VALID:\n+                {\n+                    Assume(tx_result.m_replaced_transactions.has_value());\n+                    std::list<CTransactionRef> empty_replacement_list;\n+                    ProcessValidTx(nodeid, tx, tx_result.m_replaced_transactions.value_or(empty_replacement_list));\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::INVALID:\n+                case MempoolAcceptResult::ResultType::DIFFERENT_WITNESS:\n+                {\n+                    // Don't add to vExtraTxnForCompact, as these transactions should have already been\n+                    // added there when added to the orphanage or rejected for TX_RECONSIDERABLE.\n+                    // This should be updated if package submission is ever used for transactions\n+                    // that haven't already been validated before.\n+                    ProcessInvalidTx(nodeid, tx, tx_result.m_state, /*maybe_add_extra_compact_tx=*/false);\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::MEMPOOL_ENTRY:\n+                {\n+                    // AlreadyHaveTx() should be catching transactions that are already in mempool.\n+                    Assume(false);\n+                    break;\n+                }\n+            }\n+        }\n+        package_iter++;\n+        // There should be a sender for each tx, but fall back to the last one otherwise.\n+        if (Assume(senders_iter != senders.rend())) senders_iter++;\n+    }\n+}\n+\n+void PeerManagerImpl::MaybeProcess1P1CPackage(const CTransactionRef& ptx, NodeId nodeid)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    const auto cpfp_candidates{m_orphanage.GetChildren(ptx)};\n+\n+    const auto& parent_txid{ptx->GetHash()};\n+    const auto& parent_wtxid{ptx->GetWitnessHash()};\n+\n+    CTransactionRef tx_orphan{nullptr};\n+    NodeId orphan_sender{-1};\n+    Assume(m_recent_rejects_reconsiderable.contains(parent_wtxid.ToUint256()));\n+\n+    // Create a 1p1c package using the first child that hasn't already been rejected. Sort\n+    // the children in random order to not create a bias that attackers can use to delay\n+    // package acceptance. Create a random permutation of the indices.\n+    std::vector<size_t> tx_indices(cpfp_candidates.size());\n+    std::iota(tx_indices.begin(), tx_indices.end(), 0);\n+    Shuffle(tx_indices.begin(), tx_indices.end(), m_rng);\n+\n+    for (const auto index : tx_indices) {\n+        // If we already tried a package and failed for any reason, the combined hash was\n+        // cached in m_recent_rejects_reconsiderable.\n+        Package maybe_cpfp_package{ptx, cpfp_candidates.at(index).first};\n+        if (!m_recent_rejects_reconsiderable.contains(GetPackageHash(maybe_cpfp_package))) {",
      "path": "src/net_processing.cpp",
      "position": 237,
      "original_position": 105,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "f5989537e7969c14d41c451bbc1f962e498eb0e0",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Why put the package hash into `m_recent_rejects_reconsiderable` instead of `m_recent_rejects`?\r\nWe never reconsider a failed package after all as far as I understand it.",
      "created_at": "2024-04-15T20:15:35Z",
      "updated_at": "2024-04-15T21:02:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1566378431",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1566378431"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 3317,
      "original_line": 3317,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1566405746",
      "pull_request_review_id": 2001371851,
      "id": 1566405746,
      "node_id": "PRRC_kwDOABII585dXXRy",
      "diff_hunk": "@@ -3195,6 +3210,108 @@ void PeerManagerImpl::ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, c\n     }\n }\n \n+void PeerManagerImpl::ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, const std::vector<NodeId>& senders)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    if (package_result.m_state.IsInvalid()) {\n+        m_recent_rejects_reconsiderable.insert(GetPackageHash(package));\n+    }\n+    if (!Assume(!package.empty())) return;\n+\n+    // Iterate backwards to erase in-package descendants from the orphanage before they become\n+    // relevant in AddChildrenToWorkSet.\n+    auto package_iter = package.rbegin();\n+    auto senders_iter = senders.rbegin();\n+    while (package_iter != package.rend()) {\n+        const auto& tx = *package_iter;\n+        const NodeId nodeid = *senders_iter;\n+        const auto it_result{package_result.m_tx_results.find(tx->GetWitnessHash())};\n+        if (Assume(it_result != package_result.m_tx_results.end())) {\n+            const auto& tx_result = it_result->second;\n+            switch (tx_result.m_result_type) {\n+                case MempoolAcceptResult::ResultType::VALID:\n+                {\n+                    Assume(tx_result.m_replaced_transactions.has_value());\n+                    std::list<CTransactionRef> empty_replacement_list;\n+                    ProcessValidTx(nodeid, tx, tx_result.m_replaced_transactions.value_or(empty_replacement_list));\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::INVALID:\n+                case MempoolAcceptResult::ResultType::DIFFERENT_WITNESS:\n+                {\n+                    // Don't add to vExtraTxnForCompact, as these transactions should have already been\n+                    // added there when added to the orphanage or rejected for TX_RECONSIDERABLE.\n+                    // This should be updated if package submission is ever used for transactions\n+                    // that haven't already been validated before.\n+                    ProcessInvalidTx(nodeid, tx, tx_result.m_state, /*maybe_add_extra_compact_tx=*/false);\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::MEMPOOL_ENTRY:\n+                {\n+                    // AlreadyHaveTx() should be catching transactions that are already in mempool.\n+                    Assume(false);\n+                    break;\n+                }\n+            }\n+        }\n+        package_iter++;\n+        // There should be a sender for each tx, but fall back to the last one otherwise.\n+        if (Assume(senders_iter != senders.rend())) senders_iter++;\n+    }\n+}\n+\n+void PeerManagerImpl::MaybeProcess1P1CPackage(const CTransactionRef& ptx, NodeId nodeid)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    const auto cpfp_candidates{m_orphanage.GetChildren(ptx)};\n+\n+    const auto& parent_txid{ptx->GetHash()};\n+    const auto& parent_wtxid{ptx->GetWitnessHash()};\n+\n+    CTransactionRef tx_orphan{nullptr};\n+    NodeId orphan_sender{-1};\n+    Assume(m_recent_rejects_reconsiderable.contains(parent_wtxid.ToUint256()));\n+\n+    // Create a 1p1c package using the first child that hasn't already been rejected. Sort",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 94,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "f5989537e7969c14d41c451bbc1f962e498eb0e0",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Why do we only try once in the case there are multiple children in the orphanage, instead of trying multiple times until one package succeeds? To avoid some kind of spamming attacks that could exhaust our computing power?",
      "created_at": "2024-04-15T20:37:50Z",
      "updated_at": "2024-04-15T21:02:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1566405746",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1566405746"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3288,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1566889900",
      "pull_request_review_id": 2002880430,
      "id": 1566889900,
      "node_id": "PRRC_kwDOABII585dZNes",
      "diff_hunk": "@@ -3195,6 +3210,108 @@ void PeerManagerImpl::ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, c\n     }\n }\n \n+void PeerManagerImpl::ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, const std::vector<NodeId>& senders)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    if (package_result.m_state.IsInvalid()) {\n+        m_recent_rejects_reconsiderable.insert(GetPackageHash(package));\n+    }\n+    if (!Assume(!package.empty())) return;\n+\n+    // Iterate backwards to erase in-package descendants from the orphanage before they become\n+    // relevant in AddChildrenToWorkSet.\n+    auto package_iter = package.rbegin();\n+    auto senders_iter = senders.rbegin();\n+    while (package_iter != package.rend()) {\n+        const auto& tx = *package_iter;\n+        const NodeId nodeid = *senders_iter;\n+        const auto it_result{package_result.m_tx_results.find(tx->GetWitnessHash())};\n+        if (Assume(it_result != package_result.m_tx_results.end())) {\n+            const auto& tx_result = it_result->second;\n+            switch (tx_result.m_result_type) {\n+                case MempoolAcceptResult::ResultType::VALID:\n+                {\n+                    Assume(tx_result.m_replaced_transactions.has_value());\n+                    std::list<CTransactionRef> empty_replacement_list;\n+                    ProcessValidTx(nodeid, tx, tx_result.m_replaced_transactions.value_or(empty_replacement_list));\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::INVALID:\n+                case MempoolAcceptResult::ResultType::DIFFERENT_WITNESS:\n+                {\n+                    // Don't add to vExtraTxnForCompact, as these transactions should have already been\n+                    // added there when added to the orphanage or rejected for TX_RECONSIDERABLE.\n+                    // This should be updated if package submission is ever used for transactions\n+                    // that haven't already been validated before.\n+                    ProcessInvalidTx(nodeid, tx, tx_result.m_state, /*maybe_add_extra_compact_tx=*/false);\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::MEMPOOL_ENTRY:\n+                {\n+                    // AlreadyHaveTx() should be catching transactions that are already in mempool.\n+                    Assume(false);\n+                    break;\n+                }\n+            }\n+        }\n+        package_iter++;\n+        // There should be a sender for each tx, but fall back to the last one otherwise.\n+        if (Assume(senders_iter != senders.rend())) senders_iter++;\n+    }\n+}\n+\n+void PeerManagerImpl::MaybeProcess1P1CPackage(const CTransactionRef& ptx, NodeId nodeid)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    const auto cpfp_candidates{m_orphanage.GetChildren(ptx)};\n+\n+    const auto& parent_txid{ptx->GetHash()};\n+    const auto& parent_wtxid{ptx->GetWitnessHash()};\n+\n+    CTransactionRef tx_orphan{nullptr};\n+    NodeId orphan_sender{-1};\n+    Assume(m_recent_rejects_reconsiderable.contains(parent_wtxid.ToUint256()));\n+\n+    // Create a 1p1c package using the first child that hasn't already been rejected. Sort",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 94,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "f5989537e7969c14d41c451bbc1f962e498eb0e0",
      "in_reply_to_id": 1566405746,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Yes exactly, this is to bound computation (imagine if somebody sent us 100 fake orphans descended from 1 transaction and we processed them all here). My idea was to do something similar to regular orphan processing, where we have a work queue and limit to 1 item per `ProcessMessages`.\r\n\r\nThere is no work queue here, though, and we drop the parent as soon as we try 1 (pass or fail). At coredev, we discussed adding a work queue for 1p1c as well. However, since it involves finding a way to store the low feerate parent, and we have plenty of low hanging fruit for improving orphan handling, we'll save that for a later PR.",
      "created_at": "2024-04-16T07:51:17Z",
      "updated_at": "2024-04-16T07:51:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1566889900",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1566889900"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3288,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1566907728",
      "pull_request_review_id": 2002909080,
      "id": 1566907728,
      "node_id": "PRRC_kwDOABII585dZR1Q",
      "diff_hunk": "@@ -3195,6 +3210,108 @@ void PeerManagerImpl::ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, c\n     }\n }\n \n+void PeerManagerImpl::ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, const std::vector<NodeId>& senders)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    if (package_result.m_state.IsInvalid()) {\n+        m_recent_rejects_reconsiderable.insert(GetPackageHash(package));\n+    }\n+    if (!Assume(!package.empty())) return;\n+\n+    // Iterate backwards to erase in-package descendants from the orphanage before they become\n+    // relevant in AddChildrenToWorkSet.\n+    auto package_iter = package.rbegin();\n+    auto senders_iter = senders.rbegin();\n+    while (package_iter != package.rend()) {\n+        const auto& tx = *package_iter;\n+        const NodeId nodeid = *senders_iter;\n+        const auto it_result{package_result.m_tx_results.find(tx->GetWitnessHash())};\n+        if (Assume(it_result != package_result.m_tx_results.end())) {\n+            const auto& tx_result = it_result->second;\n+            switch (tx_result.m_result_type) {\n+                case MempoolAcceptResult::ResultType::VALID:\n+                {\n+                    Assume(tx_result.m_replaced_transactions.has_value());\n+                    std::list<CTransactionRef> empty_replacement_list;\n+                    ProcessValidTx(nodeid, tx, tx_result.m_replaced_transactions.value_or(empty_replacement_list));\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::INVALID:\n+                case MempoolAcceptResult::ResultType::DIFFERENT_WITNESS:\n+                {\n+                    // Don't add to vExtraTxnForCompact, as these transactions should have already been\n+                    // added there when added to the orphanage or rejected for TX_RECONSIDERABLE.\n+                    // This should be updated if package submission is ever used for transactions\n+                    // that haven't already been validated before.\n+                    ProcessInvalidTx(nodeid, tx, tx_result.m_state, /*maybe_add_extra_compact_tx=*/false);\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::MEMPOOL_ENTRY:\n+                {\n+                    // AlreadyHaveTx() should be catching transactions that are already in mempool.\n+                    Assume(false);\n+                    break;\n+                }\n+            }\n+        }\n+        package_iter++;\n+        // There should be a sender for each tx, but fall back to the last one otherwise.\n+        if (Assume(senders_iter != senders.rend())) senders_iter++;\n+    }\n+}\n+\n+void PeerManagerImpl::MaybeProcess1P1CPackage(const CTransactionRef& ptx, NodeId nodeid)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    const auto cpfp_candidates{m_orphanage.GetChildren(ptx)};\n+\n+    const auto& parent_txid{ptx->GetHash()};\n+    const auto& parent_wtxid{ptx->GetWitnessHash()};\n+\n+    CTransactionRef tx_orphan{nullptr};\n+    NodeId orphan_sender{-1};\n+    Assume(m_recent_rejects_reconsiderable.contains(parent_wtxid.ToUint256()));\n+\n+    // Create a 1p1c package using the first child that hasn't already been rejected. Sort\n+    // the children in random order to not create a bias that attackers can use to delay\n+    // package acceptance. Create a random permutation of the indices.\n+    std::vector<size_t> tx_indices(cpfp_candidates.size());\n+    std::iota(tx_indices.begin(), tx_indices.end(), 0);\n+    Shuffle(tx_indices.begin(), tx_indices.end(), m_rng);\n+\n+    for (const auto index : tx_indices) {\n+        // If we already tried a package and failed for any reason, the combined hash was\n+        // cached in m_recent_rejects_reconsiderable.\n+        Package maybe_cpfp_package{ptx, cpfp_candidates.at(index).first};\n+        if (!m_recent_rejects_reconsiderable.contains(GetPackageHash(maybe_cpfp_package))) {",
      "path": "src/net_processing.cpp",
      "position": 237,
      "original_position": 105,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "f5989537e7969c14d41c451bbc1f962e498eb0e0",
      "in_reply_to_id": 1566378431,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Yes I think we could use either `m_recent_rejects_reconsiderable` and `m_recent_rejects` right now to get the same behavior.\r\n\r\nI suppose one mild benefit of using `m_recent_rejects_reconsiderable` is that our `m_recent_rejects` bloom filter churns less frequently.\r\n\r\n~The other benefit is extensibility in the future. In more general ancestor package relay, we could reject a parent+child for being too low feerate, but later accept it as parent+child+grandchild (where the grandchild is very high feerate).~",
      "created_at": "2024-04-16T08:03:26Z",
      "updated_at": "2024-04-16T12:25:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1566907728",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1566907728"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 3317,
      "original_line": 3317,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1567146604",
      "pull_request_review_id": 2003285723,
      "id": 1567146604,
      "node_id": "PRRC_kwDOABII585daMJs",
      "diff_hunk": "@@ -88,4 +88,10 @@ bool IsChildWithParents(const Package& package);\n  * other (the package is a \"tree\").\n  */\n bool IsChildWithParentsTree(const Package& package);\n+\n+/** Get the hash of these wtxids, concatenated in lexicographical order. */",
      "path": "src/policy/packages.h",
      "position": null,
      "original_position": 5,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "75855a4d337d8eb1c432acd54b7b507a61232b48",
      "in_reply_to_id": 1566025027,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I've added more explicit tests and changed this to be ordered based on `uint256.GetHex()` instead. I don't know enough to say which sorting is better here, but this seems like the natural ordering when I'm reading the hex strings as a human.",
      "created_at": "2024-04-16T10:49:28Z",
      "updated_at": "2024-04-16T11:09:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1567146604",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1567146604"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 92,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1567165968",
      "pull_request_review_id": 2003285723,
      "id": 1567165968,
      "node_id": "PRRC_kwDOABII585daQ4Q",
      "diff_hunk": "@@ -4354,7 +4354,9 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         const TxValidationState& state = result.m_state;\n \n         if (result.m_result_type == MempoolAcceptResult::ResultType::VALID) {\n-            ProcessValidTx(pfrom.GetId(), ptx, result.m_replaced_transactions.value());\n+            Assume(result.m_replaced_transactions.has_value());\n+            std::list<CTransactionRef> empty_replacement_list;\n+            ProcessValidTx(pfrom.GetId(), ptx, result.m_replaced_transactions.value_or(empty_replacement_list));",
      "path": "src/net_processing.cpp",
      "position": 320,
      "original_position": 7,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "53f1e65f30a0a6b931e97743113e0227748680df",
      "in_reply_to_id": 1550260907,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Elaborated in commit message",
      "created_at": "2024-04-16T11:05:57Z",
      "updated_at": "2024-04-16T11:09:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1567165968",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1567165968"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": 4357,
      "original_start_line": 4357,
      "start_side": "LEFT",
      "line": 4568,
      "original_line": 4568,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1567166206",
      "pull_request_review_id": 2003285723,
      "id": 1567166206,
      "node_id": "PRRC_kwDOABII585daQ7-",
      "diff_hunk": "@@ -3195,6 +3210,108 @@ void PeerManagerImpl::ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, c\n     }\n }\n \n+void PeerManagerImpl::ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, const std::vector<NodeId>& senders)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    if (package_result.m_state.IsInvalid()) {\n+        m_recent_rejects_reconsiderable.insert(GetPackageHash(package));\n+    }\n+    if (!Assume(!package.empty())) return;\n+\n+    // Iterate backwards to erase in-package descendants from the orphanage before they become\n+    // relevant in AddChildrenToWorkSet.\n+    auto package_iter = package.rbegin();\n+    auto senders_iter = senders.rbegin();\n+    while (package_iter != package.rend()) {\n+        const auto& tx = *package_iter;\n+        const NodeId nodeid = *senders_iter;\n+        const auto it_result{package_result.m_tx_results.find(tx->GetWitnessHash())};\n+        if (Assume(it_result != package_result.m_tx_results.end())) {\n+            const auto& tx_result = it_result->second;\n+            switch (tx_result.m_result_type) {\n+                case MempoolAcceptResult::ResultType::VALID:\n+                {\n+                    Assume(tx_result.m_replaced_transactions.has_value());\n+                    std::list<CTransactionRef> empty_replacement_list;\n+                    ProcessValidTx(nodeid, tx, tx_result.m_replaced_transactions.value_or(empty_replacement_list));\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::INVALID:\n+                case MempoolAcceptResult::ResultType::DIFFERENT_WITNESS:\n+                {\n+                    // Don't add to vExtraTxnForCompact, as these transactions should have already been\n+                    // added there when added to the orphanage or rejected for TX_RECONSIDERABLE.\n+                    // This should be updated if package submission is ever used for transactions\n+                    // that haven't already been validated before.\n+                    ProcessInvalidTx(nodeid, tx, tx_result.m_state, /*maybe_add_extra_compact_tx=*/false);\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::MEMPOOL_ENTRY:\n+                {\n+                    // AlreadyHaveTx() should be catching transactions that are already in mempool.\n+                    Assume(false);\n+                    break;\n+                }\n+            }\n+        }\n+        package_iter++;\n+        // There should be a sender for each tx, but fall back to the last one otherwise.\n+        if (Assume(senders_iter != senders.rend())) senders_iter++;\n+    }\n+}\n+\n+void PeerManagerImpl::MaybeProcess1P1CPackage(const CTransactionRef& ptx, NodeId nodeid)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    const auto cpfp_candidates{m_orphanage.GetChildren(ptx)};",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 85,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "f5989537e7969c14d41c451bbc1f962e498eb0e0",
      "in_reply_to_id": 1566300445,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done, and edited the logging a bit",
      "created_at": "2024-04-16T11:06:11Z",
      "updated_at": "2024-04-16T11:09:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1567166206",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1567166206"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3272,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1567166366",
      "pull_request_review_id": 2003285723,
      "id": 1567166366,
      "node_id": "PRRC_kwDOABII585daQ-e",
      "diff_hunk": "@@ -3195,6 +3210,108 @@ void PeerManagerImpl::ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, c\n     }\n }\n \n+void PeerManagerImpl::ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, const std::vector<NodeId>& senders)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    if (package_result.m_state.IsInvalid()) {\n+        m_recent_rejects_reconsiderable.insert(GetPackageHash(package));\n+    }\n+    if (!Assume(!package.empty())) return;",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 35,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "f5989537e7969c14d41c451bbc1f962e498eb0e0",
      "in_reply_to_id": 1566329125,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "added",
      "created_at": "2024-04-16T11:06:16Z",
      "updated_at": "2024-04-16T11:09:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1567166366",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1567166366"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3222,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1567166471",
      "pull_request_review_id": 2003285723,
      "id": 1567166471,
      "node_id": "PRRC_kwDOABII585daRAH",
      "diff_hunk": "@@ -3097,7 +3130,14 @@ void PeerManagerImpl::ProcessInvalidTx(NodeId nodeid, const CTransactionRef& ptx\n         // See also comments in https://github.com/bitcoin/bitcoin/pull/18044#discussion_r443419034\n         // for concerns around weakening security of unupgraded nodes\n         // if we start doing this too early.\n-        m_recent_rejects.insert(ptx->GetWitnessHash().ToUint256());\n+        if (state.GetResult() == TxValidationResult::TX_RECONSIDERABLE) {\n+            // If the result is TX_RECONSIDERABLE, add it to m_recent_rejects_reconsiderable\n+            // because we should not download or submit this transaction by itself again, but may\n+            // submit it as part of a package later.\n+            m_recent_rejects_reconsiderable.insert(ptx->GetWitnessHash().ToUint256());",
      "path": "src/net_processing.cpp",
      "position": 140,
      "original_position": 82,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "35351159736d71222eb358c21003881947215f3a",
      "in_reply_to_id": 1566233731,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "updated",
      "created_at": "2024-04-16T11:06:22Z",
      "updated_at": "2024-04-16T11:09:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1567166471",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1567166471"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 3179,
      "original_line": 3179,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1567166818",
      "pull_request_review_id": 2003285723,
      "id": 1567166818,
      "node_id": "PRRC_kwDOABII585daRFi",
      "diff_hunk": "@@ -806,7 +806,7 @@ class PeerManagerImpl final : public PeerManager\n     /** Stalling timeout for blocks in IBD */\n     std::atomic<std::chrono::seconds> m_block_stalling_timeout{BLOCK_STALLING_TIMEOUT_DEFAULT};\n \n-    bool AlreadyHaveTx(const GenTxid& gtxid)\n+    bool AlreadyHaveTx(const GenTxid& gtxid, bool include_reconsiderable)",
      "path": "src/net_processing.cpp",
      "position": 69,
      "original_position": 5,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "826b31b5a3bef4adb3d1d9145d1452b8e91fda46",
      "in_reply_to_id": 1549414682,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "marking as resolved since #29827 does this",
      "created_at": "2024-04-16T11:06:43Z",
      "updated_at": "2024-04-16T11:09:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1567166818",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1567166818"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 857,
      "original_line": 857,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1567205749",
      "pull_request_review_id": 1991298023,
      "id": 1567205749,
      "node_id": "PRRC_kwDOABII585daal1",
      "diff_hunk": "@@ -3195,6 +3210,108 @@ void PeerManagerImpl::ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, c\n     }\n }\n \n+void PeerManagerImpl::ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, const std::vector<NodeId>& senders)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    if (package_result.m_state.IsInvalid()) {\n+        m_recent_rejects_reconsiderable.insert(GetPackageHash(package));\n+    }\n+    if (!Assume(!package.empty())) return;\n+\n+    // Iterate backwards to erase in-package descendants from the orphanage before they become\n+    // relevant in AddChildrenToWorkSet.\n+    auto package_iter = package.rbegin();\n+    auto senders_iter = senders.rbegin();\n+    while (package_iter != package.rend()) {\n+        const auto& tx = *package_iter;\n+        const NodeId nodeid = *senders_iter;\n+        const auto it_result{package_result.m_tx_results.find(tx->GetWitnessHash())};\n+        if (Assume(it_result != package_result.m_tx_results.end())) {\n+            const auto& tx_result = it_result->second;\n+            switch (tx_result.m_result_type) {\n+                case MempoolAcceptResult::ResultType::VALID:\n+                {\n+                    Assume(tx_result.m_replaced_transactions.has_value());\n+                    std::list<CTransactionRef> empty_replacement_list;\n+                    ProcessValidTx(nodeid, tx, tx_result.m_replaced_transactions.value_or(empty_replacement_list));\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::INVALID:\n+                case MempoolAcceptResult::ResultType::DIFFERENT_WITNESS:\n+                {\n+                    // Don't add to vExtraTxnForCompact, as these transactions should have already been\n+                    // added there when added to the orphanage or rejected for TX_RECONSIDERABLE.\n+                    // This should be updated if package submission is ever used for transactions\n+                    // that haven't already been validated before.\n+                    ProcessInvalidTx(nodeid, tx, tx_result.m_state, /*maybe_add_extra_compact_tx=*/false);\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::MEMPOOL_ENTRY:\n+                {\n+                    // AlreadyHaveTx() should be catching transactions that are already in mempool.\n+                    Assume(false);\n+                    break;\n+                }\n+            }\n+        }\n+        package_iter++;\n+        // There should be a sender for each tx, but fall back to the last one otherwise.\n+        if (Assume(senders_iter != senders.rend())) senders_iter++;\n+    }\n+}\n+\n+void PeerManagerImpl::MaybeProcess1P1CPackage(const CTransactionRef& ptx, NodeId nodeid)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    const auto cpfp_candidates{m_orphanage.GetChildren(ptx)};\n+\n+    const auto& parent_txid{ptx->GetHash()};\n+    const auto& parent_wtxid{ptx->GetWitnessHash()};\n+\n+    CTransactionRef tx_orphan{nullptr};\n+    NodeId orphan_sender{-1};\n+    Assume(m_recent_rejects_reconsiderable.contains(parent_wtxid.ToUint256()));\n+\n+    // Create a 1p1c package using the first child that hasn't already been rejected. Sort\n+    // the children in random order to not create a bias that attackers can use to delay\n+    // package acceptance. Create a random permutation of the indices.\n+    std::vector<size_t> tx_indices(cpfp_candidates.size());\n+    std::iota(tx_indices.begin(), tx_indices.end(), 0);\n+    Shuffle(tx_indices.begin(), tx_indices.end(), m_rng);\n+\n+    for (const auto index : tx_indices) {\n+        // If we already tried a package and failed for any reason, the combined hash was\n+        // cached in m_recent_rejects_reconsiderable.\n+        Package maybe_cpfp_package{ptx, cpfp_candidates.at(index).first};\n+        if (!m_recent_rejects_reconsiderable.contains(GetPackageHash(maybe_cpfp_package))) {",
      "path": "src/net_processing.cpp",
      "position": 237,
      "original_position": 105,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "f5989537e7969c14d41c451bbc1f962e498eb0e0",
      "in_reply_to_id": 1566378431,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> The other benefit is extensibility in the future. In more general ancestor package relay, we could reject a parent+child for being too low feerate, but later accept it as parent+child+grandchild (where the grandchild is very high feerate).\r\n\r\nPerhaps this doesn't matter but I'm not sure I understand the distinction here. We need the combined hash committed *somewhere* in a bloom filter to not fetch the same ancestor package again. If it's different at all, we'll fetch it regardless of which filter we add it to?",
      "created_at": "2024-04-16T11:36:45Z",
      "updated_at": "2024-04-16T11:42:24Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1567205749",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1567205749"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 3317,
      "original_line": 3317,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1567269406",
      "pull_request_review_id": 2003481893,
      "id": 1567269406,
      "node_id": "PRRC_kwDOABII585daqIe",
      "diff_hunk": "@@ -3195,6 +3210,108 @@ void PeerManagerImpl::ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, c\n     }\n }\n \n+void PeerManagerImpl::ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, const std::vector<NodeId>& senders)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    if (package_result.m_state.IsInvalid()) {\n+        m_recent_rejects_reconsiderable.insert(GetPackageHash(package));\n+    }\n+    if (!Assume(!package.empty())) return;\n+\n+    // Iterate backwards to erase in-package descendants from the orphanage before they become\n+    // relevant in AddChildrenToWorkSet.\n+    auto package_iter = package.rbegin();\n+    auto senders_iter = senders.rbegin();\n+    while (package_iter != package.rend()) {\n+        const auto& tx = *package_iter;\n+        const NodeId nodeid = *senders_iter;\n+        const auto it_result{package_result.m_tx_results.find(tx->GetWitnessHash())};\n+        if (Assume(it_result != package_result.m_tx_results.end())) {\n+            const auto& tx_result = it_result->second;\n+            switch (tx_result.m_result_type) {\n+                case MempoolAcceptResult::ResultType::VALID:\n+                {\n+                    Assume(tx_result.m_replaced_transactions.has_value());\n+                    std::list<CTransactionRef> empty_replacement_list;\n+                    ProcessValidTx(nodeid, tx, tx_result.m_replaced_transactions.value_or(empty_replacement_list));\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::INVALID:\n+                case MempoolAcceptResult::ResultType::DIFFERENT_WITNESS:\n+                {\n+                    // Don't add to vExtraTxnForCompact, as these transactions should have already been\n+                    // added there when added to the orphanage or rejected for TX_RECONSIDERABLE.\n+                    // This should be updated if package submission is ever used for transactions\n+                    // that haven't already been validated before.\n+                    ProcessInvalidTx(nodeid, tx, tx_result.m_state, /*maybe_add_extra_compact_tx=*/false);\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::MEMPOOL_ENTRY:\n+                {\n+                    // AlreadyHaveTx() should be catching transactions that are already in mempool.\n+                    Assume(false);\n+                    break;\n+                }\n+            }\n+        }\n+        package_iter++;\n+        // There should be a sender for each tx, but fall back to the last one otherwise.\n+        if (Assume(senders_iter != senders.rend())) senders_iter++;\n+    }\n+}\n+\n+void PeerManagerImpl::MaybeProcess1P1CPackage(const CTransactionRef& ptx, NodeId nodeid)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    const auto cpfp_candidates{m_orphanage.GetChildren(ptx)};\n+\n+    const auto& parent_txid{ptx->GetHash()};\n+    const auto& parent_wtxid{ptx->GetWitnessHash()};\n+\n+    CTransactionRef tx_orphan{nullptr};\n+    NodeId orphan_sender{-1};\n+    Assume(m_recent_rejects_reconsiderable.contains(parent_wtxid.ToUint256()));\n+\n+    // Create a 1p1c package using the first child that hasn't already been rejected. Sort\n+    // the children in random order to not create a bias that attackers can use to delay\n+    // package acceptance. Create a random permutation of the indices.\n+    std::vector<size_t> tx_indices(cpfp_candidates.size());\n+    std::iota(tx_indices.begin(), tx_indices.end(), 0);\n+    Shuffle(tx_indices.begin(), tx_indices.end(), m_rng);\n+\n+    for (const auto index : tx_indices) {\n+        // If we already tried a package and failed for any reason, the combined hash was\n+        // cached in m_recent_rejects_reconsiderable.\n+        Package maybe_cpfp_package{ptx, cpfp_candidates.at(index).first};\n+        if (!m_recent_rejects_reconsiderable.contains(GetPackageHash(maybe_cpfp_package))) {",
      "path": "src/net_processing.cpp",
      "position": 237,
      "original_position": 105,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "f5989537e7969c14d41c451bbc1f962e498eb0e0",
      "in_reply_to_id": 1566378431,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Hm I think you're right, it wouldn't make a difference with downloads. Crossing that part out. Were we thinking of this within validation maybe? Linearize + chunk the package, see that a chunk has already been rejected as too low feerate, drop it?",
      "created_at": "2024-04-16T12:25:36Z",
      "updated_at": "2024-04-16T12:25:36Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1567269406",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1567269406"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 3317,
      "original_line": 3317,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1567718964",
      "pull_request_review_id": 2004232080,
      "id": 1567718964,
      "node_id": "PRRC_kwDOABII585dcX40",
      "diff_hunk": "@@ -0,0 +1,241 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test opportunistic 1p1c package submission logic.\n+\"\"\"\n+\n+from decimal import Decimal\n+from test_framework.messages import (\n+    CInv,\n+    CTxInWitness,\n+    MSG_WTX,\n+    msg_inv,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    fill_mempool,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+        ]]\n+        self.supports_cli = False\n+\n+    def test_basic_child_then_parent(self):\n+        node = self.nodes[0]\n+        self.log.info(\"Check that opportunistic 1p1c logic works when child is received before parent\")\n+\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first (perhaps the low feerate parent didn't meet feefilter or the requests were sent to different nodes). It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. Sender relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 4. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+        node.disconnect_p2ps()\n+\n+    def test_basic_parent_then_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=1, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=2, connection_type=\"outbound-full-relay\")\n+\n+        # 1. Parent is relayed first. It is too low feerate.\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer_sender.wait_for_getdata([parent_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer_ignored, check that it is ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+\n+        # 2. Child is relayed next. It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 3. Node requests the missing parent by txid.\n+        # It should do so even if it has previously rejected that parent for being too low feerate.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 4. Sender re-relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 5. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+        node.disconnect_p2ps()\n+\n+    def test_low_and_high_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        low_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=2*FEERATE_1SAT_VB)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=3, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=4, connection_type=\"outbound-full-relay\")\n+\n+        self.log.info(\"Check that tx caches low fee parent + low fee child package rejections\")\n+\n+        # 1. Send parent, rejected for being low feerate.\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer_sender.wait_for_getdata([parent_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer_ignored, check that it is ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+\n+        # 2. Send an (orphan) child that has a higher feerate, but not enough to bump the parent.\n+        low_child_wtxid_int = int(low_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([low_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_child[\"tx\"]))\n+\n+        # 3. Node requests the orphan's missing parent.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 4. The low parent + low child are submitted as a package. They are not accepted due to low package feerate.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+        assert low_fee_child[\"txid\"] not in node.getrawmempool()\n+\n+        # If peer_ignored announces the low feerate child, it should be ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+        # If either peer sends the parent again, package evaluation should not be attempted\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        peer_ignored.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 5. Send the high feerate (orphan) child\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 6. Node requests the orphan's parent, even though it has already been rejected, both by\n+        # itself and with a child. This is necessary, otherwise high_fee_child can be censored.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 7. The low feerate parent + high feerate child are submitted as a package.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 8. Both transactions should now be in mempool\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+        node.disconnect_p2ps()\n+\n+    def test_orphan_consensus_failure(self):\n+        node = self.nodes[0]\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        coin = low_fee_parent[\"new_utxo\"]\n+        address = node.get_deterministic_priv_key().address\n+        # Create raw transaction spending the parent, but with no signature (a consensus error).\n+        hex_orphan_no_sig = node.createrawtransaction([{\"txid\": coin[\"txid\"], \"vout\": coin[\"vout\"]}], {address : coin[\"value\"] - Decimal(\"0.0001\")})\n+        tx_orphan_bad_wit = tx_from_hex(hex_orphan_no_sig)\n+        tx_orphan_bad_wit.wit.vtxinwit.append(CTxInWitness())\n+        tx_orphan_bad_wit.wit.vtxinwit[0].scriptWitness.stack = [b'garbage']\n+\n+        peer_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first. It is missing an input.\n+        child_wtxid_int = int(tx_orphan_bad_wit.getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(tx_orphan_bad_wit))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. Sender relays the parent. Parent+Child are evaluated as a package and accepted.",
      "path": "test/functional/p2p_opportunistic_1p1c.py",
      "position": null,
      "original_position": 201,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "142d584dab3725081344520bec0a092d6b58d996",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```Suggestion\r\n        # 3. Sender relays the parent. Parent+Child are evaluated as a package and rejected.\r\n```",
      "created_at": "2024-04-16T17:25:54Z",
      "updated_at": "2024-04-16T17:48:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1567718964",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1567718964"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 201,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1567724841",
      "pull_request_review_id": 2004232080,
      "id": 1567724841,
      "node_id": "PRRC_kwDOABII585dcZUp",
      "diff_hunk": "@@ -0,0 +1,241 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test opportunistic 1p1c package submission logic.\n+\"\"\"\n+\n+from decimal import Decimal\n+from test_framework.messages import (\n+    CInv,\n+    CTxInWitness,\n+    MSG_WTX,\n+    msg_inv,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    fill_mempool,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+        ]]\n+        self.supports_cli = False\n+\n+    def test_basic_child_then_parent(self):\n+        node = self.nodes[0]\n+        self.log.info(\"Check that opportunistic 1p1c logic works when child is received before parent\")\n+\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first (perhaps the low feerate parent didn't meet feefilter or the requests were sent to different nodes). It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. Sender relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 4. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+        node.disconnect_p2ps()\n+\n+    def test_basic_parent_then_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=1, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=2, connection_type=\"outbound-full-relay\")\n+\n+        # 1. Parent is relayed first. It is too low feerate.\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer_sender.wait_for_getdata([parent_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer_ignored, check that it is ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+\n+        # 2. Child is relayed next. It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 3. Node requests the missing parent by txid.\n+        # It should do so even if it has previously rejected that parent for being too low feerate.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 4. Sender re-relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 5. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+        node.disconnect_p2ps()\n+\n+    def test_low_and_high_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        low_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=2*FEERATE_1SAT_VB)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=3, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=4, connection_type=\"outbound-full-relay\")\n+\n+        self.log.info(\"Check that tx caches low fee parent + low fee child package rejections\")\n+\n+        # 1. Send parent, rejected for being low feerate.\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer_sender.wait_for_getdata([parent_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer_ignored, check that it is ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+\n+        # 2. Send an (orphan) child that has a higher feerate, but not enough to bump the parent.\n+        low_child_wtxid_int = int(low_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([low_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_child[\"tx\"]))\n+\n+        # 3. Node requests the orphan's missing parent.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 4. The low parent + low child are submitted as a package. They are not accepted due to low package feerate.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+        assert low_fee_child[\"txid\"] not in node.getrawmempool()\n+\n+        # If peer_ignored announces the low feerate child, it should be ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+        # If either peer sends the parent again, package evaluation should not be attempted\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        peer_ignored.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 5. Send the high feerate (orphan) child\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 6. Node requests the orphan's parent, even though it has already been rejected, both by\n+        # itself and with a child. This is necessary, otherwise high_fee_child can be censored.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 7. The low feerate parent + high feerate child are submitted as a package.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 8. Both transactions should now be in mempool\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+        node.disconnect_p2ps()\n+\n+    def test_orphan_consensus_failure(self):\n+        node = self.nodes[0]\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        coin = low_fee_parent[\"new_utxo\"]\n+        address = node.get_deterministic_priv_key().address\n+        # Create raw transaction spending the parent, but with no signature (a consensus error).\n+        hex_orphan_no_sig = node.createrawtransaction([{\"txid\": coin[\"txid\"], \"vout\": coin[\"vout\"]}], {address : coin[\"value\"] - Decimal(\"0.0001\")})\n+        tx_orphan_bad_wit = tx_from_hex(hex_orphan_no_sig)\n+        tx_orphan_bad_wit.wit.vtxinwit.append(CTxInWitness())\n+        tx_orphan_bad_wit.wit.vtxinwit[0].scriptWitness.stack = [b'garbage']\n+\n+        peer_sender = node.add_p2p_connection(P2PInterface())",
      "path": "test/functional/p2p_opportunistic_1p1c.py",
      "position": null,
      "original_position": 189,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "142d584dab3725081344520bec0a092d6b58d996",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "would be good to explicitly test that the parent-giver isn't punished in this scenario, and test if parent is consensus-bad it results in something expected.\r\n\r\n```\r\ndiff --git a/test/functional/p2p_opportunistic_1p1c.py b/test/functional/p2p_opportunistic_1p1c.py\r\nindex 603cbf08a9..1c887289dc 100755\r\n--- a/test/functional/p2p_opportunistic_1p1c.py\r\n+++ b/test/functional/p2p_opportunistic_1p1c.py\r\n@@ -164,78 +164,129 @@ class PackageRelayTest(BitcoinTestFramework):\r\n         # itself and with a child. This is necessary, otherwise high_fee_child can be censored.\r\n         parent_txid_int = int(low_fee_parent[\"txid\"], 16)\r\n         peer_sender.wait_for_getdata([parent_txid_int])\r\n \r\n         # 7. The low feerate parent + high feerate child are submitted as a package.\r\n         peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\r\n \r\n         # 8. Both transactions should now be in mempool\r\n         node_mempool = node.getrawmempool()\r\n         assert low_fee_parent[\"txid\"] in node_mempool\r\n         assert high_fee_child[\"txid\"] in node_mempool\r\n \r\n         node.disconnect_p2ps()\r\n \r\n     def test_orphan_consensus_failure(self):\r\n         node = self.nodes[0]\r\n         low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\r\n         coin = low_fee_parent[\"new_utxo\"]\r\n         address = node.get_deterministic_priv_key().address\r\n         # Create raw transaction spending the parent, but with no signature (a consensus error).\r\n         hex_orphan_no_sig = node.createrawtransaction([{\"txid\": coin[\"txid\"], \"vout\": coin[\"vout\"]}], {address : coin[\"value\"] - Decimal(\"0.0001\")})\r\n         tx_orphan_bad_wit = tx_from_hex(hex_orphan_no_sig)\r\n         tx_orphan_bad_wit.wit.vtxinwit.append(CTxInWitness())\r\n         tx_orphan_bad_wit.wit.vtxinwit[0].scriptWitness.stack = [b'garbage']\r\n \r\n-        peer_sender = node.add_p2p_connection(P2PInterface())\r\n+        child_peer_sender = node.add_p2p_connection(P2PInterface())\r\n+        parent_peer_sender = node.add_p2p_connection(P2PInterface())\r\n \r\n         # 1. Child is received first. It is missing an input.\r\n         child_wtxid_int = int(tx_orphan_bad_wit.getwtxid(), 16)\r\n-        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=child_wtxid_int)]))\r\n-        peer_sender.wait_for_getdata([child_wtxid_int])\r\n-        peer_sender.send_and_ping(msg_tx(tx_orphan_bad_wit))\r\n+        child_peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=child_wtxid_int)]))\r\n+        child_peer_sender.wait_for_getdata([child_wtxid_int])\r\n+        child_peer_sender.send_and_ping(msg_tx(tx_orphan_bad_wit))\r\n \r\n         # 2. Node requests the missing parent by txid.\r\n         parent_txid_int = int(low_fee_parent[\"txid\"], 16)\r\n-        peer_sender.wait_for_getdata([parent_txid_int])\r\n+        child_peer_sender.wait_for_getdata([parent_txid_int])\r\n \r\n-        # 3. Sender relays the parent. Parent+Child are evaluated as a package and accepted.\r\n-        peer_sender.send_message(msg_tx(low_fee_parent[\"tx\"]))\r\n+        # 3. \"Honest\" sender relays the parent. Parent+Child are evaluated as a package and accepted.\r\n+        parent_peer_sender.send_message(msg_tx(low_fee_parent[\"tx\"]))\r\n \r\n         # 4. Transactions should not be in mempool.\r\n         node_mempool = node.getrawmempool()\r\n         assert low_fee_parent[\"txid\"] not in node_mempool\r\n         assert tx_orphan_bad_wit.rehash() not in node_mempool\r\n \r\n         # 5. Peer sent a consensus-invalid transaction.\r\n-        peer_sender.wait_for_disconnect()\r\n+        child_peer_sender.wait_for_disconnect()\r\n+\r\n+        # 6. \"Honest\" peer unpunished\r\n+        parent_peer_sender.sync_with_ping()\r\n+\r\n+    def test_parent_consensus_failure(self):\r\n+        node = self.nodes[0]\r\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\r\n+\r\n+        # Add bad sigature to parent\r\n+        tx_parent_bad_wit = tx_from_hex(low_fee_parent[\"hex\"])\r\n+        tx_parent_bad_wit.wit.vtxinwit.append(CTxInWitness())\r\n+        tx_parent_bad_wit.wit.vtxinwit[0].scriptWitness.stack = [b'garbage']\r\n+\r\n+        coin = low_fee_parent[\"new_utxo\"]\r\n+        address = node.get_deterministic_priv_key().address\r\n+        # Create raw transaction spending the parent, but with no signature (a consensus error).\r\n+        hex_orphan_no_sig = node.createrawtransaction([{\"txid\": coin[\"txid\"], \"vout\": coin[\"vout\"]}], {address : coin[\"value\"] - Decimal(\"0.0001\")})\r\n+        tx_orphan_bad_wit = tx_from_hex(hex_orphan_no_sig)\r\n+        tx_orphan_bad_wit.wit.vtxinwit.append(CTxInWitness())\r\n+        tx_orphan_bad_wit.wit.vtxinwit[0].scriptWitness.stack = [b'garbage']\r\n+\r\n+        child_peer_sender = node.add_p2p_connection(P2PInterface())\r\n+        parent_peer_sender = node.add_p2p_connection(P2PInterface())\r\n+\r\n+        # 1. Child is received first. It is missing an input.\r\n+        child_wtxid_int = int(tx_orphan_bad_wit.getwtxid(), 16)\r\n+        child_peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=child_wtxid_int)]))\r\n+        child_peer_sender.wait_for_getdata([child_wtxid_int])\r\n+        child_peer_sender.send_and_ping(msg_tx(tx_orphan_bad_wit))\r\n+\r\n+        # 2. Node requests the missing parent by txid.\r\n+        parent_txid_int = int(tx_parent_bad_wit.rehash(), 16)\r\n+        child_peer_sender.wait_for_getdata([parent_txid_int])\r\n+\r\n+        # 3. Parent sender relays the parent. Only parent should be evaluated.\r\n+        parent_peer_sender.send_message(msg_tx(tx_parent_bad_wit))\r\n+\r\n+        # 4. Transactions should not be in mempool.\r\n+        node_mempool = node.getrawmempool()\r\n+        assert tx_parent_bad_wit.rehash() not in node_mempool\r\n+        assert tx_orphan_bad_wit.rehash() not in node_mempool\r\n+\r\n+        # 5. Peer sent a consensus-invalid transaction.\r\n+        parent_peer_sender.wait_for_disconnect()\r\n+\r\n+        # 6. Child-sending peer unpunished for now!\r\n+        child_peer_sender.sync_with_ping()\r\n \r\n     def run_test(self):\r\n         node = self.nodes[0]\r\n         self.wallet = MiniWallet(node)\r\n         self.wallet_nonsegwit = MiniWallet(node, mode=MiniWalletMode.RAW_P2PK)\r\n         self.generate(self.wallet_nonsegwit, 10)\r\n         self.generate(self.wallet, 20)\r\n \r\n         fill_mempool(self, node, self.wallet)\r\n \r\n         self.log.info(\"Check opportunistic 1p1c logic when parent (txid != wtxid) is received before child\")\r\n         self.test_basic_parent_then_child(self.wallet)\r\n \r\n         self.log.info(\"Check opportunistic 1p1c logic when parent (txid == wtxid) is received before child\")\r\n         self.test_basic_parent_then_child(self.wallet_nonsegwit)\r\n \r\n         self.log.info(\"Check opportunistic 1p1c logic when child is received before parent\")\r\n         self.test_basic_child_then_parent()\r\n \r\n         self.log.info(\"Check opportunistic 1p1c logic when 2 candidate children exist (parent txid != wtxid)\")\r\n         self.test_low_and_high_child(self.wallet)\r\n \r\n         self.log.info(\"Check opportunistic 1p1c logic when 2 candidate children exist (parent txid == wtxid)\")\r\n         self.test_low_and_high_child(self.wallet_nonsegwit)\r\n \r\n         self.log.info(\"Check opportunistic 1p1c logic with consensus-invalid orphan causes disconnect\")\r\n         self.test_orphan_consensus_failure()\r\n \r\n+        self.log.info(\"Check opportunistic 1p1c logic doesn't evaluate package with consensus-invalid parent\")\r\n+        self.test_parent_consensus_failure()\r\n+\r\n \r\n if __name__ == '__main__':\r\n     PackageRelayTest().main()\r\n``` \r\n",
      "created_at": "2024-04-16T17:31:12Z",
      "updated_at": "2024-04-16T17:48:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1567724841",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1567724841"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 189,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1567763258",
      "pull_request_review_id": 2004307670,
      "id": 1567763258,
      "node_id": "PRRC_kwDOABII585dcis6",
      "diff_hunk": "@@ -0,0 +1,241 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test opportunistic 1p1c package submission logic.\n+\"\"\"\n+\n+from decimal import Decimal\n+from test_framework.messages import (\n+    CInv,\n+    CTxInWitness,\n+    MSG_WTX,\n+    msg_inv,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    fill_mempool,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+        ]]\n+        self.supports_cli = False\n+\n+    def test_basic_child_then_parent(self):\n+        node = self.nodes[0]\n+        self.log.info(\"Check that opportunistic 1p1c logic works when child is received before parent\")\n+\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first (perhaps the low feerate parent didn't meet feefilter or the requests were sent to different nodes). It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. Sender relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 4. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+        node.disconnect_p2ps()\n+\n+    def test_basic_parent_then_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=1, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=2, connection_type=\"outbound-full-relay\")\n+\n+        # 1. Parent is relayed first. It is too low feerate.\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer_sender.wait_for_getdata([parent_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer_ignored, check that it is ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+\n+        # 2. Child is relayed next. It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 3. Node requests the missing parent by txid.\n+        # It should do so even if it has previously rejected that parent for being too low feerate.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 4. Sender re-relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 5. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+        node.disconnect_p2ps()\n+\n+    def test_low_and_high_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        low_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=2*FEERATE_1SAT_VB)",
      "path": "test/functional/p2p_opportunistic_1p1c.py",
      "position": null,
      "original_position": 115,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "142d584dab3725081344520bec0a092d6b58d996",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "suggestion:\r\ncall this `med_fee_child` and use the mempoolminfee directly since that's a more meaningful value than `2*FEERATE_1SAT_VB` which is below the floating minfee",
      "created_at": "2024-04-16T18:06:22Z",
      "updated_at": "2024-04-16T18:06:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1567763258",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1567763258"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 115,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1567870936",
      "pull_request_review_id": 2004484626,
      "id": 1567870936,
      "node_id": "PRRC_kwDOABII585dc8_Y",
      "diff_hunk": "@@ -40,6 +43,109 @@ inline CTransactionRef create_placeholder_tx(size_t num_inputs, size_t num_outpu\n     return MakeTransactionRef(mtx);\n }\n \n+// Create a Wtxid from a hex string\n+inline Wtxid WtxidFromString(std::string_view str)\n+{\n+    return Wtxid::FromUint256(uint256S(str.data()));\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(package_hash_tests, TestChain100Setup)\n+{\n+    // Some wtxids, in lexicographical order:\n+    Wtxid wtxid_0{WtxidFromString(\"0x0000000000000000000000000000000000000000000000000000000000000000\")};\n+    Wtxid wtxid_1{WtxidFromString(\"0x0000000000000000000000000000000000000000000000000000000000000001\")};\n+    Wtxid wtxid_2{WtxidFromString(\"0x00000000000000000000000000000000000000000000000000000000ffffffff\")};\n+    Wtxid wtxid_3{WtxidFromString(\"0x1000000000000000000000000000000000000000000000000000000000000000\")};\n+    Wtxid wtxid_4{WtxidFromString(\"0x85cd1a31eb38f74ed5742ec9cb546712ab5aaf747de28a9168b53e846cbda17f\")};\n+    Wtxid wtxid_5{WtxidFromString(\"0xb4749f017444b051c44dfd2720e88f314ff94f3dd6d56d40ef65854fcd7fff6b\")};\n+    Wtxid wtxid_6{WtxidFromString(\"0xe065bac15f62bb4e761d761db928ddee65a47296b2b776785abb912cdec474e3\")};\n+\n+    BOOST_CHECK(wtxid_0.GetHex() < wtxid_1.GetHex());\n+    BOOST_CHECK(wtxid_1.GetHex() < wtxid_2.GetHex());\n+    BOOST_CHECK(wtxid_2.GetHex() < wtxid_3.GetHex());\n+    BOOST_CHECK(wtxid_1.GetHex() < wtxid_3.GetHex());",
      "path": "src/test/txpackage_tests.cpp",
      "position": null,
      "original_position": 37,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "54d0c78d104fb5412a194816590a06cad8cadf80",
      "in_reply_to_id": null,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In: 54d0c78d104fb5412a194816590a06cad8cadf80\r\n\r\nThis seems redundant",
      "created_at": "2024-04-16T19:51:41Z",
      "updated_at": "2024-04-17T20:17:07Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1567870936",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1567870936"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 66,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1568781077",
      "pull_request_review_id": 2005939457,
      "id": 1568781077,
      "node_id": "PRRC_kwDOABII585dgbMV",
      "diff_hunk": "@@ -4354,7 +4354,9 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         const TxValidationState& state = result.m_state;\n \n         if (result.m_result_type == MempoolAcceptResult::ResultType::VALID) {\n-            ProcessValidTx(pfrom.GetId(), ptx, result.m_replaced_transactions.value());\n+            Assume(result.m_replaced_transactions.has_value());",
      "path": "src/net_processing.cpp",
      "position": 318,
      "original_position": 5,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "6f4da19cc3b1b7cd23cb4be95a6bb9acb79eb3bf",
      "in_reply_to_id": null,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "This is a code style nit, but I think I agree with https://github.com/bitcoin/bitcoin/pull/21062/files#r571975710 that there's not much benefit from using a `std::optional` on `m_replaced_transactions`?  It just seems to lead to extra code around understanding when the field is set or not, when I think it would be simpler to say that it's just a list which is either empty or non-empty based on whether a replacement took place.\r\n\r\nAnyway I have no objection to the changes in this commit; just wanted to mention it so that if others agree, then perhaps this is a change we could make in the future.",
      "created_at": "2024-04-17T12:42:31Z",
      "updated_at": "2024-04-22T22:38:06Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1568781077",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1568781077"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 4566,
      "original_line": 4357,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1568834899",
      "pull_request_review_id": 2006030894,
      "id": 1568834899,
      "node_id": "PRRC_kwDOABII585dgoVT",
      "diff_hunk": "@@ -3195,6 +3210,115 @@ void PeerManagerImpl::ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, c\n     }\n }\n \n+void PeerManagerImpl::ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, const std::vector<NodeId>& senders)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    if (package_result.m_state.IsInvalid()) {\n+        m_recent_rejects_reconsiderable.insert(GetPackageHash(package));\n+    }\n+    // We currently only expect to process 1-parent-1-child packages. Remove if this changes.\n+    if (!Assume(package.size() == 2)) return;\n+\n+    // Iterate backwards to erase in-package descendants from the orphanage before they become\n+    // relevant in AddChildrenToWorkSet.\n+    auto package_iter = package.rbegin();\n+    auto senders_iter = senders.rbegin();\n+    while (package_iter != package.rend()) {\n+        const auto& tx = *package_iter;\n+        const NodeId nodeid = *senders_iter;\n+        const auto it_result{package_result.m_tx_results.find(tx->GetWitnessHash())};\n+        if (Assume(it_result != package_result.m_tx_results.end())) {\n+            const auto& tx_result = it_result->second;\n+            switch (tx_result.m_result_type) {\n+                case MempoolAcceptResult::ResultType::VALID:\n+                {\n+                    Assume(tx_result.m_replaced_transactions.has_value());\n+                    std::list<CTransactionRef> empty_replacement_list;\n+                    ProcessValidTx(nodeid, tx, tx_result.m_replaced_transactions.value_or(empty_replacement_list));\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::INVALID:\n+                case MempoolAcceptResult::ResultType::DIFFERENT_WITNESS:\n+                {\n+                    // Don't add to vExtraTxnForCompact, as these transactions should have already been\n+                    // added there when added to the orphanage or rejected for TX_RECONSIDERABLE.\n+                    // This should be updated if package submission is ever used for transactions\n+                    // that haven't already been validated before.\n+                    ProcessInvalidTx(nodeid, tx, tx_result.m_state, /*maybe_add_extra_compact_tx=*/false);\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::MEMPOOL_ENTRY:\n+                {\n+                    // AlreadyHaveTx() should be catching transactions that are already in mempool.\n+                    Assume(false);\n+                    break;\n+                }\n+            }\n+        }\n+        package_iter++;\n+        // There should be a sender for each tx, but fall back to the last one otherwise.\n+        if (Assume(senders_iter != senders.rend())) senders_iter++;\n+    }\n+}\n+\n+void PeerManagerImpl::MaybeProcess1P1CPackage(const CTransactionRef& ptx, NodeId nodeid)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    const auto& parent_txid{ptx->GetHash()};\n+    const auto& parent_wtxid{ptx->GetWitnessHash()};\n+\n+    const auto cpfp_candidates{m_orphanage.GetChildren(ptx)};\n+    // Exit early.\n+    if (cpfp_candidates.empty()) {\n+        LogDebug(BCLog::TXPACKAGES, \"didn't evaluate package for %s (wtxid=%s), no corresponding orphan found\\n\",\n+                 parent_txid.ToString(), parent_wtxid.ToString());\n+        return;\n+    }\n+\n+    CTransactionRef tx_orphan{nullptr};\n+    NodeId orphan_sender{-1};\n+    Assume(m_recent_rejects_reconsiderable.contains(parent_wtxid.ToUint256()));\n+\n+    // Create a 1p1c package using the first child that hasn't already been rejected. Sort\n+    // the children in random order to not create a bias that attackers can use to delay\n+    // package acceptance. Create a random permutation of the indices.\n+    std::vector<size_t> tx_indices(cpfp_candidates.size());\n+    std::iota(tx_indices.begin(), tx_indices.end(), 0);\n+    Shuffle(tx_indices.begin(), tx_indices.end(), m_rng);",
      "path": "src/net_processing.cpp",
      "position": 257,
      "original_position": 106,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "25c712711d6b1074b40c440676e3b1c4e12e59af",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "would it make sense to match peers and (if possible) always pick a child from the orphanage that was sent to us by the same peer that sent us the parent (instead of a random one)?\r\nThat way, it wouldn't be possible that a third peer could send us multiple low-fee children that we'd store in the orphanage, in the hope that we pick one of those and reject the package.",
      "created_at": "2024-04-17T13:20:12Z",
      "updated_at": "2024-04-17T13:20:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1568834899",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1568834899"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 3337,
      "original_line": 3337,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1568861661",
      "pull_request_review_id": 2006075374,
      "id": 1568861661,
      "node_id": "PRRC_kwDOABII585dgu3d",
      "diff_hunk": "@@ -3195,6 +3210,115 @@ void PeerManagerImpl::ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, c\n     }\n }\n \n+void PeerManagerImpl::ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, const std::vector<NodeId>& senders)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    if (package_result.m_state.IsInvalid()) {\n+        m_recent_rejects_reconsiderable.insert(GetPackageHash(package));\n+    }\n+    // We currently only expect to process 1-parent-1-child packages. Remove if this changes.\n+    if (!Assume(package.size() == 2)) return;\n+\n+    // Iterate backwards to erase in-package descendants from the orphanage before they become\n+    // relevant in AddChildrenToWorkSet.\n+    auto package_iter = package.rbegin();\n+    auto senders_iter = senders.rbegin();\n+    while (package_iter != package.rend()) {\n+        const auto& tx = *package_iter;\n+        const NodeId nodeid = *senders_iter;\n+        const auto it_result{package_result.m_tx_results.find(tx->GetWitnessHash())};\n+        if (Assume(it_result != package_result.m_tx_results.end())) {\n+            const auto& tx_result = it_result->second;\n+            switch (tx_result.m_result_type) {\n+                case MempoolAcceptResult::ResultType::VALID:\n+                {\n+                    Assume(tx_result.m_replaced_transactions.has_value());\n+                    std::list<CTransactionRef> empty_replacement_list;\n+                    ProcessValidTx(nodeid, tx, tx_result.m_replaced_transactions.value_or(empty_replacement_list));\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::INVALID:\n+                case MempoolAcceptResult::ResultType::DIFFERENT_WITNESS:\n+                {\n+                    // Don't add to vExtraTxnForCompact, as these transactions should have already been\n+                    // added there when added to the orphanage or rejected for TX_RECONSIDERABLE.\n+                    // This should be updated if package submission is ever used for transactions\n+                    // that haven't already been validated before.\n+                    ProcessInvalidTx(nodeid, tx, tx_result.m_state, /*maybe_add_extra_compact_tx=*/false);\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::MEMPOOL_ENTRY:\n+                {\n+                    // AlreadyHaveTx() should be catching transactions that are already in mempool.\n+                    Assume(false);\n+                    break;\n+                }\n+            }\n+        }\n+        package_iter++;\n+        // There should be a sender for each tx, but fall back to the last one otherwise.\n+        if (Assume(senders_iter != senders.rend())) senders_iter++;\n+    }\n+}\n+\n+void PeerManagerImpl::MaybeProcess1P1CPackage(const CTransactionRef& ptx, NodeId nodeid)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    const auto& parent_txid{ptx->GetHash()};\n+    const auto& parent_wtxid{ptx->GetWitnessHash()};\n+\n+    const auto cpfp_candidates{m_orphanage.GetChildren(ptx)};\n+    // Exit early.\n+    if (cpfp_candidates.empty()) {\n+        LogDebug(BCLog::TXPACKAGES, \"didn't evaluate package for %s (wtxid=%s), no corresponding orphan found\\n\",\n+                 parent_txid.ToString(), parent_wtxid.ToString());\n+        return;\n+    }\n+\n+    CTransactionRef tx_orphan{nullptr};\n+    NodeId orphan_sender{-1};\n+    Assume(m_recent_rejects_reconsiderable.contains(parent_wtxid.ToUint256()));\n+\n+    // Create a 1p1c package using the first child that hasn't already been rejected. Sort\n+    // the children in random order to not create a bias that attackers can use to delay\n+    // package acceptance. Create a random permutation of the indices.\n+    std::vector<size_t> tx_indices(cpfp_candidates.size());\n+    std::iota(tx_indices.begin(), tx_indices.end(), 0);\n+    Shuffle(tx_indices.begin(), tx_indices.end(), m_rng);",
      "path": "src/net_processing.cpp",
      "position": 257,
      "original_position": 106,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "25c712711d6b1074b40c440676e3b1c4e12e59af",
      "in_reply_to_id": 1568834899,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I think I made this point in person from the philosophical standpoint that orphanage-churning aside, we probably shouldn't allow peers to \"cross-talk\" when it comes to package evaluation and possible punishment.\r\n\r\nIn practice I think an adversary can just churn the orphanage until Future Work happens, but still might be a good conceptual framework to adhere to? \r\n\r\n",
      "created_at": "2024-04-17T13:37:26Z",
      "updated_at": "2024-04-17T13:37:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1568861661",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1568861661"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 3337,
      "original_line": 3337,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1568894409",
      "pull_request_review_id": 2006130667,
      "id": 1568894409,
      "node_id": "PRRC_kwDOABII585dg23J",
      "diff_hunk": "@@ -3195,6 +3210,115 @@ void PeerManagerImpl::ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, c\n     }\n }\n \n+void PeerManagerImpl::ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, const std::vector<NodeId>& senders)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    if (package_result.m_state.IsInvalid()) {\n+        m_recent_rejects_reconsiderable.insert(GetPackageHash(package));\n+    }\n+    // We currently only expect to process 1-parent-1-child packages. Remove if this changes.\n+    if (!Assume(package.size() == 2)) return;\n+\n+    // Iterate backwards to erase in-package descendants from the orphanage before they become\n+    // relevant in AddChildrenToWorkSet.\n+    auto package_iter = package.rbegin();\n+    auto senders_iter = senders.rbegin();\n+    while (package_iter != package.rend()) {\n+        const auto& tx = *package_iter;\n+        const NodeId nodeid = *senders_iter;\n+        const auto it_result{package_result.m_tx_results.find(tx->GetWitnessHash())};\n+        if (Assume(it_result != package_result.m_tx_results.end())) {\n+            const auto& tx_result = it_result->second;\n+            switch (tx_result.m_result_type) {\n+                case MempoolAcceptResult::ResultType::VALID:\n+                {\n+                    Assume(tx_result.m_replaced_transactions.has_value());\n+                    std::list<CTransactionRef> empty_replacement_list;\n+                    ProcessValidTx(nodeid, tx, tx_result.m_replaced_transactions.value_or(empty_replacement_list));\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::INVALID:\n+                case MempoolAcceptResult::ResultType::DIFFERENT_WITNESS:\n+                {\n+                    // Don't add to vExtraTxnForCompact, as these transactions should have already been\n+                    // added there when added to the orphanage or rejected for TX_RECONSIDERABLE.\n+                    // This should be updated if package submission is ever used for transactions\n+                    // that haven't already been validated before.\n+                    ProcessInvalidTx(nodeid, tx, tx_result.m_state, /*maybe_add_extra_compact_tx=*/false);\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::MEMPOOL_ENTRY:\n+                {\n+                    // AlreadyHaveTx() should be catching transactions that are already in mempool.\n+                    Assume(false);\n+                    break;\n+                }\n+            }\n+        }\n+        package_iter++;\n+        // There should be a sender for each tx, but fall back to the last one otherwise.\n+        if (Assume(senders_iter != senders.rend())) senders_iter++;\n+    }\n+}\n+\n+void PeerManagerImpl::MaybeProcess1P1CPackage(const CTransactionRef& ptx, NodeId nodeid)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    const auto& parent_txid{ptx->GetHash()};\n+    const auto& parent_wtxid{ptx->GetWitnessHash()};\n+\n+    const auto cpfp_candidates{m_orphanage.GetChildren(ptx)};\n+    // Exit early.\n+    if (cpfp_candidates.empty()) {\n+        LogDebug(BCLog::TXPACKAGES, \"didn't evaluate package for %s (wtxid=%s), no corresponding orphan found\\n\",\n+                 parent_txid.ToString(), parent_wtxid.ToString());\n+        return;\n+    }\n+\n+    CTransactionRef tx_orphan{nullptr};\n+    NodeId orphan_sender{-1};\n+    Assume(m_recent_rejects_reconsiderable.contains(parent_wtxid.ToUint256()));\n+\n+    // Create a 1p1c package using the first child that hasn't already been rejected. Sort\n+    // the children in random order to not create a bias that attackers can use to delay\n+    // package acceptance. Create a random permutation of the indices.\n+    std::vector<size_t> tx_indices(cpfp_candidates.size());\n+    std::iota(tx_indices.begin(), tx_indices.end(), 0);\n+    Shuffle(tx_indices.begin(), tx_indices.end(), m_rng);",
      "path": "src/net_processing.cpp",
      "position": 257,
      "original_position": 106,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "25c712711d6b1074b40c440676e3b1c4e12e59af",
      "in_reply_to_id": 1568834899,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "great idea, will change 👍 ",
      "created_at": "2024-04-17T13:57:18Z",
      "updated_at": "2024-04-17T13:57:18Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1568894409",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1568894409"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 3337,
      "original_line": 3337,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1568990742",
      "pull_request_review_id": 2004484626,
      "id": 1568990742,
      "node_id": "PRRC_kwDOABII585dhOYW",
      "diff_hunk": "@@ -40,6 +43,109 @@ inline CTransactionRef create_placeholder_tx(size_t num_inputs, size_t num_outpu\n     return MakeTransactionRef(mtx);\n }\n \n+// Create a Wtxid from a hex string\n+inline Wtxid WtxidFromString(std::string_view str)\n+{\n+    return Wtxid::FromUint256(uint256S(str.data()));\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(package_hash_tests, TestChain100Setup)\n+{\n+    // Some wtxids, in lexicographical order:\n+    Wtxid wtxid_0{WtxidFromString(\"0x0000000000000000000000000000000000000000000000000000000000000000\")};\n+    Wtxid wtxid_1{WtxidFromString(\"0x0000000000000000000000000000000000000000000000000000000000000001\")};\n+    Wtxid wtxid_2{WtxidFromString(\"0x00000000000000000000000000000000000000000000000000000000ffffffff\")};\n+    Wtxid wtxid_3{WtxidFromString(\"0x1000000000000000000000000000000000000000000000000000000000000000\")};\n+    Wtxid wtxid_4{WtxidFromString(\"0x85cd1a31eb38f74ed5742ec9cb546712ab5aaf747de28a9168b53e846cbda17f\")};\n+    Wtxid wtxid_5{WtxidFromString(\"0xb4749f017444b051c44dfd2720e88f314ff94f3dd6d56d40ef65854fcd7fff6b\")};\n+    Wtxid wtxid_6{WtxidFromString(\"0xe065bac15f62bb4e761d761db928ddee65a47296b2b776785abb912cdec474e3\")};\n+\n+    BOOST_CHECK(wtxid_0.GetHex() < wtxid_1.GetHex());\n+    BOOST_CHECK(wtxid_1.GetHex() < wtxid_2.GetHex());\n+    BOOST_CHECK(wtxid_2.GetHex() < wtxid_3.GetHex());\n+    BOOST_CHECK(wtxid_1.GetHex() < wtxid_3.GetHex());\n+    BOOST_CHECK(wtxid_3.GetHex() < wtxid_4.GetHex());\n+    BOOST_CHECK(wtxid_4.GetHex() < wtxid_5.GetHex());\n+    BOOST_CHECK(wtxid_5.GetHex() < wtxid_6.GetHex());\n+\n+    // Random real segwit transaction, corresponds to wtxid_4\n+    DataStream stream4{\n+        ParseHex(\"02000000000101964b8aa63509579ca6086e6012eeaa4c2f4dd1e283da29b67c8eea38b3c6fd220000000000fdffffff0294c618000000000017a9145afbbb42f4e83312666d0697f9e66259912ecde38768fa2c0000000000160014897388a0889390fd0e153a22bb2cf9d8f019faf50247304402200547406380719f84d68cf4e96cc3e4a1688309ef475b150be2b471c70ea562aa02206d255f5acc40fd95981874d77201d2eb07883657ce1c796513f32b6079545cdf0121023ae77335cefcb5ab4c1dc1fb0d2acfece184e593727d7d5906c78e564c7c11d125cf0c00\"),\n+    };\n+    CTransaction tx4(deserialize, TX_WITH_WITNESS, stream4);\n+    CTransactionRef ptx4{MakeTransactionRef(tx4)};\n+    Txid txid_4{TxidFromString(\"0xbd0f71c1d5e50589063e134fad22053cdae5ab2320db5bf5e540198b0b5a4e69\")};",
      "path": "src/test/txpackage_tests.cpp",
      "position": null,
      "original_position": 48,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "142d584dab3725081344520bec0a092d6b58d996",
      "in_reply_to_id": null,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In: 54d0c78d104fb5412a194816590a06cad8cadf80\r\n\r\nI don't see what the point of building the `txid` from a literal in this way and comparing it to the one obtained via `GetHash()` is. I'm guessing you're trying to make the point that the txids are actually what you are claiming them to be (as opposed to just writing them in a comment), so the reader can manually check the difference between internal and human-readable lexicographic ordering. Is that really necessary? ",
      "created_at": "2024-04-17T14:55:58Z",
      "updated_at": "2024-04-17T20:17:07Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1568990742",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1568990742"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 77,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1569085792",
      "pull_request_review_id": 2004484626,
      "id": 1569085792,
      "node_id": "PRRC_kwDOABII585dhllg",
      "diff_hunk": "@@ -40,6 +43,109 @@ inline CTransactionRef create_placeholder_tx(size_t num_inputs, size_t num_outpu\n     return MakeTransactionRef(mtx);\n }\n \n+// Create a Wtxid from a hex string\n+inline Wtxid WtxidFromString(std::string_view str)\n+{\n+    return Wtxid::FromUint256(uint256S(str.data()));\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(package_hash_tests, TestChain100Setup)\n+{\n+    // Some wtxids, in lexicographical order:\n+    Wtxid wtxid_0{WtxidFromString(\"0x0000000000000000000000000000000000000000000000000000000000000000\")};\n+    Wtxid wtxid_1{WtxidFromString(\"0x0000000000000000000000000000000000000000000000000000000000000001\")};\n+    Wtxid wtxid_2{WtxidFromString(\"0x00000000000000000000000000000000000000000000000000000000ffffffff\")};\n+    Wtxid wtxid_3{WtxidFromString(\"0x1000000000000000000000000000000000000000000000000000000000000000\")};\n+    Wtxid wtxid_4{WtxidFromString(\"0x85cd1a31eb38f74ed5742ec9cb546712ab5aaf747de28a9168b53e846cbda17f\")};\n+    Wtxid wtxid_5{WtxidFromString(\"0xb4749f017444b051c44dfd2720e88f314ff94f3dd6d56d40ef65854fcd7fff6b\")};\n+    Wtxid wtxid_6{WtxidFromString(\"0xe065bac15f62bb4e761d761db928ddee65a47296b2b776785abb912cdec474e3\")};\n+\n+    BOOST_CHECK(wtxid_0.GetHex() < wtxid_1.GetHex());\n+    BOOST_CHECK(wtxid_1.GetHex() < wtxid_2.GetHex());\n+    BOOST_CHECK(wtxid_2.GetHex() < wtxid_3.GetHex());\n+    BOOST_CHECK(wtxid_1.GetHex() < wtxid_3.GetHex());\n+    BOOST_CHECK(wtxid_3.GetHex() < wtxid_4.GetHex());\n+    BOOST_CHECK(wtxid_4.GetHex() < wtxid_5.GetHex());\n+    BOOST_CHECK(wtxid_5.GetHex() < wtxid_6.GetHex());\n+\n+    // Random real segwit transaction, corresponds to wtxid_4\n+    DataStream stream4{\n+        ParseHex(\"02000000000101964b8aa63509579ca6086e6012eeaa4c2f4dd1e283da29b67c8eea38b3c6fd220000000000fdffffff0294c618000000000017a9145afbbb42f4e83312666d0697f9e66259912ecde38768fa2c0000000000160014897388a0889390fd0e153a22bb2cf9d8f019faf50247304402200547406380719f84d68cf4e96cc3e4a1688309ef475b150be2b471c70ea562aa02206d255f5acc40fd95981874d77201d2eb07883657ce1c796513f32b6079545cdf0121023ae77335cefcb5ab4c1dc1fb0d2acfece184e593727d7d5906c78e564c7c11d125cf0c00\"),\n+    };\n+    CTransaction tx4(deserialize, TX_WITH_WITNESS, stream4);\n+    CTransactionRef ptx4{MakeTransactionRef(tx4)};\n+    Txid txid_4{TxidFromString(\"0xbd0f71c1d5e50589063e134fad22053cdae5ab2320db5bf5e540198b0b5a4e69\")};\n+    BOOST_CHECK_EQUAL(tx4.GetHash(), txid_4);\n+    BOOST_CHECK_EQUAL(tx4.GetWitnessHash(), wtxid_4);\n+\n+    // Random real nonsegwit transaction, corresponds to wtxid_5\n+    DataStream stream5{\n+        ParseHex(\"01000000010b26e9b7735eb6aabdf358bab62f9816a21ba9ebdb719d5299e88607d722c190000000008b4830450220070aca44506c5cef3a16ed519d7c3c39f8aab192c4e1c90d065f37b8a4af6141022100a8e160b856c2d43d27d8fba71e5aef6405b8643ac4cb7cb3c462aced7f14711a0141046d11fee51b0e60666d5049a9101a72741df480b96ee26488a4d3466b95c9a40ac5eeef87e10a5cd336c19a84565f80fa6c547957b7700ff4dfbdefe76036c339ffffffff021bff3d11000000001976a91404943fdd508053c75000106d3bc6e2754dbcff1988ac2f15de00000000001976a914a266436d2965547608b9e15d9032a7b9d64fa43188ac00000000\"),\n+    };\n+    CTransaction tx5(deserialize, TX_WITH_WITNESS, stream5);\n+    CTransactionRef ptx5{MakeTransactionRef(tx5)};\n+    BOOST_CHECK_EQUAL(tx5.GetWitnessHash(), wtxid_5);\n+    Txid txid_5{TxidFromString(\"0xb4749f017444b051c44dfd2720e88f314ff94f3dd6d56d40ef65854fcd7fff6b\")};\n+    BOOST_CHECK_EQUAL(tx5.GetHash(), txid_5);\n+\n+    // Random real segwit transaction, corresponds to wtxid_6\n+    DataStream stream6{\n+        ParseHex(\"0200000000010177862801f77c2c068a70372b4c435ef8dd621291c36a64eb4dd491f02218f5324600000000fdffffff014a0100000000000022512035ea312034cfac01e956a269f3bf147f569c2fbb00180677421262da042290d803402be713325ff285e66b0380f53f2fae0d0fb4e16f378a440fed51ce835061437566729d4883bc917632f3cff474d6384bc8b989961a1d730d4a87ed38ad28bd337b20f1d658c6c138b1c312e072b4446f50f01ae0da03a42e6274f8788aae53416a7fac0063036f7264010118746578742f706c61696e3b636861727365743d7574662d3800357b2270223a226272632d3230222c226f70223a226d696e74222c227469636b223a224342414c222c22616d74223a2236393639227d6821c1f1d658c6c138b1c312e072b4446f50f01ae0da03a42e6274f8788aae53416a7f00000000\"),\n+    };\n+    CTransaction tx6(deserialize, TX_WITH_WITNESS, stream6);\n+    CTransactionRef ptx6{MakeTransactionRef(tx6)};\n+    BOOST_CHECK_EQUAL(tx6.GetWitnessHash(), wtxid_6);\n+    Txid txid_6{TxidFromString(\"0xee707be5201160e32c4fc715bec227d1aeea5940fb4295605e7373edce3b1a93\")};\n+    BOOST_CHECK_EQUAL(tx6.GetHash(), txid_6);\n+\n+    // Testing that both functions compare using GetHex() and not uint256.\n+    // In these pairs of wtxids, hex string order != uint256 order\n+    BOOST_CHECK(wtxid_3 < wtxid_1);\n+    BOOST_CHECK(wtxid_3 < wtxid_2);\n+    BOOST_CHECK(wtxid_5 < wtxid_4);\n+\n+    // Testing that package hash is using wtxids, not txids.\n+    BOOST_CHECK(txid_4.ToUint256() != wtxid_4.ToUint256());\n+    BOOST_CHECK(txid_6.ToUint256() != wtxid_6.ToUint256());\n+\n+    // Testing that package hash is sorting by wtxids, not txids.\n+    // For tx4 and tx5, txid order != wtxid order\n+    BOOST_CHECK(txid_5.GetHex() < txid_4.GetHex());\n+\n+    // All permutations of the package containing ptx4, ptx5, ptx6\n+    std::vector<CTransactionRef> package_456{ptx4, ptx5, ptx6};\n+    std::vector<CTransactionRef> package_465{ptx4, ptx6, ptx5};\n+    std::vector<CTransactionRef> package_564{ptx5, ptx6, ptx4};\n+    std::vector<CTransactionRef> package_546{ptx5, ptx4, ptx6};\n+    std::vector<CTransactionRef> package_645{ptx6, ptx4, ptx5};\n+    std::vector<CTransactionRef> package_654{ptx6, ptx5, ptx4};\n+    // All of them must have the same package hash 2dc93431aa6eb415a4e0995f77c78098d7ed97ca6f123a0d77a7747339525acd\n+    std::vector<uint256> expected_order_txns{wtxid_4.ToUint256(), wtxid_5.ToUint256(), wtxid_6.ToUint256()};",
      "path": "src/test/txpackage_tests.cpp",
      "position": null,
      "original_position": 94,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "54d0c78d104fb5412a194816590a06cad8cadf80",
      "in_reply_to_id": null,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In: 54d0c78d104fb5412a194816590a06cad8cadf80\r\n\r\nCalling `ToUint256()` shouldn't be needed",
      "created_at": "2024-04-17T15:55:57Z",
      "updated_at": "2024-04-17T20:17:07Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1569085792",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1569085792"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 123,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1569086405",
      "pull_request_review_id": 2004484626,
      "id": 1569086405,
      "node_id": "PRRC_kwDOABII585dhlvF",
      "diff_hunk": "@@ -40,6 +43,109 @@ inline CTransactionRef create_placeholder_tx(size_t num_inputs, size_t num_outpu\n     return MakeTransactionRef(mtx);\n }\n \n+// Create a Wtxid from a hex string\n+inline Wtxid WtxidFromString(std::string_view str)\n+{\n+    return Wtxid::FromUint256(uint256S(str.data()));\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(package_hash_tests, TestChain100Setup)\n+{\n+    // Some wtxids, in lexicographical order:\n+    Wtxid wtxid_0{WtxidFromString(\"0x0000000000000000000000000000000000000000000000000000000000000000\")};\n+    Wtxid wtxid_1{WtxidFromString(\"0x0000000000000000000000000000000000000000000000000000000000000001\")};\n+    Wtxid wtxid_2{WtxidFromString(\"0x00000000000000000000000000000000000000000000000000000000ffffffff\")};\n+    Wtxid wtxid_3{WtxidFromString(\"0x1000000000000000000000000000000000000000000000000000000000000000\")};\n+    Wtxid wtxid_4{WtxidFromString(\"0x85cd1a31eb38f74ed5742ec9cb546712ab5aaf747de28a9168b53e846cbda17f\")};\n+    Wtxid wtxid_5{WtxidFromString(\"0xb4749f017444b051c44dfd2720e88f314ff94f3dd6d56d40ef65854fcd7fff6b\")};\n+    Wtxid wtxid_6{WtxidFromString(\"0xe065bac15f62bb4e761d761db928ddee65a47296b2b776785abb912cdec474e3\")};\n+\n+    BOOST_CHECK(wtxid_0.GetHex() < wtxid_1.GetHex());\n+    BOOST_CHECK(wtxid_1.GetHex() < wtxid_2.GetHex());\n+    BOOST_CHECK(wtxid_2.GetHex() < wtxid_3.GetHex());\n+    BOOST_CHECK(wtxid_1.GetHex() < wtxid_3.GetHex());\n+    BOOST_CHECK(wtxid_3.GetHex() < wtxid_4.GetHex());\n+    BOOST_CHECK(wtxid_4.GetHex() < wtxid_5.GetHex());\n+    BOOST_CHECK(wtxid_5.GetHex() < wtxid_6.GetHex());\n+\n+    // Random real segwit transaction, corresponds to wtxid_4\n+    DataStream stream4{\n+        ParseHex(\"02000000000101964b8aa63509579ca6086e6012eeaa4c2f4dd1e283da29b67c8eea38b3c6fd220000000000fdffffff0294c618000000000017a9145afbbb42f4e83312666d0697f9e66259912ecde38768fa2c0000000000160014897388a0889390fd0e153a22bb2cf9d8f019faf50247304402200547406380719f84d68cf4e96cc3e4a1688309ef475b150be2b471c70ea562aa02206d255f5acc40fd95981874d77201d2eb07883657ce1c796513f32b6079545cdf0121023ae77335cefcb5ab4c1dc1fb0d2acfece184e593727d7d5906c78e564c7c11d125cf0c00\"),\n+    };\n+    CTransaction tx4(deserialize, TX_WITH_WITNESS, stream4);\n+    CTransactionRef ptx4{MakeTransactionRef(tx4)};\n+    Txid txid_4{TxidFromString(\"0xbd0f71c1d5e50589063e134fad22053cdae5ab2320db5bf5e540198b0b5a4e69\")};\n+    BOOST_CHECK_EQUAL(tx4.GetHash(), txid_4);\n+    BOOST_CHECK_EQUAL(tx4.GetWitnessHash(), wtxid_4);\n+\n+    // Random real nonsegwit transaction, corresponds to wtxid_5\n+    DataStream stream5{\n+        ParseHex(\"01000000010b26e9b7735eb6aabdf358bab62f9816a21ba9ebdb719d5299e88607d722c190000000008b4830450220070aca44506c5cef3a16ed519d7c3c39f8aab192c4e1c90d065f37b8a4af6141022100a8e160b856c2d43d27d8fba71e5aef6405b8643ac4cb7cb3c462aced7f14711a0141046d11fee51b0e60666d5049a9101a72741df480b96ee26488a4d3466b95c9a40ac5eeef87e10a5cd336c19a84565f80fa6c547957b7700ff4dfbdefe76036c339ffffffff021bff3d11000000001976a91404943fdd508053c75000106d3bc6e2754dbcff1988ac2f15de00000000001976a914a266436d2965547608b9e15d9032a7b9d64fa43188ac00000000\"),\n+    };\n+    CTransaction tx5(deserialize, TX_WITH_WITNESS, stream5);\n+    CTransactionRef ptx5{MakeTransactionRef(tx5)};\n+    BOOST_CHECK_EQUAL(tx5.GetWitnessHash(), wtxid_5);\n+    Txid txid_5{TxidFromString(\"0xb4749f017444b051c44dfd2720e88f314ff94f3dd6d56d40ef65854fcd7fff6b\")};\n+    BOOST_CHECK_EQUAL(tx5.GetHash(), txid_5);\n+\n+    // Random real segwit transaction, corresponds to wtxid_6\n+    DataStream stream6{\n+        ParseHex(\"0200000000010177862801f77c2c068a70372b4c435ef8dd621291c36a64eb4dd491f02218f5324600000000fdffffff014a0100000000000022512035ea312034cfac01e956a269f3bf147f569c2fbb00180677421262da042290d803402be713325ff285e66b0380f53f2fae0d0fb4e16f378a440fed51ce835061437566729d4883bc917632f3cff474d6384bc8b989961a1d730d4a87ed38ad28bd337b20f1d658c6c138b1c312e072b4446f50f01ae0da03a42e6274f8788aae53416a7fac0063036f7264010118746578742f706c61696e3b636861727365743d7574662d3800357b2270223a226272632d3230222c226f70223a226d696e74222c227469636b223a224342414c222c22616d74223a2236393639227d6821c1f1d658c6c138b1c312e072b4446f50f01ae0da03a42e6274f8788aae53416a7f00000000\"),\n+    };\n+    CTransaction tx6(deserialize, TX_WITH_WITNESS, stream6);\n+    CTransactionRef ptx6{MakeTransactionRef(tx6)};\n+    BOOST_CHECK_EQUAL(tx6.GetWitnessHash(), wtxid_6);\n+    Txid txid_6{TxidFromString(\"0xee707be5201160e32c4fc715bec227d1aeea5940fb4295605e7373edce3b1a93\")};\n+    BOOST_CHECK_EQUAL(tx6.GetHash(), txid_6);\n+\n+    // Testing that both functions compare using GetHex() and not uint256.\n+    // In these pairs of wtxids, hex string order != uint256 order\n+    BOOST_CHECK(wtxid_3 < wtxid_1);\n+    BOOST_CHECK(wtxid_3 < wtxid_2);\n+    BOOST_CHECK(wtxid_5 < wtxid_4);\n+\n+    // Testing that package hash is using wtxids, not txids.\n+    BOOST_CHECK(txid_4.ToUint256() != wtxid_4.ToUint256());\n+    BOOST_CHECK(txid_6.ToUint256() != wtxid_6.ToUint256());\n+\n+    // Testing that package hash is sorting by wtxids, not txids.\n+    // For tx4 and tx5, txid order != wtxid order\n+    BOOST_CHECK(txid_5.GetHex() < txid_4.GetHex());\n+\n+    // All permutations of the package containing ptx4, ptx5, ptx6\n+    std::vector<CTransactionRef> package_456{ptx4, ptx5, ptx6};\n+    std::vector<CTransactionRef> package_465{ptx4, ptx6, ptx5};\n+    std::vector<CTransactionRef> package_564{ptx5, ptx6, ptx4};\n+    std::vector<CTransactionRef> package_546{ptx5, ptx4, ptx6};\n+    std::vector<CTransactionRef> package_645{ptx6, ptx4, ptx5};\n+    std::vector<CTransactionRef> package_654{ptx6, ptx5, ptx4};\n+    // All of them must have the same package hash 2dc93431aa6eb415a4e0995f77c78098d7ed97ca6f123a0d77a7747339525acd\n+    std::vector<uint256> expected_order_txns{wtxid_4.ToUint256(), wtxid_5.ToUint256(), wtxid_6.ToUint256()};\n+    uint256 calculated_hash_456 = (HashWriter() << expected_order_txns).GetHash();\n+    BOOST_CHECK_EQUAL(calculated_hash_456, GetPackageHash(package_456));\n+    BOOST_CHECK_EQUAL(calculated_hash_456, GetPackageHash(package_465));\n+    BOOST_CHECK_EQUAL(calculated_hash_456, GetPackageHash(package_564));\n+    BOOST_CHECK_EQUAL(calculated_hash_456, GetPackageHash(package_546));\n+    BOOST_CHECK_EQUAL(calculated_hash_456, GetPackageHash(package_645));\n+    BOOST_CHECK_EQUAL(calculated_hash_456, GetPackageHash(package_654));\n+    // GetCombinedHash is consistent with GetPackageHash: try a couple permutations\n+    std::vector<Wtxid> wtxids_546{wtxid_5, wtxid_4, wtxid_6};\n+    BOOST_CHECK_EQUAL(calculated_hash_456, GetCombinedHash(wtxids_546));\n+    std::vector<Wtxid> wtxids_654{wtxid_6, wtxid_5, wtxid_4};\n+    BOOST_CHECK_EQUAL(calculated_hash_456, GetCombinedHash(wtxids_654));\n+\n+    std::vector<uint256> expected_order_wtxids{wtxid_1.ToUint256(), wtxid_2.ToUint256(), wtxid_3.ToUint256(),",
      "path": "src/test/txpackage_tests.cpp",
      "position": null,
      "original_position": 108,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "54d0c78d104fb5412a194816590a06cad8cadf80",
      "in_reply_to_id": null,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In: 54d0c78d104fb5412a194816590a06cad8cadf80\r\n\r\nSame as before, no need to cast to `ToUint256`",
      "created_at": "2024-04-17T15:56:25Z",
      "updated_at": "2024-04-17T20:17:07Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1569086405",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1569086405"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 137,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1569100856",
      "pull_request_review_id": 2004484626,
      "id": 1569100856,
      "node_id": "PRRC_kwDOABII585dhpQ4",
      "diff_hunk": "@@ -40,6 +43,109 @@ inline CTransactionRef create_placeholder_tx(size_t num_inputs, size_t num_outpu\n     return MakeTransactionRef(mtx);\n }\n \n+// Create a Wtxid from a hex string\n+inline Wtxid WtxidFromString(std::string_view str)\n+{\n+    return Wtxid::FromUint256(uint256S(str.data()));\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(package_hash_tests, TestChain100Setup)\n+{\n+    // Some wtxids, in lexicographical order:\n+    Wtxid wtxid_0{WtxidFromString(\"0x0000000000000000000000000000000000000000000000000000000000000000\")};\n+    Wtxid wtxid_1{WtxidFromString(\"0x0000000000000000000000000000000000000000000000000000000000000001\")};\n+    Wtxid wtxid_2{WtxidFromString(\"0x00000000000000000000000000000000000000000000000000000000ffffffff\")};\n+    Wtxid wtxid_3{WtxidFromString(\"0x1000000000000000000000000000000000000000000000000000000000000000\")};\n+    Wtxid wtxid_4{WtxidFromString(\"0x85cd1a31eb38f74ed5742ec9cb546712ab5aaf747de28a9168b53e846cbda17f\")};\n+    Wtxid wtxid_5{WtxidFromString(\"0xb4749f017444b051c44dfd2720e88f314ff94f3dd6d56d40ef65854fcd7fff6b\")};\n+    Wtxid wtxid_6{WtxidFromString(\"0xe065bac15f62bb4e761d761db928ddee65a47296b2b776785abb912cdec474e3\")};\n+\n+    BOOST_CHECK(wtxid_0.GetHex() < wtxid_1.GetHex());\n+    BOOST_CHECK(wtxid_1.GetHex() < wtxid_2.GetHex());\n+    BOOST_CHECK(wtxid_2.GetHex() < wtxid_3.GetHex());\n+    BOOST_CHECK(wtxid_1.GetHex() < wtxid_3.GetHex());\n+    BOOST_CHECK(wtxid_3.GetHex() < wtxid_4.GetHex());\n+    BOOST_CHECK(wtxid_4.GetHex() < wtxid_5.GetHex());\n+    BOOST_CHECK(wtxid_5.GetHex() < wtxid_6.GetHex());\n+\n+    // Random real segwit transaction, corresponds to wtxid_4\n+    DataStream stream4{\n+        ParseHex(\"02000000000101964b8aa63509579ca6086e6012eeaa4c2f4dd1e283da29b67c8eea38b3c6fd220000000000fdffffff0294c618000000000017a9145afbbb42f4e83312666d0697f9e66259912ecde38768fa2c0000000000160014897388a0889390fd0e153a22bb2cf9d8f019faf50247304402200547406380719f84d68cf4e96cc3e4a1688309ef475b150be2b471c70ea562aa02206d255f5acc40fd95981874d77201d2eb07883657ce1c796513f32b6079545cdf0121023ae77335cefcb5ab4c1dc1fb0d2acfece184e593727d7d5906c78e564c7c11d125cf0c00\"),\n+    };\n+    CTransaction tx4(deserialize, TX_WITH_WITNESS, stream4);\n+    CTransactionRef ptx4{MakeTransactionRef(tx4)};\n+    Txid txid_4{TxidFromString(\"0xbd0f71c1d5e50589063e134fad22053cdae5ab2320db5bf5e540198b0b5a4e69\")};\n+    BOOST_CHECK_EQUAL(tx4.GetHash(), txid_4);\n+    BOOST_CHECK_EQUAL(tx4.GetWitnessHash(), wtxid_4);\n+\n+    // Random real nonsegwit transaction, corresponds to wtxid_5\n+    DataStream stream5{\n+        ParseHex(\"01000000010b26e9b7735eb6aabdf358bab62f9816a21ba9ebdb719d5299e88607d722c190000000008b4830450220070aca44506c5cef3a16ed519d7c3c39f8aab192c4e1c90d065f37b8a4af6141022100a8e160b856c2d43d27d8fba71e5aef6405b8643ac4cb7cb3c462aced7f14711a0141046d11fee51b0e60666d5049a9101a72741df480b96ee26488a4d3466b95c9a40ac5eeef87e10a5cd336c19a84565f80fa6c547957b7700ff4dfbdefe76036c339ffffffff021bff3d11000000001976a91404943fdd508053c75000106d3bc6e2754dbcff1988ac2f15de00000000001976a914a266436d2965547608b9e15d9032a7b9d64fa43188ac00000000\"),\n+    };\n+    CTransaction tx5(deserialize, TX_WITH_WITNESS, stream5);\n+    CTransactionRef ptx5{MakeTransactionRef(tx5)};\n+    BOOST_CHECK_EQUAL(tx5.GetWitnessHash(), wtxid_5);\n+    Txid txid_5{TxidFromString(\"0xb4749f017444b051c44dfd2720e88f314ff94f3dd6d56d40ef65854fcd7fff6b\")};\n+    BOOST_CHECK_EQUAL(tx5.GetHash(), txid_5);\n+\n+    // Random real segwit transaction, corresponds to wtxid_6\n+    DataStream stream6{\n+        ParseHex(\"0200000000010177862801f77c2c068a70372b4c435ef8dd621291c36a64eb4dd491f02218f5324600000000fdffffff014a0100000000000022512035ea312034cfac01e956a269f3bf147f569c2fbb00180677421262da042290d803402be713325ff285e66b0380f53f2fae0d0fb4e16f378a440fed51ce835061437566729d4883bc917632f3cff474d6384bc8b989961a1d730d4a87ed38ad28bd337b20f1d658c6c138b1c312e072b4446f50f01ae0da03a42e6274f8788aae53416a7fac0063036f7264010118746578742f706c61696e3b636861727365743d7574662d3800357b2270223a226272632d3230222c226f70223a226d696e74222c227469636b223a224342414c222c22616d74223a2236393639227d6821c1f1d658c6c138b1c312e072b4446f50f01ae0da03a42e6274f8788aae53416a7f00000000\"),\n+    };\n+    CTransaction tx6(deserialize, TX_WITH_WITNESS, stream6);\n+    CTransactionRef ptx6{MakeTransactionRef(tx6)};\n+    BOOST_CHECK_EQUAL(tx6.GetWitnessHash(), wtxid_6);\n+    Txid txid_6{TxidFromString(\"0xee707be5201160e32c4fc715bec227d1aeea5940fb4295605e7373edce3b1a93\")};\n+    BOOST_CHECK_EQUAL(tx6.GetHash(), txid_6);\n+\n+    // Testing that both functions compare using GetHex() and not uint256.\n+    // In these pairs of wtxids, hex string order != uint256 order\n+    BOOST_CHECK(wtxid_3 < wtxid_1);\n+    BOOST_CHECK(wtxid_3 < wtxid_2);\n+    BOOST_CHECK(wtxid_5 < wtxid_4);\n+\n+    // Testing that package hash is using wtxids, not txids.\n+    BOOST_CHECK(txid_4.ToUint256() != wtxid_4.ToUint256());\n+    BOOST_CHECK(txid_6.ToUint256() != wtxid_6.ToUint256());\n+\n+    // Testing that package hash is sorting by wtxids, not txids.\n+    // For tx4 and tx5, txid order != wtxid order\n+    BOOST_CHECK(txid_5.GetHex() < txid_4.GetHex());",
      "path": "src/test/txpackage_tests.cpp",
      "position": null,
      "original_position": 84,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "54d0c78d104fb5412a194816590a06cad8cadf80",
      "in_reply_to_id": null,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In: 54d0c78d104fb5412a194816590a06cad8cadf80\r\n\r\nI'm struggling to see the usefulness of this. You are showing that, for the provided transactions, the ordering may be different based on the representation used (`wtxid`/`txid`/`ToUint256`/`GetHex`), but I don't think this clearly shows that the package hash is using one or the other.\r\n\r\nYou are already proving that the order is the one you are expecting by manually computing `calculated_hash_456`. You could also create different orderings based on `ToUint256` (instead of `GetHex`) and `txid` (instead of `wtxid`) and check how those are not equal to `calculated_hash_456` (after having checked that all of the permutations of `GetPackageHash` are equal to `calculated_hash_456`)",
      "created_at": "2024-04-17T16:06:56Z",
      "updated_at": "2024-04-17T20:17:07Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1569100856",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1569100856"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": 101,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 113,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1569200313",
      "pull_request_review_id": 2004484626,
      "id": 1569200313,
      "node_id": "PRRC_kwDOABII585diBi5",
      "diff_hunk": "@@ -190,17 +296,28 @@ BOOST_FIXTURE_TEST_CASE(noncontextual_package_tests, TestChain100Setup)\n         BOOST_CHECK_EQUAL(state.GetRejectReason(), \"package-not-sorted\");\n         BOOST_CHECK(IsChildWithParents({tx_parent, tx_child}));\n         BOOST_CHECK(IsChildWithParentsTree({tx_parent, tx_child}));\n+        BOOST_CHECK_EQUAL(GetPackageHash({tx_child}), GetCombinedHash({tx_child->GetWitnessHash()}));",
      "path": "src/test/txpackage_tests.cpp",
      "position": null,
      "original_position": 127,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "54d0c78d104fb5412a194816590a06cad8cadf80",
      "in_reply_to_id": null,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In: 54d0c78d104fb5412a194816590a06cad8cadf80\r\n\r\nnit: I think it wouldn't hurt to have a comment here along the lines of:\r\n\r\n```\r\n/// Check that `GetPackageHash`/ `GetCombinedHash` are consistent with each other, and that the input order does not affect the resulting hash \r\n```",
      "created_at": "2024-04-17T17:23:42Z",
      "updated_at": "2024-04-17T20:17:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1569200313",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1569200313"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 299,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1569461340",
      "pull_request_review_id": 2004484626,
      "id": 1569461340,
      "node_id": "PRRC_kwDOABII585djBRc",
      "diff_hunk": "@@ -138,4 +162,51 @@ BOOST_AUTO_TEST_CASE(DoS_mapOrphans)\n     BOOST_CHECK(orphanage.CountOrphans() == 0);\n }\n \n+BOOST_AUTO_TEST_CASE(get_children)\n+{\n+    FastRandomContext det_rand{true};\n+    TxOrphanage orphanage;\n+    const NodeId node{0};\n+    std::vector<COutPoint> empty_outpoints;\n+\n+    auto parent1 = MakeTransactionSpending(empty_outpoints, det_rand);\n+    auto parent2 = MakeTransactionSpending(empty_outpoints, det_rand);\n+\n+    // Make sure these parents have different txids otherwise this test won't make sense.\n+    while (parent1->GetHash() == parent2->GetHash()) {\n+        parent2 = MakeTransactionSpending(empty_outpoints, det_rand);\n+    }\n+\n+    // Create children to go into orphanage.\n+    auto child_p1n0 = MakeTransactionSpending({{parent1->GetHash(), 0}}, det_rand);\n+    auto child_p2n1 = MakeTransactionSpending({{parent2->GetHash(), 1}}, det_rand);\n+    // Spends the same tx twice. Should not cause duplicates in GetChildren.\n+    auto child_p1n0_p1n1 = MakeTransactionSpending({{parent1->GetHash(), 0}, {parent1->GetHash(), 1}}, det_rand);\n+    // Spends the same outpoint as previous tx. Should still be returned; don't assume outpoints are unique.\n+    auto child_p1n0_p2n0 = MakeTransactionSpending({{parent1->GetHash(), 0}, {parent2->GetHash(), 0}}, det_rand);\n+\n+    BOOST_CHECK(orphanage.AddTx(child_p1n0, node));\n+    BOOST_CHECK(orphanage.AddTx(child_p2n1, node));\n+    BOOST_CHECK(orphanage.AddTx(child_p1n0_p1n1, node));\n+    BOOST_CHECK(orphanage.AddTx(child_p1n0_p2n0, node));\n+\n+    // Check that GetChildren returns what is expected.\n+    std::set<Wtxid> expected_parent1_children{child_p1n0->GetWitnessHash(), child_p1n0_p2n0->GetWitnessHash(), child_p1n0_p1n1->GetWitnessHash()};\n+    std::set<Wtxid> expected_parent2_children{child_p2n1->GetWitnessHash(), child_p1n0_p2n0->GetWitnessHash()};",
      "path": "src/test/orphanage_tests.cpp",
      "position": null,
      "original_position": 75,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "91f4efa420958a93f4620379f8830231f276b23b",
      "in_reply_to_id": null,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "in 91f4efa420958a93f4620379f8830231f276b23b\r\n\r\nThis should also be comparable by `CTransactionRef`, shouldn't it? So `GetWitnessHash` doesn't need to be called here and in following loops",
      "created_at": "2024-04-17T20:08:47Z",
      "updated_at": "2024-04-17T20:17:07Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1569461340",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1569461340"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": 194,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 195,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1569471367",
      "pull_request_review_id": 2004484626,
      "id": 1569471367,
      "node_id": "PRRC_kwDOABII585djDuH",
      "diff_hunk": "@@ -138,4 +162,51 @@ BOOST_AUTO_TEST_CASE(DoS_mapOrphans)\n     BOOST_CHECK(orphanage.CountOrphans() == 0);\n }\n \n+BOOST_AUTO_TEST_CASE(get_children)\n+{\n+    FastRandomContext det_rand{true};\n+    TxOrphanage orphanage;\n+    const NodeId node{0};\n+    std::vector<COutPoint> empty_outpoints;\n+\n+    auto parent1 = MakeTransactionSpending(empty_outpoints, det_rand);\n+    auto parent2 = MakeTransactionSpending(empty_outpoints, det_rand);\n+\n+    // Make sure these parents have different txids otherwise this test won't make sense.\n+    while (parent1->GetHash() == parent2->GetHash()) {\n+        parent2 = MakeTransactionSpending(empty_outpoints, det_rand);\n+    }\n+\n+    // Create children to go into orphanage.\n+    auto child_p1n0 = MakeTransactionSpending({{parent1->GetHash(), 0}}, det_rand);\n+    auto child_p2n1 = MakeTransactionSpending({{parent2->GetHash(), 1}}, det_rand);\n+    // Spends the same tx twice. Should not cause duplicates in GetChildren.\n+    auto child_p1n0_p1n1 = MakeTransactionSpending({{parent1->GetHash(), 0}, {parent1->GetHash(), 1}}, det_rand);\n+    // Spends the same outpoint as previous tx. Should still be returned; don't assume outpoints are unique.\n+    auto child_p1n0_p2n0 = MakeTransactionSpending({{parent1->GetHash(), 0}, {parent2->GetHash(), 0}}, det_rand);\n+\n+    BOOST_CHECK(orphanage.AddTx(child_p1n0, node));\n+    BOOST_CHECK(orphanage.AddTx(child_p2n1, node));\n+    BOOST_CHECK(orphanage.AddTx(child_p1n0_p1n1, node));\n+    BOOST_CHECK(orphanage.AddTx(child_p1n0_p2n0, node));\n+\n+    // Check that GetChildren returns what is expected.\n+    std::set<Wtxid> expected_parent1_children{child_p1n0->GetWitnessHash(), child_p1n0_p2n0->GetWitnessHash(), child_p1n0_p1n1->GetWitnessHash()};\n+    std::set<Wtxid> expected_parent2_children{child_p2n1->GetWitnessHash(), child_p1n0_p2n0->GetWitnessHash()};\n+\n+    auto parent1_children{orphanage.GetChildren(parent1)};\n+    BOOST_CHECK_EQUAL(parent1_children.size(), expected_parent1_children.size());\n+    for (const auto& [child, peer] : parent1_children) {\n+        BOOST_CHECK(expected_parent1_children.contains(child->GetWitnessHash()));\n+    }\n+    auto parent2_children{orphanage.GetChildren(parent2)};\n+    BOOST_CHECK_EQUAL(parent2_children.size(), expected_parent2_children.size());\n+    for (const auto& [child, peer] : parent2_children) {\n+        BOOST_CHECK(expected_parent2_children.count(child->GetWitnessHash()) > 0);",
      "path": "src/test/orphanage_tests.cpp",
      "position": null,
      "original_position": 85,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "91f4efa420958a93f4620379f8830231f276b23b",
      "in_reply_to_id": null,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "in: 91f4efa420958a93f4620379f8830231f276b23b\r\n\r\nnit: Use `contains` instead of `count(...) > 0` for consistency with the previous check (previous loop)",
      "created_at": "2024-04-17T20:14:01Z",
      "updated_at": "2024-04-17T20:17:07Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1569471367",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1569471367"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 205,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1570150713",
      "pull_request_review_id": 2008064624,
      "id": 1570150713,
      "node_id": "PRRC_kwDOABII585dlpk5",
      "diff_hunk": "@@ -0,0 +1,129 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test that 1p1c package submission allows a 1p1c package to propagate in a \"network\" of nodes. Send\n+various packages from different nodes on a network in which some nodes have already received some of\n+the transactions (and submitted them to mempool, kept them as orphans or rejected them as\n+too-low-feerate transactions). The packages should be received and accepted by all nodes.\n+\"\"\"\n+\n+from decimal import Decimal\n+from test_framework.messages import (\n+    CInv,\n+    MSG_WTX,\n+    msg_inv,\n+    msg_tx,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    fill_mempool,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 4\n+        # hugely speeds up the test, as it involves multiple hops of tx relay.\n+        self.noban_tx_relay = True\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+        ]] * self.num_nodes\n+        self.supports_cli = False\n+\n+    def raise_network_minfee(self):\n+        filler_wallet = MiniWallet(self.nodes[0])\n+        fill_mempool(self, self.nodes[0], filler_wallet)\n+\n+        self.log.debug(\"Wait for the network to sync mempools\")\n+        self.sync_mempools()\n+\n+        self.log.debug(\"Check that all nodes' mempool minimum feerates are above min relay feerate\")\n+        for node in self.nodes:\n+            assert_equal(node.getmempoolinfo()['minrelaytxfee'], FEERATE_1SAT_VB)\n+            assert_greater_than(node.getmempoolinfo()['mempoolminfee'], FEERATE_1SAT_VB)\n+\n+    def create_packages(self):\n+        # Basic 1-parent-1-child package, parent 1sat/vB, child 999sat/vB\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+        package_hex_basic = [low_fee_parent[\"hex\"], high_fee_child[\"hex\"]]\n+\n+        # Basic 1-parent-1-child package, parent 1sat/vB, child 999sat/vB\n+        # Parent's txid is the same as its wtxid.\n+        low_fee_parent_nonsegwit = self.wallet_nonsegwit.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        assert_equal(low_fee_parent_nonsegwit[\"txid\"], low_fee_parent_nonsegwit[\"wtxid\"])\n+        high_fee_child_nonsegwit = self.wallet_nonsegwit.create_self_transfer(utxo_to_spend=low_fee_parent_nonsegwit[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+        assert_equal(high_fee_child_nonsegwit[\"txid\"], high_fee_child_nonsegwit[\"wtxid\"])\n+        package_hex_basic_nonsegwit = [low_fee_parent_nonsegwit[\"hex\"], high_fee_child_nonsegwit[\"hex\"]]\n+\n+        packages_to_submit = []\n+        transactions_to_presend = [[]] * self.num_nodes\n+\n+        # node0: sender\n+        # node1: pre-received the child (orphan)\n+        # node2: pre-received nothing\n+        # node3: pre-received the parent (too low fee)\n+        packages_to_submit.append(package_hex_basic)\n+        packages_to_submit.append(package_hex_basic_nonsegwit)\n+        transactions_to_presend[1] = [high_fee_child[\"tx\"], high_fee_child_nonsegwit[\"tx\"]]\n+        transactions_to_presend[3] = [low_fee_parent[\"tx\"], low_fee_parent_nonsegwit[\"tx\"]]\n+\n+        return packages_to_submit, transactions_to_presend\n+\n+    def run_test(self):\n+        self.wallet = MiniWallet(self.nodes[1])\n+        self.wallet_nonsegwit = MiniWallet(self.nodes[2], mode=MiniWalletMode.RAW_P2PK)\n+        self.generate(self.wallet_nonsegwit, 10)\n+        self.generate(self.wallet, 120)\n+\n+        self.log.info(\"Fill mempools with large transactions to raise mempool minimum feerates\")\n+        self.raise_network_minfee()\n+\n+        # Create the transactions.\n+        self.wallet.rescan_utxos(include_mempool=True)\n+        packages_to_submit, transactions_to_presend = self.create_packages()\n+\n+        self.peers = []\n+        for i in range(self.num_nodes):\n+            self.peers.append(self.nodes[i].add_p2p_connection(P2PInterface()))\n+\n+        self.log.info(\"Pre-send some transactions to nodes\")\n+        for i in range(self.num_nodes):\n+            peer = self.peers[i]\n+            for tx in transactions_to_presend[i]:\n+                inv = CInv(t=MSG_WTX, h=int(tx.getwtxid(), 16))\n+                peer.send_and_ping(msg_inv([inv]))\n+                peer.wait_for_getdata([int(tx.getwtxid(), 16)])",
      "path": "test/functional/p2p_1p1c_network.py",
      "position": null,
      "original_position": 111,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "142d584dab3725081344520bec0a092d6b58d996",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit, feel free to ignore: strictly speaking those 3 lines are not needed, as sending in the tx unsolicitedly (without prior inv/getdata) works as well, though not adhering to the typical protocol flow.",
      "created_at": "2024-04-18T07:25:22Z",
      "updated_at": "2024-04-18T07:40:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1570150713",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1570150713"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": 109,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 111,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1571005910",
      "pull_request_review_id": 2009283703,
      "id": 1571005910,
      "node_id": "PRRC_kwDOABII585do6XW",
      "diff_hunk": "@@ -0,0 +1,129 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test that 1p1c package submission allows a 1p1c package to propagate in a \"network\" of nodes. Send\n+various packages from different nodes on a network in which some nodes have already received some of\n+the transactions (and submitted them to mempool, kept them as orphans or rejected them as\n+too-low-feerate transactions). The packages should be received and accepted by all nodes.\n+\"\"\"\n+\n+from decimal import Decimal\n+from test_framework.messages import (\n+    CInv,\n+    MSG_WTX,\n+    msg_inv,\n+    msg_tx,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    fill_mempool,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 4\n+        # hugely speeds up the test, as it involves multiple hops of tx relay.\n+        self.noban_tx_relay = True\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+        ]] * self.num_nodes\n+        self.supports_cli = False\n+\n+    def raise_network_minfee(self):\n+        filler_wallet = MiniWallet(self.nodes[0])\n+        fill_mempool(self, self.nodes[0], filler_wallet)\n+\n+        self.log.debug(\"Wait for the network to sync mempools\")\n+        self.sync_mempools()\n+\n+        self.log.debug(\"Check that all nodes' mempool minimum feerates are above min relay feerate\")\n+        for node in self.nodes:\n+            assert_equal(node.getmempoolinfo()['minrelaytxfee'], FEERATE_1SAT_VB)\n+            assert_greater_than(node.getmempoolinfo()['mempoolminfee'], FEERATE_1SAT_VB)\n+\n+    def create_packages(self):\n+        # Basic 1-parent-1-child package, parent 1sat/vB, child 999sat/vB\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+        package_hex_basic = [low_fee_parent[\"hex\"], high_fee_child[\"hex\"]]\n+\n+        # Basic 1-parent-1-child package, parent 1sat/vB, child 999sat/vB\n+        # Parent's txid is the same as its wtxid.\n+        low_fee_parent_nonsegwit = self.wallet_nonsegwit.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        assert_equal(low_fee_parent_nonsegwit[\"txid\"], low_fee_parent_nonsegwit[\"wtxid\"])\n+        high_fee_child_nonsegwit = self.wallet_nonsegwit.create_self_transfer(utxo_to_spend=low_fee_parent_nonsegwit[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+        assert_equal(high_fee_child_nonsegwit[\"txid\"], high_fee_child_nonsegwit[\"wtxid\"])\n+        package_hex_basic_nonsegwit = [low_fee_parent_nonsegwit[\"hex\"], high_fee_child_nonsegwit[\"hex\"]]\n+\n+        packages_to_submit = []\n+        transactions_to_presend = [[]] * self.num_nodes\n+\n+        # node0: sender\n+        # node1: pre-received the child (orphan)\n+        # node2: pre-received nothing\n+        # node3: pre-received the parent (too low fee)\n+        packages_to_submit.append(package_hex_basic)\n+        packages_to_submit.append(package_hex_basic_nonsegwit)\n+        transactions_to_presend[1] = [high_fee_child[\"tx\"], high_fee_child_nonsegwit[\"tx\"]]\n+        transactions_to_presend[3] = [low_fee_parent[\"tx\"], low_fee_parent_nonsegwit[\"tx\"]]\n+\n+        return packages_to_submit, transactions_to_presend\n+\n+    def run_test(self):\n+        self.wallet = MiniWallet(self.nodes[1])\n+        self.wallet_nonsegwit = MiniWallet(self.nodes[2], mode=MiniWalletMode.RAW_P2PK)\n+        self.generate(self.wallet_nonsegwit, 10)\n+        self.generate(self.wallet, 120)\n+\n+        self.log.info(\"Fill mempools with large transactions to raise mempool minimum feerates\")\n+        self.raise_network_minfee()\n+\n+        # Create the transactions.\n+        self.wallet.rescan_utxos(include_mempool=True)\n+        packages_to_submit, transactions_to_presend = self.create_packages()\n+\n+        self.peers = []\n+        for i in range(self.num_nodes):\n+            self.peers.append(self.nodes[i].add_p2p_connection(P2PInterface()))\n+\n+        self.log.info(\"Pre-send some transactions to nodes\")\n+        for i in range(self.num_nodes):\n+            peer = self.peers[i]\n+            for tx in transactions_to_presend[i]:\n+                inv = CInv(t=MSG_WTX, h=int(tx.getwtxid(), 16))\n+                peer.send_and_ping(msg_inv([inv]))\n+                peer.wait_for_getdata([int(tx.getwtxid(), 16)])",
      "path": "test/functional/p2p_1p1c_network.py",
      "position": null,
      "original_position": 111,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "142d584dab3725081344520bec0a092d6b58d996",
      "in_reply_to_id": 1570150713,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "removed",
      "created_at": "2024-04-18T15:48:10Z",
      "updated_at": "2024-04-18T16:02:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1571005910",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1571005910"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": 109,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 111,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1571006395",
      "pull_request_review_id": 2009283703,
      "id": 1571006395,
      "node_id": "PRRC_kwDOABII585do6e7",
      "diff_hunk": "@@ -190,17 +296,28 @@ BOOST_FIXTURE_TEST_CASE(noncontextual_package_tests, TestChain100Setup)\n         BOOST_CHECK_EQUAL(state.GetRejectReason(), \"package-not-sorted\");\n         BOOST_CHECK(IsChildWithParents({tx_parent, tx_child}));\n         BOOST_CHECK(IsChildWithParentsTree({tx_parent, tx_child}));\n+        BOOST_CHECK_EQUAL(GetPackageHash({tx_child}), GetCombinedHash({tx_child->GetWitnessHash()}));",
      "path": "src/test/txpackage_tests.cpp",
      "position": null,
      "original_position": 127,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "54d0c78d104fb5412a194816590a06cad8cadf80",
      "in_reply_to_id": 1569200313,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "(deleted `GetCombinedHash`)",
      "created_at": "2024-04-18T15:48:31Z",
      "updated_at": "2024-04-18T16:02:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1571006395",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1571006395"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 299,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1571006616",
      "pull_request_review_id": 2009283703,
      "id": 1571006616,
      "node_id": "PRRC_kwDOABII585do6iY",
      "diff_hunk": "@@ -40,6 +43,109 @@ inline CTransactionRef create_placeholder_tx(size_t num_inputs, size_t num_outpu\n     return MakeTransactionRef(mtx);\n }\n \n+// Create a Wtxid from a hex string\n+inline Wtxid WtxidFromString(std::string_view str)\n+{\n+    return Wtxid::FromUint256(uint256S(str.data()));\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(package_hash_tests, TestChain100Setup)\n+{\n+    // Some wtxids, in lexicographical order:\n+    Wtxid wtxid_0{WtxidFromString(\"0x0000000000000000000000000000000000000000000000000000000000000000\")};\n+    Wtxid wtxid_1{WtxidFromString(\"0x0000000000000000000000000000000000000000000000000000000000000001\")};\n+    Wtxid wtxid_2{WtxidFromString(\"0x00000000000000000000000000000000000000000000000000000000ffffffff\")};\n+    Wtxid wtxid_3{WtxidFromString(\"0x1000000000000000000000000000000000000000000000000000000000000000\")};\n+    Wtxid wtxid_4{WtxidFromString(\"0x85cd1a31eb38f74ed5742ec9cb546712ab5aaf747de28a9168b53e846cbda17f\")};\n+    Wtxid wtxid_5{WtxidFromString(\"0xb4749f017444b051c44dfd2720e88f314ff94f3dd6d56d40ef65854fcd7fff6b\")};\n+    Wtxid wtxid_6{WtxidFromString(\"0xe065bac15f62bb4e761d761db928ddee65a47296b2b776785abb912cdec474e3\")};\n+\n+    BOOST_CHECK(wtxid_0.GetHex() < wtxid_1.GetHex());\n+    BOOST_CHECK(wtxid_1.GetHex() < wtxid_2.GetHex());\n+    BOOST_CHECK(wtxid_2.GetHex() < wtxid_3.GetHex());\n+    BOOST_CHECK(wtxid_1.GetHex() < wtxid_3.GetHex());\n+    BOOST_CHECK(wtxid_3.GetHex() < wtxid_4.GetHex());\n+    BOOST_CHECK(wtxid_4.GetHex() < wtxid_5.GetHex());\n+    BOOST_CHECK(wtxid_5.GetHex() < wtxid_6.GetHex());\n+\n+    // Random real segwit transaction, corresponds to wtxid_4\n+    DataStream stream4{\n+        ParseHex(\"02000000000101964b8aa63509579ca6086e6012eeaa4c2f4dd1e283da29b67c8eea38b3c6fd220000000000fdffffff0294c618000000000017a9145afbbb42f4e83312666d0697f9e66259912ecde38768fa2c0000000000160014897388a0889390fd0e153a22bb2cf9d8f019faf50247304402200547406380719f84d68cf4e96cc3e4a1688309ef475b150be2b471c70ea562aa02206d255f5acc40fd95981874d77201d2eb07883657ce1c796513f32b6079545cdf0121023ae77335cefcb5ab4c1dc1fb0d2acfece184e593727d7d5906c78e564c7c11d125cf0c00\"),\n+    };\n+    CTransaction tx4(deserialize, TX_WITH_WITNESS, stream4);\n+    CTransactionRef ptx4{MakeTransactionRef(tx4)};\n+    Txid txid_4{TxidFromString(\"0xbd0f71c1d5e50589063e134fad22053cdae5ab2320db5bf5e540198b0b5a4e69\")};\n+    BOOST_CHECK_EQUAL(tx4.GetHash(), txid_4);\n+    BOOST_CHECK_EQUAL(tx4.GetWitnessHash(), wtxid_4);\n+\n+    // Random real nonsegwit transaction, corresponds to wtxid_5\n+    DataStream stream5{\n+        ParseHex(\"01000000010b26e9b7735eb6aabdf358bab62f9816a21ba9ebdb719d5299e88607d722c190000000008b4830450220070aca44506c5cef3a16ed519d7c3c39f8aab192c4e1c90d065f37b8a4af6141022100a8e160b856c2d43d27d8fba71e5aef6405b8643ac4cb7cb3c462aced7f14711a0141046d11fee51b0e60666d5049a9101a72741df480b96ee26488a4d3466b95c9a40ac5eeef87e10a5cd336c19a84565f80fa6c547957b7700ff4dfbdefe76036c339ffffffff021bff3d11000000001976a91404943fdd508053c75000106d3bc6e2754dbcff1988ac2f15de00000000001976a914a266436d2965547608b9e15d9032a7b9d64fa43188ac00000000\"),\n+    };\n+    CTransaction tx5(deserialize, TX_WITH_WITNESS, stream5);\n+    CTransactionRef ptx5{MakeTransactionRef(tx5)};\n+    BOOST_CHECK_EQUAL(tx5.GetWitnessHash(), wtxid_5);\n+    Txid txid_5{TxidFromString(\"0xb4749f017444b051c44dfd2720e88f314ff94f3dd6d56d40ef65854fcd7fff6b\")};\n+    BOOST_CHECK_EQUAL(tx5.GetHash(), txid_5);\n+\n+    // Random real segwit transaction, corresponds to wtxid_6\n+    DataStream stream6{\n+        ParseHex(\"0200000000010177862801f77c2c068a70372b4c435ef8dd621291c36a64eb4dd491f02218f5324600000000fdffffff014a0100000000000022512035ea312034cfac01e956a269f3bf147f569c2fbb00180677421262da042290d803402be713325ff285e66b0380f53f2fae0d0fb4e16f378a440fed51ce835061437566729d4883bc917632f3cff474d6384bc8b989961a1d730d4a87ed38ad28bd337b20f1d658c6c138b1c312e072b4446f50f01ae0da03a42e6274f8788aae53416a7fac0063036f7264010118746578742f706c61696e3b636861727365743d7574662d3800357b2270223a226272632d3230222c226f70223a226d696e74222c227469636b223a224342414c222c22616d74223a2236393639227d6821c1f1d658c6c138b1c312e072b4446f50f01ae0da03a42e6274f8788aae53416a7f00000000\"),\n+    };\n+    CTransaction tx6(deserialize, TX_WITH_WITNESS, stream6);\n+    CTransactionRef ptx6{MakeTransactionRef(tx6)};\n+    BOOST_CHECK_EQUAL(tx6.GetWitnessHash(), wtxid_6);\n+    Txid txid_6{TxidFromString(\"0xee707be5201160e32c4fc715bec227d1aeea5940fb4295605e7373edce3b1a93\")};\n+    BOOST_CHECK_EQUAL(tx6.GetHash(), txid_6);\n+\n+    // Testing that both functions compare using GetHex() and not uint256.\n+    // In these pairs of wtxids, hex string order != uint256 order\n+    BOOST_CHECK(wtxid_3 < wtxid_1);\n+    BOOST_CHECK(wtxid_3 < wtxid_2);\n+    BOOST_CHECK(wtxid_5 < wtxid_4);\n+\n+    // Testing that package hash is using wtxids, not txids.\n+    BOOST_CHECK(txid_4.ToUint256() != wtxid_4.ToUint256());\n+    BOOST_CHECK(txid_6.ToUint256() != wtxid_6.ToUint256());\n+\n+    // Testing that package hash is sorting by wtxids, not txids.\n+    // For tx4 and tx5, txid order != wtxid order\n+    BOOST_CHECK(txid_5.GetHex() < txid_4.GetHex());\n+\n+    // All permutations of the package containing ptx4, ptx5, ptx6\n+    std::vector<CTransactionRef> package_456{ptx4, ptx5, ptx6};\n+    std::vector<CTransactionRef> package_465{ptx4, ptx6, ptx5};\n+    std::vector<CTransactionRef> package_564{ptx5, ptx6, ptx4};\n+    std::vector<CTransactionRef> package_546{ptx5, ptx4, ptx6};\n+    std::vector<CTransactionRef> package_645{ptx6, ptx4, ptx5};\n+    std::vector<CTransactionRef> package_654{ptx6, ptx5, ptx4};\n+    // All of them must have the same package hash 2dc93431aa6eb415a4e0995f77c78098d7ed97ca6f123a0d77a7747339525acd\n+    std::vector<uint256> expected_order_txns{wtxid_4.ToUint256(), wtxid_5.ToUint256(), wtxid_6.ToUint256()};\n+    uint256 calculated_hash_456 = (HashWriter() << expected_order_txns).GetHash();\n+    BOOST_CHECK_EQUAL(calculated_hash_456, GetPackageHash(package_456));\n+    BOOST_CHECK_EQUAL(calculated_hash_456, GetPackageHash(package_465));\n+    BOOST_CHECK_EQUAL(calculated_hash_456, GetPackageHash(package_564));\n+    BOOST_CHECK_EQUAL(calculated_hash_456, GetPackageHash(package_546));\n+    BOOST_CHECK_EQUAL(calculated_hash_456, GetPackageHash(package_645));\n+    BOOST_CHECK_EQUAL(calculated_hash_456, GetPackageHash(package_654));\n+    // GetCombinedHash is consistent with GetPackageHash: try a couple permutations\n+    std::vector<Wtxid> wtxids_546{wtxid_5, wtxid_4, wtxid_6};\n+    BOOST_CHECK_EQUAL(calculated_hash_456, GetCombinedHash(wtxids_546));\n+    std::vector<Wtxid> wtxids_654{wtxid_6, wtxid_5, wtxid_4};\n+    BOOST_CHECK_EQUAL(calculated_hash_456, GetCombinedHash(wtxids_654));\n+\n+    std::vector<uint256> expected_order_wtxids{wtxid_1.ToUint256(), wtxid_2.ToUint256(), wtxid_3.ToUint256(),",
      "path": "src/test/txpackage_tests.cpp",
      "position": null,
      "original_position": 108,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "54d0c78d104fb5412a194816590a06cad8cadf80",
      "in_reply_to_id": 1569086405,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "done, thanks",
      "created_at": "2024-04-18T15:48:42Z",
      "updated_at": "2024-04-18T16:02:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1571006616",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1571006616"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 137,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1571006745",
      "pull_request_review_id": 2009283703,
      "id": 1571006745,
      "node_id": "PRRC_kwDOABII585do6kZ",
      "diff_hunk": "@@ -40,6 +43,109 @@ inline CTransactionRef create_placeholder_tx(size_t num_inputs, size_t num_outpu\n     return MakeTransactionRef(mtx);\n }\n \n+// Create a Wtxid from a hex string\n+inline Wtxid WtxidFromString(std::string_view str)\n+{\n+    return Wtxid::FromUint256(uint256S(str.data()));\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(package_hash_tests, TestChain100Setup)\n+{\n+    // Some wtxids, in lexicographical order:\n+    Wtxid wtxid_0{WtxidFromString(\"0x0000000000000000000000000000000000000000000000000000000000000000\")};\n+    Wtxid wtxid_1{WtxidFromString(\"0x0000000000000000000000000000000000000000000000000000000000000001\")};\n+    Wtxid wtxid_2{WtxidFromString(\"0x00000000000000000000000000000000000000000000000000000000ffffffff\")};\n+    Wtxid wtxid_3{WtxidFromString(\"0x1000000000000000000000000000000000000000000000000000000000000000\")};\n+    Wtxid wtxid_4{WtxidFromString(\"0x85cd1a31eb38f74ed5742ec9cb546712ab5aaf747de28a9168b53e846cbda17f\")};\n+    Wtxid wtxid_5{WtxidFromString(\"0xb4749f017444b051c44dfd2720e88f314ff94f3dd6d56d40ef65854fcd7fff6b\")};\n+    Wtxid wtxid_6{WtxidFromString(\"0xe065bac15f62bb4e761d761db928ddee65a47296b2b776785abb912cdec474e3\")};\n+\n+    BOOST_CHECK(wtxid_0.GetHex() < wtxid_1.GetHex());\n+    BOOST_CHECK(wtxid_1.GetHex() < wtxid_2.GetHex());\n+    BOOST_CHECK(wtxid_2.GetHex() < wtxid_3.GetHex());\n+    BOOST_CHECK(wtxid_1.GetHex() < wtxid_3.GetHex());\n+    BOOST_CHECK(wtxid_3.GetHex() < wtxid_4.GetHex());\n+    BOOST_CHECK(wtxid_4.GetHex() < wtxid_5.GetHex());\n+    BOOST_CHECK(wtxid_5.GetHex() < wtxid_6.GetHex());\n+\n+    // Random real segwit transaction, corresponds to wtxid_4\n+    DataStream stream4{\n+        ParseHex(\"02000000000101964b8aa63509579ca6086e6012eeaa4c2f4dd1e283da29b67c8eea38b3c6fd220000000000fdffffff0294c618000000000017a9145afbbb42f4e83312666d0697f9e66259912ecde38768fa2c0000000000160014897388a0889390fd0e153a22bb2cf9d8f019faf50247304402200547406380719f84d68cf4e96cc3e4a1688309ef475b150be2b471c70ea562aa02206d255f5acc40fd95981874d77201d2eb07883657ce1c796513f32b6079545cdf0121023ae77335cefcb5ab4c1dc1fb0d2acfece184e593727d7d5906c78e564c7c11d125cf0c00\"),\n+    };\n+    CTransaction tx4(deserialize, TX_WITH_WITNESS, stream4);\n+    CTransactionRef ptx4{MakeTransactionRef(tx4)};\n+    Txid txid_4{TxidFromString(\"0xbd0f71c1d5e50589063e134fad22053cdae5ab2320db5bf5e540198b0b5a4e69\")};\n+    BOOST_CHECK_EQUAL(tx4.GetHash(), txid_4);\n+    BOOST_CHECK_EQUAL(tx4.GetWitnessHash(), wtxid_4);\n+\n+    // Random real nonsegwit transaction, corresponds to wtxid_5\n+    DataStream stream5{\n+        ParseHex(\"01000000010b26e9b7735eb6aabdf358bab62f9816a21ba9ebdb719d5299e88607d722c190000000008b4830450220070aca44506c5cef3a16ed519d7c3c39f8aab192c4e1c90d065f37b8a4af6141022100a8e160b856c2d43d27d8fba71e5aef6405b8643ac4cb7cb3c462aced7f14711a0141046d11fee51b0e60666d5049a9101a72741df480b96ee26488a4d3466b95c9a40ac5eeef87e10a5cd336c19a84565f80fa6c547957b7700ff4dfbdefe76036c339ffffffff021bff3d11000000001976a91404943fdd508053c75000106d3bc6e2754dbcff1988ac2f15de00000000001976a914a266436d2965547608b9e15d9032a7b9d64fa43188ac00000000\"),\n+    };\n+    CTransaction tx5(deserialize, TX_WITH_WITNESS, stream5);\n+    CTransactionRef ptx5{MakeTransactionRef(tx5)};\n+    BOOST_CHECK_EQUAL(tx5.GetWitnessHash(), wtxid_5);\n+    Txid txid_5{TxidFromString(\"0xb4749f017444b051c44dfd2720e88f314ff94f3dd6d56d40ef65854fcd7fff6b\")};\n+    BOOST_CHECK_EQUAL(tx5.GetHash(), txid_5);\n+\n+    // Random real segwit transaction, corresponds to wtxid_6\n+    DataStream stream6{\n+        ParseHex(\"0200000000010177862801f77c2c068a70372b4c435ef8dd621291c36a64eb4dd491f02218f5324600000000fdffffff014a0100000000000022512035ea312034cfac01e956a269f3bf147f569c2fbb00180677421262da042290d803402be713325ff285e66b0380f53f2fae0d0fb4e16f378a440fed51ce835061437566729d4883bc917632f3cff474d6384bc8b989961a1d730d4a87ed38ad28bd337b20f1d658c6c138b1c312e072b4446f50f01ae0da03a42e6274f8788aae53416a7fac0063036f7264010118746578742f706c61696e3b636861727365743d7574662d3800357b2270223a226272632d3230222c226f70223a226d696e74222c227469636b223a224342414c222c22616d74223a2236393639227d6821c1f1d658c6c138b1c312e072b4446f50f01ae0da03a42e6274f8788aae53416a7f00000000\"),\n+    };\n+    CTransaction tx6(deserialize, TX_WITH_WITNESS, stream6);\n+    CTransactionRef ptx6{MakeTransactionRef(tx6)};\n+    BOOST_CHECK_EQUAL(tx6.GetWitnessHash(), wtxid_6);\n+    Txid txid_6{TxidFromString(\"0xee707be5201160e32c4fc715bec227d1aeea5940fb4295605e7373edce3b1a93\")};\n+    BOOST_CHECK_EQUAL(tx6.GetHash(), txid_6);\n+\n+    // Testing that both functions compare using GetHex() and not uint256.\n+    // In these pairs of wtxids, hex string order != uint256 order\n+    BOOST_CHECK(wtxid_3 < wtxid_1);\n+    BOOST_CHECK(wtxid_3 < wtxid_2);\n+    BOOST_CHECK(wtxid_5 < wtxid_4);\n+\n+    // Testing that package hash is using wtxids, not txids.\n+    BOOST_CHECK(txid_4.ToUint256() != wtxid_4.ToUint256());\n+    BOOST_CHECK(txid_6.ToUint256() != wtxid_6.ToUint256());\n+\n+    // Testing that package hash is sorting by wtxids, not txids.\n+    // For tx4 and tx5, txid order != wtxid order\n+    BOOST_CHECK(txid_5.GetHex() < txid_4.GetHex());\n+\n+    // All permutations of the package containing ptx4, ptx5, ptx6\n+    std::vector<CTransactionRef> package_456{ptx4, ptx5, ptx6};\n+    std::vector<CTransactionRef> package_465{ptx4, ptx6, ptx5};\n+    std::vector<CTransactionRef> package_564{ptx5, ptx6, ptx4};\n+    std::vector<CTransactionRef> package_546{ptx5, ptx4, ptx6};\n+    std::vector<CTransactionRef> package_645{ptx6, ptx4, ptx5};\n+    std::vector<CTransactionRef> package_654{ptx6, ptx5, ptx4};\n+    // All of them must have the same package hash 2dc93431aa6eb415a4e0995f77c78098d7ed97ca6f123a0d77a7747339525acd\n+    std::vector<uint256> expected_order_txns{wtxid_4.ToUint256(), wtxid_5.ToUint256(), wtxid_6.ToUint256()};",
      "path": "src/test/txpackage_tests.cpp",
      "position": null,
      "original_position": 94,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "54d0c78d104fb5412a194816590a06cad8cadf80",
      "in_reply_to_id": 1569085792,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "done, thanks",
      "created_at": "2024-04-18T15:48:46Z",
      "updated_at": "2024-04-18T16:02:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1571006745",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1571006745"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 123,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1571013196",
      "pull_request_review_id": 2009283703,
      "id": 1571013196,
      "node_id": "PRRC_kwDOABII585do8JM",
      "diff_hunk": "@@ -40,6 +43,109 @@ inline CTransactionRef create_placeholder_tx(size_t num_inputs, size_t num_outpu\n     return MakeTransactionRef(mtx);\n }\n \n+// Create a Wtxid from a hex string\n+inline Wtxid WtxidFromString(std::string_view str)\n+{\n+    return Wtxid::FromUint256(uint256S(str.data()));\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(package_hash_tests, TestChain100Setup)\n+{\n+    // Some wtxids, in lexicographical order:\n+    Wtxid wtxid_0{WtxidFromString(\"0x0000000000000000000000000000000000000000000000000000000000000000\")};\n+    Wtxid wtxid_1{WtxidFromString(\"0x0000000000000000000000000000000000000000000000000000000000000001\")};\n+    Wtxid wtxid_2{WtxidFromString(\"0x00000000000000000000000000000000000000000000000000000000ffffffff\")};\n+    Wtxid wtxid_3{WtxidFromString(\"0x1000000000000000000000000000000000000000000000000000000000000000\")};\n+    Wtxid wtxid_4{WtxidFromString(\"0x85cd1a31eb38f74ed5742ec9cb546712ab5aaf747de28a9168b53e846cbda17f\")};\n+    Wtxid wtxid_5{WtxidFromString(\"0xb4749f017444b051c44dfd2720e88f314ff94f3dd6d56d40ef65854fcd7fff6b\")};\n+    Wtxid wtxid_6{WtxidFromString(\"0xe065bac15f62bb4e761d761db928ddee65a47296b2b776785abb912cdec474e3\")};\n+\n+    BOOST_CHECK(wtxid_0.GetHex() < wtxid_1.GetHex());\n+    BOOST_CHECK(wtxid_1.GetHex() < wtxid_2.GetHex());\n+    BOOST_CHECK(wtxid_2.GetHex() < wtxid_3.GetHex());\n+    BOOST_CHECK(wtxid_1.GetHex() < wtxid_3.GetHex());\n+    BOOST_CHECK(wtxid_3.GetHex() < wtxid_4.GetHex());\n+    BOOST_CHECK(wtxid_4.GetHex() < wtxid_5.GetHex());\n+    BOOST_CHECK(wtxid_5.GetHex() < wtxid_6.GetHex());\n+\n+    // Random real segwit transaction, corresponds to wtxid_4\n+    DataStream stream4{\n+        ParseHex(\"02000000000101964b8aa63509579ca6086e6012eeaa4c2f4dd1e283da29b67c8eea38b3c6fd220000000000fdffffff0294c618000000000017a9145afbbb42f4e83312666d0697f9e66259912ecde38768fa2c0000000000160014897388a0889390fd0e153a22bb2cf9d8f019faf50247304402200547406380719f84d68cf4e96cc3e4a1688309ef475b150be2b471c70ea562aa02206d255f5acc40fd95981874d77201d2eb07883657ce1c796513f32b6079545cdf0121023ae77335cefcb5ab4c1dc1fb0d2acfece184e593727d7d5906c78e564c7c11d125cf0c00\"),\n+    };\n+    CTransaction tx4(deserialize, TX_WITH_WITNESS, stream4);\n+    CTransactionRef ptx4{MakeTransactionRef(tx4)};\n+    Txid txid_4{TxidFromString(\"0xbd0f71c1d5e50589063e134fad22053cdae5ab2320db5bf5e540198b0b5a4e69\")};\n+    BOOST_CHECK_EQUAL(tx4.GetHash(), txid_4);\n+    BOOST_CHECK_EQUAL(tx4.GetWitnessHash(), wtxid_4);\n+\n+    // Random real nonsegwit transaction, corresponds to wtxid_5\n+    DataStream stream5{\n+        ParseHex(\"01000000010b26e9b7735eb6aabdf358bab62f9816a21ba9ebdb719d5299e88607d722c190000000008b4830450220070aca44506c5cef3a16ed519d7c3c39f8aab192c4e1c90d065f37b8a4af6141022100a8e160b856c2d43d27d8fba71e5aef6405b8643ac4cb7cb3c462aced7f14711a0141046d11fee51b0e60666d5049a9101a72741df480b96ee26488a4d3466b95c9a40ac5eeef87e10a5cd336c19a84565f80fa6c547957b7700ff4dfbdefe76036c339ffffffff021bff3d11000000001976a91404943fdd508053c75000106d3bc6e2754dbcff1988ac2f15de00000000001976a914a266436d2965547608b9e15d9032a7b9d64fa43188ac00000000\"),\n+    };\n+    CTransaction tx5(deserialize, TX_WITH_WITNESS, stream5);\n+    CTransactionRef ptx5{MakeTransactionRef(tx5)};\n+    BOOST_CHECK_EQUAL(tx5.GetWitnessHash(), wtxid_5);\n+    Txid txid_5{TxidFromString(\"0xb4749f017444b051c44dfd2720e88f314ff94f3dd6d56d40ef65854fcd7fff6b\")};\n+    BOOST_CHECK_EQUAL(tx5.GetHash(), txid_5);\n+\n+    // Random real segwit transaction, corresponds to wtxid_6\n+    DataStream stream6{\n+        ParseHex(\"0200000000010177862801f77c2c068a70372b4c435ef8dd621291c36a64eb4dd491f02218f5324600000000fdffffff014a0100000000000022512035ea312034cfac01e956a269f3bf147f569c2fbb00180677421262da042290d803402be713325ff285e66b0380f53f2fae0d0fb4e16f378a440fed51ce835061437566729d4883bc917632f3cff474d6384bc8b989961a1d730d4a87ed38ad28bd337b20f1d658c6c138b1c312e072b4446f50f01ae0da03a42e6274f8788aae53416a7fac0063036f7264010118746578742f706c61696e3b636861727365743d7574662d3800357b2270223a226272632d3230222c226f70223a226d696e74222c227469636b223a224342414c222c22616d74223a2236393639227d6821c1f1d658c6c138b1c312e072b4446f50f01ae0da03a42e6274f8788aae53416a7f00000000\"),\n+    };\n+    CTransaction tx6(deserialize, TX_WITH_WITNESS, stream6);\n+    CTransactionRef ptx6{MakeTransactionRef(tx6)};\n+    BOOST_CHECK_EQUAL(tx6.GetWitnessHash(), wtxid_6);\n+    Txid txid_6{TxidFromString(\"0xee707be5201160e32c4fc715bec227d1aeea5940fb4295605e7373edce3b1a93\")};\n+    BOOST_CHECK_EQUAL(tx6.GetHash(), txid_6);\n+\n+    // Testing that both functions compare using GetHex() and not uint256.\n+    // In these pairs of wtxids, hex string order != uint256 order\n+    BOOST_CHECK(wtxid_3 < wtxid_1);\n+    BOOST_CHECK(wtxid_3 < wtxid_2);\n+    BOOST_CHECK(wtxid_5 < wtxid_4);\n+\n+    // Testing that package hash is using wtxids, not txids.\n+    BOOST_CHECK(txid_4.ToUint256() != wtxid_4.ToUint256());\n+    BOOST_CHECK(txid_6.ToUint256() != wtxid_6.ToUint256());\n+\n+    // Testing that package hash is sorting by wtxids, not txids.\n+    // For tx4 and tx5, txid order != wtxid order\n+    BOOST_CHECK(txid_5.GetHex() < txid_4.GetHex());",
      "path": "src/test/txpackage_tests.cpp",
      "position": null,
      "original_position": 84,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "54d0c78d104fb5412a194816590a06cad8cadf80",
      "in_reply_to_id": 1569100856,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Ok added tests calculating what the hashes would be if we used another order + checking they're not the same",
      "created_at": "2024-04-18T15:53:18Z",
      "updated_at": "2024-04-18T16:02:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1571013196",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1571013196"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": 101,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 113,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1571014755",
      "pull_request_review_id": 2009283703,
      "id": 1571014755,
      "node_id": "PRRC_kwDOABII585do8hj",
      "diff_hunk": "@@ -40,6 +43,109 @@ inline CTransactionRef create_placeholder_tx(size_t num_inputs, size_t num_outpu\n     return MakeTransactionRef(mtx);\n }\n \n+// Create a Wtxid from a hex string\n+inline Wtxid WtxidFromString(std::string_view str)\n+{\n+    return Wtxid::FromUint256(uint256S(str.data()));\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(package_hash_tests, TestChain100Setup)\n+{\n+    // Some wtxids, in lexicographical order:\n+    Wtxid wtxid_0{WtxidFromString(\"0x0000000000000000000000000000000000000000000000000000000000000000\")};\n+    Wtxid wtxid_1{WtxidFromString(\"0x0000000000000000000000000000000000000000000000000000000000000001\")};\n+    Wtxid wtxid_2{WtxidFromString(\"0x00000000000000000000000000000000000000000000000000000000ffffffff\")};\n+    Wtxid wtxid_3{WtxidFromString(\"0x1000000000000000000000000000000000000000000000000000000000000000\")};\n+    Wtxid wtxid_4{WtxidFromString(\"0x85cd1a31eb38f74ed5742ec9cb546712ab5aaf747de28a9168b53e846cbda17f\")};\n+    Wtxid wtxid_5{WtxidFromString(\"0xb4749f017444b051c44dfd2720e88f314ff94f3dd6d56d40ef65854fcd7fff6b\")};\n+    Wtxid wtxid_6{WtxidFromString(\"0xe065bac15f62bb4e761d761db928ddee65a47296b2b776785abb912cdec474e3\")};\n+\n+    BOOST_CHECK(wtxid_0.GetHex() < wtxid_1.GetHex());\n+    BOOST_CHECK(wtxid_1.GetHex() < wtxid_2.GetHex());\n+    BOOST_CHECK(wtxid_2.GetHex() < wtxid_3.GetHex());\n+    BOOST_CHECK(wtxid_1.GetHex() < wtxid_3.GetHex());\n+    BOOST_CHECK(wtxid_3.GetHex() < wtxid_4.GetHex());\n+    BOOST_CHECK(wtxid_4.GetHex() < wtxid_5.GetHex());\n+    BOOST_CHECK(wtxid_5.GetHex() < wtxid_6.GetHex());\n+\n+    // Random real segwit transaction, corresponds to wtxid_4\n+    DataStream stream4{\n+        ParseHex(\"02000000000101964b8aa63509579ca6086e6012eeaa4c2f4dd1e283da29b67c8eea38b3c6fd220000000000fdffffff0294c618000000000017a9145afbbb42f4e83312666d0697f9e66259912ecde38768fa2c0000000000160014897388a0889390fd0e153a22bb2cf9d8f019faf50247304402200547406380719f84d68cf4e96cc3e4a1688309ef475b150be2b471c70ea562aa02206d255f5acc40fd95981874d77201d2eb07883657ce1c796513f32b6079545cdf0121023ae77335cefcb5ab4c1dc1fb0d2acfece184e593727d7d5906c78e564c7c11d125cf0c00\"),\n+    };\n+    CTransaction tx4(deserialize, TX_WITH_WITNESS, stream4);\n+    CTransactionRef ptx4{MakeTransactionRef(tx4)};\n+    Txid txid_4{TxidFromString(\"0xbd0f71c1d5e50589063e134fad22053cdae5ab2320db5bf5e540198b0b5a4e69\")};",
      "path": "src/test/txpackage_tests.cpp",
      "position": null,
      "original_position": 48,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "142d584dab3725081344520bec0a092d6b58d996",
      "in_reply_to_id": 1568990742,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I figure it's easier to read the test this way; you can easily tell that the lexicographical ordering is what I claim it to be",
      "created_at": "2024-04-18T15:54:25Z",
      "updated_at": "2024-04-18T16:02:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1571014755",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1571014755"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 77,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1571015190",
      "pull_request_review_id": 2009283703,
      "id": 1571015190,
      "node_id": "PRRC_kwDOABII585do8oW",
      "diff_hunk": "@@ -40,6 +43,109 @@ inline CTransactionRef create_placeholder_tx(size_t num_inputs, size_t num_outpu\n     return MakeTransactionRef(mtx);\n }\n \n+// Create a Wtxid from a hex string\n+inline Wtxid WtxidFromString(std::string_view str)\n+{\n+    return Wtxid::FromUint256(uint256S(str.data()));\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(package_hash_tests, TestChain100Setup)\n+{\n+    // Some wtxids, in lexicographical order:\n+    Wtxid wtxid_0{WtxidFromString(\"0x0000000000000000000000000000000000000000000000000000000000000000\")};\n+    Wtxid wtxid_1{WtxidFromString(\"0x0000000000000000000000000000000000000000000000000000000000000001\")};\n+    Wtxid wtxid_2{WtxidFromString(\"0x00000000000000000000000000000000000000000000000000000000ffffffff\")};\n+    Wtxid wtxid_3{WtxidFromString(\"0x1000000000000000000000000000000000000000000000000000000000000000\")};\n+    Wtxid wtxid_4{WtxidFromString(\"0x85cd1a31eb38f74ed5742ec9cb546712ab5aaf747de28a9168b53e846cbda17f\")};\n+    Wtxid wtxid_5{WtxidFromString(\"0xb4749f017444b051c44dfd2720e88f314ff94f3dd6d56d40ef65854fcd7fff6b\")};\n+    Wtxid wtxid_6{WtxidFromString(\"0xe065bac15f62bb4e761d761db928ddee65a47296b2b776785abb912cdec474e3\")};\n+\n+    BOOST_CHECK(wtxid_0.GetHex() < wtxid_1.GetHex());\n+    BOOST_CHECK(wtxid_1.GetHex() < wtxid_2.GetHex());\n+    BOOST_CHECK(wtxid_2.GetHex() < wtxid_3.GetHex());\n+    BOOST_CHECK(wtxid_1.GetHex() < wtxid_3.GetHex());",
      "path": "src/test/txpackage_tests.cpp",
      "position": null,
      "original_position": 37,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "54d0c78d104fb5412a194816590a06cad8cadf80",
      "in_reply_to_id": 1567870936,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "deleted",
      "created_at": "2024-04-18T15:54:41Z",
      "updated_at": "2024-04-18T16:02:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1571015190",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1571015190"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 66,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1571015344",
      "pull_request_review_id": 2009283703,
      "id": 1571015344,
      "node_id": "PRRC_kwDOABII585do8qw",
      "diff_hunk": "@@ -138,4 +162,51 @@ BOOST_AUTO_TEST_CASE(DoS_mapOrphans)\n     BOOST_CHECK(orphanage.CountOrphans() == 0);\n }\n \n+BOOST_AUTO_TEST_CASE(get_children)\n+{\n+    FastRandomContext det_rand{true};\n+    TxOrphanage orphanage;\n+    const NodeId node{0};\n+    std::vector<COutPoint> empty_outpoints;\n+\n+    auto parent1 = MakeTransactionSpending(empty_outpoints, det_rand);\n+    auto parent2 = MakeTransactionSpending(empty_outpoints, det_rand);\n+\n+    // Make sure these parents have different txids otherwise this test won't make sense.\n+    while (parent1->GetHash() == parent2->GetHash()) {\n+        parent2 = MakeTransactionSpending(empty_outpoints, det_rand);\n+    }\n+\n+    // Create children to go into orphanage.\n+    auto child_p1n0 = MakeTransactionSpending({{parent1->GetHash(), 0}}, det_rand);\n+    auto child_p2n1 = MakeTransactionSpending({{parent2->GetHash(), 1}}, det_rand);\n+    // Spends the same tx twice. Should not cause duplicates in GetChildren.\n+    auto child_p1n0_p1n1 = MakeTransactionSpending({{parent1->GetHash(), 0}, {parent1->GetHash(), 1}}, det_rand);\n+    // Spends the same outpoint as previous tx. Should still be returned; don't assume outpoints are unique.\n+    auto child_p1n0_p2n0 = MakeTransactionSpending({{parent1->GetHash(), 0}, {parent2->GetHash(), 0}}, det_rand);\n+\n+    BOOST_CHECK(orphanage.AddTx(child_p1n0, node));\n+    BOOST_CHECK(orphanage.AddTx(child_p2n1, node));\n+    BOOST_CHECK(orphanage.AddTx(child_p1n0_p1n1, node));\n+    BOOST_CHECK(orphanage.AddTx(child_p1n0_p2n0, node));\n+\n+    // Check that GetChildren returns what is expected.\n+    std::set<Wtxid> expected_parent1_children{child_p1n0->GetWitnessHash(), child_p1n0_p2n0->GetWitnessHash(), child_p1n0_p1n1->GetWitnessHash()};\n+    std::set<Wtxid> expected_parent2_children{child_p2n1->GetWitnessHash(), child_p1n0_p2n0->GetWitnessHash()};\n+\n+    auto parent1_children{orphanage.GetChildren(parent1)};\n+    BOOST_CHECK_EQUAL(parent1_children.size(), expected_parent1_children.size());\n+    for (const auto& [child, peer] : parent1_children) {\n+        BOOST_CHECK(expected_parent1_children.contains(child->GetWitnessHash()));\n+    }\n+    auto parent2_children{orphanage.GetChildren(parent2)};\n+    BOOST_CHECK_EQUAL(parent2_children.size(), expected_parent2_children.size());\n+    for (const auto& [child, peer] : parent2_children) {\n+        BOOST_CHECK(expected_parent2_children.count(child->GetWitnessHash()) > 0);",
      "path": "src/test/orphanage_tests.cpp",
      "position": null,
      "original_position": 85,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "91f4efa420958a93f4620379f8830231f276b23b",
      "in_reply_to_id": 1569471367,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "done",
      "created_at": "2024-04-18T15:54:47Z",
      "updated_at": "2024-04-18T16:02:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1571015344",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1571015344"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 205,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1571015434",
      "pull_request_review_id": 2009283703,
      "id": 1571015434,
      "node_id": "PRRC_kwDOABII585do8sK",
      "diff_hunk": "@@ -138,4 +162,51 @@ BOOST_AUTO_TEST_CASE(DoS_mapOrphans)\n     BOOST_CHECK(orphanage.CountOrphans() == 0);\n }\n \n+BOOST_AUTO_TEST_CASE(get_children)\n+{\n+    FastRandomContext det_rand{true};\n+    TxOrphanage orphanage;\n+    const NodeId node{0};\n+    std::vector<COutPoint> empty_outpoints;\n+\n+    auto parent1 = MakeTransactionSpending(empty_outpoints, det_rand);\n+    auto parent2 = MakeTransactionSpending(empty_outpoints, det_rand);\n+\n+    // Make sure these parents have different txids otherwise this test won't make sense.\n+    while (parent1->GetHash() == parent2->GetHash()) {\n+        parent2 = MakeTransactionSpending(empty_outpoints, det_rand);\n+    }\n+\n+    // Create children to go into orphanage.\n+    auto child_p1n0 = MakeTransactionSpending({{parent1->GetHash(), 0}}, det_rand);\n+    auto child_p2n1 = MakeTransactionSpending({{parent2->GetHash(), 1}}, det_rand);\n+    // Spends the same tx twice. Should not cause duplicates in GetChildren.\n+    auto child_p1n0_p1n1 = MakeTransactionSpending({{parent1->GetHash(), 0}, {parent1->GetHash(), 1}}, det_rand);\n+    // Spends the same outpoint as previous tx. Should still be returned; don't assume outpoints are unique.\n+    auto child_p1n0_p2n0 = MakeTransactionSpending({{parent1->GetHash(), 0}, {parent2->GetHash(), 0}}, det_rand);\n+\n+    BOOST_CHECK(orphanage.AddTx(child_p1n0, node));\n+    BOOST_CHECK(orphanage.AddTx(child_p2n1, node));\n+    BOOST_CHECK(orphanage.AddTx(child_p1n0_p1n1, node));\n+    BOOST_CHECK(orphanage.AddTx(child_p1n0_p2n0, node));\n+\n+    // Check that GetChildren returns what is expected.\n+    std::set<Wtxid> expected_parent1_children{child_p1n0->GetWitnessHash(), child_p1n0_p2n0->GetWitnessHash(), child_p1n0_p1n1->GetWitnessHash()};\n+    std::set<Wtxid> expected_parent2_children{child_p2n1->GetWitnessHash(), child_p1n0_p2n0->GetWitnessHash()};",
      "path": "src/test/orphanage_tests.cpp",
      "position": null,
      "original_position": 75,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "91f4efa420958a93f4620379f8830231f276b23b",
      "in_reply_to_id": 1569461340,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "done",
      "created_at": "2024-04-18T15:54:50Z",
      "updated_at": "2024-04-18T16:02:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1571015434",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1571015434"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": 194,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 195,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1571015884",
      "pull_request_review_id": 2009283703,
      "id": 1571015884,
      "node_id": "PRRC_kwDOABII585do8zM",
      "diff_hunk": "@@ -88,4 +88,10 @@ bool IsChildWithParents(const Package& package);\n  * other (the package is a \"tree\").\n  */\n bool IsChildWithParentsTree(const Package& package);\n+\n+/** Get the hash of these wtxids, concatenated in lexicographical order. */\n+uint256 GetCombinedHash(const std::vector<Wtxid>& wtxids);\n+/** Get the hash of these transactions' wtxids, concatenated in lexicographical order. */",
      "path": "src/policy/packages.h",
      "position": null,
      "original_position": 7,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "c502734fa50104c18790ba0a5b63744552113110",
      "in_reply_to_id": 1559188232,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "(deleted `GetCombinedHash`)",
      "created_at": "2024-04-18T15:55:09Z",
      "updated_at": "2024-04-18T16:02:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1571015884",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1571015884"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 94,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1571015988",
      "pull_request_review_id": 2009283703,
      "id": 1571015988,
      "node_id": "PRRC_kwDOABII585do800",
      "diff_hunk": "@@ -147,3 +147,17 @@ bool IsChildWithParentsTree(const Package& package)\n         return true;\n     });\n }\n+\n+uint256 GetCombinedHash(const std::vector<Wtxid>& wtxids)\n+{\n+    std::vector<Wtxid> wtxids_copy(wtxids.cbegin(), wtxids.cend());\n+    std::sort(wtxids_copy.begin(), wtxids_copy.end());\n+    return (HashWriter() << wtxids_copy).GetHash();\n+}",
      "path": "src/policy/packages.cpp",
      "position": null,
      "original_position": 10,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "c502734fa50104c18790ba0a5b63744552113110",
      "in_reply_to_id": 1559187981,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "(deleted `GetCombinedHash`)",
      "created_at": "2024-04-18T15:55:13Z",
      "updated_at": "2024-04-18T16:02:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1571015988",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1571015988"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 156,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1571017712",
      "pull_request_review_id": 2009283703,
      "id": 1571017712,
      "node_id": "PRRC_kwDOABII585do9Pw",
      "diff_hunk": "@@ -3195,6 +3210,115 @@ void PeerManagerImpl::ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, c\n     }\n }\n \n+void PeerManagerImpl::ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, const std::vector<NodeId>& senders)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    if (package_result.m_state.IsInvalid()) {\n+        m_recent_rejects_reconsiderable.insert(GetPackageHash(package));\n+    }\n+    // We currently only expect to process 1-parent-1-child packages. Remove if this changes.\n+    if (!Assume(package.size() == 2)) return;\n+\n+    // Iterate backwards to erase in-package descendants from the orphanage before they become\n+    // relevant in AddChildrenToWorkSet.\n+    auto package_iter = package.rbegin();\n+    auto senders_iter = senders.rbegin();\n+    while (package_iter != package.rend()) {\n+        const auto& tx = *package_iter;\n+        const NodeId nodeid = *senders_iter;\n+        const auto it_result{package_result.m_tx_results.find(tx->GetWitnessHash())};\n+        if (Assume(it_result != package_result.m_tx_results.end())) {\n+            const auto& tx_result = it_result->second;\n+            switch (tx_result.m_result_type) {\n+                case MempoolAcceptResult::ResultType::VALID:\n+                {\n+                    Assume(tx_result.m_replaced_transactions.has_value());\n+                    std::list<CTransactionRef> empty_replacement_list;\n+                    ProcessValidTx(nodeid, tx, tx_result.m_replaced_transactions.value_or(empty_replacement_list));\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::INVALID:\n+                case MempoolAcceptResult::ResultType::DIFFERENT_WITNESS:\n+                {\n+                    // Don't add to vExtraTxnForCompact, as these transactions should have already been\n+                    // added there when added to the orphanage or rejected for TX_RECONSIDERABLE.\n+                    // This should be updated if package submission is ever used for transactions\n+                    // that haven't already been validated before.\n+                    ProcessInvalidTx(nodeid, tx, tx_result.m_state, /*maybe_add_extra_compact_tx=*/false);\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::MEMPOOL_ENTRY:\n+                {\n+                    // AlreadyHaveTx() should be catching transactions that are already in mempool.\n+                    Assume(false);\n+                    break;\n+                }\n+            }\n+        }\n+        package_iter++;\n+        // There should be a sender for each tx, but fall back to the last one otherwise.\n+        if (Assume(senders_iter != senders.rend())) senders_iter++;\n+    }\n+}\n+\n+void PeerManagerImpl::MaybeProcess1P1CPackage(const CTransactionRef& ptx, NodeId nodeid)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    const auto& parent_txid{ptx->GetHash()};\n+    const auto& parent_wtxid{ptx->GetWitnessHash()};\n+\n+    const auto cpfp_candidates{m_orphanage.GetChildren(ptx)};\n+    // Exit early.\n+    if (cpfp_candidates.empty()) {\n+        LogDebug(BCLog::TXPACKAGES, \"didn't evaluate package for %s (wtxid=%s), no corresponding orphan found\\n\",\n+                 parent_txid.ToString(), parent_wtxid.ToString());\n+        return;\n+    }\n+\n+    CTransactionRef tx_orphan{nullptr};\n+    NodeId orphan_sender{-1};\n+    Assume(m_recent_rejects_reconsiderable.contains(parent_wtxid.ToUint256()));\n+\n+    // Create a 1p1c package using the first child that hasn't already been rejected. Sort\n+    // the children in random order to not create a bias that attackers can use to delay\n+    // package acceptance. Create a random permutation of the indices.\n+    std::vector<size_t> tx_indices(cpfp_candidates.size());\n+    std::iota(tx_indices.begin(), tx_indices.end(), 0);\n+    Shuffle(tx_indices.begin(), tx_indices.end(), m_rng);",
      "path": "src/net_processing.cpp",
      "position": 257,
      "original_position": 106,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "25c712711d6b1074b40c440676e3b1c4e12e59af",
      "in_reply_to_id": 1568834899,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Did this now. We first gather all children by the same peer and try by recency order. If we cannot find one that matches, we look for children not by this peer, and try in random order.",
      "created_at": "2024-04-18T15:56:24Z",
      "updated_at": "2024-04-18T16:02:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1571017712",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1571017712"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 3337,
      "original_line": 3337,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1571063644",
      "pull_request_review_id": 2009379866,
      "id": 1571063644,
      "node_id": "PRRC_kwDOABII585dpIdc",
      "diff_hunk": "@@ -3195,6 +3210,115 @@ void PeerManagerImpl::ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, c\n     }\n }\n \n+void PeerManagerImpl::ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, const std::vector<NodeId>& senders)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    if (package_result.m_state.IsInvalid()) {\n+        m_recent_rejects_reconsiderable.insert(GetPackageHash(package));\n+    }\n+    // We currently only expect to process 1-parent-1-child packages. Remove if this changes.\n+    if (!Assume(package.size() == 2)) return;\n+\n+    // Iterate backwards to erase in-package descendants from the orphanage before they become\n+    // relevant in AddChildrenToWorkSet.\n+    auto package_iter = package.rbegin();\n+    auto senders_iter = senders.rbegin();\n+    while (package_iter != package.rend()) {\n+        const auto& tx = *package_iter;\n+        const NodeId nodeid = *senders_iter;\n+        const auto it_result{package_result.m_tx_results.find(tx->GetWitnessHash())};\n+        if (Assume(it_result != package_result.m_tx_results.end())) {\n+            const auto& tx_result = it_result->second;\n+            switch (tx_result.m_result_type) {\n+                case MempoolAcceptResult::ResultType::VALID:\n+                {\n+                    Assume(tx_result.m_replaced_transactions.has_value());\n+                    std::list<CTransactionRef> empty_replacement_list;\n+                    ProcessValidTx(nodeid, tx, tx_result.m_replaced_transactions.value_or(empty_replacement_list));\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::INVALID:\n+                case MempoolAcceptResult::ResultType::DIFFERENT_WITNESS:\n+                {\n+                    // Don't add to vExtraTxnForCompact, as these transactions should have already been\n+                    // added there when added to the orphanage or rejected for TX_RECONSIDERABLE.\n+                    // This should be updated if package submission is ever used for transactions\n+                    // that haven't already been validated before.\n+                    ProcessInvalidTx(nodeid, tx, tx_result.m_state, /*maybe_add_extra_compact_tx=*/false);\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::MEMPOOL_ENTRY:\n+                {\n+                    // AlreadyHaveTx() should be catching transactions that are already in mempool.\n+                    Assume(false);\n+                    break;\n+                }\n+            }\n+        }\n+        package_iter++;\n+        // There should be a sender for each tx, but fall back to the last one otherwise.\n+        if (Assume(senders_iter != senders.rend())) senders_iter++;\n+    }\n+}\n+\n+void PeerManagerImpl::MaybeProcess1P1CPackage(const CTransactionRef& ptx, NodeId nodeid)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    const auto& parent_txid{ptx->GetHash()};\n+    const auto& parent_wtxid{ptx->GetWitnessHash()};\n+\n+    const auto cpfp_candidates{m_orphanage.GetChildren(ptx)};\n+    // Exit early.\n+    if (cpfp_candidates.empty()) {\n+        LogDebug(BCLog::TXPACKAGES, \"didn't evaluate package for %s (wtxid=%s), no corresponding orphan found\\n\",\n+                 parent_txid.ToString(), parent_wtxid.ToString());\n+        return;\n+    }\n+\n+    CTransactionRef tx_orphan{nullptr};\n+    NodeId orphan_sender{-1};\n+    Assume(m_recent_rejects_reconsiderable.contains(parent_wtxid.ToUint256()));\n+\n+    // Create a 1p1c package using the first child that hasn't already been rejected. Sort\n+    // the children in random order to not create a bias that attackers can use to delay\n+    // package acceptance. Create a random permutation of the indices.\n+    std::vector<size_t> tx_indices(cpfp_candidates.size());\n+    std::iota(tx_indices.begin(), tx_indices.end(), 0);\n+    Shuffle(tx_indices.begin(), tx_indices.end(), m_rng);",
      "path": "src/net_processing.cpp",
      "position": 257,
      "original_position": 106,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "25c712711d6b1074b40c440676e3b1c4e12e59af",
      "in_reply_to_id": 1568834899,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "For some code deduplication you could just have `GetChildrenFromPeer` which takes `std::optional<NodeId>`, returning full `std::vector<std::pair<CTransactionRef, NodeId>>` list if `std::nullopt` or filtered to the specific nodeid otherwise. You can call it filtered once, then if a suitable orphan isn't found, call it again unfiltered. ",
      "created_at": "2024-04-18T16:32:56Z",
      "updated_at": "2024-04-18T16:32:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1571063644",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1571063644"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 3337,
      "original_line": 3337,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1572288041",
      "pull_request_review_id": 2011282364,
      "id": 1572288041,
      "node_id": "PRRC_kwDOABII585dtzYp",
      "diff_hunk": "@@ -0,0 +1,241 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test opportunistic 1p1c package submission logic.\n+\"\"\"\n+\n+from decimal import Decimal\n+from test_framework.messages import (\n+    CInv,\n+    CTxInWitness,\n+    MSG_WTX,\n+    msg_inv,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    fill_mempool,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+        ]]\n+        self.supports_cli = False\n+\n+    def test_basic_child_then_parent(self):\n+        node = self.nodes[0]\n+        self.log.info(\"Check that opportunistic 1p1c logic works when child is received before parent\")\n+\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first (perhaps the low feerate parent didn't meet feefilter or the requests were sent to different nodes). It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. Sender relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 4. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+        node.disconnect_p2ps()\n+\n+    def test_basic_parent_then_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=1, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=2, connection_type=\"outbound-full-relay\")\n+\n+        # 1. Parent is relayed first. It is too low feerate.\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer_sender.wait_for_getdata([parent_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer_ignored, check that it is ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+\n+        # 2. Child is relayed next. It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 3. Node requests the missing parent by txid.\n+        # It should do so even if it has previously rejected that parent for being too low feerate.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 4. Sender re-relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 5. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+        node.disconnect_p2ps()\n+\n+    def test_low_and_high_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        low_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=2*FEERATE_1SAT_VB)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=3, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=4, connection_type=\"outbound-full-relay\")\n+\n+        self.log.info(\"Check that tx caches low fee parent + low fee child package rejections\")\n+\n+        # 1. Send parent, rejected for being low feerate.\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer_sender.wait_for_getdata([parent_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer_ignored, check that it is ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+\n+        # 2. Send an (orphan) child that has a higher feerate, but not enough to bump the parent.\n+        low_child_wtxid_int = int(low_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([low_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_child[\"tx\"]))\n+\n+        # 3. Node requests the orphan's missing parent.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 4. The low parent + low child are submitted as a package. They are not accepted due to low package feerate.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+        assert low_fee_child[\"txid\"] not in node.getrawmempool()\n+\n+        # If peer_ignored announces the low feerate child, it should be ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+        # If either peer sends the parent again, package evaluation should not be attempted\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        peer_ignored.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 5. Send the high feerate (orphan) child\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 6. Node requests the orphan's parent, even though it has already been rejected, both by\n+        # itself and with a child. This is necessary, otherwise high_fee_child can be censored.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 7. The low feerate parent + high feerate child are submitted as a package.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 8. Both transactions should now be in mempool\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+        node.disconnect_p2ps()\n+\n+    def test_orphan_consensus_failure(self):\n+        node = self.nodes[0]\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        coin = low_fee_parent[\"new_utxo\"]\n+        address = node.get_deterministic_priv_key().address\n+        # Create raw transaction spending the parent, but with no signature (a consensus error).\n+        hex_orphan_no_sig = node.createrawtransaction([{\"txid\": coin[\"txid\"], \"vout\": coin[\"vout\"]}], {address : coin[\"value\"] - Decimal(\"0.0001\")})\n+        tx_orphan_bad_wit = tx_from_hex(hex_orphan_no_sig)\n+        tx_orphan_bad_wit.wit.vtxinwit.append(CTxInWitness())\n+        tx_orphan_bad_wit.wit.vtxinwit[0].scriptWitness.stack = [b'garbage']\n+\n+        peer_sender = node.add_p2p_connection(P2PInterface())",
      "path": "test/functional/p2p_opportunistic_1p1c.py",
      "position": null,
      "original_position": 189,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "142d584dab3725081344520bec0a092d6b58d996",
      "in_reply_to_id": 1567724841,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Added this test and tweaked a bit to check that orphan stays + can still be resolved.",
      "created_at": "2024-04-19T12:24:02Z",
      "updated_at": "2024-04-19T12:24:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1572288041",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1572288041"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 189,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1572288118",
      "pull_request_review_id": 2011282515,
      "id": 1572288118,
      "node_id": "PRRC_kwDOABII585dtzZ2",
      "diff_hunk": "@@ -0,0 +1,241 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test opportunistic 1p1c package submission logic.\n+\"\"\"\n+\n+from decimal import Decimal\n+from test_framework.messages import (\n+    CInv,\n+    CTxInWitness,\n+    MSG_WTX,\n+    msg_inv,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    fill_mempool,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+        ]]\n+        self.supports_cli = False\n+\n+    def test_basic_child_then_parent(self):\n+        node = self.nodes[0]\n+        self.log.info(\"Check that opportunistic 1p1c logic works when child is received before parent\")\n+\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first (perhaps the low feerate parent didn't meet feefilter or the requests were sent to different nodes). It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. Sender relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 4. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+        node.disconnect_p2ps()\n+\n+    def test_basic_parent_then_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=1, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=2, connection_type=\"outbound-full-relay\")\n+\n+        # 1. Parent is relayed first. It is too low feerate.\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer_sender.wait_for_getdata([parent_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer_ignored, check that it is ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+\n+        # 2. Child is relayed next. It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 3. Node requests the missing parent by txid.\n+        # It should do so even if it has previously rejected that parent for being too low feerate.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 4. Sender re-relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 5. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+        node.disconnect_p2ps()\n+\n+    def test_low_and_high_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        low_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=2*FEERATE_1SAT_VB)",
      "path": "test/functional/p2p_opportunistic_1p1c.py",
      "position": null,
      "original_position": 115,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "142d584dab3725081344520bec0a092d6b58d996",
      "in_reply_to_id": 1567763258,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "done",
      "created_at": "2024-04-19T12:24:07Z",
      "updated_at": "2024-04-19T12:24:08Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1572288118",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1572288118"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 115,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1572436712",
      "pull_request_review_id": 2011541463,
      "id": 1572436712,
      "node_id": "PRRC_kwDOABII585duXro",
      "diff_hunk": "@@ -0,0 +1,319 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test opportunistic 1p1c package submission logic.\n+\"\"\"\n+\n+from decimal import Decimal\n+from test_framework.messages import (\n+    CInv,\n+    CTxInWitness,\n+    MSG_WTX,\n+    msg_inv,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    fill_mempool,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+\n+def cleanup(func):\n+    def wrapper(self, *args, **kwargs):\n+        try:\n+            func(self, *args, **kwargs)\n+        finally:\n+            self.nodes[0].disconnect_p2ps()\n+            # Do not clear the node's mempool, as each test requires mempool min feerate > min\n+            # relay feerate. However, do check that this is the case.\n+            assert self.nodes[0].getmempoolinfo()[\"mempoolminfee\"] > self.nodes[0].getnetworkinfo()[\"relayfee\"]\n+            # Ensure we do not try to spend the same UTXOs in subsequent tests, as they will look like RBF attempts.\n+            self.wallet.rescan_utxos(include_mempool=True)\n+    return wrapper\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+        ]]\n+        self.supports_cli = False\n+\n+    def subest_check(self):",
      "path": "test/functional/p2p_opportunistic_1p1c.py",
      "position": null,
      "original_position": 56,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "a053911cb9957797faff7f68dbd6deb6b6080578",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "duplicated `cleanup`, or something?",
      "created_at": "2024-04-19T14:08:55Z",
      "updated_at": "2024-04-19T14:08:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1572436712",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1572436712"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 56,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1572451256",
      "pull_request_review_id": 2011565637,
      "id": 1572451256,
      "node_id": "PRRC_kwDOABII585dubO4",
      "diff_hunk": "@@ -0,0 +1,319 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test opportunistic 1p1c package submission logic.\n+\"\"\"\n+\n+from decimal import Decimal\n+from test_framework.messages import (\n+    CInv,\n+    CTxInWitness,\n+    MSG_WTX,\n+    msg_inv,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    fill_mempool,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+\n+def cleanup(func):\n+    def wrapper(self, *args, **kwargs):\n+        try:\n+            func(self, *args, **kwargs)\n+        finally:\n+            self.nodes[0].disconnect_p2ps()\n+            # Do not clear the node's mempool, as each test requires mempool min feerate > min\n+            # relay feerate. However, do check that this is the case.\n+            assert self.nodes[0].getmempoolinfo()[\"mempoolminfee\"] > self.nodes[0].getnetworkinfo()[\"relayfee\"]\n+            # Ensure we do not try to spend the same UTXOs in subsequent tests, as they will look like RBF attempts.\n+            self.wallet.rescan_utxos(include_mempool=True)\n+    return wrapper\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+        ]]\n+        self.supports_cli = False\n+\n+    def subest_check(self):",
      "path": "test/functional/p2p_opportunistic_1p1c.py",
      "position": null,
      "original_position": 56,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "a053911cb9957797faff7f68dbd6deb6b6080578",
      "in_reply_to_id": 1572436712,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Ah forgot to delete, yes",
      "created_at": "2024-04-19T14:18:53Z",
      "updated_at": "2024-04-19T14:18:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1572451256",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1572451256"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 56,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1572504707",
      "pull_request_review_id": 2011658807,
      "id": 1572504707,
      "node_id": "PRRC_kwDOABII585duoSD",
      "diff_hunk": "@@ -0,0 +1,319 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test opportunistic 1p1c package submission logic.\n+\"\"\"\n+\n+from decimal import Decimal\n+from test_framework.messages import (\n+    CInv,\n+    CTxInWitness,\n+    MSG_WTX,\n+    msg_inv,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    fill_mempool,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+\n+def cleanup(func):\n+    def wrapper(self, *args, **kwargs):\n+        try:\n+            func(self, *args, **kwargs)\n+        finally:\n+            self.nodes[0].disconnect_p2ps()\n+            # Do not clear the node's mempool, as each test requires mempool min feerate > min\n+            # relay feerate. However, do check that this is the case.\n+            assert self.nodes[0].getmempoolinfo()[\"mempoolminfee\"] > self.nodes[0].getnetworkinfo()[\"relayfee\"]\n+            # Ensure we do not try to spend the same UTXOs in subsequent tests, as they will look like RBF attempts.\n+            self.wallet.rescan_utxos(include_mempool=True)\n+    return wrapper\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+        ]]\n+        self.supports_cli = False\n+\n+    def subest_check(self):\n+        self.nodes[0].disconnect_p2ps()\n+        # Do not clear the node's mempool, as each test requires mempool min feerate > min\n+        # relay feerate. However, do check that this is the case.\n+        assert self.nodes[0].getmempoolinfo()[\"mempoolminfee\"] > self.nodes[0].getnetworkinfo()[\"relayfee\"]\n+        # Ensure we do not try to spend the same UTXOs in subsequent tests, as they will look like RBF attempts.\n+        self.wallet.rescan_utxos(include_mempool=True)\n+\n+    @cleanup\n+    def test_basic_child_then_parent(self):\n+        node = self.nodes[0]\n+        self.log.info(\"Check that opportunistic 1p1c logic works when child is received before parent\")\n+\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first (perhaps the low feerate parent didn't meet feefilter or the requests were sent to different nodes). It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. Sender relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 4. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+        node.disconnect_p2ps()\n+\n+    @cleanup\n+    def test_basic_parent_then_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=1, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=2, connection_type=\"outbound-full-relay\")\n+\n+        # 1. Parent is relayed first. It is too low feerate.\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer_sender.wait_for_getdata([parent_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer_ignored, check that it is ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+\n+        # 2. Child is relayed next. It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 3. Node requests the missing parent by txid.\n+        # It should do so even if it has previously rejected that parent for being too low feerate.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 4. Sender re-relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 5. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+    @cleanup\n+    def test_low_and_high_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        # This feerate is above mempoolminfee, but not enough to also bump the low feerate parent.\n+        feerate_just_above = node.getmempoolinfo()[\"mempoolminfee\"]\n+        med_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=feerate_just_above)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=3, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=4, connection_type=\"outbound-full-relay\")\n+\n+        self.log.info(\"Check that tx caches low fee parent + low fee child package rejections\")\n+\n+        # 1. Send parent, rejected for being low feerate.\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer_sender.wait_for_getdata([parent_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer_ignored, check that it is ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+\n+        # 2. Send an (orphan) child that has a higher feerate, but not enough to bump the parent.\n+        low_child_wtxid_int = int(med_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([low_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(med_fee_child[\"tx\"]))\n+\n+        # 3. Node requests the orphan's missing parent.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 4. The low parent + low child are submitted as a package. They are not accepted due to low package feerate.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+        assert med_fee_child[\"txid\"] not in node.getrawmempool()\n+\n+        # If peer_ignored announces the low feerate child, it should be ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+        # If either peer sends the parent again, package evaluation should not be attempted\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        peer_ignored.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 5. Send the high feerate (orphan) child\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 6. Node requests the orphan's parent, even though it has already been rejected, both by\n+        # itself and with a child. This is necessary, otherwise high_fee_child can be censored.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 7. The low feerate parent + high feerate child are submitted as a package.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 8. Both transactions should now be in mempool\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+    @cleanup\n+    def test_orphan_consensus_failure(self):\n+        self.log.info(\"Check opportunistic 1p1c logic with consensus-invalid orphan causes disconnect of the correct peer\")\n+        node = self.nodes[0]\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        coin = low_fee_parent[\"new_utxo\"]\n+        address = node.get_deterministic_priv_key().address\n+        # Create raw transaction spending the parent, but with no signature (a consensus error).\n+        hex_orphan_no_sig = node.createrawtransaction([{\"txid\": coin[\"txid\"], \"vout\": coin[\"vout\"]}], {address : coin[\"value\"] - Decimal(\"0.0001\")})\n+        tx_orphan_bad_wit = tx_from_hex(hex_orphan_no_sig)\n+        tx_orphan_bad_wit.wit.vtxinwit.append(CTxInWitness())\n+        tx_orphan_bad_wit.wit.vtxinwit[0].scriptWitness.stack = [b'garbage']\n+\n+        bad_orphan_sender = node.add_p2p_connection(P2PInterface())\n+        parent_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first. It is missing an input.\n+        child_wtxid_int = int(tx_orphan_bad_wit.getwtxid(), 16)\n+        bad_orphan_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=child_wtxid_int)]))\n+        bad_orphan_sender.wait_for_getdata([child_wtxid_int])\n+        bad_orphan_sender.send_and_ping(msg_tx(tx_orphan_bad_wit))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        bad_orphan_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. A different peer relays the parent. Parent+Child are evaluated as a package and rejected.\n+        parent_sender.send_message(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 4. Transactions should not be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] not in node_mempool\n+        assert tx_orphan_bad_wit.rehash() not in node_mempool\n+\n+        # 5. Peer that sent a consensus-invalid transaction should be disconnected.\n+        bad_orphan_sender.wait_for_disconnect()\n+\n+        # The peer that didn't provide the orphan should not be disconnected.\n+        parent_sender.sync_with_ping()\n+\n+    @cleanup\n+    def test_parent_consensus_failure(self):\n+        self.log.info(\"Check opportunistic 1p1c logic with consensus-invalid parent causes disconnect of the correct peer\")\n+        node = self.nodes[0]\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+\n+        # Create invalid version of parent with a bad signature.\n+        tx_parent_bad_wit = tx_from_hex(low_fee_parent[\"hex\"])\n+        tx_parent_bad_wit.wit.vtxinwit.append(CTxInWitness())\n+        tx_parent_bad_wit.wit.vtxinwit[0].scriptWitness.stack = [b'garbage']\n+\n+        package_sender = node.add_p2p_connection(P2PInterface())\n+        fake_parent_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first. It is missing an input.\n+        child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        package_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=child_wtxid_int)]))\n+        package_sender.wait_for_getdata([child_wtxid_int])\n+        package_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(tx_parent_bad_wit.rehash(), 16)\n+        package_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. A different node relays the parent. The parent is first evaluated by itself and\n+        # rejected for being too low feerate. Then it is evaluated as a package and, after passing\n+        # feerate checks, rejected for having a bad signature (consensus error).\n+        fake_parent_sender.send_message(msg_tx(tx_parent_bad_wit))\n+\n+        # 4. Transactions should not be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert tx_parent_bad_wit.rehash() not in node_mempool\n+        assert high_fee_child[\"txid\"] not in node_mempool\n+\n+        # 5. Peer sent a consensus-invalid transaction.\n+        fake_parent_sender.wait_for_disconnect()\n+\n+        self.log.info(\"Check opportunistic 1p1c logic with consensus-invalid parent causes disconnect of the correct peer\")",
      "path": "test/functional/p2p_opportunistic_1p1c.py",
      "position": null,
      "original_position": 278,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "a053911cb9957797faff7f68dbd6deb6b6080578",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "duplicate log?",
      "created_at": "2024-04-19T14:56:20Z",
      "updated_at": "2024-04-19T14:56:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1572504707",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1572504707"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 278,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1573331603",
      "pull_request_review_id": 2013113076,
      "id": 1573331603,
      "node_id": "PRRC_kwDOABII585dxyKT",
      "diff_hunk": "@@ -40,6 +43,93 @@ inline CTransactionRef create_placeholder_tx(size_t num_inputs, size_t num_outpu\n     return MakeTransactionRef(mtx);\n }\n \n+// Create a Wtxid from a hex string\n+inline Wtxid WtxidFromString(std::string_view str)\n+{\n+    return Wtxid::FromUint256(uint256S(str.data()));\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(package_hash_tests, TestChain100Setup)\n+{\n+    // Random real segwit transaction\n+    DataStream stream_1{\n+        ParseHex(\"02000000000101964b8aa63509579ca6086e6012eeaa4c2f4dd1e283da29b67c8eea38b3c6fd220000000000fdffffff0294c618000000000017a9145afbbb42f4e83312666d0697f9e66259912ecde38768fa2c0000000000160014897388a0889390fd0e153a22bb2cf9d8f019faf50247304402200547406380719f84d68cf4e96cc3e4a1688309ef475b150be2b471c70ea562aa02206d255f5acc40fd95981874d77201d2eb07883657ce1c796513f32b6079545cdf0121023ae77335cefcb5ab4c1dc1fb0d2acfece184e593727d7d5906c78e564c7c11d125cf0c00\"),\n+    };\n+    CTransaction tx_1(deserialize, TX_WITH_WITNESS, stream_1);\n+    CTransactionRef ptx_1{MakeTransactionRef(tx_1)};\n+\n+    // Random real nonsegwit transaction\n+    DataStream stream_2{\n+        ParseHex(\"01000000010b26e9b7735eb6aabdf358bab62f9816a21ba9ebdb719d5299e88607d722c190000000008b4830450220070aca44506c5cef3a16ed519d7c3c39f8aab192c4e1c90d065f37b8a4af6141022100a8e160b856c2d43d27d8fba71e5aef6405b8643ac4cb7cb3c462aced7f14711a0141046d11fee51b0e60666d5049a9101a72741df480b96ee26488a4d3466b95c9a40ac5eeef87e10a5cd336c19a84565f80fa6c547957b7700ff4dfbdefe76036c339ffffffff021bff3d11000000001976a91404943fdd508053c75000106d3bc6e2754dbcff1988ac2f15de00000000001976a914a266436d2965547608b9e15d9032a7b9d64fa43188ac00000000\"),\n+    };\n+    CTransaction tx_2(deserialize, TX_WITH_WITNESS, stream_2);\n+    CTransactionRef ptx_2{MakeTransactionRef(tx_2)};\n+\n+    // Random real segwit transaction\n+    DataStream stream_3{\n+        ParseHex(\"0200000000010177862801f77c2c068a70372b4c435ef8dd621291c36a64eb4dd491f02218f5324600000000fdffffff014a0100000000000022512035ea312034cfac01e956a269f3bf147f569c2fbb00180677421262da042290d803402be713325ff285e66b0380f53f2fae0d0fb4e16f378a440fed51ce835061437566729d4883bc917632f3cff474d6384bc8b989961a1d730d4a87ed38ad28bd337b20f1d658c6c138b1c312e072b4446f50f01ae0da03a42e6274f8788aae53416a7fac0063036f7264010118746578742f706c61696e3b636861727365743d7574662d3800357b2270223a226272632d3230222c226f70223a226d696e74222c227469636b223a224342414c222c22616d74223a2236393639227d6821c1f1d658c6c138b1c312e072b4446f50f01ae0da03a42e6274f8788aae53416a7f00000000\"),\n+    };\n+    CTransaction tx_3(deserialize, TX_WITH_WITNESS, stream_3);\n+    CTransactionRef ptx_3{MakeTransactionRef(tx_3)};\n+\n+    // It's easy to see that wtxids are sorted in lexicographical order:\n+    Wtxid wtxid_1{WtxidFromString(\"0x85cd1a31eb38f74ed5742ec9cb546712ab5aaf747de28a9168b53e846cbda17f\")};\n+    Wtxid wtxid_2{WtxidFromString(\"0xb4749f017444b051c44dfd2720e88f314ff94f3dd6d56d40ef65854fcd7fff6b\")};\n+    Wtxid wtxid_3{WtxidFromString(\"0xe065bac15f62bb4e761d761db928ddee65a47296b2b776785abb912cdec474e3\")};\n+    BOOST_CHECK_EQUAL(tx_1.GetWitnessHash(), wtxid_1);\n+    BOOST_CHECK_EQUAL(tx_2.GetWitnessHash(), wtxid_2);\n+    BOOST_CHECK_EQUAL(tx_3.GetWitnessHash(), wtxid_3);\n+\n+    BOOST_CHECK(wtxid_1.GetHex() < wtxid_2.GetHex());\n+    BOOST_CHECK(wtxid_2.GetHex() < wtxid_3.GetHex());\n+    BOOST_CHECK(wtxid_1.GetHex() < wtxid_3.GetHex());",
      "path": "src/test/txpackage_tests.cpp",
      "position": null,
      "original_position": 56,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "5c8aa657642ef24e711a73c28278644f14117d73",
      "in_reply_to_id": null,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In 5c8aa657642ef24e711a73c28278644f14117d73\r\n\r\nThis last check is still redundant",
      "created_at": "2024-04-20T16:18:20Z",
      "updated_at": "2024-04-20T18:01:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1573331603",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1573331603"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 85,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1573341141",
      "pull_request_review_id": 2013113076,
      "id": 1573341141,
      "node_id": "PRRC_kwDOABII585dx0fV",
      "diff_hunk": "@@ -241,3 +241,71 @@ void TxOrphanage::EraseForBlock(const CBlock& block)\n         LogPrint(BCLog::TXPACKAGES, \"Erased %d orphan tx included or conflicted by block\\n\", nErased);\n     }\n }\n+\n+std::vector<CTransactionRef> TxOrphanage::GetChildrenFromSamePeer(const CTransactionRef& parent, NodeId nodeid) const\n+{\n+    LOCK(m_mutex);\n+\n+    // First construct a vector of iterators to ensure we do not return duplicates of the same tx\n+    // and so we can sort by nTimeExpire.\n+    std::vector<OrphanMap::iterator> unique_iters;\n+\n+    // For each output, get all entries spending this prevout, filtering for ones from the specified peer.\n+    for (unsigned int i = 0; i < parent->vout.size(); i++) {\n+        const auto it_by_prev = m_outpoint_to_orphan_it.find(COutPoint(parent->GetHash(), i));\n+        if (it_by_prev != m_outpoint_to_orphan_it.end()) {\n+            for (const auto& elem : it_by_prev->second) {\n+                if (elem->second.fromPeer == nodeid) {\n+                    unique_iters.emplace_back(elem);\n+                }\n+            }\n+        }\n+    }\n+\n+    // Sort so that more recent orphans (which expire later) come first.\n+    std::sort(unique_iters.begin(), unique_iters.end(), [](const auto& lhs, const auto& rhs) {\n+        return lhs->second.nTimeExpire > rhs->second.nTimeExpire;\n+    });\n+    // Erase duplicates\n+    unique_iters.erase(std::unique(unique_iters.begin(), unique_iters.end()), unique_iters.end());\n+\n+    // Convert to a vector of CTransactionRef\n+    std::vector<CTransactionRef> children_found;\n+    children_found.reserve(unique_iters.size());\n+    for (const auto child_iter : unique_iters) {\n+        children_found.emplace_back(child_iter->second.tx);\n+    }\n+    return children_found;\n+}\n+\n+std::vector<std::pair<CTransactionRef, NodeId>> TxOrphanage::GetChildrenFromDifferentPeer(const CTransactionRef& parent, NodeId nodeid) const\n+{\n+    LOCK(m_mutex);\n+\n+    // First construct vector of iterators to ensure we do not return duplicates of the same tx.\n+    std::vector<OrphanMap::iterator> unique_iters;",
      "path": "src/txorphanage.cpp",
      "position": null,
      "original_position": 46,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "ca9f03f2207854c849a14d7af2fcd91a5f675e14",
      "in_reply_to_id": null,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In ca9f03f2207854c849a14d7af2fcd91a5f675e14\r\n\r\nWouldn't it be easier (and simpler) to use a set here instead of a vector (as used to be the case in 9dc967195c4965973be0174ae6041be70a886c7a). It makes sense to use a `vec` in `GetChildrenFromSamePeer` given you are sorting based on a custom order, but here a set should be equivalent and involve less boilerplate (?)",
      "created_at": "2024-04-20T16:56:31Z",
      "updated_at": "2024-04-20T22:24:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1573341141",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1573341141"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 286,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1573344593",
      "pull_request_review_id": 2013113076,
      "id": 1573344593,
      "node_id": "PRRC_kwDOABII585dx1VR",
      "diff_hunk": "@@ -241,3 +241,71 @@ void TxOrphanage::EraseForBlock(const CBlock& block)\n         LogPrint(BCLog::TXPACKAGES, \"Erased %d orphan tx included or conflicted by block\\n\", nErased);\n     }\n }\n+\n+std::vector<CTransactionRef> TxOrphanage::GetChildrenFromSamePeer(const CTransactionRef& parent, NodeId nodeid) const\n+{\n+    LOCK(m_mutex);\n+\n+    // First construct a vector of iterators to ensure we do not return duplicates of the same tx\n+    // and so we can sort by nTimeExpire.\n+    std::vector<OrphanMap::iterator> unique_iters;",
      "path": "src/txorphanage.cpp",
      "position": null,
      "original_position": 11,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "ca9f03f2207854c849a14d7af2fcd91a5f675e14",
      "in_reply_to_id": null,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In ca9f03f2207854c849a14d7af2fcd91a5f675e14\r\n\r\nI think this is misleading (both the variable name and the comment).\r\n\r\nThe reason a vector is chosen is so you can sort based on `nTimeExpire`. Removing the duplicates comes later (for most of the function, the iters may not be unique).\r\n\r\nFor the sake of future readers it may be worth changing it",
      "created_at": "2024-04-20T17:10:51Z",
      "updated_at": "2024-04-20T18:01:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1573344593",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1573344593"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": 249,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 251,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1573353122",
      "pull_request_review_id": 2013113076,
      "id": 1573353122,
      "node_id": "PRRC_kwDOABII585dx3ai",
      "diff_hunk": "@@ -138,4 +162,154 @@ BOOST_AUTO_TEST_CASE(DoS_mapOrphans)\n     BOOST_CHECK(orphanage.CountOrphans() == 0);\n }\n \n+BOOST_AUTO_TEST_CASE(get_children)\n+{\n+    FastRandomContext det_rand{true};\n+    std::vector<COutPoint> empty_outpoints;\n+\n+    auto parent1 = MakeTransactionSpending(empty_outpoints, det_rand);\n+    auto parent2 = MakeTransactionSpending(empty_outpoints, det_rand);\n+\n+    // Make sure these parents have different txids otherwise this test won't make sense.\n+    while (parent1->GetHash() == parent2->GetHash()) {\n+        parent2 = MakeTransactionSpending(empty_outpoints, det_rand);\n+    }\n+\n+    // Create children to go into orphanage.\n+    auto child_p1n0 = MakeTransactionSpending({{parent1->GetHash(), 0}}, det_rand);\n+    auto child_p2n1 = MakeTransactionSpending({{parent2->GetHash(), 1}}, det_rand);\n+    // Spends the same tx twice. Should not cause duplicates.\n+    auto child_p1n0_p1n1 = MakeTransactionSpending({{parent1->GetHash(), 0}, {parent1->GetHash(), 1}}, det_rand);\n+    // Spends the same outpoint as previous tx. Should still be returned; don't assume outpoints are unique.\n+    auto child_p1n0_p2n0 = MakeTransactionSpending({{parent1->GetHash(), 0}, {parent2->GetHash(), 0}}, det_rand);\n+\n+    const NodeId node1{1};\n+    const NodeId node2{2};\n+\n+    // All orphans provided by node1\n+    {\n+        TxOrphanage orphanage;\n+        BOOST_CHECK(orphanage.AddTx(child_p1n0, node1));\n+        BOOST_CHECK(orphanage.AddTx(child_p2n1, node1));\n+        BOOST_CHECK(orphanage.AddTx(child_p1n0_p1n1, node1));\n+        BOOST_CHECK(orphanage.AddTx(child_p1n0_p2n0, node1));\n+\n+        std::set<CTransactionRef> expected_parent1_children{child_p1n0, child_p1n0_p2n0, child_p1n0_p1n1};\n+        std::set<CTransactionRef> expected_parent2_children{child_p2n1, child_p1n0_p2n0};\n+\n+        // Check contents and ensure transactions are returned in order of recency.",
      "path": "src/test/orphanage_tests.cpp",
      "position": null,
      "original_position": 80,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "42859548ab5aebf40da6089b85065f7c204b992a",
      "in_reply_to_id": null,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In 42859548ab5aebf40da6089b85065f7c204b992a\r\n\r\nI don't think the order of recency is being tested",
      "created_at": "2024-04-20T17:43:40Z",
      "updated_at": "2024-04-20T18:01:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1573353122",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1573353122"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 200,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1573354857",
      "pull_request_review_id": 2013113076,
      "id": 1573354857,
      "node_id": "PRRC_kwDOABII585dx31p",
      "diff_hunk": "@@ -138,4 +162,154 @@ BOOST_AUTO_TEST_CASE(DoS_mapOrphans)\n     BOOST_CHECK(orphanage.CountOrphans() == 0);\n }\n \n+BOOST_AUTO_TEST_CASE(get_children)\n+{\n+    FastRandomContext det_rand{true};\n+    std::vector<COutPoint> empty_outpoints;\n+\n+    auto parent1 = MakeTransactionSpending(empty_outpoints, det_rand);\n+    auto parent2 = MakeTransactionSpending(empty_outpoints, det_rand);\n+\n+    // Make sure these parents have different txids otherwise this test won't make sense.\n+    while (parent1->GetHash() == parent2->GetHash()) {\n+        parent2 = MakeTransactionSpending(empty_outpoints, det_rand);\n+    }\n+\n+    // Create children to go into orphanage.\n+    auto child_p1n0 = MakeTransactionSpending({{parent1->GetHash(), 0}}, det_rand);\n+    auto child_p2n1 = MakeTransactionSpending({{parent2->GetHash(), 1}}, det_rand);\n+    // Spends the same tx twice. Should not cause duplicates.\n+    auto child_p1n0_p1n1 = MakeTransactionSpending({{parent1->GetHash(), 0}, {parent1->GetHash(), 1}}, det_rand);\n+    // Spends the same outpoint as previous tx. Should still be returned; don't assume outpoints are unique.\n+    auto child_p1n0_p2n0 = MakeTransactionSpending({{parent1->GetHash(), 0}, {parent2->GetHash(), 0}}, det_rand);\n+\n+    const NodeId node1{1};\n+    const NodeId node2{2};\n+\n+    // All orphans provided by node1\n+    {\n+        TxOrphanage orphanage;\n+        BOOST_CHECK(orphanage.AddTx(child_p1n0, node1));\n+        BOOST_CHECK(orphanage.AddTx(child_p2n1, node1));\n+        BOOST_CHECK(orphanage.AddTx(child_p1n0_p1n1, node1));\n+        BOOST_CHECK(orphanage.AddTx(child_p1n0_p2n0, node1));\n+\n+        std::set<CTransactionRef> expected_parent1_children{child_p1n0, child_p1n0_p2n0, child_p1n0_p1n1};\n+        std::set<CTransactionRef> expected_parent2_children{child_p2n1, child_p1n0_p2n0};\n+\n+        // Check contents and ensure transactions are returned in order of recency.\n+        const auto parent1_children_from_sender{orphanage.GetChildrenFromSamePeer(parent1, node1)};\n+        for (const auto& tx : parent1_children_from_sender) {\n+            BOOST_CHECK(expected_parent1_children.contains(tx));",
      "path": "src/test/orphanage_tests.cpp",
      "position": null,
      "original_position": 83,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "42859548ab5aebf40da6089b85065f7c204b992a",
      "in_reply_to_id": null,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In 42859548ab5aebf40da6089b85065f7c204b992a\r\n\r\nTo make sure the two collections are equal you also need to check the their sizes match. This applies to the four cases.",
      "created_at": "2024-04-20T17:50:37Z",
      "updated_at": "2024-04-20T18:01:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1573354857",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1573354857"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": 201,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 203,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1574610556",
      "pull_request_review_id": 2014522439,
      "id": 1574610556,
      "node_id": "PRRC_kwDOABII585d2qZ8",
      "diff_hunk": "@@ -241,3 +241,71 @@ void TxOrphanage::EraseForBlock(const CBlock& block)\n         LogPrint(BCLog::TXPACKAGES, \"Erased %d orphan tx included or conflicted by block\\n\", nErased);\n     }\n }\n+\n+std::vector<CTransactionRef> TxOrphanage::GetChildrenFromSamePeer(const CTransactionRef& parent, NodeId nodeid) const\n+{\n+    LOCK(m_mutex);\n+\n+    // First construct a vector of iterators to ensure we do not return duplicates of the same tx\n+    // and so we can sort by nTimeExpire.\n+    std::vector<OrphanMap::iterator> unique_iters;\n+\n+    // For each output, get all entries spending this prevout, filtering for ones from the specified peer.\n+    for (unsigned int i = 0; i < parent->vout.size(); i++) {\n+        const auto it_by_prev = m_outpoint_to_orphan_it.find(COutPoint(parent->GetHash(), i));\n+        if (it_by_prev != m_outpoint_to_orphan_it.end()) {\n+            for (const auto& elem : it_by_prev->second) {\n+                if (elem->second.fromPeer == nodeid) {\n+                    unique_iters.emplace_back(elem);\n+                }\n+            }\n+        }\n+    }\n+\n+    // Sort so that more recent orphans (which expire later) come first.\n+    std::sort(unique_iters.begin(), unique_iters.end(), [](const auto& lhs, const auto& rhs) {\n+        return lhs->second.nTimeExpire > rhs->second.nTimeExpire;\n+    });\n+    // Erase duplicates\n+    unique_iters.erase(std::unique(unique_iters.begin(), unique_iters.end()), unique_iters.end());\n+\n+    // Convert to a vector of CTransactionRef\n+    std::vector<CTransactionRef> children_found;\n+    children_found.reserve(unique_iters.size());\n+    for (const auto child_iter : unique_iters) {\n+        children_found.emplace_back(child_iter->second.tx);\n+    }\n+    return children_found;\n+}\n+\n+std::vector<std::pair<CTransactionRef, NodeId>> TxOrphanage::GetChildrenFromDifferentPeer(const CTransactionRef& parent, NodeId nodeid) const\n+{\n+    LOCK(m_mutex);\n+\n+    // First construct vector of iterators to ensure we do not return duplicates of the same tx.\n+    std::vector<OrphanMap::iterator> unique_iters;",
      "path": "src/txorphanage.cpp",
      "position": null,
      "original_position": 46,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "ca9f03f2207854c849a14d7af2fcd91a5f675e14",
      "in_reply_to_id": 1573341141,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I copied this from the way we do `unique_parents` in orphan parent requests (see the discussion on #19596 about the dynamic memory usage and speed). However I don't mind either way and agree a `std::set` would be simpler, so happy to change if people prefer using a set.",
      "created_at": "2024-04-22T11:39:04Z",
      "updated_at": "2024-04-22T11:39:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1574610556",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1574610556"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 286,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1574612750",
      "pull_request_review_id": 2014525744,
      "id": 1574612750,
      "node_id": "PRRC_kwDOABII585d2q8O",
      "diff_hunk": "@@ -138,4 +162,154 @@ BOOST_AUTO_TEST_CASE(DoS_mapOrphans)\n     BOOST_CHECK(orphanage.CountOrphans() == 0);\n }\n \n+BOOST_AUTO_TEST_CASE(get_children)\n+{\n+    FastRandomContext det_rand{true};\n+    std::vector<COutPoint> empty_outpoints;\n+\n+    auto parent1 = MakeTransactionSpending(empty_outpoints, det_rand);\n+    auto parent2 = MakeTransactionSpending(empty_outpoints, det_rand);\n+\n+    // Make sure these parents have different txids otherwise this test won't make sense.\n+    while (parent1->GetHash() == parent2->GetHash()) {\n+        parent2 = MakeTransactionSpending(empty_outpoints, det_rand);\n+    }\n+\n+    // Create children to go into orphanage.\n+    auto child_p1n0 = MakeTransactionSpending({{parent1->GetHash(), 0}}, det_rand);\n+    auto child_p2n1 = MakeTransactionSpending({{parent2->GetHash(), 1}}, det_rand);\n+    // Spends the same tx twice. Should not cause duplicates.\n+    auto child_p1n0_p1n1 = MakeTransactionSpending({{parent1->GetHash(), 0}, {parent1->GetHash(), 1}}, det_rand);\n+    // Spends the same outpoint as previous tx. Should still be returned; don't assume outpoints are unique.\n+    auto child_p1n0_p2n0 = MakeTransactionSpending({{parent1->GetHash(), 0}, {parent2->GetHash(), 0}}, det_rand);\n+\n+    const NodeId node1{1};\n+    const NodeId node2{2};\n+\n+    // All orphans provided by node1\n+    {\n+        TxOrphanage orphanage;\n+        BOOST_CHECK(orphanage.AddTx(child_p1n0, node1));\n+        BOOST_CHECK(orphanage.AddTx(child_p2n1, node1));\n+        BOOST_CHECK(orphanage.AddTx(child_p1n0_p1n1, node1));\n+        BOOST_CHECK(orphanage.AddTx(child_p1n0_p2n0, node1));\n+\n+        std::set<CTransactionRef> expected_parent1_children{child_p1n0, child_p1n0_p2n0, child_p1n0_p1n1};\n+        std::set<CTransactionRef> expected_parent2_children{child_p2n1, child_p1n0_p2n0};\n+\n+        // Check contents and ensure transactions are returned in order of recency.",
      "path": "src/test/orphanage_tests.cpp",
      "position": null,
      "original_position": 80,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "42859548ab5aebf40da6089b85065f7c204b992a",
      "in_reply_to_id": 1573353122,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Ah, forgot to remove the comment. We need to make time parameterizable across `TxOrphanage` members to test order, so not testing / saving for followup.",
      "created_at": "2024-04-22T11:40:56Z",
      "updated_at": "2024-04-22T11:40:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1574612750",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1574612750"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 200,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1574616498",
      "pull_request_review_id": 2014531627,
      "id": 1574616498,
      "node_id": "PRRC_kwDOABII585d2r2y",
      "diff_hunk": "@@ -138,4 +162,154 @@ BOOST_AUTO_TEST_CASE(DoS_mapOrphans)\n     BOOST_CHECK(orphanage.CountOrphans() == 0);\n }\n \n+BOOST_AUTO_TEST_CASE(get_children)\n+{\n+    FastRandomContext det_rand{true};\n+    std::vector<COutPoint> empty_outpoints;\n+\n+    auto parent1 = MakeTransactionSpending(empty_outpoints, det_rand);\n+    auto parent2 = MakeTransactionSpending(empty_outpoints, det_rand);\n+\n+    // Make sure these parents have different txids otherwise this test won't make sense.\n+    while (parent1->GetHash() == parent2->GetHash()) {\n+        parent2 = MakeTransactionSpending(empty_outpoints, det_rand);\n+    }\n+\n+    // Create children to go into orphanage.\n+    auto child_p1n0 = MakeTransactionSpending({{parent1->GetHash(), 0}}, det_rand);\n+    auto child_p2n1 = MakeTransactionSpending({{parent2->GetHash(), 1}}, det_rand);\n+    // Spends the same tx twice. Should not cause duplicates.\n+    auto child_p1n0_p1n1 = MakeTransactionSpending({{parent1->GetHash(), 0}, {parent1->GetHash(), 1}}, det_rand);\n+    // Spends the same outpoint as previous tx. Should still be returned; don't assume outpoints are unique.\n+    auto child_p1n0_p2n0 = MakeTransactionSpending({{parent1->GetHash(), 0}, {parent2->GetHash(), 0}}, det_rand);\n+\n+    const NodeId node1{1};\n+    const NodeId node2{2};\n+\n+    // All orphans provided by node1\n+    {\n+        TxOrphanage orphanage;\n+        BOOST_CHECK(orphanage.AddTx(child_p1n0, node1));\n+        BOOST_CHECK(orphanage.AddTx(child_p2n1, node1));\n+        BOOST_CHECK(orphanage.AddTx(child_p1n0_p1n1, node1));\n+        BOOST_CHECK(orphanage.AddTx(child_p1n0_p2n0, node1));\n+\n+        std::set<CTransactionRef> expected_parent1_children{child_p1n0, child_p1n0_p2n0, child_p1n0_p1n1};\n+        std::set<CTransactionRef> expected_parent2_children{child_p2n1, child_p1n0_p2n0};\n+\n+        // Check contents and ensure transactions are returned in order of recency.",
      "path": "src/test/orphanage_tests.cpp",
      "position": null,
      "original_position": 80,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "42859548ab5aebf40da6089b85065f7c204b992a",
      "in_reply_to_id": 1573353122,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "deleted",
      "created_at": "2024-04-22T11:44:03Z",
      "updated_at": "2024-04-22T12:27:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1574616498",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1574616498"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 200,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1574616580",
      "pull_request_review_id": 2014531627,
      "id": 1574616580,
      "node_id": "PRRC_kwDOABII585d2r4E",
      "diff_hunk": "@@ -138,4 +162,154 @@ BOOST_AUTO_TEST_CASE(DoS_mapOrphans)\n     BOOST_CHECK(orphanage.CountOrphans() == 0);\n }\n \n+BOOST_AUTO_TEST_CASE(get_children)\n+{\n+    FastRandomContext det_rand{true};\n+    std::vector<COutPoint> empty_outpoints;\n+\n+    auto parent1 = MakeTransactionSpending(empty_outpoints, det_rand);\n+    auto parent2 = MakeTransactionSpending(empty_outpoints, det_rand);\n+\n+    // Make sure these parents have different txids otherwise this test won't make sense.\n+    while (parent1->GetHash() == parent2->GetHash()) {\n+        parent2 = MakeTransactionSpending(empty_outpoints, det_rand);\n+    }\n+\n+    // Create children to go into orphanage.\n+    auto child_p1n0 = MakeTransactionSpending({{parent1->GetHash(), 0}}, det_rand);\n+    auto child_p2n1 = MakeTransactionSpending({{parent2->GetHash(), 1}}, det_rand);\n+    // Spends the same tx twice. Should not cause duplicates.\n+    auto child_p1n0_p1n1 = MakeTransactionSpending({{parent1->GetHash(), 0}, {parent1->GetHash(), 1}}, det_rand);\n+    // Spends the same outpoint as previous tx. Should still be returned; don't assume outpoints are unique.\n+    auto child_p1n0_p2n0 = MakeTransactionSpending({{parent1->GetHash(), 0}, {parent2->GetHash(), 0}}, det_rand);\n+\n+    const NodeId node1{1};\n+    const NodeId node2{2};\n+\n+    // All orphans provided by node1\n+    {\n+        TxOrphanage orphanage;\n+        BOOST_CHECK(orphanage.AddTx(child_p1n0, node1));\n+        BOOST_CHECK(orphanage.AddTx(child_p2n1, node1));\n+        BOOST_CHECK(orphanage.AddTx(child_p1n0_p1n1, node1));\n+        BOOST_CHECK(orphanage.AddTx(child_p1n0_p2n0, node1));\n+\n+        std::set<CTransactionRef> expected_parent1_children{child_p1n0, child_p1n0_p2n0, child_p1n0_p1n1};\n+        std::set<CTransactionRef> expected_parent2_children{child_p2n1, child_p1n0_p2n0};\n+\n+        // Check contents and ensure transactions are returned in order of recency.\n+        const auto parent1_children_from_sender{orphanage.GetChildrenFromSamePeer(parent1, node1)};\n+        for (const auto& tx : parent1_children_from_sender) {\n+            BOOST_CHECK(expected_parent1_children.contains(tx));",
      "path": "src/test/orphanage_tests.cpp",
      "position": null,
      "original_position": 83,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "42859548ab5aebf40da6089b85065f7c204b992a",
      "in_reply_to_id": 1573354857,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "done",
      "created_at": "2024-04-22T11:44:07Z",
      "updated_at": "2024-04-22T12:27:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1574616580",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1574616580"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": 201,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 203,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1574616703",
      "pull_request_review_id": 2014531627,
      "id": 1574616703,
      "node_id": "PRRC_kwDOABII585d2r5_",
      "diff_hunk": "@@ -40,6 +43,93 @@ inline CTransactionRef create_placeholder_tx(size_t num_inputs, size_t num_outpu\n     return MakeTransactionRef(mtx);\n }\n \n+// Create a Wtxid from a hex string\n+inline Wtxid WtxidFromString(std::string_view str)\n+{\n+    return Wtxid::FromUint256(uint256S(str.data()));\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(package_hash_tests, TestChain100Setup)\n+{\n+    // Random real segwit transaction\n+    DataStream stream_1{\n+        ParseHex(\"02000000000101964b8aa63509579ca6086e6012eeaa4c2f4dd1e283da29b67c8eea38b3c6fd220000000000fdffffff0294c618000000000017a9145afbbb42f4e83312666d0697f9e66259912ecde38768fa2c0000000000160014897388a0889390fd0e153a22bb2cf9d8f019faf50247304402200547406380719f84d68cf4e96cc3e4a1688309ef475b150be2b471c70ea562aa02206d255f5acc40fd95981874d77201d2eb07883657ce1c796513f32b6079545cdf0121023ae77335cefcb5ab4c1dc1fb0d2acfece184e593727d7d5906c78e564c7c11d125cf0c00\"),\n+    };\n+    CTransaction tx_1(deserialize, TX_WITH_WITNESS, stream_1);\n+    CTransactionRef ptx_1{MakeTransactionRef(tx_1)};\n+\n+    // Random real nonsegwit transaction\n+    DataStream stream_2{\n+        ParseHex(\"01000000010b26e9b7735eb6aabdf358bab62f9816a21ba9ebdb719d5299e88607d722c190000000008b4830450220070aca44506c5cef3a16ed519d7c3c39f8aab192c4e1c90d065f37b8a4af6141022100a8e160b856c2d43d27d8fba71e5aef6405b8643ac4cb7cb3c462aced7f14711a0141046d11fee51b0e60666d5049a9101a72741df480b96ee26488a4d3466b95c9a40ac5eeef87e10a5cd336c19a84565f80fa6c547957b7700ff4dfbdefe76036c339ffffffff021bff3d11000000001976a91404943fdd508053c75000106d3bc6e2754dbcff1988ac2f15de00000000001976a914a266436d2965547608b9e15d9032a7b9d64fa43188ac00000000\"),\n+    };\n+    CTransaction tx_2(deserialize, TX_WITH_WITNESS, stream_2);\n+    CTransactionRef ptx_2{MakeTransactionRef(tx_2)};\n+\n+    // Random real segwit transaction\n+    DataStream stream_3{\n+        ParseHex(\"0200000000010177862801f77c2c068a70372b4c435ef8dd621291c36a64eb4dd491f02218f5324600000000fdffffff014a0100000000000022512035ea312034cfac01e956a269f3bf147f569c2fbb00180677421262da042290d803402be713325ff285e66b0380f53f2fae0d0fb4e16f378a440fed51ce835061437566729d4883bc917632f3cff474d6384bc8b989961a1d730d4a87ed38ad28bd337b20f1d658c6c138b1c312e072b4446f50f01ae0da03a42e6274f8788aae53416a7fac0063036f7264010118746578742f706c61696e3b636861727365743d7574662d3800357b2270223a226272632d3230222c226f70223a226d696e74222c227469636b223a224342414c222c22616d74223a2236393639227d6821c1f1d658c6c138b1c312e072b4446f50f01ae0da03a42e6274f8788aae53416a7f00000000\"),\n+    };\n+    CTransaction tx_3(deserialize, TX_WITH_WITNESS, stream_3);\n+    CTransactionRef ptx_3{MakeTransactionRef(tx_3)};\n+\n+    // It's easy to see that wtxids are sorted in lexicographical order:\n+    Wtxid wtxid_1{WtxidFromString(\"0x85cd1a31eb38f74ed5742ec9cb546712ab5aaf747de28a9168b53e846cbda17f\")};\n+    Wtxid wtxid_2{WtxidFromString(\"0xb4749f017444b051c44dfd2720e88f314ff94f3dd6d56d40ef65854fcd7fff6b\")};\n+    Wtxid wtxid_3{WtxidFromString(\"0xe065bac15f62bb4e761d761db928ddee65a47296b2b776785abb912cdec474e3\")};\n+    BOOST_CHECK_EQUAL(tx_1.GetWitnessHash(), wtxid_1);\n+    BOOST_CHECK_EQUAL(tx_2.GetWitnessHash(), wtxid_2);\n+    BOOST_CHECK_EQUAL(tx_3.GetWitnessHash(), wtxid_3);\n+\n+    BOOST_CHECK(wtxid_1.GetHex() < wtxid_2.GetHex());\n+    BOOST_CHECK(wtxid_2.GetHex() < wtxid_3.GetHex());\n+    BOOST_CHECK(wtxid_1.GetHex() < wtxid_3.GetHex());",
      "path": "src/test/txpackage_tests.cpp",
      "position": null,
      "original_position": 56,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "5c8aa657642ef24e711a73c28278644f14117d73",
      "in_reply_to_id": 1573331603,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "deleted",
      "created_at": "2024-04-22T11:44:14Z",
      "updated_at": "2024-04-22T12:27:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1574616703",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1574616703"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 85,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1574632413",
      "pull_request_review_id": 2014531627,
      "id": 1574632413,
      "node_id": "PRRC_kwDOABII585d2vvd",
      "diff_hunk": "@@ -241,3 +241,71 @@ void TxOrphanage::EraseForBlock(const CBlock& block)\n         LogPrint(BCLog::TXPACKAGES, \"Erased %d orphan tx included or conflicted by block\\n\", nErased);\n     }\n }\n+\n+std::vector<CTransactionRef> TxOrphanage::GetChildrenFromSamePeer(const CTransactionRef& parent, NodeId nodeid) const\n+{\n+    LOCK(m_mutex);\n+\n+    // First construct a vector of iterators to ensure we do not return duplicates of the same tx\n+    // and so we can sort by nTimeExpire.\n+    std::vector<OrphanMap::iterator> unique_iters;",
      "path": "src/txorphanage.cpp",
      "position": null,
      "original_position": 11,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "ca9f03f2207854c849a14d7af2fcd91a5f675e14",
      "in_reply_to_id": 1573344593,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I think it's pretty common to name a temporary data structure based on its intended result. But ok, I've changed it to `iters` now.",
      "created_at": "2024-04-22T11:56:56Z",
      "updated_at": "2024-04-22T12:27:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1574632413",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1574632413"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": 249,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 251,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1574633307",
      "pull_request_review_id": 2014531627,
      "id": 1574633307,
      "node_id": "PRRC_kwDOABII585d2v9b",
      "diff_hunk": "@@ -0,0 +1,319 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test opportunistic 1p1c package submission logic.\n+\"\"\"\n+\n+from decimal import Decimal\n+from test_framework.messages import (\n+    CInv,\n+    CTxInWitness,\n+    MSG_WTX,\n+    msg_inv,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    fill_mempool,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+\n+def cleanup(func):\n+    def wrapper(self, *args, **kwargs):\n+        try:\n+            func(self, *args, **kwargs)\n+        finally:\n+            self.nodes[0].disconnect_p2ps()\n+            # Do not clear the node's mempool, as each test requires mempool min feerate > min\n+            # relay feerate. However, do check that this is the case.\n+            assert self.nodes[0].getmempoolinfo()[\"mempoolminfee\"] > self.nodes[0].getnetworkinfo()[\"relayfee\"]\n+            # Ensure we do not try to spend the same UTXOs in subsequent tests, as they will look like RBF attempts.\n+            self.wallet.rescan_utxos(include_mempool=True)\n+    return wrapper\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+        ]]\n+        self.supports_cli = False\n+\n+    def subest_check(self):",
      "path": "test/functional/p2p_opportunistic_1p1c.py",
      "position": null,
      "original_position": 56,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "a053911cb9957797faff7f68dbd6deb6b6080578",
      "in_reply_to_id": 1572436712,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "deleted",
      "created_at": "2024-04-22T11:57:39Z",
      "updated_at": "2024-04-22T12:27:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1574633307",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1574633307"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 56,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1574634137",
      "pull_request_review_id": 2014531627,
      "id": 1574634137,
      "node_id": "PRRC_kwDOABII585d2wKZ",
      "diff_hunk": "@@ -0,0 +1,319 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test opportunistic 1p1c package submission logic.\n+\"\"\"\n+\n+from decimal import Decimal\n+from test_framework.messages import (\n+    CInv,\n+    CTxInWitness,\n+    MSG_WTX,\n+    msg_inv,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    fill_mempool,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+\n+def cleanup(func):\n+    def wrapper(self, *args, **kwargs):\n+        try:\n+            func(self, *args, **kwargs)\n+        finally:\n+            self.nodes[0].disconnect_p2ps()\n+            # Do not clear the node's mempool, as each test requires mempool min feerate > min\n+            # relay feerate. However, do check that this is the case.\n+            assert self.nodes[0].getmempoolinfo()[\"mempoolminfee\"] > self.nodes[0].getnetworkinfo()[\"relayfee\"]\n+            # Ensure we do not try to spend the same UTXOs in subsequent tests, as they will look like RBF attempts.\n+            self.wallet.rescan_utxos(include_mempool=True)\n+    return wrapper\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+        ]]\n+        self.supports_cli = False\n+\n+    def subest_check(self):\n+        self.nodes[0].disconnect_p2ps()\n+        # Do not clear the node's mempool, as each test requires mempool min feerate > min\n+        # relay feerate. However, do check that this is the case.\n+        assert self.nodes[0].getmempoolinfo()[\"mempoolminfee\"] > self.nodes[0].getnetworkinfo()[\"relayfee\"]\n+        # Ensure we do not try to spend the same UTXOs in subsequent tests, as they will look like RBF attempts.\n+        self.wallet.rescan_utxos(include_mempool=True)\n+\n+    @cleanup\n+    def test_basic_child_then_parent(self):\n+        node = self.nodes[0]\n+        self.log.info(\"Check that opportunistic 1p1c logic works when child is received before parent\")\n+\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first (perhaps the low feerate parent didn't meet feefilter or the requests were sent to different nodes). It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. Sender relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 4. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+        node.disconnect_p2ps()\n+\n+    @cleanup\n+    def test_basic_parent_then_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=1, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=2, connection_type=\"outbound-full-relay\")\n+\n+        # 1. Parent is relayed first. It is too low feerate.\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer_sender.wait_for_getdata([parent_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer_ignored, check that it is ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+\n+        # 2. Child is relayed next. It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 3. Node requests the missing parent by txid.\n+        # It should do so even if it has previously rejected that parent for being too low feerate.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 4. Sender re-relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 5. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+    @cleanup\n+    def test_low_and_high_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        # This feerate is above mempoolminfee, but not enough to also bump the low feerate parent.\n+        feerate_just_above = node.getmempoolinfo()[\"mempoolminfee\"]\n+        med_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=feerate_just_above)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=3, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=4, connection_type=\"outbound-full-relay\")\n+\n+        self.log.info(\"Check that tx caches low fee parent + low fee child package rejections\")\n+\n+        # 1. Send parent, rejected for being low feerate.\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer_sender.wait_for_getdata([parent_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer_ignored, check that it is ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+\n+        # 2. Send an (orphan) child that has a higher feerate, but not enough to bump the parent.\n+        low_child_wtxid_int = int(med_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([low_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(med_fee_child[\"tx\"]))\n+\n+        # 3. Node requests the orphan's missing parent.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 4. The low parent + low child are submitted as a package. They are not accepted due to low package feerate.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+        assert med_fee_child[\"txid\"] not in node.getrawmempool()\n+\n+        # If peer_ignored announces the low feerate child, it should be ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+        # If either peer sends the parent again, package evaluation should not be attempted\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        peer_ignored.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 5. Send the high feerate (orphan) child\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 6. Node requests the orphan's parent, even though it has already been rejected, both by\n+        # itself and with a child. This is necessary, otherwise high_fee_child can be censored.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 7. The low feerate parent + high feerate child are submitted as a package.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 8. Both transactions should now be in mempool\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+    @cleanup\n+    def test_orphan_consensus_failure(self):\n+        self.log.info(\"Check opportunistic 1p1c logic with consensus-invalid orphan causes disconnect of the correct peer\")\n+        node = self.nodes[0]\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        coin = low_fee_parent[\"new_utxo\"]\n+        address = node.get_deterministic_priv_key().address\n+        # Create raw transaction spending the parent, but with no signature (a consensus error).\n+        hex_orphan_no_sig = node.createrawtransaction([{\"txid\": coin[\"txid\"], \"vout\": coin[\"vout\"]}], {address : coin[\"value\"] - Decimal(\"0.0001\")})\n+        tx_orphan_bad_wit = tx_from_hex(hex_orphan_no_sig)\n+        tx_orphan_bad_wit.wit.vtxinwit.append(CTxInWitness())\n+        tx_orphan_bad_wit.wit.vtxinwit[0].scriptWitness.stack = [b'garbage']\n+\n+        bad_orphan_sender = node.add_p2p_connection(P2PInterface())\n+        parent_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first. It is missing an input.\n+        child_wtxid_int = int(tx_orphan_bad_wit.getwtxid(), 16)\n+        bad_orphan_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=child_wtxid_int)]))\n+        bad_orphan_sender.wait_for_getdata([child_wtxid_int])\n+        bad_orphan_sender.send_and_ping(msg_tx(tx_orphan_bad_wit))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        bad_orphan_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. A different peer relays the parent. Parent+Child are evaluated as a package and rejected.\n+        parent_sender.send_message(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 4. Transactions should not be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] not in node_mempool\n+        assert tx_orphan_bad_wit.rehash() not in node_mempool\n+\n+        # 5. Peer that sent a consensus-invalid transaction should be disconnected.\n+        bad_orphan_sender.wait_for_disconnect()\n+\n+        # The peer that didn't provide the orphan should not be disconnected.\n+        parent_sender.sync_with_ping()\n+\n+    @cleanup\n+    def test_parent_consensus_failure(self):\n+        self.log.info(\"Check opportunistic 1p1c logic with consensus-invalid parent causes disconnect of the correct peer\")\n+        node = self.nodes[0]\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+\n+        # Create invalid version of parent with a bad signature.\n+        tx_parent_bad_wit = tx_from_hex(low_fee_parent[\"hex\"])\n+        tx_parent_bad_wit.wit.vtxinwit.append(CTxInWitness())\n+        tx_parent_bad_wit.wit.vtxinwit[0].scriptWitness.stack = [b'garbage']\n+\n+        package_sender = node.add_p2p_connection(P2PInterface())\n+        fake_parent_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first. It is missing an input.\n+        child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        package_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=child_wtxid_int)]))\n+        package_sender.wait_for_getdata([child_wtxid_int])\n+        package_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(tx_parent_bad_wit.rehash(), 16)\n+        package_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. A different node relays the parent. The parent is first evaluated by itself and\n+        # rejected for being too low feerate. Then it is evaluated as a package and, after passing\n+        # feerate checks, rejected for having a bad signature (consensus error).\n+        fake_parent_sender.send_message(msg_tx(tx_parent_bad_wit))\n+\n+        # 4. Transactions should not be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert tx_parent_bad_wit.rehash() not in node_mempool\n+        assert high_fee_child[\"txid\"] not in node_mempool\n+\n+        # 5. Peer sent a consensus-invalid transaction.\n+        fake_parent_sender.wait_for_disconnect()\n+\n+        self.log.info(\"Check opportunistic 1p1c logic with consensus-invalid parent causes disconnect of the correct peer\")",
      "path": "test/functional/p2p_opportunistic_1p1c.py",
      "position": null,
      "original_position": 278,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "a053911cb9957797faff7f68dbd6deb6b6080578",
      "in_reply_to_id": 1572504707,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Ah that was supposed to be another log, should be fixed now",
      "created_at": "2024-04-22T11:58:15Z",
      "updated_at": "2024-04-22T12:27:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1574634137",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1574634137"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 278,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1575059642",
      "pull_request_review_id": 2015296846,
      "id": 1575059642,
      "node_id": "PRRC_kwDOABII585d4YC6",
      "diff_hunk": "@@ -138,4 +162,157 @@ BOOST_AUTO_TEST_CASE(DoS_mapOrphans)\n     BOOST_CHECK(orphanage.CountOrphans() == 0);\n }\n \n+BOOST_AUTO_TEST_CASE(get_children)\n+{\n+    FastRandomContext det_rand{true};\n+    std::vector<COutPoint> empty_outpoints;\n+\n+    auto parent1 = MakeTransactionSpending(empty_outpoints, det_rand);\n+    auto parent2 = MakeTransactionSpending(empty_outpoints, det_rand);\n+\n+    // Make sure these parents have different txids otherwise this test won't make sense.\n+    while (parent1->GetHash() == parent2->GetHash()) {\n+        parent2 = MakeTransactionSpending(empty_outpoints, det_rand);\n+    }\n+\n+    // Create children to go into orphanage.\n+    auto child_p1n0 = MakeTransactionSpending({{parent1->GetHash(), 0}}, det_rand);\n+    auto child_p2n1 = MakeTransactionSpending({{parent2->GetHash(), 1}}, det_rand);\n+    // Spends the same tx twice. Should not cause duplicates.\n+    auto child_p1n0_p1n1 = MakeTransactionSpending({{parent1->GetHash(), 0}, {parent1->GetHash(), 1}}, det_rand);\n+    // Spends the same outpoint as previous tx. Should still be returned; don't assume outpoints are unique.\n+    auto child_p1n0_p2n0 = MakeTransactionSpending({{parent1->GetHash(), 0}, {parent2->GetHash(), 0}}, det_rand);\n+\n+    const NodeId node1{1};\n+    const NodeId node2{2};\n+\n+    // All orphans provided by node1\n+    {\n+        TxOrphanage orphanage;\n+        BOOST_CHECK(orphanage.AddTx(child_p1n0, node1));\n+        BOOST_CHECK(orphanage.AddTx(child_p2n1, node1));\n+        BOOST_CHECK(orphanage.AddTx(child_p1n0_p1n1, node1));\n+        BOOST_CHECK(orphanage.AddTx(child_p1n0_p2n0, node1));\n+\n+        std::set<CTransactionRef> expected_parent1_children{child_p1n0, child_p1n0_p2n0, child_p1n0_p1n1};\n+        std::set<CTransactionRef> expected_parent2_children{child_p2n1, child_p1n0_p2n0};\n+\n+        const auto parent1_children_from_sender{orphanage.GetChildrenFromSamePeer(parent1, node1)};\n+        BOOST_CHECK_EQUAL(parent1_children_from_sender.size(), expected_parent1_children.size());\n+        for (const auto& tx : parent1_children_from_sender) {\n+            BOOST_CHECK(expected_parent1_children.contains(tx));\n+        }\n+        const auto parent2_children_from_sender{orphanage.GetChildrenFromSamePeer(parent2, node1)};\n+        BOOST_CHECK_EQUAL(parent2_children_from_sender.size(), expected_parent2_children.size());\n+        for (const auto& tx : parent2_children_from_sender) {\n+            BOOST_CHECK(expected_parent2_children.contains(tx));\n+        }\n+        // The peer must match\n+        BOOST_CHECK(orphanage.GetChildrenFromSamePeer(parent1, node2).empty());",
      "path": "src/test/orphanage_tests.cpp",
      "position": 105,
      "original_position": 91,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "507f5ea12a9637a5922d6220dedb91ca40396d7e",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit\r\n```Suggestion\r\n        BOOST_CHECK(orphanage.GetChildrenFromSamePeer(parent1, node2).empty());\r\n        BOOST_CHECK(orphanage.GetChildrenFromSamePeer(parent2, node2).empty());\r\n```",
      "created_at": "2024-04-22T16:39:47Z",
      "updated_at": "2024-04-22T17:01:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1575059642",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1575059642"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 225,
      "original_line": 225,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1575061630",
      "pull_request_review_id": 2015296846,
      "id": 1575061630,
      "node_id": "PRRC_kwDOABII585d4Yh-",
      "diff_hunk": "@@ -138,4 +162,157 @@ BOOST_AUTO_TEST_CASE(DoS_mapOrphans)\n     BOOST_CHECK(orphanage.CountOrphans() == 0);\n }\n \n+BOOST_AUTO_TEST_CASE(get_children)\n+{\n+    FastRandomContext det_rand{true};\n+    std::vector<COutPoint> empty_outpoints;\n+\n+    auto parent1 = MakeTransactionSpending(empty_outpoints, det_rand);\n+    auto parent2 = MakeTransactionSpending(empty_outpoints, det_rand);\n+\n+    // Make sure these parents have different txids otherwise this test won't make sense.\n+    while (parent1->GetHash() == parent2->GetHash()) {\n+        parent2 = MakeTransactionSpending(empty_outpoints, det_rand);\n+    }\n+\n+    // Create children to go into orphanage.\n+    auto child_p1n0 = MakeTransactionSpending({{parent1->GetHash(), 0}}, det_rand);\n+    auto child_p2n1 = MakeTransactionSpending({{parent2->GetHash(), 1}}, det_rand);\n+    // Spends the same tx twice. Should not cause duplicates.\n+    auto child_p1n0_p1n1 = MakeTransactionSpending({{parent1->GetHash(), 0}, {parent1->GetHash(), 1}}, det_rand);\n+    // Spends the same outpoint as previous tx. Should still be returned; don't assume outpoints are unique.\n+    auto child_p1n0_p2n0 = MakeTransactionSpending({{parent1->GetHash(), 0}, {parent2->GetHash(), 0}}, det_rand);\n+\n+    const NodeId node1{1};\n+    const NodeId node2{2};\n+\n+    // All orphans provided by node1\n+    {\n+        TxOrphanage orphanage;\n+        BOOST_CHECK(orphanage.AddTx(child_p1n0, node1));\n+        BOOST_CHECK(orphanage.AddTx(child_p2n1, node1));\n+        BOOST_CHECK(orphanage.AddTx(child_p1n0_p1n1, node1));\n+        BOOST_CHECK(orphanage.AddTx(child_p1n0_p2n0, node1));\n+\n+        std::set<CTransactionRef> expected_parent1_children{child_p1n0, child_p1n0_p2n0, child_p1n0_p1n1};\n+        std::set<CTransactionRef> expected_parent2_children{child_p2n1, child_p1n0_p2n0};\n+\n+        const auto parent1_children_from_sender{orphanage.GetChildrenFromSamePeer(parent1, node1)};\n+        BOOST_CHECK_EQUAL(parent1_children_from_sender.size(), expected_parent1_children.size());\n+        for (const auto& tx : parent1_children_from_sender) {\n+            BOOST_CHECK(expected_parent1_children.contains(tx));\n+        }\n+        const auto parent2_children_from_sender{orphanage.GetChildrenFromSamePeer(parent2, node1)};\n+        BOOST_CHECK_EQUAL(parent2_children_from_sender.size(), expected_parent2_children.size());\n+        for (const auto& tx : parent2_children_from_sender) {\n+            BOOST_CHECK(expected_parent2_children.contains(tx));\n+        }\n+        // The peer must match\n+        BOOST_CHECK(orphanage.GetChildrenFromSamePeer(parent1, node2).empty());\n+\n+        const auto parent1_children_not_other{orphanage.GetChildrenFromDifferentPeer(parent1, node2)};\n+        BOOST_CHECK_EQUAL(parent1_children_from_sender.size(), expected_parent1_children.size());\n+        for (const auto& [tx, peer] : parent1_children_not_other) {\n+            BOOST_CHECK(expected_parent1_children.contains(tx));\n+            BOOST_CHECK_EQUAL(peer, node1);\n+        }\n+        const auto parent2_children_not_other{orphanage.GetChildrenFromDifferentPeer(parent2, node2)};\n+        BOOST_CHECK_EQUAL(parent2_children_from_sender.size(), expected_parent2_children.size());\n+        for (const auto& [tx, peer] : parent2_children_not_other) {\n+            BOOST_CHECK(expected_parent2_children.contains(tx));\n+            BOOST_CHECK_EQUAL(peer, node1);\n+        }\n+\n+        // There shouldn't be any children of this tx",
      "path": "src/test/orphanage_tests.cpp",
      "position": null,
      "original_position": 106,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "507f5ea12a9637a5922d6220dedb91ca40396d7e",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit\r\n```Suggestion\r\n        // There shouldn't be any children of this tx in orphanage\r\n```",
      "created_at": "2024-04-22T16:41:26Z",
      "updated_at": "2024-04-22T17:01:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1575061630",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1575061630"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 226,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1575118464",
      "pull_request_review_id": 2005939457,
      "id": 1575118464,
      "node_id": "PRRC_kwDOABII585d4maA",
      "diff_hunk": "@@ -4432,7 +4586,9 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                     // protocol for getting all unconfirmed parents.\n                     const auto gtxid{GenTxid::Txid(parent_txid)};\n                     AddKnownTx(*peer, parent_txid);\n-                    if (!AlreadyHaveTx(gtxid, /*include_reconsiderable=*/true)) AddTxAnnouncement(pfrom, gtxid, current_time);\n+                    // Exclude m_recent_rejects_reconsiderable: the missing parent may have been\n+                    // previously rejected for being too low feerate. This orphan might CPFP it.\n+                    if (!AlreadyHaveTx(gtxid, /*include_reconsiderable=*/false)) AddTxAnnouncement(pfrom, gtxid, current_time);",
      "path": "src/net_processing.cpp",
      "position": 355,
      "original_position": 182,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "668313e00df9db815b392811bfc27dbb673ea9f9",
      "in_reply_to_id": null,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Let's say we've got a transaction T that is missing inputs.  We loop through the missing parents and see that none are in `m_recent_rejects`, so we drop into this block of code.\r\n\r\nIf there's more than 1 missing parent in `m_recent_rejects_reconsiderable`, is there any benefit to fetching them?  It seems like we could tell in advance that validation would fail in that circumstance, because we only try 1P1C packages.\r\n\r\nI don't know if it's worth additional complexity to deal with this case, but just wanted to flag the potential bandwidth waste if this were a common pattern.",
      "created_at": "2024-04-22T17:23:36Z",
      "updated_at": "2024-04-22T22:38:06Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1575118464",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1575118464"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 4617,
      "original_line": 4617,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1575257763",
      "pull_request_review_id": 2015631578,
      "id": 1575257763,
      "node_id": "PRRC_kwDOABII585d5Iaj",
      "diff_hunk": "@@ -136,6 +156,12 @@ FUZZ_TARGET(txorphan, .init = initialize_orphanage)\n                     orphanage.LimitOrphans(limit, limit_orphans_rng);\n                     Assert(orphanage.Size() <= limit);\n                 });\n+\n+        // Set tx as potential parent to be used for future GetChildren() calls.\n+        if (!ptx_potential_parent || fuzzed_data_provider.ConsumeBool()) {\n+            ptx_potential_parent = tx;\n+        }",
      "path": "src/test/fuzz/txorphan.cpp",
      "position": null,
      "original_position": 55,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "b9caa4cfcbd1e176ab3ecd61973ab6721570aecb",
      "in_reply_to_id": null,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In b9caa4cfcbd1e176ab3ecd61973ab6721570aecb\r\n\r\nI'm not too familiar with fuzzing, but wouldn't it be better if this be set unconditionally? This will trigger on the first iteration of the loop, and then based on a coin flip AFAICT, which means that if the variable is not overwritten, we will call `orphanage.AddChildrenToWorkSet(*ptx_potential_parent);` with the same transaction multiple times. This is harmless, given the internals just add data to a set, so multiple calls won't change it, but it is redundant (and so are the fors that will trigger latter).\r\n\r\n",
      "created_at": "2024-04-22T19:23:25Z",
      "updated_at": "2024-04-25T13:25:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1575257763",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1575257763"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": 160,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 164,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1575419630",
      "pull_request_review_id": 2005939457,
      "id": 1575419630,
      "node_id": "PRRC_kwDOABII585d5v7u",
      "diff_hunk": "@@ -3195,6 +3210,136 @@ void PeerManagerImpl::ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, c\n     }\n }\n \n+void PeerManagerImpl::ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, const std::vector<NodeId>& senders)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    if (package_result.m_state.IsInvalid()) {\n+        m_recent_rejects_reconsiderable.insert(GetPackageHash(package));\n+    }\n+    // We currently only expect to process 1-parent-1-child packages. Remove if this changes.\n+    if (!Assume(package.size() == 2)) return;\n+\n+    // Iterate backwards to erase in-package descendants from the orphanage before they become\n+    // relevant in AddChildrenToWorkSet.\n+    auto package_iter = package.rbegin();\n+    auto senders_iter = senders.rbegin();\n+    while (package_iter != package.rend()) {\n+        const auto& tx = *package_iter;\n+        const NodeId nodeid = *senders_iter;\n+        const auto it_result{package_result.m_tx_results.find(tx->GetWitnessHash())};\n+        if (Assume(it_result != package_result.m_tx_results.end())) {\n+            const auto& tx_result = it_result->second;\n+            switch (tx_result.m_result_type) {\n+                case MempoolAcceptResult::ResultType::VALID:\n+                {\n+                    Assume(tx_result.m_replaced_transactions.has_value());\n+                    std::list<CTransactionRef> empty_replacement_list;\n+                    ProcessValidTx(nodeid, tx, tx_result.m_replaced_transactions.value_or(empty_replacement_list));\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::INVALID:\n+                case MempoolAcceptResult::ResultType::DIFFERENT_WITNESS:\n+                {\n+                    // Don't add to vExtraTxnForCompact, as these transactions should have already been\n+                    // added there when added to the orphanage or rejected for TX_RECONSIDERABLE.\n+                    // This should be updated if package submission is ever used for transactions\n+                    // that haven't already been validated before.\n+                    ProcessInvalidTx(nodeid, tx, tx_result.m_state, /*maybe_add_extra_compact_tx=*/false);\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::MEMPOOL_ENTRY:\n+                {\n+                    // AlreadyHaveTx() should be catching transactions that are already in mempool.\n+                    Assume(false);\n+                    break;\n+                }\n+            }\n+        }\n+        package_iter++;\n+        // There should be a sender for each tx, but fall back to the last one otherwise.\n+        if (Assume(senders_iter != senders.rend())) senders_iter++;\n+    }\n+}\n+\n+void PeerManagerImpl::MaybeProcess1P1CPackage(const CTransactionRef& ptx, NodeId nodeid)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    const auto& parent_txid{ptx->GetHash()};\n+    const auto& parent_wtxid{ptx->GetWitnessHash()};\n+\n+    CTransactionRef tx_orphan{nullptr};\n+    NodeId orphan_sender{-1};\n+    Assume(m_recent_rejects_reconsiderable.contains(parent_wtxid.ToUint256()));\n+\n+    // Prefer children from this peer. This helps prevent censorship attempts in which an attacker\n+    // sends lots of fake children for the parent, and we (unluckily) keep selecting the fake\n+    // children instead of the real one provided by the honest peer.\n+    const auto cpfp_candidates_same_peer{m_orphanage.GetChildrenFromSamePeer(ptx, nodeid)};\n+\n+    // These children should be sorted from most newest to oldest. In the case of children that\n+    // replace each other, this helps us accept the highest feerate (most recent) one most\n+    // efficiently.\n+    for (const auto& child : cpfp_candidates_same_peer) {",
      "path": "src/net_processing.cpp",
      "position": 235,
      "original_position": 101,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "668313e00df9db815b392811bfc27dbb673ea9f9",
      "in_reply_to_id": null,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Just an observation: I guess the more common case will likely be multiple children of the same parent transaction (rather than conflicting children).  Still, we have no idea which child will have the best chance of successfully bumping it, so this ordering seems as good as any.",
      "created_at": "2024-04-22T22:27:52Z",
      "updated_at": "2024-04-22T22:38:06Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1575419630",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1575419630"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 3315,
      "original_line": 3315,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1575987644",
      "pull_request_review_id": 2016798985,
      "id": 1575987644,
      "node_id": "PRRC_kwDOABII585d76m8",
      "diff_hunk": "@@ -138,4 +162,157 @@ BOOST_AUTO_TEST_CASE(DoS_mapOrphans)\n     BOOST_CHECK(orphanage.CountOrphans() == 0);\n }\n \n+BOOST_AUTO_TEST_CASE(get_children)\n+{\n+    FastRandomContext det_rand{true};\n+    std::vector<COutPoint> empty_outpoints;\n+\n+    auto parent1 = MakeTransactionSpending(empty_outpoints, det_rand);\n+    auto parent2 = MakeTransactionSpending(empty_outpoints, det_rand);\n+\n+    // Make sure these parents have different txids otherwise this test won't make sense.\n+    while (parent1->GetHash() == parent2->GetHash()) {\n+        parent2 = MakeTransactionSpending(empty_outpoints, det_rand);\n+    }\n+\n+    // Create children to go into orphanage.\n+    auto child_p1n0 = MakeTransactionSpending({{parent1->GetHash(), 0}}, det_rand);\n+    auto child_p2n1 = MakeTransactionSpending({{parent2->GetHash(), 1}}, det_rand);\n+    // Spends the same tx twice. Should not cause duplicates.\n+    auto child_p1n0_p1n1 = MakeTransactionSpending({{parent1->GetHash(), 0}, {parent1->GetHash(), 1}}, det_rand);\n+    // Spends the same outpoint as previous tx. Should still be returned; don't assume outpoints are unique.\n+    auto child_p1n0_p2n0 = MakeTransactionSpending({{parent1->GetHash(), 0}, {parent2->GetHash(), 0}}, det_rand);\n+\n+    const NodeId node1{1};\n+    const NodeId node2{2};\n+\n+    // All orphans provided by node1\n+    {\n+        TxOrphanage orphanage;\n+        BOOST_CHECK(orphanage.AddTx(child_p1n0, node1));\n+        BOOST_CHECK(orphanage.AddTx(child_p2n1, node1));\n+        BOOST_CHECK(orphanage.AddTx(child_p1n0_p1n1, node1));\n+        BOOST_CHECK(orphanage.AddTx(child_p1n0_p2n0, node1));\n+\n+        std::set<CTransactionRef> expected_parent1_children{child_p1n0, child_p1n0_p2n0, child_p1n0_p1n1};\n+        std::set<CTransactionRef> expected_parent2_children{child_p2n1, child_p1n0_p2n0};\n+\n+        const auto parent1_children_from_sender{orphanage.GetChildrenFromSamePeer(parent1, node1)};\n+        BOOST_CHECK_EQUAL(parent1_children_from_sender.size(), expected_parent1_children.size());\n+        for (const auto& tx : parent1_children_from_sender) {\n+            BOOST_CHECK(expected_parent1_children.contains(tx));\n+        }\n+        const auto parent2_children_from_sender{orphanage.GetChildrenFromSamePeer(parent2, node1)};\n+        BOOST_CHECK_EQUAL(parent2_children_from_sender.size(), expected_parent2_children.size());\n+        for (const auto& tx : parent2_children_from_sender) {\n+            BOOST_CHECK(expected_parent2_children.contains(tx));\n+        }\n+        // The peer must match\n+        BOOST_CHECK(orphanage.GetChildrenFromSamePeer(parent1, node2).empty());",
      "path": "src/test/orphanage_tests.cpp",
      "position": 105,
      "original_position": 91,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "507f5ea12a9637a5922d6220dedb91ca40396d7e",
      "in_reply_to_id": 1575059642,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done. Also refactored orphanage_tests to be more readable.",
      "created_at": "2024-04-23T09:57:42Z",
      "updated_at": "2024-04-23T09:57:42Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1575987644",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1575987644"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 225,
      "original_line": 225,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1575989359",
      "pull_request_review_id": 2016801867,
      "id": 1575989359,
      "node_id": "PRRC_kwDOABII585d77Bv",
      "diff_hunk": "@@ -3195,6 +3210,136 @@ void PeerManagerImpl::ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, c\n     }\n }\n \n+void PeerManagerImpl::ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, const std::vector<NodeId>& senders)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    if (package_result.m_state.IsInvalid()) {\n+        m_recent_rejects_reconsiderable.insert(GetPackageHash(package));\n+    }\n+    // We currently only expect to process 1-parent-1-child packages. Remove if this changes.\n+    if (!Assume(package.size() == 2)) return;\n+\n+    // Iterate backwards to erase in-package descendants from the orphanage before they become\n+    // relevant in AddChildrenToWorkSet.\n+    auto package_iter = package.rbegin();\n+    auto senders_iter = senders.rbegin();\n+    while (package_iter != package.rend()) {\n+        const auto& tx = *package_iter;\n+        const NodeId nodeid = *senders_iter;\n+        const auto it_result{package_result.m_tx_results.find(tx->GetWitnessHash())};\n+        if (Assume(it_result != package_result.m_tx_results.end())) {\n+            const auto& tx_result = it_result->second;\n+            switch (tx_result.m_result_type) {\n+                case MempoolAcceptResult::ResultType::VALID:\n+                {\n+                    Assume(tx_result.m_replaced_transactions.has_value());\n+                    std::list<CTransactionRef> empty_replacement_list;\n+                    ProcessValidTx(nodeid, tx, tx_result.m_replaced_transactions.value_or(empty_replacement_list));\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::INVALID:\n+                case MempoolAcceptResult::ResultType::DIFFERENT_WITNESS:\n+                {\n+                    // Don't add to vExtraTxnForCompact, as these transactions should have already been\n+                    // added there when added to the orphanage or rejected for TX_RECONSIDERABLE.\n+                    // This should be updated if package submission is ever used for transactions\n+                    // that haven't already been validated before.\n+                    ProcessInvalidTx(nodeid, tx, tx_result.m_state, /*maybe_add_extra_compact_tx=*/false);\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::MEMPOOL_ENTRY:\n+                {\n+                    // AlreadyHaveTx() should be catching transactions that are already in mempool.\n+                    Assume(false);\n+                    break;\n+                }\n+            }\n+        }\n+        package_iter++;\n+        // There should be a sender for each tx, but fall back to the last one otherwise.\n+        if (Assume(senders_iter != senders.rend())) senders_iter++;\n+    }\n+}\n+\n+void PeerManagerImpl::MaybeProcess1P1CPackage(const CTransactionRef& ptx, NodeId nodeid)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    const auto& parent_txid{ptx->GetHash()};\n+    const auto& parent_wtxid{ptx->GetWitnessHash()};\n+\n+    CTransactionRef tx_orphan{nullptr};\n+    NodeId orphan_sender{-1};\n+    Assume(m_recent_rejects_reconsiderable.contains(parent_wtxid.ToUint256()));\n+\n+    // Prefer children from this peer. This helps prevent censorship attempts in which an attacker\n+    // sends lots of fake children for the parent, and we (unluckily) keep selecting the fake\n+    // children instead of the real one provided by the honest peer.\n+    const auto cpfp_candidates_same_peer{m_orphanage.GetChildrenFromSamePeer(ptx, nodeid)};\n+\n+    // These children should be sorted from most newest to oldest. In the case of children that\n+    // replace each other, this helps us accept the highest feerate (most recent) one most\n+    // efficiently.\n+    for (const auto& child : cpfp_candidates_same_peer) {",
      "path": "src/net_processing.cpp",
      "position": 235,
      "original_position": 101,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "668313e00df9db815b392811bfc27dbb673ea9f9",
      "in_reply_to_id": 1575419630,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Edited the comment to say this is a probably uncommon case",
      "created_at": "2024-04-23T09:59:08Z",
      "updated_at": "2024-04-23T09:59:08Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1575989359",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1575989359"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 3315,
      "original_line": 3315,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1575996002",
      "pull_request_review_id": 2016812242,
      "id": 1575996002,
      "node_id": "PRRC_kwDOABII585d78pi",
      "diff_hunk": "@@ -4354,7 +4354,9 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         const TxValidationState& state = result.m_state;\n \n         if (result.m_result_type == MempoolAcceptResult::ResultType::VALID) {\n-            ProcessValidTx(pfrom.GetId(), ptx, result.m_replaced_transactions.value());\n+            Assume(result.m_replaced_transactions.has_value());",
      "path": "src/net_processing.cpp",
      "position": 318,
      "original_position": 5,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "6f4da19cc3b1b7cd23cb4be95a6bb9acb79eb3bf",
      "in_reply_to_id": 1568781077,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I definitely agree it's awkward and doesn't have much benefit. I'll leave the assume/handling here, and maybe in a followup we can change it to non-optional.",
      "created_at": "2024-04-23T10:04:17Z",
      "updated_at": "2024-04-23T10:04:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1575996002",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1575996002"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 4566,
      "original_line": 4357,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1576145432",
      "pull_request_review_id": 2017068778,
      "id": 1576145432,
      "node_id": "PRRC_kwDOABII585d8hIY",
      "diff_hunk": "@@ -4432,7 +4586,9 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                     // protocol for getting all unconfirmed parents.\n                     const auto gtxid{GenTxid::Txid(parent_txid)};\n                     AddKnownTx(*peer, parent_txid);\n-                    if (!AlreadyHaveTx(gtxid, /*include_reconsiderable=*/true)) AddTxAnnouncement(pfrom, gtxid, current_time);\n+                    // Exclude m_recent_rejects_reconsiderable: the missing parent may have been\n+                    // previously rejected for being too low feerate. This orphan might CPFP it.\n+                    if (!AlreadyHaveTx(gtxid, /*include_reconsiderable=*/false)) AddTxAnnouncement(pfrom, gtxid, current_time);",
      "path": "src/net_processing.cpp",
      "position": 355,
      "original_position": 182,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "668313e00df9db815b392811bfc27dbb673ea9f9",
      "in_reply_to_id": 1575118464,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Good point, I don't think this is too complex so I've added it.\r\n\r\nWhile working on this, I remembered/realized that if there are any other unconfirmed parents at all, we will reject it because the package must be child-with-unconfirmed-parents, enforced here:\r\nhttps://github.com/bitcoin/bitcoin/blob/256e1703197fdddd78bc6d659431cd0fc3b63cde/src/validation.cpp#L1558-L1564\r\n\r\nIIRC this was the way to check that a package was \"2 generations only\". But I don't know how useful this is, and it's quite annoying here, so perhaps we should consider getting rid of this restriction in a followup... Then we can accept packages where the child has parents already in mempool.",
      "created_at": "2024-04-23T12:11:32Z",
      "updated_at": "2024-04-23T12:11:33Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1576145432",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1576145432"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 4617,
      "original_line": 4617,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1576164670",
      "pull_request_review_id": 2017100083,
      "id": 1576164670,
      "node_id": "PRRC_kwDOABII585d8l0-",
      "diff_hunk": "@@ -3195,6 +3210,140 @@ void PeerManagerImpl::ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, c\n     }\n }\n \n+void PeerManagerImpl::ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, const std::vector<NodeId>& senders)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    if (package_result.m_state.IsInvalid()) {\n+        m_recent_rejects_reconsiderable.insert(GetPackageHash(package));\n+    }\n+    // We currently only expect to process 1-parent-1-child packages. Remove if this changes.\n+    if (!Assume(package.size() == 2)) return;\n+\n+    // No package results to look through for PCKG_POLICY or PCKG_MEMPOOL_ERROR\n+    if (package_result.m_state.GetResult() == PackageValidationResult::PCKG_POLICY ||\n+        package_result.m_state.GetResult() == PackageValidationResult::PCKG_MEMPOOL_ERROR) return;\n+\n+    // Iterate backwards to erase in-package descendants from the orphanage before they become\n+    // relevant in AddChildrenToWorkSet.\n+    auto package_iter = package.rbegin();\n+    auto senders_iter = senders.rbegin();\n+    while (package_iter != package.rend()) {\n+        const auto& tx = *package_iter;\n+        const NodeId nodeid = *senders_iter;\n+        const auto it_result{package_result.m_tx_results.find(tx->GetWitnessHash())};\n+        if (Assume(it_result != package_result.m_tx_results.end())) {\n+            const auto& tx_result = it_result->second;\n+            switch (tx_result.m_result_type) {\n+                case MempoolAcceptResult::ResultType::VALID:\n+                {\n+                    Assume(tx_result.m_replaced_transactions.has_value());\n+                    std::list<CTransactionRef> empty_replacement_list;\n+                    ProcessValidTx(nodeid, tx, tx_result.m_replaced_transactions.value_or(empty_replacement_list));\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::INVALID:\n+                case MempoolAcceptResult::ResultType::DIFFERENT_WITNESS:\n+                {\n+                    // Don't add to vExtraTxnForCompact, as these transactions should have already been\n+                    // added there when added to the orphanage or rejected for TX_RECONSIDERABLE.\n+                    // This should be updated if package submission is ever used for transactions\n+                    // that haven't already been validated before.\n+                    ProcessInvalidTx(nodeid, tx, tx_result.m_state, /*maybe_add_extra_compact_tx=*/false);\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::MEMPOOL_ENTRY:\n+                {\n+                    // AlreadyHaveTx() should be catching transactions that are already in mempool.\n+                    Assume(false);\n+                    break;\n+                }\n+            }\n+        }\n+        package_iter++;\n+        // There should be a sender for each tx, but fall back to the last one otherwise.\n+        if (Assume(senders_iter != senders.rend())) senders_iter++;\n+    }\n+}\n+\n+void PeerManagerImpl::MaybeProcess1P1CPackage(const CTransactionRef& ptx, NodeId nodeid)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    const auto& parent_txid{ptx->GetHash()};\n+    const auto& parent_wtxid{ptx->GetWitnessHash()};\n+\n+    CTransactionRef tx_orphan{nullptr};\n+    NodeId orphan_sender{-1};\n+    Assume(m_recent_rejects_reconsiderable.contains(parent_wtxid.ToUint256()));\n+\n+    // Prefer children from this peer. This helps prevent censorship attempts in which an attacker\n+    // sends lots of fake children for the parent, and we (unluckily) keep selecting the fake\n+    // children instead of the real one provided by the honest peer.\n+    const auto cpfp_candidates_same_peer{m_orphanage.GetChildrenFromSamePeer(ptx, nodeid)};\n+\n+    // These children should be sorted from most newest to oldest. In the (probably uncommon) case\n+    // of children that replace each other, this helps us accept the highest feerate (probably the\n+    // most recent) one efficiently.\n+    for (const auto& child : cpfp_candidates_same_peer) {\n+        Package maybe_cpfp_package{ptx, child};\n+        if (!m_recent_rejects_reconsiderable.contains(GetPackageHash(maybe_cpfp_package))) {\n+            tx_orphan = child;\n+            orphan_sender = nodeid;\n+            break;\n+        }\n+    }\n+\n+    // If no suitable candidate from the same peer is found, also try children that were provided by\n+    // a different peer. This is useful because sometimes multiple peers announce both transactions\n+    // to us, and we happen to download them from different peers (we wouldn't have known that these\n+    // 2 transactions are related). We still want to find 1p1c packages then.\n+    //\n+    // If we start tracking all announcers of orphans, we can restrict this logic to parent + child\n+    // pairs in which both were provided by the same peer, i.e. delete this step.\n+    if (!tx_orphan) {\n+        const auto cpfp_candidates_different_peer{m_orphanage.GetChildrenFromDifferentPeer(ptx, nodeid)};\n+\n+        // Find the first 1p1c that hasn't already been rejected. We randomize the order to not\n+        // create a bias that attackers can use to delay package acceptance.\n+        //\n+        // Create a random permutation of the indices.\n+        std::vector<size_t> tx_indices(cpfp_candidates_different_peer.size());\n+        std::iota(tx_indices.begin(), tx_indices.end(), 0);\n+        Shuffle(tx_indices.begin(), tx_indices.end(), m_rng);\n+\n+        for (const auto index : tx_indices) {\n+            // If we already tried a package and failed for any reason, the combined hash was\n+            // cached in m_recent_rejects_reconsiderable.\n+            Package maybe_cpfp_package{ptx, cpfp_candidates_different_peer.at(index).first};\n+            if (!m_recent_rejects_reconsiderable.contains(GetPackageHash(maybe_cpfp_package))) {\n+                tx_orphan = cpfp_candidates_different_peer.at(index).first;\n+                orphan_sender = cpfp_candidates_different_peer.at(index).second;\n+                break;\n+            }\n+        }\n+    }\n+\n+    if (tx_orphan) {\n+        const Package package_1p1c{ptx, tx_orphan};\n+        const std::vector<NodeId> senders{nodeid, orphan_sender};\n+        const auto package_result{ProcessNewPackage(m_chainman.ActiveChainstate(), m_mempool, package_1p1c, /*test_accept=*/false, /*client_maxfeerate=*/std::nullopt)};\n+        LogDebug(BCLog::TXPACKAGES, \"package evaluation for parent %s (wtxid=%s) + child %s (wtxid=%s) in orphanage: %s\\n\",",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 148,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "bb3bf0a39c036fbd94b99ed7002db7d9bdf0a1d6",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "FWIW: I added logging here to see what number of parents and given by different peers than the orphan. After a day of running it's 0 out of 162. \r\n\r\nIs there a reason to think this should be a common pattern? ",
      "created_at": "2024-04-23T12:26:42Z",
      "updated_at": "2024-04-23T12:26:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1576164670",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1576164670"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3335,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1576171557",
      "pull_request_review_id": 2017111931,
      "id": 1576171557,
      "node_id": "PRRC_kwDOABII585d8ngl",
      "diff_hunk": "@@ -3195,6 +3210,140 @@ void PeerManagerImpl::ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, c\n     }\n }\n \n+void PeerManagerImpl::ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, const std::vector<NodeId>& senders)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    if (package_result.m_state.IsInvalid()) {\n+        m_recent_rejects_reconsiderable.insert(GetPackageHash(package));\n+    }\n+    // We currently only expect to process 1-parent-1-child packages. Remove if this changes.\n+    if (!Assume(package.size() == 2)) return;\n+\n+    // No package results to look through for PCKG_POLICY or PCKG_MEMPOOL_ERROR\n+    if (package_result.m_state.GetResult() == PackageValidationResult::PCKG_POLICY ||\n+        package_result.m_state.GetResult() == PackageValidationResult::PCKG_MEMPOOL_ERROR) return;\n+\n+    // Iterate backwards to erase in-package descendants from the orphanage before they become\n+    // relevant in AddChildrenToWorkSet.\n+    auto package_iter = package.rbegin();\n+    auto senders_iter = senders.rbegin();\n+    while (package_iter != package.rend()) {\n+        const auto& tx = *package_iter;\n+        const NodeId nodeid = *senders_iter;\n+        const auto it_result{package_result.m_tx_results.find(tx->GetWitnessHash())};\n+        if (Assume(it_result != package_result.m_tx_results.end())) {\n+            const auto& tx_result = it_result->second;\n+            switch (tx_result.m_result_type) {\n+                case MempoolAcceptResult::ResultType::VALID:\n+                {\n+                    Assume(tx_result.m_replaced_transactions.has_value());\n+                    std::list<CTransactionRef> empty_replacement_list;\n+                    ProcessValidTx(nodeid, tx, tx_result.m_replaced_transactions.value_or(empty_replacement_list));\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::INVALID:\n+                case MempoolAcceptResult::ResultType::DIFFERENT_WITNESS:\n+                {\n+                    // Don't add to vExtraTxnForCompact, as these transactions should have already been\n+                    // added there when added to the orphanage or rejected for TX_RECONSIDERABLE.\n+                    // This should be updated if package submission is ever used for transactions\n+                    // that haven't already been validated before.\n+                    ProcessInvalidTx(nodeid, tx, tx_result.m_state, /*maybe_add_extra_compact_tx=*/false);\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::MEMPOOL_ENTRY:\n+                {\n+                    // AlreadyHaveTx() should be catching transactions that are already in mempool.\n+                    Assume(false);\n+                    break;\n+                }\n+            }\n+        }\n+        package_iter++;\n+        // There should be a sender for each tx, but fall back to the last one otherwise.\n+        if (Assume(senders_iter != senders.rend())) senders_iter++;\n+    }\n+}\n+\n+void PeerManagerImpl::MaybeProcess1P1CPackage(const CTransactionRef& ptx, NodeId nodeid)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    const auto& parent_txid{ptx->GetHash()};\n+    const auto& parent_wtxid{ptx->GetWitnessHash()};\n+\n+    CTransactionRef tx_orphan{nullptr};\n+    NodeId orphan_sender{-1};\n+    Assume(m_recent_rejects_reconsiderable.contains(parent_wtxid.ToUint256()));\n+\n+    // Prefer children from this peer. This helps prevent censorship attempts in which an attacker\n+    // sends lots of fake children for the parent, and we (unluckily) keep selecting the fake\n+    // children instead of the real one provided by the honest peer.\n+    const auto cpfp_candidates_same_peer{m_orphanage.GetChildrenFromSamePeer(ptx, nodeid)};\n+\n+    // These children should be sorted from most newest to oldest. In the (probably uncommon) case\n+    // of children that replace each other, this helps us accept the highest feerate (probably the\n+    // most recent) one efficiently.\n+    for (const auto& child : cpfp_candidates_same_peer) {\n+        Package maybe_cpfp_package{ptx, child};\n+        if (!m_recent_rejects_reconsiderable.contains(GetPackageHash(maybe_cpfp_package))) {\n+            tx_orphan = child;\n+            orphan_sender = nodeid;\n+            break;\n+        }\n+    }\n+\n+    // If no suitable candidate from the same peer is found, also try children that were provided by\n+    // a different peer. This is useful because sometimes multiple peers announce both transactions\n+    // to us, and we happen to download them from different peers (we wouldn't have known that these\n+    // 2 transactions are related). We still want to find 1p1c packages then.\n+    //\n+    // If we start tracking all announcers of orphans, we can restrict this logic to parent + child\n+    // pairs in which both were provided by the same peer, i.e. delete this step.\n+    if (!tx_orphan) {\n+        const auto cpfp_candidates_different_peer{m_orphanage.GetChildrenFromDifferentPeer(ptx, nodeid)};\n+\n+        // Find the first 1p1c that hasn't already been rejected. We randomize the order to not\n+        // create a bias that attackers can use to delay package acceptance.\n+        //\n+        // Create a random permutation of the indices.\n+        std::vector<size_t> tx_indices(cpfp_candidates_different_peer.size());\n+        std::iota(tx_indices.begin(), tx_indices.end(), 0);\n+        Shuffle(tx_indices.begin(), tx_indices.end(), m_rng);\n+\n+        for (const auto index : tx_indices) {\n+            // If we already tried a package and failed for any reason, the combined hash was\n+            // cached in m_recent_rejects_reconsiderable.\n+            Package maybe_cpfp_package{ptx, cpfp_candidates_different_peer.at(index).first};\n+            if (!m_recent_rejects_reconsiderable.contains(GetPackageHash(maybe_cpfp_package))) {\n+                tx_orphan = cpfp_candidates_different_peer.at(index).first;\n+                orphan_sender = cpfp_candidates_different_peer.at(index).second;\n+                break;\n+            }\n+        }\n+    }\n+\n+    if (tx_orphan) {\n+        const Package package_1p1c{ptx, tx_orphan};\n+        const std::vector<NodeId> senders{nodeid, orphan_sender};\n+        const auto package_result{ProcessNewPackage(m_chainman.ActiveChainstate(), m_mempool, package_1p1c, /*test_accept=*/false, /*client_maxfeerate=*/std::nullopt)};\n+        LogDebug(BCLog::TXPACKAGES, \"package evaluation for parent %s (wtxid=%s) + child %s (wtxid=%s) in orphanage: %s\\n\",",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 148,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "bb3bf0a39c036fbd94b99ed7002db7d9bdf0a1d6",
      "in_reply_to_id": 1576164670,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "If a parent+child are relayed roughly simultaneously across the network, then I would expect there to be times when we download the transactions out of order (eg because we send a request for the parent to a different peer than the request for the child).",
      "created_at": "2024-04-23T12:31:50Z",
      "updated_at": "2024-04-23T12:32:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1576171557",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1576171557"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3335,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1576185766",
      "pull_request_review_id": 2017135526,
      "id": 1576185766,
      "node_id": "PRRC_kwDOABII585d8q-m",
      "diff_hunk": "@@ -3195,6 +3210,140 @@ void PeerManagerImpl::ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, c\n     }\n }\n \n+void PeerManagerImpl::ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, const std::vector<NodeId>& senders)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    if (package_result.m_state.IsInvalid()) {\n+        m_recent_rejects_reconsiderable.insert(GetPackageHash(package));\n+    }\n+    // We currently only expect to process 1-parent-1-child packages. Remove if this changes.\n+    if (!Assume(package.size() == 2)) return;\n+\n+    // No package results to look through for PCKG_POLICY or PCKG_MEMPOOL_ERROR\n+    if (package_result.m_state.GetResult() == PackageValidationResult::PCKG_POLICY ||\n+        package_result.m_state.GetResult() == PackageValidationResult::PCKG_MEMPOOL_ERROR) return;\n+\n+    // Iterate backwards to erase in-package descendants from the orphanage before they become\n+    // relevant in AddChildrenToWorkSet.\n+    auto package_iter = package.rbegin();\n+    auto senders_iter = senders.rbegin();\n+    while (package_iter != package.rend()) {\n+        const auto& tx = *package_iter;\n+        const NodeId nodeid = *senders_iter;\n+        const auto it_result{package_result.m_tx_results.find(tx->GetWitnessHash())};\n+        if (Assume(it_result != package_result.m_tx_results.end())) {\n+            const auto& tx_result = it_result->second;\n+            switch (tx_result.m_result_type) {\n+                case MempoolAcceptResult::ResultType::VALID:\n+                {\n+                    Assume(tx_result.m_replaced_transactions.has_value());\n+                    std::list<CTransactionRef> empty_replacement_list;\n+                    ProcessValidTx(nodeid, tx, tx_result.m_replaced_transactions.value_or(empty_replacement_list));\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::INVALID:\n+                case MempoolAcceptResult::ResultType::DIFFERENT_WITNESS:\n+                {\n+                    // Don't add to vExtraTxnForCompact, as these transactions should have already been\n+                    // added there when added to the orphanage or rejected for TX_RECONSIDERABLE.\n+                    // This should be updated if package submission is ever used for transactions\n+                    // that haven't already been validated before.\n+                    ProcessInvalidTx(nodeid, tx, tx_result.m_state, /*maybe_add_extra_compact_tx=*/false);\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::MEMPOOL_ENTRY:\n+                {\n+                    // AlreadyHaveTx() should be catching transactions that are already in mempool.\n+                    Assume(false);\n+                    break;\n+                }\n+            }\n+        }\n+        package_iter++;\n+        // There should be a sender for each tx, but fall back to the last one otherwise.\n+        if (Assume(senders_iter != senders.rend())) senders_iter++;\n+    }\n+}\n+\n+void PeerManagerImpl::MaybeProcess1P1CPackage(const CTransactionRef& ptx, NodeId nodeid)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    const auto& parent_txid{ptx->GetHash()};\n+    const auto& parent_wtxid{ptx->GetWitnessHash()};\n+\n+    CTransactionRef tx_orphan{nullptr};\n+    NodeId orphan_sender{-1};\n+    Assume(m_recent_rejects_reconsiderable.contains(parent_wtxid.ToUint256()));\n+\n+    // Prefer children from this peer. This helps prevent censorship attempts in which an attacker\n+    // sends lots of fake children for the parent, and we (unluckily) keep selecting the fake\n+    // children instead of the real one provided by the honest peer.\n+    const auto cpfp_candidates_same_peer{m_orphanage.GetChildrenFromSamePeer(ptx, nodeid)};\n+\n+    // These children should be sorted from most newest to oldest. In the (probably uncommon) case\n+    // of children that replace each other, this helps us accept the highest feerate (probably the\n+    // most recent) one efficiently.\n+    for (const auto& child : cpfp_candidates_same_peer) {\n+        Package maybe_cpfp_package{ptx, child};\n+        if (!m_recent_rejects_reconsiderable.contains(GetPackageHash(maybe_cpfp_package))) {\n+            tx_orphan = child;\n+            orphan_sender = nodeid;\n+            break;\n+        }\n+    }\n+\n+    // If no suitable candidate from the same peer is found, also try children that were provided by\n+    // a different peer. This is useful because sometimes multiple peers announce both transactions\n+    // to us, and we happen to download them from different peers (we wouldn't have known that these\n+    // 2 transactions are related). We still want to find 1p1c packages then.\n+    //\n+    // If we start tracking all announcers of orphans, we can restrict this logic to parent + child\n+    // pairs in which both were provided by the same peer, i.e. delete this step.\n+    if (!tx_orphan) {\n+        const auto cpfp_candidates_different_peer{m_orphanage.GetChildrenFromDifferentPeer(ptx, nodeid)};\n+\n+        // Find the first 1p1c that hasn't already been rejected. We randomize the order to not\n+        // create a bias that attackers can use to delay package acceptance.\n+        //\n+        // Create a random permutation of the indices.\n+        std::vector<size_t> tx_indices(cpfp_candidates_different_peer.size());\n+        std::iota(tx_indices.begin(), tx_indices.end(), 0);\n+        Shuffle(tx_indices.begin(), tx_indices.end(), m_rng);\n+\n+        for (const auto index : tx_indices) {\n+            // If we already tried a package and failed for any reason, the combined hash was\n+            // cached in m_recent_rejects_reconsiderable.\n+            Package maybe_cpfp_package{ptx, cpfp_candidates_different_peer.at(index).first};\n+            if (!m_recent_rejects_reconsiderable.contains(GetPackageHash(maybe_cpfp_package))) {\n+                tx_orphan = cpfp_candidates_different_peer.at(index).first;\n+                orphan_sender = cpfp_candidates_different_peer.at(index).second;\n+                break;\n+            }\n+        }\n+    }\n+\n+    if (tx_orphan) {\n+        const Package package_1p1c{ptx, tx_orphan};\n+        const std::vector<NodeId> senders{nodeid, orphan_sender};\n+        const auto package_result{ProcessNewPackage(m_chainman.ActiveChainstate(), m_mempool, package_1p1c, /*test_accept=*/false, /*client_maxfeerate=*/std::nullopt)};\n+        LogDebug(BCLog::TXPACKAGES, \"package evaluation for parent %s (wtxid=%s) + child %s (wtxid=%s) in orphanage: %s\\n\",",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 148,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "bb3bf0a39c036fbd94b99ed7002db7d9bdf0a1d6",
      "in_reply_to_id": 1576164670,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I guess it'll likely be something like:\r\n\r\n1) peer A sends child, child is put in orphanage and parent tx request queued(but not yet sent)\r\n2) peer B has slightly out of date feefilter for your node, sends INV for parent\r\n\r\nthough I'm not convinced this really will make a difference",
      "created_at": "2024-04-23T12:40:37Z",
      "updated_at": "2024-04-23T12:41:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1576185766",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1576185766"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3335,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1576208038",
      "pull_request_review_id": 2017171935,
      "id": 1576208038,
      "node_id": "PRRC_kwDOABII585d8wam",
      "diff_hunk": "@@ -3195,6 +3210,140 @@ void PeerManagerImpl::ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, c\n     }\n }\n \n+void PeerManagerImpl::ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, const std::vector<NodeId>& senders)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    if (package_result.m_state.IsInvalid()) {\n+        m_recent_rejects_reconsiderable.insert(GetPackageHash(package));\n+    }\n+    // We currently only expect to process 1-parent-1-child packages. Remove if this changes.\n+    if (!Assume(package.size() == 2)) return;\n+\n+    // No package results to look through for PCKG_POLICY or PCKG_MEMPOOL_ERROR\n+    if (package_result.m_state.GetResult() == PackageValidationResult::PCKG_POLICY ||\n+        package_result.m_state.GetResult() == PackageValidationResult::PCKG_MEMPOOL_ERROR) return;\n+\n+    // Iterate backwards to erase in-package descendants from the orphanage before they become\n+    // relevant in AddChildrenToWorkSet.\n+    auto package_iter = package.rbegin();\n+    auto senders_iter = senders.rbegin();\n+    while (package_iter != package.rend()) {\n+        const auto& tx = *package_iter;\n+        const NodeId nodeid = *senders_iter;\n+        const auto it_result{package_result.m_tx_results.find(tx->GetWitnessHash())};\n+        if (Assume(it_result != package_result.m_tx_results.end())) {\n+            const auto& tx_result = it_result->second;\n+            switch (tx_result.m_result_type) {\n+                case MempoolAcceptResult::ResultType::VALID:\n+                {\n+                    Assume(tx_result.m_replaced_transactions.has_value());\n+                    std::list<CTransactionRef> empty_replacement_list;\n+                    ProcessValidTx(nodeid, tx, tx_result.m_replaced_transactions.value_or(empty_replacement_list));\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::INVALID:\n+                case MempoolAcceptResult::ResultType::DIFFERENT_WITNESS:\n+                {\n+                    // Don't add to vExtraTxnForCompact, as these transactions should have already been\n+                    // added there when added to the orphanage or rejected for TX_RECONSIDERABLE.\n+                    // This should be updated if package submission is ever used for transactions\n+                    // that haven't already been validated before.\n+                    ProcessInvalidTx(nodeid, tx, tx_result.m_state, /*maybe_add_extra_compact_tx=*/false);\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::MEMPOOL_ENTRY:\n+                {\n+                    // AlreadyHaveTx() should be catching transactions that are already in mempool.\n+                    Assume(false);\n+                    break;\n+                }\n+            }\n+        }\n+        package_iter++;\n+        // There should be a sender for each tx, but fall back to the last one otherwise.\n+        if (Assume(senders_iter != senders.rend())) senders_iter++;\n+    }\n+}\n+\n+void PeerManagerImpl::MaybeProcess1P1CPackage(const CTransactionRef& ptx, NodeId nodeid)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    const auto& parent_txid{ptx->GetHash()};\n+    const auto& parent_wtxid{ptx->GetWitnessHash()};\n+\n+    CTransactionRef tx_orphan{nullptr};\n+    NodeId orphan_sender{-1};\n+    Assume(m_recent_rejects_reconsiderable.contains(parent_wtxid.ToUint256()));\n+\n+    // Prefer children from this peer. This helps prevent censorship attempts in which an attacker\n+    // sends lots of fake children for the parent, and we (unluckily) keep selecting the fake\n+    // children instead of the real one provided by the honest peer.\n+    const auto cpfp_candidates_same_peer{m_orphanage.GetChildrenFromSamePeer(ptx, nodeid)};\n+\n+    // These children should be sorted from most newest to oldest. In the (probably uncommon) case\n+    // of children that replace each other, this helps us accept the highest feerate (probably the\n+    // most recent) one efficiently.\n+    for (const auto& child : cpfp_candidates_same_peer) {\n+        Package maybe_cpfp_package{ptx, child};\n+        if (!m_recent_rejects_reconsiderable.contains(GetPackageHash(maybe_cpfp_package))) {\n+            tx_orphan = child;\n+            orphan_sender = nodeid;\n+            break;\n+        }\n+    }\n+\n+    // If no suitable candidate from the same peer is found, also try children that were provided by\n+    // a different peer. This is useful because sometimes multiple peers announce both transactions\n+    // to us, and we happen to download them from different peers (we wouldn't have known that these\n+    // 2 transactions are related). We still want to find 1p1c packages then.\n+    //\n+    // If we start tracking all announcers of orphans, we can restrict this logic to parent + child\n+    // pairs in which both were provided by the same peer, i.e. delete this step.\n+    if (!tx_orphan) {\n+        const auto cpfp_candidates_different_peer{m_orphanage.GetChildrenFromDifferentPeer(ptx, nodeid)};\n+\n+        // Find the first 1p1c that hasn't already been rejected. We randomize the order to not\n+        // create a bias that attackers can use to delay package acceptance.\n+        //\n+        // Create a random permutation of the indices.\n+        std::vector<size_t> tx_indices(cpfp_candidates_different_peer.size());\n+        std::iota(tx_indices.begin(), tx_indices.end(), 0);\n+        Shuffle(tx_indices.begin(), tx_indices.end(), m_rng);\n+\n+        for (const auto index : tx_indices) {\n+            // If we already tried a package and failed for any reason, the combined hash was\n+            // cached in m_recent_rejects_reconsiderable.\n+            Package maybe_cpfp_package{ptx, cpfp_candidates_different_peer.at(index).first};\n+            if (!m_recent_rejects_reconsiderable.contains(GetPackageHash(maybe_cpfp_package))) {\n+                tx_orphan = cpfp_candidates_different_peer.at(index).first;\n+                orphan_sender = cpfp_candidates_different_peer.at(index).second;\n+                break;\n+            }\n+        }\n+    }\n+\n+    if (tx_orphan) {\n+        const Package package_1p1c{ptx, tx_orphan};\n+        const std::vector<NodeId> senders{nodeid, orphan_sender};\n+        const auto package_result{ProcessNewPackage(m_chainman.ActiveChainstate(), m_mempool, package_1p1c, /*test_accept=*/false, /*client_maxfeerate=*/std::nullopt)};\n+        LogDebug(BCLog::TXPACKAGES, \"package evaluation for parent %s (wtxid=%s) + child %s (wtxid=%s) in orphanage: %s\\n\",",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 148,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "bb3bf0a39c036fbd94b99ed7002db7d9bdf0a1d6",
      "in_reply_to_id": 1576164670,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "fwiw it's definitely not common, but I do see them occasionally and have a handful of acceptances of packages from 2 different peers",
      "created_at": "2024-04-23T12:55:59Z",
      "updated_at": "2024-04-23T12:55:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1576208038",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1576208038"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3335,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1576214320",
      "pull_request_review_id": 2017182417,
      "id": 1576214320,
      "node_id": "PRRC_kwDOABII585d8x8w",
      "diff_hunk": "@@ -3195,6 +3210,140 @@ void PeerManagerImpl::ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, c\n     }\n }\n \n+void PeerManagerImpl::ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, const std::vector<NodeId>& senders)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    if (package_result.m_state.IsInvalid()) {\n+        m_recent_rejects_reconsiderable.insert(GetPackageHash(package));\n+    }\n+    // We currently only expect to process 1-parent-1-child packages. Remove if this changes.\n+    if (!Assume(package.size() == 2)) return;\n+\n+    // No package results to look through for PCKG_POLICY or PCKG_MEMPOOL_ERROR\n+    if (package_result.m_state.GetResult() == PackageValidationResult::PCKG_POLICY ||\n+        package_result.m_state.GetResult() == PackageValidationResult::PCKG_MEMPOOL_ERROR) return;\n+\n+    // Iterate backwards to erase in-package descendants from the orphanage before they become\n+    // relevant in AddChildrenToWorkSet.\n+    auto package_iter = package.rbegin();\n+    auto senders_iter = senders.rbegin();\n+    while (package_iter != package.rend()) {\n+        const auto& tx = *package_iter;\n+        const NodeId nodeid = *senders_iter;\n+        const auto it_result{package_result.m_tx_results.find(tx->GetWitnessHash())};\n+        if (Assume(it_result != package_result.m_tx_results.end())) {\n+            const auto& tx_result = it_result->second;\n+            switch (tx_result.m_result_type) {\n+                case MempoolAcceptResult::ResultType::VALID:\n+                {\n+                    Assume(tx_result.m_replaced_transactions.has_value());\n+                    std::list<CTransactionRef> empty_replacement_list;\n+                    ProcessValidTx(nodeid, tx, tx_result.m_replaced_transactions.value_or(empty_replacement_list));\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::INVALID:\n+                case MempoolAcceptResult::ResultType::DIFFERENT_WITNESS:\n+                {\n+                    // Don't add to vExtraTxnForCompact, as these transactions should have already been\n+                    // added there when added to the orphanage or rejected for TX_RECONSIDERABLE.\n+                    // This should be updated if package submission is ever used for transactions\n+                    // that haven't already been validated before.\n+                    ProcessInvalidTx(nodeid, tx, tx_result.m_state, /*maybe_add_extra_compact_tx=*/false);\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::MEMPOOL_ENTRY:\n+                {\n+                    // AlreadyHaveTx() should be catching transactions that are already in mempool.\n+                    Assume(false);\n+                    break;\n+                }\n+            }\n+        }\n+        package_iter++;\n+        // There should be a sender for each tx, but fall back to the last one otherwise.\n+        if (Assume(senders_iter != senders.rend())) senders_iter++;\n+    }\n+}\n+\n+void PeerManagerImpl::MaybeProcess1P1CPackage(const CTransactionRef& ptx, NodeId nodeid)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    const auto& parent_txid{ptx->GetHash()};\n+    const auto& parent_wtxid{ptx->GetWitnessHash()};\n+\n+    CTransactionRef tx_orphan{nullptr};\n+    NodeId orphan_sender{-1};\n+    Assume(m_recent_rejects_reconsiderable.contains(parent_wtxid.ToUint256()));\n+\n+    // Prefer children from this peer. This helps prevent censorship attempts in which an attacker\n+    // sends lots of fake children for the parent, and we (unluckily) keep selecting the fake\n+    // children instead of the real one provided by the honest peer.\n+    const auto cpfp_candidates_same_peer{m_orphanage.GetChildrenFromSamePeer(ptx, nodeid)};\n+\n+    // These children should be sorted from most newest to oldest. In the (probably uncommon) case\n+    // of children that replace each other, this helps us accept the highest feerate (probably the\n+    // most recent) one efficiently.\n+    for (const auto& child : cpfp_candidates_same_peer) {\n+        Package maybe_cpfp_package{ptx, child};\n+        if (!m_recent_rejects_reconsiderable.contains(GetPackageHash(maybe_cpfp_package))) {\n+            tx_orphan = child;\n+            orphan_sender = nodeid;\n+            break;\n+        }\n+    }\n+\n+    // If no suitable candidate from the same peer is found, also try children that were provided by\n+    // a different peer. This is useful because sometimes multiple peers announce both transactions\n+    // to us, and we happen to download them from different peers (we wouldn't have known that these\n+    // 2 transactions are related). We still want to find 1p1c packages then.\n+    //\n+    // If we start tracking all announcers of orphans, we can restrict this logic to parent + child\n+    // pairs in which both were provided by the same peer, i.e. delete this step.\n+    if (!tx_orphan) {\n+        const auto cpfp_candidates_different_peer{m_orphanage.GetChildrenFromDifferentPeer(ptx, nodeid)};\n+\n+        // Find the first 1p1c that hasn't already been rejected. We randomize the order to not\n+        // create a bias that attackers can use to delay package acceptance.\n+        //\n+        // Create a random permutation of the indices.\n+        std::vector<size_t> tx_indices(cpfp_candidates_different_peer.size());\n+        std::iota(tx_indices.begin(), tx_indices.end(), 0);\n+        Shuffle(tx_indices.begin(), tx_indices.end(), m_rng);\n+\n+        for (const auto index : tx_indices) {\n+            // If we already tried a package and failed for any reason, the combined hash was\n+            // cached in m_recent_rejects_reconsiderable.\n+            Package maybe_cpfp_package{ptx, cpfp_candidates_different_peer.at(index).first};\n+            if (!m_recent_rejects_reconsiderable.contains(GetPackageHash(maybe_cpfp_package))) {\n+                tx_orphan = cpfp_candidates_different_peer.at(index).first;\n+                orphan_sender = cpfp_candidates_different_peer.at(index).second;\n+                break;\n+            }\n+        }\n+    }\n+\n+    if (tx_orphan) {\n+        const Package package_1p1c{ptx, tx_orphan};\n+        const std::vector<NodeId> senders{nodeid, orphan_sender};\n+        const auto package_result{ProcessNewPackage(m_chainman.ActiveChainstate(), m_mempool, package_1p1c, /*test_accept=*/false, /*client_maxfeerate=*/std::nullopt)};\n+        LogDebug(BCLog::TXPACKAGES, \"package evaluation for parent %s (wtxid=%s) + child %s (wtxid=%s) in orphanage: %s\\n\",",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 148,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "bb3bf0a39c036fbd94b99ed7002db7d9bdf0a1d6",
      "in_reply_to_id": 1576164670,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> though I'm not convinced this really will make a difference\r\n\r\nIs the suggestion to drop this and only try same-peer packages?",
      "created_at": "2024-04-23T13:00:19Z",
      "updated_at": "2024-04-23T13:00:48Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1576214320",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1576214320"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3335,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1576220246",
      "pull_request_review_id": 2017192534,
      "id": 1576220246,
      "node_id": "PRRC_kwDOABII585d8zZW",
      "diff_hunk": "@@ -3195,6 +3210,140 @@ void PeerManagerImpl::ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, c\n     }\n }\n \n+void PeerManagerImpl::ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, const std::vector<NodeId>& senders)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    if (package_result.m_state.IsInvalid()) {\n+        m_recent_rejects_reconsiderable.insert(GetPackageHash(package));\n+    }\n+    // We currently only expect to process 1-parent-1-child packages. Remove if this changes.\n+    if (!Assume(package.size() == 2)) return;\n+\n+    // No package results to look through for PCKG_POLICY or PCKG_MEMPOOL_ERROR\n+    if (package_result.m_state.GetResult() == PackageValidationResult::PCKG_POLICY ||\n+        package_result.m_state.GetResult() == PackageValidationResult::PCKG_MEMPOOL_ERROR) return;\n+\n+    // Iterate backwards to erase in-package descendants from the orphanage before they become\n+    // relevant in AddChildrenToWorkSet.\n+    auto package_iter = package.rbegin();\n+    auto senders_iter = senders.rbegin();\n+    while (package_iter != package.rend()) {\n+        const auto& tx = *package_iter;\n+        const NodeId nodeid = *senders_iter;\n+        const auto it_result{package_result.m_tx_results.find(tx->GetWitnessHash())};\n+        if (Assume(it_result != package_result.m_tx_results.end())) {\n+            const auto& tx_result = it_result->second;\n+            switch (tx_result.m_result_type) {\n+                case MempoolAcceptResult::ResultType::VALID:\n+                {\n+                    Assume(tx_result.m_replaced_transactions.has_value());\n+                    std::list<CTransactionRef> empty_replacement_list;\n+                    ProcessValidTx(nodeid, tx, tx_result.m_replaced_transactions.value_or(empty_replacement_list));\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::INVALID:\n+                case MempoolAcceptResult::ResultType::DIFFERENT_WITNESS:\n+                {\n+                    // Don't add to vExtraTxnForCompact, as these transactions should have already been\n+                    // added there when added to the orphanage or rejected for TX_RECONSIDERABLE.\n+                    // This should be updated if package submission is ever used for transactions\n+                    // that haven't already been validated before.\n+                    ProcessInvalidTx(nodeid, tx, tx_result.m_state, /*maybe_add_extra_compact_tx=*/false);\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::MEMPOOL_ENTRY:\n+                {\n+                    // AlreadyHaveTx() should be catching transactions that are already in mempool.\n+                    Assume(false);\n+                    break;\n+                }\n+            }\n+        }\n+        package_iter++;\n+        // There should be a sender for each tx, but fall back to the last one otherwise.\n+        if (Assume(senders_iter != senders.rend())) senders_iter++;\n+    }\n+}\n+\n+void PeerManagerImpl::MaybeProcess1P1CPackage(const CTransactionRef& ptx, NodeId nodeid)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    const auto& parent_txid{ptx->GetHash()};\n+    const auto& parent_wtxid{ptx->GetWitnessHash()};\n+\n+    CTransactionRef tx_orphan{nullptr};\n+    NodeId orphan_sender{-1};\n+    Assume(m_recent_rejects_reconsiderable.contains(parent_wtxid.ToUint256()));\n+\n+    // Prefer children from this peer. This helps prevent censorship attempts in which an attacker\n+    // sends lots of fake children for the parent, and we (unluckily) keep selecting the fake\n+    // children instead of the real one provided by the honest peer.\n+    const auto cpfp_candidates_same_peer{m_orphanage.GetChildrenFromSamePeer(ptx, nodeid)};\n+\n+    // These children should be sorted from most newest to oldest. In the (probably uncommon) case\n+    // of children that replace each other, this helps us accept the highest feerate (probably the\n+    // most recent) one efficiently.\n+    for (const auto& child : cpfp_candidates_same_peer) {\n+        Package maybe_cpfp_package{ptx, child};\n+        if (!m_recent_rejects_reconsiderable.contains(GetPackageHash(maybe_cpfp_package))) {\n+            tx_orphan = child;\n+            orphan_sender = nodeid;\n+            break;\n+        }\n+    }\n+\n+    // If no suitable candidate from the same peer is found, also try children that were provided by\n+    // a different peer. This is useful because sometimes multiple peers announce both transactions\n+    // to us, and we happen to download them from different peers (we wouldn't have known that these\n+    // 2 transactions are related). We still want to find 1p1c packages then.\n+    //\n+    // If we start tracking all announcers of orphans, we can restrict this logic to parent + child\n+    // pairs in which both were provided by the same peer, i.e. delete this step.\n+    if (!tx_orphan) {\n+        const auto cpfp_candidates_different_peer{m_orphanage.GetChildrenFromDifferentPeer(ptx, nodeid)};\n+\n+        // Find the first 1p1c that hasn't already been rejected. We randomize the order to not\n+        // create a bias that attackers can use to delay package acceptance.\n+        //\n+        // Create a random permutation of the indices.\n+        std::vector<size_t> tx_indices(cpfp_candidates_different_peer.size());\n+        std::iota(tx_indices.begin(), tx_indices.end(), 0);\n+        Shuffle(tx_indices.begin(), tx_indices.end(), m_rng);\n+\n+        for (const auto index : tx_indices) {\n+            // If we already tried a package and failed for any reason, the combined hash was\n+            // cached in m_recent_rejects_reconsiderable.\n+            Package maybe_cpfp_package{ptx, cpfp_candidates_different_peer.at(index).first};\n+            if (!m_recent_rejects_reconsiderable.contains(GetPackageHash(maybe_cpfp_package))) {\n+                tx_orphan = cpfp_candidates_different_peer.at(index).first;\n+                orphan_sender = cpfp_candidates_different_peer.at(index).second;\n+                break;\n+            }\n+        }\n+    }\n+\n+    if (tx_orphan) {\n+        const Package package_1p1c{ptx, tx_orphan};\n+        const std::vector<NodeId> senders{nodeid, orphan_sender};\n+        const auto package_result{ProcessNewPackage(m_chainman.ActiveChainstate(), m_mempool, package_1p1c, /*test_accept=*/false, /*client_maxfeerate=*/std::nullopt)};\n+        LogDebug(BCLog::TXPACKAGES, \"package evaluation for parent %s (wtxid=%s) + child %s (wtxid=%s) in orphanage: %s\\n\",",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 148,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "bb3bf0a39c036fbd94b99ed7002db7d9bdf0a1d6",
      "in_reply_to_id": 1576164670,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> I guess it'll likely be something like:\r\n> \r\n> 1. peer A sends child, child is put in orphanage and parent tx request queued(but not yet sent)\r\n> 2. peer B has slightly out of date feefilter for your node, sends INV for parent\r\n\r\nWhat I'd expect to happen is that we get inv's for parent+child from both Peer A and Peer B, and we happen to request the parent from A and the child from B, but the child arrives first -- it's put in the orphanage, and since a request for the parent is already in flight to A, we don't send another request for the parent to B.\r\n\r\n(In this scenario I guess I'm assuming no feefilter, or that the feefilter value is slightly stale.)\r\n",
      "created_at": "2024-04-23T13:04:12Z",
      "updated_at": "2024-04-23T13:04:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1576220246",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1576220246"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3335,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1576261445",
      "pull_request_review_id": 2017269003,
      "id": 1576261445,
      "node_id": "PRRC_kwDOABII585d89dF",
      "diff_hunk": "@@ -3195,6 +3210,140 @@ void PeerManagerImpl::ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, c\n     }\n }\n \n+void PeerManagerImpl::ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, const std::vector<NodeId>& senders)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    if (package_result.m_state.IsInvalid()) {\n+        m_recent_rejects_reconsiderable.insert(GetPackageHash(package));\n+    }\n+    // We currently only expect to process 1-parent-1-child packages. Remove if this changes.\n+    if (!Assume(package.size() == 2)) return;\n+\n+    // No package results to look through for PCKG_POLICY or PCKG_MEMPOOL_ERROR\n+    if (package_result.m_state.GetResult() == PackageValidationResult::PCKG_POLICY ||\n+        package_result.m_state.GetResult() == PackageValidationResult::PCKG_MEMPOOL_ERROR) return;\n+\n+    // Iterate backwards to erase in-package descendants from the orphanage before they become\n+    // relevant in AddChildrenToWorkSet.\n+    auto package_iter = package.rbegin();\n+    auto senders_iter = senders.rbegin();\n+    while (package_iter != package.rend()) {\n+        const auto& tx = *package_iter;\n+        const NodeId nodeid = *senders_iter;\n+        const auto it_result{package_result.m_tx_results.find(tx->GetWitnessHash())};\n+        if (Assume(it_result != package_result.m_tx_results.end())) {\n+            const auto& tx_result = it_result->second;\n+            switch (tx_result.m_result_type) {\n+                case MempoolAcceptResult::ResultType::VALID:\n+                {\n+                    Assume(tx_result.m_replaced_transactions.has_value());\n+                    std::list<CTransactionRef> empty_replacement_list;\n+                    ProcessValidTx(nodeid, tx, tx_result.m_replaced_transactions.value_or(empty_replacement_list));\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::INVALID:\n+                case MempoolAcceptResult::ResultType::DIFFERENT_WITNESS:\n+                {\n+                    // Don't add to vExtraTxnForCompact, as these transactions should have already been\n+                    // added there when added to the orphanage or rejected for TX_RECONSIDERABLE.\n+                    // This should be updated if package submission is ever used for transactions\n+                    // that haven't already been validated before.\n+                    ProcessInvalidTx(nodeid, tx, tx_result.m_state, /*maybe_add_extra_compact_tx=*/false);\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::MEMPOOL_ENTRY:\n+                {\n+                    // AlreadyHaveTx() should be catching transactions that are already in mempool.\n+                    Assume(false);\n+                    break;\n+                }\n+            }\n+        }\n+        package_iter++;\n+        // There should be a sender for each tx, but fall back to the last one otherwise.\n+        if (Assume(senders_iter != senders.rend())) senders_iter++;\n+    }\n+}\n+\n+void PeerManagerImpl::MaybeProcess1P1CPackage(const CTransactionRef& ptx, NodeId nodeid)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    const auto& parent_txid{ptx->GetHash()};\n+    const auto& parent_wtxid{ptx->GetWitnessHash()};\n+\n+    CTransactionRef tx_orphan{nullptr};\n+    NodeId orphan_sender{-1};\n+    Assume(m_recent_rejects_reconsiderable.contains(parent_wtxid.ToUint256()));\n+\n+    // Prefer children from this peer. This helps prevent censorship attempts in which an attacker\n+    // sends lots of fake children for the parent, and we (unluckily) keep selecting the fake\n+    // children instead of the real one provided by the honest peer.\n+    const auto cpfp_candidates_same_peer{m_orphanage.GetChildrenFromSamePeer(ptx, nodeid)};\n+\n+    // These children should be sorted from most newest to oldest. In the (probably uncommon) case\n+    // of children that replace each other, this helps us accept the highest feerate (probably the\n+    // most recent) one efficiently.\n+    for (const auto& child : cpfp_candidates_same_peer) {\n+        Package maybe_cpfp_package{ptx, child};\n+        if (!m_recent_rejects_reconsiderable.contains(GetPackageHash(maybe_cpfp_package))) {\n+            tx_orphan = child;\n+            orphan_sender = nodeid;\n+            break;\n+        }\n+    }\n+\n+    // If no suitable candidate from the same peer is found, also try children that were provided by\n+    // a different peer. This is useful because sometimes multiple peers announce both transactions\n+    // to us, and we happen to download them from different peers (we wouldn't have known that these\n+    // 2 transactions are related). We still want to find 1p1c packages then.\n+    //\n+    // If we start tracking all announcers of orphans, we can restrict this logic to parent + child\n+    // pairs in which both were provided by the same peer, i.e. delete this step.\n+    if (!tx_orphan) {\n+        const auto cpfp_candidates_different_peer{m_orphanage.GetChildrenFromDifferentPeer(ptx, nodeid)};\n+\n+        // Find the first 1p1c that hasn't already been rejected. We randomize the order to not\n+        // create a bias that attackers can use to delay package acceptance.\n+        //\n+        // Create a random permutation of the indices.\n+        std::vector<size_t> tx_indices(cpfp_candidates_different_peer.size());\n+        std::iota(tx_indices.begin(), tx_indices.end(), 0);\n+        Shuffle(tx_indices.begin(), tx_indices.end(), m_rng);\n+\n+        for (const auto index : tx_indices) {\n+            // If we already tried a package and failed for any reason, the combined hash was\n+            // cached in m_recent_rejects_reconsiderable.\n+            Package maybe_cpfp_package{ptx, cpfp_candidates_different_peer.at(index).first};\n+            if (!m_recent_rejects_reconsiderable.contains(GetPackageHash(maybe_cpfp_package))) {\n+                tx_orphan = cpfp_candidates_different_peer.at(index).first;\n+                orphan_sender = cpfp_candidates_different_peer.at(index).second;\n+                break;\n+            }\n+        }\n+    }\n+\n+    if (tx_orphan) {\n+        const Package package_1p1c{ptx, tx_orphan};\n+        const std::vector<NodeId> senders{nodeid, orphan_sender};\n+        const auto package_result{ProcessNewPackage(m_chainman.ActiveChainstate(), m_mempool, package_1p1c, /*test_accept=*/false, /*client_maxfeerate=*/std::nullopt)};\n+        LogDebug(BCLog::TXPACKAGES, \"package evaluation for parent %s (wtxid=%s) + child %s (wtxid=%s) in orphanage: %s\\n\",",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 148,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "bb3bf0a39c036fbd94b99ed7002db7d9bdf0a1d6",
      "in_reply_to_id": 1576164670,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> Is the suggestion to drop this and only try same-peer packages?\r\n\r\nIf this is hitting actual usage, no, because it's coded and I actually reviewed it, and tests seem to cover it. I'm unsure if in BIP331-like world it would be used since it would be receiver-driven, but that might be thinking too far ahead.\r\n\r\n> (In this scenario I guess I'm assuming no feefilter, or that the feefilter value is slightly stale.)\r\n\r\nLatter scenario seems likely in practice as I see things right on the bubble all the time.",
      "created_at": "2024-04-23T13:25:54Z",
      "updated_at": "2024-04-23T13:26:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1576261445",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1576261445"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3335,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1576365857",
      "pull_request_review_id": 2017442665,
      "id": 1576365857,
      "node_id": "PRRC_kwDOABII585d9W8h",
      "diff_hunk": "@@ -0,0 +1,348 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test opportunistic 1p1c package submission logic.\n+\"\"\"\n+\n+from decimal import Decimal\n+import time\n+from test_framework.messages import (\n+    CInv,\n+    CTxInWitness,\n+    MSG_WTX,\n+    msg_inv,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    fill_mempool,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+\n+def cleanup(func):\n+    def wrapper(self, *args, **kwargs):\n+        try:\n+            func(self, *args, **kwargs)\n+        finally:\n+            self.nodes[0].disconnect_p2ps()\n+            # Do not clear the node's mempool, as each test requires mempool min feerate > min\n+            # relay feerate. However, do check that this is the case.\n+            assert self.nodes[0].getmempoolinfo()[\"mempoolminfee\"] > self.nodes[0].getnetworkinfo()[\"relayfee\"]\n+            # Ensure we do not try to spend the same UTXOs in subsequent tests, as they will look like RBF attempts.\n+            self.wallet.rescan_utxos(include_mempool=True)\n+    return wrapper\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+        ]]\n+        self.supports_cli = False\n+\n+    @cleanup\n+    def test_basic_child_then_parent(self):\n+        node = self.nodes[0]\n+        self.log.info(\"Check that opportunistic 1p1c logic works when child is received before parent\")\n+\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first (perhaps the low feerate parent didn't meet feefilter or the requests were sent to different nodes). It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. Sender relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 4. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+        node.disconnect_p2ps()\n+\n+    @cleanup\n+    def test_basic_parent_then_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=1, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=2, connection_type=\"outbound-full-relay\")\n+\n+        # 1. Parent is relayed first. It is too low feerate.\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer_sender.wait_for_getdata([parent_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer_ignored, check that it is ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+\n+        # 2. Child is relayed next. It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 3. Node requests the missing parent by txid.\n+        # It should do so even if it has previously rejected that parent for being too low feerate.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 4. Sender re-relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 5. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+    @cleanup\n+    def test_low_and_high_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        # This feerate is above mempoolminfee, but not enough to also bump the low feerate parent.\n+        feerate_just_above = node.getmempoolinfo()[\"mempoolminfee\"]\n+        med_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=feerate_just_above)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=3, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=4, connection_type=\"outbound-full-relay\")\n+\n+        self.log.info(\"Check that tx caches low fee parent + low fee child package rejections\")\n+\n+        # 1. Send parent, rejected for being low feerate.\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer_sender.wait_for_getdata([parent_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer_ignored, check that it is ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+\n+        # 2. Send an (orphan) child that has a higher feerate, but not enough to bump the parent.\n+        low_child_wtxid_int = int(med_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([low_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(med_fee_child[\"tx\"]))\n+\n+        # 3. Node requests the orphan's missing parent.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 4. The low parent + low child are submitted as a package. They are not accepted due to low package feerate.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+        assert med_fee_child[\"txid\"] not in node.getrawmempool()\n+\n+        # If peer_ignored announces the low feerate child, it should be ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+        # If either peer sends the parent again, package evaluation should not be attempted\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        peer_ignored.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 5. Send the high feerate (orphan) child\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 6. Node requests the orphan's parent, even though it has already been rejected, both by\n+        # itself and with a child. This is necessary, otherwise high_fee_child can be censored.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 7. The low feerate parent + high feerate child are submitted as a package.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 8. Both transactions should now be in mempool\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+    @cleanup\n+    def test_orphan_consensus_failure(self):\n+        self.log.info(\"Check opportunistic 1p1c logic with consensus-invalid orphan causes disconnect of the correct peer\")\n+        node = self.nodes[0]\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        coin = low_fee_parent[\"new_utxo\"]\n+        address = node.get_deterministic_priv_key().address\n+        # Create raw transaction spending the parent, but with no signature (a consensus error).\n+        hex_orphan_no_sig = node.createrawtransaction([{\"txid\": coin[\"txid\"], \"vout\": coin[\"vout\"]}], {address : coin[\"value\"] - Decimal(\"0.0001\")})\n+        tx_orphan_bad_wit = tx_from_hex(hex_orphan_no_sig)\n+        tx_orphan_bad_wit.wit.vtxinwit.append(CTxInWitness())\n+        tx_orphan_bad_wit.wit.vtxinwit[0].scriptWitness.stack = [b'garbage']\n+\n+        bad_orphan_sender = node.add_p2p_connection(P2PInterface())\n+        parent_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first. It is missing an input.\n+        child_wtxid_int = int(tx_orphan_bad_wit.getwtxid(), 16)\n+        bad_orphan_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=child_wtxid_int)]))\n+        bad_orphan_sender.wait_for_getdata([child_wtxid_int])\n+        bad_orphan_sender.send_and_ping(msg_tx(tx_orphan_bad_wit))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        bad_orphan_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. A different peer relays the parent. Parent+Child are evaluated as a package and rejected.\n+        parent_sender.send_message(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 4. Transactions should not be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] not in node_mempool\n+        assert tx_orphan_bad_wit.rehash() not in node_mempool\n+\n+        # 5. Peer that sent a consensus-invalid transaction should be disconnected.\n+        bad_orphan_sender.wait_for_disconnect()\n+\n+        # The peer that didn't provide the orphan should not be disconnected.\n+        parent_sender.sync_with_ping()\n+\n+    @cleanup\n+    def test_parent_consensus_failure(self):\n+        self.log.info(\"Check opportunistic 1p1c logic with consensus-invalid parent causes disconnect of the correct peer\")\n+        node = self.nodes[0]\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+\n+        # Create invalid version of parent with a bad signature.\n+        tx_parent_bad_wit = tx_from_hex(low_fee_parent[\"hex\"])\n+        tx_parent_bad_wit.wit.vtxinwit.append(CTxInWitness())\n+        tx_parent_bad_wit.wit.vtxinwit[0].scriptWitness.stack = [b'garbage']\n+\n+        package_sender = node.add_p2p_connection(P2PInterface())\n+        fake_parent_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first. It is missing an input.\n+        child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        package_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=child_wtxid_int)]))\n+        package_sender.wait_for_getdata([child_wtxid_int])\n+        package_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(tx_parent_bad_wit.rehash(), 16)\n+        package_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. A different node relays the parent. The parent is first evaluated by itself and\n+        # rejected for being too low feerate. Then it is evaluated as a package and, after passing\n+        # feerate checks, rejected for having a bad signature (consensus error).\n+        fake_parent_sender.send_message(msg_tx(tx_parent_bad_wit))\n+\n+        # 4. Transactions should not be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert tx_parent_bad_wit.rehash() not in node_mempool\n+        assert high_fee_child[\"txid\"] not in node_mempool\n+\n+        # 5. Peer sent a consensus-invalid transaction.\n+        fake_parent_sender.wait_for_disconnect()\n+\n+        self.log.info(\"Check that fake parent does not cause orphan to be deleted and real package can still be submitted\")\n+        # 6. Child-sending should not have been punished and the orphan should remain in orphanage.\n+        # It can send the \"real\" parent transaction, and the package is accepted.\n+        package_sender.sync_with_ping()\n+        package_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+    @cleanup\n+    def test_multiple_parents(self):\n+        self.log.info(\"Check that node does not request more than 1 previously-rejected low feerate parent\")\n+\n+        node = self.nodes[0]\n+        node.setmocktime(int(time.time()))\n+\n+        # 2-parent-1-child package where both parents are below mempool min feerate\n+        parent_low_1 = self.wallet_nonsegwit.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        parent_low_2 = self.wallet_nonsegwit.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        child_bumping = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[parent_low_1[\"new_utxo\"], parent_low_2[\"new_utxo\"]],\n+            fee_per_output=999*parent_low_1[\"tx\"].get_vsize(),\n+        )\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=4, connection_type=\"outbound-full-relay\")\n+\n+        # 1. Send both parents. Each should be rejected for being too low feerate.\n+        # Send unsolicited so that we can later check that no \"getdata\" was ever received.\n+        peer_sender.send_and_ping(msg_tx(parent_low_1[\"tx\"]))\n+        peer_sender.send_and_ping(msg_tx(parent_low_2[\"tx\"]))\n+\n+        # parent_low_1 and parent_low_2 are rejected for being low feerate.\n+        assert parent_low_1[\"txid\"] not in node.getrawmempool()\n+        assert parent_low_2[\"txid\"] not in node.getrawmempool()\n+\n+        # 2. Send child.\n+        peer_sender.send_and_ping(msg_tx(child_bumping[\"tx\"]))\n+\n+        # 3. Node should not request any parents, as it should recognize that it will not accept\n+        # multi-parent-1-child packages.\n+        node.bumpmocktime(60)",
      "path": "test/functional/p2p_opportunistic_1p1c.py",
      "position": null,
      "original_position": 312,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "55b1280c52af81aa6ea0860799fa16da49f51447",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "is there a constant we can put here?",
      "created_at": "2024-04-23T14:29:29Z",
      "updated_at": "2024-04-23T16:33:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1576365857",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1576365857"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 312,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1576401327",
      "pull_request_review_id": 2015631578,
      "id": 1576401327,
      "node_id": "PRRC_kwDOABII585d9fmv",
      "diff_hunk": "",
      "path": "src/test/fuzz/txorphan.cpp",
      "position": 1,
      "original_position": 1,
      "commit_id": "55b1280c52af81aa6ea0860799fa16da49f51447",
      "original_commit_id": "55b1280c52af81aa6ea0860799fa16da49f51447",
      "in_reply_to_id": null,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Reviewing the changes in this file I realized something seems to be odd with the way the test was initially designed:\r\n\r\n`duplicate_input` is defined as a flag that, if set, will allow duplicate inputs to be used when building the transaction. However, the way this is approached is weird: if `duplicate_input` is not set, upon picking prevout as input, we will kick it off `outpoints` to make sure we don’t pick it up again as another input. Later on, all selected inputs are added back to outpoints, so they can be used again in the next iteration. However, this is done unconditionally, therefore, if `duplicate_input` is set, we will end up adding the same element to the collection twice (given we would not have kicked it off).\r\n\r\nHence, the more an input is picked, the more copies of that element will end up added to the collection, and the more likely that input will be picked. `PickValue` is already picking things randomly (AFAICT), so there is no need to have duplicates in the collection.",
      "created_at": "2024-04-23T14:50:23Z",
      "updated_at": "2024-04-25T13:25:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1576401327",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1576401327"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1,
      "original_line": 1,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1576405239",
      "pull_request_review_id": 2015631578,
      "id": 1576405239,
      "node_id": "PRRC_kwDOABII585d9gj3",
      "diff_hunk": "",
      "path": "src/test/fuzz/txorphan.cpp",
      "position": 1,
      "original_position": 1,
      "commit_id": "55b1280c52af81aa6ea0860799fa16da49f51447",
      "original_commit_id": "55b1280c52af81aa6ea0860799fa16da49f51447",
      "in_reply_to_id": 1576401327,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I also found the way `num_out` is picked to be a bit strange. `num_in` is picked based on the `outpoints` size, given that is our input candidate set. However, `num_out` is picked in the same way, and it doesn't really need to be bound by that, just by making sure the transaction stays within its size limits",
      "created_at": "2024-04-23T14:52:46Z",
      "updated_at": "2024-04-25T13:25:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1576405239",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1576405239"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1,
      "original_line": 1,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1576405884",
      "pull_request_review_id": 2015631578,
      "id": 1576405884,
      "node_id": "PRRC_kwDOABII585d9gt8",
      "diff_hunk": "",
      "path": "src/test/fuzz/txorphan.cpp",
      "position": 1,
      "original_position": 1,
      "commit_id": "55b1280c52af81aa6ea0860799fa16da49f51447",
      "original_commit_id": "55b1280c52af81aa6ea0860799fa16da49f51447",
      "in_reply_to_id": 1576401327,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I don't think this needs to be fixed in this PR btw, a followup would do",
      "created_at": "2024-04-23T14:53:08Z",
      "updated_at": "2024-04-25T13:25:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1576405884",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1576405884"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1,
      "original_line": 1,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1576456061",
      "pull_request_review_id": 2015631578,
      "id": 1576456061,
      "node_id": "PRRC_kwDOABII585d9s99",
      "diff_hunk": "@@ -136,6 +156,12 @@ FUZZ_TARGET(txorphan, .init = initialize_orphanage)\n                     orphanage.LimitOrphans(limit, limit_orphans_rng);\n                     Assert(orphanage.Size() <= limit);\n                 });\n+\n+        // Set tx as potential parent to be used for future GetChildren() calls.\n+        if (!ptx_potential_parent || fuzzed_data_provider.ConsumeBool()) {\n+            ptx_potential_parent = tx;\n+        }",
      "path": "src/test/fuzz/txorphan.cpp",
      "position": null,
      "original_position": 55,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "b9caa4cfcbd1e176ab3ecd61973ab6721570aecb",
      "in_reply_to_id": 1575257763,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "At the very least, if this is kept as is, the assignment should be moved to the outer context. Right now it is part of `LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 10 * DEFAULT_MAX_ORPHAN_TRANSACTIONS)`, which means that it would potentially be set to the same value over and over again ",
      "created_at": "2024-04-23T15:24:20Z",
      "updated_at": "2024-04-25T13:25:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1576456061",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1576456061"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": 160,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 164,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1576479584",
      "pull_request_review_id": 2017442665,
      "id": 1576479584,
      "node_id": "PRRC_kwDOABII585d9ytg",
      "diff_hunk": "@@ -0,0 +1,348 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test opportunistic 1p1c package submission logic.\n+\"\"\"\n+\n+from decimal import Decimal\n+import time\n+from test_framework.messages import (\n+    CInv,\n+    CTxInWitness,\n+    MSG_WTX,\n+    msg_inv,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    fill_mempool,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+\n+def cleanup(func):\n+    def wrapper(self, *args, **kwargs):\n+        try:\n+            func(self, *args, **kwargs)\n+        finally:\n+            self.nodes[0].disconnect_p2ps()\n+            # Do not clear the node's mempool, as each test requires mempool min feerate > min\n+            # relay feerate. However, do check that this is the case.\n+            assert self.nodes[0].getmempoolinfo()[\"mempoolminfee\"] > self.nodes[0].getnetworkinfo()[\"relayfee\"]\n+            # Ensure we do not try to spend the same UTXOs in subsequent tests, as they will look like RBF attempts.\n+            self.wallet.rescan_utxos(include_mempool=True)\n+    return wrapper\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+        ]]\n+        self.supports_cli = False\n+\n+    @cleanup\n+    def test_basic_child_then_parent(self):\n+        node = self.nodes[0]\n+        self.log.info(\"Check that opportunistic 1p1c logic works when child is received before parent\")\n+\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first (perhaps the low feerate parent didn't meet feefilter or the requests were sent to different nodes). It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. Sender relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 4. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+        node.disconnect_p2ps()\n+\n+    @cleanup\n+    def test_basic_parent_then_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=1, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=2, connection_type=\"outbound-full-relay\")\n+\n+        # 1. Parent is relayed first. It is too low feerate.\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer_sender.wait_for_getdata([parent_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer_ignored, check that it is ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+\n+        # 2. Child is relayed next. It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 3. Node requests the missing parent by txid.\n+        # It should do so even if it has previously rejected that parent for being too low feerate.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 4. Sender re-relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 5. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+    @cleanup\n+    def test_low_and_high_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        # This feerate is above mempoolminfee, but not enough to also bump the low feerate parent.\n+        feerate_just_above = node.getmempoolinfo()[\"mempoolminfee\"]\n+        med_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=feerate_just_above)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=3, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=4, connection_type=\"outbound-full-relay\")\n+\n+        self.log.info(\"Check that tx caches low fee parent + low fee child package rejections\")\n+\n+        # 1. Send parent, rejected for being low feerate.\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer_sender.wait_for_getdata([parent_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer_ignored, check that it is ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+\n+        # 2. Send an (orphan) child that has a higher feerate, but not enough to bump the parent.\n+        low_child_wtxid_int = int(med_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([low_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(med_fee_child[\"tx\"]))\n+\n+        # 3. Node requests the orphan's missing parent.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 4. The low parent + low child are submitted as a package. They are not accepted due to low package feerate.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+        assert med_fee_child[\"txid\"] not in node.getrawmempool()\n+\n+        # If peer_ignored announces the low feerate child, it should be ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+        # If either peer sends the parent again, package evaluation should not be attempted\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        peer_ignored.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 5. Send the high feerate (orphan) child\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 6. Node requests the orphan's parent, even though it has already been rejected, both by\n+        # itself and with a child. This is necessary, otherwise high_fee_child can be censored.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 7. The low feerate parent + high feerate child are submitted as a package.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 8. Both transactions should now be in mempool\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+    @cleanup\n+    def test_orphan_consensus_failure(self):\n+        self.log.info(\"Check opportunistic 1p1c logic with consensus-invalid orphan causes disconnect of the correct peer\")\n+        node = self.nodes[0]\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        coin = low_fee_parent[\"new_utxo\"]\n+        address = node.get_deterministic_priv_key().address\n+        # Create raw transaction spending the parent, but with no signature (a consensus error).\n+        hex_orphan_no_sig = node.createrawtransaction([{\"txid\": coin[\"txid\"], \"vout\": coin[\"vout\"]}], {address : coin[\"value\"] - Decimal(\"0.0001\")})\n+        tx_orphan_bad_wit = tx_from_hex(hex_orphan_no_sig)\n+        tx_orphan_bad_wit.wit.vtxinwit.append(CTxInWitness())\n+        tx_orphan_bad_wit.wit.vtxinwit[0].scriptWitness.stack = [b'garbage']\n+\n+        bad_orphan_sender = node.add_p2p_connection(P2PInterface())\n+        parent_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first. It is missing an input.\n+        child_wtxid_int = int(tx_orphan_bad_wit.getwtxid(), 16)\n+        bad_orphan_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=child_wtxid_int)]))\n+        bad_orphan_sender.wait_for_getdata([child_wtxid_int])\n+        bad_orphan_sender.send_and_ping(msg_tx(tx_orphan_bad_wit))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        bad_orphan_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. A different peer relays the parent. Parent+Child are evaluated as a package and rejected.\n+        parent_sender.send_message(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 4. Transactions should not be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] not in node_mempool\n+        assert tx_orphan_bad_wit.rehash() not in node_mempool\n+\n+        # 5. Peer that sent a consensus-invalid transaction should be disconnected.\n+        bad_orphan_sender.wait_for_disconnect()\n+\n+        # The peer that didn't provide the orphan should not be disconnected.\n+        parent_sender.sync_with_ping()\n+\n+    @cleanup\n+    def test_parent_consensus_failure(self):\n+        self.log.info(\"Check opportunistic 1p1c logic with consensus-invalid parent causes disconnect of the correct peer\")\n+        node = self.nodes[0]\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+\n+        # Create invalid version of parent with a bad signature.\n+        tx_parent_bad_wit = tx_from_hex(low_fee_parent[\"hex\"])\n+        tx_parent_bad_wit.wit.vtxinwit.append(CTxInWitness())\n+        tx_parent_bad_wit.wit.vtxinwit[0].scriptWitness.stack = [b'garbage']\n+\n+        package_sender = node.add_p2p_connection(P2PInterface())\n+        fake_parent_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first. It is missing an input.\n+        child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        package_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=child_wtxid_int)]))\n+        package_sender.wait_for_getdata([child_wtxid_int])\n+        package_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(tx_parent_bad_wit.rehash(), 16)\n+        package_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. A different node relays the parent. The parent is first evaluated by itself and\n+        # rejected for being too low feerate. Then it is evaluated as a package and, after passing\n+        # feerate checks, rejected for having a bad signature (consensus error).\n+        fake_parent_sender.send_message(msg_tx(tx_parent_bad_wit))\n+\n+        # 4. Transactions should not be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert tx_parent_bad_wit.rehash() not in node_mempool\n+        assert high_fee_child[\"txid\"] not in node_mempool\n+\n+        # 5. Peer sent a consensus-invalid transaction.\n+        fake_parent_sender.wait_for_disconnect()\n+\n+        self.log.info(\"Check that fake parent does not cause orphan to be deleted and real package can still be submitted\")\n+        # 6. Child-sending should not have been punished and the orphan should remain in orphanage.\n+        # It can send the \"real\" parent transaction, and the package is accepted.\n+        package_sender.sync_with_ping()\n+        package_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+    @cleanup\n+    def test_multiple_parents(self):\n+        self.log.info(\"Check that node does not request more than 1 previously-rejected low feerate parent\")\n+\n+        node = self.nodes[0]\n+        node.setmocktime(int(time.time()))\n+\n+        # 2-parent-1-child package where both parents are below mempool min feerate\n+        parent_low_1 = self.wallet_nonsegwit.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        parent_low_2 = self.wallet_nonsegwit.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        child_bumping = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[parent_low_1[\"new_utxo\"], parent_low_2[\"new_utxo\"]],\n+            fee_per_output=999*parent_low_1[\"tx\"].get_vsize(),\n+        )\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=4, connection_type=\"outbound-full-relay\")\n+\n+        # 1. Send both parents. Each should be rejected for being too low feerate.\n+        # Send unsolicited so that we can later check that no \"getdata\" was ever received.\n+        peer_sender.send_and_ping(msg_tx(parent_low_1[\"tx\"]))\n+        peer_sender.send_and_ping(msg_tx(parent_low_2[\"tx\"]))\n+\n+        # parent_low_1 and parent_low_2 are rejected for being low feerate.\n+        assert parent_low_1[\"txid\"] not in node.getrawmempool()\n+        assert parent_low_2[\"txid\"] not in node.getrawmempool()\n+\n+        # 2. Send child.\n+        peer_sender.send_and_ping(msg_tx(child_bumping[\"tx\"]))\n+\n+        # 3. Node should not request any parents, as it should recognize that it will not accept\n+        # multi-parent-1-child packages.\n+        node.bumpmocktime(60)\n+        peer_sender.sync_with_ping()\n+        assert \"getdata\" not in peer_sender.last_message\n+\n+\n+    def run_test(self):",
      "path": "test/functional/p2p_opportunistic_1p1c.py",
      "position": 377,
      "original_position": 317,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "55b1280c52af81aa6ea0860799fa16da49f51447",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "regression test for the `Assume()` that was hit? And unsetting the mocktime to not have interference in subtests...\r\n```\r\ndiff --git a/test/functional/p2p_opportunistic_1p1c.py b/test/functional/p2p_opportunistic_1p1c.py\r\nindex 2eaa2a0a79..f3a741498b 100755\r\n--- a/test/functional/p2p_opportunistic_1p1c.py\r\n+++ b/test/functional/p2p_opportunistic_1p1c.py\r\n@@ -291,58 +291,97 @@ class PackageRelayTest(BitcoinTestFramework):\r\n         child_bumping = self.wallet_nonsegwit.create_self_transfer_multi(\r\n             utxos_to_spend=[parent_low_1[\"new_utxo\"], parent_low_2[\"new_utxo\"]],\r\n             fee_per_output=999*parent_low_1[\"tx\"].get_vsize(),\r\n         )\r\n \r\n         peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=4, connection_type=\"outbound-full-relay\")\r\n \r\n         # 1. Send both parents. Each should be rejected for being too low feerate.\r\n         # Send unsolicited so that we can later check that no \"getdata\" was ever received.\r\n         peer_sender.send_and_ping(msg_tx(parent_low_1[\"tx\"]))\r\n         peer_sender.send_and_ping(msg_tx(parent_low_2[\"tx\"]))\r\n \r\n         # parent_low_1 and parent_low_2 are rejected for being low feerate.\r\n         assert parent_low_1[\"txid\"] not in node.getrawmempool()\r\n         assert parent_low_2[\"txid\"] not in node.getrawmempool()\r\n \r\n         # 2. Send child.\r\n         peer_sender.send_and_ping(msg_tx(child_bumping[\"tx\"]))\r\n \r\n         # 3. Node should not request any parents, as it should recognize that it will not accept\r\n         # multi-parent-1-child packages.\r\n         node.bumpmocktime(60)\r\n         peer_sender.sync_with_ping()\r\n         assert \"getdata\" not in peer_sender.last_message\r\n \r\n+        node.setmocktime(0)\r\n+\r\n+\r\n+    @cleanup\r\n+    def test_in_mempool_parent(self):\r\n+        self.log.info(\"Check that node rejects a 1p1c package if another parent is already in mempool\")\r\n+\r\n+        node = self.nodes[0]\r\n+        #node.setmocktime(int(time.time()))\r\n+\r\n+        # 2-parent-1-child package where first parent is above mempool minfeerate but second parents is below\r\n+        parent_high = self.wallet_nonsegwit.create_self_transfer(fee_rate=999*FEERATE_1SAT_VB, confirmed_only=True)\r\n+        parent_low = self.wallet_nonsegwit.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\r\n+        child_bumping = self.wallet_nonsegwit.create_self_transfer_multi(\r\n+            utxos_to_spend=[parent_high[\"new_utxo\"], parent_low[\"new_utxo\"]],\r\n+            fee_per_output=999*parent_low[\"tx\"].get_vsize(),\r\n+        )\r\n+\r\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=4, connection_type=\"outbound-full-relay\")\r\n+\r\n+        # 1. Send first parent which will be accepted.\r\n+        peer_sender.send_and_ping(msg_tx(parent_high[\"tx\"]))\r\n+        assert parent_high[\"txid\"] in node.getrawmempool()\r\n+\r\n+        # 2. Send child.\r\n+        peer_sender.send_and_ping(msg_tx(child_bumping[\"tx\"]))\r\n+\r\n+        # 3. Node should request parent_low via txid, but node will reject child_bumping + parent_low\r\n+        #    due to `package-not-child-with-unconfirmed-parents`\r\n+        #node.bumpmocktime(60)\r\n+        parent_low_txid_int = int(parent_low[\"txid\"], 16)\r\n+        peer_sender.wait_for_getdata([parent_low_txid_int])\r\n+        peer_sender.send_and_ping(msg_tx(parent_low[\"tx\"]))\r\n+\r\n+        node_mempool = node.getrawmempool()\r\n+        assert parent_low[\"txid\"] not in node_mempool\r\n+        assert child_bumping[\"txid\"] not in node_mempool\r\n+        assert parent_high[\"txid\"] in node_mempool\r\n \r\n     def run_test(self):\r\n         node = self.nodes[0]\r\n         self.wallet = MiniWallet(node)\r\n         self.wallet_nonsegwit = MiniWallet(node, mode=MiniWalletMode.RAW_P2PK)\r\n         self.generate(self.wallet_nonsegwit, 10)\r\n         self.generate(self.wallet, 20)\r\n \r\n         filler_wallet = MiniWallet(node)\r\n         fill_mempool(self, node, filler_wallet)\r\n \r\n         self.log.info(\"Check opportunistic 1p1c logic when parent (txid != wtxid) is received before child\")\r\n         self.test_basic_parent_then_child(self.wallet)\r\n \r\n         self.log.info(\"Check opportunistic 1p1c logic when parent (txid == wtxid) is received before child\")\r\n         self.test_basic_parent_then_child(self.wallet_nonsegwit)\r\n \r\n         self.log.info(\"Check opportunistic 1p1c logic when child is received before parent\")\r\n         self.test_basic_child_then_parent()\r\n \r\n         self.log.info(\"Check opportunistic 1p1c logic when 2 candidate children exist (parent txid != wtxid)\")\r\n         self.test_low_and_high_child(self.wallet)\r\n \r\n         self.log.info(\"Check opportunistic 1p1c logic when 2 candidate children exist (parent txid == wtxid)\")\r\n         self.test_low_and_high_child(self.wallet_nonsegwit)\r\n \r\n         self.test_orphan_consensus_failure()\r\n         self.test_parent_consensus_failure()\r\n         self.test_multiple_parents()\r\n+        self.test_in_mempool_parent()\r\n \r\n \r\n if __name__ == '__main__':\r\n     PackageRelayTest().main()\r\n```",
      "created_at": "2024-04-23T15:38:56Z",
      "updated_at": "2024-04-23T16:33:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1576479584",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1576479584"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 377,
      "original_line": 377,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1576613747",
      "pull_request_review_id": 2015631578,
      "id": 1576613747,
      "node_id": "PRRC_kwDOABII585d-Tdz",
      "diff_hunk": "@@ -596,6 +596,21 @@ class PeerManagerImpl final : public PeerManager\n     void ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, const std::list<CTransactionRef>& replaced_transactions)\n         EXCLUSIVE_LOCKS_REQUIRED(!m_peer_mutex, g_msgproc_mutex, cs_main);\n \n+    /** Handle the results of package validation: calls ProcessValidTx and ProcessInvalidTx for\n+     * individual transactions, and caches rejection for the package as a group.\n+     * @param[in]   senders     Must contain the nodeids of the peers that provided each transaction\n+     *                          in package, in the same order.\n+     *   */\n+    void ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, const std::vector<NodeId>& senders)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_peer_mutex, g_msgproc_mutex, cs_main);\n+\n+    /** Look for a child of this transaction in the orphanage to form a 1-parent-1-child package,\n+     * skipping any combinations have already been tried, and submit them together to the mempool.",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 13,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "bb3bf0a39c036fbd94b99ed7002db7d9bdf0a1d6",
      "in_reply_to_id": null,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In bb3bf0a39c036fbd94b99ed7002db7d9bdf0a1d6\r\n\r\nnit: skipping any combinations **that** have already been tried (?)",
      "created_at": "2024-04-23T17:18:21Z",
      "updated_at": "2024-04-25T13:25:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1576613747",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1576613747"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 608,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1576672946",
      "pull_request_review_id": 2015631578,
      "id": 1576672946,
      "node_id": "PRRC_kwDOABII585d-h6y",
      "diff_hunk": "@@ -3195,6 +3210,140 @@ void PeerManagerImpl::ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, c\n     }\n }\n \n+void PeerManagerImpl::ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, const std::vector<NodeId>& senders)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    if (package_result.m_state.IsInvalid()) {\n+        m_recent_rejects_reconsiderable.insert(GetPackageHash(package));\n+    }\n+    // We currently only expect to process 1-parent-1-child packages. Remove if this changes.\n+    if (!Assume(package.size() == 2)) return;\n+\n+    // No package results to look through for PCKG_POLICY or PCKG_MEMPOOL_ERROR\n+    if (package_result.m_state.GetResult() == PackageValidationResult::PCKG_POLICY ||\n+        package_result.m_state.GetResult() == PackageValidationResult::PCKG_MEMPOOL_ERROR) return;\n+\n+    // Iterate backwards to erase in-package descendants from the orphanage before they become\n+    // relevant in AddChildrenToWorkSet.\n+    auto package_iter = package.rbegin();\n+    auto senders_iter = senders.rbegin();\n+    while (package_iter != package.rend()) {\n+        const auto& tx = *package_iter;\n+        const NodeId nodeid = *senders_iter;\n+        const auto it_result{package_result.m_tx_results.find(tx->GetWitnessHash())};\n+        if (Assume(it_result != package_result.m_tx_results.end())) {\n+            const auto& tx_result = it_result->second;\n+            switch (tx_result.m_result_type) {\n+                case MempoolAcceptResult::ResultType::VALID:\n+                {\n+                    Assume(tx_result.m_replaced_transactions.has_value());\n+                    std::list<CTransactionRef> empty_replacement_list;\n+                    ProcessValidTx(nodeid, tx, tx_result.m_replaced_transactions.value_or(empty_replacement_list));\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::INVALID:\n+                case MempoolAcceptResult::ResultType::DIFFERENT_WITNESS:\n+                {\n+                    // Don't add to vExtraTxnForCompact, as these transactions should have already been\n+                    // added there when added to the orphanage or rejected for TX_RECONSIDERABLE.\n+                    // This should be updated if package submission is ever used for transactions\n+                    // that haven't already been validated before.\n+                    ProcessInvalidTx(nodeid, tx, tx_result.m_state, /*maybe_add_extra_compact_tx=*/false);\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::MEMPOOL_ENTRY:\n+                {\n+                    // AlreadyHaveTx() should be catching transactions that are already in mempool.\n+                    Assume(false);\n+                    break;\n+                }\n+            }\n+        }\n+        package_iter++;\n+        // There should be a sender for each tx, but fall back to the last one otherwise.\n+        if (Assume(senders_iter != senders.rend())) senders_iter++;\n+    }\n+}\n+\n+void PeerManagerImpl::MaybeProcess1P1CPackage(const CTransactionRef& ptx, NodeId nodeid)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    const auto& parent_txid{ptx->GetHash()};\n+    const auto& parent_wtxid{ptx->GetWitnessHash()};\n+\n+    CTransactionRef tx_orphan{nullptr};\n+    NodeId orphan_sender{-1};\n+    Assume(m_recent_rejects_reconsiderable.contains(parent_wtxid.ToUint256()));\n+\n+    // Prefer children from this peer. This helps prevent censorship attempts in which an attacker\n+    // sends lots of fake children for the parent, and we (unluckily) keep selecting the fake\n+    // children instead of the real one provided by the honest peer.\n+    const auto cpfp_candidates_same_peer{m_orphanage.GetChildrenFromSamePeer(ptx, nodeid)};\n+\n+    // These children should be sorted from most newest to oldest. In the (probably uncommon) case",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 102,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "bb3bf0a39c036fbd94b99ed7002db7d9bdf0a1d6",
      "in_reply_to_id": null,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In bb3bf0a39c036fbd94b99ed7002db7d9bdf0a1d6\r\n\r\nnit: ~most~ newest",
      "created_at": "2024-04-23T18:00:46Z",
      "updated_at": "2024-04-25T13:25:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1576672946",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1576672946"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3289,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1576744547",
      "pull_request_review_id": 2015631578,
      "id": 1576744547,
      "node_id": "PRRC_kwDOABII585d-zZj",
      "diff_hunk": "@@ -3195,6 +3210,140 @@ void PeerManagerImpl::ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, c\n     }\n }\n \n+void PeerManagerImpl::ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, const std::vector<NodeId>& senders)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    if (package_result.m_state.IsInvalid()) {\n+        m_recent_rejects_reconsiderable.insert(GetPackageHash(package));\n+    }\n+    // We currently only expect to process 1-parent-1-child packages. Remove if this changes.\n+    if (!Assume(package.size() == 2)) return;\n+\n+    // No package results to look through for PCKG_POLICY or PCKG_MEMPOOL_ERROR\n+    if (package_result.m_state.GetResult() == PackageValidationResult::PCKG_POLICY ||\n+        package_result.m_state.GetResult() == PackageValidationResult::PCKG_MEMPOOL_ERROR) return;\n+\n+    // Iterate backwards to erase in-package descendants from the orphanage before they become\n+    // relevant in AddChildrenToWorkSet.\n+    auto package_iter = package.rbegin();\n+    auto senders_iter = senders.rbegin();\n+    while (package_iter != package.rend()) {\n+        const auto& tx = *package_iter;\n+        const NodeId nodeid = *senders_iter;\n+        const auto it_result{package_result.m_tx_results.find(tx->GetWitnessHash())};\n+        if (Assume(it_result != package_result.m_tx_results.end())) {\n+            const auto& tx_result = it_result->second;\n+            switch (tx_result.m_result_type) {\n+                case MempoolAcceptResult::ResultType::VALID:\n+                {\n+                    Assume(tx_result.m_replaced_transactions.has_value());\n+                    std::list<CTransactionRef> empty_replacement_list;\n+                    ProcessValidTx(nodeid, tx, tx_result.m_replaced_transactions.value_or(empty_replacement_list));\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::INVALID:\n+                case MempoolAcceptResult::ResultType::DIFFERENT_WITNESS:\n+                {\n+                    // Don't add to vExtraTxnForCompact, as these transactions should have already been\n+                    // added there when added to the orphanage or rejected for TX_RECONSIDERABLE.\n+                    // This should be updated if package submission is ever used for transactions\n+                    // that haven't already been validated before.\n+                    ProcessInvalidTx(nodeid, tx, tx_result.m_state, /*maybe_add_extra_compact_tx=*/false);\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::MEMPOOL_ENTRY:\n+                {\n+                    // AlreadyHaveTx() should be catching transactions that are already in mempool.\n+                    Assume(false);\n+                    break;\n+                }\n+            }\n+        }\n+        package_iter++;\n+        // There should be a sender for each tx, but fall back to the last one otherwise.\n+        if (Assume(senders_iter != senders.rend())) senders_iter++;\n+    }\n+}\n+\n+void PeerManagerImpl::MaybeProcess1P1CPackage(const CTransactionRef& ptx, NodeId nodeid)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    const auto& parent_txid{ptx->GetHash()};\n+    const auto& parent_wtxid{ptx->GetWitnessHash()};\n+\n+    CTransactionRef tx_orphan{nullptr};",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 93,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "bb3bf0a39c036fbd94b99ed7002db7d9bdf0a1d6",
      "in_reply_to_id": null,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In bb3bf0a39c036fbd94b99ed7002db7d9bdf0a1d6\r\n\r\nI think you can potentially get rid of this variable by having a reference to a `Package` instead, which is set to the `maybe_cpfp_package` when the package cannot be found in `m_recent_rejects_reconsiderable`.\r\n\r\nThat way you won't need to construct the package again in the current `if (tx_orphan)` scope.",
      "created_at": "2024-04-23T18:47:04Z",
      "updated_at": "2024-04-25T13:25:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1576744547",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1576744547"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3280,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1576758551",
      "pull_request_review_id": 2015631578,
      "id": 1576758551,
      "node_id": "PRRC_kwDOABII585d-20X",
      "diff_hunk": "@@ -3195,6 +3210,140 @@ void PeerManagerImpl::ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, c\n     }\n }\n \n+void PeerManagerImpl::ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, const std::vector<NodeId>& senders)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    if (package_result.m_state.IsInvalid()) {\n+        m_recent_rejects_reconsiderable.insert(GetPackageHash(package));\n+    }",
      "path": "src/net_processing.cpp",
      "position": 168,
      "original_position": 34,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "bb3bf0a39c036fbd94b99ed7002db7d9bdf0a1d6",
      "in_reply_to_id": null,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In bb3bf0a39c036fbd94b99ed7002db7d9bdf0a1d6\r\n\r\nShouldn't this be moved after the two next checks, to avoid bloating the rolling bloom filter with data that is unconditionally invalid? The only way for a package of this type to be actually resonsiderable is if it fails due to a transaction being rejected, but not if `PCKG_POLICY` or `PCKG_MEMPOOL_ERROR`",
      "created_at": "2024-04-23T18:56:23Z",
      "updated_at": "2024-04-25T13:25:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1576758551",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1576758551"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": 3246,
      "original_start_line": 3219,
      "start_side": "RIGHT",
      "line": 3248,
      "original_line": 3248,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1577900718",
      "pull_request_review_id": 2019874263,
      "id": 1577900718,
      "node_id": "PRRC_kwDOABII585eDNqu",
      "diff_hunk": "@@ -40,6 +43,92 @@ inline CTransactionRef create_placeholder_tx(size_t num_inputs, size_t num_outpu\n     return MakeTransactionRef(mtx);\n }\n \n+// Create a Wtxid from a hex string\n+inline Wtxid WtxidFromString(std::string_view str)\n+{\n+    return Wtxid::FromUint256(uint256S(str.data()));\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(package_hash_tests, TestChain100Setup)\n+{\n+    // Random real segwit transaction\n+    DataStream stream_1{\n+        ParseHex(\"02000000000101964b8aa63509579ca6086e6012eeaa4c2f4dd1e283da29b67c8eea38b3c6fd220000000000fdffffff0294c618000000000017a9145afbbb42f4e83312666d0697f9e66259912ecde38768fa2c0000000000160014897388a0889390fd0e153a22bb2cf9d8f019faf50247304402200547406380719f84d68cf4e96cc3e4a1688309ef475b150be2b471c70ea562aa02206d255f5acc40fd95981874d77201d2eb07883657ce1c796513f32b6079545cdf0121023ae77335cefcb5ab4c1dc1fb0d2acfece184e593727d7d5906c78e564c7c11d125cf0c00\"),\n+    };\n+    CTransaction tx_1(deserialize, TX_WITH_WITNESS, stream_1);\n+    CTransactionRef ptx_1{MakeTransactionRef(tx_1)};\n+\n+    // Random real nonsegwit transaction\n+    DataStream stream_2{\n+        ParseHex(\"01000000010b26e9b7735eb6aabdf358bab62f9816a21ba9ebdb719d5299e88607d722c190000000008b4830450220070aca44506c5cef3a16ed519d7c3c39f8aab192c4e1c90d065f37b8a4af6141022100a8e160b856c2d43d27d8fba71e5aef6405b8643ac4cb7cb3c462aced7f14711a0141046d11fee51b0e60666d5049a9101a72741df480b96ee26488a4d3466b95c9a40ac5eeef87e10a5cd336c19a84565f80fa6c547957b7700ff4dfbdefe76036c339ffffffff021bff3d11000000001976a91404943fdd508053c75000106d3bc6e2754dbcff1988ac2f15de00000000001976a914a266436d2965547608b9e15d9032a7b9d64fa43188ac00000000\"),\n+    };\n+    CTransaction tx_2(deserialize, TX_WITH_WITNESS, stream_2);\n+    CTransactionRef ptx_2{MakeTransactionRef(tx_2)};\n+\n+    // Random real segwit transaction\n+    DataStream stream_3{\n+        ParseHex(\"0200000000010177862801f77c2c068a70372b4c435ef8dd621291c36a64eb4dd491f02218f5324600000000fdffffff014a0100000000000022512035ea312034cfac01e956a269f3bf147f569c2fbb00180677421262da042290d803402be713325ff285e66b0380f53f2fae0d0fb4e16f378a440fed51ce835061437566729d4883bc917632f3cff474d6384bc8b989961a1d730d4a87ed38ad28bd337b20f1d658c6c138b1c312e072b4446f50f01ae0da03a42e6274f8788aae53416a7fac0063036f7264010118746578742f706c61696e3b636861727365743d7574662d3800357b2270223a226272632d3230222c226f70223a226d696e74222c227469636b223a224342414c222c22616d74223a2236393639227d6821c1f1d658c6c138b1c312e072b4446f50f01ae0da03a42e6274f8788aae53416a7f00000000\"),\n+    };\n+    CTransaction tx_3(deserialize, TX_WITH_WITNESS, stream_3);\n+    CTransactionRef ptx_3{MakeTransactionRef(tx_3)};\n+\n+    // It's easy to see that wtxids are sorted in lexicographical order:\n+    Wtxid wtxid_1{WtxidFromString(\"0x85cd1a31eb38f74ed5742ec9cb546712ab5aaf747de28a9168b53e846cbda17f\")};\n+    Wtxid wtxid_2{WtxidFromString(\"0xb4749f017444b051c44dfd2720e88f314ff94f3dd6d56d40ef65854fcd7fff6b\")};\n+    Wtxid wtxid_3{WtxidFromString(\"0xe065bac15f62bb4e761d761db928ddee65a47296b2b776785abb912cdec474e3\")};\n+    BOOST_CHECK_EQUAL(tx_1.GetWitnessHash(), wtxid_1);\n+    BOOST_CHECK_EQUAL(tx_2.GetWitnessHash(), wtxid_2);\n+    BOOST_CHECK_EQUAL(tx_3.GetWitnessHash(), wtxid_3);\n+\n+    BOOST_CHECK(wtxid_1.GetHex() < wtxid_2.GetHex());\n+    BOOST_CHECK(wtxid_2.GetHex() < wtxid_3.GetHex());\n+\n+    // The txids are not (we want to test that sorting and hashing use wtxid, not txid):\n+    Txid txid_1{TxidFromString(\"0xbd0f71c1d5e50589063e134fad22053cdae5ab2320db5bf5e540198b0b5a4e69\")};\n+    Txid txid_2{TxidFromString(\"0xb4749f017444b051c44dfd2720e88f314ff94f3dd6d56d40ef65854fcd7fff6b\")};\n+    Txid txid_3{TxidFromString(\"0xee707be5201160e32c4fc715bec227d1aeea5940fb4295605e7373edce3b1a93\")};\n+    BOOST_CHECK_EQUAL(tx_1.GetHash(), txid_1);\n+    BOOST_CHECK_EQUAL(tx_2.GetHash(), txid_2);\n+    BOOST_CHECK_EQUAL(tx_3.GetHash(), txid_3);\n+\n+    BOOST_CHECK(txid_2.GetHex() < txid_1.GetHex());\n+\n+    BOOST_CHECK(txid_1.ToUint256() != wtxid_1.ToUint256());\n+    BOOST_CHECK(txid_3.ToUint256() != wtxid_3.ToUint256());\n+\n+    // We are testing that both functions compare using GetHex() and not uint256.\n+    // (in this pair of wtxids, hex string order != uint256 order)\n+    BOOST_CHECK(wtxid_2 < wtxid_1);\n+    // (in this pair of wtxids, hex string order == uint256 order)\n+    BOOST_CHECK(wtxid_2 < wtxid_3);\n+\n+    // All permutations of the package containing ptx_1, ptx_2, ptx_3 have the same package hash\n+    std::vector<CTransactionRef> package_123{ptx_1, ptx_2, ptx_3};\n+    std::vector<CTransactionRef> package_132{ptx_1, ptx_3, ptx_2};\n+    std::vector<CTransactionRef> package_231{ptx_2, ptx_3, ptx_1};\n+    std::vector<CTransactionRef> package_213{ptx_2, ptx_1, ptx_3};\n+    std::vector<CTransactionRef> package_312{ptx_3, ptx_1, ptx_2};\n+    std::vector<CTransactionRef> package_321{ptx_3, ptx_2, ptx_1};\n+\n+    uint256 calculated_hash_123 = (HashWriter() << wtxid_1 << wtxid_2 << wtxid_3).GetSHA256();\n+\n+    uint256 hash_if_by_txid = (HashWriter() << wtxid_2 << wtxid_1 << wtxid_3).GetSHA256();\n+    BOOST_CHECK(hash_if_by_txid != calculated_hash_123);\n+\n+    uint256 hash_if_use_txid = (HashWriter() << txid_2 << txid_1 << txid_3).GetSHA256();\n+    BOOST_CHECK(hash_if_use_txid != calculated_hash_123);\n+\n+    uint256 hash_if_use_int_order = (HashWriter() << wtxid_2 << wtxid_1 << txid_3).GetSHA256();",
      "path": "src/test/txpackage_tests.cpp",
      "position": null,
      "original_position": 92,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "6edf8ec0c5616d7f1dd372c704f5e0a5b3416f83",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Was it intended to mix both wtxids and txids for hashing in this test-case? (IIUC the meaning of \"int order\" here, this would be wtxid2, wtxid1, wtxid3, i.e. identical with `hash_if_by_txid`, so I guess one of the two test-cases can be removed).\r\n```suggestion\r\n    uint256 hash_if_use_int_order = (HashWriter() << wtxid_2 << wtxid_1 << wtxid_3).GetSHA256();\r\n```",
      "created_at": "2024-04-24T13:33:33Z",
      "updated_at": "2024-04-24T16:19:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1577900718",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1577900718"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 121,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1577902195",
      "pull_request_review_id": 2019874263,
      "id": 1577902195,
      "node_id": "PRRC_kwDOABII585eDOBz",
      "diff_hunk": "@@ -40,6 +43,92 @@ inline CTransactionRef create_placeholder_tx(size_t num_inputs, size_t num_outpu\n     return MakeTransactionRef(mtx);\n }\n \n+// Create a Wtxid from a hex string\n+inline Wtxid WtxidFromString(std::string_view str)\n+{\n+    return Wtxid::FromUint256(uint256S(str.data()));\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(package_hash_tests, TestChain100Setup)\n+{\n+    // Random real segwit transaction\n+    DataStream stream_1{\n+        ParseHex(\"02000000000101964b8aa63509579ca6086e6012eeaa4c2f4dd1e283da29b67c8eea38b3c6fd220000000000fdffffff0294c618000000000017a9145afbbb42f4e83312666d0697f9e66259912ecde38768fa2c0000000000160014897388a0889390fd0e153a22bb2cf9d8f019faf50247304402200547406380719f84d68cf4e96cc3e4a1688309ef475b150be2b471c70ea562aa02206d255f5acc40fd95981874d77201d2eb07883657ce1c796513f32b6079545cdf0121023ae77335cefcb5ab4c1dc1fb0d2acfece184e593727d7d5906c78e564c7c11d125cf0c00\"),\n+    };\n+    CTransaction tx_1(deserialize, TX_WITH_WITNESS, stream_1);\n+    CTransactionRef ptx_1{MakeTransactionRef(tx_1)};\n+\n+    // Random real nonsegwit transaction\n+    DataStream stream_2{\n+        ParseHex(\"01000000010b26e9b7735eb6aabdf358bab62f9816a21ba9ebdb719d5299e88607d722c190000000008b4830450220070aca44506c5cef3a16ed519d7c3c39f8aab192c4e1c90d065f37b8a4af6141022100a8e160b856c2d43d27d8fba71e5aef6405b8643ac4cb7cb3c462aced7f14711a0141046d11fee51b0e60666d5049a9101a72741df480b96ee26488a4d3466b95c9a40ac5eeef87e10a5cd336c19a84565f80fa6c547957b7700ff4dfbdefe76036c339ffffffff021bff3d11000000001976a91404943fdd508053c75000106d3bc6e2754dbcff1988ac2f15de00000000001976a914a266436d2965547608b9e15d9032a7b9d64fa43188ac00000000\"),\n+    };\n+    CTransaction tx_2(deserialize, TX_WITH_WITNESS, stream_2);\n+    CTransactionRef ptx_2{MakeTransactionRef(tx_2)};\n+\n+    // Random real segwit transaction\n+    DataStream stream_3{\n+        ParseHex(\"0200000000010177862801f77c2c068a70372b4c435ef8dd621291c36a64eb4dd491f02218f5324600000000fdffffff014a0100000000000022512035ea312034cfac01e956a269f3bf147f569c2fbb00180677421262da042290d803402be713325ff285e66b0380f53f2fae0d0fb4e16f378a440fed51ce835061437566729d4883bc917632f3cff474d6384bc8b989961a1d730d4a87ed38ad28bd337b20f1d658c6c138b1c312e072b4446f50f01ae0da03a42e6274f8788aae53416a7fac0063036f7264010118746578742f706c61696e3b636861727365743d7574662d3800357b2270223a226272632d3230222c226f70223a226d696e74222c227469636b223a224342414c222c22616d74223a2236393639227d6821c1f1d658c6c138b1c312e072b4446f50f01ae0da03a42e6274f8788aae53416a7f00000000\"),\n+    };\n+    CTransaction tx_3(deserialize, TX_WITH_WITNESS, stream_3);\n+    CTransactionRef ptx_3{MakeTransactionRef(tx_3)};\n+\n+    // It's easy to see that wtxids are sorted in lexicographical order:\n+    Wtxid wtxid_1{WtxidFromString(\"0x85cd1a31eb38f74ed5742ec9cb546712ab5aaf747de28a9168b53e846cbda17f\")};\n+    Wtxid wtxid_2{WtxidFromString(\"0xb4749f017444b051c44dfd2720e88f314ff94f3dd6d56d40ef65854fcd7fff6b\")};\n+    Wtxid wtxid_3{WtxidFromString(\"0xe065bac15f62bb4e761d761db928ddee65a47296b2b776785abb912cdec474e3\")};\n+    BOOST_CHECK_EQUAL(tx_1.GetWitnessHash(), wtxid_1);\n+    BOOST_CHECK_EQUAL(tx_2.GetWitnessHash(), wtxid_2);\n+    BOOST_CHECK_EQUAL(tx_3.GetWitnessHash(), wtxid_3);\n+\n+    BOOST_CHECK(wtxid_1.GetHex() < wtxid_2.GetHex());\n+    BOOST_CHECK(wtxid_2.GetHex() < wtxid_3.GetHex());\n+\n+    // The txids are not (we want to test that sorting and hashing use wtxid, not txid):\n+    Txid txid_1{TxidFromString(\"0xbd0f71c1d5e50589063e134fad22053cdae5ab2320db5bf5e540198b0b5a4e69\")};\n+    Txid txid_2{TxidFromString(\"0xb4749f017444b051c44dfd2720e88f314ff94f3dd6d56d40ef65854fcd7fff6b\")};\n+    Txid txid_3{TxidFromString(\"0xee707be5201160e32c4fc715bec227d1aeea5940fb4295605e7373edce3b1a93\")};\n+    BOOST_CHECK_EQUAL(tx_1.GetHash(), txid_1);\n+    BOOST_CHECK_EQUAL(tx_2.GetHash(), txid_2);\n+    BOOST_CHECK_EQUAL(tx_3.GetHash(), txid_3);\n+\n+    BOOST_CHECK(txid_2.GetHex() < txid_1.GetHex());\n+\n+    BOOST_CHECK(txid_1.ToUint256() != wtxid_1.ToUint256());\n+    BOOST_CHECK(txid_3.ToUint256() != wtxid_3.ToUint256());",
      "path": "src/test/txpackage_tests.cpp",
      "position": null,
      "original_position": 68,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "6edf8ec0c5616d7f1dd372c704f5e0a5b3416f83",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: for the sake of completeness, could also check that txid and wtxid are equal for non-segwit tx 2:\r\n```suggestion\r\n    BOOST_CHECK(txid_1.ToUint256() != wtxid_1.ToUint256());\r\n    BOOST_CHECK_EQUAL(txid_2.ToUint256(), wtxid_2.ToUint256());\r\n    BOOST_CHECK(txid_3.ToUint256() != wtxid_3.ToUint256());\r\n```",
      "created_at": "2024-04-24T13:34:34Z",
      "updated_at": "2024-04-24T16:19:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1577902195",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1577902195"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": 96,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 98,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1577936862",
      "pull_request_review_id": 2019952070,
      "id": 1577936862,
      "node_id": "PRRC_kwDOABII585eDWfe",
      "diff_hunk": "@@ -3195,6 +3210,115 @@ void PeerManagerImpl::ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, c\n     }\n }\n \n+void PeerManagerImpl::ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, const std::vector<NodeId>& senders)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    if (package_result.m_state.IsInvalid()) {\n+        m_recent_rejects_reconsiderable.insert(GetPackageHash(package));\n+    }\n+    // We currently only expect to process 1-parent-1-child packages. Remove if this changes.\n+    if (!Assume(package.size() == 2)) return;\n+\n+    // Iterate backwards to erase in-package descendants from the orphanage before they become\n+    // relevant in AddChildrenToWorkSet.\n+    auto package_iter = package.rbegin();\n+    auto senders_iter = senders.rbegin();\n+    while (package_iter != package.rend()) {\n+        const auto& tx = *package_iter;\n+        const NodeId nodeid = *senders_iter;\n+        const auto it_result{package_result.m_tx_results.find(tx->GetWitnessHash())};\n+        if (Assume(it_result != package_result.m_tx_results.end())) {\n+            const auto& tx_result = it_result->second;\n+            switch (tx_result.m_result_type) {\n+                case MempoolAcceptResult::ResultType::VALID:\n+                {\n+                    Assume(tx_result.m_replaced_transactions.has_value());\n+                    std::list<CTransactionRef> empty_replacement_list;\n+                    ProcessValidTx(nodeid, tx, tx_result.m_replaced_transactions.value_or(empty_replacement_list));\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::INVALID:\n+                case MempoolAcceptResult::ResultType::DIFFERENT_WITNESS:\n+                {\n+                    // Don't add to vExtraTxnForCompact, as these transactions should have already been\n+                    // added there when added to the orphanage or rejected for TX_RECONSIDERABLE.\n+                    // This should be updated if package submission is ever used for transactions\n+                    // that haven't already been validated before.\n+                    ProcessInvalidTx(nodeid, tx, tx_result.m_state, /*maybe_add_extra_compact_tx=*/false);\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::MEMPOOL_ENTRY:\n+                {\n+                    // AlreadyHaveTx() should be catching transactions that are already in mempool.\n+                    Assume(false);\n+                    break;\n+                }\n+            }\n+        }\n+        package_iter++;\n+        // There should be a sender for each tx, but fall back to the last one otherwise.\n+        if (Assume(senders_iter != senders.rend())) senders_iter++;\n+    }\n+}\n+\n+void PeerManagerImpl::MaybeProcess1P1CPackage(const CTransactionRef& ptx, NodeId nodeid)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    const auto& parent_txid{ptx->GetHash()};\n+    const auto& parent_wtxid{ptx->GetWitnessHash()};\n+\n+    const auto cpfp_candidates{m_orphanage.GetChildren(ptx)};\n+    // Exit early.\n+    if (cpfp_candidates.empty()) {\n+        LogDebug(BCLog::TXPACKAGES, \"didn't evaluate package for %s (wtxid=%s), no corresponding orphan found\\n\",\n+                 parent_txid.ToString(), parent_wtxid.ToString());\n+        return;\n+    }\n+\n+    CTransactionRef tx_orphan{nullptr};\n+    NodeId orphan_sender{-1};\n+    Assume(m_recent_rejects_reconsiderable.contains(parent_wtxid.ToUint256()));\n+\n+    // Create a 1p1c package using the first child that hasn't already been rejected. Sort\n+    // the children in random order to not create a bias that attackers can use to delay\n+    // package acceptance. Create a random permutation of the indices.\n+    std::vector<size_t> tx_indices(cpfp_candidates.size());\n+    std::iota(tx_indices.begin(), tx_indices.end(), 0);\n+    Shuffle(tx_indices.begin(), tx_indices.end(), m_rng);",
      "path": "src/net_processing.cpp",
      "position": 257,
      "original_position": 106,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "25c712711d6b1074b40c440676e3b1c4e12e59af",
      "in_reply_to_id": 1568834899,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I don't think that is much simpler. Also I think this is easier to delete if/when we don't try orphans from different peers in the future.",
      "created_at": "2024-04-24T13:53:43Z",
      "updated_at": "2024-04-24T13:53:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1577936862",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1577936862"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 3337,
      "original_line": 3337,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1577947487",
      "pull_request_review_id": 2019970056,
      "id": 1577947487,
      "node_id": "PRRC_kwDOABII585eDZFf",
      "diff_hunk": "@@ -3195,6 +3210,140 @@ void PeerManagerImpl::ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, c\n     }\n }\n \n+void PeerManagerImpl::ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, const std::vector<NodeId>& senders)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    if (package_result.m_state.IsInvalid()) {\n+        m_recent_rejects_reconsiderable.insert(GetPackageHash(package));\n+    }\n+    // We currently only expect to process 1-parent-1-child packages. Remove if this changes.\n+    if (!Assume(package.size() == 2)) return;\n+\n+    // No package results to look through for PCKG_POLICY or PCKG_MEMPOOL_ERROR\n+    if (package_result.m_state.GetResult() == PackageValidationResult::PCKG_POLICY ||\n+        package_result.m_state.GetResult() == PackageValidationResult::PCKG_MEMPOOL_ERROR) return;\n+\n+    // Iterate backwards to erase in-package descendants from the orphanage before they become\n+    // relevant in AddChildrenToWorkSet.\n+    auto package_iter = package.rbegin();\n+    auto senders_iter = senders.rbegin();\n+    while (package_iter != package.rend()) {\n+        const auto& tx = *package_iter;\n+        const NodeId nodeid = *senders_iter;\n+        const auto it_result{package_result.m_tx_results.find(tx->GetWitnessHash())};\n+        if (Assume(it_result != package_result.m_tx_results.end())) {\n+            const auto& tx_result = it_result->second;\n+            switch (tx_result.m_result_type) {\n+                case MempoolAcceptResult::ResultType::VALID:\n+                {\n+                    Assume(tx_result.m_replaced_transactions.has_value());\n+                    std::list<CTransactionRef> empty_replacement_list;\n+                    ProcessValidTx(nodeid, tx, tx_result.m_replaced_transactions.value_or(empty_replacement_list));\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::INVALID:\n+                case MempoolAcceptResult::ResultType::DIFFERENT_WITNESS:\n+                {\n+                    // Don't add to vExtraTxnForCompact, as these transactions should have already been\n+                    // added there when added to the orphanage or rejected for TX_RECONSIDERABLE.\n+                    // This should be updated if package submission is ever used for transactions\n+                    // that haven't already been validated before.\n+                    ProcessInvalidTx(nodeid, tx, tx_result.m_state, /*maybe_add_extra_compact_tx=*/false);\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::MEMPOOL_ENTRY:\n+                {\n+                    // AlreadyHaveTx() should be catching transactions that are already in mempool.\n+                    Assume(false);\n+                    break;\n+                }\n+            }\n+        }\n+        package_iter++;\n+        // There should be a sender for each tx, but fall back to the last one otherwise.\n+        if (Assume(senders_iter != senders.rend())) senders_iter++;\n+    }\n+}\n+\n+void PeerManagerImpl::MaybeProcess1P1CPackage(const CTransactionRef& ptx, NodeId nodeid)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    const auto& parent_txid{ptx->GetHash()};\n+    const auto& parent_wtxid{ptx->GetWitnessHash()};\n+\n+    CTransactionRef tx_orphan{nullptr};\n+    NodeId orphan_sender{-1};\n+    Assume(m_recent_rejects_reconsiderable.contains(parent_wtxid.ToUint256()));\n+\n+    // Prefer children from this peer. This helps prevent censorship attempts in which an attacker\n+    // sends lots of fake children for the parent, and we (unluckily) keep selecting the fake\n+    // children instead of the real one provided by the honest peer.\n+    const auto cpfp_candidates_same_peer{m_orphanage.GetChildrenFromSamePeer(ptx, nodeid)};\n+\n+    // These children should be sorted from most newest to oldest. In the (probably uncommon) case\n+    // of children that replace each other, this helps us accept the highest feerate (probably the\n+    // most recent) one efficiently.\n+    for (const auto& child : cpfp_candidates_same_peer) {\n+        Package maybe_cpfp_package{ptx, child};\n+        if (!m_recent_rejects_reconsiderable.contains(GetPackageHash(maybe_cpfp_package))) {\n+            tx_orphan = child;\n+            orphan_sender = nodeid;\n+            break;\n+        }\n+    }\n+\n+    // If no suitable candidate from the same peer is found, also try children that were provided by\n+    // a different peer. This is useful because sometimes multiple peers announce both transactions\n+    // to us, and we happen to download them from different peers (we wouldn't have known that these\n+    // 2 transactions are related). We still want to find 1p1c packages then.\n+    //\n+    // If we start tracking all announcers of orphans, we can restrict this logic to parent + child\n+    // pairs in which both were provided by the same peer, i.e. delete this step.\n+    if (!tx_orphan) {\n+        const auto cpfp_candidates_different_peer{m_orphanage.GetChildrenFromDifferentPeer(ptx, nodeid)};\n+\n+        // Find the first 1p1c that hasn't already been rejected. We randomize the order to not\n+        // create a bias that attackers can use to delay package acceptance.\n+        //\n+        // Create a random permutation of the indices.\n+        std::vector<size_t> tx_indices(cpfp_candidates_different_peer.size());\n+        std::iota(tx_indices.begin(), tx_indices.end(), 0);\n+        Shuffle(tx_indices.begin(), tx_indices.end(), m_rng);\n+\n+        for (const auto index : tx_indices) {\n+            // If we already tried a package and failed for any reason, the combined hash was\n+            // cached in m_recent_rejects_reconsiderable.\n+            Package maybe_cpfp_package{ptx, cpfp_candidates_different_peer.at(index).first};\n+            if (!m_recent_rejects_reconsiderable.contains(GetPackageHash(maybe_cpfp_package))) {\n+                tx_orphan = cpfp_candidates_different_peer.at(index).first;\n+                orphan_sender = cpfp_candidates_different_peer.at(index).second;\n+                break;\n+            }\n+        }\n+    }\n+\n+    if (tx_orphan) {\n+        const Package package_1p1c{ptx, tx_orphan};\n+        const std::vector<NodeId> senders{nodeid, orphan_sender};\n+        const auto package_result{ProcessNewPackage(m_chainman.ActiveChainstate(), m_mempool, package_1p1c, /*test_accept=*/false, /*client_maxfeerate=*/std::nullopt)};\n+        LogDebug(BCLog::TXPACKAGES, \"package evaluation for parent %s (wtxid=%s) + child %s (wtxid=%s) in orphanage: %s\\n\",",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 148,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "bb3bf0a39c036fbd94b99ed7002db7d9bdf0a1d6",
      "in_reply_to_id": 1576164670,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Ok, marking this as resolved",
      "created_at": "2024-04-24T14:00:21Z",
      "updated_at": "2024-04-24T14:00:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1577947487",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1577947487"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3335,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1577949702",
      "pull_request_review_id": 2019973872,
      "id": 1577949702,
      "node_id": "PRRC_kwDOABII585eDZoG",
      "diff_hunk": "@@ -0,0 +1,348 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test opportunistic 1p1c package submission logic.\n+\"\"\"\n+\n+from decimal import Decimal\n+import time\n+from test_framework.messages import (\n+    CInv,\n+    CTxInWitness,\n+    MSG_WTX,\n+    msg_inv,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    fill_mempool,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+\n+def cleanup(func):\n+    def wrapper(self, *args, **kwargs):\n+        try:\n+            func(self, *args, **kwargs)\n+        finally:\n+            self.nodes[0].disconnect_p2ps()\n+            # Do not clear the node's mempool, as each test requires mempool min feerate > min\n+            # relay feerate. However, do check that this is the case.\n+            assert self.nodes[0].getmempoolinfo()[\"mempoolminfee\"] > self.nodes[0].getnetworkinfo()[\"relayfee\"]\n+            # Ensure we do not try to spend the same UTXOs in subsequent tests, as they will look like RBF attempts.\n+            self.wallet.rescan_utxos(include_mempool=True)\n+    return wrapper\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+        ]]\n+        self.supports_cli = False\n+\n+    @cleanup\n+    def test_basic_child_then_parent(self):\n+        node = self.nodes[0]\n+        self.log.info(\"Check that opportunistic 1p1c logic works when child is received before parent\")\n+\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first (perhaps the low feerate parent didn't meet feefilter or the requests were sent to different nodes). It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. Sender relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 4. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+        node.disconnect_p2ps()\n+\n+    @cleanup\n+    def test_basic_parent_then_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=1, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=2, connection_type=\"outbound-full-relay\")\n+\n+        # 1. Parent is relayed first. It is too low feerate.\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer_sender.wait_for_getdata([parent_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer_ignored, check that it is ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+\n+        # 2. Child is relayed next. It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 3. Node requests the missing parent by txid.\n+        # It should do so even if it has previously rejected that parent for being too low feerate.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 4. Sender re-relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 5. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+    @cleanup\n+    def test_low_and_high_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        # This feerate is above mempoolminfee, but not enough to also bump the low feerate parent.\n+        feerate_just_above = node.getmempoolinfo()[\"mempoolminfee\"]\n+        med_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=feerate_just_above)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=3, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=4, connection_type=\"outbound-full-relay\")\n+\n+        self.log.info(\"Check that tx caches low fee parent + low fee child package rejections\")\n+\n+        # 1. Send parent, rejected for being low feerate.\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer_sender.wait_for_getdata([parent_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer_ignored, check that it is ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+\n+        # 2. Send an (orphan) child that has a higher feerate, but not enough to bump the parent.\n+        low_child_wtxid_int = int(med_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([low_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(med_fee_child[\"tx\"]))\n+\n+        # 3. Node requests the orphan's missing parent.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 4. The low parent + low child are submitted as a package. They are not accepted due to low package feerate.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+        assert med_fee_child[\"txid\"] not in node.getrawmempool()\n+\n+        # If peer_ignored announces the low feerate child, it should be ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+        # If either peer sends the parent again, package evaluation should not be attempted\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        peer_ignored.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 5. Send the high feerate (orphan) child\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 6. Node requests the orphan's parent, even though it has already been rejected, both by\n+        # itself and with a child. This is necessary, otherwise high_fee_child can be censored.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 7. The low feerate parent + high feerate child are submitted as a package.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 8. Both transactions should now be in mempool\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+    @cleanup\n+    def test_orphan_consensus_failure(self):\n+        self.log.info(\"Check opportunistic 1p1c logic with consensus-invalid orphan causes disconnect of the correct peer\")\n+        node = self.nodes[0]\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        coin = low_fee_parent[\"new_utxo\"]\n+        address = node.get_deterministic_priv_key().address\n+        # Create raw transaction spending the parent, but with no signature (a consensus error).\n+        hex_orphan_no_sig = node.createrawtransaction([{\"txid\": coin[\"txid\"], \"vout\": coin[\"vout\"]}], {address : coin[\"value\"] - Decimal(\"0.0001\")})\n+        tx_orphan_bad_wit = tx_from_hex(hex_orphan_no_sig)\n+        tx_orphan_bad_wit.wit.vtxinwit.append(CTxInWitness())\n+        tx_orphan_bad_wit.wit.vtxinwit[0].scriptWitness.stack = [b'garbage']\n+\n+        bad_orphan_sender = node.add_p2p_connection(P2PInterface())\n+        parent_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first. It is missing an input.\n+        child_wtxid_int = int(tx_orphan_bad_wit.getwtxid(), 16)\n+        bad_orphan_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=child_wtxid_int)]))\n+        bad_orphan_sender.wait_for_getdata([child_wtxid_int])\n+        bad_orphan_sender.send_and_ping(msg_tx(tx_orphan_bad_wit))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        bad_orphan_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. A different peer relays the parent. Parent+Child are evaluated as a package and rejected.\n+        parent_sender.send_message(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 4. Transactions should not be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] not in node_mempool\n+        assert tx_orphan_bad_wit.rehash() not in node_mempool\n+\n+        # 5. Peer that sent a consensus-invalid transaction should be disconnected.\n+        bad_orphan_sender.wait_for_disconnect()\n+\n+        # The peer that didn't provide the orphan should not be disconnected.\n+        parent_sender.sync_with_ping()\n+\n+    @cleanup\n+    def test_parent_consensus_failure(self):\n+        self.log.info(\"Check opportunistic 1p1c logic with consensus-invalid parent causes disconnect of the correct peer\")\n+        node = self.nodes[0]\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+\n+        # Create invalid version of parent with a bad signature.\n+        tx_parent_bad_wit = tx_from_hex(low_fee_parent[\"hex\"])\n+        tx_parent_bad_wit.wit.vtxinwit.append(CTxInWitness())\n+        tx_parent_bad_wit.wit.vtxinwit[0].scriptWitness.stack = [b'garbage']\n+\n+        package_sender = node.add_p2p_connection(P2PInterface())\n+        fake_parent_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first. It is missing an input.\n+        child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        package_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=child_wtxid_int)]))\n+        package_sender.wait_for_getdata([child_wtxid_int])\n+        package_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(tx_parent_bad_wit.rehash(), 16)\n+        package_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. A different node relays the parent. The parent is first evaluated by itself and\n+        # rejected for being too low feerate. Then it is evaluated as a package and, after passing\n+        # feerate checks, rejected for having a bad signature (consensus error).\n+        fake_parent_sender.send_message(msg_tx(tx_parent_bad_wit))\n+\n+        # 4. Transactions should not be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert tx_parent_bad_wit.rehash() not in node_mempool\n+        assert high_fee_child[\"txid\"] not in node_mempool\n+\n+        # 5. Peer sent a consensus-invalid transaction.\n+        fake_parent_sender.wait_for_disconnect()\n+\n+        self.log.info(\"Check that fake parent does not cause orphan to be deleted and real package can still be submitted\")\n+        # 6. Child-sending should not have been punished and the orphan should remain in orphanage.\n+        # It can send the \"real\" parent transaction, and the package is accepted.\n+        package_sender.sync_with_ping()\n+        package_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+    @cleanup\n+    def test_multiple_parents(self):\n+        self.log.info(\"Check that node does not request more than 1 previously-rejected low feerate parent\")\n+\n+        node = self.nodes[0]\n+        node.setmocktime(int(time.time()))\n+\n+        # 2-parent-1-child package where both parents are below mempool min feerate\n+        parent_low_1 = self.wallet_nonsegwit.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        parent_low_2 = self.wallet_nonsegwit.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        child_bumping = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[parent_low_1[\"new_utxo\"], parent_low_2[\"new_utxo\"]],\n+            fee_per_output=999*parent_low_1[\"tx\"].get_vsize(),\n+        )\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=4, connection_type=\"outbound-full-relay\")\n+\n+        # 1. Send both parents. Each should be rejected for being too low feerate.\n+        # Send unsolicited so that we can later check that no \"getdata\" was ever received.\n+        peer_sender.send_and_ping(msg_tx(parent_low_1[\"tx\"]))\n+        peer_sender.send_and_ping(msg_tx(parent_low_2[\"tx\"]))\n+\n+        # parent_low_1 and parent_low_2 are rejected for being low feerate.\n+        assert parent_low_1[\"txid\"] not in node.getrawmempool()\n+        assert parent_low_2[\"txid\"] not in node.getrawmempool()\n+\n+        # 2. Send child.\n+        peer_sender.send_and_ping(msg_tx(child_bumping[\"tx\"]))\n+\n+        # 3. Node should not request any parents, as it should recognize that it will not accept\n+        # multi-parent-1-child packages.\n+        node.bumpmocktime(60)\n+        peer_sender.sync_with_ping()\n+        assert \"getdata\" not in peer_sender.last_message\n+\n+\n+    def run_test(self):",
      "path": "test/functional/p2p_opportunistic_1p1c.py",
      "position": 377,
      "original_position": 317,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "55b1280c52af81aa6ea0860799fa16da49f51447",
      "in_reply_to_id": 1576479584,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Added a similar test",
      "created_at": "2024-04-24T14:01:45Z",
      "updated_at": "2024-04-24T14:01:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1577949702",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1577949702"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 377,
      "original_line": 377,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1577950806",
      "pull_request_review_id": 2019975582,
      "id": 1577950806,
      "node_id": "PRRC_kwDOABII585eDZ5W",
      "diff_hunk": "@@ -0,0 +1,348 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test opportunistic 1p1c package submission logic.\n+\"\"\"\n+\n+from decimal import Decimal\n+import time\n+from test_framework.messages import (\n+    CInv,\n+    CTxInWitness,\n+    MSG_WTX,\n+    msg_inv,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    fill_mempool,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+\n+def cleanup(func):\n+    def wrapper(self, *args, **kwargs):\n+        try:\n+            func(self, *args, **kwargs)\n+        finally:\n+            self.nodes[0].disconnect_p2ps()\n+            # Do not clear the node's mempool, as each test requires mempool min feerate > min\n+            # relay feerate. However, do check that this is the case.\n+            assert self.nodes[0].getmempoolinfo()[\"mempoolminfee\"] > self.nodes[0].getnetworkinfo()[\"relayfee\"]\n+            # Ensure we do not try to spend the same UTXOs in subsequent tests, as they will look like RBF attempts.\n+            self.wallet.rescan_utxos(include_mempool=True)\n+    return wrapper\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+        ]]\n+        self.supports_cli = False\n+\n+    @cleanup\n+    def test_basic_child_then_parent(self):\n+        node = self.nodes[0]\n+        self.log.info(\"Check that opportunistic 1p1c logic works when child is received before parent\")\n+\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first (perhaps the low feerate parent didn't meet feefilter or the requests were sent to different nodes). It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. Sender relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 4. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+        node.disconnect_p2ps()\n+\n+    @cleanup\n+    def test_basic_parent_then_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=1, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=2, connection_type=\"outbound-full-relay\")\n+\n+        # 1. Parent is relayed first. It is too low feerate.\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer_sender.wait_for_getdata([parent_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer_ignored, check that it is ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+\n+        # 2. Child is relayed next. It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 3. Node requests the missing parent by txid.\n+        # It should do so even if it has previously rejected that parent for being too low feerate.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 4. Sender re-relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 5. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+    @cleanup\n+    def test_low_and_high_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        # This feerate is above mempoolminfee, but not enough to also bump the low feerate parent.\n+        feerate_just_above = node.getmempoolinfo()[\"mempoolminfee\"]\n+        med_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=feerate_just_above)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=3, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=4, connection_type=\"outbound-full-relay\")\n+\n+        self.log.info(\"Check that tx caches low fee parent + low fee child package rejections\")\n+\n+        # 1. Send parent, rejected for being low feerate.\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer_sender.wait_for_getdata([parent_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer_ignored, check that it is ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+\n+        # 2. Send an (orphan) child that has a higher feerate, but not enough to bump the parent.\n+        low_child_wtxid_int = int(med_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([low_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(med_fee_child[\"tx\"]))\n+\n+        # 3. Node requests the orphan's missing parent.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 4. The low parent + low child are submitted as a package. They are not accepted due to low package feerate.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+        assert med_fee_child[\"txid\"] not in node.getrawmempool()\n+\n+        # If peer_ignored announces the low feerate child, it should be ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+        # If either peer sends the parent again, package evaluation should not be attempted\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        peer_ignored.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 5. Send the high feerate (orphan) child\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 6. Node requests the orphan's parent, even though it has already been rejected, both by\n+        # itself and with a child. This is necessary, otherwise high_fee_child can be censored.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 7. The low feerate parent + high feerate child are submitted as a package.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 8. Both transactions should now be in mempool\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+    @cleanup\n+    def test_orphan_consensus_failure(self):\n+        self.log.info(\"Check opportunistic 1p1c logic with consensus-invalid orphan causes disconnect of the correct peer\")\n+        node = self.nodes[0]\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        coin = low_fee_parent[\"new_utxo\"]\n+        address = node.get_deterministic_priv_key().address\n+        # Create raw transaction spending the parent, but with no signature (a consensus error).\n+        hex_orphan_no_sig = node.createrawtransaction([{\"txid\": coin[\"txid\"], \"vout\": coin[\"vout\"]}], {address : coin[\"value\"] - Decimal(\"0.0001\")})\n+        tx_orphan_bad_wit = tx_from_hex(hex_orphan_no_sig)\n+        tx_orphan_bad_wit.wit.vtxinwit.append(CTxInWitness())\n+        tx_orphan_bad_wit.wit.vtxinwit[0].scriptWitness.stack = [b'garbage']\n+\n+        bad_orphan_sender = node.add_p2p_connection(P2PInterface())\n+        parent_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first. It is missing an input.\n+        child_wtxid_int = int(tx_orphan_bad_wit.getwtxid(), 16)\n+        bad_orphan_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=child_wtxid_int)]))\n+        bad_orphan_sender.wait_for_getdata([child_wtxid_int])\n+        bad_orphan_sender.send_and_ping(msg_tx(tx_orphan_bad_wit))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        bad_orphan_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. A different peer relays the parent. Parent+Child are evaluated as a package and rejected.\n+        parent_sender.send_message(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 4. Transactions should not be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] not in node_mempool\n+        assert tx_orphan_bad_wit.rehash() not in node_mempool\n+\n+        # 5. Peer that sent a consensus-invalid transaction should be disconnected.\n+        bad_orphan_sender.wait_for_disconnect()\n+\n+        # The peer that didn't provide the orphan should not be disconnected.\n+        parent_sender.sync_with_ping()\n+\n+    @cleanup\n+    def test_parent_consensus_failure(self):\n+        self.log.info(\"Check opportunistic 1p1c logic with consensus-invalid parent causes disconnect of the correct peer\")\n+        node = self.nodes[0]\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+\n+        # Create invalid version of parent with a bad signature.\n+        tx_parent_bad_wit = tx_from_hex(low_fee_parent[\"hex\"])\n+        tx_parent_bad_wit.wit.vtxinwit.append(CTxInWitness())\n+        tx_parent_bad_wit.wit.vtxinwit[0].scriptWitness.stack = [b'garbage']\n+\n+        package_sender = node.add_p2p_connection(P2PInterface())\n+        fake_parent_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first. It is missing an input.\n+        child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        package_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=child_wtxid_int)]))\n+        package_sender.wait_for_getdata([child_wtxid_int])\n+        package_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(tx_parent_bad_wit.rehash(), 16)\n+        package_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. A different node relays the parent. The parent is first evaluated by itself and\n+        # rejected for being too low feerate. Then it is evaluated as a package and, after passing\n+        # feerate checks, rejected for having a bad signature (consensus error).\n+        fake_parent_sender.send_message(msg_tx(tx_parent_bad_wit))\n+\n+        # 4. Transactions should not be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert tx_parent_bad_wit.rehash() not in node_mempool\n+        assert high_fee_child[\"txid\"] not in node_mempool\n+\n+        # 5. Peer sent a consensus-invalid transaction.\n+        fake_parent_sender.wait_for_disconnect()\n+\n+        self.log.info(\"Check that fake parent does not cause orphan to be deleted and real package can still be submitted\")\n+        # 6. Child-sending should not have been punished and the orphan should remain in orphanage.\n+        # It can send the \"real\" parent transaction, and the package is accepted.\n+        package_sender.sync_with_ping()\n+        package_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+    @cleanup\n+    def test_multiple_parents(self):\n+        self.log.info(\"Check that node does not request more than 1 previously-rejected low feerate parent\")\n+\n+        node = self.nodes[0]\n+        node.setmocktime(int(time.time()))\n+\n+        # 2-parent-1-child package where both parents are below mempool min feerate\n+        parent_low_1 = self.wallet_nonsegwit.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        parent_low_2 = self.wallet_nonsegwit.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        child_bumping = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[parent_low_1[\"new_utxo\"], parent_low_2[\"new_utxo\"]],\n+            fee_per_output=999*parent_low_1[\"tx\"].get_vsize(),\n+        )\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=4, connection_type=\"outbound-full-relay\")\n+\n+        # 1. Send both parents. Each should be rejected for being too low feerate.\n+        # Send unsolicited so that we can later check that no \"getdata\" was ever received.\n+        peer_sender.send_and_ping(msg_tx(parent_low_1[\"tx\"]))\n+        peer_sender.send_and_ping(msg_tx(parent_low_2[\"tx\"]))\n+\n+        # parent_low_1 and parent_low_2 are rejected for being low feerate.\n+        assert parent_low_1[\"txid\"] not in node.getrawmempool()\n+        assert parent_low_2[\"txid\"] not in node.getrawmempool()\n+\n+        # 2. Send child.\n+        peer_sender.send_and_ping(msg_tx(child_bumping[\"tx\"]))\n+\n+        # 3. Node should not request any parents, as it should recognize that it will not accept\n+        # multi-parent-1-child packages.\n+        node.bumpmocktime(60)",
      "path": "test/functional/p2p_opportunistic_1p1c.py",
      "position": null,
      "original_position": 312,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "55b1280c52af81aa6ea0860799fa16da49f51447",
      "in_reply_to_id": 1576365857,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Added ",
      "created_at": "2024-04-24T14:02:24Z",
      "updated_at": "2024-04-24T14:02:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1577950806",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1577950806"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 312,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1578117743",
      "pull_request_review_id": 2019874263,
      "id": 1578117743,
      "node_id": "PRRC_kwDOABII585eECpv",
      "diff_hunk": "@@ -3195,6 +3210,140 @@ void PeerManagerImpl::ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, c\n     }\n }\n \n+void PeerManagerImpl::ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, const std::vector<NodeId>& senders)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    if (package_result.m_state.IsInvalid()) {\n+        m_recent_rejects_reconsiderable.insert(GetPackageHash(package));\n+    }\n+    // We currently only expect to process 1-parent-1-child packages. Remove if this changes.\n+    if (!Assume(package.size() == 2)) return;\n+\n+    // No package results to look through for PCKG_POLICY or PCKG_MEMPOOL_ERROR\n+    if (package_result.m_state.GetResult() == PackageValidationResult::PCKG_POLICY ||\n+        package_result.m_state.GetResult() == PackageValidationResult::PCKG_MEMPOOL_ERROR) return;\n+\n+    // Iterate backwards to erase in-package descendants from the orphanage before they become\n+    // relevant in AddChildrenToWorkSet.\n+    auto package_iter = package.rbegin();\n+    auto senders_iter = senders.rbegin();\n+    while (package_iter != package.rend()) {\n+        const auto& tx = *package_iter;\n+        const NodeId nodeid = *senders_iter;\n+        const auto it_result{package_result.m_tx_results.find(tx->GetWitnessHash())};\n+        if (Assume(it_result != package_result.m_tx_results.end())) {\n+            const auto& tx_result = it_result->second;\n+            switch (tx_result.m_result_type) {\n+                case MempoolAcceptResult::ResultType::VALID:\n+                {\n+                    Assume(tx_result.m_replaced_transactions.has_value());\n+                    std::list<CTransactionRef> empty_replacement_list;\n+                    ProcessValidTx(nodeid, tx, tx_result.m_replaced_transactions.value_or(empty_replacement_list));\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::INVALID:\n+                case MempoolAcceptResult::ResultType::DIFFERENT_WITNESS:\n+                {\n+                    // Don't add to vExtraTxnForCompact, as these transactions should have already been\n+                    // added there when added to the orphanage or rejected for TX_RECONSIDERABLE.\n+                    // This should be updated if package submission is ever used for transactions\n+                    // that haven't already been validated before.\n+                    ProcessInvalidTx(nodeid, tx, tx_result.m_state, /*maybe_add_extra_compact_tx=*/false);\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::MEMPOOL_ENTRY:\n+                {\n+                    // AlreadyHaveTx() should be catching transactions that are already in mempool.\n+                    Assume(false);\n+                    break;\n+                }\n+            }\n+        }\n+        package_iter++;\n+        // There should be a sender for each tx, but fall back to the last one otherwise.\n+        if (Assume(senders_iter != senders.rend())) senders_iter++;",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 80,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "bb3bf0a39c036fbd94b99ed7002db7d9bdf0a1d6",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: as alternative, could check at the beginning of the function if the sizes of `package` and `senders` match and return early if they don't (not sure how this function is used in the future if the 1p1c limit is lifted, but i guess a size mismatch should never happen, unless there is a bug at the call-site?). that would be slightly simpler to reason imho.",
      "created_at": "2024-04-24T15:42:21Z",
      "updated_at": "2024-04-24T16:19:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1578117743",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1578117743"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": 3266,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 3267,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1578122793",
      "pull_request_review_id": 2019874263,
      "id": 1578122793,
      "node_id": "PRRC_kwDOABII585eED4p",
      "diff_hunk": "@@ -3195,6 +3210,140 @@ void PeerManagerImpl::ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, c\n     }\n }\n \n+void PeerManagerImpl::ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, const std::vector<NodeId>& senders)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    if (package_result.m_state.IsInvalid()) {\n+        m_recent_rejects_reconsiderable.insert(GetPackageHash(package));\n+    }\n+    // We currently only expect to process 1-parent-1-child packages. Remove if this changes.\n+    if (!Assume(package.size() == 2)) return;\n+\n+    // No package results to look through for PCKG_POLICY or PCKG_MEMPOOL_ERROR\n+    if (package_result.m_state.GetResult() == PackageValidationResult::PCKG_POLICY ||\n+        package_result.m_state.GetResult() == PackageValidationResult::PCKG_MEMPOOL_ERROR) return;\n+\n+    // Iterate backwards to erase in-package descendants from the orphanage before they become\n+    // relevant in AddChildrenToWorkSet.\n+    auto package_iter = package.rbegin();\n+    auto senders_iter = senders.rbegin();\n+    while (package_iter != package.rend()) {\n+        const auto& tx = *package_iter;\n+        const NodeId nodeid = *senders_iter;\n+        const auto it_result{package_result.m_tx_results.find(tx->GetWitnessHash())};\n+        if (Assume(it_result != package_result.m_tx_results.end())) {\n+            const auto& tx_result = it_result->second;\n+            switch (tx_result.m_result_type) {\n+                case MempoolAcceptResult::ResultType::VALID:\n+                {\n+                    Assume(tx_result.m_replaced_transactions.has_value());\n+                    std::list<CTransactionRef> empty_replacement_list;\n+                    ProcessValidTx(nodeid, tx, tx_result.m_replaced_transactions.value_or(empty_replacement_list));\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::INVALID:\n+                case MempoolAcceptResult::ResultType::DIFFERENT_WITNESS:\n+                {\n+                    // Don't add to vExtraTxnForCompact, as these transactions should have already been\n+                    // added there when added to the orphanage or rejected for TX_RECONSIDERABLE.\n+                    // This should be updated if package submission is ever used for transactions\n+                    // that haven't already been validated before.\n+                    ProcessInvalidTx(nodeid, tx, tx_result.m_state, /*maybe_add_extra_compact_tx=*/false);\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::MEMPOOL_ENTRY:\n+                {\n+                    // AlreadyHaveTx() should be catching transactions that are already in mempool.\n+                    Assume(false);\n+                    break;\n+                }\n+            }\n+        }\n+        package_iter++;\n+        // There should be a sender for each tx, but fall back to the last one otherwise.\n+        if (Assume(senders_iter != senders.rend())) senders_iter++;\n+    }\n+}\n+\n+void PeerManagerImpl::MaybeProcess1P1CPackage(const CTransactionRef& ptx, NodeId nodeid)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    const auto& parent_txid{ptx->GetHash()};\n+    const auto& parent_wtxid{ptx->GetWitnessHash()};\n+\n+    CTransactionRef tx_orphan{nullptr};\n+    NodeId orphan_sender{-1};\n+    Assume(m_recent_rejects_reconsiderable.contains(parent_wtxid.ToUint256()));\n+\n+    // Prefer children from this peer. This helps prevent censorship attempts in which an attacker\n+    // sends lots of fake children for the parent, and we (unluckily) keep selecting the fake\n+    // children instead of the real one provided by the honest peer.\n+    const auto cpfp_candidates_same_peer{m_orphanage.GetChildrenFromSamePeer(ptx, nodeid)};\n+\n+    // These children should be sorted from most newest to oldest. In the (probably uncommon) case\n+    // of children that replace each other, this helps us accept the highest feerate (probably the\n+    // most recent) one efficiently.\n+    for (const auto& child : cpfp_candidates_same_peer) {\n+        Package maybe_cpfp_package{ptx, child};\n+        if (!m_recent_rejects_reconsiderable.contains(GetPackageHash(maybe_cpfp_package))) {\n+            tx_orphan = child;\n+            orphan_sender = nodeid;\n+            break;\n+        }\n+    }\n+\n+    // If no suitable candidate from the same peer is found, also try children that were provided by\n+    // a different peer. This is useful because sometimes multiple peers announce both transactions\n+    // to us, and we happen to download them from different peers (we wouldn't have known that these\n+    // 2 transactions are related). We still want to find 1p1c packages then.\n+    //\n+    // If we start tracking all announcers of orphans, we can restrict this logic to parent + child\n+    // pairs in which both were provided by the same peer, i.e. delete this step.\n+    if (!tx_orphan) {\n+        const auto cpfp_candidates_different_peer{m_orphanage.GetChildrenFromDifferentPeer(ptx, nodeid)};\n+\n+        // Find the first 1p1c that hasn't already been rejected. We randomize the order to not\n+        // create a bias that attackers can use to delay package acceptance.\n+        //\n+        // Create a random permutation of the indices.\n+        std::vector<size_t> tx_indices(cpfp_candidates_different_peer.size());\n+        std::iota(tx_indices.begin(), tx_indices.end(), 0);\n+        Shuffle(tx_indices.begin(), tx_indices.end(), m_rng);\n+\n+        for (const auto index : tx_indices) {\n+            // If we already tried a package and failed for any reason, the combined hash was\n+            // cached in m_recent_rejects_reconsiderable.\n+            Package maybe_cpfp_package{ptx, cpfp_candidates_different_peer.at(index).first};\n+            if (!m_recent_rejects_reconsiderable.contains(GetPackageHash(maybe_cpfp_package))) {\n+                tx_orphan = cpfp_candidates_different_peer.at(index).first;\n+                orphan_sender = cpfp_candidates_different_peer.at(index).second;\n+                break;\n+            }",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 140,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "bb3bf0a39c036fbd94b99ed7002db7d9bdf0a1d6",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "refactoring nit to avoid multiple accesses in `cpfp_candidates_different_peer` (feel free to ignore):\r\n```suggestion\r\n            const auto [candidate_child, candidate_peer] = cpfp_candidates_different_peer.at(index);\r\n            const Package maybe_cpfp_package{ptx, candidate_child};\r\n             if (!m_recent_rejects_reconsiderable.contains(GetPackageHash(maybe_cpfp_package))) {\r\n                tx_orphan = candidate_child;\r\n                orphan_sender = candidate_peer;\r\n                break;\r\n            }\r\n```",
      "created_at": "2024-04-24T15:45:51Z",
      "updated_at": "2024-04-24T16:19:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1578122793",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1578122793"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": 3322,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 3327,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1578179082",
      "pull_request_review_id": 2019874263,
      "id": 1578179082,
      "node_id": "PRRC_kwDOABII585eERoK",
      "diff_hunk": "@@ -0,0 +1,175 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test that 1p1c package submission allows a 1p1c package to propagate in a \"network\" of nodes. Send\n+various packages from different nodes on a network in which some nodes have already received some of\n+the transactions (and submitted them to mempool, kept them as orphans or rejected them as\n+too-low-feerate transactions). The packages should be received and accepted by all nodes.\n+\"\"\"\n+\n+from decimal import Decimal\n+from math import ceil\n+\n+from test_framework.messages import (\n+    msg_tx,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    fill_mempool,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 4\n+        # hugely speeds up the test, as it involves multiple hops of tx relay.\n+        self.noban_tx_relay = True\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+        ]] * self.num_nodes\n+        self.supports_cli = False\n+\n+    def raise_network_minfee(self):\n+        filler_wallet = MiniWallet(self.nodes[0])\n+        fill_mempool(self, self.nodes[0], filler_wallet)\n+\n+        self.log.debug(\"Wait for the network to sync mempools\")\n+        self.sync_mempools()\n+\n+        self.log.debug(\"Check that all nodes' mempool minimum feerates are above min relay feerate\")\n+        for node in self.nodes:\n+            assert_equal(node.getmempoolinfo()['minrelaytxfee'], FEERATE_1SAT_VB)\n+            assert_greater_than(node.getmempoolinfo()['mempoolminfee'], FEERATE_1SAT_VB)\n+\n+    def create_basic_1p1c(self, wallet):\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+        package_hex_basic = [low_fee_parent[\"hex\"], high_fee_child[\"hex\"]]\n+        return package_hex_basic, low_fee_parent[\"tx\"], high_fee_child[\"tx\"]\n+\n+    def create_package_2outs(self, wallet):\n+        # First create a tester tx to see the vsize, and then adjust the fees\n+        placeholder_fee = 100000\n+        utxo_for_2outs = wallet.get_utxo(confirmed_only=True)\n+\n+        low_fee_parent_2outs_tester = wallet.create_self_transfer_multi(\n+            utxos_to_spend=[utxo_for_2outs],\n+            num_outputs=2,\n+            fee_per_output=placeholder_fee,\n+            confirmed_only=True\n+        )\n+\n+        # Target 1sat/vB so the number of satoshis is equal to the vsize.\n+        # Round up. The goal is to be between min relay feerate and mempool min feerate.\n+        fee_2outs = ceil(low_fee_parent_2outs_tester[\"tx\"].get_vsize() / 2)\n+\n+        low_fee_parent_2outs = wallet.create_self_transfer_multi(\n+            utxos_to_spend=[utxo_for_2outs],\n+            num_outputs=2,\n+            fee_per_output=fee_2outs,\n+        )\n+\n+        # Now create the child\n+        high_fee_child_2outs = wallet.create_self_transfer_multi(\n+            utxos_to_spend=low_fee_parent_2outs[\"new_utxos\"][::-1],\n+            fee_per_output=fee_2outs*100,\n+        )\n+        return [low_fee_parent_2outs[\"hex\"], high_fee_child_2outs[\"hex\"]], low_fee_parent_2outs[\"tx\"], high_fee_child_2outs[\"tx\"]\n+\n+    def create_package_2p1c(self, wallet):\n+        parent1 = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB*10, confirmed_only=True)\n+        parent2 = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB*20, confirmed_only=True)\n+        child = wallet.create_self_transfer_multi(\n+            utxos_to_spend=[parent1[\"new_utxo\"], parent2[\"new_utxo\"]],\n+            fee_per_output=999*parent1[\"tx\"].get_vsize(),\n+        )\n+        return [parent1[\"hex\"], parent2[\"hex\"], child[\"hex\"]], parent1[\"tx\"], parent2[\"tx\"], child[\"tx\"]\n+\n+    def create_packages(self):\n+        # 1: Basic 1-parent-1-child package, parent 1sat/vB, child 999sat/vB\n+        package_hex_1, parent_1, child_1 = self.create_basic_1p1c(self.wallet)\n+\n+        # 2: same as 1, parent's txid is the same as its wtxid.\n+        package_hex_2, parent_2, child_2 = self.create_basic_1p1c(self.wallet_nonsegwit)\n+\n+        # 3: 2-parent-1-child package. Both parents are above mempool min feerate. No package submission happens.\n+        # We require packages to be child-with-unconfirmed-parents and only allow 1-parent-1-child packages.\n+        package_hex_3, parent_31, parent_32, child_3 = self.create_package_2p1c(self.wallet)\n+\n+        # 4: parent + child package where the child spends 2 different outputs from the parent.\n+        package_hex_4, parent_4, child_4 = self.create_package_2outs(self.wallet)\n+\n+        # Assemble return results\n+        packages_to_submit = []\n+        txns_to_send = [[]] * self.num_nodes\n+\n+        packages_to_submit.append(package_hex_1)\n+        packages_to_submit.append(package_hex_2)\n+        packages_to_submit.append(package_hex_3)\n+        packages_to_submit.append(package_hex_4)\n+\n+        # node0: sender\n+        # node1: pre-received the children (orphan)\n+        # node3: pre-received the parents (too low fee)\n+        # All nodes receive high_parent_51 ahead of time.",
      "path": "test/functional/p2p_1p1c_network.py",
      "position": null,
      "original_position": 129,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "30c9e6bc4e9f8b8b606e55435dc3f743cb2dd670",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n        # All nodes receive parent_31 ahead of time.\r\n```",
      "created_at": "2024-04-24T16:17:11Z",
      "updated_at": "2024-04-24T16:19:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1578179082",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1578179082"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 129,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1578202070",
      "pull_request_review_id": 2020396119,
      "id": 1578202070,
      "node_id": "PRRC_kwDOABII585eEXPW",
      "diff_hunk": "@@ -3195,6 +3210,140 @@ void PeerManagerImpl::ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, c\n     }\n }\n \n+void PeerManagerImpl::ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, const std::vector<NodeId>& senders)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    if (package_result.m_state.IsInvalid()) {\n+        m_recent_rejects_reconsiderable.insert(GetPackageHash(package));\n+    }\n+    // We currently only expect to process 1-parent-1-child packages. Remove if this changes.\n+    if (!Assume(package.size() == 2)) return;\n+\n+    // No package results to look through for PCKG_POLICY or PCKG_MEMPOOL_ERROR\n+    if (package_result.m_state.GetResult() == PackageValidationResult::PCKG_POLICY ||\n+        package_result.m_state.GetResult() == PackageValidationResult::PCKG_MEMPOOL_ERROR) return;\n+\n+    // Iterate backwards to erase in-package descendants from the orphanage before they become\n+    // relevant in AddChildrenToWorkSet.\n+    auto package_iter = package.rbegin();\n+    auto senders_iter = senders.rbegin();\n+    while (package_iter != package.rend()) {\n+        const auto& tx = *package_iter;\n+        const NodeId nodeid = *senders_iter;\n+        const auto it_result{package_result.m_tx_results.find(tx->GetWitnessHash())};\n+        if (Assume(it_result != package_result.m_tx_results.end())) {\n+            const auto& tx_result = it_result->second;\n+            switch (tx_result.m_result_type) {\n+                case MempoolAcceptResult::ResultType::VALID:\n+                {\n+                    Assume(tx_result.m_replaced_transactions.has_value());\n+                    std::list<CTransactionRef> empty_replacement_list;\n+                    ProcessValidTx(nodeid, tx, tx_result.m_replaced_transactions.value_or(empty_replacement_list));\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::INVALID:\n+                case MempoolAcceptResult::ResultType::DIFFERENT_WITNESS:\n+                {\n+                    // Don't add to vExtraTxnForCompact, as these transactions should have already been\n+                    // added there when added to the orphanage or rejected for TX_RECONSIDERABLE.\n+                    // This should be updated if package submission is ever used for transactions\n+                    // that haven't already been validated before.\n+                    ProcessInvalidTx(nodeid, tx, tx_result.m_state, /*maybe_add_extra_compact_tx=*/false);\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::MEMPOOL_ENTRY:\n+                {\n+                    // AlreadyHaveTx() should be catching transactions that are already in mempool.\n+                    Assume(false);\n+                    break;\n+                }\n+            }\n+        }\n+        package_iter++;\n+        // There should be a sender for each tx, but fall back to the last one otherwise.\n+        if (Assume(senders_iter != senders.rend())) senders_iter++;",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 80,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "bb3bf0a39c036fbd94b99ed7002db7d9bdf0a1d6",
      "in_reply_to_id": 1578117743,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I think we'd want to make sure that even if we had a bad `senders` vector we would still call `ProcessValidTx` / `ProcessInvalidTx` (seems kind of bad not to). Maybe a better approach is to use -1 when we don't know what it is - I do realize we're not handling the empty vector case.\r\n\r\n(Yeah maybe this is moot as the 1 caller should always make `senders` properly...)",
      "created_at": "2024-04-24T16:35:04Z",
      "updated_at": "2024-04-24T16:35:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1578202070",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1578202070"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": 3266,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 3267,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1578202506",
      "pull_request_review_id": 2020396119,
      "id": 1578202506,
      "node_id": "PRRC_kwDOABII585eEXWK",
      "diff_hunk": "@@ -40,6 +43,92 @@ inline CTransactionRef create_placeholder_tx(size_t num_inputs, size_t num_outpu\n     return MakeTransactionRef(mtx);\n }\n \n+// Create a Wtxid from a hex string\n+inline Wtxid WtxidFromString(std::string_view str)\n+{\n+    return Wtxid::FromUint256(uint256S(str.data()));\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(package_hash_tests, TestChain100Setup)\n+{\n+    // Random real segwit transaction\n+    DataStream stream_1{\n+        ParseHex(\"02000000000101964b8aa63509579ca6086e6012eeaa4c2f4dd1e283da29b67c8eea38b3c6fd220000000000fdffffff0294c618000000000017a9145afbbb42f4e83312666d0697f9e66259912ecde38768fa2c0000000000160014897388a0889390fd0e153a22bb2cf9d8f019faf50247304402200547406380719f84d68cf4e96cc3e4a1688309ef475b150be2b471c70ea562aa02206d255f5acc40fd95981874d77201d2eb07883657ce1c796513f32b6079545cdf0121023ae77335cefcb5ab4c1dc1fb0d2acfece184e593727d7d5906c78e564c7c11d125cf0c00\"),\n+    };\n+    CTransaction tx_1(deserialize, TX_WITH_WITNESS, stream_1);\n+    CTransactionRef ptx_1{MakeTransactionRef(tx_1)};\n+\n+    // Random real nonsegwit transaction\n+    DataStream stream_2{\n+        ParseHex(\"01000000010b26e9b7735eb6aabdf358bab62f9816a21ba9ebdb719d5299e88607d722c190000000008b4830450220070aca44506c5cef3a16ed519d7c3c39f8aab192c4e1c90d065f37b8a4af6141022100a8e160b856c2d43d27d8fba71e5aef6405b8643ac4cb7cb3c462aced7f14711a0141046d11fee51b0e60666d5049a9101a72741df480b96ee26488a4d3466b95c9a40ac5eeef87e10a5cd336c19a84565f80fa6c547957b7700ff4dfbdefe76036c339ffffffff021bff3d11000000001976a91404943fdd508053c75000106d3bc6e2754dbcff1988ac2f15de00000000001976a914a266436d2965547608b9e15d9032a7b9d64fa43188ac00000000\"),\n+    };\n+    CTransaction tx_2(deserialize, TX_WITH_WITNESS, stream_2);\n+    CTransactionRef ptx_2{MakeTransactionRef(tx_2)};\n+\n+    // Random real segwit transaction\n+    DataStream stream_3{\n+        ParseHex(\"0200000000010177862801f77c2c068a70372b4c435ef8dd621291c36a64eb4dd491f02218f5324600000000fdffffff014a0100000000000022512035ea312034cfac01e956a269f3bf147f569c2fbb00180677421262da042290d803402be713325ff285e66b0380f53f2fae0d0fb4e16f378a440fed51ce835061437566729d4883bc917632f3cff474d6384bc8b989961a1d730d4a87ed38ad28bd337b20f1d658c6c138b1c312e072b4446f50f01ae0da03a42e6274f8788aae53416a7fac0063036f7264010118746578742f706c61696e3b636861727365743d7574662d3800357b2270223a226272632d3230222c226f70223a226d696e74222c227469636b223a224342414c222c22616d74223a2236393639227d6821c1f1d658c6c138b1c312e072b4446f50f01ae0da03a42e6274f8788aae53416a7f00000000\"),\n+    };\n+    CTransaction tx_3(deserialize, TX_WITH_WITNESS, stream_3);\n+    CTransactionRef ptx_3{MakeTransactionRef(tx_3)};\n+\n+    // It's easy to see that wtxids are sorted in lexicographical order:\n+    Wtxid wtxid_1{WtxidFromString(\"0x85cd1a31eb38f74ed5742ec9cb546712ab5aaf747de28a9168b53e846cbda17f\")};\n+    Wtxid wtxid_2{WtxidFromString(\"0xb4749f017444b051c44dfd2720e88f314ff94f3dd6d56d40ef65854fcd7fff6b\")};\n+    Wtxid wtxid_3{WtxidFromString(\"0xe065bac15f62bb4e761d761db928ddee65a47296b2b776785abb912cdec474e3\")};\n+    BOOST_CHECK_EQUAL(tx_1.GetWitnessHash(), wtxid_1);\n+    BOOST_CHECK_EQUAL(tx_2.GetWitnessHash(), wtxid_2);\n+    BOOST_CHECK_EQUAL(tx_3.GetWitnessHash(), wtxid_3);\n+\n+    BOOST_CHECK(wtxid_1.GetHex() < wtxid_2.GetHex());\n+    BOOST_CHECK(wtxid_2.GetHex() < wtxid_3.GetHex());\n+\n+    // The txids are not (we want to test that sorting and hashing use wtxid, not txid):\n+    Txid txid_1{TxidFromString(\"0xbd0f71c1d5e50589063e134fad22053cdae5ab2320db5bf5e540198b0b5a4e69\")};\n+    Txid txid_2{TxidFromString(\"0xb4749f017444b051c44dfd2720e88f314ff94f3dd6d56d40ef65854fcd7fff6b\")};\n+    Txid txid_3{TxidFromString(\"0xee707be5201160e32c4fc715bec227d1aeea5940fb4295605e7373edce3b1a93\")};\n+    BOOST_CHECK_EQUAL(tx_1.GetHash(), txid_1);\n+    BOOST_CHECK_EQUAL(tx_2.GetHash(), txid_2);\n+    BOOST_CHECK_EQUAL(tx_3.GetHash(), txid_3);\n+\n+    BOOST_CHECK(txid_2.GetHex() < txid_1.GetHex());\n+\n+    BOOST_CHECK(txid_1.ToUint256() != wtxid_1.ToUint256());\n+    BOOST_CHECK(txid_3.ToUint256() != wtxid_3.ToUint256());\n+\n+    // We are testing that both functions compare using GetHex() and not uint256.\n+    // (in this pair of wtxids, hex string order != uint256 order)\n+    BOOST_CHECK(wtxid_2 < wtxid_1);\n+    // (in this pair of wtxids, hex string order == uint256 order)\n+    BOOST_CHECK(wtxid_2 < wtxid_3);\n+\n+    // All permutations of the package containing ptx_1, ptx_2, ptx_3 have the same package hash\n+    std::vector<CTransactionRef> package_123{ptx_1, ptx_2, ptx_3};\n+    std::vector<CTransactionRef> package_132{ptx_1, ptx_3, ptx_2};\n+    std::vector<CTransactionRef> package_231{ptx_2, ptx_3, ptx_1};\n+    std::vector<CTransactionRef> package_213{ptx_2, ptx_1, ptx_3};\n+    std::vector<CTransactionRef> package_312{ptx_3, ptx_1, ptx_2};\n+    std::vector<CTransactionRef> package_321{ptx_3, ptx_2, ptx_1};\n+\n+    uint256 calculated_hash_123 = (HashWriter() << wtxid_1 << wtxid_2 << wtxid_3).GetSHA256();\n+\n+    uint256 hash_if_by_txid = (HashWriter() << wtxid_2 << wtxid_1 << wtxid_3).GetSHA256();\n+    BOOST_CHECK(hash_if_by_txid != calculated_hash_123);\n+\n+    uint256 hash_if_use_txid = (HashWriter() << txid_2 << txid_1 << txid_3).GetSHA256();\n+    BOOST_CHECK(hash_if_use_txid != calculated_hash_123);\n+\n+    uint256 hash_if_use_int_order = (HashWriter() << wtxid_2 << wtxid_1 << txid_3).GetSHA256();",
      "path": "src/test/txpackage_tests.cpp",
      "position": null,
      "original_position": 92,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "6edf8ec0c5616d7f1dd372c704f5e0a5b3416f83",
      "in_reply_to_id": 1577900718,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Yeah that's a typo :+1: ",
      "created_at": "2024-04-24T16:35:27Z",
      "updated_at": "2024-04-24T16:35:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1578202506",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1578202506"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 121,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1578402851",
      "pull_request_review_id": 2015631578,
      "id": 1578402851,
      "node_id": "PRRC_kwDOABII585eFIQj",
      "diff_hunk": "@@ -0,0 +1,175 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test that 1p1c package submission allows a 1p1c package to propagate in a \"network\" of nodes. Send\n+various packages from different nodes on a network in which some nodes have already received some of\n+the transactions (and submitted them to mempool, kept them as orphans or rejected them as\n+too-low-feerate transactions). The packages should be received and accepted by all nodes.\n+\"\"\"\n+\n+from decimal import Decimal\n+from math import ceil\n+\n+from test_framework.messages import (\n+    msg_tx,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    fill_mempool,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 4\n+        # hugely speeds up the test, as it involves multiple hops of tx relay.\n+        self.noban_tx_relay = True\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+        ]] * self.num_nodes\n+        self.supports_cli = False\n+\n+    def raise_network_minfee(self):\n+        filler_wallet = MiniWallet(self.nodes[0])\n+        fill_mempool(self, self.nodes[0], filler_wallet)\n+\n+        self.log.debug(\"Wait for the network to sync mempools\")\n+        self.sync_mempools()\n+\n+        self.log.debug(\"Check that all nodes' mempool minimum feerates are above min relay feerate\")\n+        for node in self.nodes:\n+            assert_equal(node.getmempoolinfo()['minrelaytxfee'], FEERATE_1SAT_VB)\n+            assert_greater_than(node.getmempoolinfo()['mempoolminfee'], FEERATE_1SAT_VB)\n+\n+    def create_basic_1p1c(self, wallet):\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+        package_hex_basic = [low_fee_parent[\"hex\"], high_fee_child[\"hex\"]]\n+        return package_hex_basic, low_fee_parent[\"tx\"], high_fee_child[\"tx\"]\n+\n+    def create_package_2outs(self, wallet):\n+        # First create a tester tx to see the vsize, and then adjust the fees\n+        placeholder_fee = 100000",
      "path": "test/functional/p2p_1p1c_network.py",
      "position": null,
      "original_position": 67,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "30c9e6bc4e9f8b8b606e55435dc3f743cb2dd670",
      "in_reply_to_id": null,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In 30c9e6bc4e9f8b8b606e55435dc3f743cb2dd670\r\n\r\nIs the placeholder fee needed? `create_self_transfer_multi` already has a default fee, and the value shouldn't matter, should it?",
      "created_at": "2024-04-24T19:25:33Z",
      "updated_at": "2024-04-25T13:25:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1578402851",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1578402851"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 67,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1578404294",
      "pull_request_review_id": 2015631578,
      "id": 1578404294,
      "node_id": "PRRC_kwDOABII585eFInG",
      "diff_hunk": "@@ -0,0 +1,175 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test that 1p1c package submission allows a 1p1c package to propagate in a \"network\" of nodes. Send\n+various packages from different nodes on a network in which some nodes have already received some of\n+the transactions (and submitted them to mempool, kept them as orphans or rejected them as\n+too-low-feerate transactions). The packages should be received and accepted by all nodes.\n+\"\"\"\n+\n+from decimal import Decimal\n+from math import ceil\n+\n+from test_framework.messages import (\n+    msg_tx,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    fill_mempool,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 4\n+        # hugely speeds up the test, as it involves multiple hops of tx relay.\n+        self.noban_tx_relay = True\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+        ]] * self.num_nodes\n+        self.supports_cli = False\n+\n+    def raise_network_minfee(self):\n+        filler_wallet = MiniWallet(self.nodes[0])\n+        fill_mempool(self, self.nodes[0], filler_wallet)\n+\n+        self.log.debug(\"Wait for the network to sync mempools\")\n+        self.sync_mempools()\n+\n+        self.log.debug(\"Check that all nodes' mempool minimum feerates are above min relay feerate\")\n+        for node in self.nodes:\n+            assert_equal(node.getmempoolinfo()['minrelaytxfee'], FEERATE_1SAT_VB)\n+            assert_greater_than(node.getmempoolinfo()['mempoolminfee'], FEERATE_1SAT_VB)\n+\n+    def create_basic_1p1c(self, wallet):\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+        package_hex_basic = [low_fee_parent[\"hex\"], high_fee_child[\"hex\"]]\n+        return package_hex_basic, low_fee_parent[\"tx\"], high_fee_child[\"tx\"]\n+\n+    def create_package_2outs(self, wallet):\n+        # First create a tester tx to see the vsize, and then adjust the fees\n+        placeholder_fee = 100000\n+        utxo_for_2outs = wallet.get_utxo(confirmed_only=True)\n+\n+        low_fee_parent_2outs_tester = wallet.create_self_transfer_multi(\n+            utxos_to_spend=[utxo_for_2outs],\n+            num_outputs=2,\n+            fee_per_output=placeholder_fee,\n+            confirmed_only=True",
      "path": "test/functional/p2p_1p1c_network.py",
      "position": null,
      "original_position": 74,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "30c9e6bc4e9f8b8b606e55435dc3f743cb2dd670",
      "in_reply_to_id": null,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In 30c9e6bc4e9f8b8b606e55435dc3f743cb2dd670\r\n\r\n`confirmed_only` is only used if no utxos are provided, but this is not the case, so it shouldn't be needed.",
      "created_at": "2024-04-24T19:26:27Z",
      "updated_at": "2024-04-25T13:25:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1578404294",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1578404294"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 74,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1578426417",
      "pull_request_review_id": 2015631578,
      "id": 1578426417,
      "node_id": "PRRC_kwDOABII585eFOAx",
      "diff_hunk": "@@ -0,0 +1,175 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test that 1p1c package submission allows a 1p1c package to propagate in a \"network\" of nodes. Send\n+various packages from different nodes on a network in which some nodes have already received some of\n+the transactions (and submitted them to mempool, kept them as orphans or rejected them as\n+too-low-feerate transactions). The packages should be received and accepted by all nodes.\n+\"\"\"\n+\n+from decimal import Decimal\n+from math import ceil\n+\n+from test_framework.messages import (\n+    msg_tx,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    fill_mempool,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 4\n+        # hugely speeds up the test, as it involves multiple hops of tx relay.\n+        self.noban_tx_relay = True\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+        ]] * self.num_nodes\n+        self.supports_cli = False\n+\n+    def raise_network_minfee(self):\n+        filler_wallet = MiniWallet(self.nodes[0])\n+        fill_mempool(self, self.nodes[0], filler_wallet)\n+\n+        self.log.debug(\"Wait for the network to sync mempools\")\n+        self.sync_mempools()\n+\n+        self.log.debug(\"Check that all nodes' mempool minimum feerates are above min relay feerate\")\n+        for node in self.nodes:\n+            assert_equal(node.getmempoolinfo()['minrelaytxfee'], FEERATE_1SAT_VB)\n+            assert_greater_than(node.getmempoolinfo()['mempoolminfee'], FEERATE_1SAT_VB)\n+\n+    def create_basic_1p1c(self, wallet):\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+        package_hex_basic = [low_fee_parent[\"hex\"], high_fee_child[\"hex\"]]\n+        return package_hex_basic, low_fee_parent[\"tx\"], high_fee_child[\"tx\"]\n+\n+    def create_package_2outs(self, wallet):\n+        # First create a tester tx to see the vsize, and then adjust the fees\n+        placeholder_fee = 100000\n+        utxo_for_2outs = wallet.get_utxo(confirmed_only=True)\n+\n+        low_fee_parent_2outs_tester = wallet.create_self_transfer_multi(\n+            utxos_to_spend=[utxo_for_2outs],\n+            num_outputs=2,\n+            fee_per_output=placeholder_fee,\n+            confirmed_only=True\n+        )\n+\n+        # Target 1sat/vB so the number of satoshis is equal to the vsize.\n+        # Round up. The goal is to be between min relay feerate and mempool min feerate.\n+        fee_2outs = ceil(low_fee_parent_2outs_tester[\"tx\"].get_vsize() / 2)\n+\n+        low_fee_parent_2outs = wallet.create_self_transfer_multi(\n+            utxos_to_spend=[utxo_for_2outs],\n+            num_outputs=2,\n+            fee_per_output=fee_2outs,\n+        )\n+\n+        # Now create the child\n+        high_fee_child_2outs = wallet.create_self_transfer_multi(\n+            utxos_to_spend=low_fee_parent_2outs[\"new_utxos\"][::-1],\n+            fee_per_output=fee_2outs*100,\n+        )\n+        return [low_fee_parent_2outs[\"hex\"], high_fee_child_2outs[\"hex\"]], low_fee_parent_2outs[\"tx\"], high_fee_child_2outs[\"tx\"]\n+\n+    def create_package_2p1c(self, wallet):\n+        parent1 = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB*10, confirmed_only=True)\n+        parent2 = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB*20, confirmed_only=True)\n+        child = wallet.create_self_transfer_multi(\n+            utxos_to_spend=[parent1[\"new_utxo\"], parent2[\"new_utxo\"]],\n+            fee_per_output=999*parent1[\"tx\"].get_vsize(),\n+        )\n+        return [parent1[\"hex\"], parent2[\"hex\"], child[\"hex\"]], parent1[\"tx\"], parent2[\"tx\"], child[\"tx\"]\n+\n+    def create_packages(self):\n+        # 1: Basic 1-parent-1-child package, parent 1sat/vB, child 999sat/vB\n+        package_hex_1, parent_1, child_1 = self.create_basic_1p1c(self.wallet)\n+\n+        # 2: same as 1, parent's txid is the same as its wtxid.\n+        package_hex_2, parent_2, child_2 = self.create_basic_1p1c(self.wallet_nonsegwit)\n+\n+        # 3: 2-parent-1-child package. Both parents are above mempool min feerate. No package submission happens.\n+        # We require packages to be child-with-unconfirmed-parents and only allow 1-parent-1-child packages.\n+        package_hex_3, parent_31, parent_32, child_3 = self.create_package_2p1c(self.wallet)\n+\n+        # 4: parent + child package where the child spends 2 different outputs from the parent.\n+        package_hex_4, parent_4, child_4 = self.create_package_2outs(self.wallet)\n+\n+        # Assemble return results\n+        packages_to_submit = []\n+        txns_to_send = [[]] * self.num_nodes",
      "path": "test/functional/p2p_1p1c_network.py",
      "position": null,
      "original_position": 119,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "30c9e6bc4e9f8b8b606e55435dc3f743cb2dd670",
      "in_reply_to_id": null,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In 30c9e6bc4e9f8b8b606e55435dc3f743cb2dd670\r\n\r\nnit: There's no need to reserve here, this could be defined as `txns_to_send = [[]]` and subsequent calls could call `append` instead",
      "created_at": "2024-04-24T19:40:58Z",
      "updated_at": "2024-04-25T13:25:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1578426417",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1578426417"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 119,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1578441000",
      "pull_request_review_id": 2015631578,
      "id": 1578441000,
      "node_id": "PRRC_kwDOABII585eFRko",
      "diff_hunk": "@@ -0,0 +1,175 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test that 1p1c package submission allows a 1p1c package to propagate in a \"network\" of nodes. Send\n+various packages from different nodes on a network in which some nodes have already received some of\n+the transactions (and submitted them to mempool, kept them as orphans or rejected them as\n+too-low-feerate transactions). The packages should be received and accepted by all nodes.\n+\"\"\"\n+\n+from decimal import Decimal\n+from math import ceil\n+\n+from test_framework.messages import (\n+    msg_tx,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    fill_mempool,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 4\n+        # hugely speeds up the test, as it involves multiple hops of tx relay.\n+        self.noban_tx_relay = True\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+        ]] * self.num_nodes\n+        self.supports_cli = False\n+\n+    def raise_network_minfee(self):\n+        filler_wallet = MiniWallet(self.nodes[0])\n+        fill_mempool(self, self.nodes[0], filler_wallet)\n+\n+        self.log.debug(\"Wait for the network to sync mempools\")\n+        self.sync_mempools()\n+\n+        self.log.debug(\"Check that all nodes' mempool minimum feerates are above min relay feerate\")\n+        for node in self.nodes:\n+            assert_equal(node.getmempoolinfo()['minrelaytxfee'], FEERATE_1SAT_VB)\n+            assert_greater_than(node.getmempoolinfo()['mempoolminfee'], FEERATE_1SAT_VB)\n+\n+    def create_basic_1p1c(self, wallet):\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+        package_hex_basic = [low_fee_parent[\"hex\"], high_fee_child[\"hex\"]]\n+        return package_hex_basic, low_fee_parent[\"tx\"], high_fee_child[\"tx\"]\n+\n+    def create_package_2outs(self, wallet):\n+        # First create a tester tx to see the vsize, and then adjust the fees\n+        placeholder_fee = 100000\n+        utxo_for_2outs = wallet.get_utxo(confirmed_only=True)\n+\n+        low_fee_parent_2outs_tester = wallet.create_self_transfer_multi(\n+            utxos_to_spend=[utxo_for_2outs],\n+            num_outputs=2,\n+            fee_per_output=placeholder_fee,\n+            confirmed_only=True\n+        )\n+\n+        # Target 1sat/vB so the number of satoshis is equal to the vsize.\n+        # Round up. The goal is to be between min relay feerate and mempool min feerate.\n+        fee_2outs = ceil(low_fee_parent_2outs_tester[\"tx\"].get_vsize() / 2)\n+\n+        low_fee_parent_2outs = wallet.create_self_transfer_multi(\n+            utxos_to_spend=[utxo_for_2outs],\n+            num_outputs=2,\n+            fee_per_output=fee_2outs,\n+        )\n+\n+        # Now create the child\n+        high_fee_child_2outs = wallet.create_self_transfer_multi(\n+            utxos_to_spend=low_fee_parent_2outs[\"new_utxos\"][::-1],\n+            fee_per_output=fee_2outs*100,\n+        )\n+        return [low_fee_parent_2outs[\"hex\"], high_fee_child_2outs[\"hex\"]], low_fee_parent_2outs[\"tx\"], high_fee_child_2outs[\"tx\"]\n+\n+    def create_package_2p1c(self, wallet):\n+        parent1 = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB*10, confirmed_only=True)\n+        parent2 = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB*20, confirmed_only=True)\n+        child = wallet.create_self_transfer_multi(\n+            utxos_to_spend=[parent1[\"new_utxo\"], parent2[\"new_utxo\"]],\n+            fee_per_output=999*parent1[\"tx\"].get_vsize(),\n+        )\n+        return [parent1[\"hex\"], parent2[\"hex\"], child[\"hex\"]], parent1[\"tx\"], parent2[\"tx\"], child[\"tx\"]\n+\n+    def create_packages(self):\n+        # 1: Basic 1-parent-1-child package, parent 1sat/vB, child 999sat/vB\n+        package_hex_1, parent_1, child_1 = self.create_basic_1p1c(self.wallet)\n+\n+        # 2: same as 1, parent's txid is the same as its wtxid.\n+        package_hex_2, parent_2, child_2 = self.create_basic_1p1c(self.wallet_nonsegwit)\n+\n+        # 3: 2-parent-1-child package. Both parents are above mempool min feerate. No package submission happens.\n+        # We require packages to be child-with-unconfirmed-parents and only allow 1-parent-1-child packages.\n+        package_hex_3, parent_31, parent_32, child_3 = self.create_package_2p1c(self.wallet)\n+\n+        # 4: parent + child package where the child spends 2 different outputs from the parent.\n+        package_hex_4, parent_4, child_4 = self.create_package_2outs(self.wallet)\n+\n+        # Assemble return results\n+        packages_to_submit = []\n+        txns_to_send = [[]] * self.num_nodes\n+\n+        packages_to_submit.append(package_hex_1)\n+        packages_to_submit.append(package_hex_2)\n+        packages_to_submit.append(package_hex_3)\n+        packages_to_submit.append(package_hex_4)\n+\n+        # node0: sender\n+        # node1: pre-received the children (orphan)\n+        # node3: pre-received the parents (too low fee)\n+        # All nodes receive high_parent_51 ahead of time.\n+        txns_to_send[1] = [child_1, child_2, parent_31, child_3, child_4]\n+        txns_to_send[2] = [parent_31]\n+        txns_to_send[3] = [parent_1, parent_2, parent_31, parent_4]\n+\n+        return packages_to_submit, txns_to_send\n+\n+    def run_test(self):\n+        self.wallet = MiniWallet(self.nodes[1])\n+        self.wallet_nonsegwit = MiniWallet(self.nodes[2], mode=MiniWalletMode.RAW_P2PK)\n+        self.generate(self.wallet_nonsegwit, 10)\n+        self.generate(self.wallet, 120)\n+\n+        self.log.info(\"Fill mempools with large transactions to raise mempool minimum feerates\")\n+        self.raise_network_minfee()\n+\n+        # Create the transactions.\n+        self.wallet.rescan_utxos(include_mempool=True)\n+        packages_to_submit, transactions_to_presend = self.create_packages()\n+\n+        self.peers = []\n+        for i in range(self.num_nodes):\n+            self.peers.append(self.nodes[i].add_p2p_connection(P2PInterface()))",
      "path": "test/functional/p2p_1p1c_network.py",
      "position": null,
      "original_position": 151,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "30c9e6bc4e9f8b8b606e55435dc3f743cb2dd670",
      "in_reply_to_id": null,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In 30c9e6bc4e9f8b8b606e55435dc3f743cb2dd670\r\n\r\nnit: This could be done more idiomatically, but feel free to disregard\r\n\r\n```suggestion\r\n        self.peers = [self.nodes[i].add_p2p_connection(P2PInterface()) for i in range(self.num_nodes)]\r\n```",
      "created_at": "2024-04-24T19:48:58Z",
      "updated_at": "2024-04-25T14:16:19Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1578441000",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1578441000"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": 149,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 151,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1578476332",
      "pull_request_review_id": 2015631578,
      "id": 1578476332,
      "node_id": "PRRC_kwDOABII585eFaMs",
      "diff_hunk": "@@ -0,0 +1,175 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test that 1p1c package submission allows a 1p1c package to propagate in a \"network\" of nodes. Send\n+various packages from different nodes on a network in which some nodes have already received some of\n+the transactions (and submitted them to mempool, kept them as orphans or rejected them as\n+too-low-feerate transactions). The packages should be received and accepted by all nodes.\n+\"\"\"\n+\n+from decimal import Decimal\n+from math import ceil\n+\n+from test_framework.messages import (\n+    msg_tx,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    fill_mempool,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 4\n+        # hugely speeds up the test, as it involves multiple hops of tx relay.\n+        self.noban_tx_relay = True\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+        ]] * self.num_nodes\n+        self.supports_cli = False\n+\n+    def raise_network_minfee(self):\n+        filler_wallet = MiniWallet(self.nodes[0])\n+        fill_mempool(self, self.nodes[0], filler_wallet)\n+\n+        self.log.debug(\"Wait for the network to sync mempools\")\n+        self.sync_mempools()\n+\n+        self.log.debug(\"Check that all nodes' mempool minimum feerates are above min relay feerate\")\n+        for node in self.nodes:\n+            assert_equal(node.getmempoolinfo()['minrelaytxfee'], FEERATE_1SAT_VB)\n+            assert_greater_than(node.getmempoolinfo()['mempoolminfee'], FEERATE_1SAT_VB)\n+\n+    def create_basic_1p1c(self, wallet):\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+        package_hex_basic = [low_fee_parent[\"hex\"], high_fee_child[\"hex\"]]\n+        return package_hex_basic, low_fee_parent[\"tx\"], high_fee_child[\"tx\"]\n+\n+    def create_package_2outs(self, wallet):\n+        # First create a tester tx to see the vsize, and then adjust the fees\n+        placeholder_fee = 100000\n+        utxo_for_2outs = wallet.get_utxo(confirmed_only=True)\n+\n+        low_fee_parent_2outs_tester = wallet.create_self_transfer_multi(\n+            utxos_to_spend=[utxo_for_2outs],\n+            num_outputs=2,\n+            fee_per_output=placeholder_fee,\n+            confirmed_only=True\n+        )\n+\n+        # Target 1sat/vB so the number of satoshis is equal to the vsize.\n+        # Round up. The goal is to be between min relay feerate and mempool min feerate.\n+        fee_2outs = ceil(low_fee_parent_2outs_tester[\"tx\"].get_vsize() / 2)\n+\n+        low_fee_parent_2outs = wallet.create_self_transfer_multi(\n+            utxos_to_spend=[utxo_for_2outs],\n+            num_outputs=2,\n+            fee_per_output=fee_2outs,\n+        )\n+\n+        # Now create the child\n+        high_fee_child_2outs = wallet.create_self_transfer_multi(\n+            utxos_to_spend=low_fee_parent_2outs[\"new_utxos\"][::-1],\n+            fee_per_output=fee_2outs*100,\n+        )\n+        return [low_fee_parent_2outs[\"hex\"], high_fee_child_2outs[\"hex\"]], low_fee_parent_2outs[\"tx\"], high_fee_child_2outs[\"tx\"]\n+\n+    def create_package_2p1c(self, wallet):\n+        parent1 = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB*10, confirmed_only=True)\n+        parent2 = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB*20, confirmed_only=True)\n+        child = wallet.create_self_transfer_multi(\n+            utxos_to_spend=[parent1[\"new_utxo\"], parent2[\"new_utxo\"]],\n+            fee_per_output=999*parent1[\"tx\"].get_vsize(),\n+        )\n+        return [parent1[\"hex\"], parent2[\"hex\"], child[\"hex\"]], parent1[\"tx\"], parent2[\"tx\"], child[\"tx\"]\n+\n+    def create_packages(self):\n+        # 1: Basic 1-parent-1-child package, parent 1sat/vB, child 999sat/vB\n+        package_hex_1, parent_1, child_1 = self.create_basic_1p1c(self.wallet)\n+\n+        # 2: same as 1, parent's txid is the same as its wtxid.\n+        package_hex_2, parent_2, child_2 = self.create_basic_1p1c(self.wallet_nonsegwit)\n+\n+        # 3: 2-parent-1-child package. Both parents are above mempool min feerate. No package submission happens.\n+        # We require packages to be child-with-unconfirmed-parents and only allow 1-parent-1-child packages.\n+        package_hex_3, parent_31, parent_32, child_3 = self.create_package_2p1c(self.wallet)\n+\n+        # 4: parent + child package where the child spends 2 different outputs from the parent.\n+        package_hex_4, parent_4, child_4 = self.create_package_2outs(self.wallet)\n+\n+        # Assemble return results\n+        packages_to_submit = []\n+        txns_to_send = [[]] * self.num_nodes\n+\n+        packages_to_submit.append(package_hex_1)\n+        packages_to_submit.append(package_hex_2)\n+        packages_to_submit.append(package_hex_3)\n+        packages_to_submit.append(package_hex_4)\n+\n+        # node0: sender\n+        # node1: pre-received the children (orphan)\n+        # node3: pre-received the parents (too low fee)\n+        # All nodes receive high_parent_51 ahead of time.\n+        txns_to_send[1] = [child_1, child_2, parent_31, child_3, child_4]\n+        txns_to_send[2] = [parent_31]\n+        txns_to_send[3] = [parent_1, parent_2, parent_31, parent_4]\n+\n+        return packages_to_submit, txns_to_send\n+\n+    def run_test(self):\n+        self.wallet = MiniWallet(self.nodes[1])\n+        self.wallet_nonsegwit = MiniWallet(self.nodes[2], mode=MiniWalletMode.RAW_P2PK)\n+        self.generate(self.wallet_nonsegwit, 10)\n+        self.generate(self.wallet, 120)\n+\n+        self.log.info(\"Fill mempools with large transactions to raise mempool minimum feerates\")\n+        self.raise_network_minfee()\n+\n+        # Create the transactions.\n+        self.wallet.rescan_utxos(include_mempool=True)\n+        packages_to_submit, transactions_to_presend = self.create_packages()\n+\n+        self.peers = []\n+        for i in range(self.num_nodes):\n+            self.peers.append(self.nodes[i].add_p2p_connection(P2PInterface()))\n+\n+        self.log.info(\"Pre-send some transactions to nodes\")\n+        for i in range(self.num_nodes):\n+            peer = self.peers[i]",
      "path": "test/functional/p2p_1p1c_network.py",
      "position": null,
      "original_position": 155,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "30c9e6bc4e9f8b8b606e55435dc3f743cb2dd670",
      "in_reply_to_id": null,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In 30c9e6bc4e9f8b8b606e55435dc3f743cb2dd670\r\n\r\n```suggestion\r\n        for (i, peer) in enumerate(self.peers):\r\n```",
      "created_at": "2024-04-24T20:18:59Z",
      "updated_at": "2024-04-25T14:16:31Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1578476332",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1578476332"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": 154,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 155,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1578541041",
      "pull_request_review_id": 2015631578,
      "id": 1578541041,
      "node_id": "PRRC_kwDOABII585eFp_x",
      "diff_hunk": "@@ -0,0 +1,392 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test opportunistic 1p1c package submission logic.\n+\"\"\"\n+\n+from decimal import Decimal\n+import time\n+from test_framework.messages import (\n+    CInv,\n+    CTxInWitness,\n+    MSG_WTX,\n+    msg_inv,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    fill_mempool,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+# Number of seconds to wait to ensure no getdata is received\n+GETDATA_WAIT = 60\n+\n+def cleanup(func):\n+    def wrapper(self, *args, **kwargs):\n+        try:\n+            func(self, *args, **kwargs)\n+        finally:\n+            self.nodes[0].disconnect_p2ps()\n+            # Do not clear the node's mempool, as each test requires mempool min feerate > min\n+            # relay feerate. However, do check that this is the case.\n+            assert self.nodes[0].getmempoolinfo()[\"mempoolminfee\"] > self.nodes[0].getnetworkinfo()[\"relayfee\"]\n+            # Ensure we do not try to spend the same UTXOs in subsequent tests, as they will look like RBF attempts.\n+            self.wallet.rescan_utxos(include_mempool=True)\n+\n+            # Resets if mocktime was used\n+            self.nodes[0].setmocktime(0)\n+    return wrapper\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+        ]]\n+        self.supports_cli = False\n+\n+    @cleanup\n+    def test_basic_child_then_parent(self):\n+        node = self.nodes[0]\n+        self.log.info(\"Check that opportunistic 1p1c logic works when child is received before parent\")\n+\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first (perhaps the low feerate parent didn't meet feefilter or the requests were sent to different nodes). It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. Sender relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 4. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+        node.disconnect_p2ps()\n+\n+    @cleanup\n+    def test_basic_parent_then_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=1, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=2, connection_type=\"outbound-full-relay\")\n+\n+        # 1. Parent is relayed first. It is too low feerate.\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer_sender.wait_for_getdata([parent_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer_ignored, check that it is ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+\n+        # 2. Child is relayed next. It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 3. Node requests the missing parent by txid.\n+        # It should do so even if it has previously rejected that parent for being too low feerate.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 4. Sender re-relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 5. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+    @cleanup\n+    def test_low_and_high_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        # This feerate is above mempoolminfee, but not enough to also bump the low feerate parent.\n+        feerate_just_above = node.getmempoolinfo()[\"mempoolminfee\"]\n+        med_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=feerate_just_above)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=3, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=4, connection_type=\"outbound-full-relay\")\n+\n+        self.log.info(\"Check that tx caches low fee parent + low fee child package rejections\")\n+\n+        # 1. Send parent, rejected for being low feerate.\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer_sender.wait_for_getdata([parent_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer_ignored, check that it is ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+\n+        # 2. Send an (orphan) child that has a higher feerate, but not enough to bump the parent.\n+        low_child_wtxid_int = int(med_fee_child[\"tx\"].getwtxid(), 16)",
      "path": "test/functional/p2p_opportunistic_1p1c.py",
      "position": null,
      "original_position": 158,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "30c9e6bc4e9f8b8b606e55435dc3f743cb2dd670",
      "in_reply_to_id": null,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In 30c9e6bc4e9f8b8b606e55435dc3f743cb2dd670\r\n\r\nnit: shouldn't this be called `med_child_wtxid_int`, for consistency?",
      "created_at": "2024-04-24T21:28:55Z",
      "updated_at": "2024-04-25T13:25:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1578541041",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1578541041"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 158,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1578543042",
      "pull_request_review_id": 2015631578,
      "id": 1578543042,
      "node_id": "PRRC_kwDOABII585eFqfC",
      "diff_hunk": "@@ -0,0 +1,392 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test opportunistic 1p1c package submission logic.\n+\"\"\"\n+\n+from decimal import Decimal\n+import time\n+from test_framework.messages import (\n+    CInv,\n+    CTxInWitness,\n+    MSG_WTX,\n+    msg_inv,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    fill_mempool,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+# Number of seconds to wait to ensure no getdata is received\n+GETDATA_WAIT = 60\n+\n+def cleanup(func):\n+    def wrapper(self, *args, **kwargs):\n+        try:\n+            func(self, *args, **kwargs)\n+        finally:\n+            self.nodes[0].disconnect_p2ps()\n+            # Do not clear the node's mempool, as each test requires mempool min feerate > min\n+            # relay feerate. However, do check that this is the case.\n+            assert self.nodes[0].getmempoolinfo()[\"mempoolminfee\"] > self.nodes[0].getnetworkinfo()[\"relayfee\"]\n+            # Ensure we do not try to spend the same UTXOs in subsequent tests, as they will look like RBF attempts.\n+            self.wallet.rescan_utxos(include_mempool=True)\n+\n+            # Resets if mocktime was used\n+            self.nodes[0].setmocktime(0)\n+    return wrapper\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+        ]]\n+        self.supports_cli = False\n+\n+    @cleanup\n+    def test_basic_child_then_parent(self):\n+        node = self.nodes[0]\n+        self.log.info(\"Check that opportunistic 1p1c logic works when child is received before parent\")\n+\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first (perhaps the low feerate parent didn't meet feefilter or the requests were sent to different nodes). It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. Sender relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 4. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+        node.disconnect_p2ps()\n+\n+    @cleanup\n+    def test_basic_parent_then_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=1, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=2, connection_type=\"outbound-full-relay\")\n+\n+        # 1. Parent is relayed first. It is too low feerate.\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer_sender.wait_for_getdata([parent_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer_ignored, check that it is ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+\n+        # 2. Child is relayed next. It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 3. Node requests the missing parent by txid.\n+        # It should do so even if it has previously rejected that parent for being too low feerate.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 4. Sender re-relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 5. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+    @cleanup\n+    def test_low_and_high_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        # This feerate is above mempoolminfee, but not enough to also bump the low feerate parent.\n+        feerate_just_above = node.getmempoolinfo()[\"mempoolminfee\"]\n+        med_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=feerate_just_above)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=3, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=4, connection_type=\"outbound-full-relay\")\n+\n+        self.log.info(\"Check that tx caches low fee parent + low fee child package rejections\")\n+\n+        # 1. Send parent, rejected for being low feerate.\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer_sender.wait_for_getdata([parent_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer_ignored, check that it is ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+\n+        # 2. Send an (orphan) child that has a higher feerate, but not enough to bump the parent.\n+        low_child_wtxid_int = int(med_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([low_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(med_fee_child[\"tx\"]))\n+\n+        # 3. Node requests the orphan's missing parent.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 4. The low parent + low child are submitted as a package. They are not accepted due to low package feerate.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+        assert med_fee_child[\"txid\"] not in node.getrawmempool()\n+\n+        # If peer_ignored announces the low feerate child, it should be ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+        # If either peer sends the parent again, package evaluation should not be attempted\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        peer_ignored.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+",
      "path": "test/functional/p2p_opportunistic_1p1c.py",
      "position": 190,
      "original_position": 179,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "30c9e6bc4e9f8b8b606e55435dc3f743cb2dd670",
      "in_reply_to_id": null,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In 30c9e6bc4e9f8b8b606e55435dc3f743cb2dd670\r\n\r\nGiven the comment above, isn't this missing the check for both transactions not being in the mempool?",
      "created_at": "2024-04-24T21:31:34Z",
      "updated_at": "2024-04-25T13:25:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1578543042",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1578543042"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 190,
      "original_line": 190,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1578545268",
      "pull_request_review_id": 2015631578,
      "id": 1578545268,
      "node_id": "PRRC_kwDOABII585eFrB0",
      "diff_hunk": "@@ -0,0 +1,392 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test opportunistic 1p1c package submission logic.\n+\"\"\"\n+\n+from decimal import Decimal\n+import time\n+from test_framework.messages import (\n+    CInv,\n+    CTxInWitness,\n+    MSG_WTX,\n+    msg_inv,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    fill_mempool,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+# Number of seconds to wait to ensure no getdata is received\n+GETDATA_WAIT = 60\n+\n+def cleanup(func):\n+    def wrapper(self, *args, **kwargs):\n+        try:\n+            func(self, *args, **kwargs)\n+        finally:\n+            self.nodes[0].disconnect_p2ps()\n+            # Do not clear the node's mempool, as each test requires mempool min feerate > min\n+            # relay feerate. However, do check that this is the case.\n+            assert self.nodes[0].getmempoolinfo()[\"mempoolminfee\"] > self.nodes[0].getnetworkinfo()[\"relayfee\"]\n+            # Ensure we do not try to spend the same UTXOs in subsequent tests, as they will look like RBF attempts.\n+            self.wallet.rescan_utxos(include_mempool=True)\n+\n+            # Resets if mocktime was used\n+            self.nodes[0].setmocktime(0)\n+    return wrapper\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+        ]]\n+        self.supports_cli = False\n+\n+    @cleanup\n+    def test_basic_child_then_parent(self):\n+        node = self.nodes[0]\n+        self.log.info(\"Check that opportunistic 1p1c logic works when child is received before parent\")\n+\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first (perhaps the low feerate parent didn't meet feefilter or the requests were sent to different nodes). It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. Sender relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 4. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+        node.disconnect_p2ps()\n+\n+    @cleanup\n+    def test_basic_parent_then_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=1, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=2, connection_type=\"outbound-full-relay\")\n+\n+        # 1. Parent is relayed first. It is too low feerate.\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer_sender.wait_for_getdata([parent_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer_ignored, check that it is ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+\n+        # 2. Child is relayed next. It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 3. Node requests the missing parent by txid.\n+        # It should do so even if it has previously rejected that parent for being too low feerate.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 4. Sender re-relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 5. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+    @cleanup\n+    def test_low_and_high_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        # This feerate is above mempoolminfee, but not enough to also bump the low feerate parent.\n+        feerate_just_above = node.getmempoolinfo()[\"mempoolminfee\"]\n+        med_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=feerate_just_above)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=3, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=4, connection_type=\"outbound-full-relay\")\n+\n+        self.log.info(\"Check that tx caches low fee parent + low fee child package rejections\")\n+\n+        # 1. Send parent, rejected for being low feerate.\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer_sender.wait_for_getdata([parent_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer_ignored, check that it is ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+\n+        # 2. Send an (orphan) child that has a higher feerate, but not enough to bump the parent.\n+        low_child_wtxid_int = int(med_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([low_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(med_fee_child[\"tx\"]))\n+\n+        # 3. Node requests the orphan's missing parent.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 4. The low parent + low child are submitted as a package. They are not accepted due to low package feerate.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+        assert med_fee_child[\"txid\"] not in node.getrawmempool()\n+\n+        # If peer_ignored announces the low feerate child, it should be ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+        # If either peer sends the parent again, package evaluation should not be attempted\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        peer_ignored.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 5. Send the high feerate (orphan) child\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 6. Node requests the orphan's parent, even though it has already been rejected, both by\n+        # itself and with a child. This is necessary, otherwise high_fee_child can be censored.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 7. The low feerate parent + high feerate child are submitted as a package.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 8. Both transactions should now be in mempool\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool",
      "path": "test/functional/p2p_opportunistic_1p1c.py",
      "position": 211,
      "original_position": 197,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "30c9e6bc4e9f8b8b606e55435dc3f743cb2dd670",
      "in_reply_to_id": null,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In 30c9e6bc4e9f8b8b606e55435dc3f743cb2dd670\r\n\r\nI think it wouldn't hurt to check that `med_fee_child` is not in the mempool. It cannot be, given it is a double spend of `high_fee_child`, but it made me check how the transactions were created, given it could have been the case that `low_fee_parent` had more than one output",
      "created_at": "2024-04-24T21:34:21Z",
      "updated_at": "2024-04-25T13:25:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1578545268",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1578545268"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 211,
      "original_line": 211,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1578550174",
      "pull_request_review_id": 2015631578,
      "id": 1578550174,
      "node_id": "PRRC_kwDOABII585eFsOe",
      "diff_hunk": "@@ -0,0 +1,392 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test opportunistic 1p1c package submission logic.\n+\"\"\"\n+\n+from decimal import Decimal\n+import time\n+from test_framework.messages import (\n+    CInv,\n+    CTxInWitness,\n+    MSG_WTX,\n+    msg_inv,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    fill_mempool,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+# Number of seconds to wait to ensure no getdata is received\n+GETDATA_WAIT = 60\n+\n+def cleanup(func):\n+    def wrapper(self, *args, **kwargs):\n+        try:\n+            func(self, *args, **kwargs)\n+        finally:\n+            self.nodes[0].disconnect_p2ps()\n+            # Do not clear the node's mempool, as each test requires mempool min feerate > min\n+            # relay feerate. However, do check that this is the case.\n+            assert self.nodes[0].getmempoolinfo()[\"mempoolminfee\"] > self.nodes[0].getnetworkinfo()[\"relayfee\"]\n+            # Ensure we do not try to spend the same UTXOs in subsequent tests, as they will look like RBF attempts.\n+            self.wallet.rescan_utxos(include_mempool=True)\n+\n+            # Resets if mocktime was used\n+            self.nodes[0].setmocktime(0)\n+    return wrapper\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+        ]]\n+        self.supports_cli = False\n+\n+    @cleanup\n+    def test_basic_child_then_parent(self):\n+        node = self.nodes[0]\n+        self.log.info(\"Check that opportunistic 1p1c logic works when child is received before parent\")\n+\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first (perhaps the low feerate parent didn't meet feefilter or the requests were sent to different nodes). It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. Sender relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 4. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+        node.disconnect_p2ps()\n+\n+    @cleanup\n+    def test_basic_parent_then_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=1, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=2, connection_type=\"outbound-full-relay\")\n+\n+        # 1. Parent is relayed first. It is too low feerate.\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer_sender.wait_for_getdata([parent_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer_ignored, check that it is ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+\n+        # 2. Child is relayed next. It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 3. Node requests the missing parent by txid.\n+        # It should do so even if it has previously rejected that parent for being too low feerate.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 4. Sender re-relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 5. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+    @cleanup\n+    def test_low_and_high_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        # This feerate is above mempoolminfee, but not enough to also bump the low feerate parent.\n+        feerate_just_above = node.getmempoolinfo()[\"mempoolminfee\"]\n+        med_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=feerate_just_above)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=3, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=4, connection_type=\"outbound-full-relay\")\n+\n+        self.log.info(\"Check that tx caches low fee parent + low fee child package rejections\")\n+\n+        # 1. Send parent, rejected for being low feerate.\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer_sender.wait_for_getdata([parent_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer_ignored, check that it is ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+\n+        # 2. Send an (orphan) child that has a higher feerate, but not enough to bump the parent.\n+        low_child_wtxid_int = int(med_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([low_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(med_fee_child[\"tx\"]))\n+\n+        # 3. Node requests the orphan's missing parent.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 4. The low parent + low child are submitted as a package. They are not accepted due to low package feerate.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+        assert med_fee_child[\"txid\"] not in node.getrawmempool()\n+\n+        # If peer_ignored announces the low feerate child, it should be ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+        # If either peer sends the parent again, package evaluation should not be attempted\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        peer_ignored.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 5. Send the high feerate (orphan) child\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 6. Node requests the orphan's parent, even though it has already been rejected, both by\n+        # itself and with a child. This is necessary, otherwise high_fee_child can be censored.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 7. The low feerate parent + high feerate child are submitted as a package.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 8. Both transactions should now be in mempool\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+    @cleanup\n+    def test_orphan_consensus_failure(self):\n+        self.log.info(\"Check opportunistic 1p1c logic with consensus-invalid orphan causes disconnect of the correct peer\")\n+        node = self.nodes[0]\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        coin = low_fee_parent[\"new_utxo\"]\n+        address = node.get_deterministic_priv_key().address\n+        # Create raw transaction spending the parent, but with no signature (a consensus error).\n+        hex_orphan_no_sig = node.createrawtransaction([{\"txid\": coin[\"txid\"], \"vout\": coin[\"vout\"]}], {address : coin[\"value\"] - Decimal(\"0.0001\")})\n+        tx_orphan_bad_wit = tx_from_hex(hex_orphan_no_sig)\n+        tx_orphan_bad_wit.wit.vtxinwit.append(CTxInWitness())\n+        tx_orphan_bad_wit.wit.vtxinwit[0].scriptWitness.stack = [b'garbage']\n+\n+        bad_orphan_sender = node.add_p2p_connection(P2PInterface())\n+        parent_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first. It is missing an input.\n+        child_wtxid_int = int(tx_orphan_bad_wit.getwtxid(), 16)\n+        bad_orphan_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=child_wtxid_int)]))\n+        bad_orphan_sender.wait_for_getdata([child_wtxid_int])\n+        bad_orphan_sender.send_and_ping(msg_tx(tx_orphan_bad_wit))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        bad_orphan_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. A different peer relays the parent. Parent+Child are evaluated as a package and rejected.\n+        parent_sender.send_message(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 4. Transactions should not be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] not in node_mempool\n+        assert tx_orphan_bad_wit.rehash() not in node_mempool\n+\n+        # 5. Peer that sent a consensus-invalid transaction should be disconnected.\n+        bad_orphan_sender.wait_for_disconnect()\n+\n+        # The peer that didn't provide the orphan should not be disconnected.\n+        parent_sender.sync_with_ping()\n+\n+    @cleanup\n+    def test_parent_consensus_failure(self):\n+        self.log.info(\"Check opportunistic 1p1c logic with consensus-invalid parent causes disconnect of the correct peer\")\n+        node = self.nodes[0]\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+\n+        # Create invalid version of parent with a bad signature.\n+        tx_parent_bad_wit = tx_from_hex(low_fee_parent[\"hex\"])\n+        tx_parent_bad_wit.wit.vtxinwit.append(CTxInWitness())\n+        tx_parent_bad_wit.wit.vtxinwit[0].scriptWitness.stack = [b'garbage']\n+\n+        package_sender = node.add_p2p_connection(P2PInterface())\n+        fake_parent_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first. It is missing an input.\n+        child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        package_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=child_wtxid_int)]))\n+        package_sender.wait_for_getdata([child_wtxid_int])\n+        package_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(tx_parent_bad_wit.rehash(), 16)\n+        package_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. A different node relays the parent. The parent is first evaluated by itself and\n+        # rejected for being too low feerate. Then it is evaluated as a package and, after passing\n+        # feerate checks, rejected for having a bad signature (consensus error).\n+        fake_parent_sender.send_message(msg_tx(tx_parent_bad_wit))\n+\n+        # 4. Transactions should not be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert tx_parent_bad_wit.rehash() not in node_mempool\n+        assert high_fee_child[\"txid\"] not in node_mempool\n+\n+        # 5. Peer sent a consensus-invalid transaction.\n+        fake_parent_sender.wait_for_disconnect()\n+\n+        self.log.info(\"Check that fake parent does not cause orphan to be deleted and real package can still be submitted\")\n+        # 6. Child-sending should not have been punished and the orphan should remain in orphanage.\n+        # It can send the \"real\" parent transaction, and the package is accepted.\n+        package_sender.sync_with_ping()\n+        package_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))",
      "path": "test/functional/p2p_opportunistic_1p1c.py",
      "position": 298,
      "original_position": 281,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "30c9e6bc4e9f8b8b606e55435dc3f743cb2dd670",
      "in_reply_to_id": null,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In 30c9e6bc4e9f8b8b606e55435dc3f743cb2dd670\r\n\r\nIs the parent kept as recently rejected? I tried to modify the test to make the peer offer the transaction over the regular `inv->getdata->tx` flow and looks like the node won't request it.\r\n\r\n```\r\nparent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\r\npackage_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\r\npackage_sender.wait_for_getdata([parent_wtxid_int])\r\npackage_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\r\n```\r\n\r\n```\r\n  File \"/xxx//test/functional/p2p_opportunistic_1p1c.py\", line 283, in test_parent_consensus_failure\r\n    package_sender.wait_for_getdata([parent_wtxid_int])\r\n```\r\n\r\nIf so, it feels that could be exploited to prevent a package from being accepted",
      "created_at": "2024-04-24T21:41:09Z",
      "updated_at": "2024-04-25T13:25:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1578550174",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1578550174"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 298,
      "original_line": 298,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1579435718",
      "pull_request_review_id": 2015631578,
      "id": 1579435718,
      "node_id": "PRRC_kwDOABII585eJEbG",
      "diff_hunk": "@@ -0,0 +1,392 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test opportunistic 1p1c package submission logic.\n+\"\"\"\n+\n+from decimal import Decimal\n+import time\n+from test_framework.messages import (\n+    CInv,\n+    CTxInWitness,\n+    MSG_WTX,\n+    msg_inv,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    fill_mempool,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+# Number of seconds to wait to ensure no getdata is received\n+GETDATA_WAIT = 60\n+\n+def cleanup(func):\n+    def wrapper(self, *args, **kwargs):\n+        try:\n+            func(self, *args, **kwargs)\n+        finally:\n+            self.nodes[0].disconnect_p2ps()\n+            # Do not clear the node's mempool, as each test requires mempool min feerate > min\n+            # relay feerate. However, do check that this is the case.\n+            assert self.nodes[0].getmempoolinfo()[\"mempoolminfee\"] > self.nodes[0].getnetworkinfo()[\"relayfee\"]\n+            # Ensure we do not try to spend the same UTXOs in subsequent tests, as they will look like RBF attempts.\n+            self.wallet.rescan_utxos(include_mempool=True)\n+\n+            # Resets if mocktime was used\n+            self.nodes[0].setmocktime(0)\n+    return wrapper\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+        ]]\n+        self.supports_cli = False\n+\n+    @cleanup\n+    def test_basic_child_then_parent(self):\n+        node = self.nodes[0]\n+        self.log.info(\"Check that opportunistic 1p1c logic works when child is received before parent\")\n+\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first (perhaps the low feerate parent didn't meet feefilter or the requests were sent to different nodes). It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. Sender relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 4. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+        node.disconnect_p2ps()\n+\n+    @cleanup\n+    def test_basic_parent_then_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=1, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=2, connection_type=\"outbound-full-relay\")\n+\n+        # 1. Parent is relayed first. It is too low feerate.\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer_sender.wait_for_getdata([parent_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer_ignored, check that it is ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+\n+        # 2. Child is relayed next. It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 3. Node requests the missing parent by txid.\n+        # It should do so even if it has previously rejected that parent for being too low feerate.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 4. Sender re-relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 5. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+    @cleanup\n+    def test_low_and_high_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        # This feerate is above mempoolminfee, but not enough to also bump the low feerate parent.\n+        feerate_just_above = node.getmempoolinfo()[\"mempoolminfee\"]\n+        med_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=feerate_just_above)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=3, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=4, connection_type=\"outbound-full-relay\")",
      "path": "test/functional/p2p_opportunistic_1p1c.py",
      "position": null,
      "original_position": 142,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "30c9e6bc4e9f8b8b606e55435dc3f743cb2dd670",
      "in_reply_to_id": null,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In 30c9e6bc4e9f8b8b606e55435dc3f743cb2dd670\r\n\r\nnit: Given you are cleaning after each test, this could be `1, 2`",
      "created_at": "2024-04-25T13:03:28Z",
      "updated_at": "2024-04-26T14:15:48Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1579435718",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1579435718"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": 141,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 142,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1579436716",
      "pull_request_review_id": 2015631578,
      "id": 1579436716,
      "node_id": "PRRC_kwDOABII585eJEqs",
      "diff_hunk": "@@ -0,0 +1,392 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test opportunistic 1p1c package submission logic.\n+\"\"\"\n+\n+from decimal import Decimal\n+import time\n+from test_framework.messages import (\n+    CInv,\n+    CTxInWitness,\n+    MSG_WTX,\n+    msg_inv,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    fill_mempool,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+# Number of seconds to wait to ensure no getdata is received\n+GETDATA_WAIT = 60\n+\n+def cleanup(func):\n+    def wrapper(self, *args, **kwargs):\n+        try:\n+            func(self, *args, **kwargs)\n+        finally:\n+            self.nodes[0].disconnect_p2ps()\n+            # Do not clear the node's mempool, as each test requires mempool min feerate > min\n+            # relay feerate. However, do check that this is the case.\n+            assert self.nodes[0].getmempoolinfo()[\"mempoolminfee\"] > self.nodes[0].getnetworkinfo()[\"relayfee\"]\n+            # Ensure we do not try to spend the same UTXOs in subsequent tests, as they will look like RBF attempts.\n+            self.wallet.rescan_utxos(include_mempool=True)\n+\n+            # Resets if mocktime was used\n+            self.nodes[0].setmocktime(0)\n+    return wrapper\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+        ]]\n+        self.supports_cli = False\n+\n+    @cleanup\n+    def test_basic_child_then_parent(self):\n+        node = self.nodes[0]\n+        self.log.info(\"Check that opportunistic 1p1c logic works when child is received before parent\")\n+\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first (perhaps the low feerate parent didn't meet feefilter or the requests were sent to different nodes). It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. Sender relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 4. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+        node.disconnect_p2ps()\n+\n+    @cleanup\n+    def test_basic_parent_then_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=1, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=2, connection_type=\"outbound-full-relay\")\n+\n+        # 1. Parent is relayed first. It is too low feerate.\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer_sender.wait_for_getdata([parent_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer_ignored, check that it is ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+\n+        # 2. Child is relayed next. It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 3. Node requests the missing parent by txid.\n+        # It should do so even if it has previously rejected that parent for being too low feerate.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 4. Sender re-relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 5. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+    @cleanup\n+    def test_low_and_high_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        # This feerate is above mempoolminfee, but not enough to also bump the low feerate parent.\n+        feerate_just_above = node.getmempoolinfo()[\"mempoolminfee\"]\n+        med_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=feerate_just_above)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=3, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=4, connection_type=\"outbound-full-relay\")",
      "path": "test/functional/p2p_opportunistic_1p1c.py",
      "position": null,
      "original_position": 142,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "30c9e6bc4e9f8b8b606e55435dc3f743cb2dd670",
      "in_reply_to_id": 1579435718,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "The same happens in the last two tests with `p2p_idx=4`",
      "created_at": "2024-04-25T13:04:13Z",
      "updated_at": "2024-04-25T14:17:24Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1579436716",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1579436716"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": 141,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 142,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1579450824",
      "pull_request_review_id": 2015631578,
      "id": 1579450824,
      "node_id": "PRRC_kwDOABII585eJIHI",
      "diff_hunk": "@@ -0,0 +1,392 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test opportunistic 1p1c package submission logic.\n+\"\"\"\n+\n+from decimal import Decimal\n+import time\n+from test_framework.messages import (\n+    CInv,\n+    CTxInWitness,\n+    MSG_WTX,\n+    msg_inv,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    fill_mempool,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+# Number of seconds to wait to ensure no getdata is received\n+GETDATA_WAIT = 60\n+\n+def cleanup(func):\n+    def wrapper(self, *args, **kwargs):\n+        try:\n+            func(self, *args, **kwargs)\n+        finally:\n+            self.nodes[0].disconnect_p2ps()\n+            # Do not clear the node's mempool, as each test requires mempool min feerate > min\n+            # relay feerate. However, do check that this is the case.\n+            assert self.nodes[0].getmempoolinfo()[\"mempoolminfee\"] > self.nodes[0].getnetworkinfo()[\"relayfee\"]\n+            # Ensure we do not try to spend the same UTXOs in subsequent tests, as they will look like RBF attempts.\n+            self.wallet.rescan_utxos(include_mempool=True)\n+\n+            # Resets if mocktime was used\n+            self.nodes[0].setmocktime(0)\n+    return wrapper\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+        ]]\n+        self.supports_cli = False\n+\n+    @cleanup\n+    def test_basic_child_then_parent(self):\n+        node = self.nodes[0]\n+        self.log.info(\"Check that opportunistic 1p1c logic works when child is received before parent\")\n+\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first (perhaps the low feerate parent didn't meet feefilter or the requests were sent to different nodes). It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. Sender relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 4. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+        node.disconnect_p2ps()\n+\n+    @cleanup\n+    def test_basic_parent_then_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=1, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=2, connection_type=\"outbound-full-relay\")\n+\n+        # 1. Parent is relayed first. It is too low feerate.\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer_sender.wait_for_getdata([parent_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer_ignored, check that it is ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+\n+        # 2. Child is relayed next. It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 3. Node requests the missing parent by txid.\n+        # It should do so even if it has previously rejected that parent for being too low feerate.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 4. Sender re-relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 5. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+    @cleanup\n+    def test_low_and_high_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        # This feerate is above mempoolminfee, but not enough to also bump the low feerate parent.\n+        feerate_just_above = node.getmempoolinfo()[\"mempoolminfee\"]\n+        med_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=feerate_just_above)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=3, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=4, connection_type=\"outbound-full-relay\")\n+\n+        self.log.info(\"Check that tx caches low fee parent + low fee child package rejections\")\n+\n+        # 1. Send parent, rejected for being low feerate.\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer_sender.wait_for_getdata([parent_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer_ignored, check that it is ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+\n+        # 2. Send an (orphan) child that has a higher feerate, but not enough to bump the parent.\n+        low_child_wtxid_int = int(med_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([low_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(med_fee_child[\"tx\"]))\n+\n+        # 3. Node requests the orphan's missing parent.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 4. The low parent + low child are submitted as a package. They are not accepted due to low package feerate.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+        assert med_fee_child[\"txid\"] not in node.getrawmempool()\n+\n+        # If peer_ignored announces the low feerate child, it should be ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+        # If either peer sends the parent again, package evaluation should not be attempted\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        peer_ignored.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 5. Send the high feerate (orphan) child\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 6. Node requests the orphan's parent, even though it has already been rejected, both by\n+        # itself and with a child. This is necessary, otherwise high_fee_child can be censored.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 7. The low feerate parent + high feerate child are submitted as a package.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 8. Both transactions should now be in mempool\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+    @cleanup\n+    def test_orphan_consensus_failure(self):\n+        self.log.info(\"Check opportunistic 1p1c logic with consensus-invalid orphan causes disconnect of the correct peer\")\n+        node = self.nodes[0]\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        coin = low_fee_parent[\"new_utxo\"]\n+        address = node.get_deterministic_priv_key().address\n+        # Create raw transaction spending the parent, but with no signature (a consensus error).\n+        hex_orphan_no_sig = node.createrawtransaction([{\"txid\": coin[\"txid\"], \"vout\": coin[\"vout\"]}], {address : coin[\"value\"] - Decimal(\"0.0001\")})\n+        tx_orphan_bad_wit = tx_from_hex(hex_orphan_no_sig)\n+        tx_orphan_bad_wit.wit.vtxinwit.append(CTxInWitness())\n+        tx_orphan_bad_wit.wit.vtxinwit[0].scriptWitness.stack = [b'garbage']\n+\n+        bad_orphan_sender = node.add_p2p_connection(P2PInterface())\n+        parent_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first. It is missing an input.\n+        child_wtxid_int = int(tx_orphan_bad_wit.getwtxid(), 16)\n+        bad_orphan_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=child_wtxid_int)]))\n+        bad_orphan_sender.wait_for_getdata([child_wtxid_int])\n+        bad_orphan_sender.send_and_ping(msg_tx(tx_orphan_bad_wit))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        bad_orphan_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. A different peer relays the parent. Parent+Child are evaluated as a package and rejected.\n+        parent_sender.send_message(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 4. Transactions should not be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] not in node_mempool\n+        assert tx_orphan_bad_wit.rehash() not in node_mempool\n+\n+        # 5. Peer that sent a consensus-invalid transaction should be disconnected.\n+        bad_orphan_sender.wait_for_disconnect()\n+\n+        # The peer that didn't provide the orphan should not be disconnected.\n+        parent_sender.sync_with_ping()\n+\n+    @cleanup\n+    def test_parent_consensus_failure(self):\n+        self.log.info(\"Check opportunistic 1p1c logic with consensus-invalid parent causes disconnect of the correct peer\")\n+        node = self.nodes[0]\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+\n+        # Create invalid version of parent with a bad signature.\n+        tx_parent_bad_wit = tx_from_hex(low_fee_parent[\"hex\"])\n+        tx_parent_bad_wit.wit.vtxinwit.append(CTxInWitness())\n+        tx_parent_bad_wit.wit.vtxinwit[0].scriptWitness.stack = [b'garbage']\n+\n+        package_sender = node.add_p2p_connection(P2PInterface())\n+        fake_parent_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first. It is missing an input.\n+        child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        package_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=child_wtxid_int)]))\n+        package_sender.wait_for_getdata([child_wtxid_int])\n+        package_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(tx_parent_bad_wit.rehash(), 16)\n+        package_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. A different node relays the parent. The parent is first evaluated by itself and\n+        # rejected for being too low feerate. Then it is evaluated as a package and, after passing\n+        # feerate checks, rejected for having a bad signature (consensus error).\n+        fake_parent_sender.send_message(msg_tx(tx_parent_bad_wit))\n+\n+        # 4. Transactions should not be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert tx_parent_bad_wit.rehash() not in node_mempool\n+        assert high_fee_child[\"txid\"] not in node_mempool\n+\n+        # 5. Peer sent a consensus-invalid transaction.\n+        fake_parent_sender.wait_for_disconnect()\n+\n+        self.log.info(\"Check that fake parent does not cause orphan to be deleted and real package can still be submitted\")\n+        # 6. Child-sending should not have been punished and the orphan should remain in orphanage.\n+        # It can send the \"real\" parent transaction, and the package is accepted.\n+        package_sender.sync_with_ping()\n+        package_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+    @cleanup\n+    def test_multiple_parents(self):\n+        self.log.info(\"Check that node does not request more than 1 previously-rejected low feerate parent\")\n+\n+        node = self.nodes[0]\n+        node.setmocktime(int(time.time()))\n+\n+        # 2-parent-1-child package where both parents are below mempool min feerate\n+        parent_low_1 = self.wallet_nonsegwit.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        parent_low_2 = self.wallet_nonsegwit.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        child_bumping = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[parent_low_1[\"new_utxo\"], parent_low_2[\"new_utxo\"]],\n+            fee_per_output=999*parent_low_1[\"tx\"].get_vsize(),\n+        )\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=4, connection_type=\"outbound-full-relay\")\n+\n+        # 1. Send both parents. Each should be rejected for being too low feerate.\n+        # Send unsolicited so that we can later check that no \"getdata\" was ever received.\n+        peer_sender.send_and_ping(msg_tx(parent_low_1[\"tx\"]))\n+        peer_sender.send_and_ping(msg_tx(parent_low_2[\"tx\"]))\n+\n+        # parent_low_1 and parent_low_2 are rejected for being low feerate.\n+        assert parent_low_1[\"txid\"] not in node.getrawmempool()\n+        assert parent_low_2[\"txid\"] not in node.getrawmempool()\n+\n+        # 2. Send child.\n+        peer_sender.send_and_ping(msg_tx(child_bumping[\"tx\"]))\n+\n+        # 3. Node should not request any parents, as it should recognize that it will not accept\n+        # multi-parent-1-child packages.\n+        node.bumpmocktime(GETDATA_WAIT)\n+        peer_sender.sync_with_ping()\n+        assert \"getdata\" not in peer_sender.last_message\n+\n+    @cleanup\n+    def test_other_parent_in_mempool(self):\n+        self.log.info(\"Check opportunistic 1p1c fails if child already has another parent in mempool\")",
      "path": "test/functional/p2p_opportunistic_1p1c.py",
      "position": 341,
      "original_position": 324,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "30c9e6bc4e9f8b8b606e55435dc3f743cb2dd670",
      "in_reply_to_id": null,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In 30c9e6bc4e9f8b8b606e55435dc3f743cb2dd670\r\n\r\nHow is this different from submitting the whole package? My understanding is that given a package with `[p1_high, p2_low, c12]`, on processing the package, `p1_high` would make it to the mempool by itself: https://github.com/bitcoin/bitcoin/blob/2a07c4662d7266158d47f79fa2433ab22e22c907/src/validation.cpp#L1611\r\n\r\nAnd the `[p2_low, c12]` will make it as a package:\r\nhttps://github.com/bitcoin/bitcoin/blob/2a07c4662d7266158d47f79fa2433ab22e22c907/src/validation.cpp#L1639-L1640\r\n\r\nSo why have the distinction?",
      "created_at": "2024-04-25T13:14:05Z",
      "updated_at": "2024-04-25T13:25:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1579450824",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1579450824"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 341,
      "original_line": 341,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1579527839",
      "pull_request_review_id": 2022594202,
      "id": 1579527839,
      "node_id": "PRRC_kwDOABII585eJa6f",
      "diff_hunk": "@@ -0,0 +1,392 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test opportunistic 1p1c package submission logic.\n+\"\"\"\n+\n+from decimal import Decimal\n+import time\n+from test_framework.messages import (\n+    CInv,\n+    CTxInWitness,\n+    MSG_WTX,\n+    msg_inv,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    fill_mempool,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+# Number of seconds to wait to ensure no getdata is received\n+GETDATA_WAIT = 60\n+\n+def cleanup(func):\n+    def wrapper(self, *args, **kwargs):\n+        try:\n+            func(self, *args, **kwargs)\n+        finally:\n+            self.nodes[0].disconnect_p2ps()\n+            # Do not clear the node's mempool, as each test requires mempool min feerate > min\n+            # relay feerate. However, do check that this is the case.\n+            assert self.nodes[0].getmempoolinfo()[\"mempoolminfee\"] > self.nodes[0].getnetworkinfo()[\"relayfee\"]\n+            # Ensure we do not try to spend the same UTXOs in subsequent tests, as they will look like RBF attempts.\n+            self.wallet.rescan_utxos(include_mempool=True)\n+\n+            # Resets if mocktime was used\n+            self.nodes[0].setmocktime(0)\n+    return wrapper\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+        ]]\n+        self.supports_cli = False\n+\n+    @cleanup\n+    def test_basic_child_then_parent(self):\n+        node = self.nodes[0]\n+        self.log.info(\"Check that opportunistic 1p1c logic works when child is received before parent\")\n+\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first (perhaps the low feerate parent didn't meet feefilter or the requests were sent to different nodes). It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. Sender relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 4. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+        node.disconnect_p2ps()\n+\n+    @cleanup\n+    def test_basic_parent_then_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=1, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=2, connection_type=\"outbound-full-relay\")\n+\n+        # 1. Parent is relayed first. It is too low feerate.\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer_sender.wait_for_getdata([parent_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer_ignored, check that it is ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+\n+        # 2. Child is relayed next. It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 3. Node requests the missing parent by txid.\n+        # It should do so even if it has previously rejected that parent for being too low feerate.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 4. Sender re-relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 5. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+    @cleanup\n+    def test_low_and_high_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        # This feerate is above mempoolminfee, but not enough to also bump the low feerate parent.\n+        feerate_just_above = node.getmempoolinfo()[\"mempoolminfee\"]\n+        med_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=feerate_just_above)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=3, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=4, connection_type=\"outbound-full-relay\")\n+\n+        self.log.info(\"Check that tx caches low fee parent + low fee child package rejections\")\n+\n+        # 1. Send parent, rejected for being low feerate.\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer_sender.wait_for_getdata([parent_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer_ignored, check that it is ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+\n+        # 2. Send an (orphan) child that has a higher feerate, but not enough to bump the parent.\n+        low_child_wtxid_int = int(med_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([low_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(med_fee_child[\"tx\"]))\n+\n+        # 3. Node requests the orphan's missing parent.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 4. The low parent + low child are submitted as a package. They are not accepted due to low package feerate.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+        assert med_fee_child[\"txid\"] not in node.getrawmempool()\n+\n+        # If peer_ignored announces the low feerate child, it should be ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+        # If either peer sends the parent again, package evaluation should not be attempted\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        peer_ignored.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 5. Send the high feerate (orphan) child\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 6. Node requests the orphan's parent, even though it has already been rejected, both by\n+        # itself and with a child. This is necessary, otherwise high_fee_child can be censored.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 7. The low feerate parent + high feerate child are submitted as a package.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 8. Both transactions should now be in mempool\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+    @cleanup\n+    def test_orphan_consensus_failure(self):\n+        self.log.info(\"Check opportunistic 1p1c logic with consensus-invalid orphan causes disconnect of the correct peer\")\n+        node = self.nodes[0]\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        coin = low_fee_parent[\"new_utxo\"]\n+        address = node.get_deterministic_priv_key().address\n+        # Create raw transaction spending the parent, but with no signature (a consensus error).\n+        hex_orphan_no_sig = node.createrawtransaction([{\"txid\": coin[\"txid\"], \"vout\": coin[\"vout\"]}], {address : coin[\"value\"] - Decimal(\"0.0001\")})\n+        tx_orphan_bad_wit = tx_from_hex(hex_orphan_no_sig)\n+        tx_orphan_bad_wit.wit.vtxinwit.append(CTxInWitness())\n+        tx_orphan_bad_wit.wit.vtxinwit[0].scriptWitness.stack = [b'garbage']\n+\n+        bad_orphan_sender = node.add_p2p_connection(P2PInterface())\n+        parent_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first. It is missing an input.\n+        child_wtxid_int = int(tx_orphan_bad_wit.getwtxid(), 16)\n+        bad_orphan_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=child_wtxid_int)]))\n+        bad_orphan_sender.wait_for_getdata([child_wtxid_int])\n+        bad_orphan_sender.send_and_ping(msg_tx(tx_orphan_bad_wit))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        bad_orphan_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. A different peer relays the parent. Parent+Child are evaluated as a package and rejected.\n+        parent_sender.send_message(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 4. Transactions should not be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] not in node_mempool\n+        assert tx_orphan_bad_wit.rehash() not in node_mempool\n+\n+        # 5. Peer that sent a consensus-invalid transaction should be disconnected.\n+        bad_orphan_sender.wait_for_disconnect()\n+\n+        # The peer that didn't provide the orphan should not be disconnected.\n+        parent_sender.sync_with_ping()\n+\n+    @cleanup\n+    def test_parent_consensus_failure(self):\n+        self.log.info(\"Check opportunistic 1p1c logic with consensus-invalid parent causes disconnect of the correct peer\")\n+        node = self.nodes[0]\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+\n+        # Create invalid version of parent with a bad signature.\n+        tx_parent_bad_wit = tx_from_hex(low_fee_parent[\"hex\"])\n+        tx_parent_bad_wit.wit.vtxinwit.append(CTxInWitness())\n+        tx_parent_bad_wit.wit.vtxinwit[0].scriptWitness.stack = [b'garbage']\n+\n+        package_sender = node.add_p2p_connection(P2PInterface())\n+        fake_parent_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first. It is missing an input.\n+        child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        package_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=child_wtxid_int)]))\n+        package_sender.wait_for_getdata([child_wtxid_int])\n+        package_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(tx_parent_bad_wit.rehash(), 16)\n+        package_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. A different node relays the parent. The parent is first evaluated by itself and\n+        # rejected for being too low feerate. Then it is evaluated as a package and, after passing\n+        # feerate checks, rejected for having a bad signature (consensus error).\n+        fake_parent_sender.send_message(msg_tx(tx_parent_bad_wit))\n+\n+        # 4. Transactions should not be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert tx_parent_bad_wit.rehash() not in node_mempool\n+        assert high_fee_child[\"txid\"] not in node_mempool\n+\n+        # 5. Peer sent a consensus-invalid transaction.\n+        fake_parent_sender.wait_for_disconnect()\n+\n+        self.log.info(\"Check that fake parent does not cause orphan to be deleted and real package can still be submitted\")\n+        # 6. Child-sending should not have been punished and the orphan should remain in orphanage.\n+        # It can send the \"real\" parent transaction, and the package is accepted.\n+        package_sender.sync_with_ping()\n+        package_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))",
      "path": "test/functional/p2p_opportunistic_1p1c.py",
      "position": 298,
      "original_position": 281,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "30c9e6bc4e9f8b8b606e55435dc3f743cb2dd670",
      "in_reply_to_id": 1578550174,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "this is from `test_orphan_consensus_failure` causing the exact same parent to be added to `m_recent_rejects_reconsiderable`\r\n\r\nCan we somehow cause chaintip updates during cleanup, without dropping minfee too much? What if cleanup detects that it went down too much, then calls `fill_mempool` again?",
      "created_at": "2024-04-25T13:58:17Z",
      "updated_at": "2024-04-25T13:59:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1579527839",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1579527839"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 298,
      "original_line": 298,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1579549901",
      "pull_request_review_id": 2022636400,
      "id": 1579549901,
      "node_id": "PRRC_kwDOABII585eJgTN",
      "diff_hunk": "@@ -0,0 +1,392 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test opportunistic 1p1c package submission logic.\n+\"\"\"\n+\n+from decimal import Decimal\n+import time\n+from test_framework.messages import (\n+    CInv,\n+    CTxInWitness,\n+    MSG_WTX,\n+    msg_inv,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    fill_mempool,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+# Number of seconds to wait to ensure no getdata is received\n+GETDATA_WAIT = 60\n+\n+def cleanup(func):\n+    def wrapper(self, *args, **kwargs):\n+        try:\n+            func(self, *args, **kwargs)\n+        finally:\n+            self.nodes[0].disconnect_p2ps()\n+            # Do not clear the node's mempool, as each test requires mempool min feerate > min\n+            # relay feerate. However, do check that this is the case.\n+            assert self.nodes[0].getmempoolinfo()[\"mempoolminfee\"] > self.nodes[0].getnetworkinfo()[\"relayfee\"]\n+            # Ensure we do not try to spend the same UTXOs in subsequent tests, as they will look like RBF attempts.\n+            self.wallet.rescan_utxos(include_mempool=True)\n+\n+            # Resets if mocktime was used\n+            self.nodes[0].setmocktime(0)\n+    return wrapper\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+        ]]\n+        self.supports_cli = False\n+\n+    @cleanup\n+    def test_basic_child_then_parent(self):\n+        node = self.nodes[0]\n+        self.log.info(\"Check that opportunistic 1p1c logic works when child is received before parent\")\n+\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first (perhaps the low feerate parent didn't meet feefilter or the requests were sent to different nodes). It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. Sender relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 4. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+        node.disconnect_p2ps()\n+\n+    @cleanup\n+    def test_basic_parent_then_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=1, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=2, connection_type=\"outbound-full-relay\")\n+\n+        # 1. Parent is relayed first. It is too low feerate.\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer_sender.wait_for_getdata([parent_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer_ignored, check that it is ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+\n+        # 2. Child is relayed next. It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 3. Node requests the missing parent by txid.\n+        # It should do so even if it has previously rejected that parent for being too low feerate.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 4. Sender re-relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 5. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+    @cleanup\n+    def test_low_and_high_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        # This feerate is above mempoolminfee, but not enough to also bump the low feerate parent.\n+        feerate_just_above = node.getmempoolinfo()[\"mempoolminfee\"]\n+        med_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=feerate_just_above)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=3, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=4, connection_type=\"outbound-full-relay\")\n+\n+        self.log.info(\"Check that tx caches low fee parent + low fee child package rejections\")\n+\n+        # 1. Send parent, rejected for being low feerate.\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer_sender.wait_for_getdata([parent_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer_ignored, check that it is ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+\n+        # 2. Send an (orphan) child that has a higher feerate, but not enough to bump the parent.\n+        low_child_wtxid_int = int(med_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([low_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(med_fee_child[\"tx\"]))\n+\n+        # 3. Node requests the orphan's missing parent.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 4. The low parent + low child are submitted as a package. They are not accepted due to low package feerate.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+        assert med_fee_child[\"txid\"] not in node.getrawmempool()\n+\n+        # If peer_ignored announces the low feerate child, it should be ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+        # If either peer sends the parent again, package evaluation should not be attempted\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        peer_ignored.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 5. Send the high feerate (orphan) child\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 6. Node requests the orphan's parent, even though it has already been rejected, both by\n+        # itself and with a child. This is necessary, otherwise high_fee_child can be censored.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 7. The low feerate parent + high feerate child are submitted as a package.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 8. Both transactions should now be in mempool\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+    @cleanup\n+    def test_orphan_consensus_failure(self):\n+        self.log.info(\"Check opportunistic 1p1c logic with consensus-invalid orphan causes disconnect of the correct peer\")\n+        node = self.nodes[0]\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        coin = low_fee_parent[\"new_utxo\"]\n+        address = node.get_deterministic_priv_key().address\n+        # Create raw transaction spending the parent, but with no signature (a consensus error).\n+        hex_orphan_no_sig = node.createrawtransaction([{\"txid\": coin[\"txid\"], \"vout\": coin[\"vout\"]}], {address : coin[\"value\"] - Decimal(\"0.0001\")})\n+        tx_orphan_bad_wit = tx_from_hex(hex_orphan_no_sig)\n+        tx_orphan_bad_wit.wit.vtxinwit.append(CTxInWitness())\n+        tx_orphan_bad_wit.wit.vtxinwit[0].scriptWitness.stack = [b'garbage']\n+\n+        bad_orphan_sender = node.add_p2p_connection(P2PInterface())\n+        parent_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first. It is missing an input.\n+        child_wtxid_int = int(tx_orphan_bad_wit.getwtxid(), 16)\n+        bad_orphan_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=child_wtxid_int)]))\n+        bad_orphan_sender.wait_for_getdata([child_wtxid_int])\n+        bad_orphan_sender.send_and_ping(msg_tx(tx_orphan_bad_wit))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        bad_orphan_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. A different peer relays the parent. Parent+Child are evaluated as a package and rejected.\n+        parent_sender.send_message(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 4. Transactions should not be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] not in node_mempool\n+        assert tx_orphan_bad_wit.rehash() not in node_mempool\n+\n+        # 5. Peer that sent a consensus-invalid transaction should be disconnected.\n+        bad_orphan_sender.wait_for_disconnect()\n+\n+        # The peer that didn't provide the orphan should not be disconnected.\n+        parent_sender.sync_with_ping()\n+\n+    @cleanup\n+    def test_parent_consensus_failure(self):\n+        self.log.info(\"Check opportunistic 1p1c logic with consensus-invalid parent causes disconnect of the correct peer\")\n+        node = self.nodes[0]\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+\n+        # Create invalid version of parent with a bad signature.\n+        tx_parent_bad_wit = tx_from_hex(low_fee_parent[\"hex\"])\n+        tx_parent_bad_wit.wit.vtxinwit.append(CTxInWitness())\n+        tx_parent_bad_wit.wit.vtxinwit[0].scriptWitness.stack = [b'garbage']\n+\n+        package_sender = node.add_p2p_connection(P2PInterface())\n+        fake_parent_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first. It is missing an input.\n+        child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        package_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=child_wtxid_int)]))\n+        package_sender.wait_for_getdata([child_wtxid_int])\n+        package_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(tx_parent_bad_wit.rehash(), 16)\n+        package_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. A different node relays the parent. The parent is first evaluated by itself and\n+        # rejected for being too low feerate. Then it is evaluated as a package and, after passing\n+        # feerate checks, rejected for having a bad signature (consensus error).\n+        fake_parent_sender.send_message(msg_tx(tx_parent_bad_wit))\n+\n+        # 4. Transactions should not be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert tx_parent_bad_wit.rehash() not in node_mempool\n+        assert high_fee_child[\"txid\"] not in node_mempool\n+\n+        # 5. Peer sent a consensus-invalid transaction.\n+        fake_parent_sender.wait_for_disconnect()\n+\n+        self.log.info(\"Check that fake parent does not cause orphan to be deleted and real package can still be submitted\")\n+        # 6. Child-sending should not have been punished and the orphan should remain in orphanage.\n+        # It can send the \"real\" parent transaction, and the package is accepted.\n+        package_sender.sync_with_ping()\n+        package_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))",
      "path": "test/functional/p2p_opportunistic_1p1c.py",
      "position": 298,
      "original_position": 281,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "30c9e6bc4e9f8b8b606e55435dc3f743cb2dd670",
      "in_reply_to_id": 1578550174,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I've done some more digging on this and looks like this is an interference between `test_orphan_consensus_failure` and `test_parent_consensus_failure`.  The `low_fee_parent` created in the former is the exact same as the one created in the latter.",
      "created_at": "2024-04-25T14:10:52Z",
      "updated_at": "2024-04-25T14:10:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1579549901",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1579549901"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 298,
      "original_line": 298,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1579554883",
      "pull_request_review_id": 2022646077,
      "id": 1579554883,
      "node_id": "PRRC_kwDOABII585eJhhD",
      "diff_hunk": "@@ -0,0 +1,392 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test opportunistic 1p1c package submission logic.\n+\"\"\"\n+\n+from decimal import Decimal\n+import time\n+from test_framework.messages import (\n+    CInv,\n+    CTxInWitness,\n+    MSG_WTX,\n+    msg_inv,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    fill_mempool,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+# Number of seconds to wait to ensure no getdata is received\n+GETDATA_WAIT = 60\n+\n+def cleanup(func):\n+    def wrapper(self, *args, **kwargs):\n+        try:\n+            func(self, *args, **kwargs)\n+        finally:\n+            self.nodes[0].disconnect_p2ps()\n+            # Do not clear the node's mempool, as each test requires mempool min feerate > min\n+            # relay feerate. However, do check that this is the case.\n+            assert self.nodes[0].getmempoolinfo()[\"mempoolminfee\"] > self.nodes[0].getnetworkinfo()[\"relayfee\"]\n+            # Ensure we do not try to spend the same UTXOs in subsequent tests, as they will look like RBF attempts.\n+            self.wallet.rescan_utxos(include_mempool=True)\n+\n+            # Resets if mocktime was used\n+            self.nodes[0].setmocktime(0)\n+    return wrapper\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+        ]]\n+        self.supports_cli = False\n+\n+    @cleanup\n+    def test_basic_child_then_parent(self):\n+        node = self.nodes[0]\n+        self.log.info(\"Check that opportunistic 1p1c logic works when child is received before parent\")\n+\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first (perhaps the low feerate parent didn't meet feefilter or the requests were sent to different nodes). It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. Sender relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 4. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+        node.disconnect_p2ps()\n+\n+    @cleanup\n+    def test_basic_parent_then_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=1, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=2, connection_type=\"outbound-full-relay\")\n+\n+        # 1. Parent is relayed first. It is too low feerate.\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer_sender.wait_for_getdata([parent_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer_ignored, check that it is ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+\n+        # 2. Child is relayed next. It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 3. Node requests the missing parent by txid.\n+        # It should do so even if it has previously rejected that parent for being too low feerate.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 4. Sender re-relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 5. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+    @cleanup\n+    def test_low_and_high_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        # This feerate is above mempoolminfee, but not enough to also bump the low feerate parent.\n+        feerate_just_above = node.getmempoolinfo()[\"mempoolminfee\"]\n+        med_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=feerate_just_above)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=3, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=4, connection_type=\"outbound-full-relay\")\n+\n+        self.log.info(\"Check that tx caches low fee parent + low fee child package rejections\")\n+\n+        # 1. Send parent, rejected for being low feerate.\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer_sender.wait_for_getdata([parent_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer_ignored, check that it is ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+\n+        # 2. Send an (orphan) child that has a higher feerate, but not enough to bump the parent.\n+        low_child_wtxid_int = int(med_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([low_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(med_fee_child[\"tx\"]))\n+\n+        # 3. Node requests the orphan's missing parent.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 4. The low parent + low child are submitted as a package. They are not accepted due to low package feerate.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+        assert med_fee_child[\"txid\"] not in node.getrawmempool()\n+\n+        # If peer_ignored announces the low feerate child, it should be ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+        # If either peer sends the parent again, package evaluation should not be attempted\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        peer_ignored.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 5. Send the high feerate (orphan) child\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 6. Node requests the orphan's parent, even though it has already been rejected, both by\n+        # itself and with a child. This is necessary, otherwise high_fee_child can be censored.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 7. The low feerate parent + high feerate child are submitted as a package.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 8. Both transactions should now be in mempool\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+    @cleanup\n+    def test_orphan_consensus_failure(self):\n+        self.log.info(\"Check opportunistic 1p1c logic with consensus-invalid orphan causes disconnect of the correct peer\")\n+        node = self.nodes[0]\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        coin = low_fee_parent[\"new_utxo\"]\n+        address = node.get_deterministic_priv_key().address\n+        # Create raw transaction spending the parent, but with no signature (a consensus error).\n+        hex_orphan_no_sig = node.createrawtransaction([{\"txid\": coin[\"txid\"], \"vout\": coin[\"vout\"]}], {address : coin[\"value\"] - Decimal(\"0.0001\")})\n+        tx_orphan_bad_wit = tx_from_hex(hex_orphan_no_sig)\n+        tx_orphan_bad_wit.wit.vtxinwit.append(CTxInWitness())\n+        tx_orphan_bad_wit.wit.vtxinwit[0].scriptWitness.stack = [b'garbage']\n+\n+        bad_orphan_sender = node.add_p2p_connection(P2PInterface())\n+        parent_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first. It is missing an input.\n+        child_wtxid_int = int(tx_orphan_bad_wit.getwtxid(), 16)\n+        bad_orphan_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=child_wtxid_int)]))\n+        bad_orphan_sender.wait_for_getdata([child_wtxid_int])\n+        bad_orphan_sender.send_and_ping(msg_tx(tx_orphan_bad_wit))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        bad_orphan_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. A different peer relays the parent. Parent+Child are evaluated as a package and rejected.\n+        parent_sender.send_message(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 4. Transactions should not be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] not in node_mempool\n+        assert tx_orphan_bad_wit.rehash() not in node_mempool\n+\n+        # 5. Peer that sent a consensus-invalid transaction should be disconnected.\n+        bad_orphan_sender.wait_for_disconnect()\n+\n+        # The peer that didn't provide the orphan should not be disconnected.\n+        parent_sender.sync_with_ping()\n+\n+    @cleanup\n+    def test_parent_consensus_failure(self):\n+        self.log.info(\"Check opportunistic 1p1c logic with consensus-invalid parent causes disconnect of the correct peer\")\n+        node = self.nodes[0]\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+\n+        # Create invalid version of parent with a bad signature.\n+        tx_parent_bad_wit = tx_from_hex(low_fee_parent[\"hex\"])\n+        tx_parent_bad_wit.wit.vtxinwit.append(CTxInWitness())\n+        tx_parent_bad_wit.wit.vtxinwit[0].scriptWitness.stack = [b'garbage']\n+\n+        package_sender = node.add_p2p_connection(P2PInterface())\n+        fake_parent_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first. It is missing an input.\n+        child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        package_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=child_wtxid_int)]))\n+        package_sender.wait_for_getdata([child_wtxid_int])\n+        package_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(tx_parent_bad_wit.rehash(), 16)\n+        package_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. A different node relays the parent. The parent is first evaluated by itself and\n+        # rejected for being too low feerate. Then it is evaluated as a package and, after passing\n+        # feerate checks, rejected for having a bad signature (consensus error).\n+        fake_parent_sender.send_message(msg_tx(tx_parent_bad_wit))\n+\n+        # 4. Transactions should not be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert tx_parent_bad_wit.rehash() not in node_mempool\n+        assert high_fee_child[\"txid\"] not in node_mempool\n+\n+        # 5. Peer sent a consensus-invalid transaction.\n+        fake_parent_sender.wait_for_disconnect()\n+\n+        self.log.info(\"Check that fake parent does not cause orphan to be deleted and real package can still be submitted\")\n+        # 6. Child-sending should not have been punished and the orphan should remain in orphanage.\n+        # It can send the \"real\" parent transaction, and the package is accepted.\n+        package_sender.sync_with_ping()\n+        package_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))",
      "path": "test/functional/p2p_opportunistic_1p1c.py",
      "position": 298,
      "original_position": 281,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "30c9e6bc4e9f8b8b606e55435dc3f743cb2dd670",
      "in_reply_to_id": 1578550174,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> this is from `test_orphan_consensus_failure` causing the exact same parent to be added to `m_recent_rejects_reconsiderable`\r\n> \r\n> Can we somehow cause chaintip updates during cleanup, without dropping minfee too much? What if cleanup detects that it went down too much, then calls `fill_mempool` again?\r\n\r\nlol, I missed this 🤣 ",
      "created_at": "2024-04-25T14:13:58Z",
      "updated_at": "2024-04-25T14:13:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1579554883",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1579554883"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 298,
      "original_line": 298,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1579558091",
      "pull_request_review_id": 2022652271,
      "id": 1579558091,
      "node_id": "PRRC_kwDOABII585eJiTL",
      "diff_hunk": "@@ -0,0 +1,392 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test opportunistic 1p1c package submission logic.\n+\"\"\"\n+\n+from decimal import Decimal\n+import time\n+from test_framework.messages import (\n+    CInv,\n+    CTxInWitness,\n+    MSG_WTX,\n+    msg_inv,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    fill_mempool,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+# Number of seconds to wait to ensure no getdata is received\n+GETDATA_WAIT = 60\n+\n+def cleanup(func):\n+    def wrapper(self, *args, **kwargs):\n+        try:\n+            func(self, *args, **kwargs)\n+        finally:\n+            self.nodes[0].disconnect_p2ps()\n+            # Do not clear the node's mempool, as each test requires mempool min feerate > min\n+            # relay feerate. However, do check that this is the case.\n+            assert self.nodes[0].getmempoolinfo()[\"mempoolminfee\"] > self.nodes[0].getnetworkinfo()[\"relayfee\"]\n+            # Ensure we do not try to spend the same UTXOs in subsequent tests, as they will look like RBF attempts.\n+            self.wallet.rescan_utxos(include_mempool=True)\n+\n+            # Resets if mocktime was used\n+            self.nodes[0].setmocktime(0)\n+    return wrapper\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+        ]]\n+        self.supports_cli = False\n+\n+    @cleanup\n+    def test_basic_child_then_parent(self):\n+        node = self.nodes[0]\n+        self.log.info(\"Check that opportunistic 1p1c logic works when child is received before parent\")\n+\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first (perhaps the low feerate parent didn't meet feefilter or the requests were sent to different nodes). It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. Sender relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 4. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+        node.disconnect_p2ps()\n+\n+    @cleanup\n+    def test_basic_parent_then_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=1, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=2, connection_type=\"outbound-full-relay\")\n+\n+        # 1. Parent is relayed first. It is too low feerate.\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer_sender.wait_for_getdata([parent_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer_ignored, check that it is ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+\n+        # 2. Child is relayed next. It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 3. Node requests the missing parent by txid.\n+        # It should do so even if it has previously rejected that parent for being too low feerate.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 4. Sender re-relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 5. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+    @cleanup\n+    def test_low_and_high_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        # This feerate is above mempoolminfee, but not enough to also bump the low feerate parent.\n+        feerate_just_above = node.getmempoolinfo()[\"mempoolminfee\"]\n+        med_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=feerate_just_above)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=3, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=4, connection_type=\"outbound-full-relay\")\n+\n+        self.log.info(\"Check that tx caches low fee parent + low fee child package rejections\")\n+\n+        # 1. Send parent, rejected for being low feerate.\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer_sender.wait_for_getdata([parent_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer_ignored, check that it is ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+\n+        # 2. Send an (orphan) child that has a higher feerate, but not enough to bump the parent.\n+        low_child_wtxid_int = int(med_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([low_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(med_fee_child[\"tx\"]))\n+\n+        # 3. Node requests the orphan's missing parent.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 4. The low parent + low child are submitted as a package. They are not accepted due to low package feerate.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+        assert med_fee_child[\"txid\"] not in node.getrawmempool()\n+\n+        # If peer_ignored announces the low feerate child, it should be ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+        # If either peer sends the parent again, package evaluation should not be attempted\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        peer_ignored.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 5. Send the high feerate (orphan) child\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 6. Node requests the orphan's parent, even though it has already been rejected, both by\n+        # itself and with a child. This is necessary, otherwise high_fee_child can be censored.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 7. The low feerate parent + high feerate child are submitted as a package.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 8. Both transactions should now be in mempool\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+    @cleanup\n+    def test_orphan_consensus_failure(self):\n+        self.log.info(\"Check opportunistic 1p1c logic with consensus-invalid orphan causes disconnect of the correct peer\")\n+        node = self.nodes[0]\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        coin = low_fee_parent[\"new_utxo\"]\n+        address = node.get_deterministic_priv_key().address\n+        # Create raw transaction spending the parent, but with no signature (a consensus error).\n+        hex_orphan_no_sig = node.createrawtransaction([{\"txid\": coin[\"txid\"], \"vout\": coin[\"vout\"]}], {address : coin[\"value\"] - Decimal(\"0.0001\")})\n+        tx_orphan_bad_wit = tx_from_hex(hex_orphan_no_sig)\n+        tx_orphan_bad_wit.wit.vtxinwit.append(CTxInWitness())\n+        tx_orphan_bad_wit.wit.vtxinwit[0].scriptWitness.stack = [b'garbage']\n+\n+        bad_orphan_sender = node.add_p2p_connection(P2PInterface())\n+        parent_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first. It is missing an input.\n+        child_wtxid_int = int(tx_orphan_bad_wit.getwtxid(), 16)\n+        bad_orphan_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=child_wtxid_int)]))\n+        bad_orphan_sender.wait_for_getdata([child_wtxid_int])\n+        bad_orphan_sender.send_and_ping(msg_tx(tx_orphan_bad_wit))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        bad_orphan_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. A different peer relays the parent. Parent+Child are evaluated as a package and rejected.\n+        parent_sender.send_message(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 4. Transactions should not be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] not in node_mempool\n+        assert tx_orphan_bad_wit.rehash() not in node_mempool\n+\n+        # 5. Peer that sent a consensus-invalid transaction should be disconnected.\n+        bad_orphan_sender.wait_for_disconnect()\n+\n+        # The peer that didn't provide the orphan should not be disconnected.\n+        parent_sender.sync_with_ping()\n+\n+    @cleanup\n+    def test_parent_consensus_failure(self):\n+        self.log.info(\"Check opportunistic 1p1c logic with consensus-invalid parent causes disconnect of the correct peer\")\n+        node = self.nodes[0]\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+\n+        # Create invalid version of parent with a bad signature.\n+        tx_parent_bad_wit = tx_from_hex(low_fee_parent[\"hex\"])\n+        tx_parent_bad_wit.wit.vtxinwit.append(CTxInWitness())\n+        tx_parent_bad_wit.wit.vtxinwit[0].scriptWitness.stack = [b'garbage']\n+\n+        package_sender = node.add_p2p_connection(P2PInterface())\n+        fake_parent_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first. It is missing an input.\n+        child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        package_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=child_wtxid_int)]))\n+        package_sender.wait_for_getdata([child_wtxid_int])\n+        package_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(tx_parent_bad_wit.rehash(), 16)\n+        package_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. A different node relays the parent. The parent is first evaluated by itself and\n+        # rejected for being too low feerate. Then it is evaluated as a package and, after passing\n+        # feerate checks, rejected for having a bad signature (consensus error).\n+        fake_parent_sender.send_message(msg_tx(tx_parent_bad_wit))\n+\n+        # 4. Transactions should not be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert tx_parent_bad_wit.rehash() not in node_mempool\n+        assert high_fee_child[\"txid\"] not in node_mempool\n+\n+        # 5. Peer sent a consensus-invalid transaction.\n+        fake_parent_sender.wait_for_disconnect()\n+\n+        self.log.info(\"Check that fake parent does not cause orphan to be deleted and real package can still be submitted\")\n+        # 6. Child-sending should not have been punished and the orphan should remain in orphanage.\n+        # It can send the \"real\" parent transaction, and the package is accepted.\n+        package_sender.sync_with_ping()\n+        package_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))",
      "path": "test/functional/p2p_opportunistic_1p1c.py",
      "position": 298,
      "original_position": 281,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "30c9e6bc4e9f8b8b606e55435dc3f743cb2dd670",
      "in_reply_to_id": 1578550174,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Adding this block to `cleanup` resets the cache, though I haven't looked at if this messes with minfee too much:\r\n\r\n```\r\n            # Cause small re-org and tickle AlreadyHaveTx to flush reject filters between tests\r\n            chaintip = self.nodes[0].getbestblockhash()\r\n            self.nodes[0].invalidateblock(chaintip)\r\n            peer_sender = self.nodes[0].add_p2p_connection(P2PInterface())\r\n            peer_sender.send_message(msg_tx(CTransaction()))\r\n            peer_sender.wait_for_disconnect()\r\n            self.nodes[0].reconsiderblock(chaintip)\r\n```",
      "created_at": "2024-04-25T14:16:03Z",
      "updated_at": "2024-04-25T14:16:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1579558091",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1579558091"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 298,
      "original_line": 298,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1579565183",
      "pull_request_review_id": 2022664176,
      "id": 1579565183,
      "node_id": "PRRC_kwDOABII585eJkB_",
      "diff_hunk": "@@ -0,0 +1,392 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test opportunistic 1p1c package submission logic.\n+\"\"\"\n+\n+from decimal import Decimal\n+import time\n+from test_framework.messages import (\n+    CInv,\n+    CTxInWitness,\n+    MSG_WTX,\n+    msg_inv,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    fill_mempool,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+# Number of seconds to wait to ensure no getdata is received\n+GETDATA_WAIT = 60\n+\n+def cleanup(func):\n+    def wrapper(self, *args, **kwargs):\n+        try:\n+            func(self, *args, **kwargs)\n+        finally:\n+            self.nodes[0].disconnect_p2ps()\n+            # Do not clear the node's mempool, as each test requires mempool min feerate > min\n+            # relay feerate. However, do check that this is the case.\n+            assert self.nodes[0].getmempoolinfo()[\"mempoolminfee\"] > self.nodes[0].getnetworkinfo()[\"relayfee\"]\n+            # Ensure we do not try to spend the same UTXOs in subsequent tests, as they will look like RBF attempts.\n+            self.wallet.rescan_utxos(include_mempool=True)\n+\n+            # Resets if mocktime was used\n+            self.nodes[0].setmocktime(0)\n+    return wrapper\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+        ]]\n+        self.supports_cli = False\n+\n+    @cleanup\n+    def test_basic_child_then_parent(self):\n+        node = self.nodes[0]\n+        self.log.info(\"Check that opportunistic 1p1c logic works when child is received before parent\")\n+\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first (perhaps the low feerate parent didn't meet feefilter or the requests were sent to different nodes). It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. Sender relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 4. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+        node.disconnect_p2ps()\n+\n+    @cleanup\n+    def test_basic_parent_then_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=1, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=2, connection_type=\"outbound-full-relay\")\n+\n+        # 1. Parent is relayed first. It is too low feerate.\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer_sender.wait_for_getdata([parent_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer_ignored, check that it is ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+\n+        # 2. Child is relayed next. It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 3. Node requests the missing parent by txid.\n+        # It should do so even if it has previously rejected that parent for being too low feerate.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 4. Sender re-relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 5. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+    @cleanup\n+    def test_low_and_high_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        # This feerate is above mempoolminfee, but not enough to also bump the low feerate parent.\n+        feerate_just_above = node.getmempoolinfo()[\"mempoolminfee\"]\n+        med_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=feerate_just_above)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=3, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=4, connection_type=\"outbound-full-relay\")\n+\n+        self.log.info(\"Check that tx caches low fee parent + low fee child package rejections\")\n+\n+        # 1. Send parent, rejected for being low feerate.\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer_sender.wait_for_getdata([parent_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer_ignored, check that it is ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+\n+        # 2. Send an (orphan) child that has a higher feerate, but not enough to bump the parent.\n+        low_child_wtxid_int = int(med_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([low_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(med_fee_child[\"tx\"]))\n+\n+        # 3. Node requests the orphan's missing parent.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 4. The low parent + low child are submitted as a package. They are not accepted due to low package feerate.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+        assert med_fee_child[\"txid\"] not in node.getrawmempool()\n+\n+        # If peer_ignored announces the low feerate child, it should be ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+        # If either peer sends the parent again, package evaluation should not be attempted\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        peer_ignored.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 5. Send the high feerate (orphan) child\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 6. Node requests the orphan's parent, even though it has already been rejected, both by\n+        # itself and with a child. This is necessary, otherwise high_fee_child can be censored.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 7. The low feerate parent + high feerate child are submitted as a package.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 8. Both transactions should now be in mempool\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+    @cleanup\n+    def test_orphan_consensus_failure(self):\n+        self.log.info(\"Check opportunistic 1p1c logic with consensus-invalid orphan causes disconnect of the correct peer\")\n+        node = self.nodes[0]\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        coin = low_fee_parent[\"new_utxo\"]\n+        address = node.get_deterministic_priv_key().address\n+        # Create raw transaction spending the parent, but with no signature (a consensus error).\n+        hex_orphan_no_sig = node.createrawtransaction([{\"txid\": coin[\"txid\"], \"vout\": coin[\"vout\"]}], {address : coin[\"value\"] - Decimal(\"0.0001\")})\n+        tx_orphan_bad_wit = tx_from_hex(hex_orphan_no_sig)\n+        tx_orphan_bad_wit.wit.vtxinwit.append(CTxInWitness())\n+        tx_orphan_bad_wit.wit.vtxinwit[0].scriptWitness.stack = [b'garbage']\n+\n+        bad_orphan_sender = node.add_p2p_connection(P2PInterface())\n+        parent_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first. It is missing an input.\n+        child_wtxid_int = int(tx_orphan_bad_wit.getwtxid(), 16)\n+        bad_orphan_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=child_wtxid_int)]))\n+        bad_orphan_sender.wait_for_getdata([child_wtxid_int])\n+        bad_orphan_sender.send_and_ping(msg_tx(tx_orphan_bad_wit))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        bad_orphan_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. A different peer relays the parent. Parent+Child are evaluated as a package and rejected.\n+        parent_sender.send_message(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 4. Transactions should not be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] not in node_mempool\n+        assert tx_orphan_bad_wit.rehash() not in node_mempool\n+\n+        # 5. Peer that sent a consensus-invalid transaction should be disconnected.\n+        bad_orphan_sender.wait_for_disconnect()\n+\n+        # The peer that didn't provide the orphan should not be disconnected.\n+        parent_sender.sync_with_ping()\n+\n+    @cleanup\n+    def test_parent_consensus_failure(self):\n+        self.log.info(\"Check opportunistic 1p1c logic with consensus-invalid parent causes disconnect of the correct peer\")\n+        node = self.nodes[0]\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+\n+        # Create invalid version of parent with a bad signature.\n+        tx_parent_bad_wit = tx_from_hex(low_fee_parent[\"hex\"])\n+        tx_parent_bad_wit.wit.vtxinwit.append(CTxInWitness())\n+        tx_parent_bad_wit.wit.vtxinwit[0].scriptWitness.stack = [b'garbage']\n+\n+        package_sender = node.add_p2p_connection(P2PInterface())\n+        fake_parent_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first. It is missing an input.\n+        child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        package_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=child_wtxid_int)]))\n+        package_sender.wait_for_getdata([child_wtxid_int])\n+        package_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(tx_parent_bad_wit.rehash(), 16)\n+        package_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. A different node relays the parent. The parent is first evaluated by itself and\n+        # rejected for being too low feerate. Then it is evaluated as a package and, after passing\n+        # feerate checks, rejected for having a bad signature (consensus error).\n+        fake_parent_sender.send_message(msg_tx(tx_parent_bad_wit))\n+\n+        # 4. Transactions should not be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert tx_parent_bad_wit.rehash() not in node_mempool\n+        assert high_fee_child[\"txid\"] not in node_mempool\n+\n+        # 5. Peer sent a consensus-invalid transaction.\n+        fake_parent_sender.wait_for_disconnect()\n+\n+        self.log.info(\"Check that fake parent does not cause orphan to be deleted and real package can still be submitted\")\n+        # 6. Child-sending should not have been punished and the orphan should remain in orphanage.\n+        # It can send the \"real\" parent transaction, and the package is accepted.\n+        package_sender.sync_with_ping()\n+        package_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))",
      "path": "test/functional/p2p_opportunistic_1p1c.py",
      "position": 298,
      "original_position": 281,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "30c9e6bc4e9f8b8b606e55435dc3f743cb2dd670",
      "in_reply_to_id": 1578550174,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> Can we somehow cause chaintip updates during cleanup, without dropping minfee too much? What if cleanup detects that it went down too much, then calls fill_mempool again?\r\n\r\nHm, `fill_mempool` isn't really built for this (though we can change that). I'll try to see if we can make sure we don't reuse utxos.",
      "created_at": "2024-04-25T14:20:41Z",
      "updated_at": "2024-04-25T14:20:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1579565183",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1579565183"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 298,
      "original_line": 298,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1580693160",
      "pull_request_review_id": 2024465284,
      "id": 1580693160,
      "node_id": "PRRC_kwDOABII585eN3ao",
      "diff_hunk": "@@ -0,0 +1,175 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test that 1p1c package submission allows a 1p1c package to propagate in a \"network\" of nodes. Send\n+various packages from different nodes on a network in which some nodes have already received some of\n+the transactions (and submitted them to mempool, kept them as orphans or rejected them as\n+too-low-feerate transactions). The packages should be received and accepted by all nodes.\n+\"\"\"\n+\n+from decimal import Decimal\n+from math import ceil\n+\n+from test_framework.messages import (\n+    msg_tx,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    fill_mempool,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 4\n+        # hugely speeds up the test, as it involves multiple hops of tx relay.\n+        self.noban_tx_relay = True\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+        ]] * self.num_nodes\n+        self.supports_cli = False\n+\n+    def raise_network_minfee(self):\n+        filler_wallet = MiniWallet(self.nodes[0])\n+        fill_mempool(self, self.nodes[0], filler_wallet)\n+\n+        self.log.debug(\"Wait for the network to sync mempools\")\n+        self.sync_mempools()\n+\n+        self.log.debug(\"Check that all nodes' mempool minimum feerates are above min relay feerate\")\n+        for node in self.nodes:\n+            assert_equal(node.getmempoolinfo()['minrelaytxfee'], FEERATE_1SAT_VB)\n+            assert_greater_than(node.getmempoolinfo()['mempoolminfee'], FEERATE_1SAT_VB)\n+\n+    def create_basic_1p1c(self, wallet):\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+        package_hex_basic = [low_fee_parent[\"hex\"], high_fee_child[\"hex\"]]\n+        return package_hex_basic, low_fee_parent[\"tx\"], high_fee_child[\"tx\"]\n+\n+    def create_package_2outs(self, wallet):\n+        # First create a tester tx to see the vsize, and then adjust the fees\n+        placeholder_fee = 100000",
      "path": "test/functional/p2p_1p1c_network.py",
      "position": null,
      "original_position": 67,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "30c9e6bc4e9f8b8b606e55435dc3f743cb2dd670",
      "in_reply_to_id": 1578402851,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "removed",
      "created_at": "2024-04-26T08:45:37Z",
      "updated_at": "2024-04-26T10:10:19Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1580693160",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1580693160"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 67,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1580693314",
      "pull_request_review_id": 2024465284,
      "id": 1580693314,
      "node_id": "PRRC_kwDOABII585eN3dC",
      "diff_hunk": "@@ -0,0 +1,175 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test that 1p1c package submission allows a 1p1c package to propagate in a \"network\" of nodes. Send\n+various packages from different nodes on a network in which some nodes have already received some of\n+the transactions (and submitted them to mempool, kept them as orphans or rejected them as\n+too-low-feerate transactions). The packages should be received and accepted by all nodes.\n+\"\"\"\n+\n+from decimal import Decimal\n+from math import ceil\n+\n+from test_framework.messages import (\n+    msg_tx,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    fill_mempool,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 4\n+        # hugely speeds up the test, as it involves multiple hops of tx relay.\n+        self.noban_tx_relay = True\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+        ]] * self.num_nodes\n+        self.supports_cli = False\n+\n+    def raise_network_minfee(self):\n+        filler_wallet = MiniWallet(self.nodes[0])\n+        fill_mempool(self, self.nodes[0], filler_wallet)\n+\n+        self.log.debug(\"Wait for the network to sync mempools\")\n+        self.sync_mempools()\n+\n+        self.log.debug(\"Check that all nodes' mempool minimum feerates are above min relay feerate\")\n+        for node in self.nodes:\n+            assert_equal(node.getmempoolinfo()['minrelaytxfee'], FEERATE_1SAT_VB)\n+            assert_greater_than(node.getmempoolinfo()['mempoolminfee'], FEERATE_1SAT_VB)\n+\n+    def create_basic_1p1c(self, wallet):\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+        package_hex_basic = [low_fee_parent[\"hex\"], high_fee_child[\"hex\"]]\n+        return package_hex_basic, low_fee_parent[\"tx\"], high_fee_child[\"tx\"]\n+\n+    def create_package_2outs(self, wallet):\n+        # First create a tester tx to see the vsize, and then adjust the fees\n+        placeholder_fee = 100000\n+        utxo_for_2outs = wallet.get_utxo(confirmed_only=True)\n+\n+        low_fee_parent_2outs_tester = wallet.create_self_transfer_multi(\n+            utxos_to_spend=[utxo_for_2outs],\n+            num_outputs=2,\n+            fee_per_output=placeholder_fee,\n+            confirmed_only=True",
      "path": "test/functional/p2p_1p1c_network.py",
      "position": null,
      "original_position": 74,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "30c9e6bc4e9f8b8b606e55435dc3f743cb2dd670",
      "in_reply_to_id": 1578404294,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "removed",
      "created_at": "2024-04-26T08:45:43Z",
      "updated_at": "2024-04-26T10:10:19Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1580693314",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1580693314"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 74,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1580698318",
      "pull_request_review_id": 2024465284,
      "id": 1580698318,
      "node_id": "PRRC_kwDOABII585eN4rO",
      "diff_hunk": "@@ -0,0 +1,175 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test that 1p1c package submission allows a 1p1c package to propagate in a \"network\" of nodes. Send\n+various packages from different nodes on a network in which some nodes have already received some of\n+the transactions (and submitted them to mempool, kept them as orphans or rejected them as\n+too-low-feerate transactions). The packages should be received and accepted by all nodes.\n+\"\"\"\n+\n+from decimal import Decimal\n+from math import ceil\n+\n+from test_framework.messages import (\n+    msg_tx,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    fill_mempool,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 4\n+        # hugely speeds up the test, as it involves multiple hops of tx relay.\n+        self.noban_tx_relay = True\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+        ]] * self.num_nodes\n+        self.supports_cli = False\n+\n+    def raise_network_minfee(self):\n+        filler_wallet = MiniWallet(self.nodes[0])\n+        fill_mempool(self, self.nodes[0], filler_wallet)\n+\n+        self.log.debug(\"Wait for the network to sync mempools\")\n+        self.sync_mempools()\n+\n+        self.log.debug(\"Check that all nodes' mempool minimum feerates are above min relay feerate\")\n+        for node in self.nodes:\n+            assert_equal(node.getmempoolinfo()['minrelaytxfee'], FEERATE_1SAT_VB)\n+            assert_greater_than(node.getmempoolinfo()['mempoolminfee'], FEERATE_1SAT_VB)\n+\n+    def create_basic_1p1c(self, wallet):\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+        package_hex_basic = [low_fee_parent[\"hex\"], high_fee_child[\"hex\"]]\n+        return package_hex_basic, low_fee_parent[\"tx\"], high_fee_child[\"tx\"]\n+\n+    def create_package_2outs(self, wallet):\n+        # First create a tester tx to see the vsize, and then adjust the fees\n+        placeholder_fee = 100000\n+        utxo_for_2outs = wallet.get_utxo(confirmed_only=True)\n+\n+        low_fee_parent_2outs_tester = wallet.create_self_transfer_multi(\n+            utxos_to_spend=[utxo_for_2outs],\n+            num_outputs=2,\n+            fee_per_output=placeholder_fee,\n+            confirmed_only=True\n+        )\n+\n+        # Target 1sat/vB so the number of satoshis is equal to the vsize.\n+        # Round up. The goal is to be between min relay feerate and mempool min feerate.\n+        fee_2outs = ceil(low_fee_parent_2outs_tester[\"tx\"].get_vsize() / 2)\n+\n+        low_fee_parent_2outs = wallet.create_self_transfer_multi(\n+            utxos_to_spend=[utxo_for_2outs],\n+            num_outputs=2,\n+            fee_per_output=fee_2outs,\n+        )\n+\n+        # Now create the child\n+        high_fee_child_2outs = wallet.create_self_transfer_multi(\n+            utxos_to_spend=low_fee_parent_2outs[\"new_utxos\"][::-1],\n+            fee_per_output=fee_2outs*100,\n+        )\n+        return [low_fee_parent_2outs[\"hex\"], high_fee_child_2outs[\"hex\"]], low_fee_parent_2outs[\"tx\"], high_fee_child_2outs[\"tx\"]\n+\n+    def create_package_2p1c(self, wallet):\n+        parent1 = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB*10, confirmed_only=True)\n+        parent2 = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB*20, confirmed_only=True)\n+        child = wallet.create_self_transfer_multi(\n+            utxos_to_spend=[parent1[\"new_utxo\"], parent2[\"new_utxo\"]],\n+            fee_per_output=999*parent1[\"tx\"].get_vsize(),\n+        )\n+        return [parent1[\"hex\"], parent2[\"hex\"], child[\"hex\"]], parent1[\"tx\"], parent2[\"tx\"], child[\"tx\"]\n+\n+    def create_packages(self):\n+        # 1: Basic 1-parent-1-child package, parent 1sat/vB, child 999sat/vB\n+        package_hex_1, parent_1, child_1 = self.create_basic_1p1c(self.wallet)\n+\n+        # 2: same as 1, parent's txid is the same as its wtxid.\n+        package_hex_2, parent_2, child_2 = self.create_basic_1p1c(self.wallet_nonsegwit)\n+\n+        # 3: 2-parent-1-child package. Both parents are above mempool min feerate. No package submission happens.\n+        # We require packages to be child-with-unconfirmed-parents and only allow 1-parent-1-child packages.\n+        package_hex_3, parent_31, parent_32, child_3 = self.create_package_2p1c(self.wallet)\n+\n+        # 4: parent + child package where the child spends 2 different outputs from the parent.\n+        package_hex_4, parent_4, child_4 = self.create_package_2outs(self.wallet)\n+\n+        # Assemble return results\n+        packages_to_submit = []\n+        txns_to_send = [[]] * self.num_nodes",
      "path": "test/functional/p2p_1p1c_network.py",
      "position": null,
      "original_position": 119,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "30c9e6bc4e9f8b8b606e55435dc3f743cb2dd670",
      "in_reply_to_id": 1578426417,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I've changed them to just construct everything in 1 line, should be clearer",
      "created_at": "2024-04-26T08:48:38Z",
      "updated_at": "2024-04-26T10:10:19Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1580698318",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1580698318"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 119,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1580698811",
      "pull_request_review_id": 2024465284,
      "id": 1580698811,
      "node_id": "PRRC_kwDOABII585eN4y7",
      "diff_hunk": "@@ -0,0 +1,175 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test that 1p1c package submission allows a 1p1c package to propagate in a \"network\" of nodes. Send\n+various packages from different nodes on a network in which some nodes have already received some of\n+the transactions (and submitted them to mempool, kept them as orphans or rejected them as\n+too-low-feerate transactions). The packages should be received and accepted by all nodes.\n+\"\"\"\n+\n+from decimal import Decimal\n+from math import ceil\n+\n+from test_framework.messages import (\n+    msg_tx,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    fill_mempool,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 4\n+        # hugely speeds up the test, as it involves multiple hops of tx relay.\n+        self.noban_tx_relay = True\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+        ]] * self.num_nodes\n+        self.supports_cli = False\n+\n+    def raise_network_minfee(self):\n+        filler_wallet = MiniWallet(self.nodes[0])\n+        fill_mempool(self, self.nodes[0], filler_wallet)\n+\n+        self.log.debug(\"Wait for the network to sync mempools\")\n+        self.sync_mempools()\n+\n+        self.log.debug(\"Check that all nodes' mempool minimum feerates are above min relay feerate\")\n+        for node in self.nodes:\n+            assert_equal(node.getmempoolinfo()['minrelaytxfee'], FEERATE_1SAT_VB)\n+            assert_greater_than(node.getmempoolinfo()['mempoolminfee'], FEERATE_1SAT_VB)\n+\n+    def create_basic_1p1c(self, wallet):\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+        package_hex_basic = [low_fee_parent[\"hex\"], high_fee_child[\"hex\"]]\n+        return package_hex_basic, low_fee_parent[\"tx\"], high_fee_child[\"tx\"]\n+\n+    def create_package_2outs(self, wallet):\n+        # First create a tester tx to see the vsize, and then adjust the fees\n+        placeholder_fee = 100000\n+        utxo_for_2outs = wallet.get_utxo(confirmed_only=True)\n+\n+        low_fee_parent_2outs_tester = wallet.create_self_transfer_multi(\n+            utxos_to_spend=[utxo_for_2outs],\n+            num_outputs=2,\n+            fee_per_output=placeholder_fee,\n+            confirmed_only=True\n+        )\n+\n+        # Target 1sat/vB so the number of satoshis is equal to the vsize.\n+        # Round up. The goal is to be between min relay feerate and mempool min feerate.\n+        fee_2outs = ceil(low_fee_parent_2outs_tester[\"tx\"].get_vsize() / 2)\n+\n+        low_fee_parent_2outs = wallet.create_self_transfer_multi(\n+            utxos_to_spend=[utxo_for_2outs],\n+            num_outputs=2,\n+            fee_per_output=fee_2outs,\n+        )\n+\n+        # Now create the child\n+        high_fee_child_2outs = wallet.create_self_transfer_multi(\n+            utxos_to_spend=low_fee_parent_2outs[\"new_utxos\"][::-1],\n+            fee_per_output=fee_2outs*100,\n+        )\n+        return [low_fee_parent_2outs[\"hex\"], high_fee_child_2outs[\"hex\"]], low_fee_parent_2outs[\"tx\"], high_fee_child_2outs[\"tx\"]\n+\n+    def create_package_2p1c(self, wallet):\n+        parent1 = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB*10, confirmed_only=True)\n+        parent2 = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB*20, confirmed_only=True)\n+        child = wallet.create_self_transfer_multi(\n+            utxos_to_spend=[parent1[\"new_utxo\"], parent2[\"new_utxo\"]],\n+            fee_per_output=999*parent1[\"tx\"].get_vsize(),\n+        )\n+        return [parent1[\"hex\"], parent2[\"hex\"], child[\"hex\"]], parent1[\"tx\"], parent2[\"tx\"], child[\"tx\"]\n+\n+    def create_packages(self):\n+        # 1: Basic 1-parent-1-child package, parent 1sat/vB, child 999sat/vB\n+        package_hex_1, parent_1, child_1 = self.create_basic_1p1c(self.wallet)\n+\n+        # 2: same as 1, parent's txid is the same as its wtxid.\n+        package_hex_2, parent_2, child_2 = self.create_basic_1p1c(self.wallet_nonsegwit)\n+\n+        # 3: 2-parent-1-child package. Both parents are above mempool min feerate. No package submission happens.\n+        # We require packages to be child-with-unconfirmed-parents and only allow 1-parent-1-child packages.\n+        package_hex_3, parent_31, parent_32, child_3 = self.create_package_2p1c(self.wallet)\n+\n+        # 4: parent + child package where the child spends 2 different outputs from the parent.\n+        package_hex_4, parent_4, child_4 = self.create_package_2outs(self.wallet)\n+\n+        # Assemble return results\n+        packages_to_submit = []\n+        txns_to_send = [[]] * self.num_nodes\n+\n+        packages_to_submit.append(package_hex_1)\n+        packages_to_submit.append(package_hex_2)\n+        packages_to_submit.append(package_hex_3)\n+        packages_to_submit.append(package_hex_4)\n+\n+        # node0: sender\n+        # node1: pre-received the children (orphan)\n+        # node3: pre-received the parents (too low fee)\n+        # All nodes receive high_parent_51 ahead of time.",
      "path": "test/functional/p2p_1p1c_network.py",
      "position": null,
      "original_position": 129,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "30c9e6bc4e9f8b8b606e55435dc3f743cb2dd670",
      "in_reply_to_id": 1578179082,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "done",
      "created_at": "2024-04-26T08:48:57Z",
      "updated_at": "2024-04-26T10:10:19Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1580698811",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1580698811"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 129,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1580700450",
      "pull_request_review_id": 2024465284,
      "id": 1580700450,
      "node_id": "PRRC_kwDOABII585eN5Mi",
      "diff_hunk": "@@ -0,0 +1,175 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test that 1p1c package submission allows a 1p1c package to propagate in a \"network\" of nodes. Send\n+various packages from different nodes on a network in which some nodes have already received some of\n+the transactions (and submitted them to mempool, kept them as orphans or rejected them as\n+too-low-feerate transactions). The packages should be received and accepted by all nodes.\n+\"\"\"\n+\n+from decimal import Decimal\n+from math import ceil\n+\n+from test_framework.messages import (\n+    msg_tx,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    fill_mempool,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 4\n+        # hugely speeds up the test, as it involves multiple hops of tx relay.\n+        self.noban_tx_relay = True\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+        ]] * self.num_nodes\n+        self.supports_cli = False\n+\n+    def raise_network_minfee(self):\n+        filler_wallet = MiniWallet(self.nodes[0])\n+        fill_mempool(self, self.nodes[0], filler_wallet)\n+\n+        self.log.debug(\"Wait for the network to sync mempools\")\n+        self.sync_mempools()\n+\n+        self.log.debug(\"Check that all nodes' mempool minimum feerates are above min relay feerate\")\n+        for node in self.nodes:\n+            assert_equal(node.getmempoolinfo()['minrelaytxfee'], FEERATE_1SAT_VB)\n+            assert_greater_than(node.getmempoolinfo()['mempoolminfee'], FEERATE_1SAT_VB)\n+\n+    def create_basic_1p1c(self, wallet):\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+        package_hex_basic = [low_fee_parent[\"hex\"], high_fee_child[\"hex\"]]\n+        return package_hex_basic, low_fee_parent[\"tx\"], high_fee_child[\"tx\"]\n+\n+    def create_package_2outs(self, wallet):\n+        # First create a tester tx to see the vsize, and then adjust the fees\n+        placeholder_fee = 100000\n+        utxo_for_2outs = wallet.get_utxo(confirmed_only=True)\n+\n+        low_fee_parent_2outs_tester = wallet.create_self_transfer_multi(\n+            utxos_to_spend=[utxo_for_2outs],\n+            num_outputs=2,\n+            fee_per_output=placeholder_fee,\n+            confirmed_only=True\n+        )\n+\n+        # Target 1sat/vB so the number of satoshis is equal to the vsize.\n+        # Round up. The goal is to be between min relay feerate and mempool min feerate.\n+        fee_2outs = ceil(low_fee_parent_2outs_tester[\"tx\"].get_vsize() / 2)\n+\n+        low_fee_parent_2outs = wallet.create_self_transfer_multi(\n+            utxos_to_spend=[utxo_for_2outs],\n+            num_outputs=2,\n+            fee_per_output=fee_2outs,\n+        )\n+\n+        # Now create the child\n+        high_fee_child_2outs = wallet.create_self_transfer_multi(\n+            utxos_to_spend=low_fee_parent_2outs[\"new_utxos\"][::-1],\n+            fee_per_output=fee_2outs*100,\n+        )\n+        return [low_fee_parent_2outs[\"hex\"], high_fee_child_2outs[\"hex\"]], low_fee_parent_2outs[\"tx\"], high_fee_child_2outs[\"tx\"]\n+\n+    def create_package_2p1c(self, wallet):\n+        parent1 = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB*10, confirmed_only=True)\n+        parent2 = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB*20, confirmed_only=True)\n+        child = wallet.create_self_transfer_multi(\n+            utxos_to_spend=[parent1[\"new_utxo\"], parent2[\"new_utxo\"]],\n+            fee_per_output=999*parent1[\"tx\"].get_vsize(),\n+        )\n+        return [parent1[\"hex\"], parent2[\"hex\"], child[\"hex\"]], parent1[\"tx\"], parent2[\"tx\"], child[\"tx\"]\n+\n+    def create_packages(self):\n+        # 1: Basic 1-parent-1-child package, parent 1sat/vB, child 999sat/vB\n+        package_hex_1, parent_1, child_1 = self.create_basic_1p1c(self.wallet)\n+\n+        # 2: same as 1, parent's txid is the same as its wtxid.\n+        package_hex_2, parent_2, child_2 = self.create_basic_1p1c(self.wallet_nonsegwit)\n+\n+        # 3: 2-parent-1-child package. Both parents are above mempool min feerate. No package submission happens.\n+        # We require packages to be child-with-unconfirmed-parents and only allow 1-parent-1-child packages.\n+        package_hex_3, parent_31, parent_32, child_3 = self.create_package_2p1c(self.wallet)\n+\n+        # 4: parent + child package where the child spends 2 different outputs from the parent.\n+        package_hex_4, parent_4, child_4 = self.create_package_2outs(self.wallet)\n+\n+        # Assemble return results\n+        packages_to_submit = []\n+        txns_to_send = [[]] * self.num_nodes\n+\n+        packages_to_submit.append(package_hex_1)\n+        packages_to_submit.append(package_hex_2)\n+        packages_to_submit.append(package_hex_3)\n+        packages_to_submit.append(package_hex_4)\n+\n+        # node0: sender\n+        # node1: pre-received the children (orphan)\n+        # node3: pre-received the parents (too low fee)\n+        # All nodes receive high_parent_51 ahead of time.\n+        txns_to_send[1] = [child_1, child_2, parent_31, child_3, child_4]\n+        txns_to_send[2] = [parent_31]\n+        txns_to_send[3] = [parent_1, parent_2, parent_31, parent_4]\n+\n+        return packages_to_submit, txns_to_send\n+\n+    def run_test(self):\n+        self.wallet = MiniWallet(self.nodes[1])\n+        self.wallet_nonsegwit = MiniWallet(self.nodes[2], mode=MiniWalletMode.RAW_P2PK)\n+        self.generate(self.wallet_nonsegwit, 10)\n+        self.generate(self.wallet, 120)\n+\n+        self.log.info(\"Fill mempools with large transactions to raise mempool minimum feerates\")\n+        self.raise_network_minfee()\n+\n+        # Create the transactions.\n+        self.wallet.rescan_utxos(include_mempool=True)\n+        packages_to_submit, transactions_to_presend = self.create_packages()\n+\n+        self.peers = []\n+        for i in range(self.num_nodes):\n+            self.peers.append(self.nodes[i].add_p2p_connection(P2PInterface()))",
      "path": "test/functional/p2p_1p1c_network.py",
      "position": null,
      "original_position": 151,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "30c9e6bc4e9f8b8b606e55435dc3f743cb2dd670",
      "in_reply_to_id": 1578441000,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "done",
      "created_at": "2024-04-26T08:49:38Z",
      "updated_at": "2024-04-26T10:10:19Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1580700450",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1580700450"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": 149,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 151,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1580701947",
      "pull_request_review_id": 2024465284,
      "id": 1580701947,
      "node_id": "PRRC_kwDOABII585eN5j7",
      "diff_hunk": "@@ -0,0 +1,175 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test that 1p1c package submission allows a 1p1c package to propagate in a \"network\" of nodes. Send\n+various packages from different nodes on a network in which some nodes have already received some of\n+the transactions (and submitted them to mempool, kept them as orphans or rejected them as\n+too-low-feerate transactions). The packages should be received and accepted by all nodes.\n+\"\"\"\n+\n+from decimal import Decimal\n+from math import ceil\n+\n+from test_framework.messages import (\n+    msg_tx,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_greater_than,\n+    fill_mempool,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 4\n+        # hugely speeds up the test, as it involves multiple hops of tx relay.\n+        self.noban_tx_relay = True\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+        ]] * self.num_nodes\n+        self.supports_cli = False\n+\n+    def raise_network_minfee(self):\n+        filler_wallet = MiniWallet(self.nodes[0])\n+        fill_mempool(self, self.nodes[0], filler_wallet)\n+\n+        self.log.debug(\"Wait for the network to sync mempools\")\n+        self.sync_mempools()\n+\n+        self.log.debug(\"Check that all nodes' mempool minimum feerates are above min relay feerate\")\n+        for node in self.nodes:\n+            assert_equal(node.getmempoolinfo()['minrelaytxfee'], FEERATE_1SAT_VB)\n+            assert_greater_than(node.getmempoolinfo()['mempoolminfee'], FEERATE_1SAT_VB)\n+\n+    def create_basic_1p1c(self, wallet):\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+        package_hex_basic = [low_fee_parent[\"hex\"], high_fee_child[\"hex\"]]\n+        return package_hex_basic, low_fee_parent[\"tx\"], high_fee_child[\"tx\"]\n+\n+    def create_package_2outs(self, wallet):\n+        # First create a tester tx to see the vsize, and then adjust the fees\n+        placeholder_fee = 100000\n+        utxo_for_2outs = wallet.get_utxo(confirmed_only=True)\n+\n+        low_fee_parent_2outs_tester = wallet.create_self_transfer_multi(\n+            utxos_to_spend=[utxo_for_2outs],\n+            num_outputs=2,\n+            fee_per_output=placeholder_fee,\n+            confirmed_only=True\n+        )\n+\n+        # Target 1sat/vB so the number of satoshis is equal to the vsize.\n+        # Round up. The goal is to be between min relay feerate and mempool min feerate.\n+        fee_2outs = ceil(low_fee_parent_2outs_tester[\"tx\"].get_vsize() / 2)\n+\n+        low_fee_parent_2outs = wallet.create_self_transfer_multi(\n+            utxos_to_spend=[utxo_for_2outs],\n+            num_outputs=2,\n+            fee_per_output=fee_2outs,\n+        )\n+\n+        # Now create the child\n+        high_fee_child_2outs = wallet.create_self_transfer_multi(\n+            utxos_to_spend=low_fee_parent_2outs[\"new_utxos\"][::-1],\n+            fee_per_output=fee_2outs*100,\n+        )\n+        return [low_fee_parent_2outs[\"hex\"], high_fee_child_2outs[\"hex\"]], low_fee_parent_2outs[\"tx\"], high_fee_child_2outs[\"tx\"]\n+\n+    def create_package_2p1c(self, wallet):\n+        parent1 = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB*10, confirmed_only=True)\n+        parent2 = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB*20, confirmed_only=True)\n+        child = wallet.create_self_transfer_multi(\n+            utxos_to_spend=[parent1[\"new_utxo\"], parent2[\"new_utxo\"]],\n+            fee_per_output=999*parent1[\"tx\"].get_vsize(),\n+        )\n+        return [parent1[\"hex\"], parent2[\"hex\"], child[\"hex\"]], parent1[\"tx\"], parent2[\"tx\"], child[\"tx\"]\n+\n+    def create_packages(self):\n+        # 1: Basic 1-parent-1-child package, parent 1sat/vB, child 999sat/vB\n+        package_hex_1, parent_1, child_1 = self.create_basic_1p1c(self.wallet)\n+\n+        # 2: same as 1, parent's txid is the same as its wtxid.\n+        package_hex_2, parent_2, child_2 = self.create_basic_1p1c(self.wallet_nonsegwit)\n+\n+        # 3: 2-parent-1-child package. Both parents are above mempool min feerate. No package submission happens.\n+        # We require packages to be child-with-unconfirmed-parents and only allow 1-parent-1-child packages.\n+        package_hex_3, parent_31, parent_32, child_3 = self.create_package_2p1c(self.wallet)\n+\n+        # 4: parent + child package where the child spends 2 different outputs from the parent.\n+        package_hex_4, parent_4, child_4 = self.create_package_2outs(self.wallet)\n+\n+        # Assemble return results\n+        packages_to_submit = []\n+        txns_to_send = [[]] * self.num_nodes\n+\n+        packages_to_submit.append(package_hex_1)\n+        packages_to_submit.append(package_hex_2)\n+        packages_to_submit.append(package_hex_3)\n+        packages_to_submit.append(package_hex_4)\n+\n+        # node0: sender\n+        # node1: pre-received the children (orphan)\n+        # node3: pre-received the parents (too low fee)\n+        # All nodes receive high_parent_51 ahead of time.\n+        txns_to_send[1] = [child_1, child_2, parent_31, child_3, child_4]\n+        txns_to_send[2] = [parent_31]\n+        txns_to_send[3] = [parent_1, parent_2, parent_31, parent_4]\n+\n+        return packages_to_submit, txns_to_send\n+\n+    def run_test(self):\n+        self.wallet = MiniWallet(self.nodes[1])\n+        self.wallet_nonsegwit = MiniWallet(self.nodes[2], mode=MiniWalletMode.RAW_P2PK)\n+        self.generate(self.wallet_nonsegwit, 10)\n+        self.generate(self.wallet, 120)\n+\n+        self.log.info(\"Fill mempools with large transactions to raise mempool minimum feerates\")\n+        self.raise_network_minfee()\n+\n+        # Create the transactions.\n+        self.wallet.rescan_utxos(include_mempool=True)\n+        packages_to_submit, transactions_to_presend = self.create_packages()\n+\n+        self.peers = []\n+        for i in range(self.num_nodes):\n+            self.peers.append(self.nodes[i].add_p2p_connection(P2PInterface()))\n+\n+        self.log.info(\"Pre-send some transactions to nodes\")\n+        for i in range(self.num_nodes):\n+            peer = self.peers[i]",
      "path": "test/functional/p2p_1p1c_network.py",
      "position": null,
      "original_position": 155,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "30c9e6bc4e9f8b8b606e55435dc3f743cb2dd670",
      "in_reply_to_id": 1578476332,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "done",
      "created_at": "2024-04-26T08:50:04Z",
      "updated_at": "2024-04-26T10:10:19Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1580701947",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1580701947"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": 154,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 155,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1580705044",
      "pull_request_review_id": 2024465284,
      "id": 1580705044,
      "node_id": "PRRC_kwDOABII585eN6UU",
      "diff_hunk": "@@ -0,0 +1,392 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test opportunistic 1p1c package submission logic.\n+\"\"\"\n+\n+from decimal import Decimal\n+import time\n+from test_framework.messages import (\n+    CInv,\n+    CTxInWitness,\n+    MSG_WTX,\n+    msg_inv,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    fill_mempool,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+# Number of seconds to wait to ensure no getdata is received\n+GETDATA_WAIT = 60\n+\n+def cleanup(func):\n+    def wrapper(self, *args, **kwargs):\n+        try:\n+            func(self, *args, **kwargs)\n+        finally:\n+            self.nodes[0].disconnect_p2ps()\n+            # Do not clear the node's mempool, as each test requires mempool min feerate > min\n+            # relay feerate. However, do check that this is the case.\n+            assert self.nodes[0].getmempoolinfo()[\"mempoolminfee\"] > self.nodes[0].getnetworkinfo()[\"relayfee\"]\n+            # Ensure we do not try to spend the same UTXOs in subsequent tests, as they will look like RBF attempts.\n+            self.wallet.rescan_utxos(include_mempool=True)\n+\n+            # Resets if mocktime was used\n+            self.nodes[0].setmocktime(0)\n+    return wrapper\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+        ]]\n+        self.supports_cli = False\n+\n+    @cleanup\n+    def test_basic_child_then_parent(self):\n+        node = self.nodes[0]\n+        self.log.info(\"Check that opportunistic 1p1c logic works when child is received before parent\")\n+\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first (perhaps the low feerate parent didn't meet feefilter or the requests were sent to different nodes). It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. Sender relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 4. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+        node.disconnect_p2ps()\n+\n+    @cleanup\n+    def test_basic_parent_then_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=1, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=2, connection_type=\"outbound-full-relay\")\n+\n+        # 1. Parent is relayed first. It is too low feerate.\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer_sender.wait_for_getdata([parent_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer_ignored, check that it is ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+\n+        # 2. Child is relayed next. It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 3. Node requests the missing parent by txid.\n+        # It should do so even if it has previously rejected that parent for being too low feerate.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 4. Sender re-relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 5. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+    @cleanup\n+    def test_low_and_high_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        # This feerate is above mempoolminfee, but not enough to also bump the low feerate parent.\n+        feerate_just_above = node.getmempoolinfo()[\"mempoolminfee\"]\n+        med_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=feerate_just_above)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=3, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=4, connection_type=\"outbound-full-relay\")",
      "path": "test/functional/p2p_opportunistic_1p1c.py",
      "position": null,
      "original_position": 142,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "30c9e6bc4e9f8b8b606e55435dc3f743cb2dd670",
      "in_reply_to_id": 1579435718,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "done",
      "created_at": "2024-04-26T08:52:28Z",
      "updated_at": "2024-04-26T10:10:19Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1580705044",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1580705044"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": 141,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 142,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1580705515",
      "pull_request_review_id": 2024465284,
      "id": 1580705515,
      "node_id": "PRRC_kwDOABII585eN6br",
      "diff_hunk": "@@ -0,0 +1,392 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test opportunistic 1p1c package submission logic.\n+\"\"\"\n+\n+from decimal import Decimal\n+import time\n+from test_framework.messages import (\n+    CInv,\n+    CTxInWitness,\n+    MSG_WTX,\n+    msg_inv,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    fill_mempool,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+# Number of seconds to wait to ensure no getdata is received\n+GETDATA_WAIT = 60\n+\n+def cleanup(func):\n+    def wrapper(self, *args, **kwargs):\n+        try:\n+            func(self, *args, **kwargs)\n+        finally:\n+            self.nodes[0].disconnect_p2ps()\n+            # Do not clear the node's mempool, as each test requires mempool min feerate > min\n+            # relay feerate. However, do check that this is the case.\n+            assert self.nodes[0].getmempoolinfo()[\"mempoolminfee\"] > self.nodes[0].getnetworkinfo()[\"relayfee\"]\n+            # Ensure we do not try to spend the same UTXOs in subsequent tests, as they will look like RBF attempts.\n+            self.wallet.rescan_utxos(include_mempool=True)\n+\n+            # Resets if mocktime was used\n+            self.nodes[0].setmocktime(0)\n+    return wrapper\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+        ]]\n+        self.supports_cli = False\n+\n+    @cleanup\n+    def test_basic_child_then_parent(self):\n+        node = self.nodes[0]\n+        self.log.info(\"Check that opportunistic 1p1c logic works when child is received before parent\")\n+\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first (perhaps the low feerate parent didn't meet feefilter or the requests were sent to different nodes). It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. Sender relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 4. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+        node.disconnect_p2ps()\n+\n+    @cleanup\n+    def test_basic_parent_then_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=1, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=2, connection_type=\"outbound-full-relay\")\n+\n+        # 1. Parent is relayed first. It is too low feerate.\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer_sender.wait_for_getdata([parent_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer_ignored, check that it is ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+\n+        # 2. Child is relayed next. It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 3. Node requests the missing parent by txid.\n+        # It should do so even if it has previously rejected that parent for being too low feerate.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 4. Sender re-relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 5. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+    @cleanup\n+    def test_low_and_high_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        # This feerate is above mempoolminfee, but not enough to also bump the low feerate parent.\n+        feerate_just_above = node.getmempoolinfo()[\"mempoolminfee\"]\n+        med_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=feerate_just_above)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=3, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=4, connection_type=\"outbound-full-relay\")\n+\n+        self.log.info(\"Check that tx caches low fee parent + low fee child package rejections\")\n+\n+        # 1. Send parent, rejected for being low feerate.\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer_sender.wait_for_getdata([parent_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer_ignored, check that it is ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+\n+        # 2. Send an (orphan) child that has a higher feerate, but not enough to bump the parent.\n+        low_child_wtxid_int = int(med_fee_child[\"tx\"].getwtxid(), 16)",
      "path": "test/functional/p2p_opportunistic_1p1c.py",
      "position": null,
      "original_position": 158,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "30c9e6bc4e9f8b8b606e55435dc3f743cb2dd670",
      "in_reply_to_id": 1578541041,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "done",
      "created_at": "2024-04-26T08:52:52Z",
      "updated_at": "2024-04-26T10:10:19Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1580705515",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1580705515"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 158,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1580707638",
      "pull_request_review_id": 2024465284,
      "id": 1580707638,
      "node_id": "PRRC_kwDOABII585eN682",
      "diff_hunk": "@@ -0,0 +1,392 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test opportunistic 1p1c package submission logic.\n+\"\"\"\n+\n+from decimal import Decimal\n+import time\n+from test_framework.messages import (\n+    CInv,\n+    CTxInWitness,\n+    MSG_WTX,\n+    msg_inv,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    fill_mempool,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+# Number of seconds to wait to ensure no getdata is received\n+GETDATA_WAIT = 60\n+\n+def cleanup(func):\n+    def wrapper(self, *args, **kwargs):\n+        try:\n+            func(self, *args, **kwargs)\n+        finally:\n+            self.nodes[0].disconnect_p2ps()\n+            # Do not clear the node's mempool, as each test requires mempool min feerate > min\n+            # relay feerate. However, do check that this is the case.\n+            assert self.nodes[0].getmempoolinfo()[\"mempoolminfee\"] > self.nodes[0].getnetworkinfo()[\"relayfee\"]\n+            # Ensure we do not try to spend the same UTXOs in subsequent tests, as they will look like RBF attempts.\n+            self.wallet.rescan_utxos(include_mempool=True)\n+\n+            # Resets if mocktime was used\n+            self.nodes[0].setmocktime(0)\n+    return wrapper\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+        ]]\n+        self.supports_cli = False\n+\n+    @cleanup\n+    def test_basic_child_then_parent(self):\n+        node = self.nodes[0]\n+        self.log.info(\"Check that opportunistic 1p1c logic works when child is received before parent\")\n+\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first (perhaps the low feerate parent didn't meet feefilter or the requests were sent to different nodes). It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. Sender relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 4. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+        node.disconnect_p2ps()\n+\n+    @cleanup\n+    def test_basic_parent_then_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=1, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=2, connection_type=\"outbound-full-relay\")\n+\n+        # 1. Parent is relayed first. It is too low feerate.\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer_sender.wait_for_getdata([parent_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer_ignored, check that it is ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+\n+        # 2. Child is relayed next. It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 3. Node requests the missing parent by txid.\n+        # It should do so even if it has previously rejected that parent for being too low feerate.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 4. Sender re-relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 5. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+    @cleanup\n+    def test_low_and_high_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        # This feerate is above mempoolminfee, but not enough to also bump the low feerate parent.\n+        feerate_just_above = node.getmempoolinfo()[\"mempoolminfee\"]\n+        med_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=feerate_just_above)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=3, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=4, connection_type=\"outbound-full-relay\")\n+\n+        self.log.info(\"Check that tx caches low fee parent + low fee child package rejections\")\n+\n+        # 1. Send parent, rejected for being low feerate.\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer_sender.wait_for_getdata([parent_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer_ignored, check that it is ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+\n+        # 2. Send an (orphan) child that has a higher feerate, but not enough to bump the parent.\n+        low_child_wtxid_int = int(med_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([low_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(med_fee_child[\"tx\"]))\n+\n+        # 3. Node requests the orphan's missing parent.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 4. The low parent + low child are submitted as a package. They are not accepted due to low package feerate.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+        assert med_fee_child[\"txid\"] not in node.getrawmempool()\n+\n+        # If peer_ignored announces the low feerate child, it should be ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+        # If either peer sends the parent again, package evaluation should not be attempted\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        peer_ignored.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+",
      "path": "test/functional/p2p_opportunistic_1p1c.py",
      "position": 190,
      "original_position": 179,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "30c9e6bc4e9f8b8b606e55435dc3f743cb2dd670",
      "in_reply_to_id": 1578543042,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "added",
      "created_at": "2024-04-26T08:54:14Z",
      "updated_at": "2024-04-26T10:10:19Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1580707638",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1580707638"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 190,
      "original_line": 190,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1580708256",
      "pull_request_review_id": 2024465284,
      "id": 1580708256,
      "node_id": "PRRC_kwDOABII585eN7Gg",
      "diff_hunk": "@@ -0,0 +1,392 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test opportunistic 1p1c package submission logic.\n+\"\"\"\n+\n+from decimal import Decimal\n+import time\n+from test_framework.messages import (\n+    CInv,\n+    CTxInWitness,\n+    MSG_WTX,\n+    msg_inv,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    fill_mempool,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+# Number of seconds to wait to ensure no getdata is received\n+GETDATA_WAIT = 60\n+\n+def cleanup(func):\n+    def wrapper(self, *args, **kwargs):\n+        try:\n+            func(self, *args, **kwargs)\n+        finally:\n+            self.nodes[0].disconnect_p2ps()\n+            # Do not clear the node's mempool, as each test requires mempool min feerate > min\n+            # relay feerate. However, do check that this is the case.\n+            assert self.nodes[0].getmempoolinfo()[\"mempoolminfee\"] > self.nodes[0].getnetworkinfo()[\"relayfee\"]\n+            # Ensure we do not try to spend the same UTXOs in subsequent tests, as they will look like RBF attempts.\n+            self.wallet.rescan_utxos(include_mempool=True)\n+\n+            # Resets if mocktime was used\n+            self.nodes[0].setmocktime(0)\n+    return wrapper\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+        ]]\n+        self.supports_cli = False\n+\n+    @cleanup\n+    def test_basic_child_then_parent(self):\n+        node = self.nodes[0]\n+        self.log.info(\"Check that opportunistic 1p1c logic works when child is received before parent\")\n+\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first (perhaps the low feerate parent didn't meet feefilter or the requests were sent to different nodes). It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. Sender relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 4. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+        node.disconnect_p2ps()\n+\n+    @cleanup\n+    def test_basic_parent_then_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=1, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=2, connection_type=\"outbound-full-relay\")\n+\n+        # 1. Parent is relayed first. It is too low feerate.\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer_sender.wait_for_getdata([parent_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer_ignored, check that it is ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+\n+        # 2. Child is relayed next. It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 3. Node requests the missing parent by txid.\n+        # It should do so even if it has previously rejected that parent for being too low feerate.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 4. Sender re-relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 5. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+    @cleanup\n+    def test_low_and_high_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        # This feerate is above mempoolminfee, but not enough to also bump the low feerate parent.\n+        feerate_just_above = node.getmempoolinfo()[\"mempoolminfee\"]\n+        med_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=feerate_just_above)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=3, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=4, connection_type=\"outbound-full-relay\")\n+\n+        self.log.info(\"Check that tx caches low fee parent + low fee child package rejections\")\n+\n+        # 1. Send parent, rejected for being low feerate.\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer_sender.wait_for_getdata([parent_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer_ignored, check that it is ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+\n+        # 2. Send an (orphan) child that has a higher feerate, but not enough to bump the parent.\n+        low_child_wtxid_int = int(med_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([low_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(med_fee_child[\"tx\"]))\n+\n+        # 3. Node requests the orphan's missing parent.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 4. The low parent + low child are submitted as a package. They are not accepted due to low package feerate.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+        assert med_fee_child[\"txid\"] not in node.getrawmempool()\n+\n+        # If peer_ignored announces the low feerate child, it should be ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+        # If either peer sends the parent again, package evaluation should not be attempted\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        peer_ignored.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 5. Send the high feerate (orphan) child\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 6. Node requests the orphan's parent, even though it has already been rejected, both by\n+        # itself and with a child. This is necessary, otherwise high_fee_child can be censored.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 7. The low feerate parent + high feerate child are submitted as a package.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 8. Both transactions should now be in mempool\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool",
      "path": "test/functional/p2p_opportunistic_1p1c.py",
      "position": 211,
      "original_position": 197,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "30c9e6bc4e9f8b8b606e55435dc3f743cb2dd670",
      "in_reply_to_id": 1578545268,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "sure, added",
      "created_at": "2024-04-26T08:54:44Z",
      "updated_at": "2024-04-26T10:10:19Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1580708256",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1580708256"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 211,
      "original_line": 211,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1580723637",
      "pull_request_review_id": 2024465284,
      "id": 1580723637,
      "node_id": "PRRC_kwDOABII585eN-21",
      "diff_hunk": "@@ -0,0 +1,392 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test opportunistic 1p1c package submission logic.\n+\"\"\"\n+\n+from decimal import Decimal\n+import time\n+from test_framework.messages import (\n+    CInv,\n+    CTxInWitness,\n+    MSG_WTX,\n+    msg_inv,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    fill_mempool,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+# Number of seconds to wait to ensure no getdata is received\n+GETDATA_WAIT = 60\n+\n+def cleanup(func):\n+    def wrapper(self, *args, **kwargs):\n+        try:\n+            func(self, *args, **kwargs)\n+        finally:\n+            self.nodes[0].disconnect_p2ps()\n+            # Do not clear the node's mempool, as each test requires mempool min feerate > min\n+            # relay feerate. However, do check that this is the case.\n+            assert self.nodes[0].getmempoolinfo()[\"mempoolminfee\"] > self.nodes[0].getnetworkinfo()[\"relayfee\"]\n+            # Ensure we do not try to spend the same UTXOs in subsequent tests, as they will look like RBF attempts.\n+            self.wallet.rescan_utxos(include_mempool=True)\n+\n+            # Resets if mocktime was used\n+            self.nodes[0].setmocktime(0)\n+    return wrapper\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+        ]]\n+        self.supports_cli = False\n+\n+    @cleanup\n+    def test_basic_child_then_parent(self):\n+        node = self.nodes[0]\n+        self.log.info(\"Check that opportunistic 1p1c logic works when child is received before parent\")\n+\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first (perhaps the low feerate parent didn't meet feefilter or the requests were sent to different nodes). It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. Sender relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 4. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+        node.disconnect_p2ps()\n+\n+    @cleanup\n+    def test_basic_parent_then_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=1, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=2, connection_type=\"outbound-full-relay\")\n+\n+        # 1. Parent is relayed first. It is too low feerate.\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer_sender.wait_for_getdata([parent_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer_ignored, check that it is ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+\n+        # 2. Child is relayed next. It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 3. Node requests the missing parent by txid.\n+        # It should do so even if it has previously rejected that parent for being too low feerate.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 4. Sender re-relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 5. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+    @cleanup\n+    def test_low_and_high_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        # This feerate is above mempoolminfee, but not enough to also bump the low feerate parent.\n+        feerate_just_above = node.getmempoolinfo()[\"mempoolminfee\"]\n+        med_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=feerate_just_above)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=3, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=4, connection_type=\"outbound-full-relay\")\n+\n+        self.log.info(\"Check that tx caches low fee parent + low fee child package rejections\")\n+\n+        # 1. Send parent, rejected for being low feerate.\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer_sender.wait_for_getdata([parent_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer_ignored, check that it is ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+\n+        # 2. Send an (orphan) child that has a higher feerate, but not enough to bump the parent.\n+        low_child_wtxid_int = int(med_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([low_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(med_fee_child[\"tx\"]))\n+\n+        # 3. Node requests the orphan's missing parent.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 4. The low parent + low child are submitted as a package. They are not accepted due to low package feerate.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+        assert med_fee_child[\"txid\"] not in node.getrawmempool()\n+\n+        # If peer_ignored announces the low feerate child, it should be ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+        # If either peer sends the parent again, package evaluation should not be attempted\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        peer_ignored.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 5. Send the high feerate (orphan) child\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 6. Node requests the orphan's parent, even though it has already been rejected, both by\n+        # itself and with a child. This is necessary, otherwise high_fee_child can be censored.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 7. The low feerate parent + high feerate child are submitted as a package.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 8. Both transactions should now be in mempool\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+    @cleanup\n+    def test_orphan_consensus_failure(self):\n+        self.log.info(\"Check opportunistic 1p1c logic with consensus-invalid orphan causes disconnect of the correct peer\")\n+        node = self.nodes[0]\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        coin = low_fee_parent[\"new_utxo\"]\n+        address = node.get_deterministic_priv_key().address\n+        # Create raw transaction spending the parent, but with no signature (a consensus error).\n+        hex_orphan_no_sig = node.createrawtransaction([{\"txid\": coin[\"txid\"], \"vout\": coin[\"vout\"]}], {address : coin[\"value\"] - Decimal(\"0.0001\")})\n+        tx_orphan_bad_wit = tx_from_hex(hex_orphan_no_sig)\n+        tx_orphan_bad_wit.wit.vtxinwit.append(CTxInWitness())\n+        tx_orphan_bad_wit.wit.vtxinwit[0].scriptWitness.stack = [b'garbage']\n+\n+        bad_orphan_sender = node.add_p2p_connection(P2PInterface())\n+        parent_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first. It is missing an input.\n+        child_wtxid_int = int(tx_orphan_bad_wit.getwtxid(), 16)\n+        bad_orphan_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=child_wtxid_int)]))\n+        bad_orphan_sender.wait_for_getdata([child_wtxid_int])\n+        bad_orphan_sender.send_and_ping(msg_tx(tx_orphan_bad_wit))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        bad_orphan_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. A different peer relays the parent. Parent+Child are evaluated as a package and rejected.\n+        parent_sender.send_message(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 4. Transactions should not be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] not in node_mempool\n+        assert tx_orphan_bad_wit.rehash() not in node_mempool\n+\n+        # 5. Peer that sent a consensus-invalid transaction should be disconnected.\n+        bad_orphan_sender.wait_for_disconnect()\n+\n+        # The peer that didn't provide the orphan should not be disconnected.\n+        parent_sender.sync_with_ping()\n+\n+    @cleanup\n+    def test_parent_consensus_failure(self):\n+        self.log.info(\"Check opportunistic 1p1c logic with consensus-invalid parent causes disconnect of the correct peer\")\n+        node = self.nodes[0]\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+\n+        # Create invalid version of parent with a bad signature.\n+        tx_parent_bad_wit = tx_from_hex(low_fee_parent[\"hex\"])\n+        tx_parent_bad_wit.wit.vtxinwit.append(CTxInWitness())\n+        tx_parent_bad_wit.wit.vtxinwit[0].scriptWitness.stack = [b'garbage']\n+\n+        package_sender = node.add_p2p_connection(P2PInterface())\n+        fake_parent_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first. It is missing an input.\n+        child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        package_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=child_wtxid_int)]))\n+        package_sender.wait_for_getdata([child_wtxid_int])\n+        package_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(tx_parent_bad_wit.rehash(), 16)\n+        package_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. A different node relays the parent. The parent is first evaluated by itself and\n+        # rejected for being too low feerate. Then it is evaluated as a package and, after passing\n+        # feerate checks, rejected for having a bad signature (consensus error).\n+        fake_parent_sender.send_message(msg_tx(tx_parent_bad_wit))\n+\n+        # 4. Transactions should not be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert tx_parent_bad_wit.rehash() not in node_mempool\n+        assert high_fee_child[\"txid\"] not in node_mempool\n+\n+        # 5. Peer sent a consensus-invalid transaction.\n+        fake_parent_sender.wait_for_disconnect()\n+\n+        self.log.info(\"Check that fake parent does not cause orphan to be deleted and real package can still be submitted\")\n+        # 6. Child-sending should not have been punished and the orphan should remain in orphanage.\n+        # It can send the \"real\" parent transaction, and the package is accepted.\n+        package_sender.sync_with_ping()\n+        package_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+    @cleanup\n+    def test_multiple_parents(self):\n+        self.log.info(\"Check that node does not request more than 1 previously-rejected low feerate parent\")\n+\n+        node = self.nodes[0]\n+        node.setmocktime(int(time.time()))\n+\n+        # 2-parent-1-child package where both parents are below mempool min feerate\n+        parent_low_1 = self.wallet_nonsegwit.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        parent_low_2 = self.wallet_nonsegwit.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        child_bumping = self.wallet_nonsegwit.create_self_transfer_multi(\n+            utxos_to_spend=[parent_low_1[\"new_utxo\"], parent_low_2[\"new_utxo\"]],\n+            fee_per_output=999*parent_low_1[\"tx\"].get_vsize(),\n+        )\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=4, connection_type=\"outbound-full-relay\")\n+\n+        # 1. Send both parents. Each should be rejected for being too low feerate.\n+        # Send unsolicited so that we can later check that no \"getdata\" was ever received.\n+        peer_sender.send_and_ping(msg_tx(parent_low_1[\"tx\"]))\n+        peer_sender.send_and_ping(msg_tx(parent_low_2[\"tx\"]))\n+\n+        # parent_low_1 and parent_low_2 are rejected for being low feerate.\n+        assert parent_low_1[\"txid\"] not in node.getrawmempool()\n+        assert parent_low_2[\"txid\"] not in node.getrawmempool()\n+\n+        # 2. Send child.\n+        peer_sender.send_and_ping(msg_tx(child_bumping[\"tx\"]))\n+\n+        # 3. Node should not request any parents, as it should recognize that it will not accept\n+        # multi-parent-1-child packages.\n+        node.bumpmocktime(GETDATA_WAIT)\n+        peer_sender.sync_with_ping()\n+        assert \"getdata\" not in peer_sender.last_message\n+\n+    @cleanup\n+    def test_other_parent_in_mempool(self):\n+        self.log.info(\"Check opportunistic 1p1c fails if child already has another parent in mempool\")",
      "path": "test/functional/p2p_opportunistic_1p1c.py",
      "position": 341,
      "original_position": 324,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "30c9e6bc4e9f8b8b606e55435dc3f743cb2dd670",
      "in_reply_to_id": 1579450824,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> How is this different from submitting the whole package? \r\n\r\nThe p2p logic is only going to match up 1p1cs, so it won't ever submit the whole package. I suppose you're asking why the validation logic is this way?\r\n\r\nFor the purpose of this PR, I think we should just try to make sure the p2p logic is able to handle the result returned from validation, whatever it may be. If you're interested in why the validation stuff works the way it does, all the PRs are listed in #27463. The relevant one here is #22674 (also have [review club notes](https://bitcoincore.reviews/22674)). TLDR we do a topology check at the top of `AcceptPackage` and check that we have all unconfirmed ancestors. Idea was to drop it if we're still missing something, though I don't really like this approach anymore (also see https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1576145432).",
      "created_at": "2024-04-26T09:06:48Z",
      "updated_at": "2024-04-26T11:00:33Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1580723637",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1580723637"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 341,
      "original_line": 341,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1580736833",
      "pull_request_review_id": 2024465284,
      "id": 1580736833,
      "node_id": "PRRC_kwDOABII585eOCFB",
      "diff_hunk": "@@ -40,6 +43,92 @@ inline CTransactionRef create_placeholder_tx(size_t num_inputs, size_t num_outpu\n     return MakeTransactionRef(mtx);\n }\n \n+// Create a Wtxid from a hex string\n+inline Wtxid WtxidFromString(std::string_view str)\n+{\n+    return Wtxid::FromUint256(uint256S(str.data()));\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(package_hash_tests, TestChain100Setup)\n+{\n+    // Random real segwit transaction\n+    DataStream stream_1{\n+        ParseHex(\"02000000000101964b8aa63509579ca6086e6012eeaa4c2f4dd1e283da29b67c8eea38b3c6fd220000000000fdffffff0294c618000000000017a9145afbbb42f4e83312666d0697f9e66259912ecde38768fa2c0000000000160014897388a0889390fd0e153a22bb2cf9d8f019faf50247304402200547406380719f84d68cf4e96cc3e4a1688309ef475b150be2b471c70ea562aa02206d255f5acc40fd95981874d77201d2eb07883657ce1c796513f32b6079545cdf0121023ae77335cefcb5ab4c1dc1fb0d2acfece184e593727d7d5906c78e564c7c11d125cf0c00\"),\n+    };\n+    CTransaction tx_1(deserialize, TX_WITH_WITNESS, stream_1);\n+    CTransactionRef ptx_1{MakeTransactionRef(tx_1)};\n+\n+    // Random real nonsegwit transaction\n+    DataStream stream_2{\n+        ParseHex(\"01000000010b26e9b7735eb6aabdf358bab62f9816a21ba9ebdb719d5299e88607d722c190000000008b4830450220070aca44506c5cef3a16ed519d7c3c39f8aab192c4e1c90d065f37b8a4af6141022100a8e160b856c2d43d27d8fba71e5aef6405b8643ac4cb7cb3c462aced7f14711a0141046d11fee51b0e60666d5049a9101a72741df480b96ee26488a4d3466b95c9a40ac5eeef87e10a5cd336c19a84565f80fa6c547957b7700ff4dfbdefe76036c339ffffffff021bff3d11000000001976a91404943fdd508053c75000106d3bc6e2754dbcff1988ac2f15de00000000001976a914a266436d2965547608b9e15d9032a7b9d64fa43188ac00000000\"),\n+    };\n+    CTransaction tx_2(deserialize, TX_WITH_WITNESS, stream_2);\n+    CTransactionRef ptx_2{MakeTransactionRef(tx_2)};\n+\n+    // Random real segwit transaction\n+    DataStream stream_3{\n+        ParseHex(\"0200000000010177862801f77c2c068a70372b4c435ef8dd621291c36a64eb4dd491f02218f5324600000000fdffffff014a0100000000000022512035ea312034cfac01e956a269f3bf147f569c2fbb00180677421262da042290d803402be713325ff285e66b0380f53f2fae0d0fb4e16f378a440fed51ce835061437566729d4883bc917632f3cff474d6384bc8b989961a1d730d4a87ed38ad28bd337b20f1d658c6c138b1c312e072b4446f50f01ae0da03a42e6274f8788aae53416a7fac0063036f7264010118746578742f706c61696e3b636861727365743d7574662d3800357b2270223a226272632d3230222c226f70223a226d696e74222c227469636b223a224342414c222c22616d74223a2236393639227d6821c1f1d658c6c138b1c312e072b4446f50f01ae0da03a42e6274f8788aae53416a7f00000000\"),\n+    };\n+    CTransaction tx_3(deserialize, TX_WITH_WITNESS, stream_3);\n+    CTransactionRef ptx_3{MakeTransactionRef(tx_3)};\n+\n+    // It's easy to see that wtxids are sorted in lexicographical order:\n+    Wtxid wtxid_1{WtxidFromString(\"0x85cd1a31eb38f74ed5742ec9cb546712ab5aaf747de28a9168b53e846cbda17f\")};\n+    Wtxid wtxid_2{WtxidFromString(\"0xb4749f017444b051c44dfd2720e88f314ff94f3dd6d56d40ef65854fcd7fff6b\")};\n+    Wtxid wtxid_3{WtxidFromString(\"0xe065bac15f62bb4e761d761db928ddee65a47296b2b776785abb912cdec474e3\")};\n+    BOOST_CHECK_EQUAL(tx_1.GetWitnessHash(), wtxid_1);\n+    BOOST_CHECK_EQUAL(tx_2.GetWitnessHash(), wtxid_2);\n+    BOOST_CHECK_EQUAL(tx_3.GetWitnessHash(), wtxid_3);\n+\n+    BOOST_CHECK(wtxid_1.GetHex() < wtxid_2.GetHex());\n+    BOOST_CHECK(wtxid_2.GetHex() < wtxid_3.GetHex());\n+\n+    // The txids are not (we want to test that sorting and hashing use wtxid, not txid):\n+    Txid txid_1{TxidFromString(\"0xbd0f71c1d5e50589063e134fad22053cdae5ab2320db5bf5e540198b0b5a4e69\")};\n+    Txid txid_2{TxidFromString(\"0xb4749f017444b051c44dfd2720e88f314ff94f3dd6d56d40ef65854fcd7fff6b\")};\n+    Txid txid_3{TxidFromString(\"0xee707be5201160e32c4fc715bec227d1aeea5940fb4295605e7373edce3b1a93\")};\n+    BOOST_CHECK_EQUAL(tx_1.GetHash(), txid_1);\n+    BOOST_CHECK_EQUAL(tx_2.GetHash(), txid_2);\n+    BOOST_CHECK_EQUAL(tx_3.GetHash(), txid_3);\n+\n+    BOOST_CHECK(txid_2.GetHex() < txid_1.GetHex());\n+\n+    BOOST_CHECK(txid_1.ToUint256() != wtxid_1.ToUint256());\n+    BOOST_CHECK(txid_3.ToUint256() != wtxid_3.ToUint256());",
      "path": "src/test/txpackage_tests.cpp",
      "position": null,
      "original_position": 68,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "6edf8ec0c5616d7f1dd372c704f5e0a5b3416f83",
      "in_reply_to_id": 1577902195,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "added",
      "created_at": "2024-04-26T09:18:30Z",
      "updated_at": "2024-04-26T10:10:18Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1580736833",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1580736833"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": 96,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 98,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1580737130",
      "pull_request_review_id": 2024465284,
      "id": 1580737130,
      "node_id": "PRRC_kwDOABII585eOCJq",
      "diff_hunk": "@@ -40,6 +43,92 @@ inline CTransactionRef create_placeholder_tx(size_t num_inputs, size_t num_outpu\n     return MakeTransactionRef(mtx);\n }\n \n+// Create a Wtxid from a hex string\n+inline Wtxid WtxidFromString(std::string_view str)\n+{\n+    return Wtxid::FromUint256(uint256S(str.data()));\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(package_hash_tests, TestChain100Setup)\n+{\n+    // Random real segwit transaction\n+    DataStream stream_1{\n+        ParseHex(\"02000000000101964b8aa63509579ca6086e6012eeaa4c2f4dd1e283da29b67c8eea38b3c6fd220000000000fdffffff0294c618000000000017a9145afbbb42f4e83312666d0697f9e66259912ecde38768fa2c0000000000160014897388a0889390fd0e153a22bb2cf9d8f019faf50247304402200547406380719f84d68cf4e96cc3e4a1688309ef475b150be2b471c70ea562aa02206d255f5acc40fd95981874d77201d2eb07883657ce1c796513f32b6079545cdf0121023ae77335cefcb5ab4c1dc1fb0d2acfece184e593727d7d5906c78e564c7c11d125cf0c00\"),\n+    };\n+    CTransaction tx_1(deserialize, TX_WITH_WITNESS, stream_1);\n+    CTransactionRef ptx_1{MakeTransactionRef(tx_1)};\n+\n+    // Random real nonsegwit transaction\n+    DataStream stream_2{\n+        ParseHex(\"01000000010b26e9b7735eb6aabdf358bab62f9816a21ba9ebdb719d5299e88607d722c190000000008b4830450220070aca44506c5cef3a16ed519d7c3c39f8aab192c4e1c90d065f37b8a4af6141022100a8e160b856c2d43d27d8fba71e5aef6405b8643ac4cb7cb3c462aced7f14711a0141046d11fee51b0e60666d5049a9101a72741df480b96ee26488a4d3466b95c9a40ac5eeef87e10a5cd336c19a84565f80fa6c547957b7700ff4dfbdefe76036c339ffffffff021bff3d11000000001976a91404943fdd508053c75000106d3bc6e2754dbcff1988ac2f15de00000000001976a914a266436d2965547608b9e15d9032a7b9d64fa43188ac00000000\"),\n+    };\n+    CTransaction tx_2(deserialize, TX_WITH_WITNESS, stream_2);\n+    CTransactionRef ptx_2{MakeTransactionRef(tx_2)};\n+\n+    // Random real segwit transaction\n+    DataStream stream_3{\n+        ParseHex(\"0200000000010177862801f77c2c068a70372b4c435ef8dd621291c36a64eb4dd491f02218f5324600000000fdffffff014a0100000000000022512035ea312034cfac01e956a269f3bf147f569c2fbb00180677421262da042290d803402be713325ff285e66b0380f53f2fae0d0fb4e16f378a440fed51ce835061437566729d4883bc917632f3cff474d6384bc8b989961a1d730d4a87ed38ad28bd337b20f1d658c6c138b1c312e072b4446f50f01ae0da03a42e6274f8788aae53416a7fac0063036f7264010118746578742f706c61696e3b636861727365743d7574662d3800357b2270223a226272632d3230222c226f70223a226d696e74222c227469636b223a224342414c222c22616d74223a2236393639227d6821c1f1d658c6c138b1c312e072b4446f50f01ae0da03a42e6274f8788aae53416a7f00000000\"),\n+    };\n+    CTransaction tx_3(deserialize, TX_WITH_WITNESS, stream_3);\n+    CTransactionRef ptx_3{MakeTransactionRef(tx_3)};\n+\n+    // It's easy to see that wtxids are sorted in lexicographical order:\n+    Wtxid wtxid_1{WtxidFromString(\"0x85cd1a31eb38f74ed5742ec9cb546712ab5aaf747de28a9168b53e846cbda17f\")};\n+    Wtxid wtxid_2{WtxidFromString(\"0xb4749f017444b051c44dfd2720e88f314ff94f3dd6d56d40ef65854fcd7fff6b\")};\n+    Wtxid wtxid_3{WtxidFromString(\"0xe065bac15f62bb4e761d761db928ddee65a47296b2b776785abb912cdec474e3\")};\n+    BOOST_CHECK_EQUAL(tx_1.GetWitnessHash(), wtxid_1);\n+    BOOST_CHECK_EQUAL(tx_2.GetWitnessHash(), wtxid_2);\n+    BOOST_CHECK_EQUAL(tx_3.GetWitnessHash(), wtxid_3);\n+\n+    BOOST_CHECK(wtxid_1.GetHex() < wtxid_2.GetHex());\n+    BOOST_CHECK(wtxid_2.GetHex() < wtxid_3.GetHex());\n+\n+    // The txids are not (we want to test that sorting and hashing use wtxid, not txid):\n+    Txid txid_1{TxidFromString(\"0xbd0f71c1d5e50589063e134fad22053cdae5ab2320db5bf5e540198b0b5a4e69\")};\n+    Txid txid_2{TxidFromString(\"0xb4749f017444b051c44dfd2720e88f314ff94f3dd6d56d40ef65854fcd7fff6b\")};\n+    Txid txid_3{TxidFromString(\"0xee707be5201160e32c4fc715bec227d1aeea5940fb4295605e7373edce3b1a93\")};\n+    BOOST_CHECK_EQUAL(tx_1.GetHash(), txid_1);\n+    BOOST_CHECK_EQUAL(tx_2.GetHash(), txid_2);\n+    BOOST_CHECK_EQUAL(tx_3.GetHash(), txid_3);\n+\n+    BOOST_CHECK(txid_2.GetHex() < txid_1.GetHex());\n+\n+    BOOST_CHECK(txid_1.ToUint256() != wtxid_1.ToUint256());\n+    BOOST_CHECK(txid_3.ToUint256() != wtxid_3.ToUint256());\n+\n+    // We are testing that both functions compare using GetHex() and not uint256.\n+    // (in this pair of wtxids, hex string order != uint256 order)\n+    BOOST_CHECK(wtxid_2 < wtxid_1);\n+    // (in this pair of wtxids, hex string order == uint256 order)\n+    BOOST_CHECK(wtxid_2 < wtxid_3);\n+\n+    // All permutations of the package containing ptx_1, ptx_2, ptx_3 have the same package hash\n+    std::vector<CTransactionRef> package_123{ptx_1, ptx_2, ptx_3};\n+    std::vector<CTransactionRef> package_132{ptx_1, ptx_3, ptx_2};\n+    std::vector<CTransactionRef> package_231{ptx_2, ptx_3, ptx_1};\n+    std::vector<CTransactionRef> package_213{ptx_2, ptx_1, ptx_3};\n+    std::vector<CTransactionRef> package_312{ptx_3, ptx_1, ptx_2};\n+    std::vector<CTransactionRef> package_321{ptx_3, ptx_2, ptx_1};\n+\n+    uint256 calculated_hash_123 = (HashWriter() << wtxid_1 << wtxid_2 << wtxid_3).GetSHA256();\n+\n+    uint256 hash_if_by_txid = (HashWriter() << wtxid_2 << wtxid_1 << wtxid_3).GetSHA256();\n+    BOOST_CHECK(hash_if_by_txid != calculated_hash_123);\n+\n+    uint256 hash_if_use_txid = (HashWriter() << txid_2 << txid_1 << txid_3).GetSHA256();\n+    BOOST_CHECK(hash_if_use_txid != calculated_hash_123);\n+\n+    uint256 hash_if_use_int_order = (HashWriter() << wtxid_2 << wtxid_1 << txid_3).GetSHA256();",
      "path": "src/test/txpackage_tests.cpp",
      "position": null,
      "original_position": 92,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "6edf8ec0c5616d7f1dd372c704f5e0a5b3416f83",
      "in_reply_to_id": 1577900718,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "fixed",
      "created_at": "2024-04-26T09:18:47Z",
      "updated_at": "2024-04-26T10:10:18Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1580737130",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1580737130"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 121,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1580739332",
      "pull_request_review_id": 2024465284,
      "id": 1580739332,
      "node_id": "PRRC_kwDOABII585eOCsE",
      "diff_hunk": "",
      "path": "src/test/fuzz/txorphan.cpp",
      "position": 1,
      "original_position": 1,
      "commit_id": "55b1280c52af81aa6ea0860799fa16da49f51447",
      "original_commit_id": "55b1280c52af81aa6ea0860799fa16da49f51447",
      "in_reply_to_id": 1576401327,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "As discussed offline, I agree the fuzz test has a few quirks that could be fixed up, but I think they are out of scope for this PR so I'm going to mark this resolved.",
      "created_at": "2024-04-26T09:20:40Z",
      "updated_at": "2024-04-26T10:10:18Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1580739332",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1580739332"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1,
      "original_line": 1,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1580742501",
      "pull_request_review_id": 2024465284,
      "id": 1580742501,
      "node_id": "PRRC_kwDOABII585eODdl",
      "diff_hunk": "@@ -136,6 +156,12 @@ FUZZ_TARGET(txorphan, .init = initialize_orphanage)\n                     orphanage.LimitOrphans(limit, limit_orphans_rng);\n                     Assert(orphanage.Size() <= limit);\n                 });\n+\n+        // Set tx as potential parent to be used for future GetChildren() calls.\n+        if (!ptx_potential_parent || fuzzed_data_provider.ConsumeBool()) {\n+            ptx_potential_parent = tx;\n+        }",
      "path": "src/test/fuzz/txorphan.cpp",
      "position": null,
      "original_position": 55,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "b9caa4cfcbd1e176ab3ecd61973ab6721570aecb",
      "in_reply_to_id": 1575257763,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Thanks, I've moved it to the outer loop.\r\nKept bool, seems harmless and I imagine we can find some more interesting code paths by sometimes not setting it immediately.",
      "created_at": "2024-04-26T09:23:26Z",
      "updated_at": "2024-04-26T10:10:18Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1580742501",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1580742501"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": 160,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 164,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1580743469",
      "pull_request_review_id": 2024465284,
      "id": 1580743469,
      "node_id": "PRRC_kwDOABII585eODst",
      "diff_hunk": "@@ -596,6 +596,21 @@ class PeerManagerImpl final : public PeerManager\n     void ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, const std::list<CTransactionRef>& replaced_transactions)\n         EXCLUSIVE_LOCKS_REQUIRED(!m_peer_mutex, g_msgproc_mutex, cs_main);\n \n+    /** Handle the results of package validation: calls ProcessValidTx and ProcessInvalidTx for\n+     * individual transactions, and caches rejection for the package as a group.\n+     * @param[in]   senders     Must contain the nodeids of the peers that provided each transaction\n+     *                          in package, in the same order.\n+     *   */\n+    void ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, const std::vector<NodeId>& senders)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_peer_mutex, g_msgproc_mutex, cs_main);\n+\n+    /** Look for a child of this transaction in the orphanage to form a 1-parent-1-child package,\n+     * skipping any combinations have already been tried, and submit them together to the mempool.",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 13,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "bb3bf0a39c036fbd94b99ed7002db7d9bdf0a1d6",
      "in_reply_to_id": 1576613747,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "added",
      "created_at": "2024-04-26T09:24:15Z",
      "updated_at": "2024-04-26T10:10:18Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1580743469",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1580743469"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 608,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1580750294",
      "pull_request_review_id": 2024465284,
      "id": 1580750294,
      "node_id": "PRRC_kwDOABII585eOFXW",
      "diff_hunk": "@@ -3195,6 +3210,140 @@ void PeerManagerImpl::ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, c\n     }\n }\n \n+void PeerManagerImpl::ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, const std::vector<NodeId>& senders)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    if (package_result.m_state.IsInvalid()) {\n+        m_recent_rejects_reconsiderable.insert(GetPackageHash(package));\n+    }",
      "path": "src/net_processing.cpp",
      "position": 168,
      "original_position": 34,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "bb3bf0a39c036fbd94b99ed7002db7d9bdf0a1d6",
      "in_reply_to_id": 1576758551,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Packages aren't ever reconsiderable since we never submit anything beyond 1p1c. I've clarified this in the docs now. I definitely think we should cache a rejection when the error is `PCKG_POLICY` or `PCKG_MEMPOOL_ERROR`.",
      "created_at": "2024-04-26T09:30:01Z",
      "updated_at": "2024-04-26T10:10:18Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1580750294",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1580750294"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": 3246,
      "original_start_line": 3219,
      "start_side": "RIGHT",
      "line": 3248,
      "original_line": 3248,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1580752309",
      "pull_request_review_id": 2024465284,
      "id": 1580752309,
      "node_id": "PRRC_kwDOABII585eOF21",
      "diff_hunk": "@@ -3195,6 +3210,140 @@ void PeerManagerImpl::ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, c\n     }\n }\n \n+void PeerManagerImpl::ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, const std::vector<NodeId>& senders)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    if (package_result.m_state.IsInvalid()) {\n+        m_recent_rejects_reconsiderable.insert(GetPackageHash(package));\n+    }\n+    // We currently only expect to process 1-parent-1-child packages. Remove if this changes.\n+    if (!Assume(package.size() == 2)) return;\n+\n+    // No package results to look through for PCKG_POLICY or PCKG_MEMPOOL_ERROR\n+    if (package_result.m_state.GetResult() == PackageValidationResult::PCKG_POLICY ||\n+        package_result.m_state.GetResult() == PackageValidationResult::PCKG_MEMPOOL_ERROR) return;\n+\n+    // Iterate backwards to erase in-package descendants from the orphanage before they become\n+    // relevant in AddChildrenToWorkSet.\n+    auto package_iter = package.rbegin();\n+    auto senders_iter = senders.rbegin();\n+    while (package_iter != package.rend()) {\n+        const auto& tx = *package_iter;\n+        const NodeId nodeid = *senders_iter;\n+        const auto it_result{package_result.m_tx_results.find(tx->GetWitnessHash())};\n+        if (Assume(it_result != package_result.m_tx_results.end())) {\n+            const auto& tx_result = it_result->second;\n+            switch (tx_result.m_result_type) {\n+                case MempoolAcceptResult::ResultType::VALID:\n+                {\n+                    Assume(tx_result.m_replaced_transactions.has_value());\n+                    std::list<CTransactionRef> empty_replacement_list;\n+                    ProcessValidTx(nodeid, tx, tx_result.m_replaced_transactions.value_or(empty_replacement_list));\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::INVALID:\n+                case MempoolAcceptResult::ResultType::DIFFERENT_WITNESS:\n+                {\n+                    // Don't add to vExtraTxnForCompact, as these transactions should have already been\n+                    // added there when added to the orphanage or rejected for TX_RECONSIDERABLE.\n+                    // This should be updated if package submission is ever used for transactions\n+                    // that haven't already been validated before.\n+                    ProcessInvalidTx(nodeid, tx, tx_result.m_state, /*maybe_add_extra_compact_tx=*/false);\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::MEMPOOL_ENTRY:\n+                {\n+                    // AlreadyHaveTx() should be catching transactions that are already in mempool.\n+                    Assume(false);\n+                    break;\n+                }\n+            }\n+        }\n+        package_iter++;\n+        // There should be a sender for each tx, but fall back to the last one otherwise.\n+        if (Assume(senders_iter != senders.rend())) senders_iter++;",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 80,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "bb3bf0a39c036fbd94b99ed7002db7d9bdf0a1d6",
      "in_reply_to_id": 1578117743,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Ok I have deleted this now and created a `PackageToValidate` struct where the only constructor available guarantees there is a sender for each tx. So I've removed this `Assume` stuff as it's probably overly paranoid.",
      "created_at": "2024-04-26T09:31:39Z",
      "updated_at": "2024-04-26T10:10:19Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1580752309",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1580752309"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": 3266,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 3267,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1580755767",
      "pull_request_review_id": 2024465284,
      "id": 1580755767,
      "node_id": "PRRC_kwDOABII585eOGs3",
      "diff_hunk": "@@ -3195,6 +3210,140 @@ void PeerManagerImpl::ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, c\n     }\n }\n \n+void PeerManagerImpl::ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, const std::vector<NodeId>& senders)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    if (package_result.m_state.IsInvalid()) {\n+        m_recent_rejects_reconsiderable.insert(GetPackageHash(package));\n+    }\n+    // We currently only expect to process 1-parent-1-child packages. Remove if this changes.\n+    if (!Assume(package.size() == 2)) return;\n+\n+    // No package results to look through for PCKG_POLICY or PCKG_MEMPOOL_ERROR\n+    if (package_result.m_state.GetResult() == PackageValidationResult::PCKG_POLICY ||\n+        package_result.m_state.GetResult() == PackageValidationResult::PCKG_MEMPOOL_ERROR) return;\n+\n+    // Iterate backwards to erase in-package descendants from the orphanage before they become\n+    // relevant in AddChildrenToWorkSet.\n+    auto package_iter = package.rbegin();\n+    auto senders_iter = senders.rbegin();\n+    while (package_iter != package.rend()) {\n+        const auto& tx = *package_iter;\n+        const NodeId nodeid = *senders_iter;\n+        const auto it_result{package_result.m_tx_results.find(tx->GetWitnessHash())};\n+        if (Assume(it_result != package_result.m_tx_results.end())) {\n+            const auto& tx_result = it_result->second;\n+            switch (tx_result.m_result_type) {\n+                case MempoolAcceptResult::ResultType::VALID:\n+                {\n+                    Assume(tx_result.m_replaced_transactions.has_value());\n+                    std::list<CTransactionRef> empty_replacement_list;\n+                    ProcessValidTx(nodeid, tx, tx_result.m_replaced_transactions.value_or(empty_replacement_list));\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::INVALID:\n+                case MempoolAcceptResult::ResultType::DIFFERENT_WITNESS:\n+                {\n+                    // Don't add to vExtraTxnForCompact, as these transactions should have already been\n+                    // added there when added to the orphanage or rejected for TX_RECONSIDERABLE.\n+                    // This should be updated if package submission is ever used for transactions\n+                    // that haven't already been validated before.\n+                    ProcessInvalidTx(nodeid, tx, tx_result.m_state, /*maybe_add_extra_compact_tx=*/false);\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::MEMPOOL_ENTRY:\n+                {\n+                    // AlreadyHaveTx() should be catching transactions that are already in mempool.\n+                    Assume(false);\n+                    break;\n+                }\n+            }\n+        }\n+        package_iter++;\n+        // There should be a sender for each tx, but fall back to the last one otherwise.\n+        if (Assume(senders_iter != senders.rend())) senders_iter++;\n+    }\n+}\n+\n+void PeerManagerImpl::MaybeProcess1P1CPackage(const CTransactionRef& ptx, NodeId nodeid)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    const auto& parent_txid{ptx->GetHash()};\n+    const auto& parent_wtxid{ptx->GetWitnessHash()};\n+\n+    CTransactionRef tx_orphan{nullptr};",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 93,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "bb3bf0a39c036fbd94b99ed7002db7d9bdf0a1d6",
      "in_reply_to_id": 1576744547,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Ok I've done a bit of refactoring to split this into 2 functions for finding the package and validating/processing the package, and made a `PackageToValidate` struct that's difficult to misuse. Got rid of these \"set me if you find something\" variables.",
      "created_at": "2024-04-26T09:34:42Z",
      "updated_at": "2024-04-26T10:10:18Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1580755767",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1580755767"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3280,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1580756146",
      "pull_request_review_id": 2024465284,
      "id": 1580756146,
      "node_id": "PRRC_kwDOABII585eOGyy",
      "diff_hunk": "@@ -3195,6 +3210,140 @@ void PeerManagerImpl::ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, c\n     }\n }\n \n+void PeerManagerImpl::ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, const std::vector<NodeId>& senders)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    if (package_result.m_state.IsInvalid()) {\n+        m_recent_rejects_reconsiderable.insert(GetPackageHash(package));\n+    }\n+    // We currently only expect to process 1-parent-1-child packages. Remove if this changes.\n+    if (!Assume(package.size() == 2)) return;\n+\n+    // No package results to look through for PCKG_POLICY or PCKG_MEMPOOL_ERROR\n+    if (package_result.m_state.GetResult() == PackageValidationResult::PCKG_POLICY ||\n+        package_result.m_state.GetResult() == PackageValidationResult::PCKG_MEMPOOL_ERROR) return;\n+\n+    // Iterate backwards to erase in-package descendants from the orphanage before they become\n+    // relevant in AddChildrenToWorkSet.\n+    auto package_iter = package.rbegin();\n+    auto senders_iter = senders.rbegin();\n+    while (package_iter != package.rend()) {\n+        const auto& tx = *package_iter;\n+        const NodeId nodeid = *senders_iter;\n+        const auto it_result{package_result.m_tx_results.find(tx->GetWitnessHash())};\n+        if (Assume(it_result != package_result.m_tx_results.end())) {\n+            const auto& tx_result = it_result->second;\n+            switch (tx_result.m_result_type) {\n+                case MempoolAcceptResult::ResultType::VALID:\n+                {\n+                    Assume(tx_result.m_replaced_transactions.has_value());\n+                    std::list<CTransactionRef> empty_replacement_list;\n+                    ProcessValidTx(nodeid, tx, tx_result.m_replaced_transactions.value_or(empty_replacement_list));\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::INVALID:\n+                case MempoolAcceptResult::ResultType::DIFFERENT_WITNESS:\n+                {\n+                    // Don't add to vExtraTxnForCompact, as these transactions should have already been\n+                    // added there when added to the orphanage or rejected for TX_RECONSIDERABLE.\n+                    // This should be updated if package submission is ever used for transactions\n+                    // that haven't already been validated before.\n+                    ProcessInvalidTx(nodeid, tx, tx_result.m_state, /*maybe_add_extra_compact_tx=*/false);\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::MEMPOOL_ENTRY:\n+                {\n+                    // AlreadyHaveTx() should be catching transactions that are already in mempool.\n+                    Assume(false);\n+                    break;\n+                }\n+            }\n+        }\n+        package_iter++;\n+        // There should be a sender for each tx, but fall back to the last one otherwise.\n+        if (Assume(senders_iter != senders.rend())) senders_iter++;\n+    }\n+}\n+\n+void PeerManagerImpl::MaybeProcess1P1CPackage(const CTransactionRef& ptx, NodeId nodeid)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    const auto& parent_txid{ptx->GetHash()};\n+    const auto& parent_wtxid{ptx->GetWitnessHash()};\n+\n+    CTransactionRef tx_orphan{nullptr};\n+    NodeId orphan_sender{-1};\n+    Assume(m_recent_rejects_reconsiderable.contains(parent_wtxid.ToUint256()));\n+\n+    // Prefer children from this peer. This helps prevent censorship attempts in which an attacker\n+    // sends lots of fake children for the parent, and we (unluckily) keep selecting the fake\n+    // children instead of the real one provided by the honest peer.\n+    const auto cpfp_candidates_same_peer{m_orphanage.GetChildrenFromSamePeer(ptx, nodeid)};\n+\n+    // These children should be sorted from most newest to oldest. In the (probably uncommon) case",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 102,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "bb3bf0a39c036fbd94b99ed7002db7d9bdf0a1d6",
      "in_reply_to_id": 1576672946,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "haha oops, deleted",
      "created_at": "2024-04-26T09:35:03Z",
      "updated_at": "2024-04-26T10:10:18Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1580756146",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1580756146"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3289,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1580789096",
      "pull_request_review_id": 2024465284,
      "id": 1580789096,
      "node_id": "PRRC_kwDOABII585eOO1o",
      "diff_hunk": "@@ -0,0 +1,392 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test opportunistic 1p1c package submission logic.\n+\"\"\"\n+\n+from decimal import Decimal\n+import time\n+from test_framework.messages import (\n+    CInv,\n+    CTxInWitness,\n+    MSG_WTX,\n+    msg_inv,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    fill_mempool,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+# Number of seconds to wait to ensure no getdata is received\n+GETDATA_WAIT = 60\n+\n+def cleanup(func):\n+    def wrapper(self, *args, **kwargs):\n+        try:\n+            func(self, *args, **kwargs)\n+        finally:\n+            self.nodes[0].disconnect_p2ps()\n+            # Do not clear the node's mempool, as each test requires mempool min feerate > min\n+            # relay feerate. However, do check that this is the case.\n+            assert self.nodes[0].getmempoolinfo()[\"mempoolminfee\"] > self.nodes[0].getnetworkinfo()[\"relayfee\"]\n+            # Ensure we do not try to spend the same UTXOs in subsequent tests, as they will look like RBF attempts.\n+            self.wallet.rescan_utxos(include_mempool=True)\n+\n+            # Resets if mocktime was used\n+            self.nodes[0].setmocktime(0)\n+    return wrapper\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+        ]]\n+        self.supports_cli = False\n+\n+    @cleanup\n+    def test_basic_child_then_parent(self):\n+        node = self.nodes[0]\n+        self.log.info(\"Check that opportunistic 1p1c logic works when child is received before parent\")\n+\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first (perhaps the low feerate parent didn't meet feefilter or the requests were sent to different nodes). It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. Sender relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 4. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+        node.disconnect_p2ps()\n+\n+    @cleanup\n+    def test_basic_parent_then_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=1, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=2, connection_type=\"outbound-full-relay\")\n+\n+        # 1. Parent is relayed first. It is too low feerate.\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer_sender.wait_for_getdata([parent_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer_ignored, check that it is ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+\n+        # 2. Child is relayed next. It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 3. Node requests the missing parent by txid.\n+        # It should do so even if it has previously rejected that parent for being too low feerate.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 4. Sender re-relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 5. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+    @cleanup\n+    def test_low_and_high_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        # This feerate is above mempoolminfee, but not enough to also bump the low feerate parent.\n+        feerate_just_above = node.getmempoolinfo()[\"mempoolminfee\"]\n+        med_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=feerate_just_above)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=3, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=4, connection_type=\"outbound-full-relay\")\n+\n+        self.log.info(\"Check that tx caches low fee parent + low fee child package rejections\")\n+\n+        # 1. Send parent, rejected for being low feerate.\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer_sender.wait_for_getdata([parent_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer_ignored, check that it is ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+\n+        # 2. Send an (orphan) child that has a higher feerate, but not enough to bump the parent.\n+        low_child_wtxid_int = int(med_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([low_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(med_fee_child[\"tx\"]))\n+\n+        # 3. Node requests the orphan's missing parent.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 4. The low parent + low child are submitted as a package. They are not accepted due to low package feerate.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+        assert med_fee_child[\"txid\"] not in node.getrawmempool()\n+\n+        # If peer_ignored announces the low feerate child, it should be ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+        # If either peer sends the parent again, package evaluation should not be attempted\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        peer_ignored.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 5. Send the high feerate (orphan) child\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 6. Node requests the orphan's parent, even though it has already been rejected, both by\n+        # itself and with a child. This is necessary, otherwise high_fee_child can be censored.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 7. The low feerate parent + high feerate child are submitted as a package.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 8. Both transactions should now be in mempool\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+    @cleanup\n+    def test_orphan_consensus_failure(self):\n+        self.log.info(\"Check opportunistic 1p1c logic with consensus-invalid orphan causes disconnect of the correct peer\")\n+        node = self.nodes[0]\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        coin = low_fee_parent[\"new_utxo\"]\n+        address = node.get_deterministic_priv_key().address\n+        # Create raw transaction spending the parent, but with no signature (a consensus error).\n+        hex_orphan_no_sig = node.createrawtransaction([{\"txid\": coin[\"txid\"], \"vout\": coin[\"vout\"]}], {address : coin[\"value\"] - Decimal(\"0.0001\")})\n+        tx_orphan_bad_wit = tx_from_hex(hex_orphan_no_sig)\n+        tx_orphan_bad_wit.wit.vtxinwit.append(CTxInWitness())\n+        tx_orphan_bad_wit.wit.vtxinwit[0].scriptWitness.stack = [b'garbage']\n+\n+        bad_orphan_sender = node.add_p2p_connection(P2PInterface())\n+        parent_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first. It is missing an input.\n+        child_wtxid_int = int(tx_orphan_bad_wit.getwtxid(), 16)\n+        bad_orphan_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=child_wtxid_int)]))\n+        bad_orphan_sender.wait_for_getdata([child_wtxid_int])\n+        bad_orphan_sender.send_and_ping(msg_tx(tx_orphan_bad_wit))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        bad_orphan_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. A different peer relays the parent. Parent+Child are evaluated as a package and rejected.\n+        parent_sender.send_message(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 4. Transactions should not be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] not in node_mempool\n+        assert tx_orphan_bad_wit.rehash() not in node_mempool\n+\n+        # 5. Peer that sent a consensus-invalid transaction should be disconnected.\n+        bad_orphan_sender.wait_for_disconnect()\n+\n+        # The peer that didn't provide the orphan should not be disconnected.\n+        parent_sender.sync_with_ping()\n+\n+    @cleanup\n+    def test_parent_consensus_failure(self):\n+        self.log.info(\"Check opportunistic 1p1c logic with consensus-invalid parent causes disconnect of the correct peer\")\n+        node = self.nodes[0]\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+\n+        # Create invalid version of parent with a bad signature.\n+        tx_parent_bad_wit = tx_from_hex(low_fee_parent[\"hex\"])\n+        tx_parent_bad_wit.wit.vtxinwit.append(CTxInWitness())\n+        tx_parent_bad_wit.wit.vtxinwit[0].scriptWitness.stack = [b'garbage']\n+\n+        package_sender = node.add_p2p_connection(P2PInterface())\n+        fake_parent_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first. It is missing an input.\n+        child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        package_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=child_wtxid_int)]))\n+        package_sender.wait_for_getdata([child_wtxid_int])\n+        package_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(tx_parent_bad_wit.rehash(), 16)\n+        package_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. A different node relays the parent. The parent is first evaluated by itself and\n+        # rejected for being too low feerate. Then it is evaluated as a package and, after passing\n+        # feerate checks, rejected for having a bad signature (consensus error).\n+        fake_parent_sender.send_message(msg_tx(tx_parent_bad_wit))\n+\n+        # 4. Transactions should not be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert tx_parent_bad_wit.rehash() not in node_mempool\n+        assert high_fee_child[\"txid\"] not in node_mempool\n+\n+        # 5. Peer sent a consensus-invalid transaction.\n+        fake_parent_sender.wait_for_disconnect()\n+\n+        self.log.info(\"Check that fake parent does not cause orphan to be deleted and real package can still be submitted\")\n+        # 6. Child-sending should not have been punished and the orphan should remain in orphanage.\n+        # It can send the \"real\" parent transaction, and the package is accepted.\n+        package_sender.sync_with_ping()\n+        package_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))",
      "path": "test/functional/p2p_opportunistic_1p1c.py",
      "position": 298,
      "original_position": 281,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "30c9e6bc4e9f8b8b606e55435dc3f743cb2dd670",
      "in_reply_to_id": 1578550174,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I've fixed it by having each subtest set a unique `nSequence` on parent transactions :shrug:\r\nAlso considered changing `MiniWallet` to have some randomness but this seemed simpler.\r\nI've added these lines to the test as well.",
      "created_at": "2024-04-26T09:56:25Z",
      "updated_at": "2024-04-26T10:10:19Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1580789096",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1580789096"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 298,
      "original_line": 298,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1580804186",
      "pull_request_review_id": 2024465284,
      "id": 1580804186,
      "node_id": "PRRC_kwDOABII585eOSha",
      "diff_hunk": "@@ -3195,6 +3210,140 @@ void PeerManagerImpl::ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, c\n     }\n }\n \n+void PeerManagerImpl::ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, const std::vector<NodeId>& senders)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    if (package_result.m_state.IsInvalid()) {\n+        m_recent_rejects_reconsiderable.insert(GetPackageHash(package));\n+    }\n+    // We currently only expect to process 1-parent-1-child packages. Remove if this changes.\n+    if (!Assume(package.size() == 2)) return;\n+\n+    // No package results to look through for PCKG_POLICY or PCKG_MEMPOOL_ERROR\n+    if (package_result.m_state.GetResult() == PackageValidationResult::PCKG_POLICY ||\n+        package_result.m_state.GetResult() == PackageValidationResult::PCKG_MEMPOOL_ERROR) return;\n+\n+    // Iterate backwards to erase in-package descendants from the orphanage before they become\n+    // relevant in AddChildrenToWorkSet.\n+    auto package_iter = package.rbegin();\n+    auto senders_iter = senders.rbegin();\n+    while (package_iter != package.rend()) {\n+        const auto& tx = *package_iter;\n+        const NodeId nodeid = *senders_iter;\n+        const auto it_result{package_result.m_tx_results.find(tx->GetWitnessHash())};\n+        if (Assume(it_result != package_result.m_tx_results.end())) {\n+            const auto& tx_result = it_result->second;\n+            switch (tx_result.m_result_type) {\n+                case MempoolAcceptResult::ResultType::VALID:\n+                {\n+                    Assume(tx_result.m_replaced_transactions.has_value());\n+                    std::list<CTransactionRef> empty_replacement_list;\n+                    ProcessValidTx(nodeid, tx, tx_result.m_replaced_transactions.value_or(empty_replacement_list));\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::INVALID:\n+                case MempoolAcceptResult::ResultType::DIFFERENT_WITNESS:\n+                {\n+                    // Don't add to vExtraTxnForCompact, as these transactions should have already been\n+                    // added there when added to the orphanage or rejected for TX_RECONSIDERABLE.\n+                    // This should be updated if package submission is ever used for transactions\n+                    // that haven't already been validated before.\n+                    ProcessInvalidTx(nodeid, tx, tx_result.m_state, /*maybe_add_extra_compact_tx=*/false);\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::MEMPOOL_ENTRY:\n+                {\n+                    // AlreadyHaveTx() should be catching transactions that are already in mempool.\n+                    Assume(false);\n+                    break;\n+                }\n+            }\n+        }\n+        package_iter++;\n+        // There should be a sender for each tx, but fall back to the last one otherwise.\n+        if (Assume(senders_iter != senders.rend())) senders_iter++;\n+    }\n+}\n+\n+void PeerManagerImpl::MaybeProcess1P1CPackage(const CTransactionRef& ptx, NodeId nodeid)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    const auto& parent_txid{ptx->GetHash()};\n+    const auto& parent_wtxid{ptx->GetWitnessHash()};\n+\n+    CTransactionRef tx_orphan{nullptr};\n+    NodeId orphan_sender{-1};\n+    Assume(m_recent_rejects_reconsiderable.contains(parent_wtxid.ToUint256()));\n+\n+    // Prefer children from this peer. This helps prevent censorship attempts in which an attacker\n+    // sends lots of fake children for the parent, and we (unluckily) keep selecting the fake\n+    // children instead of the real one provided by the honest peer.\n+    const auto cpfp_candidates_same_peer{m_orphanage.GetChildrenFromSamePeer(ptx, nodeid)};\n+\n+    // These children should be sorted from most newest to oldest. In the (probably uncommon) case\n+    // of children that replace each other, this helps us accept the highest feerate (probably the\n+    // most recent) one efficiently.\n+    for (const auto& child : cpfp_candidates_same_peer) {\n+        Package maybe_cpfp_package{ptx, child};\n+        if (!m_recent_rejects_reconsiderable.contains(GetPackageHash(maybe_cpfp_package))) {\n+            tx_orphan = child;\n+            orphan_sender = nodeid;\n+            break;\n+        }\n+    }\n+\n+    // If no suitable candidate from the same peer is found, also try children that were provided by\n+    // a different peer. This is useful because sometimes multiple peers announce both transactions\n+    // to us, and we happen to download them from different peers (we wouldn't have known that these\n+    // 2 transactions are related). We still want to find 1p1c packages then.\n+    //\n+    // If we start tracking all announcers of orphans, we can restrict this logic to parent + child\n+    // pairs in which both were provided by the same peer, i.e. delete this step.\n+    if (!tx_orphan) {\n+        const auto cpfp_candidates_different_peer{m_orphanage.GetChildrenFromDifferentPeer(ptx, nodeid)};\n+\n+        // Find the first 1p1c that hasn't already been rejected. We randomize the order to not\n+        // create a bias that attackers can use to delay package acceptance.\n+        //\n+        // Create a random permutation of the indices.\n+        std::vector<size_t> tx_indices(cpfp_candidates_different_peer.size());\n+        std::iota(tx_indices.begin(), tx_indices.end(), 0);\n+        Shuffle(tx_indices.begin(), tx_indices.end(), m_rng);\n+\n+        for (const auto index : tx_indices) {\n+            // If we already tried a package and failed for any reason, the combined hash was\n+            // cached in m_recent_rejects_reconsiderable.\n+            Package maybe_cpfp_package{ptx, cpfp_candidates_different_peer.at(index).first};\n+            if (!m_recent_rejects_reconsiderable.contains(GetPackageHash(maybe_cpfp_package))) {\n+                tx_orphan = cpfp_candidates_different_peer.at(index).first;\n+                orphan_sender = cpfp_candidates_different_peer.at(index).second;\n+                break;\n+            }",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 140,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "bb3bf0a39c036fbd94b99ed7002db7d9bdf0a1d6",
      "in_reply_to_id": 1578122793,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "done",
      "created_at": "2024-04-26T10:09:54Z",
      "updated_at": "2024-04-26T10:10:19Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1580804186",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1580804186"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": 3322,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 3327,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1581019326",
      "pull_request_review_id": 2025023787,
      "id": 1581019326,
      "node_id": "PRRC_kwDOABII585ePHC-",
      "diff_hunk": "@@ -596,6 +596,45 @@ class PeerManagerImpl final : public PeerManager\n     void ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, const std::list<CTransactionRef>& replaced_transactions)\n         EXCLUSIVE_LOCKS_REQUIRED(!m_peer_mutex, g_msgproc_mutex, cs_main);\n \n+    /** Handle the results of package validation: calls ProcessValidTx and ProcessInvalidTx for\n+     * individual transactions, and caches rejection for the package as a group.\n+     * @param[in]   senders     Must contain the nodeids of the peers that provided each transaction\n+     *                          in package, in the same order.\n+     *   */\n+    void ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, const std::vector<NodeId>& senders)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_peer_mutex, g_msgproc_mutex, cs_main);\n+\n+    /** A package to validate  */",
      "path": "src/net_processing.cpp",
      "position": 21,
      "original_position": 12,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "87c5c524d63c833cf490c7f2f73d72695ad480df",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "redundant comment",
      "created_at": "2024-04-26T13:12:04Z",
      "updated_at": "2024-04-26T14:00:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1581019326",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1581019326"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 607,
      "original_line": 607,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1581036209",
      "pull_request_review_id": 2025023787,
      "id": 1581036209,
      "node_id": "PRRC_kwDOABII585ePLKx",
      "diff_hunk": "@@ -3198,6 +3237,117 @@ void PeerManagerImpl::ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, c\n     }\n }\n \n+void PeerManagerImpl::ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, const std::vector<NodeId>& senders)",
      "path": "src/net_processing.cpp",
      "position": 160,
      "original_position": 50,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "87c5c524d63c833cf490c7f2f73d72695ad480df",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "now that we have `PackageToValidate`, just directly pass here?",
      "created_at": "2024-04-26T13:25:36Z",
      "updated_at": "2024-04-26T14:00:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1581036209",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1581036209"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 3240,
      "original_line": 3240,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1581069584",
      "pull_request_review_id": 2025023787,
      "id": 1581069584,
      "node_id": "PRRC_kwDOABII585ePTUQ",
      "diff_hunk": "@@ -596,6 +596,45 @@ class PeerManagerImpl final : public PeerManager\n     void ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, const std::list<CTransactionRef>& replaced_transactions)\n         EXCLUSIVE_LOCKS_REQUIRED(!m_peer_mutex, g_msgproc_mutex, cs_main);\n \n+    /** Handle the results of package validation: calls ProcessValidTx and ProcessInvalidTx for\n+     * individual transactions, and caches rejection for the package as a group.\n+     * @param[in]   senders     Must contain the nodeids of the peers that provided each transaction\n+     *                          in package, in the same order.\n+     *   */\n+    void ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, const std::vector<NodeId>& senders)\n+        EXCLUSIVE_LOCKS_REQUIRED(!m_peer_mutex, g_msgproc_mutex, cs_main);\n+\n+    /** A package to validate  */\n+    struct PackageToValidate {\n+        const Package m_txns;\n+        const std::vector<NodeId> m_senders;\n+        /** Construct a 1-parent-1-child package. */\n+        explicit PackageToValidate(const CTransactionRef& parent,\n+                                   const CTransactionRef& child,\n+                                   NodeId parent_sender,\n+                                   NodeId child_sender) :\n+            m_txns{parent, child},\n+            m_senders {parent_sender, child_sender}\n+        {}\n+\n+        std::string ToString() const {",
      "path": "src/net_processing.cpp",
      "position": 34,
      "original_position": 25,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "87c5c524d63c833cf490c7f2f73d72695ad480df",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "useful log message for stats :+1: ",
      "created_at": "2024-04-26T13:51:11Z",
      "updated_at": "2024-04-26T14:00:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1581069584",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1581069584"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 620,
      "original_line": 620,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1581122150",
      "pull_request_review_id": 2025196272,
      "id": 1581122150,
      "node_id": "PRRC_kwDOABII585ePgJm",
      "diff_hunk": "@@ -0,0 +1,392 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2024-present The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test opportunistic 1p1c package submission logic.\n+\"\"\"\n+\n+from decimal import Decimal\n+import time\n+from test_framework.messages import (\n+    CInv,\n+    CTxInWitness,\n+    MSG_WTX,\n+    msg_inv,\n+    msg_tx,\n+    tx_from_hex,\n+)\n+from test_framework.p2p import (\n+    P2PInterface,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    fill_mempool,\n+)\n+from test_framework.wallet import (\n+    MiniWallet,\n+    MiniWalletMode,\n+)\n+\n+# 1sat/vB feerate denominated in BTC/KvB\n+FEERATE_1SAT_VB = Decimal(\"0.00001000\")\n+# Number of seconds to wait to ensure no getdata is received\n+GETDATA_WAIT = 60\n+\n+def cleanup(func):\n+    def wrapper(self, *args, **kwargs):\n+        try:\n+            func(self, *args, **kwargs)\n+        finally:\n+            self.nodes[0].disconnect_p2ps()\n+            # Do not clear the node's mempool, as each test requires mempool min feerate > min\n+            # relay feerate. However, do check that this is the case.\n+            assert self.nodes[0].getmempoolinfo()[\"mempoolminfee\"] > self.nodes[0].getnetworkinfo()[\"relayfee\"]\n+            # Ensure we do not try to spend the same UTXOs in subsequent tests, as they will look like RBF attempts.\n+            self.wallet.rescan_utxos(include_mempool=True)\n+\n+            # Resets if mocktime was used\n+            self.nodes[0].setmocktime(0)\n+    return wrapper\n+\n+class PackageRelayTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+        self.extra_args = [[\n+            \"-datacarriersize=100000\",\n+            \"-maxmempool=5\",\n+        ]]\n+        self.supports_cli = False\n+\n+    @cleanup\n+    def test_basic_child_then_parent(self):\n+        node = self.nodes[0]\n+        self.log.info(\"Check that opportunistic 1p1c logic works when child is received before parent\")\n+\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first (perhaps the low feerate parent didn't meet feefilter or the requests were sent to different nodes). It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. Sender relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 4. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+        node.disconnect_p2ps()\n+\n+    @cleanup\n+    def test_basic_parent_then_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=20*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=1, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=2, connection_type=\"outbound-full-relay\")\n+\n+        # 1. Parent is relayed first. It is too low feerate.\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer_sender.wait_for_getdata([parent_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer_ignored, check that it is ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+\n+        # 2. Child is relayed next. It is missing an input.\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 3. Node requests the missing parent by txid.\n+        # It should do so even if it has previously rejected that parent for being too low feerate.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 4. Sender re-relays the parent. Parent+Child are evaluated as a package and accepted.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 5. Both transactions should now be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+    @cleanup\n+    def test_low_and_high_child(self, wallet):\n+        node = self.nodes[0]\n+        low_fee_parent = wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        # This feerate is above mempoolminfee, but not enough to also bump the low feerate parent.\n+        feerate_just_above = node.getmempoolinfo()[\"mempoolminfee\"]\n+        med_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=feerate_just_above)\n+        high_fee_child = wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+\n+        peer_sender = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=3, connection_type=\"outbound-full-relay\")\n+        peer_ignored = node.add_outbound_p2p_connection(P2PInterface(), p2p_idx=4, connection_type=\"outbound-full-relay\")\n+\n+        self.log.info(\"Check that tx caches low fee parent + low fee child package rejections\")\n+\n+        # 1. Send parent, rejected for being low feerate.\n+        parent_wtxid_int = int(low_fee_parent[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        peer_sender.wait_for_getdata([parent_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+\n+        # Send again from peer_ignored, check that it is ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=parent_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+\n+        # 2. Send an (orphan) child that has a higher feerate, but not enough to bump the parent.\n+        low_child_wtxid_int = int(med_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([low_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(med_fee_child[\"tx\"]))\n+\n+        # 3. Node requests the orphan's missing parent.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 4. The low parent + low child are submitted as a package. They are not accepted due to low package feerate.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        assert low_fee_parent[\"txid\"] not in node.getrawmempool()\n+        assert med_fee_child[\"txid\"] not in node.getrawmempool()\n+\n+        # If peer_ignored announces the low feerate child, it should be ignored\n+        peer_ignored.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=low_child_wtxid_int)]))\n+        assert \"getdata\" not in peer_ignored.last_message\n+        # If either peer sends the parent again, package evaluation should not be attempted\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+        peer_ignored.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 5. Send the high feerate (orphan) child\n+        high_child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        peer_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=high_child_wtxid_int)]))\n+        peer_sender.wait_for_getdata([high_child_wtxid_int])\n+        peer_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 6. Node requests the orphan's parent, even though it has already been rejected, both by\n+        # itself and with a child. This is necessary, otherwise high_fee_child can be censored.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        peer_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 7. The low feerate parent + high feerate child are submitted as a package.\n+        peer_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 8. Both transactions should now be in mempool\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] in node_mempool\n+        assert high_fee_child[\"txid\"] in node_mempool\n+\n+    @cleanup\n+    def test_orphan_consensus_failure(self):\n+        self.log.info(\"Check opportunistic 1p1c logic with consensus-invalid orphan causes disconnect of the correct peer\")\n+        node = self.nodes[0]\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        coin = low_fee_parent[\"new_utxo\"]\n+        address = node.get_deterministic_priv_key().address\n+        # Create raw transaction spending the parent, but with no signature (a consensus error).\n+        hex_orphan_no_sig = node.createrawtransaction([{\"txid\": coin[\"txid\"], \"vout\": coin[\"vout\"]}], {address : coin[\"value\"] - Decimal(\"0.0001\")})\n+        tx_orphan_bad_wit = tx_from_hex(hex_orphan_no_sig)\n+        tx_orphan_bad_wit.wit.vtxinwit.append(CTxInWitness())\n+        tx_orphan_bad_wit.wit.vtxinwit[0].scriptWitness.stack = [b'garbage']\n+\n+        bad_orphan_sender = node.add_p2p_connection(P2PInterface())\n+        parent_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first. It is missing an input.\n+        child_wtxid_int = int(tx_orphan_bad_wit.getwtxid(), 16)\n+        bad_orphan_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=child_wtxid_int)]))\n+        bad_orphan_sender.wait_for_getdata([child_wtxid_int])\n+        bad_orphan_sender.send_and_ping(msg_tx(tx_orphan_bad_wit))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(low_fee_parent[\"txid\"], 16)\n+        bad_orphan_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. A different peer relays the parent. Parent+Child are evaluated as a package and rejected.\n+        parent_sender.send_message(msg_tx(low_fee_parent[\"tx\"]))\n+\n+        # 4. Transactions should not be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert low_fee_parent[\"txid\"] not in node_mempool\n+        assert tx_orphan_bad_wit.rehash() not in node_mempool\n+\n+        # 5. Peer that sent a consensus-invalid transaction should be disconnected.\n+        bad_orphan_sender.wait_for_disconnect()\n+\n+        # The peer that didn't provide the orphan should not be disconnected.\n+        parent_sender.sync_with_ping()\n+\n+    @cleanup\n+    def test_parent_consensus_failure(self):\n+        self.log.info(\"Check opportunistic 1p1c logic with consensus-invalid parent causes disconnect of the correct peer\")\n+        node = self.nodes[0]\n+        low_fee_parent = self.wallet.create_self_transfer(fee_rate=FEERATE_1SAT_VB, confirmed_only=True)\n+        high_fee_child = self.wallet.create_self_transfer(utxo_to_spend=low_fee_parent[\"new_utxo\"], fee_rate=999*FEERATE_1SAT_VB)\n+\n+        # Create invalid version of parent with a bad signature.\n+        tx_parent_bad_wit = tx_from_hex(low_fee_parent[\"hex\"])\n+        tx_parent_bad_wit.wit.vtxinwit.append(CTxInWitness())\n+        tx_parent_bad_wit.wit.vtxinwit[0].scriptWitness.stack = [b'garbage']\n+\n+        package_sender = node.add_p2p_connection(P2PInterface())\n+        fake_parent_sender = node.add_p2p_connection(P2PInterface())\n+\n+        # 1. Child is received first. It is missing an input.\n+        child_wtxid_int = int(high_fee_child[\"tx\"].getwtxid(), 16)\n+        package_sender.send_and_ping(msg_inv([CInv(t=MSG_WTX, h=child_wtxid_int)]))\n+        package_sender.wait_for_getdata([child_wtxid_int])\n+        package_sender.send_and_ping(msg_tx(high_fee_child[\"tx\"]))\n+\n+        # 2. Node requests the missing parent by txid.\n+        parent_txid_int = int(tx_parent_bad_wit.rehash(), 16)\n+        package_sender.wait_for_getdata([parent_txid_int])\n+\n+        # 3. A different node relays the parent. The parent is first evaluated by itself and\n+        # rejected for being too low feerate. Then it is evaluated as a package and, after passing\n+        # feerate checks, rejected for having a bad signature (consensus error).\n+        fake_parent_sender.send_message(msg_tx(tx_parent_bad_wit))\n+\n+        # 4. Transactions should not be in mempool.\n+        node_mempool = node.getrawmempool()\n+        assert tx_parent_bad_wit.rehash() not in node_mempool\n+        assert high_fee_child[\"txid\"] not in node_mempool\n+\n+        # 5. Peer sent a consensus-invalid transaction.\n+        fake_parent_sender.wait_for_disconnect()\n+\n+        self.log.info(\"Check that fake parent does not cause orphan to be deleted and real package can still be submitted\")\n+        # 6. Child-sending should not have been punished and the orphan should remain in orphanage.\n+        # It can send the \"real\" parent transaction, and the package is accepted.\n+        package_sender.sync_with_ping()\n+        package_sender.send_and_ping(msg_tx(low_fee_parent[\"tx\"]))",
      "path": "test/functional/p2p_opportunistic_1p1c.py",
      "position": 298,
      "original_position": 281,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "30c9e6bc4e9f8b8b606e55435dc3f743cb2dd670",
      "in_reply_to_id": 1578550174,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Seems good enough ",
      "created_at": "2024-04-26T14:30:53Z",
      "updated_at": "2024-04-26T14:30:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1581122150",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1581122150"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 298,
      "original_line": 298,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1581147730",
      "pull_request_review_id": 2025241088,
      "id": 1581147730,
      "node_id": "PRRC_kwDOABII585ePmZS",
      "diff_hunk": "@@ -3195,6 +3210,140 @@ void PeerManagerImpl::ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, c\n     }\n }\n \n+void PeerManagerImpl::ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, const std::vector<NodeId>& senders)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    if (package_result.m_state.IsInvalid()) {\n+        m_recent_rejects_reconsiderable.insert(GetPackageHash(package));\n+    }\n+    // We currently only expect to process 1-parent-1-child packages. Remove if this changes.\n+    if (!Assume(package.size() == 2)) return;\n+\n+    // No package results to look through for PCKG_POLICY or PCKG_MEMPOOL_ERROR\n+    if (package_result.m_state.GetResult() == PackageValidationResult::PCKG_POLICY ||\n+        package_result.m_state.GetResult() == PackageValidationResult::PCKG_MEMPOOL_ERROR) return;\n+\n+    // Iterate backwards to erase in-package descendants from the orphanage before they become\n+    // relevant in AddChildrenToWorkSet.\n+    auto package_iter = package.rbegin();\n+    auto senders_iter = senders.rbegin();\n+    while (package_iter != package.rend()) {\n+        const auto& tx = *package_iter;\n+        const NodeId nodeid = *senders_iter;\n+        const auto it_result{package_result.m_tx_results.find(tx->GetWitnessHash())};\n+        if (Assume(it_result != package_result.m_tx_results.end())) {\n+            const auto& tx_result = it_result->second;\n+            switch (tx_result.m_result_type) {\n+                case MempoolAcceptResult::ResultType::VALID:\n+                {\n+                    Assume(tx_result.m_replaced_transactions.has_value());\n+                    std::list<CTransactionRef> empty_replacement_list;\n+                    ProcessValidTx(nodeid, tx, tx_result.m_replaced_transactions.value_or(empty_replacement_list));\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::INVALID:\n+                case MempoolAcceptResult::ResultType::DIFFERENT_WITNESS:\n+                {\n+                    // Don't add to vExtraTxnForCompact, as these transactions should have already been\n+                    // added there when added to the orphanage or rejected for TX_RECONSIDERABLE.\n+                    // This should be updated if package submission is ever used for transactions\n+                    // that haven't already been validated before.\n+                    ProcessInvalidTx(nodeid, tx, tx_result.m_state, /*maybe_add_extra_compact_tx=*/false);\n+                    break;\n+                }\n+                case MempoolAcceptResult::ResultType::MEMPOOL_ENTRY:\n+                {\n+                    // AlreadyHaveTx() should be catching transactions that are already in mempool.\n+                    Assume(false);\n+                    break;\n+                }\n+            }\n+        }\n+        package_iter++;\n+        // There should be a sender for each tx, but fall back to the last one otherwise.\n+        if (Assume(senders_iter != senders.rend())) senders_iter++;\n+    }\n+}\n+\n+void PeerManagerImpl::MaybeProcess1P1CPackage(const CTransactionRef& ptx, NodeId nodeid)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    const auto& parent_txid{ptx->GetHash()};\n+    const auto& parent_wtxid{ptx->GetWitnessHash()};\n+\n+    CTransactionRef tx_orphan{nullptr};",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 93,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "bb3bf0a39c036fbd94b99ed7002db7d9bdf0a1d6",
      "in_reply_to_id": 1576744547,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Much cleaner now",
      "created_at": "2024-04-26T14:50:52Z",
      "updated_at": "2024-04-26T14:50:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1581147730",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1581147730"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3280,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1581157473",
      "pull_request_review_id": 2025256892,
      "id": 1581157473,
      "node_id": "PRRC_kwDOABII585ePoxh",
      "diff_hunk": "@@ -3195,6 +3210,140 @@ void PeerManagerImpl::ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, c\n     }\n }\n \n+void PeerManagerImpl::ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, const std::vector<NodeId>& senders)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    if (package_result.m_state.IsInvalid()) {\n+        m_recent_rejects_reconsiderable.insert(GetPackageHash(package));\n+    }",
      "path": "src/net_processing.cpp",
      "position": 168,
      "original_position": 34,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "bb3bf0a39c036fbd94b99ed7002db7d9bdf0a1d6",
      "in_reply_to_id": 1576758551,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Why caching this in `m_recent_rejects_reconsiderable` instead of `m_recent_rejects` if we are not going to reconsider them?",
      "created_at": "2024-04-26T14:58:26Z",
      "updated_at": "2024-04-26T14:58:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1581157473",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1581157473"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": 3246,
      "original_start_line": 3219,
      "start_side": "RIGHT",
      "line": 3248,
      "original_line": 3248,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1581758233",
      "pull_request_review_id": 2026609147,
      "id": 1581758233,
      "node_id": "PRRC_kwDOABII585eR7cZ",
      "diff_hunk": "@@ -3195,6 +3210,140 @@ void PeerManagerImpl::ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, c\n     }\n }\n \n+void PeerManagerImpl::ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, const std::vector<NodeId>& senders)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    if (package_result.m_state.IsInvalid()) {\n+        m_recent_rejects_reconsiderable.insert(GetPackageHash(package));\n+    }",
      "path": "src/net_processing.cpp",
      "position": 168,
      "original_position": 34,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "bb3bf0a39c036fbd94b99ed7002db7d9bdf0a1d6",
      "in_reply_to_id": 1576758551,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Same question as https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1566378431\r\n\r\nI like that this doesn't add extra burden to `m_recent_rejects` (which is probably the busier of the 2 filters even though they have the same size). It makes more sense if you think of each tx within the package as reconsiderable, even though the package isn't?",
      "created_at": "2024-04-27T08:25:43Z",
      "updated_at": "2024-04-27T08:25:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1581758233",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1581758233"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": 3246,
      "original_start_line": 3219,
      "start_side": "RIGHT",
      "line": 3248,
      "original_line": 3248,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1583123904",
      "pull_request_review_id": 2028574204,
      "id": 1583123904,
      "node_id": "PRRC_kwDOABII585eXI3A",
      "diff_hunk": "@@ -3195,6 +3210,140 @@ void PeerManagerImpl::ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, c\n     }\n }\n \n+void PeerManagerImpl::ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, const std::vector<NodeId>& senders)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    if (package_result.m_state.IsInvalid()) {\n+        m_recent_rejects_reconsiderable.insert(GetPackageHash(package));\n+    }",
      "path": "src/net_processing.cpp",
      "position": 168,
      "original_position": 34,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "bb3bf0a39c036fbd94b99ed7002db7d9bdf0a1d6",
      "in_reply_to_id": 1576758551,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I think, design-wise, it's a bit counter-intuitive, but I do agree that not overloading `m_recent_rejects` is potentially better",
      "created_at": "2024-04-29T13:46:32Z",
      "updated_at": "2024-04-29T13:46:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1583123904",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1583123904"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": 3246,
      "original_start_line": 3219,
      "start_side": "RIGHT",
      "line": 3248,
      "original_line": 3248,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1584871688",
      "pull_request_review_id": 2031444770,
      "id": 1584871688,
      "node_id": "PRRC_kwDOABII585edzkI",
      "diff_hunk": "@@ -4467,6 +4646,19 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         if (state.IsInvalid()) {\n             ProcessInvalidTx(pfrom.GetId(), ptx, state, /*maybe_add_extra_compact_tx=*/true);\n         }\n+        // When a transaction fails for TX_RECONSIDERABLE, look for a matching child in the\n+        // orphanage, as it is possible that they succeed as a package.\n+        if (state.GetResult() == TxValidationResult::TX_RECONSIDERABLE) {",
      "path": "src/net_processing.cpp",
      "position": 365,
      "original_position": 226,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "87c5c524d63c833cf490c7f2f73d72695ad480df",
      "in_reply_to_id": null,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I think attempting to accept a 1p1c package could also be done when reconsidering transactions from the orphanage in `ProcessOrphanTx`. E.g. you might have a 1p1c package in your orphanage (P -> C) and if P is reconsidered but rejected as `TX_RECONSIDERABLE` you might want to look for C in the orphanage and if found try 1p1c acceptance.\r\n\r\nMaybe its not worth adding right now (any scenarios I can think of seem somewhat rare) but perhaps worthwhile later if the data suggests so.",
      "created_at": "2024-04-30T13:52:34Z",
      "updated_at": "2024-04-30T14:08:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1584871688",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1584871688"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 4651,
      "original_line": 4651,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1584882538",
      "pull_request_review_id": 2031463183,
      "id": 1584882538,
      "node_id": "PRRC_kwDOABII585ed2Nq",
      "diff_hunk": "@@ -4371,10 +4582,23 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             }\n             std::sort(unique_parents.begin(), unique_parents.end());\n             unique_parents.erase(std::unique(unique_parents.begin(), unique_parents.end()), unique_parents.end());\n+\n+            // Distinguish between parents in m_recent_rejects and m_recent_rejects_reconsiderable.\n+            // We can tolerate having up to 1 parent in m_recent_rejects_reconsiderable since we\n+            // submit 1p1c packages. However, fail immediately if any are in m_recent_rejects.\n+            std::optional<uint256> rejected_parent_reconsiderable;\n             for (const uint256& parent_txid : unique_parents) {\n                 if (m_recent_rejects.contains(parent_txid)) {\n                     fRejectedParents = true;\n                     break;\n+                } else if (m_recent_rejects_reconsiderable.contains(parent_txid) && !m_mempool.exists(GenTxid::Txid(parent_txid))) {\n+                    // More than 1 parent in m_recent_rejects_reconsiderable: 1p1c will not be\n+                    // sufficient to accept this package, so just give up here.\n+                    if (rejected_parent_reconsiderable.has_value()) {",
      "path": "src/net_processing.cpp",
      "position": 340,
      "original_position": 340,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Ah, just found a mistake. I think this can go in a followup though.\r\n```suggestion\r\n                    if (rejected_parent_reconsiderable.has_value() && *rejected_parent_reconsiderable != parent_txid.ToUint256()) {\r\n```",
      "created_at": "2024-04-30T13:59:18Z",
      "updated_at": "2024-04-30T13:59:18Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1584882538",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1584882538"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 4597,
      "original_line": 4597,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1584890259",
      "pull_request_review_id": 2031444770,
      "id": 1584890259,
      "node_id": "PRRC_kwDOABII585ed4GT",
      "diff_hunk": "@@ -241,3 +241,77 @@ void TxOrphanage::EraseForBlock(const CBlock& block)\n         LogPrint(BCLog::TXPACKAGES, \"Erased %d orphan tx included or conflicted by block\\n\", nErased);\n     }\n }\n+\n+std::vector<CTransactionRef> TxOrphanage::GetChildrenFromSamePeer(const CTransactionRef& parent, NodeId nodeid) const\n+{\n+    LOCK(m_mutex);\n+\n+    // First construct a vector of iterators to ensure we do not return duplicates of the same tx\n+    // and so we can sort by nTimeExpire.\n+    std::vector<OrphanMap::iterator> iters;\n+\n+    // For each output, get all entries spending this prevout, filtering for ones from the specified peer.\n+    for (unsigned int i = 0; i < parent->vout.size(); i++) {\n+        const auto it_by_prev = m_outpoint_to_orphan_it.find(COutPoint(parent->GetHash(), i));\n+        if (it_by_prev != m_outpoint_to_orphan_it.end()) {\n+            for (const auto& elem : it_by_prev->second) {\n+                if (elem->second.fromPeer == nodeid) {\n+                    iters.emplace_back(elem);\n+                }\n+            }\n+        }\n+    }\n+\n+    // Sort by address so that duplicates can be deleted. At the same time, sort so that more recent\n+    // orphans (which expire later) come first.  Break ties based on address, as nTimeExpire is\n+    // quantified in seconds and it is possible for orphans to have the same expiry.\n+    std::sort(iters.begin(), iters.end(), [](const auto& lhs, const auto& rhs) {\n+        if (lhs->second.nTimeExpire == rhs->second.nTimeExpire) {\n+            return &(*lhs) < &(*rhs);\n+        } else {\n+            return lhs->second.nTimeExpire > rhs->second.nTimeExpire;\n+        }\n+    });\n+    // Erase duplicates\n+    iters.erase(std::unique(iters.begin(), iters.end()), iters.end());\n+\n+    // Convert to a vector of CTransactionRef\n+    std::vector<CTransactionRef> children_found;\n+    children_found.reserve(iters.size());\n+    for (const auto child_iter : iters) {\n+        children_found.emplace_back(child_iter->second.tx);\n+    }\n+    return children_found;\n+}\n+\n+std::vector<std::pair<CTransactionRef, NodeId>> TxOrphanage::GetChildrenFromDifferentPeer(const CTransactionRef& parent, NodeId nodeid) const\n+{\n+    LOCK(m_mutex);\n+\n+    // First construct vector of iterators to ensure we do not return duplicates of the same tx.\n+    std::vector<OrphanMap::iterator> iters;\n+\n+    // For each output, get all entries spending this prevout, filtering for ones not from the specified peer.\n+    for (unsigned int i = 0; i < parent->vout.size(); i++) {\n+        const auto it_by_prev = m_outpoint_to_orphan_it.find(COutPoint(parent->GetHash(), i));\n+        if (it_by_prev != m_outpoint_to_orphan_it.end()) {\n+            for (const auto& elem : it_by_prev->second) {\n+                if (elem->second.fromPeer != nodeid) {\n+                    iters.emplace_back(elem);\n+                }\n+            }\n+        }\n+    }\n+\n+    // Erase duplicates\n+    std::sort(iters.begin(), iters.end(), IteratorComparator());\n+    iters.erase(std::unique(iters.begin(), iters.end()), iters.end());",
      "path": "src/txorphanage.cpp",
      "position": 68,
      "original_position": 68,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "2f51cd680fb4323f1c792dae37d4c4e0e0e35804",
      "in_reply_to_id": null,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Why is this sort comparison different from the one in `GetChildrenFromSamePeer`?\r\n\r\nThese functions are almost identical as well. Perhaps a more generic ```std::vector<std::pair<CTransactionRef, NodeId>> GetChildren(const CTransactionRef&)``` that returns all children and their senders would be less code?",
      "created_at": "2024-04-30T14:04:13Z",
      "updated_at": "2024-04-30T14:08:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1584890259",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1584890259"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": 306,
      "original_start_line": 306,
      "start_side": "RIGHT",
      "line": 308,
      "original_line": 308,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1584890852",
      "pull_request_review_id": 2031477015,
      "id": 1584890852,
      "node_id": "PRRC_kwDOABII585ed4Pk",
      "diff_hunk": "@@ -4371,10 +4582,23 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             }\n             std::sort(unique_parents.begin(), unique_parents.end());\n             unique_parents.erase(std::unique(unique_parents.begin(), unique_parents.end()), unique_parents.end());\n+\n+            // Distinguish between parents in m_recent_rejects and m_recent_rejects_reconsiderable.\n+            // We can tolerate having up to 1 parent in m_recent_rejects_reconsiderable since we\n+            // submit 1p1c packages. However, fail immediately if any are in m_recent_rejects.\n+            std::optional<uint256> rejected_parent_reconsiderable;\n             for (const uint256& parent_txid : unique_parents) {\n                 if (m_recent_rejects.contains(parent_txid)) {\n                     fRejectedParents = true;\n                     break;\n+                } else if (m_recent_rejects_reconsiderable.contains(parent_txid) && !m_mempool.exists(GenTxid::Txid(parent_txid))) {\n+                    // More than 1 parent in m_recent_rejects_reconsiderable: 1p1c will not be\n+                    // sufficient to accept this package, so just give up here.\n+                    if (rejected_parent_reconsiderable.has_value()) {",
      "path": "src/net_processing.cpp",
      "position": 340,
      "original_position": 340,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "in_reply_to_id": 1584882538,
      "user": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Hmm, we're looping over unique parents already, so I think this code should be fine?  In which case is there a bug?",
      "created_at": "2024-04-30T14:04:35Z",
      "updated_at": "2024-04-30T14:04:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1584890852",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1584890852"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 4597,
      "original_line": 4597,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1584892625",
      "pull_request_review_id": 2031480350,
      "id": 1584892625,
      "node_id": "PRRC_kwDOABII585ed4rR",
      "diff_hunk": "@@ -4371,10 +4582,23 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             }\n             std::sort(unique_parents.begin(), unique_parents.end());\n             unique_parents.erase(std::unique(unique_parents.begin(), unique_parents.end()), unique_parents.end());\n+\n+            // Distinguish between parents in m_recent_rejects and m_recent_rejects_reconsiderable.\n+            // We can tolerate having up to 1 parent in m_recent_rejects_reconsiderable since we\n+            // submit 1p1c packages. However, fail immediately if any are in m_recent_rejects.\n+            std::optional<uint256> rejected_parent_reconsiderable;\n             for (const uint256& parent_txid : unique_parents) {\n                 if (m_recent_rejects.contains(parent_txid)) {\n                     fRejectedParents = true;\n                     break;\n+                } else if (m_recent_rejects_reconsiderable.contains(parent_txid) && !m_mempool.exists(GenTxid::Txid(parent_txid))) {\n+                    // More than 1 parent in m_recent_rejects_reconsiderable: 1p1c will not be\n+                    // sufficient to accept this package, so just give up here.\n+                    if (rejected_parent_reconsiderable.has_value()) {",
      "path": "src/net_processing.cpp",
      "position": 340,
      "original_position": 340,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "in_reply_to_id": 1584882538,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "they're unique txids, which scenarios will this fix?",
      "created_at": "2024-04-30T14:05:37Z",
      "updated_at": "2024-04-30T14:05:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1584892625",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1584892625"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 4597,
      "original_line": 4597,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1584902362",
      "pull_request_review_id": 2031498289,
      "id": 1584902362,
      "node_id": "PRRC_kwDOABII585ed7Da",
      "diff_hunk": "@@ -4371,10 +4582,23 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             }\n             std::sort(unique_parents.begin(), unique_parents.end());\n             unique_parents.erase(std::unique(unique_parents.begin(), unique_parents.end()), unique_parents.end());\n+\n+            // Distinguish between parents in m_recent_rejects and m_recent_rejects_reconsiderable.\n+            // We can tolerate having up to 1 parent in m_recent_rejects_reconsiderable since we\n+            // submit 1p1c packages. However, fail immediately if any are in m_recent_rejects.\n+            std::optional<uint256> rejected_parent_reconsiderable;\n             for (const uint256& parent_txid : unique_parents) {\n                 if (m_recent_rejects.contains(parent_txid)) {\n                     fRejectedParents = true;\n                     break;\n+                } else if (m_recent_rejects_reconsiderable.contains(parent_txid) && !m_mempool.exists(GenTxid::Txid(parent_txid))) {\n+                    // More than 1 parent in m_recent_rejects_reconsiderable: 1p1c will not be\n+                    // sufficient to accept this package, so just give up here.\n+                    if (rejected_parent_reconsiderable.has_value()) {",
      "path": "src/net_processing.cpp",
      "position": 340,
      "original_position": 340,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "in_reply_to_id": 1584882538,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Ah you're right, nevermind! I was thinking this would be a bug if it spends twice from the same low-feerate parent. Yes, `unique_parents` already takes care of this case.",
      "created_at": "2024-04-30T14:11:54Z",
      "updated_at": "2024-04-30T14:15:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1584902362",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1584902362"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 4597,
      "original_line": 4597,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1585554972",
      "pull_request_review_id": 2032571316,
      "id": 1585554972,
      "node_id": "PRRC_kwDOABII585egaYc",
      "diff_hunk": "@@ -147,3 +147,21 @@ bool IsChildWithParentsTree(const Package& package)\n         return true;\n     });\n }\n+\n+uint256 GetPackageHash(const std::vector<CTransactionRef>& transactions)\n+{\n+    // Create a vector of the wtxids.\n+    std::vector<Wtxid> wtxids_copy;\n+    std::transform(transactions.cbegin(), transactions.cend(), std::back_inserter(wtxids_copy),\n+        [](const auto& tx){ return tx->GetWitnessHash(); });\n+\n+    // Sort in ascending order\n+    std::sort(wtxids_copy.begin(), wtxids_copy.end(), [](const auto& lhs, const auto& rhs) { return lhs.GetHex() < rhs.GetHex(); });",
      "path": "src/policy/packages.cpp",
      "position": 13,
      "original_position": 13,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "092c978a42e8f4a02291b994713505ba8aac8b28",
      "in_reply_to_id": null,
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In 092c978a42e8f4a02291b994713505ba8aac8b28 \"[txpackages] add canonical way to get hash of package\"\r\n\r\nIs there a reason to convert the wtxids into hex strings for this comparison? That seems kind of expensive, especially when `Wtxid` already has an `operator<`.\r\n\r\nI surmise that this has to do with the \"concatenated in lexicographical order (treating the wtxids as little endian encoded uint256, smallest to largest)\" and BIP 331 defines the same thing, but it's not clear to me why it must be like that (and couldn't also be changed in the BIP).\r\n\r\nIf this must be done in reverse byte order, then I think it would at be better to use `std::lexicographical_compare` with reverse iterators, rather than turning the wtxids into strings:\r\n\r\n```suggestion\r\n    std::sort(wtxids_copy.begin(), wtxids_copy.end(), [](const auto& lhs, const auto& rhs) { return std::lexicographical_compare(std::make_reverse_iterator(lhs.end()), std::make_reverse_iterator(lhs.begin()), std::make_reverse_iterator(rhs.end()), std::make_reverse_iterator(rhs.begin())); });\r\n```",
      "created_at": "2024-04-30T21:41:42Z",
      "updated_at": "2024-04-30T22:31:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1585554972",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1585554972"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 159,
      "original_line": 159,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1585612529",
      "pull_request_review_id": 2032696340,
      "id": 1585612529,
      "node_id": "PRRC_kwDOABII585egobx",
      "diff_hunk": "@@ -3097,7 +3133,14 @@ void PeerManagerImpl::ProcessInvalidTx(NodeId nodeid, const CTransactionRef& ptx\n         // See also comments in https://github.com/bitcoin/bitcoin/pull/18044#discussion_r443419034\n         // for concerns around weakening security of unupgraded nodes\n         // if we start doing this too early.\n-        m_recent_rejects.insert(ptx->GetWitnessHash().ToUint256());\n+        if (state.GetResult() == TxValidationResult::TX_RECONSIDERABLE) {\n+            // If the result is TX_RECONSIDERABLE, add it to m_recent_rejects_reconsiderable\n+            // because we should not download or submit this transaction by itself again, but may\n+            // submit it as part of a package later.\n+            m_recent_rejects_reconsiderable.insert(ptx->GetWitnessHash().ToUint256());",
      "path": "src/net_processing.cpp",
      "position": 140,
      "original_position": 94,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "6c51e1d7d021ed6523107a6db87a865aaa8fc4c9",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: I think that 6c51e1d7d021ed6523107a6db87a865aaa8fc4c9 changes behavior such that txns which are now in `m_recent_rejects_reconsiderable` instead of `m_recent_rejects` will be ignored when calling `m_recent_rejects.contains(...)`. That is probably an undesired change of behavior - however it's just for 1 commit :man_shrugging: ",
      "created_at": "2024-04-30T22:30:14Z",
      "updated_at": "2024-04-30T22:43:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1585612529",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1585612529"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 3179,
      "original_line": 3140,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1585614142",
      "pull_request_review_id": 2032696340,
      "id": 1585614142,
      "node_id": "PRRC_kwDOABII585ego0-",
      "diff_hunk": "@@ -241,3 +241,77 @@ void TxOrphanage::EraseForBlock(const CBlock& block)\n         LogPrint(BCLog::TXPACKAGES, \"Erased %d orphan tx included or conflicted by block\\n\", nErased);\n     }\n }\n+\n+std::vector<CTransactionRef> TxOrphanage::GetChildrenFromSamePeer(const CTransactionRef& parent, NodeId nodeid) const\n+{\n+    LOCK(m_mutex);\n+\n+    // First construct a vector of iterators to ensure we do not return duplicates of the same tx\n+    // and so we can sort by nTimeExpire.\n+    std::vector<OrphanMap::iterator> iters;\n+\n+    // For each output, get all entries spending this prevout, filtering for ones from the specified peer.\n+    for (unsigned int i = 0; i < parent->vout.size(); i++) {\n+        const auto it_by_prev = m_outpoint_to_orphan_it.find(COutPoint(parent->GetHash(), i));\n+        if (it_by_prev != m_outpoint_to_orphan_it.end()) {\n+            for (const auto& elem : it_by_prev->second) {\n+                if (elem->second.fromPeer == nodeid) {\n+                    iters.emplace_back(elem);\n+                }\n+            }\n+        }\n+    }\n+\n+    // Sort by address so that duplicates can be deleted. At the same time, sort so that more recent\n+    // orphans (which expire later) come first.  Break ties based on address, as nTimeExpire is\n+    // quantified in seconds and it is possible for orphans to have the same expiry.\n+    std::sort(iters.begin(), iters.end(), [](const auto& lhs, const auto& rhs) {\n+        if (lhs->second.nTimeExpire == rhs->second.nTimeExpire) {\n+            return &(*lhs) < &(*rhs);\n+        } else {\n+            return lhs->second.nTimeExpire > rhs->second.nTimeExpire;\n+        }\n+    });\n+    // Erase duplicates\n+    iters.erase(std::unique(iters.begin(), iters.end()), iters.end());\n+\n+    // Convert to a vector of CTransactionRef\n+    std::vector<CTransactionRef> children_found;\n+    children_found.reserve(iters.size());\n+    for (const auto child_iter : iters) {\n+        children_found.emplace_back(child_iter->second.tx);\n+    }\n+    return children_found;\n+}\n+\n+std::vector<std::pair<CTransactionRef, NodeId>> TxOrphanage::GetChildrenFromDifferentPeer(const CTransactionRef& parent, NodeId nodeid) const\n+{\n+    LOCK(m_mutex);\n+\n+    // First construct vector of iterators to ensure we do not return duplicates of the same tx.\n+    std::vector<OrphanMap::iterator> iters;\n+\n+    // For each output, get all entries spending this prevout, filtering for ones not from the specified peer.\n+    for (unsigned int i = 0; i < parent->vout.size(); i++) {\n+        const auto it_by_prev = m_outpoint_to_orphan_it.find(COutPoint(parent->GetHash(), i));\n+        if (it_by_prev != m_outpoint_to_orphan_it.end()) {\n+            for (const auto& elem : it_by_prev->second) {\n+                if (elem->second.fromPeer != nodeid) {\n+                    iters.emplace_back(elem);\n+                }\n+            }\n+        }\n+    }\n+\n+    // Erase duplicates\n+    std::sort(iters.begin(), iters.end(), IteratorComparator());\n+    iters.erase(std::unique(iters.begin(), iters.end()), iters.end());",
      "path": "src/txorphanage.cpp",
      "position": 68,
      "original_position": 68,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "2f51cd680fb4323f1c792dae37d4c4e0e0e35804",
      "in_reply_to_id": 1584890259,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I agree, would be nice to avoid this code duplication.",
      "created_at": "2024-04-30T22:32:44Z",
      "updated_at": "2024-04-30T22:43:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1585614142",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1585614142"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": 306,
      "original_start_line": 306,
      "start_side": "RIGHT",
      "line": 308,
      "original_line": 308,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1585616207",
      "pull_request_review_id": 2032711922,
      "id": 1585616207,
      "node_id": "PRRC_kwDOABII585egpVP",
      "diff_hunk": "@@ -241,3 +241,77 @@ void TxOrphanage::EraseForBlock(const CBlock& block)\n         LogPrint(BCLog::TXPACKAGES, \"Erased %d orphan tx included or conflicted by block\\n\", nErased);\n     }\n }\n+\n+std::vector<CTransactionRef> TxOrphanage::GetChildrenFromSamePeer(const CTransactionRef& parent, NodeId nodeid) const\n+{\n+    LOCK(m_mutex);\n+\n+    // First construct a vector of iterators to ensure we do not return duplicates of the same tx\n+    // and so we can sort by nTimeExpire.\n+    std::vector<OrphanMap::iterator> iters;\n+\n+    // For each output, get all entries spending this prevout, filtering for ones from the specified peer.\n+    for (unsigned int i = 0; i < parent->vout.size(); i++) {\n+        const auto it_by_prev = m_outpoint_to_orphan_it.find(COutPoint(parent->GetHash(), i));\n+        if (it_by_prev != m_outpoint_to_orphan_it.end()) {\n+            for (const auto& elem : it_by_prev->second) {\n+                if (elem->second.fromPeer == nodeid) {\n+                    iters.emplace_back(elem);\n+                }\n+            }\n+        }\n+    }\n+\n+    // Sort by address so that duplicates can be deleted. At the same time, sort so that more recent\n+    // orphans (which expire later) come first.  Break ties based on address, as nTimeExpire is\n+    // quantified in seconds and it is possible for orphans to have the same expiry.\n+    std::sort(iters.begin(), iters.end(), [](const auto& lhs, const auto& rhs) {\n+        if (lhs->second.nTimeExpire == rhs->second.nTimeExpire) {\n+            return &(*lhs) < &(*rhs);\n+        } else {\n+            return lhs->second.nTimeExpire > rhs->second.nTimeExpire;\n+        }\n+    });\n+    // Erase duplicates\n+    iters.erase(std::unique(iters.begin(), iters.end()), iters.end());\n+\n+    // Convert to a vector of CTransactionRef\n+    std::vector<CTransactionRef> children_found;\n+    children_found.reserve(iters.size());\n+    for (const auto child_iter : iters) {\n+        children_found.emplace_back(child_iter->second.tx);\n+    }\n+    return children_found;\n+}\n+\n+std::vector<std::pair<CTransactionRef, NodeId>> TxOrphanage::GetChildrenFromDifferentPeer(const CTransactionRef& parent, NodeId nodeid) const\n+{\n+    LOCK(m_mutex);\n+\n+    // First construct vector of iterators to ensure we do not return duplicates of the same tx.\n+    std::vector<OrphanMap::iterator> iters;\n+\n+    // For each output, get all entries spending this prevout, filtering for ones not from the specified peer.\n+    for (unsigned int i = 0; i < parent->vout.size(); i++) {\n+        const auto it_by_prev = m_outpoint_to_orphan_it.find(COutPoint(parent->GetHash(), i));\n+        if (it_by_prev != m_outpoint_to_orphan_it.end()) {\n+            for (const auto& elem : it_by_prev->second) {\n+                if (elem->second.fromPeer != nodeid) {\n+                    iters.emplace_back(elem);\n+                }\n+            }\n+        }\n+    }\n+\n+    // Erase duplicates\n+    std::sort(iters.begin(), iters.end(), IteratorComparator());\n+    iters.erase(std::unique(iters.begin(), iters.end()), iters.end());",
      "path": "src/txorphanage.cpp",
      "position": 68,
      "original_position": 68,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "2f51cd680fb4323f1c792dae37d4c4e0e0e35804",
      "in_reply_to_id": 1584890259,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "made a similar point at https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1571063644 fwiw (with a response attached)",
      "created_at": "2024-04-30T22:36:04Z",
      "updated_at": "2024-04-30T22:36:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1585616207",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1585616207"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": 306,
      "original_start_line": 306,
      "start_side": "RIGHT",
      "line": 308,
      "original_line": 308,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1585616821",
      "pull_request_review_id": 2032696340,
      "id": 1585616821,
      "node_id": "PRRC_kwDOABII585egpe1",
      "diff_hunk": "@@ -3198,6 +3237,117 @@ void PeerManagerImpl::ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, c\n     }\n }\n \n+void PeerManagerImpl::ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, const std::vector<NodeId>& senders)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    if (package_result.m_state.IsInvalid()) {\n+        m_recent_rejects_reconsiderable.insert(GetPackageHash(package));\n+    }\n+    // We currently only expect to process 1-parent-1-child packages. Remove if this changes.\n+    if (!Assume(package.size() == 2)) return;\n+\n+    // No package results to look through for PCKG_POLICY or PCKG_MEMPOOL_ERROR\n+    if (package_result.m_state.GetResult() == PackageValidationResult::PCKG_POLICY ||\n+        package_result.m_state.GetResult() == PackageValidationResult::PCKG_MEMPOOL_ERROR) return;",
      "path": "src/net_processing.cpp",
      "position": 174,
      "original_position": 64,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "87c5c524d63c833cf490c7f2f73d72695ad480df",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I wonder if there are situations in which we fail on a package level and therefore return here and never call `ProcessInvalidTx()` to remove the child from the orphanage. Would that be possible, for example, with v3 transactions that violate `PackageV3Checks()`, and is there something we could do against it? (or should, maybe it's not that terrible?).",
      "created_at": "2024-04-30T22:37:17Z",
      "updated_at": "2024-04-30T22:43:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1585616821",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1585616821"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 3254,
      "original_line": 3254,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1585991033",
      "pull_request_review_id": 2033190862,
      "id": 1585991033,
      "node_id": "PRRC_kwDOABII585eiE15",
      "diff_hunk": "@@ -241,3 +241,77 @@ void TxOrphanage::EraseForBlock(const CBlock& block)\n         LogPrint(BCLog::TXPACKAGES, \"Erased %d orphan tx included or conflicted by block\\n\", nErased);\n     }\n }\n+\n+std::vector<CTransactionRef> TxOrphanage::GetChildrenFromSamePeer(const CTransactionRef& parent, NodeId nodeid) const\n+{\n+    LOCK(m_mutex);\n+\n+    // First construct a vector of iterators to ensure we do not return duplicates of the same tx\n+    // and so we can sort by nTimeExpire.\n+    std::vector<OrphanMap::iterator> iters;\n+\n+    // For each output, get all entries spending this prevout, filtering for ones from the specified peer.\n+    for (unsigned int i = 0; i < parent->vout.size(); i++) {\n+        const auto it_by_prev = m_outpoint_to_orphan_it.find(COutPoint(parent->GetHash(), i));\n+        if (it_by_prev != m_outpoint_to_orphan_it.end()) {\n+            for (const auto& elem : it_by_prev->second) {\n+                if (elem->second.fromPeer == nodeid) {\n+                    iters.emplace_back(elem);\n+                }\n+            }\n+        }\n+    }\n+\n+    // Sort by address so that duplicates can be deleted. At the same time, sort so that more recent\n+    // orphans (which expire later) come first.  Break ties based on address, as nTimeExpire is\n+    // quantified in seconds and it is possible for orphans to have the same expiry.\n+    std::sort(iters.begin(), iters.end(), [](const auto& lhs, const auto& rhs) {\n+        if (lhs->second.nTimeExpire == rhs->second.nTimeExpire) {\n+            return &(*lhs) < &(*rhs);\n+        } else {\n+            return lhs->second.nTimeExpire > rhs->second.nTimeExpire;\n+        }\n+    });\n+    // Erase duplicates\n+    iters.erase(std::unique(iters.begin(), iters.end()), iters.end());\n+\n+    // Convert to a vector of CTransactionRef\n+    std::vector<CTransactionRef> children_found;\n+    children_found.reserve(iters.size());\n+    for (const auto child_iter : iters) {\n+        children_found.emplace_back(child_iter->second.tx);\n+    }\n+    return children_found;\n+}\n+\n+std::vector<std::pair<CTransactionRef, NodeId>> TxOrphanage::GetChildrenFromDifferentPeer(const CTransactionRef& parent, NodeId nodeid) const\n+{\n+    LOCK(m_mutex);\n+\n+    // First construct vector of iterators to ensure we do not return duplicates of the same tx.\n+    std::vector<OrphanMap::iterator> iters;\n+\n+    // For each output, get all entries spending this prevout, filtering for ones not from the specified peer.\n+    for (unsigned int i = 0; i < parent->vout.size(); i++) {\n+        const auto it_by_prev = m_outpoint_to_orphan_it.find(COutPoint(parent->GetHash(), i));\n+        if (it_by_prev != m_outpoint_to_orphan_it.end()) {\n+            for (const auto& elem : it_by_prev->second) {\n+                if (elem->second.fromPeer != nodeid) {\n+                    iters.emplace_back(elem);\n+                }\n+            }\n+        }\n+    }\n+\n+    // Erase duplicates\n+    std::sort(iters.begin(), iters.end(), IteratorComparator());\n+    iters.erase(std::unique(iters.begin(), iters.end()), iters.end());",
      "path": "src/txorphanage.cpp",
      "position": 68,
      "original_position": 68,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "2f51cd680fb4323f1c792dae37d4c4e0e0e35804",
      "in_reply_to_id": 1584890259,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> Why is this sort comparison different from the one in `GetChildrenFromSamePeer`?\r\n\r\nThe idea is to return `GetChildrenFromSamePeer` in recency order. This one could be returned that way as well, as the goal is to have a random order (and we randomize the indices), but all I wanted to do here was deduplicate.\r\n\r\n> These functions are almost identical as well.\r\n\r\nAs for the 2 functions having duplicate code, for a longer explanation: I'm hoping we can remove 1p1cs with different providers by tracking all orphan announcers, which would mean deleting `GetChildrenFromDifferentPeer`. I think it'll be easier to delete the function + unit tests wholesale if it's a different function. But it seems I'm in the minority here, and apologies for resolving the first comment about this. Will avoid this in the future.",
      "created_at": "2024-05-01T07:56:17Z",
      "updated_at": "2024-05-01T07:56:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1585991033",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1585991033"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": 306,
      "original_start_line": 306,
      "start_side": "RIGHT",
      "line": 308,
      "original_line": 308,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1586000826",
      "pull_request_review_id": 2033199492,
      "id": 1586000826,
      "node_id": "PRRC_kwDOABII585eiHO6",
      "diff_hunk": "@@ -147,3 +147,21 @@ bool IsChildWithParentsTree(const Package& package)\n         return true;\n     });\n }\n+\n+uint256 GetPackageHash(const std::vector<CTransactionRef>& transactions)\n+{\n+    // Create a vector of the wtxids.\n+    std::vector<Wtxid> wtxids_copy;\n+    std::transform(transactions.cbegin(), transactions.cend(), std::back_inserter(wtxids_copy),\n+        [](const auto& tx){ return tx->GetWitnessHash(); });\n+\n+    // Sort in ascending order\n+    std::sort(wtxids_copy.begin(), wtxids_copy.end(), [](const auto& lhs, const auto& rhs) { return lhs.GetHex() < rhs.GetHex(); });",
      "path": "src/policy/packages.cpp",
      "position": 13,
      "original_position": 13,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "092c978a42e8f4a02291b994713505ba8aac8b28",
      "in_reply_to_id": 1585554972,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> Is there a reason to convert the wtxids into hex strings for this comparison? That seems kind of expensive, especially when Wtxid already has an operator<.\r\n\r\n> I surmise that this has to do with the \"concatenated in lexicographical order (treating the wtxids as little endian encoded uint256, smallest to largest)\" and BIP 331 defines the same thing, but it's not clear to me why it must be like that (and couldn't also be changed in the BIP).\r\n\r\nThe code was originally using the operator< defined on `uint256`, and the opposite switch happened :sweat_smile: A few people commented on lexicographical being underspecified or different from how it's usually defined (e.g. https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1566025027). Mostly I felt like reverse byte order was much more intuitive, so I changed it here and in the BIP. Yes this doesn't have to match the BIP since it's only used internally, but I figured I might as well write something that's reusable.\r\n\r\nThanks for the `std::lexicographical_compare` suggestion, I'll add that in a followup.",
      "created_at": "2024-05-01T08:06:16Z",
      "updated_at": "2024-05-01T08:06:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1586000826",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1586000826"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 159,
      "original_line": 159,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1586034211",
      "pull_request_review_id": 2033245347,
      "id": 1586034211,
      "node_id": "PRRC_kwDOABII585eiPYj",
      "diff_hunk": "@@ -3198,6 +3237,117 @@ void PeerManagerImpl::ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, c\n     }\n }\n \n+void PeerManagerImpl::ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, const std::vector<NodeId>& senders)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    if (package_result.m_state.IsInvalid()) {\n+        m_recent_rejects_reconsiderable.insert(GetPackageHash(package));\n+    }\n+    // We currently only expect to process 1-parent-1-child packages. Remove if this changes.\n+    if (!Assume(package.size() == 2)) return;\n+\n+    // No package results to look through for PCKG_POLICY or PCKG_MEMPOOL_ERROR\n+    if (package_result.m_state.GetResult() == PackageValidationResult::PCKG_POLICY ||\n+        package_result.m_state.GetResult() == PackageValidationResult::PCKG_MEMPOOL_ERROR) return;",
      "path": "src/net_processing.cpp",
      "position": 174,
      "original_position": 64,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "87c5c524d63c833cf490c7f2f73d72695ad480df",
      "in_reply_to_id": 1585616821,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "`PCKG_POLICY` doesn't populate `m_tx_results` so we wouldn't have results for those transactions - it's meant for situations in which the package is invalid, but the individual transactions could be if submitted in a different context. However, going over the failures that are marked as `PCKG_POLICY`, I agree there's a few failures that are classified as `PCKG_POLICY` but are actually more definitively invalid, and we should bubble that up to p2p.\r\n\r\nHaving both mempool + package v3 parents, v2-spending-v3, and v3-spending-v2 are failures that can't change in another context, so we can delete the tx from orphanage.\r\n\r\nWe shouldn't do this for `package-mempool-limits` and `package-not-child-with-unconfirmed-parents`, since there could be a parent with a smaller witness that makes this child acceptable.\r\n\r\nThe 2 changes we'd make are:\r\n- update validation-side things to return a `MempoolAcceptResult` for the results where we should mark transactions as invalid. Perhaps we can reclassify these failures as `PCKG_TX` failures, or allow `PCKG_POLICY` failures to populate `m_tx_results`. cc @instagibbs ?\r\n- update the p2p logic here to continue when it's `PCKG_POLICY` and call `ProcessInvalidTx` for the `MempoolAcceptResult`s we find.",
      "created_at": "2024-05-01T08:48:23Z",
      "updated_at": "2024-05-01T08:48:23Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1586034211",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1586034211"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 3254,
      "original_line": 3254,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1586254555",
      "pull_request_review_id": 2033543952,
      "id": 1586254555,
      "node_id": "PRRC_kwDOABII585ejFLb",
      "diff_hunk": "@@ -3198,6 +3237,117 @@ void PeerManagerImpl::ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, c\n     }\n }\n \n+void PeerManagerImpl::ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, const std::vector<NodeId>& senders)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    if (package_result.m_state.IsInvalid()) {\n+        m_recent_rejects_reconsiderable.insert(GetPackageHash(package));\n+    }\n+    // We currently only expect to process 1-parent-1-child packages. Remove if this changes.\n+    if (!Assume(package.size() == 2)) return;\n+\n+    // No package results to look through for PCKG_POLICY or PCKG_MEMPOOL_ERROR\n+    if (package_result.m_state.GetResult() == PackageValidationResult::PCKG_POLICY ||\n+        package_result.m_state.GetResult() == PackageValidationResult::PCKG_MEMPOOL_ERROR) return;",
      "path": "src/net_processing.cpp",
      "position": 174,
      "original_position": 64,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "87c5c524d63c833cf490c7f2f73d72695ad480df",
      "in_reply_to_id": 1585616821,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> PCKG_POLICY doesn't populate m_tx_results so we wouldn't have results for those transactions\r\n\r\nFrom my reading of the code, `package-mempool-limits` populates `m_tx_results`? We also allow those cases in our fuzz target(which I'm guessing is there because I hit it!).\r\n\r\nWe could probably be more aggressive about filling out results when possible and passing those results along, sounds like future work for now?",
      "created_at": "2024-05-01T12:40:20Z",
      "updated_at": "2024-05-01T12:40:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1586254555",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1586254555"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 3254,
      "original_line": 3254,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1586256784",
      "pull_request_review_id": 2033547397,
      "id": 1586256784,
      "node_id": "PRRC_kwDOABII585ejFuQ",
      "diff_hunk": "@@ -147,3 +147,21 @@ bool IsChildWithParentsTree(const Package& package)\n         return true;\n     });\n }\n+\n+uint256 GetPackageHash(const std::vector<CTransactionRef>& transactions)\n+{\n+    // Create a vector of the wtxids.\n+    std::vector<Wtxid> wtxids_copy;\n+    std::transform(transactions.cbegin(), transactions.cend(), std::back_inserter(wtxids_copy),\n+        [](const auto& tx){ return tx->GetWitnessHash(); });\n+\n+    // Sort in ascending order\n+    std::sort(wtxids_copy.begin(), wtxids_copy.end(), [](const auto& lhs, const auto& rhs) { return lhs.GetHex() < rhs.GetHex(); });",
      "path": "src/policy/packages.cpp",
      "position": 13,
      "original_position": 13,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "092c978a42e8f4a02291b994713505ba8aac8b28",
      "in_reply_to_id": 1585554972,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done in #30012",
      "created_at": "2024-05-01T12:43:28Z",
      "updated_at": "2024-05-01T12:43:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1586256784",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1586256784"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 159,
      "original_line": 159,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1586256968",
      "pull_request_review_id": 2033547701,
      "id": 1586256968,
      "node_id": "PRRC_kwDOABII585ejFxI",
      "diff_hunk": "@@ -3198,6 +3237,117 @@ void PeerManagerImpl::ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, c\n     }\n }\n \n+void PeerManagerImpl::ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, const std::vector<NodeId>& senders)",
      "path": "src/net_processing.cpp",
      "position": 160,
      "original_position": 50,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "87c5c524d63c833cf490c7f2f73d72695ad480df",
      "in_reply_to_id": 1581036209,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done in #30012",
      "created_at": "2024-05-01T12:43:48Z",
      "updated_at": "2024-05-01T12:43:48Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1586256968",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1586256968"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 3240,
      "original_line": 3240,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1586257053",
      "pull_request_review_id": 2033547810,
      "id": 1586257053,
      "node_id": "PRRC_kwDOABII585ejFyd",
      "diff_hunk": "@@ -4354,7 +4354,9 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         const TxValidationState& state = result.m_state;\n \n         if (result.m_result_type == MempoolAcceptResult::ResultType::VALID) {\n-            ProcessValidTx(pfrom.GetId(), ptx, result.m_replaced_transactions.value());\n+            Assume(result.m_replaced_transactions.has_value());",
      "path": "src/net_processing.cpp",
      "position": 318,
      "original_position": 5,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "6f4da19cc3b1b7cd23cb4be95a6bb9acb79eb3bf",
      "in_reply_to_id": 1568781077,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done in #30012",
      "created_at": "2024-05-01T12:43:56Z",
      "updated_at": "2024-05-01T12:43:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1586257053",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1586257053"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 4566,
      "original_line": 4357,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1586258730",
      "pull_request_review_id": 2033550395,
      "id": 1586258730,
      "node_id": "PRRC_kwDOABII585ejGMq",
      "diff_hunk": "@@ -3198,6 +3237,117 @@ void PeerManagerImpl::ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, c\n     }\n }\n \n+void PeerManagerImpl::ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, const std::vector<NodeId>& senders)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    if (package_result.m_state.IsInvalid()) {\n+        m_recent_rejects_reconsiderable.insert(GetPackageHash(package));\n+    }\n+    // We currently only expect to process 1-parent-1-child packages. Remove if this changes.\n+    if (!Assume(package.size() == 2)) return;\n+\n+    // No package results to look through for PCKG_POLICY or PCKG_MEMPOOL_ERROR\n+    if (package_result.m_state.GetResult() == PackageValidationResult::PCKG_POLICY ||\n+        package_result.m_state.GetResult() == PackageValidationResult::PCKG_MEMPOOL_ERROR) return;",
      "path": "src/net_processing.cpp",
      "position": 174,
      "original_position": 64,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "87c5c524d63c833cf490c7f2f73d72695ad480df",
      "in_reply_to_id": 1585616821,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Then maybe we should just do this?\r\n\r\n> Update the p2p logic here to continue when it's PCKG_POLICY and call ProcessInvalidTx for the MempoolAcceptResults we find.\r\n\r\n(and remove the `Assume` that they always exist)",
      "created_at": "2024-05-01T12:46:31Z",
      "updated_at": "2024-05-01T12:46:31Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1586258730",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1586258730"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 3254,
      "original_line": 3254,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1586354156",
      "pull_request_review_id": 2033722303,
      "id": 1586354156,
      "node_id": "PRRC_kwDOABII585ejdfs",
      "diff_hunk": "@@ -3198,6 +3237,117 @@ void PeerManagerImpl::ProcessValidTx(NodeId nodeid, const CTransactionRef& tx, c\n     }\n }\n \n+void PeerManagerImpl::ProcessPackageResult(const Package& package, const PackageMempoolAcceptResult& package_result, const std::vector<NodeId>& senders)\n+{\n+    AssertLockNotHeld(m_peer_mutex);\n+    AssertLockHeld(g_msgproc_mutex);\n+    AssertLockHeld(cs_main);\n+\n+    if (package_result.m_state.IsInvalid()) {\n+        m_recent_rejects_reconsiderable.insert(GetPackageHash(package));\n+    }\n+    // We currently only expect to process 1-parent-1-child packages. Remove if this changes.\n+    if (!Assume(package.size() == 2)) return;\n+\n+    // No package results to look through for PCKG_POLICY or PCKG_MEMPOOL_ERROR\n+    if (package_result.m_state.GetResult() == PackageValidationResult::PCKG_POLICY ||\n+        package_result.m_state.GetResult() == PackageValidationResult::PCKG_MEMPOOL_ERROR) return;",
      "path": "src/net_processing.cpp",
      "position": 174,
      "original_position": 64,
      "commit_id": "e518a8bf8abf3d7b83c9013f56d0dca18ae04d6f",
      "original_commit_id": "87c5c524d63c833cf490c7f2f73d72695ad480df",
      "in_reply_to_id": 1585616821,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "^I added this to #30012",
      "created_at": "2024-05-01T14:24:40Z",
      "updated_at": "2024-05-01T14:24:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/28970#discussion_r1586354156",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1586354156"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28970"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 3254,
      "original_line": 3254,
      "side": "RIGHT"
    }
  ]
}