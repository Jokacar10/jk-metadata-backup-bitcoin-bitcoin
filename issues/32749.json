{
  "type": "issue",
  "issue": {
    "id": 3146119702,
    "node_id": "I_kwDOABII5867hfoW",
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32749",
    "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
    "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32749/labels%7B/name%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32749/comments",
    "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32749/events",
    "html_url": "https://github.com/bitcoin/bitcoin/issues/32749",
    "number": 32749,
    "state": "closed",
    "state_reason": "completed",
    "title": "A cryptographic model based on modular inverse and non -colloisive properties",
    "body": "Author: Pedro Henrique Marques\n\n1. Introduction\n2. \nThis document has an original cryptographic model that explores modular inverse properties and circular dependencies, aiming to provide a highly resistant hash mechanism for collisions and inversion, even in the face of known quantum attacks.\n\nThe model was conceived as a resistant alternative to quantum brute strength techniques and factoring algorithms, being ideal for applications such as VDF, proof-o-work and high safety blockchains.\n\n2. Definition of the model\n\n2.1 Parameters\nChoose an integer such that 100 ≤ a ≤ 2²⁵⁶.\nA prime number p = 2^770+ 63 is defined, which satisfies p> 4 · a³ for any possible a. This property is essential to prevent collisions in the exit hashes as we will see later.\n\n2.2 Calculation of the modular reverse\nThe modular reverse of A mod p is calculated, ie it is x such that: a · x-p · k = 1, for some k ∈ ℤ. Note that MDC (A, K) = 1.\n\n2.3 Definition of W and M\nThe smallest positive integer w is defined such that: a · w> p.\nThen it defines: m = a · w + k, with k = (a · x - 1) / p. Since A · W is a multiple of A and MDC (A, K) = 1, we have MDC (A, M) = 1, which means the modular inverse of A mod m.\n\n2.4 Calculation of the output hash\nThe inverse modular is calculated i such that: a · i - t · m = 1, for some t ∈ ℤ.\nThe last step consists of calculating: f = part_inteira (i ÷ 2²⁵⁶).\nThe value F is defined as the model output hash, with size between 257 and 514 bits.\n\n2.5 Step by Step Algorithm\n1️⃣ Choose A ∈ [100, 2²⁵⁶].\n2️⃣ Define P = 2^770 + 63.\n3️⃣ Calculate x = a⁻¹ Mod p.\n4️⃣ determine w such that a · w> p.\n5️⃣ Calculate m = a · w + k, with k = (a · x - 1) / p.\n6️⃣ Calculate i = a⁻¹ mod m.\n7️⃣ Calculate F = part_inteira (i ÷ 2²⁵⁶).\n8️⃣ Return F as exit hash.\n3. Security analysis\n\n3.1 Irreversibility\n\nThe irreversibility of the model, including for quantum algorithms, stems from the enormous difficulty in manipulating several variables, each based on a different function, and any attempt at reversal leads to circular dependencies.\n\nFor starters, the final division of the reverse I by 2^256 is equivalent to deleting 256 bits of information, which would be crucial to start working on a reversal algorithm. Without a safe method to recover the lost 256 bits, thinking of a mathematical approach that does not involve brute strength begins to prove very problematic.\nBut even if we had these 256 bits, thinking of a way to reverse the algorithm is still a very problematic task, bordering on the impossible with the tools we have today.\n\nI is the modular converse of mod m. A is the input hash we want to find out. But for that, we need to know the value of m, which is hidden in the calculation. M = AW+K, being the smallest positive integer that satisfies AW> P, and k = (ax-1)/p, being x the modular converse of mod p. P and I (if we could recover the 256 bits lost in the final division) are the only known values. If m were known, the inversion operation would be trivial. But as M is not known, our algorithm reversal problems begin.\n\nW is the smallest positive integer that satisfies AW> p. If we had the value of A, it would be trivial to calculate w. But it is precisely who we want to find. W is a ceiling function, which is quite chaotic. At times, AW = P+1. In others, AW = P+2^127+1. There is no simple way to estimate the value of AW, which would be very useful for reversing the calculation.\n\nIn the case of k, it is the p coefficient in the expression Ax-kp = 1, which means that k = (ax-1)/p. Eliminating K is easy, replacing with this last expression. But this adds x to the equation, which is the modular converse of mod p. What would be an effective method of recovering x in calculating the modular converse of mod m?\nBut the problems don't stop there. There is also one last variable. If i is the modular converse of mod m, then there is a T that satisfies ai-tm = 1. The problems to estimate the value of T are the same to estimate the values ​​of W, K, X and M.\n\nThis eliminates any possibility of algebraic reversal of this model, because we have W, which is the result of a ceiling function; X, which is a modular reverse; k, which is the coefficient resulting from the modular inverse of X; m, which depends on A, W and K; and t, which is the coefficient resulting from the calculation of i.\n\nIf there is no possibility of algebraic reversal, we have to appeal to more sophisticated reversal methods of this algorithm, such as quantum algorithms. But with the knowledge that we have today, is there a possibility that, in the near future, quantum algorithms can be able to break such a model? This is what we will discuss from now on.\n\n3.2 Resistance to Quantum Attacks\n\n3.2.1 Shor Algorithm\n\nWhen we talk about quantum attacks on cryptographic models, the first attack that comes to mind is Shor's algorithm, which has proven to be a real threat to several models widely used today. But would this algorithm be useful for breaking the current model? And the answer is no.\n\nShor's algorithm, used for factorization and discrete logarithms, is not applicable, since the model does not depend on integer factorization. There is nothing to factorize, since the number p is already a prime number, and the output hash f is a truncated version of the inverse I, which also has nothing to be factorized. Therefore, the best-known quantum breaking algorithm for cryptographic models finds natural immunity in the case of this model.\n\n3.2.2 Grover's Algorithm\nGrover's algorithm speeds up the brute-force search from 2²⁵⁶ to 2¹²⁸, decreasing the security of the models quadratically and facilitating the use of brute force. Still, 2¹²⁸ is impractical for computational attacks in any current or anticipated scenario.\n\n3.2.3 Other Potential Quantum Attacks\nLLL is an algorithm that reduces a lattice basis to a shorter, nearly orthogonal basis. It is used to attack problems that can be expressed as finding small solutions to systems of congruences or rational approximations.\nPotential application:\nIf it were possible to express the equations of the model as a system of congruences over linear variables (e.g., expressing i, m, k, x, w as vectors in a linear space with modular constraints), LLL could be applied to try to recover a.\nWhy it doesn't apply well here:\nThe problem is that m depends on a·w + k, and w depends on a ceiling function based on a.\nTherefore, the relations are not practically linearizable — it is not possible to express the system as a stable lattice basis for which LLL is effective.\n\n▶️ CVP (Closest Vector Problem)\nGiven a lattice and a target vector, the problem is to find the closest vector in the lattice. CVP-based techniques are used, for example, in attacks against partial-key cryptography or modular inverse approximations.\nWhy it doesn't apply well here:\nTo use CVP, it would be necessary to have an explicit lattice over the variables. But since m is not known (it is hidden and dependent on a and w), it is not possible to assemble the target vector or the basis of the lattice.\nIn addition, the equations of the system are not linear.\n\n▶️ SVP (Shortest Vector Problem)\nSVP searches for the vector with the smallest norm in a lattice. It is fundamental in breaking lattice-based cryptography (LWE, NTRU). It can also be attempted in modular systems if it is possible to \"linearize\" the system.\nWhy it doesn't apply here:\nSame reason as CVP — since m is dependent on hidden, nonlinear functions, the vector space needed to form the lattice is not available.\n\n▶️ Coppersmith techniques\nCoppersmith searches for small roots of polynomials mod n. The model system does not generate a univariate polynomial with small roots or a known modulus n. The modulus m is hidden and dependent on a and w, blocking this class of attacks.\n\n▶️ Machine learning/differential analysis-based techniques\nCoppersmith's method searches for small roots of polynomials mod n, and is used in attacks such as \"partial key exposure\" or \"low exponent RSA\". It can attack modular equations if the structure of the polynomial allows it.\nWhy it doesn't apply:\n\nThe model equations do not form a univariate polynomial with small roots over known modulus.\nIn addition, the modulus m is not known, and the equations are highly nonlinear and involve ceiling functions.\n\nSummary: The main known quantum and post-quantum attacks (LLL, CVP, SVP, Coppersmith, and machine learning techniques) do not apply effectively to the present model, due to the absence of a linearizable system, dynamic and hidden module (m), circular dependencies between variables, and the absence of an exploitable gradient or differential.\n\nBreaking this model depends on the emergence of new areas of mathematics that explore the functions involved (modular inverse, ceiling, among others). With the tools we have today, trying to reverse the algorithm leads to circular dependencies in various forms.\n\nWe can eliminate the variable k, but that only leaves us having to deal with the variable x. To eliminate the variable w, we could use the relation p<aw<p+a. But that only leads us to a brute force approach in an even more gigantic range. Finally, the variable t, which appears in the expression ai-tm=1, seems to be the most problematic of all, since it depends on a (which is what we want to find), m (which depends on the variables w and k) and I (which we only know partially, since 256 bits were lost). It also depends on some innovation that, if it occurred, would be incredible, capable of recovering the 256 bits lost in the final process. The bijective relation between a and f exists, as has already been proven. Therefore, if there is a path that starts from a and ends at f, the reverse path must exists, how to do this with such a large amount of missing information is a really considerable challenge.\n4. \n5. Absence of Collisions\n\nOne of the most relevant attack vectors against cryptographic constructions based on hash functions is the collision attack, which aims to find two distinct inputs that generate the same output of the target function. This principle is based on the birthday paradox, according to which, for a function with nnn-bit outputs, it does not take 2n2^n2n attempts to obtain a collision, but rather approximately 2n/22^{n/2}2n/2 attempts. This phenomenon underlies classical collision attacks. In the quantum context, this attack is considerably accelerated by the Brassard-Høyer-Tapp (BHT) algorithm, developed in 1997. This algorithm exploits the properties of superposition and quantum interference to reduce the complexity of the collision search to O(2n/3)O(2^{n/3})O(2n/3), thus providing an exponential gain over the classical attack.\n\nThe operation of the BHT algorithm, at a high level, consists of preparing a quantum superposition over the input space, followed by the application of reflection operators that amplify the amplitudes of the states that lead to collisions, in a process analogous to Grover amplification. After an adequate number of iterations, the system is measured, with a high probability of obtaining a collision.\n\nAs a result, any cryptographic scheme that depends on collision resistance or that reduces its security to this type of problem becomes vulnerable in the quantum scenario. Constructions based on conventional hash functions, symmetric compressions, or problems that can be modeled as collision searches are subject to this type of attack.\nOn the other hand, if a cryptographic model does not structurally depend on collision resistance — either because it has an intrinsically non-collapsible preimage space or because it adopts mathematical problems of a different nature —, the BHT algorithm does not apply directly.\n\nFor this reason, a comprehensive quantum security analysis must always consider the applicability of collision-based attacks and the structural resistance of the proposed model against this vector.\n\nIn the following topics, I explain in detail why this model does not have collisions and, therefore, has natural immunity against approaches of this type.\n\n4.1 Collisions in i\n\nWe want to prove that there are no two distinct values ​​a₁ ≠ a₂ that result in the same i.\n\nWe know that: a·i - t·m = 1, which implies that:\n\n(1) i = (t·m + 1) / a\n\nTo prove that collisions are impossible, let's assume that there was a collision. From definition 1, the hypothesis leads us to this equality:\n\n(2) (t₁·m₁ + 1) / a₁ = (t₂·m₂ + 1) / a₂\n\nMultiplying both sides in a cross-wise fashion:\n\n(3) t₁·m₁·a₂ + a₂ = t₂·m₂·a₁ + a₁\n\nRearranging:\n\n(4) t₁·m₁·a₂ - t₂·m₂·a₁ = a₁ - a₂\n\nWe define m₁ = m₂ + d, then substituting into the expression:\n\n(5) t₁·(m₂ + d)·a₂ - t₂·m₂·a₁ = a₁ - a₂\n\nExpanding:\n\n(6) t₁·m₂·a₂ + t₁·d·a₂ - t₂·m₂·a₁ = a₁ - a₂\n\nRearranging again:\n\n(7) t₁·m₂·a₂ - t₂·m₂·a₁ = a₁ - a₂ - t₁·d·a₂\n\nPutting m₂ in evidence:\n\n(8) m₂·(t₁·a₂ - t₂·a₁) = a₁ - a₂ - t₁·d·a₂\n\nThis last expression shows a fundamental condition for the collision to be possible. What we will do is show that such equality is impossible, proving that there are no collisions between values ​​of i.\n\n- Left side: m₂·(t₁·a₂ - t₂·a₁). The smallest possible difference of (t₁·a₂ - t₂·a₁) is 1, therefore this side is ≥ m₂.\n- We know that m = a·w + k and a·w > p, therefore m > p. Therefore, the left side of the equality > p, for all p.\n\n- Right side: a₁ - a₂ - t₁·d·a₂.\n\nIn our argument, the difference a₁ - a₂ will be disregarded by the arguments that we will present below. We are only interested in the term t₁·d·a₂. - t₁ ≤ a - 1 (since a·i - t·m = 1 and i < m. Assuming that some t is greater than or equal to a would make equality impossible).\n- d ≤ 2·a – 4 (this is because m=aw+k. We know that aw>p, but aw<p+a. In other words, aw is between p+1 and p+a-1. Furthermore, k<a by the same argument applicable to the variable t (k appears in the expression ax-kp=1). Therefore, k assumes values ​​between 1 and a-1. Therefore, the possible values ​​for m revolve around p+2 and p+2a-2, which gives us the greatest possible difference between distinct m’s). - Therefore, t₁·d·a₂ ≤ (a - 1)(2·a - 4)·a = 2·a³ - 6·a² + 4·a < 2·a³.\n\nEven if we want to consider the difference a₁ - a₂, the term - 6·a² is more than enough to compensate for this difference.\n\nConclusion:\n\nFor the equality to be satisfied, knowing that the left side is strictly greater than p, and the right side is strictly less than 2·a³, we would need:\n\n(9) p < 2·a³\n\nBut this is false, since p = 2^770 + 63 and the largest possible a is 2²⁵⁶. The prime p was chosen on purpose to make the equality impossible.\n\nTherefore, the equality cannot occur, and therefore **there are no collisions in i**.\n\n\n4.2 Collisions in f\nWe have proven that there are no collisions in i. However, the algorithm predicts the division of I by 2²⁵⁶, considering only the integer part, which gives us the final hash f. Could there be collisions in f because of this last procedure?\n\nTo answer this question, we analyze whether distinct values ​​of i could generate the same output f after division by 2²⁵⁶.\n\nWe know that:\nai-tm=1, i=(tm+1)/a\nm>p>4a^3\nLet's estimate the difference between two distinct I's. We know that this difference will never be zero by the argumentation already posted previously. But we want to know what is the global minimum for Δi = i₁ - i₂. Δi = [ t₁·m₁·a₂ - t₂·m₂·a₁ + a₁- a₂) ] / (a₁·a₂)\nWe define m₁ = m₂ + d\nΔi = [ t₁·( m₂ + d) ·a₂ - t₂·m₂·a₁ + a₁- a₂) ] / (a₁·a₂)\nΔi = [ m₂·( t₁ a₂- t₂a₁) + a₁- a₂+ t₁.d. a₂) ] / (a₁·a₂)\n\nWe already know that m₂·( t₁ a₂- t₂a₁) is strictly greater than p, which is greater than 4a^3, while a₁- a₂+ t₁.d. a₂ is strictly less than 2a^3 (a=2256). Therefore, the numerator of this last equality is strictly greater than 4a^3-2a^3=2a^3.\nThe denominator a₁·a₂ is strictly less than a^2.\nTherefore, the difference Δi will always be strictly less than 2a^3/a^2=2a. In other words, the distance between two distinct I's will never be less than 2a, which means that if you divide I by a and ignore the decimal part, which is the calculation that returns f, the distance between distinct f's will still always be greater than 2, which proves that there are no collisions between f's either.\n\n5. Applications and Limitations\n5.1 Applications\nThis model is recommended for:\n✅ Verifiable Delay Protocols (VDF).\n✅ Brute-force resistant encryption.\n✅ Alternative Proof-of-Work algorithms.\n✅ Creation of Keyless Signatures.\n✅ Applications in blockchains and distributed systems with quantum resistance requirements.\n5.2 Limitations\n✅ The current implementation is computationally slow compared to models such as SHA256.\n✅ Not recommended for massive data hashing.\n✅ Best suited for selective and time-controlled applications.\n6. Conclusion\nThe proposed model presents high resistance to inversion and proven absence of collisions. The circular dependencies and dynamic design make it resistant to both classical and quantum attacks.\nFuture work will include formal benchmarks, statistical analysis of the output distribution, detailed study of the model's entropy, and possible algorithmic optimizations.",
    "user": {
      "login": "phmarx",
      "id": 50559628,
      "node_id": "MDQ6VXNlcjUwNTU5NjI4",
      "avatar_url": "https://avatars.githubusercontent.com/u/50559628?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/phmarx",
      "html_url": "https://github.com/phmarx",
      "followers_url": "https://api.github.com/users/phmarx/followers",
      "following_url": "https://api.github.com/users/phmarx/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/phmarx/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/phmarx/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/phmarx/subscriptions",
      "organizations_url": "https://api.github.com/users/phmarx/orgs",
      "repos_url": "https://api.github.com/users/phmarx/repos",
      "events_url": "https://api.github.com/users/phmarx/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/phmarx/received_events",
      "type": "User",
      "site_admin": false,
      "patch_url": null
    },
    "labels": [],
    "assignees": [],
    "author_association": "NONE",
    "locked": false,
    "comments": 1,
    "closed_at": "2025-06-14T13:02:14Z",
    "closed_by": {
      "login": "pinheadmz",
      "id": 2084648,
      "node_id": "MDQ6VXNlcjIwODQ2NDg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pinheadmz",
      "html_url": "https://github.com/pinheadmz",
      "followers_url": "https://api.github.com/users/pinheadmz/followers",
      "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
      "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
      "repos_url": "https://api.github.com/users/pinheadmz/repos",
      "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
      "type": "User",
      "site_admin": false,
      "patch_url": null
    },
    "created_at": "2025-06-14T12:48:11Z",
    "updated_at": "2025-06-14T13:02:55Z"
  },
  "events": [
    {
      "event": "closed",
      "id": 18149220650,
      "node_id": "CE_lADOABII5867hfoWzwAAAAQ5xyEq",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/18149220650",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-14T13:02:14Z"
    },
    {
      "event": "commented",
      "id": 2972753291,
      "node_id": "IC_kwDOABII586xMJ2L",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2972753291",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-06-14T13:02:54Z",
      "updated_at": "2025-06-14T13:02:54Z",
      "author_association": "MEMBER",
      "body": "This post belongs on the bitcoindev mailing list or delving bitcoin, not the bitcoin core software issue tracker",
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/issues/32749#issuecomment-2972753291",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32749"
    }
  ]
}