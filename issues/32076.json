{
  "type": "issue",
  "issue": {
    "id": 2922080241,
    "node_id": "I_kwDOABII586uK2fx",
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32076",
    "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
    "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32076/labels%7B/name%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32076/comments",
    "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/32076/events",
    "html_url": "https://github.com/bitcoin/bitcoin/issues/32076",
    "number": 32076,
    "state": "open",
    "state_reason": null,
    "title": "Feature Request: Forking Bitcoin for Native gRPC/dRPC Integration",
    "body": "### Please describe the feature you'd like to see added.\n\nSo I noticed on mintscan that we have bitcoin API, but... we don't have gRPC/dRPC hooking in bitcore,  which is causing a lot of wacky stuff to occur on Coinbase. \n\nThen again, if we're going to introduce this feature we to be careful of this following bug vulnerability \n\ninterface ProviderRpcError {\n  message: string;\n  code: number;\n  data?: { method?: string };\n  stack?: string;\n}\n\nBecause we all know what that does. Coinbase, the cryptocurrency exchange, announced a security bug in their API that would have allowed an attacker to take over user accounts. Coinbase halted all trading and withdrawals while they investigated the issue. The bug has since been fixed, and Coinbase has resumed trading. I mean, I'm grateful that bitcore has deprecated the private key generation function for a legac wallet, becausr if you combine that RPC error within the API with bitcore's... unique console commands, well, let's just say you get more than a misconfigured graph going the opposite direction, while your  crypto wallet is showing the inverse of the graph (my friend James told me about this issue with his crypto and... it's jarring, I hope to God y'all didn't put an AI model without persistent stateful memory like I ahve been telling you all to do time and time again... \n\nSo yeah, there are going to be hurdles with this developing this feature, yes I deserve to get paid for bringing this problem up because I will be the one coming to a solution with dRPC.org so that interchain.io has a better bitcoin cryptocurrency that isn't as easily hackable. \n\nBecause you all realize that's why bitcoin is going down? I mean sure, there's the political drama and bullshit, but it's because the network is not secure in the trenches, in those data mines. \n\n\n@coderabbitai can you provide some solutions for us?\n\n\n....\nfor now, this is our proposal and we will provide code examples of current vulnerabilities still found via RPC hooking in coinbase that have not been addressed\n\n1. Introduction\nObjective\nFork the Bitcoin Core repository to add a native gRPC (or dRPC) interface to bitcoind, enabling direct streaming and RPC calls without relying solely on JSON-RPC proxies or wrappers.\nWhy gRPC or dRPC?\nModern Capabilities\n\ngRPC offers bidirectional streaming, a standardized protocol buffer (protobuf) approach, and improved performance compared to REST/JSON-RPC in many cases.\nMulti-Chain Interoperability\n\nMany Cosmos-based chains expose gRPC endpoints, making Bitcoin a “special case” on cross-chain platforms like Mintscan or interchain.io. Currently, Mintscan/interchain.io only have a limited HTTP “API” for Bitcoin and no standard RPC, introducing unnecessary complexity and potential security gaps.\nFuture Alignment with Bitcore\n\nTools like Bitcore (JavaScript/TypeScript with optional C/C++ bindings) integrate more smoothly when there is a native gRPC or dRPC server available, reducing friction for multi-chain solutions.\nImpact on Bitcoin’s Price\n\nAlthough external factors (political, economic) influence Bitcoin’s valuation, technical weaknesses—such as lacking robust cross-chain interfaces—can erode confidence and adoption. This perceived security and integration gap can contribute to negative market sentiment. The downward pressure on Bitcoin’s price has been partly attributed to concerns over network security “in the trenches,” especially as institutional and retail users demand more reliable, modern tools.\nCosmos SDK Roadblocks\n\nThe Cosmos SDK team has historically been protective of its own ecosystem, causing difficulties for third-party or cross-chain solutions (particularly around interchain queries). Julien’s involvement (cited in multiple issue threads) has introduced major bugs or blocked proposals aimed at bridging Bitcoin more seamlessly into the Cosmos ecosystem. This friction exacerbates multi-chain fragmentation, impacting both Bitcoin and Cosmos-based projects.\n2. Repository Structure and File Changes\n2.1 New Files\nCreate three new core files in src/grpc/:\n\ngRPC.h – The header file defining your main gRPC server class and public methods.\ngRPC.c – (Optional) C-based scaffolding if bridging with lower-level libraries or external dependencies.\ngRPC.cpp – The main implementation of your gRPC server logic, method stubs, and request handlers.\ncss\nCopy\nEdit\nbitcoin/\n  ├─ src/\n  │   ├─ grpc/\n  │   │   ├─ gRPC.h\n  │   │   ├─ gRPC.cpp\n  │   │   └─ gRPC.c\n  │   ├─ rpc/  # Existing JSON-RPC logic\n  │   └─ ... other Bitcoin Core files\n  └─ ... rest of repo\n2.2 Protobuf Definitions\nPlace your .proto files (e.g., bitcoin_service.proto, messages.proto) in a directory such as proto/:\n\nplaintext\nCopy\nEdit\nproto/\n  bitcoin_service.proto\n  messages.proto\nAn example bitcoin_service.proto:\n\nprotobuf\nCopy\nEdit\nsyntax = \"proto3\";\n\npackage bitcoin;\n\n// Basic gRPC service for Bitcoin\nservice BitcoinRPC {\n  // Get the current block height\n  rpc GetBlockHeight (EmptyRequest) returns (BlockHeightResponse);\n\n  // Get the balance for a given address\n  rpc GetBalance (BalanceRequest) returns (BalanceResponse);\n}\n\nmessage EmptyRequest {}\nmessage BlockHeightResponse { int64 height = 1; }\nmessage BalanceRequest { string address = 1; }\nmessage BalanceResponse { double balance = 1; }\n3. Implementation Outline\n3.1 gRPC Dependencies\nAdd gRPC and Protocol Buffers to your depends/ folder or build system.\nUpdate configure.ac or CMakeLists.txt to detect and link against gRPC.\nOptionally introduce a build flag (e.g., --enable-grpc).\n3.2 gRPC.h — Header Example\ncpp\nCopy\nEdit\n#ifndef BITCOIN_GRPC_H\n#define BITCOIN_GRPC_H\n\n#include <memory>\n#include <string>\n\nnamespace grpc {\n    class Server;\n    class Service;\n    class ServerBuilder;\n}\n\nclass BitcoinGrpcServer {\npublic:\n    BitcoinGrpcServer(const std::string& server_address);\n    ~BitcoinGrpcServer();\n\n    // Start and stop the server\n    void Start();\n    void Shutdown();\n\nprivate:\n    std::unique_ptr<grpc::ServerBuilder> builder;\n    std::unique_ptr<grpc::Server> server;\n\n    // e.g., std::unique_ptr<BitcoinServiceImpl> service;\n};\n\n#endif // BITCOIN_GRPC_H\n3.3 gRPC.cpp — Implementation Example\ncpp\nCopy\nEdit\n#include \"gRPC.h\"\n#include <grpcpp/grpcpp.h>\n// #include \"bitcoin_service.grpc.pb.h\" // generated from your .proto\n\n// Example stub for the gRPC service\nclass BitcoinServiceImpl final /* : public bitcoin::BitcoinRPC::Service */ {\npublic:\n    /*\n    // e.g., Implementation of GetBlockHeight\n    grpc::Status GetBlockHeight(\n        grpc::ServerContext* context,\n        const bitcoin::EmptyRequest* request,\n        bitcoin::BlockHeightResponse* response\n    ) override {\n        int64_t height = GetActiveChainHeight();\n        response->set_height(height);\n        return grpc::Status::OK;\n    }\n    */\n};\n\nBitcoinGrpcServer::BitcoinGrpcServer(const std::string& server_address) {\n    builder = std::make_unique<grpc::ServerBuilder>();\n    builder->AddListeningPort(server_address, grpc::InsecureServerCredentials());\n\n    // auto service = std::make_unique<BitcoinServiceImpl>();\n    // builder->RegisterService(service.get());\n\n    server = builder->BuildAndStart();\n}\n\nBitcoinGrpcServer::~BitcoinGrpcServer() {\n    if (server) {\n        server->Shutdown();\n    }\n}\n\nvoid BitcoinGrpcServer::Start() {\n    if (server) {\n        // Typically run in a separate thread; demonstration uses a blocking Wait()\n        server->Wait();\n    }\n}\n\nvoid BitcoinGrpcServer::Shutdown() {\n    if (server) {\n        server->Shutdown();\n    }\n}\n3.4 gRPC.c — C Fallback or Bridge Example\nc\nCopy\nEdit\n#include \"gRPC.h\"\n#include <stdio.h>\n\nvoid initialize_grpc_module() {\n    printf(\"Initializing gRPC module...\\n\");\n    // Specialized C logic or bridging if needed\n}\n4. Bitcore Alignment\nNode.js Native Addons: Bitcore-based apps (JavaScript/TypeScript) can load your C/C++ gRPC server via native addons.\nJSON-like I/O: Although gRPC uses protobuf, you can create helper utilities to convert requests/responses to JSON for existing Bitcore workflows.\nPerformance Focus: Keep bridging overhead minimal so gRPC’s speed advantage is preserved.\n5. Integration with Bitcoin Core\nFork the Repo\n\nCreate a new branch, e.g., feature/grpc-integration.\nAdd Build Options\n\nIn configure.ac or CMakeLists.txt, insert logic to detect gRPC libraries:\nbash\nCopy\nEdit\n./configure --enable-grpc\nConditional Compilation\n\nWrap gRPC code with #ifdef ENABLE_GRPC to make it optional.\nInitialization (init.cpp)\n\ncpp\nCopy\nEdit\n#ifdef ENABLE_GRPC\n#include \"gRPC.h\"\n\nstatic std::unique_ptr<BitcoinGrpcServer> g_grpcServer;\n\nbool AppInitServers(...) {\n    if (gArgs.GetBoolArg(\"-grpcenabled\", false)) {\n        g_grpcServer = std::make_unique<BitcoinGrpcServer>(\"0.0.0.0:50051\");\n        g_grpcServer->Start();\n    }\n    ...\n}\n#endif\nShutdown (shutdown.cpp)\n\ncpp\nCopy\nEdit\n#ifdef ENABLE_GRPC\nif (g_grpcServer) {\n    g_grpcServer->Shutdown();\n}\n#endif\n6. Code Vulnerabilities & Security Considerations\nExpanding Bitcoin’s API surface with gRPC/dRPC can open new attack vectors. This is especially relevant since Mintscan and interchain.io only see Bitcoin through a limited HTTP “API,” lacking a formal, secured RPC approach.\n\nProviderRpcError Leaks\n\nPotentially exposing internal stack traces or method data (interface ProviderRpcError { ... }) can reveal node internals.\nMitigation: Sanitize error messages and avoid sending debug info in production.\nUnauthenticated gRPC Endpoints\n\nIf gRPC runs on an open port without TLS or token-based auth, attackers might invoke critical node methods.\nMitigation: Use TLS certificates, IP allowlists, or replicate JSON-RPC’s cookie-based approach.\nStreaming Overflows\n\ngRPC streams can exceed normal message sizes, risking DoS or memory exhaustion.\nMitigation: Enforce maximum message size; monitor streaming traffic.\nConcurrency & Race Conditions\n\ngRPC typically handles multiple requests in parallel. If wallet or UTXO data isn’t thread-safe, you risk race conditions.\nMitigation: Add concurrency controls, locks, or thread-safe data structures.\nReplay/Signature Attacks (for dRPC)\n\nA dRPC system might allow cross-chain transactions or custom signing. Without robust replay protection, signatures can be reused.\nMitigation: Use nonces/timestamps, domain separation, and strict validation.\n7. Proposed Solutions & Best Practices\nWrapper Approach (Short-Term)\n\nA standalone “bridge” service that proxies between the existing JSON-RPC and gRPC/dRPC.\nPros: Quick to prototype, no changes to Bitcoin Core required.\nCons: Additional maintenance overhead; potential single point of failure.\nNative Integration (Long-Term)\n\nIntegrate gRPC/dRPC directly within bitcoind.\nPros: Single source of truth, minimal overhead.\nCons: Requires consensus from Bitcoin Core devs (notoriously conservative), adds complexity.\nSecurity Best Practices\n\nAuthentication: TLS, tokens, IP filtering.\nGranular Permissions: Restrict sensitive wallet commands.\nError Sanitization: Strip stack traces in production.\nIncremental Rollout: Thorough testing on testnet/regtest, security audits, then mainnet.\n8. Potential Hurdles\nConservative Bitcoin Community: The project’s maintainers may be hesitant to include a new interface like gRPC/dRPC.\nMaintenance Overhead: A fork must be continuously updated to sync with upstream security patches.\nAdoption & Ecosystem: Exchanges, wallets, and node operators would need to adopt the new interface for it to become widely used.\nCosmos SDK Conflicts: Cosmos’s SDK team, along with devs like Julien, have historically introduced obstacles or bugs that limit certain bridging or cross-chain proposals. This tension may hinder cross-chain synergy if not addressed collaboratively.\n9. Conclusion\nBy adding a native gRPC/dRPC interface to Bitcoin, we modernize the network’s developer experience and reduce vulnerabilities introduced by ad-hoc HTTP APIs on platforms like Mintscan and interchain.io. While other factors (e.g., political, economic) drive Bitcoin’s price, technological confidence plays a critical role—continuing to rely on inconsistent integrations can undermine market trust, contributing to downward price trends.\n\nA short-term wrapper can confirm feasibility, but a carefully reviewed, optional build flag for native gRPC/dRPC might be the long-term path if it gains acceptance in the Bitcoin ecosystem. Collaboration with or awareness of the Cosmos SDK team’s (and developers like Julien’s) stance is also crucial, as friction there can reverberate across multiple chains and hamper stable cross-chain functionality.\n\ndRPC gRPC Hooking Alongside the API That Bitcoin Uses\n\n### Is your feature related to a problem, if so please describe it.\n\nyes, RPC and AAPI vulnerability hacking in the millions because there is no gRPC.\n\n### Describe the solution you'd like\n\nBelow is a concise, solution-focused summary of the proposal, describing the ideal approach to implementing a native gRPC/dRPC interface in a Bitcoin Core fork. It highlights the most critical steps, benefits, and security considerations:\n\nSolution Overview\nFork Bitcoin Core & Introduce gRPC/dRPC\n\nCreate a specialized branch (e.g., feature/grpc-integration) in the Bitcoin Core repository.\nAdd gRPC/dRPC functionality as optional via a build flag (--enable-grpc or similar).\nMaintain the existing JSON-RPC interface for backward compatibility, so developers can choose between the old and new interfaces.\nFile & Code Structure\n\nAdd a src/grpc/ directory containing:\ngRPC.h / gRPC.cpp for core gRPC server classes and methods.\ngRPC.c if lower-level or C-based bridging code is needed.\nDefine .proto files (e.g., bitcoin_service.proto) in a proto/ folder, describing request/response structures (e.g., GetBlockHeight, GetBalance).\nInitialization & Compilation\n\nExtend Bitcoin Core’s build system (Autotools/CMake) to detect and link against gRPC and protobuf libraries.\nWrap all new gRPC/dRPC code with #ifdef ENABLE_GRPC guards to ensure the core remains minimal if the feature is disabled.\nModify init.cpp and shutdown.cpp to start and stop the gRPC/dRPC server (e.g., listening on 0.0.0.0:50051).\nCore Functionality\n\nBitcoinServiceImpl: Implement necessary Bitcoin RPC calls in gRPC form, such as:\nGetBlockHeight() to retrieve chain height,\nGetBalance() or more advanced features for multi-chain queries and wallet management.\nEnsure each gRPC handler carefully validates user inputs (to prevent injection or tampering).\nSecurity & Best Practices\n\nAuthentication: Support TLS for secure connections; use token/cookie-based auth mirroring the existing JSON-RPC approach.\nError Handling: Sanitize all error messages (avoid leaking stack traces, method details, or sensitive data).\nConcurrency Controls: gRPC is multi-threaded by default. Add locks around wallet or UTXO data to prevent race conditions.\nReplay Protection (for dRPC): If integrating signing/cross-chain bridging, enforce nonces and domain checks.\nIncremental Rollout: Test thoroughly on regtest or testnet environments before any mainnet release.\nMulti-Chain & Ecosystem Alignment\n\nIntegrate with Bitcore via Node.js “native addons,” allowing JavaScript/TypeScript apps to call the new gRPC services seamlessly.\nProvide optional JSON bridging for developers already reliant on JSON-formatted inputs/outputs.\nCoordinate with cross-chain platforms (e.g., Mintscan, interchain.io) to standardize calls, reduce custom bridging hacks, and bolster security across the ecosystem.\nAddressing Bitcoin’s Price & Cosmos SDK Friction\n\nBy demonstrably improving Bitcoin’s developer experience and cross-chain readiness, user confidence may rise—alleviating some negative market sentiment and reinforcing Bitcoin’s position in multi-chain solutions.\nCollaboration or at least dialogue with the Cosmos SDK team—especially regarding repeated issues or “blocking” behaviors—will help ensure stable, robust interoperability across ecosystems.\nWhat This Solution Achieves\nModernizes Bitcoin’s Developer API: gRPC or dRPC can provide streaming, structured messaging, and higher throughput compared to JSON-RPC.\nStrengthens Cross-Chain Reliability: A clear, well-secured gRPC/dRPC interface prevents ad-hoc or insecure bridging, reducing vulnerabilities.\nRetains Bitcoin’s Core Ethos: Making it an optional build feature respects Bitcoin’s minimal, consensus-driven philosophy while allowing progressive adoption.\nAddresses Ecosystem Tensions: Transparent, standardized interfaces reduce friction with Cosmos-based chains, minimize duplication, and build trust—potentially improving Bitcoin’s market perception.\nThis solution’s end goal: a smoother, more secure interaction model for Bitcoin, delivering improved multi-chain support without compromising the stability and consensus processes that the Bitcoin community holds dear.\n\n### Describe any alternatives you've considered\n\nBNB bridging is still vulnerable as a bridge because of the lack of gRPC hooking within the API\n\nBelow is a brief overview of alternative approaches considered (beyond forking Bitcoin Core to natively integrate gRPC/dRPC). Each has distinct pros and cons regarding security, performance, and maintainability.\n\n1. External “Bridge” or Proxy Service\nWhat It Entails\n\nDevelop a standalone daemon (or microservice) that runs alongside bitcoind. This service communicates with Bitcoin Core over the existing JSON-RPC interface, then exposes a gRPC/dRPC endpoint externally.\nPros\n\nNo Upstream Changes: Avoids modifying Bitcoin Core directly, so there’s no need for a dedicated fork or consensus from Bitcoin Core maintainers.\nQuick Prototyping: Faster to build and iterate upon since you’re simply layering a new service over the existing JSON-RPC.\nCons\n\nMaintenance Overhead: Yet another moving piece to install, update, and secure—potentially duplicating logic.\nPotential Desynchronization: Must keep the external proxy’s code and endpoint definitions in sync with any changes to Bitcoin Core JSON-RPC.\nPerformance Bottleneck: Additional network hops (gRPC/dRPC → Bridge → JSON-RPC → bitcoind) might reduce efficiency.\n2. Retrofitting btcd or Other Bitcoin Implementations\nWhat It Entails\n\nInstead of modifying “Bitcoin Core” itself, implement gRPC/dRPC in alternative full-node implementations such as btcd (written in Go) or bcoin (JavaScript-based). These projects have different architectures and may be more open to additional services.\nPros\n\nCommunity-Friendlier: Smaller dev communities can be more receptive to changes.\nRapid Iteration: Generally, alt-implementations move faster than Bitcoin Core in adding features.\nCons\n\nLess Adoption: Bitcoin Core remains the de facto standard client; many exchanges, wallet providers, and node operators only trust or support “Core.”\nFragmentation: Splitting development efforts across multiple Bitcoin implementations can create inconsistencies and compatibility challenges.\n3. Relying on Cosmos or Bitcore to Solve It\nWhat It Entails\n\nWaiting for Cosmos SDK or Bitcore teams to develop bridging modules or wrappers that handle Bitcoin’s JSON-RPC internally and unify it under a new or existing gRPC/dRPC interface.\nPros\n\nNo Direct Bitcoin Changes: Offloads development and maintenance efforts to third-party ecosystems.\nPotential Ecosystem Standards: If Cosmos and Bitcore unify around a single bridging interface, multi-chain devs might benefit from a standardized solution.\nCons\n\nDependency on External Roadmaps: Cosmos/Bitcore maintainers may have other priorities or be blocked by internal disagreements (e.g., issues caused by “Julien” in Cosmos).\nUnpredictable Timelines: No guarantee if or when they’ll deliver a robust, secure bridging solution.\nLimited Control: You’re reliant on external teams for critical security and feature decisions, which can hamper timely fixes or customizations.\n4. Staying With JSON-RPC Only\nWhat It Entails\n\nContinue using the existing JSON-RPC interface for all Bitcoin operations, possibly augmenting with improved documentation or partial bridging solutions.\nPros\n\nNo Changes Needed: Zero modification to Bitcoin Core or external dependencies.\nWidely Understood: JSON-RPC has been in place for years, so tooling and documentation already exist.\nCons\n\nNo Streaming: Lacks the real-time streaming or efficient chunked data transfers that gRPC can offer.\nLess Interoperable: Multi-chain solutions often use gRPC/dRPC, making Bitcoin the “odd one out” and requiring special-case handling.\nPotential Security Gaps: If bridging scripts remain ad hoc, they may not follow best security practices or might inadvertently leak sensitive data.\n5. Using REST Endpoints for Partial Functionality\nWhat It Entails\n\nExposing more advanced REST endpoints in Bitcoin Core (similar to the “REST interface” that already exists for some data), but not adopting full gRPC/dRPC.\nPros\n\nMinimal Code Changes: Expanding the existing REST capabilities requires less structural alteration than a wholly new gRPC server.\nFamiliar to Web Developers: REST is widely used, so devs might find it straightforward.\nCons\n\nNo Real-Time/Streaming: REST generally lacks native streaming and requires multiple polling requests for updates.\nStill Not gRPC: Cross-chain and advanced tooling typically leverage protocol buffers for efficient data transfer and wide language support; REST remains a less efficient fallback.\nSummary of Alternatives\nExternal Bridge: Simplifies short-term implementation but increases operational complexity.\nAlternate Implementations (btcd, bcoin, etc.): Potentially more open to feature additions, but lacks mainstream adoption.\nRely on Cosmos/Bitcore: Offloads effort but surrenders control to external roadmaps and priorities.\nStick to JSON-RPC: Zero changes but perpetuates multi-chain friction and security workarounds.\nEnhanced REST Endpoints: Minor expansion but still not a full replacement for real-time gRPC/dRPC features.\nEach approach addresses different constraints, but none offers the same performance, flexibility, and direct cross-chain compatibility as a native gRPC/dRPC fork of Bitcoin Core.\n\n\n\n### Please leave any additional context\n\nIf you have any new or follow-up questions about these alternatives—such as how to implement a specific one, how to mitigate certain security issues, or how to align the solution with existing tooling—feel free to let me know, and I’ll be happy to help.\n\n\n\n\n\n\n\n",
    "user": {
      "login": "bearycool11",
      "id": 187712293,
      "node_id": "U_kgDOCzBDJQ",
      "avatar_url": "https://avatars.githubusercontent.com/u/187712293?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bearycool11",
      "html_url": "https://github.com/bearycool11",
      "followers_url": "https://api.github.com/users/bearycool11/followers",
      "following_url": "https://api.github.com/users/bearycool11/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/bearycool11/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/bearycool11/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/bearycool11/subscriptions",
      "organizations_url": "https://api.github.com/users/bearycool11/orgs",
      "repos_url": "https://api.github.com/users/bearycool11/repos",
      "events_url": "https://api.github.com/users/bearycool11/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/bearycool11/received_events",
      "type": "User",
      "site_admin": false,
      "patch_url": null
    },
    "labels": [
      {
        "id": 64583,
        "node_id": "MDU6TGFiZWw2NDU4Mw==",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Feature",
        "name": "Feature",
        "color": "7cf575",
        "default": false
      }
    ],
    "assignees": [],
    "author_association": "NONE",
    "locked": false,
    "comments": 0,
    "created_at": "2025-03-15T12:53:06Z",
    "updated_at": "2025-03-15T12:53:06Z"
  },
  "events": [
    {
      "event": "labeled",
      "id": 16785422188,
      "node_id": "LE_lADOABII586uK2fxzwAAAAPofTds",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16785422188",
      "actor": {
        "login": "bearycool11",
        "id": 187712293,
        "node_id": "U_kgDOCzBDJQ",
        "avatar_url": "https://avatars.githubusercontent.com/u/187712293?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bearycool11",
        "html_url": "https://github.com/bearycool11",
        "followers_url": "https://api.github.com/users/bearycool11/followers",
        "following_url": "https://api.github.com/users/bearycool11/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bearycool11/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bearycool11/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bearycool11/subscriptions",
        "organizations_url": "https://api.github.com/users/bearycool11/orgs",
        "repos_url": "https://api.github.com/users/bearycool11/repos",
        "events_url": "https://api.github.com/users/bearycool11/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bearycool11/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-15T12:53:06Z",
      "label": {
        "name": "Feature",
        "color": "7cf575"
      }
    }
  ]
}